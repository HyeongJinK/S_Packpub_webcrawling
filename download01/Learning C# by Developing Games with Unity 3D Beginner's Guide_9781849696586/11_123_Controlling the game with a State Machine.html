<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec120"></a>Controlling the game with a State Machine</h2></div></div><hr /></div><p>Just like your daily routines, you follow certain patterns that are comfortable to you. Why is that? Probably because it's easy for you and they're etched in your brain; they're habits.</p><p>Whatever it is you do; <a id="id490" class="indexterm"></a>sort your laundry, build a sandwich, wash the dishes, work with Unity, you will eventually develop a routine pattern that you'll follow and like. You can equally believe that you will establish a pattern for writing scripts, too. Right now, after reading this book, you may already have some idea of how you will write and add scripts to GameObjects. Maybe you're already quite proficient at everything in Unity except for the scripting part. All you may want is to write some scripts and attach them to your GameObjects, then get back to doing the fun stuff.</p><p>How you design your scripts to control your game can be simple and neat, or if you're not careful, it could turn into a spaghetti nightmare that will make you pull out your hair. Just haphazardly writing scripts will not make you happy, especially if you need to make changes in your game flow at a later time.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec173"></a>Using a State Machine is a design pattern choice</h3></div></div></div><p>As you discovered, each active State allows you to control what Unity does and what it displays.</p><p>It organized our code<a id="id491" class="indexterm"></a> making it simple, neat, and easy to follow. I happen to like it. You may have decided that you don't like the idea of a State Machine after seeing the version in this book. Every programmer develops their own routine for coding. The point is, you will decide what's easiest for you and establish a pattern that's comfortable.</p><p>Besides showing you why I like State Machines, I also exposed you to writing regular C# classes. I also expanded a little into using a C# interface as well. A C# interface could be used easily with Unity Component classes as well. I just happened to need this C# feature for the State Machine classes.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec174"></a>Using the State Machine at the GameObject level</h3></div></div></div><p>Our State Machine <a id="id492" class="indexterm"></a>was used to control the whole game. You could just as easily use this State Machine design pattern at the GameObject level as well.</p><p>Our game State Machine used the <code class="literal">StateManager</code> object. This was a Component attached to the empty <span class="strong"><strong>GameManager</strong></span> in the <span class="strong"><strong>Scenes</strong></span> panel. Its primary job was to know which State was active during the game.</p><p>For a visible GameObject such as an enemy, you could control its allowed actions for various conditions. You would basically name the attached Component script something like <code class="literal">EnemyStateManager</code>. The following graphic shows a possible enemy State Machine:</p><div class="mediaobject"><img src="/graphics/9781849696586/graphics/6586OT_11_01.jpg" /></div><p>An alternate to using this type of State Machine is that you could code a GameObject State Machine using a combination of a C# enumeration and a switch statement.</p><p>That's the neat <a id="id493" class="indexterm"></a>thing about programming. There are countless way to write code to get the desired result and behavior.</p><p>I personally prefer to have many very small class files that do one task rather than having one huge class file that does many things by using endless lines of <code class="literal">if</code>-<code class="literal">else</code> statements or long switch statements. You will eventually determine your preferred way of doing things.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec175"></a>Pulling all the little C# pieces together</h3></div></div></div><p>It's one thing to study a bunch of tutorials about C# to learn the programming jargon and syntax. That's actually the <a id="id494" class="indexterm"></a>easy part. The tough part for beginners is to understand how to bring it all together into a project.</p><p>I personally like using the State Machine because it doubles as an outline or mind map for a Unity project. Then it's just a matter of creating the class files corresponding to the mind map, and coding the behavior that each class will perform.</p><p>This is especially helpful for the beginner programmer. You've learned many things about C# in specific little chunks, such as variables, methods, <code class="literal">if</code> statements, <code class="literal">for</code> loops, and lists. Trying to combine all these little chunks of new knowledge to create a game can seem like a mountain has to be climbed. Separating code into many little class files makes each class easier to deal with, as opposed to having a class file that has long pages and does everything.</p><p>The only way to get good at programming is to actually write code. The usual advice to beginner programmers is to practice, practice, and practice by doing small projects. That advice is good, but let's be realistic. You probably already have a Unity project started that just needs some scripts written. Do you really feel like going off on some tangent to create some little <a id="id495" class="indexterm"></a>learning projects that don't interest you? Will you really be able to concentrate on learning as you practice coding when all you can think about is your game project?</p><p>By separating your code into smaller, dedicated classes, you essentially have your little project to practice on. Plus you'll feel so much better having completed something you actually needed.</p></div></div>