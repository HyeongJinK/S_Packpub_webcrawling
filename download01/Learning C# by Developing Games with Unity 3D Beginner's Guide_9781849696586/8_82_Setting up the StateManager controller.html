<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec82"></a>Setting up the StateManager controller</h2></div></div><hr /></div><p>Now, look at line<a id="id282" class="indexterm"></a> 6 of the <code class="literal">StateManager</code> class in the following screenshot. We have a big problem right off the bat:</p><div class="mediaobject"><img src="/graphics/9781849696586/graphics/6586OT_08_02.jpg" /></div><p>The <a id="id283" class="indexterm"></a>
<code class="literal">activeState</code> variable needs to be able to store all of the State types. Right now it can only store a reference to a <code class="literal">BeginState</code> type of object. This looks like a huge problem! What about the classes <code class="literal">PlayState</code>, <code class="literal">WonState</code>, and <code class="literal">LostState</code>? What if we had 50 different States that needed to be referenced in <code class="literal">activeState</code>?</p><p>The following diagram is our dilemma:</p><div class="mediaobject"><img src="/graphics/9781849696586/graphics/6586OT_08_03.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec116"></a>Studying an example of inheritance</h3></div></div></div><p>Let's look at this issue using objects we all use all the time.</p><p>How about a Potato?<a id="id284" class="indexterm"></a> Let's also imagine we have a Potato bag. Now to connect these real objects into the scripting world, the following is a simple declared variable:</p><div class="informalexample"><pre class="programlisting">public Potato bag;</pre></div><p>So we have a variable named <code class="literal">bag</code>. The type of object it can store is a <code class="literal">Potato</code>. Saying this in another way: <span class="emphasis"><em>I have a Potato bag, and the only thing I can put in it is a potato</em></span>.</p><p>The issue is<a id="id285" class="indexterm"></a> shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781849696586/graphics/6586OT_08_04.jpg" /></div><p>We're not allowed to put a Steak, a Lettuce, or a Donut object into a Potato bag.</p><p>This is exactly the same issue we have with our <code class="literal">activeState</code> variable that is declared to only store one type of object, a <code class="literal">BeginState</code> object. We can put a <code class="literal">BeginState</code> object in <code class="literal">activeState</code>, but not a <code class="literal">PlayState</code>, a <code class="literal">WonState</code>, or a <code class="literal">LostState</code> object.</p><p>So what do we do now?</p><p>Let's get back to the Potato example. Instead of using a very specific Potato bag, how about making<a id="id286" class="indexterm"></a> the bag a bit more general, like a Food bag? Can we put a Potato in a Food bag? Is a Potato a Food? Well, we eat it, so it is a food. How about a Steak? Is that a food? Sure it is.</p><div class="mediaobject"><img src="/graphics/9781849696586/graphics/6586OT_08_05.jpg" /></div><p>Look at each class declaration right below each Food object. Each class inherits properties from the <code class="literal">Food</code> class. Now that we're also classifying each object in the more general class of <code class="literal">Food</code>, we can now declare that the variable <code class="literal">bag</code> can hold a type of <code class="literal">Food</code>.</p><p>That's great. So, we can do something similar with our classes as well, such as create a more general <code class="literal">StateBase</code> class for the State Machine, and then modify each State class to inherit from <code class="literal">StateBase</code>, and the problem is solved. Yes, we could do that and make the State Machine <a id="id287" class="indexterm"></a>work. However, inheritance does have some limitations in a State Machine and they are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If we use inheritance, every method that's inherited will be identical, which is not what we want. The State methods need to have a code block specific to its needs.</p></li><li style="list-style-type: disc"><p>Using an inherited method is optional which is not what need what. We want to guarantee that the methods will be used.</p></li><li style="list-style-type: disc"><p>If we chose not to use an inherited method, then why bother creating the class in the first place?</p></li><li style="list-style-type: disc"><p>Also, if we created a State system using inheritance, and later wished we could inherit from more than one class, we're out of luck.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>A C# class can only inherit from one class.</p></div></li></ul></div><p>The question is what to do now?</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec117"></a>Enter the IStateBase interface  again</h3></div></div></div><p>We don't have<a id="id288" class="indexterm"></a> to create another class for the State classes to inherit and get the State Machine to work.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note48"></a>Note</h3><p>An interface behaves just like inheritance, plus a class can implement more than one interface.</p></div><p>Each of our <a id="id289" class="indexterm"></a>States is already implementing the <code class="literal">IStateBase</code> interface to guarantee the methods are included. Now, since <code class="literal">IStateBase</code> acts like it's being inherited, it means each of our States can be treated as if they're an <code class="literal">IStateBase</code> type of object.</p><p>What we'll have after we modify <code class="literal">StateManager</code> is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781849696586/graphics/6586OT_08_06.jpg" /></div><p>The <code class="literal">IStateBase</code> interface<a id="id290" class="indexterm"></a> is providing a<a id="id291" class="indexterm"></a> double guarantee that:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The State objects will have the required methods that <code class="literal">StateManager</code> needs to access</p></li><li style="list-style-type: disc"><p>The <code class="literal">activeState</code> variable, of type <code class="literal">IStateBase</code>, requires all States to implement <code class="literal">IStateBase</code>
</p></li></ul></div></div></div>