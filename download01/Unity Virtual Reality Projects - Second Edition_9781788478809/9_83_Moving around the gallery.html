<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec83"></a>Moving around the gallery</h2></div></div><hr /></div><p>We've done so much, and yet have not discussed moving about the gallery level. In <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Locomotion and Comfort</em></span>, we examined <span>various</span><a id="id325317274" class="indexterm"></a> ways of implementing locomotion and teleportation. Let's now consider setting up specific teleportation spawn points that provide an optimal viewing pose for each artwork picture in the gallery. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec127"></a>Teleporting between pictures</h3></div></div></div><p>I suppose a good viewing position is <span>about</span><a id="id325317302" class="indexterm"></a> one meter back from the picture. We can add a ViewPose object at that location, within the ArtworkRig. We'll place its origin on the floor. Let's add that now:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select a <strong class="userinput"><code>ArtworkRig</code></strong> in <strong class="userinput"><code>Hierarchy</code></strong></li><li>Create a child <strong class="userinput"><code>Empty</code></strong> game object, name it <code class="literal">ViewPose</code></li><li><strong class="userinput"><code>Reset</code></strong> the ViewPose transform</li><li>Set its <strong class="userinput"><code>Position</code></strong> to (<code class="literal">0</code>, <code class="literal">-1.4</code>, <code class="literal">-1.5</code>)</li></ol></div><p>In <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Locomotion and Comfort</em></span>, we examined various ways of implementing locomotion and teleportation, including our own home-grown scripts as well as higher-level toolkits. Here, we'll use teleportation toolkits for SteamVR and Daydream. For a more general introduction to these toolkits, or alternative solutions, please refer back to that chapter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec7"></a>Teleporting with SteamVR Interaction System</h4></div></div></div><p>To use the SteamVR Interaction System, we start <span>with</span><a id="id325552055" class="indexterm"></a> their Player prefab and add the components we want to use:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Locate the <strong class="userinput"><code>Player</code></strong> prefab in <code class="literal">SteamVR/InteractionSystem/Core/Prefabs</code></li><li>Drag it as a child of <code class="literal">MeMyselfEye</code> in your scene <strong class="userinput"><code>Hierarchy</code></strong></li><li>Delete or disable the <code class="literal">[CameraRig]</code> object</li><li>Drag a copy of <strong class="userinput"><code>Teleporting</code></strong> prefab from Project <code class="literal">Assets/SteamVR/InteractionSystem/Teleport/Prefabs</code> as a child of MeMyselfEye (this controller can actually go anywhere in the scene)</li><li>Select the <strong class="userinput"><code>Player</code></strong> in <strong class="userinput"><code>Hierarchy</code></strong>, and drag its parent <code class="literal">MeMyselfEye</code> onto its <strong class="userinput"><code>Tracking Origin Transform</code></strong> slot</li></ol></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Select the <strong class="userinput"><code>ViewPose</code></strong> object in the <strong class="userinput"><code>ArtworkRig</code></strong> </li><li>Drag a copy of the <strong class="userinput"><code>TeleportPoint</code></strong> prefab from Project <code class="literal">Assets/SteamVR/InteractionSystem/Teleport/Prefabs</code> into the Hierarchy as a child of ViewPose</li><li>Select the ArtworkRig and <strong class="userinput"><code>Apply</code></strong> to save the prefab changes</li></ol></div><p>That's it! Press <strong class="userinput"><code>Play</code></strong>. The teleport points do not show until you press the button on your controller, then they glow, a dashed laser arc lets you choose one, and you go there. Here is a screenshot of the Scene view while the teleport points are activated:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/7125b885-ef13-47dd-8672-5062425f82bd.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec8"></a>Teleporting with Daydream Elements</h4></div></div></div><p>The Daydream Elements toolkit is <span>more</span><a id="id325553090" class="indexterm"></a> granular so it takes a little more to get this working. By default, the TeleportController lets you teleport to any horizontal surface on the scene (provided it has a collider). To limit it to our teleport stations we'll restrict the search to a specific layer, named <code class="literal">Teleport</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In an ArtworkRig in Hierarchy, select its <strong class="userinput"><code>ViewPose</code></strong> object and create a child cylinder (<strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>3D Object</code></strong> | <strong class="userinput"><code>Cylinder</code></strong>) and name it <code class="literal">TeleportPod</code>.</li><li>Set its <strong class="userinput"><code>Scale</code></strong> to (<code class="literal">0.5</code>, <code class="literal">0.5</code>, <code class="literal">0.01</code>). You may choose to decorate its material, for example, with transparency.</li><li>Put it on <strong class="userinput"><code>Layer</code></strong><code class="literal">"Teleport"</code> (If there is no layer named Teleport, from the <strong class="userinput"><code>Layers</code></strong> select list choose <strong class="userinput"><code>Add Layer...</code></strong> first).</li><li>Select the parent <strong class="userinput"><code>ArtworkRig</code></strong> and <strong class="userinput"><code>Apply</code></strong> to save the prefab changes.</li></ol></div><p>Now, we add the Daydream Elements teleport controller:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Drag the <strong class="userinput"><code>TeleportController</code></strong> prefab into your <strong class="userinput"><code>Hierarchy</code></strong> as child of <strong class="userinput"><code>Player</code></strong> (for us, <code class="literal">MeMyselfEye / GVRCameraRig / Player</code>)</li><li>Reset its <strong class="userinput"><code>Transform</code></strong>, if necessary</li><li>Drag the <code class="literal">MeMyselfEye</code> object onto the <code class="literal">TeleportController</code> component's <strong class="userinput"><code>Player</code></strong> transform slot</li><li>Drag <strong class="userinput"><code>GvrControllerPointer</code></strong> (or whichever controller game object you're using) onto the <strong class="userinput"><code>Controller</code></strong> transform slot</li><li>On the TeleportController's <strong class="userinput"><code>Valid Teleport Layers</code></strong>, select <strong class="userinput"><code>Teleport</code></strong> (so both <strong class="userinput"><code>Default, Teleport</code></strong> are selected)</li><li>On <strong class="userinput"><code>Raycast Mask</code></strong>, we want only Teleport, so select <strong class="userinput"><code>Nothing</code></strong> (to deselect all), then select <strong class="userinput"><code>Teleport</code></strong>. The layer settings are shown in the screen capture here:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788478809/graphics/6118a986-466a-4aaa-827b-d83e5f5d2327.png" /></div><p></p><p>Press Play. When the controller pointer's arc touches a teleport pod, it will glow highlight. If you click, you will be teleported to that spot.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec128"></a>Room-scale considerations</h3></div></div></div><p>The gallery level layout we have designed <span>works</span><a id="id325552291" class="indexterm"></a> best in seated, standing, or non-positionally tracked VR. Our use of the zig-zag partitions, for example, is not a good idea in room scale VR unless you take care to not allow the player's play space (chaperone boundaries) to cross these walls. This can be done, but you would need to make the overall space larger, perhaps adaptive to the actual play space size, and add conditions to the teleportation feature that we implement later in the chapter, complicating our examples. See <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Locomotion and Comfort</em></span> for more about room-scale considerations.</p><p>The following image is a depiction of an initial position for MeMyselfEye for a room scale OpenVR camera rig, showing the guardian boundaries fit neatly within the gallery viewing space for the first ArtworkRig. It may not fit so easily at the other viewing situations, so you'd need to make adjustments to discourage the player from walking through walls (or through Ethan!). Also, whereas this is the default length and width, the player's actual space will vary to their configuration requirements. To fully accommodate these possibilities, it may be necessary to go to a procedurally generated level layout, where the position and scale of the walls are determined at runtime based on the player settings.</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/cf8b6379-625f-4c0c-a454-0692196821c5.png" /></div><p></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec129"></a>Animating a ride-through</h3></div></div></div><p>If you can be certain the player will be <span>seated</span><a id="id325552327" class="indexterm"></a> or at least standing in one place, they might enjoy a ride-through guided tour of the gallery.</p><p>In conventional games, first-person animation is often used for a cut-scene, that is, a canned fly-through animation as a transition from one level to another. In VR, it's somewhat different. Walkthroughs can really be the VR experience itself. Head tracking is still active. So, it's not simply a prerecorded video. You can look around and experience it, and it is more like an amusement park ride. This is often called an on-the-rails VR experience.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip92"></a>Note</h3><p>Be cautious using ride-through animations in your VR apps. It can cause motion sickness. If you do, give your players as much control as possible. For example, we're animating the <code class="literal">MeMyselfEye</code> rig, allowing users to continue to look around. Placing the user in a cockpit or vehicle with stationary surfaces in the foreground can also reduce the tendency for sickness. On the other hand, if you're a thrill seeker, techniques similar to those here can be used for making roller-coaster rides on a track that moves in three dimensions!</p></div><p>In this topic, we are scripting the animations ourselves. In a later chapter, we will dive more deeply into other Unity animation and cinematic tools. We create a <code class="literal">RidethroughController</code> that animates the first-person character (<code class="literal">MeMyselfEye</code>) <strong class="userinput"><code>Transform</code></strong> position, and rotation over time. It works by defining the key-frame transforms, using the Unity <code class="literal">AnimationCurve</code> class (<a class="ulink" href="https://docs.unity3d.com/ScriptReference/AnimationCurve.html" target="_blank">https://docs.unity3d.com/ScriptReference/AnimationCurve.html</a>). As the name suggests, for key-frame animation, we define the player's location at specific key times in the ride. The in-between frames are calculated automatically. </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>At the root of Hierarchy, create a new <strong class="userinput"><code>Empty</code></strong> game object and name it <code class="literal">RidethroughController</code></li><li>Add a new C# script component and name it <code class="literal">RidethroughController</code></li><li>Open the script for editing </li></ol></div><p>First, we'll define some variables we will need:</p><pre class="programlisting"> public Transform playerRoot;
 public GameObject artWorks;
 public float startDelay = 3f;
 public float transitionTime = 5f;

 private AnimationCurve xCurve, zCurve, rCurve;</pre><p><code class="literal">playerRoot</code> is the player transform we will animate (<code class="literal">MeMyselfEye</code>). <code class="literal">artWorks</code> is the container of the <strong class="userinput"><code>ArtworkRigs</code></strong>. We've included an option to specify an initial delay and the transition time between pictures. The setup function will generate three curves, for position (<span class="emphasis"><em>x </em></span>and <span class="emphasis"><em>z</em></span>) and rotation (about the <span class="emphasis"><em>y </em></span>axis).  </p><p>Next, we write a <code class="literal">SetupCurves</code> function that <span>generates</span><a id="id325552524" class="indexterm"></a> the animation curves, using each of <strong class="userinput"><code>ArtworkRig</code></strong>'s <strong class="userinput"><code>ViewPose</code></strong> as nodes in the curve. We do this concurrently for the <span class="emphasis"><em>x</em></span>, z, and rotation curves as follows:</p><pre class="programlisting">    private void SetupCurves()
    {
        int count = artWorks.transform.childCount + 1;
        Keyframe[] xKeys = new Keyframe[count];
        Keyframe[] zKeys = new Keyframe[count];
        Keyframe[] rKeys = new Keyframe[count];

        int i = 0;
        float time = startDelay;
        xKeys[0] = new Keyframe(time, playerRoot.position.x);
        zKeys[0] = new Keyframe(time, playerRoot.position.z);
        rKeys[0] = new Keyframe(time, playerRoot.rotation.y);

        foreach (Transform artwork in artWorks.transform)
        {
            i++;
            time += transitionTime;
            Transform pose = artwork.Find("ViewPose");
            xKeys[i] = new Keyframe(time, pose.position.x);
            zKeys[i] = new Keyframe(time, pose.position.z);
            rKeys[i] = new Keyframe(time, pose.rotation.y);
        }
        xCurve = new AnimationCurve(xKeys);
        zCurve = new AnimationCurve(zKeys);
        rCurve = new AnimationCurve(rKeys);
    }</pre><p>We will define the <code class="literal">RidethroughController</code> to start animating when the game object is enabled:</p><pre class="programlisting">    void OnEnable()
    {
        SetupCurves();
    }</pre><p>On each Update, we evaluate the X and Z curves to set the player's current position. And, we evaluate the rotation curve to set the player's current rotation. We use the native <code class="literal">Quaternion</code> representation of rotations since we're interpolating between two angles we do not want use Euler coordinates:</p><pre class="programlisting">    void Update()
    {
        playerRoot.position = new Vector3(
                xCurve.Evaluate(Time.time), 
                playerRoot.position.y, 
                zCurve.Evaluate(Time.time));

        Quaternion rot = playerRoot.rotation;
        rot.y = rCurve.Evaluate(Time.time);
        playerRoot.rotation = rot;

        // done?
        if (Time.time &gt;= xCurve[xCurve.length - 1].time)
            gameObject.SetActive(false);
    }</pre><p>Lastly, we check whether we've completed <span>the</span><a id="id325552568" class="indexterm"></a> animation by comparing the current time with the time of the last node in the curve. If so, we disable the game object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note93"></a>Note</h3><p>In this script, I used the <code class="literal">transform.rotation</code> Quaternion y value directly. It's usually not recommended to manipulate Quaternion's value directly, but since we're consistently changing only a single axis, it is safe. For more information on Quaternion versus Euler angles, see <a class="ulink" href="https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html" target="_blank">https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html</a>.</p></div><p>As written, if/when <span>the</span><a id="id325552116" class="indexterm"></a><strong class="userinput"><code>RidethroughController</code></strong> game object is enabled, the animation will play. You can save your scene with it enabled, and it will play when the app begins. We'll leave it up to you to modify it to be trigged by a player's option such as a <span class="emphasis"><em>Start Ride</em></span> button within the app!</p><p>Save the script and then perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>From <strong class="userinput"><code>Hierarchy</code></strong>, drag <code class="literal">MeMyselfEye</code> onto the <strong class="userinput"><code>Player Root</code></strong> slot</li><li>Drag the <code class="literal">Artworks</code> (which contains all <code class="literal">ArtworkRigs</code>) onto the <strong class="userinput"><code>Artworks</code></strong> slot</li></ol></div><p>When you <strong class="userinput"><code>Play</code></strong> the scene, you get a nice easy ride through the art gallery, with a slight pause to view each photo. That's real nice! Hopefully, you picked images that can be shown by you to all your friends and family!</p></div></div>