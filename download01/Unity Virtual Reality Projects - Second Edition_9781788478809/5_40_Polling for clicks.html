<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec44"></a>Polling for clicks</h2></div></div><hr /></div><p>The simplest way to obtain user <span>input</span><a id="id325317294" class="indexterm"></a> is just <span class="emphasis"><em>get</em></span> the current data from an input component. We've already seen this using the Input class and VR SDK. Presently, we will write our own input component that maps the Unity (or SDK) input to our own simple API in <code class="literal">MyInputController</code>. Then, we'll write a <code class="literal">BalloonController</code> that polls the input, as illustrated:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/e03a2130-fe32-41cc-8a20-d95cd09f071c.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec72"></a>Our own button interface functions</h3></div></div></div><p>You may recall that the <code class="literal">MeMyselfEye</code> player rig may <span>have</span><a id="id325577036" class="indexterm"></a> device-specific toolkit child objects for a particular VR SDK. The version for OpenVR, for example, has their<strong class="userinput"><code> [CameraRig]</code></strong>prefab. The version for Daydream has the Daydream<strong class="userinput"><code>Player</code></strong>prefab. It makes sense to add our <code class="literal">MyInputController</code> component to <code class="literal">MeMyselfEye</code>, as it may make device-specific SDK calls. In this way, should you want to maintain camera rig prefabs for a variety of platforms, and swap them in and out as you build the project for a different VR target, the API that is exposed to the rest of your application will be consistent and independent of the specific device toolkit. </p><p>Our input controller will expose two custom API Functions, <code class="literal">ButtonDown </code>and <code class="literal">ButtonUp</code>. The implementation of these functions will be hidden from the components that call them. For example, we could write it to handle <code class="literal">Fire1</code> button presses as first but later change it to use a trigger press instead, or make a version for Daydream that does not use <code class="literal">Fire1</code>. Let's update the <code class="literal">MyInputController</code> by adding the following code:</p><pre class="programlisting">public bool ButtonDown()
{
  return Input.GetButtonDown("Fire1");
}

public bool ButtonUp()
{
  return Input.GetButtonUp("Fire1");
}</pre><p>Or you can modify the preceding code to use the button interface that works for you. For example, for Daydream you might use this instead:</p><pre class="programlisting">public bool ButtonDown()
{
  return GvrControllerInput.ClickButtonDown;
}

public bool ButtonUp()
{
  return GvrControllerInput.ClickButtonUp;
}</pre><p>Now, we'll use our little <code class="literal">ButtonUp</code>/<code class="literal">ButtonDown</code> input API.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec73"></a>Creating and releasing balloons</h3></div></div></div><p>Let's now create a <code class="literal">BalloonController</code> that <span>will</span><a id="id325577488" class="indexterm"></a> be the application component that creates and controls balloons. It will reference our <code class="literal">MyInputController</code>. Follow <span>these</span><a id="id325577500" class="indexterm"></a> steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In <strong class="userinput"><code>Hierarchy</code></strong>, create an empty game object, reset its Transform, and name it <code class="literal">BalloonController</code></li><li>Create a new script on the object named <code class="literal">BalloonController</code> and open it for editing as follows:</li></ol></div><pre class="programlisting">public class BalloonController : MonoBehaviour 
{
  public GameObject meMyselfEye;

  private MyInputController inputController;

  void Start () 
  {
    inputController = meMyselfEye.GetComponent&lt;MyInputController&gt;();
  }

  void Update () 
  {
    if (inputController.ButtonDown())
    {
      NewBalloon()
    }
    else if (inputController.ButtonUp())
    {
      ReleaseBalloon();
    }
    // else while button is still pressed, grow it
 }</pre><p><span>This</span> is the skeleton of the controller. Given a reference to the <code class="literal">MeMyselfEye</code> object, the <code class="literal">Start()</code> function gets its <code class="literal">MyInputController</code> component and assigns it to the <code class="literal">inputController </code>variable.</p><p><code class="literal">Update()</code> is called each frame while your game is running. It will call <code class="literal">inputController.ButtonDown</code> or <code class="literal">ButtonUp</code> to see if the user has changed their input, and in response, either create or release a balloon. We'll write the functions next.</p><p>Note that we've also included a placeholder (as a comment) where we'll add the <code class="literal">GrowBalloon</code> function too. </p><p>Given the balloon prefab, the <code class="literal">BalloonController</code> can create new instances of it in our scene, by calling the Unity <code class="literal">Instantiate</code> function. Add the following <code class="literal">public</code> variable declaration at the top of your controller class for the balloon prefab:</p><pre class="programlisting"> public GameObject balloonPrefab;</pre><p>And add a <code class="literal">private</code> variable to hold the current instance of the balloon:</p><pre class="programlisting"> private GameObject balloon;</pre><p>Now, the <code class="literal">NewBalloon</code> function, which is called when the player presses the button, references the prefab and instantiates it as follows:</p><pre class="programlisting"> private void NewBalloon()
 {
   balloon = Instantiate(balloonPrefab);
 }</pre><p>The <code class="literal">ReleaseBalloon</code> function is called when the player releases the button. It will apply a gentle upward force on the balloon so it floats skyward. We'll define a floatStrength variable and apply it to the object's RigidBody (the Unity physics engine and RigidBodies are explained in a later chapter):</p><pre class="programlisting"> public float floatStrength = 20f;</pre><p><span>And</span>,</p><pre class="programlisting">private void ReleaseBalloon()
{
  balloon.GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.up * floatStrength);
  balloon = null;
}</pre><p>Notice that we also clear the balloon variable (setting it to null), getting it ready for the next button press.</p><p>Save the file and in Unity:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Drag the <strong class="userinput"><code>MeMyselfEye</code></strong> object from <strong class="userinput"><code>Hierarchy</code></strong> onto the BalloonController's <strong class="userinput"><code>Me Myself Eye</code></strong> slot in <strong class="userinput"><code>Inspector</code></strong></li><li>Drag the <strong class="userinput"><code>Ballon</code></strong> prefab from the Project's <code class="literal">Assets</code> folder onto the BalloonController's <strong class="userinput"><code>Balloon Prefab</code></strong> slot in <strong class="userinput"><code>Inspector</code></strong></li></ol></div><p>When you're ready, press <strong class="userinput"><code>Play</code></strong>. Inside VR, when you press the <code class="literal">Fire1</code> button (or whichever you programmed), a new balloon is instantiated. When you release it, the balloon floats upwards. In the following game window, I have pressed the button multiple times in succession, creating a series of balloons:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/71a36831-02f2-4d6f-b7ab-50d4a5eb46c5.png" /></div><p></p><p>Here is the Hierarchy of the same game state, showing the cloned balloons in the <strong class="userinput"><code>Hierarchy</code></strong> (my prefab's name is <code class="literal">Balloon-poly</code>):</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/96760143-d9f3-481e-bf97-cd8ea5562db0.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec74"></a>Inflating a balloon while pressed</h3></div></div></div><p>The next thing we want to do is <span>inflate</span><a id="id325586492" class="indexterm"></a> the balloon while you're still holding the button. We can do this by checking whether there's a current balloon instance from a button press, and modifying its scale each update by a specified grow rate. Let's define that first, to grow by 150% each second the button is held down (1.5 times):</p><pre class="programlisting">public float growRate = 1.5f;</pre><p>Now, modify the Update function with a third <code class="literal">else if</code> condition as follows:</p><pre class="programlisting">  else if (balloon != null)
  {
    GrowBalloon();
  }</pre><p>And add the <code class="literal">GrowBalloon</code> function like this:</p><pre class="programlisting"> private void GrowBalloon()
 {
   balloon.transform.localScale += balloon.transform.localScale * growRate * Time.deltaTime;
 }</pre><p>The <code class="literal">GrowBalloon</code> function will modify the balloon's local scale by a percentage of its current size. <code class="literal">growRate</code> is the rate of growth per second. So, we multiply that by the current fraction of a second in this frame (<code class="literal">Time.deltaTime</code>).</p><p>Press <strong class="userinput"><code>Play</code></strong> in Unity. When you press the controller button, you'll create a balloon, which continues to inflate until you release the button. Then the balloon floats up. Wow, that's actually pretty fun!</p><p>Next, we're going to refactor our <span>code</span><a id="id325594738" class="indexterm"></a> to use a different software pattern for getting user input, using scriptable objects.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>No one writes code without expecting to change it. Programming is a dynamic art as you rethink how to do things, as requirements grow, and problems get fixed. Sometimes, these changes are not necessarily to add a new feature or fix a bug but to make the code cleaner, easier to use, and easier to maintain. This is called <span class="strong"><strong>refactoring</strong></span>, when you change or rewrite parts of a program but do not necessarily change how the feature works from the player's perspective.</p></div></div></div>