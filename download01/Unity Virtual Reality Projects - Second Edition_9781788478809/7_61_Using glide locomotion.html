<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec63"></a>Using glide locomotion</h2></div></div><hr /></div><p>For our locomotion features <span>in</span><a id="id325317266" class="indexterm"></a> this chapter, let's take an <span class="emphasis"><em>agile</em></span> approach to development. This means (in part) that we'll start by defining our new feature, or story, with a set of requirements. Then, we'll incrementally build and test this feature, one requirement at a time, by iterating and refining our <span>work</span><a id="id325317277" class="indexterm"></a> as we go along. Experimentation is not only allowed, it's encouraged.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note74"></a>Note</h3><p><span class="strong"><strong>Agile software development</strong></span> is a broad term for methodologies that encourage small incremental and iterative development in a fashion that's easy to respond to changing and refined requirements. See the Agile Manifesto at <a class="ulink" href="http://agilemanifesto.org/" target="_blank">http://agilemanifesto.org/</a>.</p></div><p>The feature we want to implement is this: as a first-person character, when I start walking, I will move through the scene in the direction I am looking until I indicate to stop walking. Here are the requirements to achieve this feature:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Move in the direction you're looking</li><li style="list-style-type: disc">Keep your feet on the ground</li><li style="list-style-type: disc">Don't pass through solid objects</li><li style="list-style-type: disc">Don't fall off the edge of the world</li><li style="list-style-type: disc">Step over small objects and handle uneven terrain</li><li style="list-style-type: disc">Start and stop moving by clicking an input button</li></ul></div><p>This sounds reasonable.</p><p>To begin, if you have a saved version of the scene from <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Gaze-Based Control</em></span>, you can start with that. Or, build a similar simple new scene containing a ground plane, some 3D objects as obstacles, and a copy of your <code class="literal">MeMyselfEye</code> prefab.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec95"></a>Move in the direction you're looking</h3></div></div></div><p>We already have a <code class="literal">MeMyselfEye</code> object <span>containing</span><a id="id325549828" class="indexterm"></a> the camera rig. We're going to turn it into a first-person controller. Our first requirement is to move about the scene in the direction you're looking. Add a script named <code class="literal">GlideLocomotion</code>. Keeping it simple, let's start by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select the <code class="literal">MeMyselfEye</code> object in the <strong class="userinput"><code>Hierarchy</code></strong> panel</li><li>In the <strong class="userinput"><code>Inspector</code></strong> panel, select <strong class="userinput"><code>Add Component</code></strong> | <strong class="userinput"><code>New Script</code></strong> and name it <code class="literal">GlideLocomotion</code></li></ol></div><p>Then, open the script and code it, as follows:</p><pre class="programlisting">using UnityEngine; 
 
public class GlideLocomotion : MonoBehaviour 
{ 
  public float velocity = 0.4f; 
 
  void Update () 
  { 
    Vector3 moveDirection = Camera.main.transform.forward; 
    moveDirection *= velocity * Time.deltaTime; 
    transform.position += moveDirection; 
  } 
} </pre><p>The normal walking speed for humans is about 1.4 meters per second. In VR, that could make you feel sick. Let's travel a lot slower than that, at 0.4 m/s. During <code class="literal">Update()</code>, we check the current direction in which the player is looking (<code class="literal">camera.transform.forward</code>) and move the <code class="literal">MeMyselfEye</code> transform position in this direction at the current velocity.</p><p>Note the coding shortcuts for the self-modification of a variable (<code class="literal">*=</code> and <code class="literal">+=</code>). The last two lines of the preceding code could have been written out like this:</p><pre class="programlisting">moveDirection = moveDirection * velocity * Time.deltaTime; 
transform.position = transform.position  + moveDirection; </pre><p>Here, I used the <code class="literal">*=</code> and <code class="literal">+=</code> operators instead. Save the script and the scene and try it in VR.</p><p>When you look forward, you move forward. Look left, move left. Look right, move right. It works!</p><p>Look up... <span class="emphasis"><em>Whoa!! Did you expect that?! We're freakin' flying!</em></span> You can move up, down, and all around as if you're Superman or piloting a drone. Presently, <code class="literal">MeMyselfEye</code> has no mass and physics and does not respond to gravity. Nonetheless, it meets our requirement to move in the direction you're looking. So, let's continue.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec96"></a>Keep your feet on the ground</h3></div></div></div><p>The next requirement wants you to <span>keep</span><a id="id325563529" class="indexterm"></a> your feet on the ground. We know that <code class="literal">GroundPlane</code> is flat and positioned at <strong class="userinput"><code>Y</code></strong> = <code class="literal">0</code>. So, let's just add this simple constraint to the <code class="literal">GlideLocomotion</code> script, as follows:</p><pre class="programlisting">  void Update () 
  { 
    Vector3 moveDirection = Camera.main.transform.forward; 
    moveDirection *= velocity * Time.deltaTime; 
<span class="strong"><strong>    moveDirection.y = 0f;</strong></span> 
    transform.position += moveDirection; 
  } </pre><p>Save the script and try it in VR.</p><p>Not bad. Now, we can move around the <strong class="userinput"><code>Y</code></strong> = <code class="literal">0</code> plane.</p><p>On the other hand, you're like a ghost, readily passing through the cube, sphere, and the other objects.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec97"></a>Don't pass through solid objects</h3></div></div></div><p>The third requirement states <span class="emphasis"><em>don't pass through solid objects</em></span>. Here's an idea. Give it a Rigidbody component, a collider, and let the physics engine take <span>care</span><a id="id325567578" class="indexterm"></a> of it. Follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select the <code class="literal">MeMyselfEye</code> object in the <strong class="userinput"><code>Hierarchy</code></strong> panel</li><li>In the <strong class="userinput"><code>Inspector</code></strong> panel, navigate to <strong class="userinput"><code>Add Component</code></strong> | <strong class="userinput"><code>Physics</code></strong> | <strong class="userinput"><code>Rigidbody</code></strong></li><li>Then <strong class="userinput"><code>Add Component | Physics | Capsule Collider</code></strong></li><li>Set the Capsule Collider <strong class="userinput"><code>Height</code></strong> to <strong class="userinput"><code>2</code></strong></li><li>If your Character Controller's capsule collider (green mesh in the Scene window) extends through the ground plane, adjusts its <strong class="userinput"><code>Center Y</code></strong> to <code class="literal">1</code></li></ol></div><p>Try it in VR.</p><p><span class="emphasis"><em>Whoa!! What the...?</em></span> It was going fine there for a second, but as soon as you knock into the cube, you go spinning out of control in wild directions, like a spacewalk gone bad in the movie <span class="emphasis"><em>Gravity</em></span>. Well, that's a Rigidbody for you. Forces are being applied in all directions and axes. Let's add some constraints as follows.</p><p>In the <strong class="userinput"><code>Inspector</code></strong> panel's <strong class="userinput"><code>Rigidbody</code></strong> pane, check off the checkboxes for <strong class="userinput"><code>Freeze Position: Y</code></strong> and <strong class="userinput"><code>Freeze Rotation: X</code></strong> and <strong class="userinput"><code>Z</code></strong>.</p><p>Try it in VR.</p><p>Now that's pretty nice! You're able to move by looking in a direction, you're not flying (<strong class="userinput"><code>Y</code></strong> position constrained), and you don't pass through solid objects. Instead, you slide past them since only the <strong class="userinput"><code>Y</code></strong> rotation is allowed.</p><p>If your <code class="literal">KillTarget</code> script is still running (from <a class="link" href="#" linkend="ch02"><span>Chapter 2</span></a>, <span class="emphasis"><em>Content, Objects, and Scale</em></span>), you should be able to stare at Ethan until he explodes. Do it, make Ethan explode... <span class="emphasis"><em>Whoa!</em></span> We just got blown out of here by the explosion, spinning out of control in wild directions again. Maybe we're just not ready for this powerful physics engine yet. We can probably address this in the scripting, but for the time being, let's abandon the Rigidbody idea. We'll come back to it in the next chapter.</p><p>You may recall that CC includes a Capsule Collider and supports movement that is constrained by collisions. We'll try that instead, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In the <strong class="userinput"><code>Inspector</code></strong> panel, click on the <strong class="userinput"><code>Rigidbody</code></strong> pane's <span class="emphasis"><em>gear</em></span> icon and select <strong class="userinput"><code>Remove Component</code></strong></li><li>Also, remove its <strong class="userinput"><code>Capsule Collider</code></strong> component</li><li>In the <strong class="userinput"><code>Inspector</code></strong> panel, navigate to <strong class="userinput"><code>Add Component</code></strong> | <strong class="userinput"><code>Physics</code></strong> | <strong class="userinput"><code>Character Controller</code></strong></li><li>If your Character Controller's capsule collider (green mesh in the Scene window) extends through the ground plane, adjusts its <strong class="userinput"><code>Center Y</code></strong> to <code class="literal">1</code></li></ol></div><p>Modify the <code class="literal">GlideLocomotion</code> script, as follows:</p><pre class="programlisting">using UnityEngine; 
 
public class GlideLocomotion : MonoBehaviour 
{ 
  public float velocity = 0.4f; 
 
<span class="strong"><strong>  private CharacterController character;

</strong></span><span class="strong"><strong>  void Start () 
  {
</strong></span><span class="strong"><strong>    character = GetComponent&lt;CharacterController&gt;();
</strong></span><span class="strong"><strong>  }</strong></span> 
 
  void Update () 
  { 
    Vector3 moveDirection = Camera.main.transform.forward; 
    moveDirection *= velocity * Time.deltaTime; 
    moveDirection.y = 0.0f; 
<span class="strong"><strong>    character.Move(moveDirection);</strong></span> 
  } 
}</pre><p>Instead of updating <code class="literal">transform.position</code> directly, we called the built-in <code class="literal">CharacterController.Move()</code> function and let it do it for us. It knows that the characters should behave with certain constraints.</p><p>Save the script and try it in VR.</p><p>This time, when we bump into objects (a cube or sphere), we kind of go over it and then remain in the air. The <code class="literal">Move()</code> function does not apply gravity to the scene for us. We need to add that to the script, which isn't so hard (see the Unity API docs at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/CharacterController.Move.html" target="_blank"><span>http://docs.unity3d.com/ScriptReference/CharacterController.Move.html</span></a>).</p><p>However, there is a simpler way. The <code class="literal">CharacterController.SimpleMove()</code> function applies gravity to the move for us. Just replace the whole <code class="literal">Update()</code> function with the following one-liner:</p><pre class="programlisting"><span class="strong"><strong>  void Update () 
      {</strong></span><span class="strong"><strong>    character.SimpleMove(Camera.main.transform.forward * velocity);</strong></span><span class="strong"><strong>  }</strong></span></pre><p>The <code class="literal">SimpleMove()</code> function takes care of gravity and also handles <code class="literal">Time.deltaTime</code>. So, all that we need to give it is the movement direction vector. Also, since it's introducing gravity, we don't need the <strong class="userinput"><code>Y</code></strong> = <code class="literal">0</code> constraint either. Much simpler.</p><p>Save the script and try it in VR.</p><p>Awesome! I think we've met <span>all</span><a id="id325581687" class="indexterm"></a> the requirements so far. <span class="emphasis"><em>Just don't go walking off the edge...</em></span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip75"></a>Note</h3><p>The exercises in this section assume you're using VR in seated or standing mode, not room-scale. We're modifying the whole MyMyselfEye rig as we move the player. In room-scale, that's moving the play area bounds as well. Since we're attaching the collider to the MyMyselfEye position, if you physically step away from the center of the play area, the collider will not be aligned with your actual body position. Later on, we will address issues of locomotion with room-scale VR.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec98"></a>Don't fall off the edge of the world</h3></div></div></div><p>Now that we have gravity, if <span>we</span><a id="id325581709" class="indexterm"></a> walk off the edge of the ground plane, you'll fall into oblivion. Fixing this isn't a first-person character thing. Just add some railings to the scene.</p><p>Use cubes, scaling them to the desired thickness and length and moving them into position. Go ahead and do it. I won't give you the step-by-step instructions for it. For example, I used these transforms:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Scale</code></strong>: <code class="literal">0.1</code>, <code class="literal">0.1</code>, <code class="literal">10.0</code></li><li style="list-style-type: disc">Railing 1: <strong class="userinput"><code>Position</code></strong>: <code class="literal">-5</code>, <code class="literal">1</code>, <code class="literal">0</code></li><li style="list-style-type: disc">Railing 2: <strong class="userinput"><code>Position</code></strong>: <code class="literal">5</code>, <code class="literal">1</code>, <code class="literal">0</code></li><li style="list-style-type: disc">Railing 3: <strong class="userinput"><code>Position</code></strong>: <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">-5</code>; <strong class="userinput"><code>Rotation</code></strong>: <code class="literal">0</code>, <code class="literal">90</code>, <code class="literal">0</code></li><li style="list-style-type: disc">Railing 4: <strong class="userinput"><code>Position</code></strong>: <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">5</code>; <strong class="userinput"><code>Rotation</code></strong>: <code class="literal">0</code>, <code class="literal">90</code>, <code class="literal">0</code></li></ul></div><p>Try it in VR. Try to walk through the railings. Whew! This is safer.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec99"></a>Stepping over small objects and handling uneven terrain</h3></div></div></div><p>While we're at it, add a few things to <span>walk</span><a id="id325577492" class="indexterm"></a> on and over, such as a ramp and other obstacles. The result will look like this:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/5c9ef0fb-f6d3-4579-b241-628f70f8adca.png" /></div><p>Try it in VR. Walk up the ramp and step off the cube. Hey, this is fun!</p><p>The CC component is taking care of the requirement to step over small objects and handle uneven terrain. You might want to tinker with its<strong class="userinput"><code>Slope Limit</code></strong>and<strong class="userinput"><code>Step Offset</code></strong>settings.</p><p><span class="strong"><strong>Caution</strong></span>: Glide locomotion can cause motion sickness, especially for players who are susceptible. Please use it with caution in your apps. This may become especially noticeable as you glide up the ramp and then jump off the block onto the ground plane. On the other hand, some people love rollercoaster VR! Also, giving the player control of the locomotion through a mechanic as simple as a button press can go a long way in helping reduce queasiness and motion sickness, which we'll add next.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec100"></a>Starting and stopping movement</h3></div></div></div><p>The next requirement is <span class="emphasis"><em>to start and stop moving by clicking an input button</em></span>. We'll look for a button press using the logical <code class="literal">"Fire1"</code> button. If you <span>want</span><a id="id325577537" class="indexterm"></a> to use a different button, or if you're targeting a platform that does not have a mapping to <code class="literal">"Fire1"</code> please refer to <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Handy Interactables</em></span>, under the topic <span class="emphasis"><em>Basic button input</em></span>. </p><p>Modify the <code class="literal">GlideLocomotion</code> script as follows:</p><pre class="programlisting">using UnityEngine; 
 
public class GlideLocomotion : MonoBehaviour 
{ 
  public float velocity = 0.7f; 
 
  private CharacterController controller; 
<span class="strong"><strong>private bool isWalking = false;</strong></span>
 
  void Start() 
  { 
    controller = GetComponent&lt;CharacterController&gt; (); 
  } 
 
  void Update () { 
<span class="strong"><strong>    if (Input.GetButtonDown("Fire1")) 
        isWalking = true;
    else if (Input.GetButtonUp("Fire1"))
        isWalking = false;
</strong></span><span class="strong"><strong>
</strong></span><span class="strong"><strong>    if (isWalking) {
</strong></span>      controller.SimpleMove (Camera.main.transform.forward * velocity);
    }
  } 
} </pre><p>On Daydream, you may call <code class="literal">GvrControllerInput.ClickButtonDown</code> and <code class="literal">ClickButtonUp</code> instead.</p><p>By adding a Boolean <code class="literal">isWalking</code> flag, we can switch the forward movement on and off, which can be signaled by a key press.</p></div></div>