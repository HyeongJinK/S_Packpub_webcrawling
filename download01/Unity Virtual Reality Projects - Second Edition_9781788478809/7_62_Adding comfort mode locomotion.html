<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec64"></a>Adding comfort mode locomotion</h2></div></div><hr /></div><p>We have mentioned the potential of <span>motion</span><a id="id325317294" class="indexterm"></a> sickness several times already in this chapter, and earlier in this book. In general, the more control you give the player in moving around within VR the better off she'll be and reduce the risk of feeling queasy. Offering a button to start/stop motion is one step, as we just saw. Another is what's commonly referred to as <span class="emphasis"><em>comfort mode</em></span>.</p><p>It's been discovered that using glide locomotion around curves is worse that simply going in a straight line. So, one technique for getting around in a VR scene is only allow forward motion, regardless of which direction the player is looking, and then use the thumbstick to change direction. Also, rather than allow the thumbstick to change the direction angle continuously, we limit it to fixed angle steps of 30 degrees, for example. We'll add this to our <code class="literal">GlideLocomotion</code> script as follows. </p><p>At the top of the class, add the following variables:</p><pre class="programlisting"> public float comfortAngle = 30f;
 private bool hasRotated = true;</pre><p>Then in <code class="literal">Update()</code>, add the following statements:</p><pre class="programlisting">  void Update()
  {
    if (Input.GetButtonDown("Fire1"))
      isWalking = true;
    else if (Input.GetButtonUp("Fire1"))
      isWalking = false;

    if (isWalking)
<span class="strong"><strong>character.SimpleMove(transform.forward * velocity);</strong></span>

    float axis = Input.GetAxis("Horizontal"); 
    if (axis &gt; 0.5f)
    {
      if (!hasRotated)
        transform.Rotate(0, comfortAngle, 0);
      hasRotated = true;
    }
    else if (axis &lt; -0.5f)
    {
      if (!hasRotated)
        transform.Rotate(0, -comfortAngle, 0);
      hasRotated = true;
    } 
    else
    {
      hasRotated = false;
    }
  }</pre><p>Now, when the <code class="literal">"Fire1"</code> button is pressed and <code class="literal">isWalking</code> is true, we move the <code class="literal">MeMyselfEye</code> forward in the direction indicated in its transform, rather than the <code class="literal">Camera</code> look directions, changing the line to <code class="literal">character.SimpleMove(transform.forward * velocity)</code>.</p><p>When the user pushes the thumbstick to the right, that is, the logical <code class="literal">"Horizontal"</code> axis is positive, we will rotate the rig clockwise by 30 degrees (<code class="literal">comfortAngle</code>). When the thumbstick is pressed left, we rotate counter-clockwise. We check for greater than 0.5 rather than exactly 1.0 so the player does not need to jam the stick all the way to the edge.</p><p>We don't want to keep rotating, again and again, each update while the joystick is pressed, so we set a flag, <code class="literal">hasRotated</code>, and then ignore the axis until it comes to rest at the zero position. Then, we'll allow the player to press it again.</p><p>The result is a comfortable navigation mechanic where one button moves you forward and another lets you change direction in large increments. </p><p>For your reference, some button mappings used in this mechanic are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">In OpenVR on HTC VIVE, <code class="literal">"Fire1"</code> is the menu button on one controller, <code class="literal">"Horizontal"</code> is touching the touchpad on the other controller. </li><li style="list-style-type: disc">In OpenVR on Oculus, <code class="literal">"Fire1"</code> is the right controller's <strong class="userinput"><code>B</code></strong> button, <code class="literal">"Horizontal"</code> is the left controller thumbstick. 
</li><li style="list-style-type: disc">On Daydream, you should modify the code to use <code class="literal">GvrControllerInput</code>. To detect horizontal clicks on the touchpad, call <code class="literal">GvrControllerInput.TouchPosCentered</code>, which returns a <code class="literal">Vector2</code>, and check <code class="literal">x</code> for values between <code class="literal">-1</code> and <code class="literal">1</code>. For example, replace the call to GetAxis with the following:</li></ul></div><pre class="programlisting">    Vector2 touchPos = GvrControllerInput.TouchPosCentered;
    float axis = touchPos.x;
    if (axis &gt; 0.5f) ...</pre><p>You're encouraged to extend the <code class="literal">ButtonTest()</code> function used in the beginning of <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Handy Interactables</em></span>, to determine which button mappings, axes, and SDK functions work best for your target VR device.</p><p>We just implemented glide locomotion, where <span>you</span><a id="id325577472" class="indexterm"></a> move forward smoothly in the direction you're looking, or with comfort mode, in the direction your body is facing, while your head can look around. Comfort mode reduces the chance of motion sickness by having you change the direction you're facing in jumps of 30-degree angles. But even that may not be comfortable enough, and some developers (and players) prefer no gliding at all, and instead let you just <span class="emphasis"><em>teleport</em></span> from one location to another.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec101"></a>Other locomotion considerations</h3></div></div></div><p>If you want to offer your players a VR ride, you can <span>define</span><a id="id325581587" class="indexterm"></a> a predefined <span class="emphasis"><em>track</em></span> to glide along, like a guided tour of a building or art gallery. Tracks can be 3D, moving you up and down too, with gravity, such as VR roller coasters, or without gravity, such as a space tour. We do not recommend this mechanic except for the most hardcore thrill seekers as it has a good chance of causing motion sickness. </p><p>Another technique for comfort <span>during</span><a id="id325581602" class="indexterm"></a> locomotion is <span class="strong"><strong>Tunneling</strong></span>. During the movement, the camera is cropped with a vignette and simple background, like a grid, is displayed in the player's peripheral vision, so the user only sees what is directly before them. Eliminating peripheral vision while moving can reduce the chance of motion sickness.</p><p>For vertical locomotion, apps have implemented a climbing mechanic, using your hands to reach, grab, and pull yourself up. Mountain climbing simulation games such as The Climb (<a class="ulink" href="http://www.theclimbgame.com/" target="_blank">http://www.theclimbgame.com/</a>) takes this idea to the next level (literally!), providing a number of different reach mechanics and grip types to grab onto.</p><p>Other apps have also tried using your hands, not for climbing, but for walking. For example, reaching and pulling like a rope, or swinging your arms like a runner, or even a circular pulling motion like you're operating a wheelchair.</p><p>Of course, there are hardware devices, such as that implement locomotion mechanisms using your feet to walk and run. Examples include:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">VR treadmills <span>such</span><a id="id325581659" class="indexterm"></a> as Virtuix Omni (<a class="ulink" href="http://www.virtuix.com/" target="_blank">http://www.virtuix.com/</a>) and VR Virtualizer (<a class="ulink" href="https://www.cyberith.com/" target="_blank">https://www.cyberith.com/</a>), where you walk in place with your feet and legs to <span>walk</span><a id="id325581676" class="indexterm"></a> and run in VR.</li><li style="list-style-type: disc">Exercise <span>bikes</span><a id="id325581687" class="indexterm"></a> such as VirZoom (<a class="ulink" href="https://www.virzoom.com/" target="_blank">https://www.virzoom.com/</a>) where you can bike and even hang glide in VR.</li><li style="list-style-type: disc">Body tracking <span>sensors</span><a id="id325581702" class="indexterm"></a> can be used not just for player <span>locomotion</span><a id="id325581710" class="indexterm"></a> but also motion capture for creating character animations. Devices <span>include</span><a id="id325581719" class="indexterm"></a> Optitrack (<a class="ulink" href="http://optitrack.com/motion-capture-virtual-reality/" target="_blank">http://optitrack.com/motion-capture-virtual-reality/</a>), Perception Neuron (<a class="ulink" href="https://neuronmocap.com/" target="_blank">https://neuronmocap.com/</a>), ProVR (<a class="ulink" href="http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html" target="_blank">http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html</a>), and others.</li></ul></div><p>You probably need to write your app specifically for that device as there are no standards for these body tracking devices, but they're certainly a lot of fun.</p></div></div>