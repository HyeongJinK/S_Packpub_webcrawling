<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec81"></a>Managing art info data </h2></div></div><hr /></div><p>We could end here, but suppose we <span>want</span><a id="id325317266" class="indexterm"></a> to track more data than just the images for each artwork, such as artist, title, description, and so on. First, we'll consider several software design patterns to manage the data, including separate lists, data structures, and scriptable objects. Later, we'll update our ArtworkRig to display the info with each framed artwork.</p><p>The first two scenarios are for explanation only. We will actually implement the <code class="literal">ScriptableObjects</code> one last. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec121"></a>Using lists</h3></div></div></div><p>One approach could be to <span>add</span><a id="id325317299" class="indexterm"></a> more lists to the <code class="literal">PopulateArtFrames</code> script for each of the data fields. For example, if the script had the following:</p><pre class="programlisting"> public Texture[] images;
 public string[] titles;
 public string[] artists;
 public string[] descriptions;</pre><p>The <strong class="userinput"><code>Inspector</code></strong> would show the following (I limited the list to four items for brevity):</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/a6076d1f-7bf9-4ab0-8f61-f9b12d6aa70f.png" /></div><p>As you can imagine, this could get very unwieldy. To change <strong class="userinput"><code>Element 3</code></strong>, for example, you'd have to go to all the lists, which is easily prone to mistakes; things could fatally get very out of sync. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec122"></a>Using data structures</h3></div></div></div><p>A better approach could be to write a C# <code class="literal">struct</code> (or <code class="literal">class</code>) as a data structure that contains each of the fields we want and then <span>make</span><a id="id325549817" class="indexterm"></a> the list in <code class="literal">PopulateArtFrames</code> as this type. For example, the script may read as follows:</p><pre class="programlisting">[System.Serializable]
public struct ArtInfo
{
    public Texture image;
    public string title;
    public string artist;
    public string description;
}

public class PopulateArtFrames : MonoBehaviour
{
    public List&lt;ArtInfo&gt; artInfos = new List&lt;ArtInfo&gt;();</pre><p>In this example snippet, we declare a separate data structure named <code class="literal">ArtInfo</code> defining our data fields. Then, in <code class="literal">PopulateArtFrames</code> we declare it as a <code class="literal">List</code> (which must be initialized with the <code class="literal">new List&lt;ArtInfo&gt;()</code> call). In the script, we'd then reference the textures as <code class="literal">artInfos[i].image</code>. Likewise, you'd get its size using <code class="literal">artInfos.Count</code>  rather than <code class="literal">Length</code>. Also, we need to say it's <code class="literal">System.Serializable</code> so the list appears in the editor <strong class="userinput"><code>Inspector</code></strong>, as follows:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/75a8f883-ca9f-4a35-b10a-76b9d0e41de8.png" /></div><p></p><p>Now we have a list of <code class="literal">ArtInfo</code> elements that we can fill in, and the data for each element is grouped together.</p><p>Another benefit of <span>this</span><a id="id325552472" class="indexterm"></a> structure is it <span>could</span><a id="id325552481" class="indexterm"></a> be more easily populated <span>from</span><a id="id325552489" class="indexterm"></a> an external data source, such as cloud-based JSON data or a CSV (comma separated values) data file.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note88"></a>Note</h3><p>If you are interested in loading data from a database there are a number of approaches, outside the scope of this chapter. But briefly, if you do find a source of CSV data, this handy CSV parser (<a class="ulink" href="https://github.com/frozax/fgCSVReader" target="_blank">https://github.com/frozax/fgCSVReader</a>)  is basic but gets the job done. If you are in need of a JSON parser, from a web-based REST API for example, consider the JSON .NET For Unity package (<a class="ulink" href="https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347" target="_blank">https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347</a>) or another similar one.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec123"></a>Using scriptable objects</h3></div></div></div><p>In the previous examples, the art info <span>data</span><a id="id325555187" class="indexterm"></a> is maintained on a <code class="literal">GameObject</code> in the Scene Hierarchy. As a software design, this is not really where the data belongs. Data objects are not game objects and should be managed separately.</p><p>In the Scene hierarchy, we define the level design and game behaviors. ArtworkRigs have spatial coordinates (Transform) and renderers (and other potentially necessary runtime components such as colliders and RigidBodies for physics). But other data, still a project asset, can live outside the scene hierarchy. For this, Unity offers <span class="emphasis"><em>ScriptableObjects</em></span>. We first introduced ScriptableObjects in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Handy Interactables</em></span>, as a way of sharing input data across game objects. We will use them again here:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In the <strong class="userinput"><code>Project</code></strong> window, create a new folder under <span class="emphasis"><em>Assets</em></span> named <code class="literal">ScriptableObjects</code> if not already present</li><li>In the new folder, right-click and select <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>C# Script</code></strong></li><li>Name the script <code class="literal">ArtInfo</code></li><li>Then, open the <code class="literal">ArtInfo.cs</code> script for editing</li></ol></div><p>Create the <code class="literal">ArtInfo.cs</code> script as follows:</p><pre class="programlisting">using UnityEngine;

[CreateAssetMenu(menuName = "My Objects/Art Info")]
public class ArtInfo : ScriptableObject
{
    public Texture image;
    public string title;
    public string artist;
    [Multiline]
    public string description;
}</pre><p>Rather than inheriting from <code class="literal">MonoBehaviour</code>, we define the class as a <code class="literal">ScriptableObject</code>. We added a <code class="literal">Multiline</code> attribute for description so the input field in<strong class="userinput"><code>Inspector</code></strong>will be a text area.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note89"></a>Note</h3><p>If you are importing JSON data into your project and want to generate ScriptableObject classes that match the JSON object properties, take a look at this tool: <a class="ulink" href="https://app.quicktype.io/#r=json2csharp" target="_blank">https://app.quicktype.io/#r=json2csharp</a>.</p></div><p>At the top, we provide a <code class="literal">CreateAssetMenu</code> attribute, which generates a menu item in the Unity Editor for our object. Since scriptable objects are not added to the scene Hierarchy, we need a way to create them in the project. Using this attribute <span>makes</span><a id="id325552135" class="indexterm"></a> it easy, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Save the script and return to Unity.</li><li>In the <strong class="userinput"><code>Project</code></strong> window, select your <strong class="userinput"><code>Photos</code></strong> folder where you imported your image textures. We'll create the Art Info objects in the same folder.</li><li>In the Unity editor main menu, navigate to <strong class="userinput"><code>Assets</code></strong> | <strong class="userinput"><code>Create</code></strong>.</li><li>You will see a new item <strong class="userinput"><code>My Objects </code></strong>with a submenu with an item Art Info, as directed in the CreateAssetsMenu property attribute in our script. </li><li>Choose <strong class="userinput"><code>Art Info</code></strong> to create an instance. By default, it will be created in the same folder as the defining script (this can be changed in the property attribute options).</li><li>It maybe be helpful to rename the object similar to your images. For example, if you have <strong class="userinput"><code>PictureA</code></strong>, name it <code class="literal">PictureA Info</code>.</li><li>Drag the image texture onto the scriptable object's <strong class="userinput"><code>Image</code></strong> slot.</li><li>Add information for the <strong class="userinput"><code>Title</code></strong>, <strong class="userinput"><code>Artist</code></strong>, and <strong class="userinput"><code>Description</code></strong> too.</li></ol></div><p>Here is a screenshot of an ArtInfo object with data filled in:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/23342615-6376-4e8d-b284-fd1c55631a62.png" /></div><p>Repeat these steps for all your pictures.  When you're done, your art data will be Project assets.</p><p>To use the scriptable object assets in the project, we could modify the PopulateArtFrames much like we would have for the<code class="literal">struct</code>version of the code. We'll do a little bit of refactoring, creating a new component on the ArtworkRig to <span>populate</span><a id="id325552224" class="indexterm"></a> itself with an ArtInfo object, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select one of the ArtworkRigs in the Hierarchy</li><li>Add <strong class="userinput"><code>Component</code></strong> | <strong class="userinput"><code>New Script</code></strong>, name it <code class="literal">ArtworkController</code></li></ol></div><p>Open it for editing and write it as follows:</p><pre class="programlisting">using UnityEngine;

public class ArtworkController : MonoBehaviour {
    public GameObject image;

    public void SetArtInfo(ArtInfo info)
    {
        Renderer rend = image.GetComponent&lt;Renderer&gt;();
        Material material = rend.material;
        material.mainTexture = info.image;
    }
}</pre><p>Save the script and back in Unity, on the <code class="literal">ArtworkRig</code> where we just added this component:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Drag the image child onto the <strong class="userinput"><code>image</code></strong> slot</li><li>Press <strong class="userinput"><code>Apply</code></strong> to save the <code class="literal">ArtworkRig</code> prefab</li></ol></div><p>Now, update the <code class="literal">PopulateArtFrames</code> to iterate the list of <code class="literal">ArtInfo</code> and send the object to the <code class="literal">ArtworkRig</code>, as follows:</p><pre class="programlisting">using System.Collections.Generic;
using UnityEngine;

public class PopulateArtFrames : MonoBehaviour
{
    public List&lt;ArtInfo&gt; artInfos = new List&lt;ArtInfo&gt;();

    void Start()
    {
        int index = 0;
        foreach (Transform artwork in transform)
        {
            artwork.GetComponent&lt;ArtworkController&gt;().SetArtInfo(artInfos[index]);

            index++;
            if (index == artInfos.Count || artInfos[index]==null)
                break;
        }
    }
}</pre><p>Now, the Inspector interface is much <span>cleaner</span><a id="id325552334" class="indexterm"></a> and workable. The Artworks' Populate Art Frames component maintains a list of Art Info objects, as shown next. We just need to populate the list and use it. The data the list references are maintained separately as <code class="literal">ScriptableObjects</code>:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/faf303fc-2d45-48ed-b271-7b0a57070285.png" /></div><p>Press <strong class="userinput"><code>Play</code></strong>. The artwork images should get loaded during Start, just like before although we've greatly improved the underlying implementation and can now extend our app to include more info about each art picture.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip90"></a>Note</h3><p>Another advantage of using ScriptableObject in situations like this is once you have a distributable app, you can package these assets into an AssetBundle. This would allow, for example, changing out the gallery pictures, along with all the art info, in the live version.</p></div></div></div>