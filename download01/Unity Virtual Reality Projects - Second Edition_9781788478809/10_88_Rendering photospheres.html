<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec87"></a>Rendering photospheres</h2></div></div><hr /></div><p>The inverse of a globe is a photosphere. Where a <span>globe</span><a id="id325552311" class="indexterm"></a> maps an equirectangular texture onto the outside surface of a sphere, a photosphere would map the texture onto the inside surface, and you view it from the inside so it surrounds you.</p><p>For our examples, I'm using the <code class="literal">Farmhouse.png</code> image which is provided with this book, as shown below. Feel free to use your own 360-degree photo, whether you have a 360-degree camera such as the Ricoh Theta or other brand, use a photo stitching app for Android or iOS, or download one from any number of photo sources on the web.</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/a74f0ff1-6db9-40c4-95e8-b42fac10f158.png" /></div><p>As we've seen, Unity ordinarily renders only the outward-facing surfaces of objects. This is determined, mathematically, as the <span class="emphasis"><em>normal</em></span> direction vector of each facet of its surface mesh. A Plane is the simplest example. Back in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Content, Objects, and Scale</em></span>, we created a big screen image plane with the Grand Canyon on it. When you are facing the plane, you see the image. But if you move around behind the plane, it is not rendered, as if it were not in the scene at all. Similarly, suppose there is a cube or sphere in front of you; you will see it rendered, lit, and shaded. But if you put your head inside the object, it seems to disappear, because you're now looking at the inside faces of the object's mesh. This is all handled by the shader. And since we want to change it, we need to use a different shader. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec136"></a>Writing a custom Inward shader</h3></div></div></div><p>We are going to write a custom <span>shader</span><a id="id325552353" class="indexterm"></a> to render our texture on the <span>inside</span><a id="id325552361" class="indexterm"></a> of the sphere mesh.</p><p>Shaders are a critical part of the Unity rendering pipeline, and it's where a lot of the magic of computer graphics and virtual reality actually occurs. Unity provides an impressive set of built-in shaders, as you've likely noticed just by opening the <strong class="userinput"><code>Shader</code></strong> select list on any object's Material in the Inspector. Many asset packages you import may also include shaders that implement custom effects, including some we've already used in previous chapters, such as TextMeshPro and TiltBrush. The VR toolkits from Oculus, Google Daydream, and SteamVR also include shaders that provide an extra kick in performance and optimization of the rendering pipeline.</p><p>Writing shaders is an advanced topic in computer graphics and Unity development. Nonetheless, Unity provides tools to facilitate the <span>programming</span><a id="id325577435" class="indexterm"></a> of shaders (see <a class="ulink" href="https://docs.unity3d.com/Manual/SL-Reference.html" target="_blank">https://docs.unity3d.com/Manual/SL-Reference.html</a>), including a declarative language called <span class="emphasis"><em>ShaderLab</em></span>, a lot of documentation and tutorials, and example shaders to work from. We are not going to go very deep here but many find it a very interesting and valuable skill to learn. </p><p>To create a new shader, begin as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Navigate to <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>Shader</code></strong> | <strong class="userinput"><code>Unlit Shader</code></strong> and name it <code class="literal">MyInwardShader</code></li><li>Double-click the new shader file to open it for editing</li></ol></div><p>To turn the shader into an inside shader, all you need to do is add the line <code class="literal">Cull Front</code>, for example, immediately after the <code class="literal">Tags</code> line as follows:</p><pre class="programlisting">    ...
    Tags { "RenderType"="Opaque" }
    Cull Front
    ...</pre><p>The <code class="literal">Cull</code> command tell the shader whether to <span>ignore</span><a id="id325577733" class="indexterm"></a> front or back facing surfaces. The default is Back; we're changing it to cull the front ones and render the back ones. (For details on this, see <a class="ulink" href="https://docs.unity3d.com/Manual/SL-CullAndDepth.html" target="_blank">https://docs.unity3d.com/Manual/SL-CullAndDepth.html</a>.) </p><p>Save the file. Now we can use it in our project.</p><p>Notice that the top line of the shader file names it <code class="literal">Shader "Unlit/MyInwardShader"</code>, which means you'll find it in the select <strong class="userinput"><code>Shader</code></strong> | <strong class="userinput"><code>Unlit</code></strong> submenu, or you can modify it without the submenu to <code class="literal">Shader "MyInwardShader"</code>.</p><p>Since we're inverting the texture, it may appear mirrored backwards. We will fix that by setting its <strong class="userinput"><code>X Tiling</code></strong> to <code class="literal">-1</code>, as we will see.</p><p>An alternative approach is to invert the vertex normals within the shader. We used that technique in the first edition of this book, and it is shown here:</p><pre class="programlisting">Shader "MyInwardNormalsShader" {
    Properties {
        _MainTex ("Base (RGB)", 2D) = "white" {}
    }
    SubShader {
        Tags { "RenderType" = "Opaque" }
        Cull Off

        CGPROGRAM
        #pragma surface surf Lambert vertex:vert
        sampler2D _MainTex;

        struct Input {
            float2 uv_MainTex;
            float4 color : COLOR;
        };

        void vert(inout appdata_full v) {
            v.normal.xyz = v.normal * -1;
        }

        void surf (Input IN, inout SurfaceOutput o) {
             fixed3 result = tex2D(_MainTex, IN.uv_MainTex);
             o.Albedo = result.rgb;
             o.Alpha = 1;
        }
        ENDCG
    }
      Fallback "Diffuse"
}</pre><p>Briefly, this shader script declares the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Lets you supply  both a texture and a color property</li><li style="list-style-type: disc">Does no culling of surfaces (the texture will be visible both inside and out)</li><li style="list-style-type: disc">Uses a simple Lambert diffuse lighting algorithm (versus unlit or the Standard Unity physically-based lighting)
</li><li style="list-style-type: disc">The <code class="literal">vert</code> function inverts the mesh vertices (by multiplying the normal vector by <code class="literal">-1</code>)</li><li style="list-style-type: disc">The <code class="literal">surf</code> renderer copies the texture pixel and also lets you tint it with an Albedo color (but forces Alpha to be opaque)</li></ul></div><p>You can use this <span>shader</span><a id="id325581668" class="indexterm"></a> instead of the quick one we wrote previously.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note99"></a>Note</h3><p>Consider what would happen if you used an Alpha channel in your shader settings and set up a cutout mask. It would allow photospheres with some areas completely transparent. This opens the possibility of nesting multiple photospheres to create visual layers of 360 activity within your scene!</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec137"></a>Magic orbs</h3></div></div></div><p>Before we do full 360-photo viewing, for fun let's first consider a special case, <span class="emphasis"><em>magic orbs</em></span>. For this example, we'll look at the sphere from the inside, mapping a 360-degree image onto its inside surface. Then, we'll put a solid colored <span class="emphasis"><em>shell</em></span> around the outside. So, you really have to stick your head into the sphere to see what's there, or grab the sphere and "put it on your eyes!"</p><p>To build it, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new material by navigating to <strong class="userinput"><code>Assets</code></strong> | <strong class="userinput"><code>Create</code></strong>|<strong class="userinput"><code>Material</code></strong>and name it<code class="literal">FarmhouseInward</code>.</li><li>In <strong class="userinput"><code>Inspector</code></strong>, use the <strong class="userinput"><code>Shader</code></strong> selector and choose<strong class="userinput"><code>Unlit</code></strong> |<strong class="userinput"><code> </code></strong><strong class="userinput"><code>My</code></strong><strong class="userinput"><code>InwardShader</code></strong>, the one we just created.</li><li>Locate the <code class="literal">Farmhouse</code>texture image and drag it onto the <span>shader</span><a id="id325586480" class="indexterm"></a> component's<strong class="userinput"><code>Albedo</code></strong>texture. If needed, set <strong class="userinput"><code>Tiling X</code></strong> to <code class="literal">-1</code> to compensate for mirroring.</li><li>Add a new sphere to the scene, dragging the <code class="literal">PhotoSphere.fbx</code> from your <span class="emphasis"><em>Models</em></span> folder introduced before, and name it "MagicOrb."</li><li>Drag the <code class="literal">FarmhouseInward</code> material onto the sphere. </li></ol></div><p>We'll encase it in a solid colored orb by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select the <code class="literal">MagicOrb</code> object in <strong class="userinput"><code>Hierarchy</code></strong>, right-click, and navigate to <strong class="userinput"><code>3D Object</code></strong> | <strong class="userinput"><code>Sphere</code></strong> so that the new sphere is a child.</li></ol></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Set its <strong class="userinput"><code>Scale</code></strong> to something a little bigger than the inner sphere, such as (<code class="literal">1.02</code>, <code class="literal">1.02</code>, <code class="literal">1.02</code>)</li><li>Disable its <strong class="userinput"><code>Sphere Collider</code></strong> component by unchecking it.</li><li>Find a solid material, such as the one we made in a previous chapter named <code class="literal">RedMaterial</code>, and drag it onto the new sphere.</li></ol></div><p>Try it in VR. From the outside, it looks like a solid ball, but lean into it and there's a whole new little world in there! The following image is a capture of what I see. It's like peering into an egg shell!</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/c5ece203-3f13-4940-957b-592b56f01ca1.png" /></div><p>For non-positionally tracked mobile VR devices, you may not be able to do this in VR, but you can manually drag the camera rig in the Scene view while playing the scene in the Editor. Or, add some locomotion as described in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Locomotion and Comfort</em></span>. Or, make the orb grab-able, so the player can pick it up and move it very close to their face, using techniques described in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Handy Interactables</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip100"></a>Note</h3><p>If you want to dive deeper into shaders, as an exercise, try and see how you could modify InwardShader to take an additional Color parameter that is used to render the outward facing surface, while the texture is used to render the inward facing ones.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec138"></a>Photospheres</h3></div></div></div><p><span class="emphasis"><em>Yes sir, it's all the rage these days. It's better than panoramas. It's better than selfies. It may be even better than Snapchat! We're finally getting to the moment that you've been waiting for! It's 360-degree photospheres!</em></span></p><p>We covered a lot of topics in this chapter, which will now make it fairly easy to talk about 360-degree photospheres. To build one, we'll just make a very big sphere with the <code class="literal">MyInwardShader</code> shader.</p><p>Start with a new empty scene:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new scene by navigating to <strong class="userinput"><code>File</code></strong> | <strong class="userinput"><code>New Scene</code></strong>. Then, <strong class="userinput"><code>File</code></strong> | <strong class="userinput"><code>Save Scene</code></strong> and name it <code class="literal">PhotoSphere</code>. Delete the default Main Camera.</li><li>Add the <code class="literal">MyMyselfEye</code> prefab and reset its <strong class="userinput"><code>Transform</code></strong><strong class="userinput"><code>Position</code></strong> to (<code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">0</code>).</li><li>Create an equirectangular sphere by dragging the <code class="literal">PhotoSphere</code> model from the <code class="literal">Project Models</code> folder into the scene (as imported from <code class="literal">PhotoSphere.fbx</code> in the previous example).</li><li>Reset its <strong class="userinput"><code>Transform</code></strong>  (<span class="emphasis"><em>gear</em></span> icon | <strong class="userinput"><code>Reset) and</code></strong> set its <strong class="userinput"><code>Scale</code></strong> to (<code class="literal">10</code>, <code class="literal">10</code>, <code class="literal">10</code>).</li><li>Create a material (<strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>Material)</code></strong> and name it to <code class="literal">PhotoSphere Material</code>.</li><li>Navigate to <strong class="userinput"><code><span>Shader</span><a id="id325577657" class="indexterm"></a></code></strong> | <strong class="userinput"><code>Unlit</code></strong> | <strong class="userinput"><code>My</code></strong><strong class="userinput"><code>InwardShader</code></strong> (as created earlier in this chapter).</li><li>Drag the <code class="literal">Photosphere</code> Material onto the <code class="literal">Photosphere</code> game object.</li><li>If there will be other objects in the Scene, you may need to disable shadows. On the Photosphere game object, in its <strong class="userinput"><code>Mesh Renderer</code></strong> component, uncheck the <strong class="userinput"><code>Receive Shadows</code></strong> checkbox.</li></ol></div><p>Now, to add the photo:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the photo that you want to use; ours is named <code class="literal">FarmHouse.jpg</code>. </li><li>With <code class="literal">PhotoSphere</code> selected (or the <code class="literal">PhotoSphere Material</code> itself), drag the <code class="literal">FarmHouse</code> texture onto the <strong class="userinput"><code>Albedo</code></strong> texture tile.</li><li>Set the <strong class="userinput"><code>Tiling X</code></strong> value to <code class="literal">-1</code> to compensate for the mirror inversion, if necessary.</li></ol></div><p>Press <strong class="userinput"><code>Play</code></strong>. You should now see the photosphere surrounding you in the scene.</p><p>If you are using a device with positional tracking, such as the Oculus Rift, we need to disable it. Create a new script on  <code class="literal">MemMyselfEye</code> as follows:</p><pre class="programlisting">public class DisablePositionalTracking : MonoBehaviour
{
    void Start()
    {
        UnityEngine.XR.InputTracking.disablePositionalTracking = true;
    }
} </pre><p>You may find that the default texture resolution and/or compression are not high enough quality for your taste. To modify the resolution, follow these steps: </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select the texture (Farmhouse.png)</li><li>In <strong class="userinput"><code>Inspector</code></strong>, change the <strong class="userinput"><code>Max Size</code></strong> to <code class="literal">4096</code> or <code class="literal">8192</code></li><li>Press <strong class="userinput"><code>Apply</code></strong> to re-import the texture</li></ol></div><p>Note the file size (at bottom of <strong class="userinput"><code>Inspector</code></strong>) can grow exponentially, affecting the final size of your app, load times, and runtime performance. Also try the other compression settings, including the new <span>Crunch</span><a id="id325577917" class="indexterm"></a> Compression (<a class="ulink" href="https://blogs.unity3d.com/2017/11/15/updated-crunch-texture-compression-library/" target="_blank">https://blogs.unity3d.com/2017/11/15/updated-crunch-texture-compression-library/</a>). You can configure these settings on a per-platform basis.</p><p>To switch images, repeat the last two steps: import the asset and assign it to the <strong class="userinput"><code>Albedo</code></strong> texture of the <code class="literal">Photosphere Mataterial</code>. If you want to do this in-game, you can do this in a script (for example, by using <code class="literal">Material.mainTexture()</code>).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec139"></a>Playing 360-degree videos</h3></div></div></div><p>The steps for adding a 360-degree video are pretty much the same as <span>adding</span><a id="id325577949" class="indexterm"></a> a regular rectangular one to your project (see <a class="ulink" href="https://docs.unity3d.com/Manual/class-MovieTexture.html" target="_blank">https://docs.unity3d.com/Manual/class-MovieTexture.html</a>). To play a 360-degree video, you use a  <code class="literal">Video Player</code> to render the video on a <code class="literal">Render Texture</code>.  If you do not have a 360-degree <span>video</span><a id="id325577969" class="indexterm"></a> handy, search the web free downloads and pick one that's not too long and a limited file size. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note101"></a>Note</h3><p>Depending on the format of your video, you may need to install QuickTime on your system first before you can import it into Unity, for the conversion codec. </p></div><p>If you would like, start a new scene and reset the MyMyselfEye <strong class="userinput"><code>Transform</code></strong> to the origin. Then, import a 360 video into your<strong class="userinput"><code>Project Assets. </code></strong>Note its dimensions (for example, a 4K video is 4096 x 2048). You can see it in <strong class="userinput"><code>Inspector</code></strong>, if you're not sure.</p><p>Add a video player to your project as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create an <strong class="userinput"><code>Empty</code></strong> named <code class="literal">"VideoPlayer"</code></li><li><strong class="userinput"><code>Add Component</code></strong> | <strong class="userinput"><code>Video Player</code></strong></li><li>Drag your video file onto its <strong class="userinput"><code>Video Clip</code></strong> slot</li><li>Check the <strong class="userinput"><code>Play On Awake</code></strong> checkbox and the <strong class="userinput"><code>Loop</code></strong> checkbox</li><li>Ensure <strong class="userinput"><code>Render Mode</code></strong> is set to <strong class="userinput"><code>Render Texture</code></strong></li></ol></div><p>Now, we will create a <code class="literal">Render Texture</code>, a special Unity texture that will be rendered at runtime by the video player:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In your <strong class="userinput"><code>Project Assets</code></strong>, <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>Render Texture</code></strong>, name it <code class="literal">"Video Render Texture"</code></li><li>Set the <strong class="userinput"><code>Size</code></strong> to exactly the size of your video, (such as 4096 x 2048).</li><li>Setting <strong class="userinput"><code>Anti aliasing</code></strong> to <strong class="userinput"><code>2 samples</code></strong> is recommended.</li><li>You can set <strong class="userinput"><code>Depth Buffer</code></strong> to <strong class="userinput"><code>No Depth Buffer</code></strong></li><li>Select <strong class="userinput"><code>VideoPlayer</code></strong> in Hierarchy and drag VideoRenderTexture onto its <strong class="userinput"><code>Target Texture</code></strong> slot</li></ol></div><p>Now, create your photosphere:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new 3D <strong class="userinput"><code>Sphere</code></strong> and name it "VideoSphere"</li><li>Reset its <strong class="userinput"><code>Transform</code></strong>, so its <strong class="userinput"><code>Position</code></strong> is (<code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">0</code>), then set its <strong class="userinput"><code>Scale</code></strong> to  (<code class="literal">10</code>, <code class="literal">10</code>, <code class="literal">10</code>)</li><li>Drag <strong class="userinput"><code>Video Render Texture</code></strong> onto the sphere and make a new Material (or you could have separately created this material first)</li><li>Change the Material <strong class="userinput"><code>Shader</code></strong> to <strong class="userinput"><code>MyInwardShader</code></strong></li></ol></div><p>A resulting VideoPlayer in Inspector is shown here:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/603ba851-69a1-4e0e-8701-d531e3f2f3af.png" /></div><p>Press <strong class="userinput"><code>Play</code></strong>. You now have a basic 360 video player built with Unity.</p><p>To review, the sphere uses a material with an inward shader. The shader renders an equirectangular texture on the inside of the sphere. The video player modifies that texture each update with the next video frame.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip102"></a>Note</h3><p>When building for Android and iOS, you must put your video file (such as MP4) into a folder named <span class="emphasis"><em>StreamingAssets</em></span> in your Project Assets. For more information on this and other considerations for Video Player and codecs, see the Unity documentation at <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html" target="_blank">https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html</a>.</p></div><p></p><p>If the video has audio, we can make the video an <strong class="userinput"><code>Audio Source</code></strong> as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Select the <strong class="userinput"><code>VideoPlayer</code></strong> and <strong class="userinput"><code>Add Component</code></strong> | <strong class="userinput"><code>Audio Source</code></strong></li><li style="list-style-type: disc">Drag <code class="literal">VideoPlayer</code> itself onto its Video Player component's <strong class="userinput"><code>Audio Source</code></strong> slot</li></ul></div><p>As with all Unity components, the video player has an API and can be controlled <span>via</span><a id="id325552442" class="indexterm"></a> scripting. For example, to simply pause the video with a <span>button</span><a id="id325552451" class="indexterm"></a> click, you could add this <span>script</span><a id="id325552459" class="indexterm"></a> to the <code class="literal">VideoPlayer</code>:</p><pre class="programlisting">using UnityEngine;
using UnityEngine.Video;

public class PlayPause : MonoBehaviour {
    private VideoPlayer player;

    void Start() {
        player = GetComponent&lt;VideoPlayer&gt;();
    }

    void Update() {
        if (Input.GetButtonDown("Fire1"))
        {
            if (player.isPlaying)
            {
                player.Pause();
            }
            else
            {
                player.Play();
            }
        }
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note103"></a>Note</h3><p>For additional tips, also check out the tutorial from Unity <span class="emphasis"><em>Getting started in interactive 360 video: Download our sample project</em></span> at  <a class="ulink" href="https://blogs.unity3d.com/2018/01/19/getting-started-in-interactive-360-video-download-our-sample-project/" target="_blank">https://blogs.unity3d.com/2018/01/19/getting-started-in-interactive-360-video-download-our-sample-project/</a>.</p></div></div></div>