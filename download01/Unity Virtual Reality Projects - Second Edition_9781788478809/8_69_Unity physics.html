<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec70"></a>Unity physics</h2></div></div><hr /></div><p>In Unity, the behavior of an object that is <span>based</span><a id="id325317294" class="indexterm"></a> on physics is defined separately from its mesh (shape), materials (UV texture), and the renderer properties. The items that play into physics include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong><span>Rigidbody</span></strong></span>: Enables the <span>object</span><a id="id325560755" class="indexterm"></a> to act under the control of the physics engine, receive forces and torque to move in a realistic way</li><li style="list-style-type: disc"><span class="strong"><strong>Collider</strong></span>: Defines a simplified, approximated shape of the <span>object</span><a id="id325563534" class="indexterm"></a> used for calculating collisions with other objects
</li><li style="list-style-type: disc"><span class="strong"><strong>Physic Material</strong></span>: Defines friction <span>and</span><a id="id325563579" class="indexterm"></a> bounce effects of colliding objects</li><li style="list-style-type: disc"><span class="strong"><strong>Physics Manager</strong></span>: Applies global <span>settings</span><a id="id325563593" class="indexterm"></a> for 3D physics for your project</li></ul></div><p>Basically, physics (in this context) is defined by the positional and rotational forces that affect the transform of an object, such as gravity, friction, momentum, and collisions with other objects. It is not necessarily a perfect simulation of physics in the real world because it's optimized for performance and separation of concerns to facilitate animation. Besides, virtual worlds might just need their own laws of physics that aren't found in our God-given universe!</p><p>Unity integrates the <span class="strong"><strong>NVIDIA PhysX</strong></span> engine, a real-time physics calculation middleware, which implements classical Newtonian mechanics for <span>games</span><a id="id325567576" class="indexterm"></a> and 3D applications. This multiplatform software is optimized to utilize fast hardware processors when present. It is accessible via the Unity scripting API.</p><p>A key to physics is the Rigidbody component that you add to objects. Rigidbodies have parameters for gravity, mass, and drag, among others. Rigidbodies can automatically react to gravity and collisions with other objects. No extra scripting is needed for this. During gameplay, the <span>engine</span><a id="id325567585" class="indexterm"></a> calculates each rigid object's momentum and updates its transform position and rotation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note77"></a>Note</h3><p>Details on Rigidbodies can be found at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rigidbody.html" target="_blank"><span>http://docs.unity3d.com/ScriptReference/Rigidbody.html</span></a>.</p></div><p>Unity projects have a global gravity setting, found in the project's Physics Manager by navigating to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Physics</code></strong>. As you might expect, the default gravity setting is a <strong class="userinput"><code>Vector3</code></strong> with values (<code class="literal">0</code>, <code class="literal">-9.81</code>, <code class="literal">0</code>) that apply a downward force to all Rigidbodies. Gravity is in meters per second squared.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip78"></a>Note</h3><p>Rigidbodies can automatically react to gravity and collisions with other objects. Extra scripting is not needed for this.</p></div><p>In order to detect a collision, both the colliding objects must have a <code class="literal">Collider</code> component. There are built-in colliders with basic geometric shapes such as a cube, sphere, cylinder, and a capsule. A mesh collider can assume an arbitrary shape. If you can, it's best to use one or more basic collider shapes that approximately fit the actual object, rather than a mesh collider to reduce the expense of calculating the actual collisions during gameplay. Unity requires that if your object will be used in physics and has a Rigidbody, then its mesh collider must be marked as convex and be limited to 255 triangles.</p><p>When rigid objects collide, the forces pertinent to each object in the collision are applied to the others. The values of the resulting forces are calculated based on the objects' current velocity and body mass. Other factors are also taken into consideration, such as gravity and drag (that is, resistance). Furthermore, you have options to add constraints to freeze the position or rotation of a given object in any of its <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> axes.</p><p>The calculations can be further affected when a Physic Material is assigned to the object's collider, which adjusts the friction and the bounciness effects of the colliding objects. These properties will be applied only to the object that owns the Physic Material. (Note that it's really spelled <span class="emphasis"><em>Physic Material</em></span> rather than <span class="emphasis"><em>Physics Material</em></span> for historical reasons.)</p><p>So, let's say that Object A (Ball) hits Object B (Brick). If Object A has bounciness and Object B does not, Object A will have an impulse applied in the collision, but Object B will not. However, you have options to determine how their friction and bounciness combine, as we'll see next. It's not necessarily an accurate simulation of real-world physics. It's a game engine, not a computer-aided engineering modeler.</p><p>From a scripting point of view, Unity will trigger eventsÂ when objects collide (<code class="literal">OnTriggerEnter</code>), each frame while objects are colliding (<code class="literal">OnTriggerStay</code>), and when they've stopped colliding (<code class="literal">OnTriggerExit</code>).</p><p>If this sounds daunting, read on. The rest of this chapter breaks it down into understandable bits and pieces.</p></div>