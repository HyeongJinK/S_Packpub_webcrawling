<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch12lvl1sec101"></a>Multiplayer networking</h2></div></div><hr /></div><p>Before we begin any implementation, let's take a look at what <span>multiplayer</span><a id="id325552311" class="indexterm"></a> networking is all about and define some terms.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec165"></a>Networking services</h3></div></div></div><p>Consider a situation where you are running a VR application that is connected over the internet to other players running the same application on their own VR rigs at the same time. When you move your first person view within the game, shoot things, or otherwise interact with the virtual environment, you expect the other players to see that, too. Their version of the game stays in sync with yours and vice versa. How does this work?</p><p>One instance of the running game acts as a host or server. Other players are concurrently connected to the same. When you move, your character's new position is shared with each of the other connections, which then updates your avatar's position in their own views. Similarly, when your game receives a changed position of another character, it is updated in your view. The faster, the better. That is, the shorter the delay (latency) between the <span class="emphasis"><em>send</em></span> and <span class="emphasis"><em>receive</em></span> messages and the corresponding screen updates, the more live, or real-time, the interaction feels.</p><p><span>Multiplayer</span><a id="id325577038" class="indexterm"></a> services should help you manage the sharing of the game's state between all active clients, the spawning of new players and objects, security considerations, as well as the management of low-level network connections, protocols, and quality of service (such as data rate and performance).</p><p>Networking is built as a series of API layers, where the low-level functions deal with details of the data transport and would be agnostic to the content of the data. Middle and higher layers provide increasingly aggregated features that also may be more directly helpful for the networking application. In our case, this is multiplayer gaming and social VR. Ideally, the high-level layer will provide all you need to implement multiplayer features into your games with minimal custom scripting, while offering access to other layers through a clean API in case you have special requirements.</p><p>There are a number of multiplayer services available, including Photon from Exit Games and platforms from Google, Facebook/Oculus, Apple, Microsoft, Amazon, and more.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The popular Photon Cloud service can be easily <span>added</span><a id="id325577438" class="indexterm"></a> using their free <span class="strong"><strong>Photon Unity Networking</strong></span> (<span class="strong"><strong>PUN</strong></span>) package from the Unity Asset Store (for more information, visit <span><a class="ulink" href="https://www.assetstore.unity3d.com/#/content/1786" target="_blank">https://www.assetstore.unity3d.com/#/content/1786</a></span>). If you are interested in trying Photon with Unity, take a look their documentation and tutorial pages (<a class="ulink" href="https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links" target="_blank">https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links</a>). </li><li style="list-style-type: disc">Unity has its own built-in networking system, <span class="strong"><strong>Unity Networking</strong></span> (<span class="strong"><strong>UNet</strong></span>), which reduces the need for custom scripting and provides a feature-rich set of <span>components</span><a id="id325577474" class="indexterm"></a> and API that tightly integrate with Unity. There is a whole tutorial series on the Unity website (<a class="ulink" href="https://unity3d.com/learn/tutorials/s/multiplayer-networking" target="_blank">https://unity3d.com/learn/tutorials/s/multiplayer-networking</a>), and it's what we will use in this chapter's project.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec166"></a>The network architecture</h3></div></div></div><p>A key to networking is the client-server system architecture. We see this all around us in today's world; your web browser is a client and <span>websites</span><a id="id325581588" class="indexterm"></a> are hosted on a server. Your favorite music listening app is a client and its streaming service is a server. Similarly, each instance of your game, when connected to a network, is a client. It talks to a server, which communicates the status and control information between all the other game clients.</p><p>I say <span class="emphasis"><em>server</em></span>, but it doesn't necessarily need to be a separate physical computer somewhere. It could be, but it's probably not. It's best to think of a client and server as <span class="emphasis"><em>processes</em></span>: instances of a program or an application running somewhere. A <span class="strong"><strong>cloud server</strong></span> is a virtual process that is <span>accessible</span><a id="id325581609" class="indexterm"></a> via the internet as a service.</p><p>A single app can sometimes act as both a client and a server at the same time. This latter case, where the server and client are one, is said to be running as a host. With Unity networking, games can be run as a client, a server, and/or as a host.</p><p>Even so, a public <span class="strong"><strong>IP</strong></span> (<span class="strong"><strong>Internet Protocol</strong></span>) address is needed for <span>game</span><a id="id325581628" class="indexterm"></a> instances to talk to one another. A lightweight relay server can provide this service with minimal resources.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec167"></a>Local versus server</h3></div></div></div><p>In Unity, you can use scripting to create, or instantiate, new objects during gameplay. In a multiplayer situation, these objects need to be activated, or spawned, locally as well as on the <span>network</span><a id="id325581671" class="indexterm"></a> so that all the clients will know about it. A spawning system manages objects across all the clients.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note116"></a>Note</h3><p>It is important to make a distinction between objects that are local player o<span class="emphasis"><em>bjects</em></span> versus network ones. Local player objects are controlled by actions in your playing version of the game, on your client, rather than remotely.</p></div><p>For example, in a first-person experience, you are the camera whereas other players see you as your avatar, and you would want security precautions; for example, to prevent others from hacking a game and changing your avatar.</p><p>Local player objects have local authority, that is, the player object is responsible for controlling itself, such as its own movement. Otherwise, when the creation, movement, and destruction of objects are not controlled by any player, the authority should reside on a server. Local authority is needed when individual players are driving gameplay.</p><p>On the other hand, server authority is needed when game logic and random events are driving the gameplay. For example, when a game creates enemies at random locations, you'd want all the clients to get the same random locations. When a new player joins an ongoing game, the server helps create and set up objects that are active in the current gameplay. You wouldn't want an object to show up in its default position and then jump to a different current position as it's syncing with the other clients.</p><p>The following image from Unity documentation shows ways in <span>which</span><a id="id325581697" class="indexterm"></a> actions are performed across the network. The server makes <span class="strong"><strong>remote procedure calls</strong></span> (<span class="strong"><strong>RPC</strong></span>) to the client to spawn or update objects. The client sends <span class="strong"><strong>commands</strong></span> to the server and affects actions, which then are communicated to all the remote clients:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/78f7aae3-9483-4e25-8ff5-47b96edc5f8e.jpg" /></div><p>Image source: <a class="ulink" href="https://docs.unity3d.com/Manual/class-NetworkBehaviour.html" target="_blank">https://docs.unity3d.com/Manual/class-NetworkBehaviour.html</a></p><p>Real-time networking is an engineering discipline. Layered network architectures aim to simplify and shield you from brutally arcane details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip117"></a>Note</h3><p>It all comes down to performance, security, and reliability. If you need to debug or optimize any of these in your multiplayer game, you may need to dig in your heels and gain a better understanding of what's going on under the hood. Refer to the next chapter, <a class="link" href="#" linkend="ch13">Chapter 13</a>, <span class="emphasis"><em>Optimizing for Performance and Comfort</em></span>, for suggestions.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec168"></a>The Unity networking system</h3></div></div></div><p>The <span class="strong"><strong>Unity Networking</strong></span> engine (<span class="strong"><strong>UNet</strong></span>) includes a robust set of high-level <span>component</span><a id="id325586499" class="indexterm"></a> scripts that make it easy to add multiplayer capabilities to your games. Some of the more important components include <span class="emphasis"><em>Network Identity</em></span>, <span class="emphasis"><em>Network Behavior</em></span>, <span class="emphasis"><em>Network Transform</em></span>, and <span class="emphasis"><em>Network Manager</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note118"></a>Note</h3><p>
A good overview of Unity Networking and exposition of the concepts is the Unity Networking Concepts document (<a class="ulink" href="http://docs.unity3d.com/Manual/UNetConcepts.html" target="_blank">http://docs.unity3d.com/Manual/UNetConcepts.html</a>).</p></div><p>The <span class="strong"><strong>Network Identity</strong></span> component is required on each game object <span>prefab</span><a id="id325594729" class="indexterm"></a> that may be spawned (created) on clients. Internally, it provides a universally unique asset ID, and other parameters, so that objects can be unambiguously identified and spawned across the network.</p><p>The <code class="literal">NetworkBehaviour</code> class is derived from <code class="literal">MonoBehaviour</code> and provides <span>network</span><a id="id325594746" class="indexterm"></a> functionality to scripts. We'll be using it in the <span>examples</span><a id="id325594755" class="indexterm"></a> in this chapter. Details are documented at <a class="ulink" href="http://docs.unity3d.com/Manual/class-NetworkBehaviour.html" target="_blank"><span>http://docs.unity3d.com/Manual/class-NetworkBehaviour.html</span></a>.</p><p>When you want to synchronize the movement and physics of objects, add a <span class="strong"><strong>Network Transform</strong></span> component. It's like a shortcut for the more general <code class="literal">SyncVar</code> variable synchronization with additional intelligent interpolation for smoother movement between updates.</p><p>The <span class="strong"><strong>Network Manager</strong></span> component is the glue that <span>puts</span><a id="id325552070" class="indexterm"></a> it all together. It handles the managing of connections, the spawning of objects across the network, and configuration.</p><p>When new player objects are spawned, you can specify a spawn position in the Network Manager component. Alternatively, you can add game objects to your scene and give them a <span class="emphasis"><em>Network Start Position</em></span> component, which can be used by the spawning system.</p><p>Nonplayer objects that can get spawned can also be set in the Network Manager spawn list. Additionally, the Network Manager component handles scene changes and provides debugging information.</p><p>Related to the Network Manager component is the matchmaking functionality, using Unity Cloud Services, which can be configured to match up players to make them come together and start a game at the same time-a multiplayer lobby manager where players can set themselves as ready for the game to start, among other useful features.</p></div></div>