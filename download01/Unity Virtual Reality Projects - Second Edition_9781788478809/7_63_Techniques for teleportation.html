<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec65"></a>Techniques for teleportation</h2></div></div><hr /></div><p><span class="strong"><strong>Pointer teleportation</strong></span> is a <span>mechanic</span><a id="id325317269" class="indexterm"></a> where you point to a location you want to go to, and you jump there. No gliding. You just teleport to the new location. A <span>laser</span><a id="id325317276" class="indexterm"></a> beam or arc may be drawn, along with a teleport location receptacle to indicate where you may go.</p><p>As we've seen in previous chapters, we can make our own scripts. But since this is a core feature of VR applications, teleportation components are often included with device SDK toolkits. We'll write our own and consider some provided ones afterward.</p><p>To begin, if you have a saved version of the scene from <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Gaze-Based Control</em></span>, you can start with that. You may disable a few objects that we do not need, including <code class="literal">Ethan</code> and <code class="literal">WalkTarget</code>. Or, build a similar simple new scene containing a ground plane, some 3D objects as obstacles, and a copy of your <code class="literal">MeMyselfEye</code> prefab.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec102"></a>Looking to teleport</h3></div></div></div><p>The mechanic we'll implement for our homegrown teleportation will <span>work</span><a id="id325547511" class="indexterm"></a> on any VR platform, using gaze-based pointing. Similar to how we controlled Ethan the zombie in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Gaze-Based Control</em></span>, we'll cast a ray from the player's camera view to the ground plane to choose a move-to location.</p><p>In our script, we'll use button press to initiate the teleport and release to jump there if you've selected a valid location. Alternatively, you could consider other input such as a forward push of the thumbstick using <code class="literal">Input.GetAxis</code>(v<span class="emphasis"><em>ertical</em></span>) .</p><p>First, let's create a teleport marker (similar to the WalkTarget one), as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Add an empty game object to the <strong class="userinput"><code>Hierarchy</code></strong> panel, and rename it <code class="literal">TeleportMarker</code>.</li><li>Reset its <strong class="userinput"><code>Transform</code></strong> values to position (<code class="literal">0</code>,<code class="literal">0</code>,<code class="literal">0</code>) (using the gear icon in the upper-right of the Transform pane).</li><li>Right-click on the mouse and navigate to <strong class="userinput"><code>3D Object</code></strong> | <strong class="userinput"><code>Cylinder</code></strong>. This will create a cylindrical object parented by <code class="literal">TeleportMarker</code>. </li><li>Reset its transform and change the <strong class="userinput"><code>Scale</code></strong> to (<code class="literal">0.4</code>, <code class="literal">0.05</code>, <code class="literal">0.4</code>). This will create a flat disk with a diameter of <code class="literal">0.4</code>.</li><li>Disable or remove its <strong class="userinput"><code>Capsule Collider</code></strong>.</li></ol></div><p>For now, we'll use the default material. Or, you could decorate your marker with another material. (For example, if you have Steam <code class="literal">InteractionSystem</code> installed, try the <code class="literal">TeleportPointVisible</code> material. If you have Daydream Elements installed, try the <code class="literal">TeleportGlow</code> material.)</p><p>Now, let's write the script:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select the <code class="literal">MeMyselfEye</code> object in the <strong class="userinput"><code>Hierarchy</code></strong> panel</li><li>Disable or remove the <code class="literal">GlideLocomotion</code> component, if present</li><li>Select <strong class="userinput"><code>Add Component</code></strong> | <strong class="userinput"><code>New Script</code></strong> and name it <code class="literal">LookTeleport</code></li></ol></div><p>Write the script as follows:</p><pre class="programlisting">using UnityEngine;

public class LookTeleport : MonoBehaviour
{
    public GameObject target;
    public GameObject ground;

    void Update()
    {
        Transform camera = Camera.main.transform;
        Ray ray;
        RaycastHit hit;

        if (Input.GetButtonDown("Fire1"))
        {
          // start searching
          target.SetActive(true);
        }
        else if (Input.GetButtonUp("Fire1")) 
        {
          // done searching, teleport player
          target.SetActive(false);
          transform.position = target.transform.position;
        }
        else if (target.activeSelf)
        {
          ray = new Ray(camera.position, camera.rotation * Vector3.forward);
          if (Physics.Raycast(ray, out hit) &amp;&amp; 
              (hit.collider.gameObject == ground))
          {
            // move target to look-at position
            target.transform.position = hit.point;
          }
          else
          {
            // not looking a ground, reset target to player position
            target.transform.position = transform.position;
          }
       }
    }
}</pre><p>The script works as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">When the player clicks, targeting begins, and the target marker is made visible (<code class="literal">SetActive(true)</code>).</li><li style="list-style-type: disc">While targeting, we identify what the player is looking at (<code class="literal">Raycast</code>). And if it's the ground, we position the target there (<code class="literal">hit.point</code>). Otherwise, the target is reset to the player's position.</li><li style="list-style-type: disc">When the player stops pressing the button, the target is hidden. And we position the player to the target's current position, thus completing the teleportation.</li></ul></div><p>Notice that we are using the <code class="literal">TeleportMarker</code> target to store the state of our teleport mechanic while in targeting mode. When the target is active, we're targeting. When we exit targeting, we use the target's position as the new player position.</p><p>Save the script and in Unity:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Drag the <code class="literal">GroundPlane</code> object onto the Ground slot</li><li>Drag the <code class="literal">TeleportMarker</code> object onto the Target slot</li></ol></div><p>Press <strong class="userinput"><code>Play</code></strong>. Pressing the input button will activate the target marker, which moves as you look. On releasing the button, you teleport to that position. You <span>can</span><a id="id325563595" class="indexterm"></a> cancel the teleport by looking at something other than the ground and releasing the button.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec103"></a>Teleporting between surfaces</h3></div></div></div><p>In the previous script, we're <span>using</span><a id="id325567576" class="indexterm"></a> a plain Raycast to determine where to place the <code class="literal">TeleportMarker</code>. This really only works on Plane objects. For any other 3D object, the hit point might be any surface, not just the topside walkable one. </p><p>An alternative approach is to use NavMesh to identify surfaces you can teleport to within the scene. Back in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Gaze-Based Control</em></span>, we generated a NavMesh for Ethan's <code class="literal">AIThirdPersonController</code> to control where he's allowed to roam. This time, we also use the NavMesh to determine where we (<code class="literal">MeMyselfEye</code>) can go. Feel free to go back and review our conversations about NavMesh.</p><p>The advantage of this approach is the available teleportation locations can be a subset of the ground plane. There can be can be multiple other object surfaces and even complex terrains. The teleportation locations will be limited to valid flat or slightly sloped surfaces. </p><p>In case you skipped that section, or if you've rearranged objects in your scene since then, we will regenerate the NavMesh now:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select the <strong class="userinput"><code>Navigation</code></strong> panel. If it's not already a tab in your editor, open the Navigation window from the main menu by navigating to <strong class="userinput"><code>Window</code></strong> | <strong class="userinput"><code>Navigation</code></strong>.</li><li>Select its <strong class="userinput"><code>Object</code></strong> tab.</li><li>Select the <strong class="userinput"><code>Ground Plane</code></strong> in <strong class="userinput"><code>Hierarchy</code></strong>, then in the <strong class="userinput"><code>Navigation</code></strong> window's <strong class="userinput"><code>Object</code></strong> pane, check the <strong class="userinput"><code>Navigation Static</code></strong> checkbox. (Alternatively, you can use the object's <strong class="userinput"><code>Inspector</code></strong> window <strong class="userinput"><code>Static</code></strong> drop-down list.)</li><li>Repeat step 3 for each of the objects that should block your possible teleportation locations: the cubes, sphere, and so on.</li></ol></div><p>For demonstration, we will now also add a second story platform:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In <strong class="userinput"><code>Hierarchy</code></strong>, create a new 3D <strong class="userinput"><code>Cube</code></strong> and name it Overlook</li><li>Set its <strong class="userinput"><code>Scale</code></strong> to (<code class="literal">2.5</code>, <code class="literal">0.1</code>, <code class="literal">5</code>) and its <strong class="userinput"><code>Position</code></strong> to (<code class="literal">4</code>, <code class="literal">2.5</code>, <code class="literal">0.5</code>)</li><li>In the <strong class="userinput"><code>Navigation</code></strong> window, select the <strong class="userinput"><code>Object</code></strong> tab and check <strong class="userinput"><code>Navigation Static</code></strong> for the o<span>verlook, then</span></li><li>Select the <strong class="userinput"><code>Bake</code></strong> tab and click on the <strong class="userinput"><code>Bake</code></strong> button at the bottom of the panel</li></ol></div><p>Note that its height (<strong class="userinput"><code>Y Scale</code></strong>) of the platform is greater than <strong class="userinput"><code>Agent Height</code></strong> (2) in the <strong class="userinput"><code>Navigation</code></strong> Bake settings. This will ensure the player can go both beneath the platform and on top of it. In the <strong class="userinput"><code>Scene</code></strong> window, you can see the areas in blue defined by the NavMesh, shown next, including a nice lookout area on the second story platform:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/4aece75f-00a8-40ad-8276-1ae20ac238f4.png" /></div><p>We can now modify the script to find our teleport target position on the NavMesh rather than the ground plane. Unfortunately, Unity does not provide a <code class="literal">Raycast</code> function for directly finding a hit point on the NavMesh. Instead, we find a hit point, as usual, using Physics colliders (which may be on the side or bottom of an object, not just the walkable surface), and then call <code class="literal">NavMesh.SamplePosition</code> to find the hit point position on the NavMesh. Modify the <code class="literal">LookTeleport</code> script as follows.</p><p>Add the following line at the top of your script to access the NavMesh API:</p><pre class="programlisting">using UnityEngine.AI;</pre><p>Now, modify <code class="literal">Update()</code> as follows:</p><pre class="programlisting">  if (Physics.Raycast(ray, out hit))
  {
    NavMeshHit navHit;
    if (NavMesh.SamplePosition(hit.point, out navHit, 1.0f, NavMesh.AllAreas))
      target.transform.position = navHit.position;
  }</pre><p>The call to <code class="literal">NavMesh.SamplePosition</code> takes the <code class="literal">hit.point</code> and finds the closest point on the NavMesh, within a given radius (we gave 1.0). </p><p>Press <strong class="userinput"><code>Play</code></strong>. Now, you can set the <code class="literal">TeleportMarker</code> not only on the walkable surface of the <code class="literal">GroundPlane</code> but also on top of the Overlook!</p><p>One more thing. Doing a <code class="literal">Physics.Raycast</code> can <span>get</span><a id="id325577699" class="indexterm"></a> quite expensive, especially in scenes with a lot of objects. You can limit the Raycast search by providing a layer mask. For example, create a layer named <code class="literal">Teleport</code> and set this layer for both <code class="literal">GroundPlane</code> and Overlook game objects. Then, modify the Raycast call as follows:</p><pre class="programlisting">  if (Physics.Raycast(ray, out hit, LayerMask.GetMask("Teleport")))</pre><p>This will limit our Raycast to just the surfaces overlaid by the NavMesh, namely the ground plane and overlook.</p><p>The next scenario we'll consider is not permitting free roaming at all, but setting up a limited set of teleportation locations.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec104"></a>Teleport spawn points</h3></div></div></div><p>It is very common in VR applications to <span>limit</span><a id="id325552164" class="indexterm"></a> teleportation to only specific predefined locations within the scene. In that case, you would not need any free-roaming glide locomotion or arbitrary teleportation targets. Instead, you can define the specific teleportation spawn points. Let's see how to do this.</p><p>First, let's create a <code class="literal">TeleportSpawn</code> prefab to mark our locations:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In Hierarchy, create a 3D <strong class="userinput"><code>Sphere</code></strong> and name it <code class="literal">TeleportSpawn</code></li><li>Reset its transform (<strong class="userinput"><code>gear icon</code></strong> | <strong class="userinput"><code>Reset</code></strong>)</li><li>Set its <strong class="userinput"><code>Scale</code></strong> to <code class="literal">0.4</code>, <code class="literal">0.4</code>, <code class="literal">0.4</code></li><li>Set its <strong class="userinput"><code>Position</code></strong> to something like (<code class="literal">2</code>, <code class="literal">0</code>, <code class="literal">3</code>)</li><li>Create a new layer named <code class="literal">TeleportSpawn</code> from <strong class="userinput"><code>Inspector</code></strong> | <strong class="userinput"><code>Layers</code></strong> | <strong class="userinput"><code>Add Layer</code></strong> and fill in the name in an empty slot</li><li>Select the <code class="literal">TeleportSpawn</code> object in Hierarchy again, and now set its layer (<strong class="userinput"><code>Layers</code></strong> | <strong class="userinput"><code>TeleportSpawn</code></strong>) to the one we just defined</li></ol></div><p>Let's quickly make a material:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In your Materials folder, right-click to <strong class="userinput"><code>Create</code></strong> a new <strong class="userinput"><code>Material</code></strong> and name it <code class="literal">Teleport Material</code></li><li>Set its <strong class="userinput"><code>Rendering Mode</code></strong> to <strong class="userinput"><code>Transparent</code></strong></li><li>Set its <strong class="userinput"><code>Albedo</code></strong> color and give it a low alpha (such as 30) so it's translucent, such as our pale green (<code class="literal">70</code>, <code class="literal">230</code>, <code class="literal">70</code>, <code class="literal">30</code>)</li><li>Drag the material onto the <code class="literal">TeleportSpawn</code> object</li></ol></div><p>For this exercise, we'll replace the <code class="literal">LookTeleport</code> component on <code class="literal">MeMyselfEye</code> with a new <code class="literal">LookSpawnTeleport</code> one:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In Hierarchy, select <code class="literal">MeMyselfEye</code></li><li>Disable the <code class="literal">LookTeleport</code> component, if present</li><li>Add <strong class="userinput"><code>Component | New Script</code></strong> and name it <code class="literal">LookSpawnTeleport</code></li></ol></div><p>Write the new script as follows:</p><pre class="programlisting">using UnityEngine;

public class LookSpawnTeleport : MonoBehaviour 
{
  private Color saveColor;
  private GameObject currentTarget;

    void Update()
    {
        Transform camera = Camera.main.transform;
        Ray ray;
        RaycastHit hit;
        GameObject hitTarget;

        ray = new Ray(camera.position, camera.rotation * 
        Vector3.forward);
        if (Physics.Raycast(ray, out hit, 10f, 
              LayerMask.GetMask("TeleportSpawn")))
        {
            hitTarget = hit.collider.gameObject;
            if (hitTarget != currentTarget) 
            {
                Unhighlight();
                Highlight(hitTarget);
            }

            if (Input.GetButtonDown("Fire1"))
            {
                transform.position = hitTarget.transform.position;
            }
        }
        else if (currentTarget != null)
        {
            Unhighlight();
        }
    }
}</pre><p>The <code class="literal">Update()</code> function does a Raycast to see if any of the spawn point objects is selected. If so, the object is highlighted (unhighlighting any previous ones). Then, if the <code class="literal">Fire1</code> button is pressed, it teleports the player to that location. </p><p>We add a couple of private helper functions, <code class="literal">Highlight()</code> and <code class="literal">Unhighlight()</code>. The first highlights an object by modifying its material color, making it <span>more</span><a id="id325552363" class="indexterm"></a> opaque (alpha 0.8). Unhighlight restores the original color when you look away:</p><pre class="programlisting">    private void Highlight(GameObject target)
    {
        Material material = target.GetComponent&lt;Renderer&gt;().material;
        saveColor = material.color;
        Color hiColor = material.color;
        hiColor.a = 0.8f; // more opaque
        material.color = hiColor;
        currentTarget = target;
    }

    private void Unhighlight()
    {
        if (currentTarget != null)
        {
          Material material = currentTarget.GetComponent&lt;Renderer&gt;().material;
          material.color = saveColor;
          currentTarget = null;
        }
    }</pre><p>OK, now let's place a few of the markers around the scene:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Drag the <code class="literal">TeleportSpawn</code> object from Hierarchy to your <code class="literal">Prefabs</code> folder in the <strong class="userinput"><code>Project Assets</code></strong></li><li>Duplicate <code class="literal">TeleportSpawn</code> three times</li><li><strong class="userinput"><code>Position</code></strong> one of them at (<code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">-1.5</code>) (the default <code class="literal">MeMyselfEye</code> position)</li><li>Move the others to suitable locations, such as (<code class="literal">2</code>, <code class="literal">0</code>, <code class="literal">3</code>), (<code class="literal">-4</code>, <code class="literal">0</code>, <code class="literal">1</code>), and if you have the Overlook, (<code class="literal">3.5</code>, <code class="literal">2.5</code>, <code class="literal">0</code>)</li></ol></div><p>Alright! Press <strong class="userinput"><code>Play</code></strong>. When you look at a spawn point, it highlights. When you press the <code class="literal">Fire1</code> button, you teleport to the location.</p><p>It may be useful to add a reticle (small cursor) at the center of your camera view to help focus the player's attention on the teleport objects, as we did in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>World Space UI,</em></span> under the topic <span class="emphasis"><em>The reticle cursor</em></span>.</p><p>Although the teleport works, it may be nice if it also sets your view direction. One way to do this is to carefully place the <code class="literal">TeleportSpawn</code> objects facing the direction we want the player to face, and setting the player's transform rotation, in addition to position.</p><p>To give a visual clue for the direction the spawn point is facing, we'll add a graphic. We have included an image file, <code class="literal">flip-flops.png</code>, with this book. Otherwise, use anything that indicates a forward direction. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the <code class="literal">flip-flops.png</code> texture by dragging it into your <code class="literal">Project Textures</code> folder (or navigating to <strong class="userinput"><code>Import New Asset...</code></strong>).</li><li>Create a new material in the Material folder and name it <code class="literal">FlipFlops</code>.</li><li>Drag the <code class="literal">flip-flops</code> texture onto the <code class="literal">FlipFlops</code> material's <strong class="userinput"><code>Albedo</code></strong> map and choose <strong class="userinput"><code>Rendering Mode</code></strong> as <strong class="userinput"><code>Cutout</code></strong>.</li><li>Select the <code class="literal">TeleportSpawn</code> object in <strong class="userinput"><code>Hierarchy</code></strong>.</li><li>Create a child <strong class="userinput"><code>Quad</code></strong> object (right-click <strong class="userinput"><code>Create</code></strong> |<strong class="userinput"><code> <strong class="userinput"><code>3D Object</code></strong> </code></strong>|<strong class="userinput"><code> <strong class="userinput"><code>Quad</code></strong></code></strong>).</li><li>Drag the <code class="literal">FlipFlops</code> material onto the <code class="literal">Quad</code>.</li><li>Set the Quad's <strong class="userinput"><code><strong class="userinput"><code>Transform</code></strong> <strong class="userinput"><code>Position</code></strong></code></strong> to (<code class="literal">0</code>, <code class="literal">.01</code>, <code class="literal">0</code>) and its <strong class="userinput"><code>Rotation</code></strong> to (<code class="literal">90</code>, <code class="literal">0</code>, <code class="literal">0</code>) so that it lies flat on the ground plane.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Select the parent <code class="literal">TeleportSpawn</code> object and in Inspector, press <strong class="userinput"><code>Apply</code></strong> to save these changes to the prefab. Now all the spawns will have feet. </li><li>Note that for the one up on the Overlook, you can adjust its Quad so it's visible from below, such as <strong class="userinput"><code>Position</code></strong> (<code class="literal">0</code>, <code class="literal">-0.2</code>, <code class="literal">0</code>) and <strong class="userinput"><code>Rotation</code></strong> (<code class="literal">-90</code>, <code class="literal">0</code>, <code class="literal">180</code>)</li></ol></div><p>The modification to our script to <span>apply</span><a id="id325552677" class="indexterm"></a> the rotation is trivial:</p><pre class="programlisting">            if (Input.GetButtonDown("Fire1"))
            {
                transform.position = hitTarget.transform.position;
                transform.rotation = hitTarget.transform.rotation;
            }</pre><p>There it is, a gaze-based teleportation system with predefined spawn points, as shown here in the <strong class="userinput"><code>Scene</code></strong> window:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/736614a0-33ed-443f-bfc4-5457f5de79ba.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec105"></a>Other teleport considerations</h3></div></div></div><p>There's a lot more that can <span>be</span><a id="id325552711" class="indexterm"></a> said and done with teleportation. You may prefer to select the location using hand controllers rather than gaze. It is common to show the teleport pointer using an arced laser beam (using a Bezier curve). The teleport spawn point is often rendered using a glow or fiery effect. Many of these features have already been built and provided using higher-level VR toolkits (see next topic).</p><p>Blink teleport is a technique that does a fade-out fade-in between the change in player position. It is said to provide an additional degree of comfort. We won't show the code here, but there are several techniques for implementing fades for VR, such as creating a screen-space canvas that covers the entire <span>camera</span><a id="id325552722" class="indexterm"></a> with a black panel, and lerping its alpha channel as it fades (see <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html" target="_blank">https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html</a>). Some have even found fading with a literal blink effect is quite natural, where you rapidly fade out from top to bottom, and fade in bottom to top, like an eyelid closing and opening.</p><p>Another technique is to provide a third-person view of the scene from above, sometimes called a <span class="strong"><strong>mini-map</strong></span>, <span class="strong"><strong>god view</strong></span><span class="emphasis"><em>,</em></span> or <span class="strong"><strong>dollhouse view</strong></span>. From <span>this</span><a id="id325552753" class="indexterm"></a> perspective, the player could point to a new <span>location</span><a id="id325552759" class="indexterm"></a> to teleport. This <span>mini</span><a id="id325552765" class="indexterm"></a> version of the scene could be an object the player uses as a tool in the main scene, or you transition to this view mode during the teleportation selection process.</p><p>You can also teleport to a different scene. Combined with the blink fade in/out, you call <code class="literal">SceneManager.LoadScene("OtherSceneName")</code> rather than simply changing the transform position. Note, you must add the other scene to the <strong class="userinput"><code>Build Settings Scenes to Build</code></strong> list (see <a class="ulink" href="https://github.com/thestonefox/VRTK" target="_blank">https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html</a>). </p><p>Clever use of teleportation and the player's direction can lead to efficient use of limited play space and give the perception of the VR space being much larger than actually in real life. For example, in room-scale VR, if you have the player walk toward the edge of the play space and enter an elevator (teleport), she could be facing the back of the elevator going in and must turn around when the doors open on the new level and can now physically walk forward. In fact, infinite corridors and connected rooms could be implemented this way while maintaining player immersion.</p></div></div>