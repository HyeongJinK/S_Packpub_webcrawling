<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch12lvl1sec105"></a>Syncing objects and properties</h2></div></div><hr /></div><p>Let's play ball! Back in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Playing With Physics And Fire</em></span>, we implemented various ball games in VR. Now, we have the means to make a multiplayer one. We will <span>make</span><a id="id325552068" class="indexterm"></a> a game similar to the <span class="emphasis"><em>Headshot</em></span> game, which uses your head as the paddle. But after this exercise, feel free to go and build multiplayer versions of the <span class="emphasis"><em>Paddle Ball</em></span> and/or <span class="emphasis"><em>Shooter Ball</em></span> games, which use a hand controller to hold and move a paddle to hit or deflect the ball.</p><p>Also, since the objective here is to focus on the multiplayer networking considerations, we will leave out some details covered in the earlier chapter, such as sound effects, particles, and object pooling.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec177"></a>Setting up the headshot ball game</h3></div></div></div><p>First, we'll add the cube <span>paddle</span><a id="id325552096" class="indexterm"></a> to the Avatar head as the one and only Collider on the Avatar:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Drag a copy of the <code class="literal">Avatar</code> prefab into your <strong class="userinput"><code>Hierarchy</code></strong> for editing</li><li>For each of its children (<code class="literal">Head, Glasses</code>), disable the <strong class="userinput"><code>Collider</code></strong> if present</li><li>Create a new cube child of <code class="literal">Avatar</code> (<strong class="userinput"><code>Create | 3D Object | Cube</code></strong>) and name it <code class="literal">CubePaddle</code></li><li>Reset its <strong class="userinput"><code>Transform</code></strong> and set its <strong class="userinput"><code>Scale</code></strong> to (<code class="literal">0.5, 0.5, 0.5</code>)</li><li>Disable the Cube's <strong class="userinput"><code>Mesh Renderer</code></strong></li><li>Apply the Avatar changes back to its prefab (click <strong class="userinput"><code>Apply</code></strong> in Inspector)</li><li>Delete it from <strong class="userinput"><code>Hierarchy</code></strong></li></ol></div><p>Now, we'll add a <code class="literal">GameController</code> object and a script that serves balls to the avatar at fixed intervals:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create an <strong class="userinput"><code>Empty</code></strong> game object at the <strong class="userinput"><code>Hierarchy</code></strong> root named <code class="literal">GameController</code>, and reset its <strong class="userinput"><code>Transform</code></strong></li><li><strong class="userinput"><code>Add Component | New Script</code></strong> and name it <code class="literal">BallServer</code></li></ol></div><p>Open the script and write it as follows:</p><pre class="programlisting">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BallServer : MonoBehaviour
{
    public GameObject ballPrefab;
    public float startHeight = 10f;
    public float interval = 5f;
    public List&lt;Color&gt; colors = new List&lt;Color&gt;();

    [SerializeField] private int colorId;
    private Transform player;

    void Start()
    {
        colorId = Random.Range(0, colors.Count);
        player = Camera.main.transform;
        StartCoroutine("DropBall");
    }

    IEnumerator DropBall()
    {
        while (true)
        {
            Vector3 position = new Vector3(player.position.x, 
                                   startHeight, player.position.z);
            GameObject ball = Instantiate(ballPrefab, position, 
                                   Quaternion.identity);
            ball.GetComponent&lt;Renderer&gt;().material.color = 
                                                 colors[colorId];
            // (network spawn will go here)

            Destroy(ball, interval * 5);

            yield return new WaitForSeconds(interval);
        }
    }
}</pre><p>In this script, we play a new ball every 5 seconds. Each ball remains in the scene for 25 seconds (<code class="literal">interval * 5</code>). We use a coroutine, with <code class="literal">yield return new WaitForSeconds(interval)</code> to instantiate a new ball each interval. </p><p>We also create a list of <code class="literal">colors</code> and randomly choose one for this player when the game starts. All balls instantiated by this player will be this color. Create the list of colors to pick from:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>On <strong class="userinput"><code>Ball Server</code></strong> component, unfold the <strong class="userinput"><code>Colors</code></strong> parameter</li><li>Set <strong class="userinput"><code>Size</code></strong> to <code class="literal">4</code> or higher</li><li>Define unique colors for each of the <strong class="userinput"><code>Element n</code></strong> color slots</li></ol></div><p>The <strong class="userinput"><code>GameController</code></strong> component will look similar to this in <strong class="userinput"><code>Inspector</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/e343b058-004a-46fc-8023-f5b18870dd94.png" /></div><p>Create a bouncy ball. We'll name it <code class="literal">NetworkBall</code> because in the next section we will share it across the network:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create <strong class="userinput"><code>3D Object | Sphere</code></strong>, name it <code class="literal">NetworkBall</code>, and <strong class="userinput"><code>Scale</code></strong> (<code class="literal">0.5, </code><code class="literal">0.5, 0.5</code>)</li><li>On its <strong class="userinput"><code>Sphere Collider</code></strong>, assign the <code class="literal">Bouncy</code> physic material to the <strong class="userinput"><code>Material</code></strong> slot</li><li>Add a <code class="literal">Rigidbody</code> component (<strong class="userinput"><code>Add Component | Physics | Rigidbody</code></strong>)</li><li>Drag <code class="literal">NetworkBall</code> into your <strong class="userinput"><code>Project Assets</code></strong> <span class="emphasis"><em>Prefabs</em></span> folder to create a prefab, and delete the object from <strong class="userinput"><code>Hierarchy</code></strong></li><li>Drag a <code class="literal">NetworkBall</code> from <span class="emphasis"><em>Prefabs</em></span> onto <strong class="userinput"><code>Ball Prefab</code></strong> slot of the GameController's <strong class="userinput"><code>BallServer</code></strong></li></ol></div><p>Press <strong class="userinput"><code>Play</code></strong>. Locally, you'll get served balls from above, and <span>you</span><a id="id325552244" class="indexterm"></a> can deflect them with your head, just like we did in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Playing with Physics and Fire</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec178"></a>Spawning the ball over the network</h3></div></div></div><p>Other players in our networked game need to see the same balls <span>you</span><a id="id325552266" class="indexterm"></a> do. There are several steps to getting this going:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">First, when we instantiate a ball locally, we need to tell the network to also spawn it for all the players</li><li style="list-style-type: disc">When the ball moves, is bounced or hit, its Transform must be updated for all the players</li><li style="list-style-type: disc">When the ball's life is done, it must be destroyed for all the players</li></ul></div><p>In our present single-player version of the game, we instantiate new balls in the <code class="literal">BallServer</code> script. Let's make it networked:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">BallServer</code> script for editing</li><li>Add <code class="literal">using UnityEngine.Networking;</code> namespace at the top</li><li>Add a call to <code class="literal">NetworkServer.Spawn(ball);</code> once we have an instance created</li></ol></div><p>Then, we must register the <code class="literal">NetworkBall</code> prefab with the <code class="literal">NetworkManager</code> to inform it the prefab is spawnable:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select <code class="literal">NetworkController</code> in <strong class="userinput"><code>Hierarchy</code></strong></li><li>In <strong class="userinput"><code>Inspector</code></strong>, unfold the <strong class="userinput"><code>Spawn Info</code></strong> parameters</li><li>Click + in the <strong class="userinput"><code>Registered Spawnable Prefabs</code></strong> list</li><li>Drag a copy of <code class="literal">NetworkBall</code> onto the spawnable prefab <strong class="userinput"><code>Game Object</code></strong> slot</li></ol></div><p>The <strong class="userinput"><code>Network Manager</code></strong> component now looks like the following:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/7fad37e4-6303-45a3-b903-0db31cb7c911.png" /></div><p>There's one other thing that we did not handle yet: destroying ball instances. In the standalone version, we called <code class="literal">Destroy(ball, interval*5)</code> to destroy the ball after the given time. For network spawned objects, you will call <code class="literal">Network.Destroy(ball)</code> instead. However, there is not an equivalent version with a timer argument. You could write a countdown timer for it in BallServer, or use some other strategy for determining when its life cycle is complete and it can be destroyed (such as a DestroySelf script on the ball prefab itself) that runs locally.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec179"></a>Synchronizing the ball transform</h3></div></div></div><p>Unity Networking has a <span>component</span><a id="id325553070" class="indexterm"></a> to share this data between players,<code class="literal">Network Transform</code>, which we used earlier for syncing the Avatar head. Now, we'll use it for the ball:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select the <code class="literal">NetworkBall</code> prefab in <strong class="userinput"><code>Project Assets.</code></strong></li><li><strong class="userinput"><code>Add Component | Network Transform.</code></strong></li><li>Ensure the <strong class="userinput"><code>Transform Sync Mode</code></strong> is set to <strong class="userinput"><code>Sync Rigidbody/3D.</code></strong></li><li>Adding Network Transform will add a <strong class="userinput"><code>Network Identity</code></strong> for you. Check its <strong class="userinput"><code>Local Player Authority</code></strong> checkbox. </li></ol></div><p>The Network Transform parameters for <code class="literal">NetworkBall</code> are shown here:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/a2682b14-3586-4e75-a6fd-6a744e20bb26.png" /></div><p>Run two copies of your project now. <span class="emphasis"><em>Voila!</em></span> When you connect the games on the network, the player's balls will be visible to all other players (<span class="emphasis"><em>nsfw? Keep it clean guys</em></span>). The movement of each ball in the local game will control its transform on all the other game instances.</p><p>Note that Unity is providing optimizations to limit the amount of data and frequency of updates while ensuring each player continues to see the same thing. For example, in the Network Transform, while <span>you</span><a id="id325553141" class="indexterm"></a> can sync an object's Transform position and rotation each update, you can also specify movement and velocity thresholds that signal when a sync is required. Perhaps more significant, you can choose what to sync. Instead of the Transform values themselves, you can sync changes in the Rigidbody physics (velocity, angular velocity, and so on), which happen much less often, and let each player's local game calculate the corresponding new Transform. This is the option we chose for the NetworkBall.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec180"></a>State variable synchronization</h3></div></div></div><p>When we spawn an object over the network, it uses the prefab object we registered with the Network Manager. So the spawned balls all have the default color, not the one we set locally when the object was instantiated in BallServer. We'll use this as an opportunity to show how to synchronize other properties.</p><p>The example is a little contrived, but let's say we want the object <span>color</span><a id="id325553158" class="indexterm"></a> to be a state variable. (You could add others too, such as power, health, magic and so on.) We will write a script that tells the network to sync the properties across the network, if and when its value is changed.</p><p>The compiler <code class="literal">[SyncVar]</code> attribute identifies the property we want to sync and sets up an <span class="emphasis"><em>observer</em></span>. If we include a <code class="literal">hook</code>, that function will be called by the observer when the value changes.</p><p>On the <code class="literal">NetworkBall</code> prefab, create a new script named <code class="literal">StateVariables</code> and write it as follows:</p><pre class="programlisting">using UnityEngine;
using UnityEngine.Networking;

public class StateVariables : NetworkBehaviour
{
    [SyncVar(hook = "OnColorChanged")]
    public Color color;

    public void SetColor(Color changedColor)
    {
        color = changedColor;
        GetComponent&lt;Renderer&gt;().material.color = color;
    }

    void OnColorChanged(Color networkColor)
    {
        GetComponent&lt;Renderer&gt;().material.color = networkColor;
    }
}</pre><p>The class derives from <code class="literal">NetworkBehaviour</code>. We declare <code class="literal">color</code> with a <code class="literal">SyncVar</code> attribute. We provide a public setter function, <code class="literal">SetColor</code>, that can be called from other game objects as normal. Likewise, when the <code class="literal">color</code> variable is changed, it will be synchronized over the network. Remote copies running your game will call <code class="literal">OnColorChanged</code> to change that instance of the object too.</p><p>Now, we just need to modify the <code class="literal">BallServer</code> to set the color using this interface rather than modifying the material color directly. Modify the loop in the <code class="literal">DropBall</code> function to read as follows:</p><pre class="programlisting">IEnumerator DropBall()
{
    while (true)
    {
        Vector3 position = new Vector3(player.position.x, startHeight, player.position.z);
        GameObject ball = Instantiate(ballPrefab, position, Quaternion.identity);
        NetworkServer.Spawn(ball);
<span class="strong"><strong>        ball.GetComponent&lt;StateVariables&gt;().SetColor( colors[colorId] );</strong></span>
        Destroy(ball, interval * 5);

        yield return new WaitForSeconds(interval);
    }
}</pre><p>Now the server will not just spawn balls on the clients, but will then send its <span>color</span><a id="id325553234" class="indexterm"></a> property setting as well.</p><p>Here is a screenshot of live two-player HeadShot gameplay on our makeshift game court:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/df05dbe5-a645-4566-bf74-aa8768eb18aa.png" /></div><p>Using this basic pattern, you could extend this script to set and sync other variables representing the state of individual objects (heath, power, and so on) or the game itself (score, who's turn it is to serve, and so on).</p></div></div>