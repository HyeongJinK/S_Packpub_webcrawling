<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec114"></a>Optimizing your code</h2></div></div><hr /></div><p>Another area prone to performance <span>problems</span><a id="id325317274" class="indexterm"></a> and ripe for <span>optimization</span><a id="id325317283" class="indexterm"></a> is your script code. Throughout this book, we have used various coding best practices, without necessarily explaining why. (On the other hand, some examples in this book are not necessarily efficient, in favor of simplicity and explanation.) In <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Playing with Physics and Fire</em></span>, for example, we implemented an object pool memory manager to avoid repeatedly instantiating and destroying game objects that causes memory <span class="strong"><strong>garbage collection</strong></span> (<span class="strong"><strong>GC</strong></span>) issues, which in turn slows down your app. </p><p>In general, try to avoid code that repeats a lot of computation over and over. Try to pre-compute as much work as you can and store the partial results in variables. </p><p>At some point, you may have to use a profiling tool to see how your code is performing under the hood. If the <strong class="userinput"><code>Profiler</code></strong> indicates that a large amount of time is spent in the scripts that you've written, you should consider another way to refactor the code so that it's more efficient. Often, this is related to memory management, but it could be math or physics. (See <span><a class="ulink" href="http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html" target="_blank">http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html</a>.)</span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip138"></a>Note</h3><p>Please follow coding best practices, but otherwise avoid going out of your way with premature optimization. One mistake people make is putting too much effort into optimizing areas of their code that don't need it, sacrificing readability and maintainability in the process. Use the Profiler to analyze where the performance bottlenecks are and focus your optimization efforts there first.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec194"></a>Understanding the Unity life cycle</h3></div></div></div><p>Like all video game engines, when your game runs, Unity is <span>executing</span><a id="id325547513" class="indexterm"></a> a giant loop, repeating over and over each frame update. Unity provides many <span class="emphasis"><em>hooks</em></span> to tap into events at just about every step in the game loop. Depicted below is the life cycle flowchart, taken from the Unity Manual page Execution Order of Event Functions (<a class="ulink" href="https://docs.unity3d.com/Manual/ExecutionOrder.html" target="_blank">https://docs.unity3d.com/Manual/ExecutionOrder.html</a>). The two event functions you are most familiar with, <code class="literal">Start</code> and <code class="literal">Update</code>, are highlighted with the red arrows. The green dots highlight a number of other events we'll reference in this conversation:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/234f6739-3fd6-478f-92f7-ac300b0c111a.png" /></div><p>Starting at the top of this chart, when your game starts, each GameObject's component, which is derived from the <code class="literal">MonoBehaviour</code> class, will be woke with a call to <code class="literal">Awake</code>. Unless you need to use <code class="literal">Awake</code> or <code class="literal">OnEnable</code>, we typically initialize objects in <code class="literal">Start</code>. Skipping down to the Game Logic section, <code class="literal">Update</code> is called on each frame iteration. Note the loop line/arrows. (The physics engine has its own loop timing, for dealing with RigidBodies, which may be more frequent than the frame updates. You hook into it with <code class="literal">FixedUpdate</code>.) The <code class="literal">OnDestroy</code> event is called to decommission the object.</p><p>For the current discussion, the important thing to notice is which events are within the game loop, and which are outside. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec195"></a>Writing efficient code</h3></div></div></div><p>We want to keep all of the code <span>within</span><a id="id325552103" class="indexterm"></a> the game loop (such as<code class="literal">FixedUpdate</code>, <code class="literal">Update</code>, and <code class="literal">LateUpdate</code>) as lean as possible. Move any initialization into <code class="literal">Awake</code>, <code class="literal">OnEnable</code>, or <code class="literal">Start</code>. We also want to precompute and cache any computationally expensive work in the initialization functions.</p><p>For example, a call to <code class="literal">GetComponent</code> is expensive. As we've seen in many scripts in this book, it is a best practice to get references to any components that Update will need, outside the game logic loop, in <code class="literal">Start</code>. The following code, used in <a class="link" href="#" linkend="ch07">Chapter 7</a>, Lo<span class="emphasis"><em>comotion and Comfort</em></span>, gets the <code class="literal">CharacterController</code> component in <code class="literal">Start</code>, caches it in a variable, and then references it in <code class="literal">Update</code>, rather than calling <code class="literal">GetComponent</code> every frame:</p><pre class="programlisting">public class GlideLocomotion : MonoBehaviour 
{
    private Camera camera;
    private CharacterController controller;

    void Start ()
    {
        camera = Camera.main;
        character = GetComponent&lt;CharacterController&gt;();
    }

    void Update()
    {
        character.SimpleMove(camera.transform.forward * 0.4f);
    }
}</pre><p>Any time you declare an <code class="literal">Update()</code> function in your script (or any other event function), Unity will call it, even if it's empty. Therefore, you should remove any unused <code class="literal">Updates</code> even though they're part of the default template when you create a new C# <code class="literal">MonoBehaviour</code> script.</p><p>Likewise, if you have code in <code class="literal">Update</code> that does not need to be called every frame, turn off the calculations using a state variable (and an <code class="literal">if</code> statement) when they are not needed, for example:</p><pre class="programlisting">    public bool isWalking;

    void Update()
    {
        if (isWalking)
        {
            character.SimpleMove(camera.transform.forward * 0.4f);
        }
    }</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec196"></a>Avoiding expensive API calls</h3></div></div></div><p>Other than moving expensive API calls out of <span>Update</span><a id="id325563579" class="indexterm"></a> into an initialization function, there are some APIs that should be avoided altogether if possible. Here are a few.</p><p>Avoid <code class="literal">Object.Find()</code>. To obtain a reference to a game object in your scene, do not call <code class="literal">Find</code>. Not only is <code class="literal">Find</code> by name expensive, as it must search the Hierarchy tree, but it is brittle (might break) if you rename the object it is looking for. If you can, define a <code class="literal">public</code> variable to reference the object and associate it in the Editor Inspector. If you must find the object at runtime, use Tags or perhaps Layers to limit the search to a known fixed set of candidates. </p><p>Avoid <code class="literal">SendMessage()</code>. The legacy use of <code class="literal">SendMessage</code> is computationally expensive (because it makes use of runtime <span class="emphasis"><em>reflection</em></span>). To trigger functions in another object, use Unity <strong class="userinput"><code>Events</code></strong> instead. </p><p>Avoid fragmenting memory and garbage collection. Temporary allocations of data and objects may cause memory to fragment. Unity will periodically go through the memory <span>heap</span><a id="id325578451" class="indexterm"></a> to consolidate free blocks, but this is expensive and can cause frames to skip in your app.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip139"></a>Note</h3><p>For more suggestions and a deeper discussion, see the Unity best practices guide, <span class="emphasis"><em>Understanding Optimization in Unity</em></span> (<a class="ulink" href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html" target="_blank">https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html</a>).</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note140"></a>Note</h3><p>Another area of optimization is Unity Physics. In previous chapters, we briefly mentioned using layers for ray casting, to limit the objects Unity needs to search, for example, for gaze-based selection in VR. Likewise, physics collision detection can be limited to objects on specific layers by defining a Layer Collision Matrix. See the manual page on Optimizing Physics Performance (<a class="ulink" href="https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html" target="_blank">https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html</a>) and the Physics Best Practices tutorial (<a class="ulink" href="https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices" target="_blank">https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices</a>).</p></div></div></div>