<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec117"></a>Summary</h2></div></div><hr /></div><p>Latency and low frames-per-second rates are not acceptable and can cause motion sickness in VR. We are bound by the capabilities and limitations of the hardware devices we run on and their SDKs. In this chapter, we dove into some of the more technical aspects of making great VR, considering four separate areas that affect performance: the artwork, the scene, the code, and the rendering pipeline. </p><p>We started the chapter by introducing the built-in Unity Profiler and Stats windows, our primary weapons in this battle. To illustrate the impacts of designing models and materials, we built a scene with 1000 high-poly Sunglasses with transparent lenses, examined the performance stats, and then tried several ways to improve the frame rate: decimating the models (making them low poly), removing transparency in the materials, and managing level of detail (LOD) in the scene. Then, we considered things we can do at the scene level, using static objects, baked lightmaps, and occlusion culling.</p><p>Next, we looked at basic practices for optimizing your C# scripts. A key to this is understanding the Unity life cycle, game loop, and expensive API functions, encouraging you to make the frame <code class="literal">Update</code> processing as lean as possible. Then, we looked at the rendering pipeline, gaining some insight into how it works and how to use recommended <strong class="userinput"><code>Quality</code></strong>, <strong class="userinput"><code>Graphics</code></strong> and <strong class="userinput"><code>Player</code></strong> settings, VR optimized shaders, and runtime tools to analyze and improve performance.   </p><p>It should be abundantly clear by now that developing for VR has many facets (pun intended). You work hard to create an awesome scene with beautiful models, textures, and lighting. You try to provide a thrilling interactive experience for your visitors. At the same time, you should also be thinking about the requirements of your target platform, rendering performance, frames per second, latency, and motion sickness. It's never too early to focus on performance. It's a mistake to start too late. Follow recommended best practices that are easy to implement, while keeping your code and object hierarchy clean and maintainable. However, take a thoughtful, scientific approach to troubleshooting and performance tuning, using the Profiler and other tools to analyze your project so you can zero in on the root causes rather than spend time on areas that may yield little net effect.</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>We developers rapidly become immune to all but the most obvious rendering errors, and as a result we are the worst people at testing our own code. It introduces a new and exciting variation of the coder's defense that "it works on my machine" - in this case, "it works for my brain." -Tom Forsyth, Oculus</em></span></p></blockquote></div><p>Developing for VR is a moving target. The platform hardware, software SDKs, and the Unity 3D engine itself are all changing and improving rapidly. Books, blog posts, and YouTube videos can be readily superseded as products improve and new developer insights emerge. On the other hand, great strides have already been made to establish best practices, preferred Unity settings, and optimized device SDKs that address the needs of VR developers. </p><p>As VR goes mainstream, it is coming into its own as a new medium for expression, communication, education, problem solving, and storytelling. Your grandparents needed to learn to type and read. Your parents needed to learn PowerPoint and browse the web. Your children will build castles and teleport between virtual spaces. VR will not replace the real world and our humanity; it will enhance it.</p></div>