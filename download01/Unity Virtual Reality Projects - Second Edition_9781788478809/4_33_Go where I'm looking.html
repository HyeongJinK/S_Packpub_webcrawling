<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec38"></a>Go where I'm looking</h2></div></div><hr /></div><p>In this next script, instead of being random, we'll send Ethan to <span>wherever</span><a id="id325578215" class="indexterm"></a> we look. In Unity, this is <span>accomplished</span><a id="id325578224" class="indexterm"></a> by using <span class="strong"><strong>ray casting. </strong></span>It's like shooting a ray from the camera and seeing what it hits (for more information, visit <a class="ulink" href="http://docs.unity3d.com/Manual/CameraRays.html" target="_blank"><span>http://docs.unity3d.com/Manual/CameraRays.html</span></a>).</p><p>We're going to create a new script, which will be attached to <code class="literal">WalkTarget</code> like before, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Select the <code class="literal">WalkTarget</code> object in the <strong class="userinput"><code>Hierarchy</code></strong> panel or the <strong class="userinput"><code>Scene</code></strong> view.</li><li>In its <strong class="userinput"><code>Inspector</code></strong> panel, click on the <strong class="userinput"><code>Add Component</code></strong> button.</li><li>Select <strong class="userinput"><code>New Script</code></strong>.</li><li>Name it <code class="literal">LookMoveTo</code>.</li><li>Ensure that the <strong class="userinput"><code>C Sharp</code></strong> language is selected.</li><li>Click on <strong class="userinput"><code>Create</code></strong> and <strong class="userinput"><code>Add</code></strong>.</li></ol></div><p>This should create a script component on the <code class="literal">WalkTarget</code> object. Double-click on it to open it in your code editor.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip38"></a>Note</h3><p>This <code class="literal">LookMoveTo</code> script replaces the <code class="literal">RandomPosition</code> one we created before. Disable the <code class="literal">RandomPosition</code> component of <code class="literal">WalkTarget</code> before proceeding.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec61"></a>The LookMoveTo script</h3></div></div></div><p>In our script, each time <code class="literal">Update()</code> is called, we'll read <span>where</span><a id="id325555193" class="indexterm"></a> the camera is pointing (by using its transform position and rotation), cast a ray in that direction, and ask Unity to <span>tell</span><a id="id325555201" class="indexterm"></a> us where it hits the ground plane. Then, we'll use this location to set the <code class="literal">WalkTarget</code> object's position.</p><p>Here's the full <code class="literal">LookMoveTo.cs</code> script:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
public class LookMoveTo : MonoBehaviour { 
  public GameObject ground; 
 
  void Update () { 
    Transform camera = Camera.main.transform; 
    Ray ray; 
    RaycastHit hit; 
    GameObject hitObject; 
 
    Debug.DrawRay (camera.position, 
      camera.rotation * Vector3.forward * 100.0f); 
 
    ray = new Ray (camera.position, 
      camera.rotation * Vector3.forward); 
    if (Physics.Raycast (ray, out hit)) { 
      hitObject = hit.collider.gameObject; 
      if (hitObject == ground) { 
        Debug.Log ("Hit (x,y,z): " + hit.point.ToString("F2")); 
        transform.position = hit.point; 
      } 
    } 
  } 
 
} </pre><p>Let's go through the script a bit at a time.</p><pre class="programlisting">public GameObject ground; </pre><p>The first thing the script does is declare a variable for the <code class="literal">GroundPlane</code> object.
Since it's <code class="literal">public</code>, we can use the Unity editor to assign the actual object:</p><pre class="programlisting">  void Update () { 
    Transform camera = Camera.main.transform; 
    Ray ray; 
    RaycastHit hit; 
    GameObject hitObject; </pre><p>Inside <code class="literal">Update()</code>, we define a few local variables, <code class="literal">camera</code>, <code class="literal">ray</code>, <code class="literal">hit</code>, and <code class="literal">hitObject</code>, which have datatypes that are required by the Unity functions that we're going to use.</p><p><code class="literal">Camera.main</code> is the current active camera object (that is, tagged as <code class="literal">MainCamera</code>). We get its current transform, which will be assigned to the camera variable:</p><pre class="programlisting">    ray = new Ray (camera.position, 
      camera.rotation * Vector3.forward); </pre><p>Ignoring the handy <code class="literal">Debug</code> statements for a moment, we first determine the ray from the camera using <code class="literal">new Ray()</code>.</p><p>A <span class="strong"><strong>ray</strong></span> can be <span>defined</span><a id="id325567592" class="indexterm"></a> by a starting position in the <strong class="userinput"><code>x</code></strong>, y, and z space and a <span>direction</span><a id="id325567602" class="indexterm"></a> vector. A <span class="strong"><strong>direction vector</strong></span> can be defined as the relative offsets from a 3D starting point to some other point in space. The forward direction, where <strong class="userinput"><code>z</code></strong> is positive, is (<code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">1</code>). Unity will do the math for us. So, if we take a unit vector (<code class="literal">Vector3.forward</code>), multiply it by a three-axis rotation (<code class="literal">camera.rotation</code>), and scale it by a length (<code class="literal">100.0f</code>), we'll get a ray pointing in the same direction as the camera, measuring 100 units long:</p><pre class="programlisting">if (Physics.Raycast (ray, out hit)) {</pre><p>Then, we cast the ray and see if it hit anything. If so, the <code class="literal">hit</code> variable will
now contain more details about what was hit, including the specific object in<code class="literal">hit.collider.gameObject</code>. (The <code class="literal">out</code> keyword means that the <code class="literal">hit</code> variable value is filled in by the <code class="literal">Physics.Raycast()</code> function.)</p><pre class="programlisting">      if (hitObject == ground) { 
        transform.position = hit.point; 
      } </pre><p>We check whether the ray hit the <code class="literal">GroundPlane</code> object and if so, we'll assign that as the position to move the <code class="literal">WalkTarget</code> object to the <code class="literal">hit</code> location.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"></a>Note</h3><p>The <code class="literal">==</code>compare operator should not to be confused with <code class="literal">=</code>, which is the assignment operator.</p></div><p>This script contains two <code class="literal">Debug</code> statements, which are a useful way to monitor what's going on while a script is running in Play Mode. <code class="literal">Debug.DrawRay()</code> will draw the given ray in the <strong class="userinput"><code>Scene</code></strong> view so that you can actually see it, and <code class="literal">Debug.Log()</code> will dump the current hit position to the console if and when there's a hit.</p><p>Save the script, switch into the Unity editor, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>With <code class="literal">WalkTarget</code> selected, in the <code class="literal">Inspector</code> panel, the <code class="literal">LookMoveTo</code> script component now has a field for the <code class="literal">GroundPlane</code> object.</li><li>From the <strong class="userinput"><code>Hierarchy</code></strong> panel, select and drag the <code class="literal">GroundPlane</code> game object onto the <strong class="userinput"><code>Ground</code></strong> field.</li></ol></div><p>Save the scene. The script pane looks like this:</p><div class="mediaobject"><img src="/graphics/9781788478809/graphics/3a98a728-647a-4512-9ea3-d598cf2531ae.png" /></div><p>Then, click the <span class="emphasis"><em>Play</em></span> button. Ethan should follow our gaze (at his own pace).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"></a>Note</h3><p>In projects with more than a few objects with colliders, in order to optimize the performance of your raycast, it is advised to place the objects on a specific layer (for example, named "Raycast") and then add that layer mask to the Raycast call. For example, if "Raycast" is layer 5, <code class="literal">int layerMask = 1 &lt;&lt; 5</code>, then <code class="literal">Physics.Raycast(ray, out hit, maxDistance, layerMask);</code>. See <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Physics.Raycast.html" target="_blank">https://docs.unity3d.com/ScriptReference/Physics.Raycast.html</a> and <a class="ulink" href="https://docs.unity3d.com/Manual/Layers.html" target="_blank">https://docs.unity3d.com/Manual/Layers.html</a> for details and examples.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec62"></a>Adding a feedback cursor</h3></div></div></div><p>Given it's not always obvious <span>where</span><a id="id325581604" class="indexterm"></a> your gaze is <span>hitting</span><a id="id325581612" class="indexterm"></a> the ground plane, we'll now add a cursor to the scene. It's really easy because what we've been doing is moving around an invisible, empty <code class="literal">WalkTarget</code> object. If we give it a mesh by using the following steps, it'll be visible:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In the <strong class="userinput"><code>Hierarchy</code></strong> panel, select the <code class="literal">WalkTarget</code> object.</li><li>Right-click on the mouse and navigate to <strong class="userinput"><code>3D Object</code></strong> | <strong class="userinput"><code>Cylinder</code></strong>. This will create a cylindrical object parented by <code class="literal">WalkTarget</code>. (Alternatively, you can use the <strong class="userinput"><code>GameObject</code></strong> tab on the main menu bar, and then drag and drop the object onto <code class="literal">WalkTarget</code>.)</li><li>Ensure that we're starting with the reset values of transform by clicking on <strong class="userinput"><code>Reset</code></strong> from the <span class="emphasis"><em>gear</em></span> icon menu in the <strong class="userinput"><code>Transform</code></strong> pane.</li><li>Select the new cylinder and in its <strong class="userinput"><code>Inspector</code></strong> panel, change the <strong class="userinput"><code>Scale</code></strong> to (<code class="literal">0.4</code>, <code class="literal">0.05</code>, <code class="literal">0.4</code>). This will create a flat disk with a diameter of <code class="literal">0.4</code>.</li><li>Disable its <strong class="userinput"><code>Capsule Collider</code></strong> by unchecking that checkbox.</li><li>As a performance optimization, in <strong class="userinput"><code>Mesh Renderer</code></strong> you can also disable <strong class="userinput"><code>Cast Shadows</code></strong>, <strong class="userinput"><code>Receive Shadows</code></strong>, <strong class="userinput"><code>Use Light Probes</code></strong>, and <strong class="userinput"><code>Reflection Probes</code></strong>.</li></ol></div><p>Now, try to play again. The cursor disk follows our gaze.</p><p>If you want, decorate the disk better with a colored material. Better yet, find an appropriate texture. For example, we used a grid texture in <a class="link" href="#" linkend="ch02"><span>Chapter 2</span></a>, <span class="emphasis"><em>Content, Objects, and Scale</em></span>, for the <code class="literal">GridProjector</code> file (<code class="literal">Standard Assets/Effects/Projectors/Textures/Grid.psd</code>). The <code class="literal">CircleCrossHair.png</code> file is provided with the files for this book. Drop the texture onto the cylinder cursor. When you do, set its <strong class="userinput"><code>Shader</code></strong> to <strong class="userinput"><code>Standard</code></strong>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec63"></a>Observing through obstacles</h3></div></div></div><p>In this project, we got Ethan to <span>follow</span><a id="id325590409" class="indexterm"></a> where we're looking by moving the <code class="literal">WalkTarget</code> object to a position on the ground plane determined by raycasting from the camera and seeing where it intersected that plane.</p><p>You may have noticed that the cursor seems to get <span class="emphasis"><em>stuck</em></span> when we slide our gaze over the cube and sphere. That's because the <span class="strong"><strong>physics engine</strong></span> has determined which object is hit first, never getting to the ground plane. In our script, we have the <span>conditional</span><a id="id325594733" class="indexterm"></a> statement <code class="literal">if (hitObject == ground)</code> before moving <code class="literal">WalkTarget</code>. Without it, the cursor would float over any object in 3D space where the cast ray hits something. Sometimes, that's interesting, but in our case, it is not. We want to keep the cursor on the ground. However now, if the ray hits something other than the ground, it doesn't get repositioned and seems <span class="emphasis"><em>stuck</em></span>. Can you think of a way around it? Here's a hint: look up <code class="literal">Physics.RaycastAll</code>. Alright, I'll show you. Replace the body of <code class="literal">Update()</code> with the following code:</p><pre class="programlisting">    Transform camera = Camera.main.transform; 
    Ray ray; 
    RaycastHit[] hits; 
    GameObject hitObject; 
     
    Debug.DrawRay (camera.position, camera.rotation * 
       Vector3.forward * 100.0f);
    ray = new Ray (camera.position, camera.rotation * 
       Vector3.forward); 
    hits = Physics.RaycastAll (ray); 
    for (int i = 0; i &lt; hits.Length; i++) { 
      RaycastHit hit = hits [i]; 
      hitObject = hit.collider.gameObject; 
      if (hitObject == ground) { 
        Debug.Log ("Hit (x,y,z): " + 
           hit.point.ToString("F2")); 
        transform.position = hit.point; 
      } 
    } </pre><p>On calling <code class="literal">RaycastAll</code>, we get back a list, or an array, of hits. Then, we loop
through each one looking for a ground hit anywhere along the path of the ray
vector. Now our cursor will trace along the ground, whether or not there's another object in between.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"></a>Note</h3><p><span class="strong"><strong>Extra challenge</strong></span>: Another more efficient solution is to use the <span class="emphasis"><em>layer system</em></span>. Create a new layer, assign it to the plane, and pass it as an argument to <code class="literal">Physics.raycast()</code>. Can you see why that's much more efficient?</p></div><p></p></div></div>