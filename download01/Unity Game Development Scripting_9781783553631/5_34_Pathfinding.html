<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec37"></a>Pathfinding</h2></div></div><hr /></div><p>Pathfinding<a id="id297" class="indexterm"></a> is how the AI will maneuver around the level. For our AI package, we will be using two different kinds of pathfinding, NavMesh and waypoints. The waypoint system is a common approach to create paths for AI to move around the game level. To allow our AI to move through our level in an intelligent manner, we will use Unity's NavMesh component.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec74"></a>Creating paths using the waypoint system</h3></div></div></div><p>Using<a id="id298" class="indexterm"></a> waypoints to create paths is <a id="id299" class="indexterm"></a>a common practice in game design, and it's simple too. To<a id="id300" class="indexterm"></a> sum it up, you place objects or set locations around the game world; these are your waypoints. In the code, you will place all of your waypoints that you created in a container of some kind, such as a list or an array. Then, starting at the first waypoint, you tell the AI to move to the next waypoint. Once that waypoint has been reached, you send the AI off to another one, ultimately creating a system that iterates through all of the waypoints, allowing the AI to move around the game world through the set paths. Although using the waypoint system will grant our AI movement in the world, at this point, it doesn't know how to avoid obstacles<a id="id301" class="indexterm"></a> that it may come across. That is when <a id="id302" class="indexterm"></a>you need to implement<a id="id303" class="indexterm"></a> some sort of mesh navigation system so that the AI won't get stuck anywhere.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec75"></a>Unity's NavMesh system</h3></div></div></div><p>The next <a id="id304" class="indexterm"></a>step in creating AI pathfinding is to create a <a id="id305" class="indexterm"></a>way for our AI to navigate through the game world intelligently, meaning that it does not get stuck anywhere. In just about every game out there that has a 3D-based AI, the world it inhabits has all sorts of obstacles. These obstacles could be plants, stairs, ramps, boxes, holes, and so on. To get our AI to avoid these obstacles, we will use Unity's NavMesh system, which is built into Unity itself.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec76"></a>Setting up the environment</h3></div></div></div><p>Before we <a id="id306" class="indexterm"></a>can start creating our pathfinding system, we <a id="id307" class="indexterm"></a>need to create a level for our AI to move around in. To do this, I am just using Unity primitive models such as cubes and capsules. For the floor, create a cube, stretch it out, and squish it to make a rectangle. From there, clone it several times so that you have a large floor made up of cubes.</p><p>Next, delete a bunch of the cubes and move some others around. This will create holes in our floor, which will be used and tested when we implement the NavMesh system. To make the floor easy to see, I've created a material in green and assigned it to the floor cubes.</p><p>After this, create a few more cubes, make one really long and one shorter than the previous one but thicker, and the last one will be used as a ramp. I've created an intersection of the really long cube and the thick cube. Then, place the ramp towards the end of the thick cube, giving access to the top of the cubes.</p><p>Our final step in creating our test environment is to add a few waypoints for our AI. For testing purposes, create five waypoints in this manner. Place one in each corner of the level and one in the middle. For the actual waypoints, use the capsule primitive. For each waypoint, add a rigid body component. Name the waypoints as <code class="literal">Waypoint1</code>, <code class="literal">Waypoint2</code>, <code class="literal">Waypoint3</code>, and so on. The name is not all that important for our code; it just makes it easier to distinguish between waypoints in the inspector. Here's what I made for my level:</p><div class="mediaobject"><img src="/graphics/9781783553631/graphics/3631OT_05_02.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec13"></a>Creating the NavMesh</h4></div></div></div><p>Now, we <a id="id308" class="indexterm"></a>will create the navigation mesh for<a id="id309" class="indexterm"></a> our scene. The first thing we will do is select all of the floor cubes. In the menu tab in Unity, click on the <span class="strong"><strong>Window</strong></span> option, and then click on the <span class="strong"><strong>Navigation</strong></span> option at the bottom of the dropdown; this will open up the <span class="strong"><strong>Navigation</strong></span> window. This is what you should be seeing right now:</p><div class="mediaobject"><img src="/graphics/9781783553631/graphics/3631OT_05_03.jpg" /></div><p>By <a id="id310" class="indexterm"></a>default, the <span class="strong"><strong>OffMeshLink Generation</strong></span> option<a id="id311" class="indexterm"></a> is not checked; be sure to check it. What this does is create links at the edges of the mesh allowing it to communicate with any other <span class="strong"><strong>OffMeshLink</strong></span> nearby, creating a singular mesh. This is a handy tool since game levels typically use more than one mesh as a floor.</p><p>The <span class="strong"><strong>Scene</strong></span> filter<a id="id312" class="indexterm"></a> will just show specific objects within the hierarchy view list. Selecting all the objects will show all of your GameObjects. Selecting mesh renderers will only show GameObjects that have the mesh renderer component. Then, finally, if you select terrains, only terrains will be shown in the <span class="strong"><strong>Hierarchy</strong></span> view list.</p><p>The <span class="strong"><strong>Navigation Layer</strong></span> dropdown will allow you to set the area as either <span class="strong"><strong>walkable</strong></span>, <span class="strong"><strong>not walkable</strong></span>, or <span class="strong"><strong>jump accessible</strong></span>. Walkable areas typically refer to floors, ramps, and so on. Non-walkable areas refer to walls, rocks, and other various obstacles.</p><p>Next, click on the <span class="strong"><strong>Bake</strong></span> tab next to the <span class="strong"><strong>Object</strong></span> tab. You should see information that looks like this:</p><div class="mediaobject"><img src="/graphics/9781783553631/graphics/3631OT_05_04.jpg" /></div><p>For <a id="id313" class="indexterm"></a>this chapter, I am leaving all the values at<a id="id314" class="indexterm"></a> their defaults. The <span class="strong"><strong>Radius</strong></span> property is used to determine how close <a id="id315" class="indexterm"></a>to the walls the navigation mesh will exist. <span class="strong"><strong>Height</strong></span> determines how much vertical space is needed for the AI agent to be able to walk on the navigation mesh. <span class="strong"><strong>Max Slope</strong></span> is the maximum angle that the AI is allowed to travel on for ramps, hills, and<a id="id316" class="indexterm"></a> so on. The <span class="strong"><strong>Step Height</strong></span> property is used to determine how high the AI can step up onto surfaces higher than the ground level.</p><p>For <span class="strong"><strong>Generated Off Mesh Links</strong></span>, the properties are very similar to each other. The <span class="strong"><strong>Drop Height</strong></span> value is the maximum amount of space the AI can intelligently drop down to another part of the navigation mesh. <span class="strong"><strong>Jump Distance</strong></span> is the opposite of <span class="strong"><strong>Height</strong></span>; it determines how high the AI can jump up to another part of the navigation mesh.</p><p>The <span class="strong"><strong>Advanced</strong></span> options<a id="id317" class="indexterm"></a> are to be used when you have a better understanding of the NavMesh component and want a little more out of it. Here, you can further tweak the accuracy of the NavMesh as well as create <span class="strong"><strong>Height Mesh</strong></span> to coincide with the navigation mesh.</p><p>Now that you know all the basics of the Unity NavMesh, let's go ahead and create our navigation mesh. At the bottom-right corner of the <span class="strong"><strong>Navigation</strong></span> tab in the <span class="strong"><strong>Inspector</strong></span> window, you should see two buttons: one that says <span class="strong"><strong>Clear</strong></span> and the other that says <span class="strong"><strong>Bake</strong></span>. Click on the <span class="strong"><strong>Bake</strong></span> button now to create your new navigation mesh.</p><p>Select the ramp and the thick cube that we created earlier. In the <span class="strong"><strong>Navigation</strong></span> window, make sure that the <span class="strong"><strong>OffMeshLink Generation</strong></span> option is not checked, and that <span class="strong"><strong>Navigation Layer</strong></span> is set to <span class="strong"><strong>Default</strong></span>. If the ramp and the thick cube are not selected, reselect the floor cubes <a id="id318" class="indexterm"></a>so that you have the floors, ramp, and <a id="id319" class="indexterm"></a>thick wall selected. Bake the navigation mesh again to create a new one. This is what my scene looks like now with the navigation mesh:</p><div class="mediaobject"><img src="/graphics/9781783553631/graphics/3631OT_05_05.jpg" /></div><p>You should be able to see the newly generated navigation mesh overlaying the underlying mesh. This is what was created using the default <span class="strong"><strong>Bake</strong></span> properties. Changing the <span class="strong"><strong>Bake</strong></span> properties will give you different results, which will come down to what kind of navigation mesh you want the AI to use. Now that we have a navigation mesh, let's create the code for our AI to utilize. First, we will code the waypoint system, and then we will code what is needed for the NavMesh system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec14"></a>Adding our variables</h4></div></div></div><p>To <a id="id320" class="indexterm"></a>start our navigation system, we will need to add<a id="id321" class="indexterm"></a> a few variables first. Place these with the rest of our variables:</p><div class="informalexample"><pre class="programlisting">public Transform[] Waypoints;
public int curWaypoint = 0;
bool ReversePath = false;
NavMeshAgent navAgent;
Vector3 Destination;
float Distance;</pre></div><p>The first variable is an array of <code class="literal">Transforms</code>; this is what we will use to hold our waypoints. Next, we have an integer that is used to iterate through our <code class="literal">Transform</code> array. We have a <code class="literal">bool</code> variable, which will decide how we should navigate through the waypoints.</p><p>The next three variables are more oriented towards our navigation mesh that we created earlier. The <code class="literal">NavMeshAgent</code> object<a id="id322" class="indexterm"></a> is what we will reference when we want to interact with the navigation mesh. The destination will be the location that we want the AI to move towards. The distance is what we will use to check how far away we are from that location.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec15"></a>Scripting the navigation functions</h4></div></div></div><p>Previously, we<a id="id323" class="indexterm"></a> created many <a id="id324" class="indexterm"></a>empty functions; some of these are dependent on pathfinding. Let's start with the <code class="literal">Flee</code> function. Add this code to replace the empty function:</p><div class="informalexample"><pre class="programlisting">void Flee()
{
  for(int fleePoint = 0; fleePoint &lt; Waypoints.Length; fleePoint++)
  {
    Distance = Vector3.Distance(gameObject.transform.position, Waypoints[fleePoint].position);
    if(Distance &gt; 10.00f)
    {
      Destination = Waypoints[curWaypoint].position;
      navAgent.SetDestination(Destination);
      break;
    }
    else if(Distance &lt; 2.00f)
    {
      ChangeBehavior(Behaviors.Idle);
    }
  }
}</pre></div><p>What this <code class="literal">for</code> loop does is pick a waypoint that has <code class="literal">Distance</code> of more than <code class="literal">10</code>. If it does, then we set the <code class="literal">Destination</code> value to the current waypoint and move the AI accordingly. If the distance from the current waypoint is less than <code class="literal">2</code>, we change the behavior to <code class="literal">Idle</code>.</p><p>The next function that we will adjust is the <code class="literal">SearchForTarget</code> function. Add the following code to it, replacing its previous emptiness:</p><div class="informalexample"><pre class="programlisting">void SearchForTarget()
{
  Destination = GameObject.FindGameObjectWithTag("Player").transform.position;
  navAgent.SetDestination(Destination);
  Distance = Vector3.Distance(gameObject.transform.position, Destination);
  if(Distance &lt; 10)
    ChangeBehavior(Behaviors.Combat);
}</pre></div><p>This<a id="id325" class="indexterm"></a> function will now be able to<a id="id326" class="indexterm"></a> search for a target, the <code class="literal">Player</code> target to be more specific. We set <code class="literal">Destination</code> to the player's current position, and then move the AI towards the player. When <code class="literal">Distance</code> is less than <code class="literal">10</code>, we set the AI behavior to <code class="literal">Combat</code>.</p><p>Now that our AI can run from the player as well as chase them down, let's utilize the waypoints and create paths for the AI. Add this code to the empty <code class="literal">Patrol</code> function:</p><div class="informalexample"><pre class="programlisting">void Patrol()
{
  Distance = Vector3.Distance(gameObject.transform.position, Waypoints[curWaypoint].position);
  if(Distance &gt; 2.00f)
  {
    Destination = Waypoints[curWaypoint].position;
    navAgent.SetDestination(Destination);
  }
  else
  {
    if(ReversePath)
    {
      if(curWaypoint &lt;= 0)
      {
        ReversePath = false;
      }
      else
      {
        curWaypoint--;
        Destination = Waypoints[curWaypoint].position;
      }
    }
    else
    {
      if(curWaypoint &gt;= Waypoints.Length - 1)
      {
        ReversePath = true;
      }
      else
      {
        curWaypoint++;
        Destination = Waypoints[curWaypoint].position;
      }
    }
  }
}</pre></div><p>What <code class="literal">Patrol</code> will now do is check the <code class="literal">Distance</code> variable. If it is far from the current waypoint, we<a id="id327" class="indexterm"></a> set that waypoint as <a id="id328" class="indexterm"></a>the new destination of our AI. If the current waypoint is close to the AI, we check the <code class="literal">ReversePath</code> Boolean variable. When <code class="literal">ReversePath</code> is <code class="literal">true</code>, we tell the AI to go to the previous waypoint, going through the path in the reverse order. When <code class="literal">ReversePath</code> is <code class="literal">false</code>, the AI will go on to the next waypoint in the list of waypoints.</p><p>With all of this completed, you now have an AI with pathfinding abilities. The AI can also patrol a path set by waypoints and reverse the path when the end has been reached. We have also added abilities for the AI to search for the player as well as flee from the player.</p></div></div></div>