<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec55"></a>Loading data with XML</h2></div></div><hr /></div><p>Our final <a id="id460" class="indexterm"></a>step in learning how to use XML is to load the data that we just saved to our XML document into our game. While loading the XML data, you will notice that it's a process similar to that of loading from a flat file. The real difference is that instead of loading a line of data, we are loading from a specific part of the saved data.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec108"></a>Loading the player data</h3></div></div></div><p>To load<a id="id461" class="indexterm"></a> player data, we will add this function to your script just<a id="id462" class="indexterm"></a> below the <code class="literal">SavePlayer</code> function and above the <code class="literal">SaveEnemies</code> function:</p><div class="informalexample"><pre class="programlisting">void LoadPlayer()
{
  float xPos = 0.00f;
  float yPos = 0.00f;
  float zPos = 0.00f;
  float xRot = 0.00f;
  float yRot = 0.00f;
  float zRot = 0.00f;
  float xScale = 0.00f;
  float yScale = 0.00f;
  float zScale = 0.00f;
    
  if(Player != null)
  {
    XmlNode root = xPlayer.FirstChild;
    foreach(XmlNode node in root.ChildNodes)
    {
      switch(node.Name)
      {
      case "xPos":
        xPos = Convert.ToSingle(node.InnerText);
        break;
      case "yPos":
        yPos = Convert.ToSingle(node.InnerText);
        break;
      case "zPos":
        zPos = Convert.ToSingle(node.InnerText);
        break;
      case "xRot":
        xRot = Convert.ToSingle(node.InnerText);
        break;
      case "yRot":
        yRot = Convert.ToSingle(node.InnerText);
        break;
      case "zRot":
        zRot = Convert.ToSingle(node.InnerText);
        break;
      case "xScale":
        xScale = Convert.ToSingle(node.InnerText);
        break;
      case "yScale":
        yScale = Convert.ToSingle(node.InnerText);
        break;
      case "zScale":
        zScale = Convert.ToSingle(node.InnerText);
        break;
      }
    }
      
    Player.transform.position = new Vector3(xPos, yPos, zPos);
    Player.transform.rotation = new Quaternion(xRot, yRot, zRot, 0.00f);
    Player.transform.localScale = new Vector3(xScale, yScale, zScale);
  }
}</pre></div><p>Before <a id="id463" class="indexterm"></a>we start loading our data, we need to create some <a id="id464" class="indexterm"></a>placeholder variables for our data. These will be used later on to load data from the XML document, then be loaded into our player GameObject. Next, we check whether the player GameObject isn't null as a fail-safe, then we start loading our data.</p><p>To load our data, we first create an <code class="literal">XmlNode</code> root from <code class="literal">xPlayer XmlDocument</code>. Then, we run a <code class="literal">foreach</code> loop to look for every child node within the root node. We then assign our placeholder variables we just created with the <code class="literal">InnerText</code> values from each of the child nodes. Since a string can't be loaded into a float variable, we use the <code class="literal">Convert</code> method to make the string into a float for the <code class="literal">InnerText</code> values.</p><p>Finally, after we load our data from the XML document into our placeholder variables, we start assigning them to our player GameObject. We access the transform of the player and assign the position, rotation, and scale to our new values.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec109"></a>Loading the enemy data</h3></div></div></div><p>Now, we<a id="id465" class="indexterm"></a> load our enemy data from our <code class="literal">EnemyData</code> XML <a id="id466" class="indexterm"></a>document. This process is similar to loading our player data, except that we will change the code slightly to accommodate multiple GameObjects. Add the following function to your script now just after the <code class="literal">SaveEnemies</code> function:</p><div class="informalexample"><pre class="programlisting">void LoadEnemies()
{
  string name = "";
  float xPos = 0.00f;
  float yPos = 0.00f;
  float zPos = 0.00f;
  float xRot = 0.00f;
  float yRot = 0.00f;
  float zRot = 0.00f;
  float xScale = 0.00f;
  float yScale = 0.00f;
  float zScale = 0.00f;
    
  for(int e = 0; e &lt; Enemies.Length; e++)
  {
    if(Enemies[e] != null)
    {
      XmlNode eData = xEnemy.FirstChild;

      XmlNode enemy = eData.ChildNodes[e];

      if(enemy.Name == "enemy")
      {
        foreach(XmlNode eNode in enemy.ChildNodes)
        {
          switch(eNode.Name)
          {
          case "name":
            name = eNode.InnerText;
            break;
          case "xPos":
            xPos = Convert.ToSingle(eNode.InnerText);
            break;
          case "yPos":
            yPos = Convert.ToSingle(eNode.InnerText);
            break;
          case "zPos":
            zPos = Convert.ToSingle(eNode.InnerText);
            break;
          case "xRot":
            xRot = Convert.ToSingle(eNode.InnerText);
            break;
          case "yRot":
            yRot = Convert.ToSingle(eNode.InnerText);
            break;
          case "zRot":
            zRot = Convert.ToSingle(eNode.InnerText);
            break;
          case "xScale":
            xScale = Convert.ToSingle(eNode.InnerText);
            break;
          case "yScale":
            yScale = Convert.ToSingle(eNode.InnerText);
            break;
          case "zScale":
            zScale = Convert.ToSingle(eNode.InnerText);
            break;
          }

          Enemies[e].name = name;
          Enemies[e].transform.localPosition = new Vector3(xPos, yPos, zPos);
          Enemies[e].transform.localRotation = new Quaternion(xRot, yRot, zRot, 0.00f);
          Enemies[e].transform.localScale = new Vector3(xScale, yScale, zScale);
        }
      }
    }
  }
}</pre></div><p>Just as <a id="id467" class="indexterm"></a>we did to load player data, we create placeholder<a id="id468" class="indexterm"></a> variables. Next, we use a <code class="literal">for</code> loop to iterate through the enemies' GameObject array and then check to see whether that GameObject is null or not. After this, we go through the process of loading our data.</p><p>First, we create the root node and then create the enemy node; these will be the same as those in the <code class="literal">EnemyData</code> XML. To assign the enemy node, we assign to the current child node within the root node. We match the child node with the enemy GameObject by using the same iterator from the <code class="literal">for</code> loop.</p><p>Next, we check whether the enemy node's name is <code class="literal">enemy</code> just to verify that we are using the correct node. Then, we use a <code class="literal">foreach</code> loop to go through each node within the child nodes of the enemy node. Next, we assign the placeholder variables to the associating data from the nodes.</p><p>To finish<a id="id469" class="indexterm"></a> loading our data, we assign each of the placeholder <a id="id470" class="indexterm"></a>variables to our current GameObject in the enemies' array. Our code will load the correct data for each of the enemies and the data from the XML because we use the iterator from the first <code class="literal">for</code> loop to choose the correct data from each of the arrays.</p></div></div>