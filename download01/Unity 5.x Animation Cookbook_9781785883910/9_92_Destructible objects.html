<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec91"></a>Destructible objects</h2></div></div><hr /></div><p>In this recipe, we are going to create a simple <span>destructible object</span><a id="id325241232" class="indexterm"></a>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec283"></a>Getting ready</h3></div></div></div><p>To follow this recipe, you will need an object with two states: normal and shattered. The shattered object is a cut-to-pieces version of the normal one. Each piece of the fractured object should be a separate game object. See the following screenshot (we are using Blender fracture tools to fracture a simple sphere):</p><div class="mediaobject"><img src="/graphics/9781785883910/graphics/fd4f0e88-296e-4aa3-94dd-9a41fdcf9e41.png" /></div><p>Normal ball and a fractured one: each fractured element is a separate game object</p><p>You can also download the provided example Unity project and go to the <code class="literal">Chapter 09 Physics and animations\Recipe 03 Destructible objects</code> directory. You can find the <code class="literal">Example.unity</code> scene there. If you play the game, you will see a ball falling down. When it hits the ground, it will be fractured into pieces.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec284"></a>How to do it...</h3></div></div></div><p>To create a <span>destructible object,</span><a id="id325241587" class="indexterm"></a> follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the normal and shattered objects to Unity. In our example, we have an object called <strong class="userinput"><code>Ball</code></strong> and the other one is called <strong class="userinput"><code>BallFractured</code></strong>.</li><li>Drag and drop both objects into the scene.</li><li>Select all child game objects (pieces) of the <strong class="userinput"><code>BallFractured</code></strong> game object. Add the <strong class="userinput"><code>Rigidbody</code></strong> and <strong class="userinput"><code>Mesh Collider</code></strong> components to them. Set the <strong class="userinput"><code>Mesh Collider</code></strong> to <strong class="userinput"><code>Convex</code></strong>.</li><li>Create a prefab from the <strong class="userinput"><code>BallFractured</code></strong> game object (containing all the pieces).</li><li>Select the <strong class="userinput"><code>Ball</code></strong> game object and add a <strong class="userinput"><code>Rigidbody</code></strong> and a <strong class="userinput"><code>Sphere Collider</code></strong> to it (or another type, depending on the shape of your object).</li><li>Write a new C# script and call it <code class="literal">SpawnFracturedObject.cs</code>. In this script, we have a <code class="literal">void Fracture()</code> function that spawns a fractured game object prefab (our <strong class="userinput"><code>BallFractured</code></strong>), applies velocity to all its pieces, and destroys the main object (<strong class="userinput"><code>Ball</code></strong>):</li></ol></div><pre class="programlisting">      void Fracture() 
      { 
          GetComponent&lt;Collider&gt;().enabled = false; 
          GameObject fracturedObject = 
          (GameObject)GameObject.Instantiate(fracturedObject 
          Prefab, transform.position, transform.rotation); 
     
          Rigidbody[] rigidBodies = 
          fracturedObject.GetComponentsInChildren&lt;Rigidbody&gt;    (); 
     
          for (int i = 0; i &lt; rigidBodies.Length; i++) 
          { 
              rigidBodies[i].velocity += 
              lastRigidBodyVelocity; 
          } 
          Destroy(gameObject); 
      } </pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>The <code class="literal">void Fracture()</code> function is called when our main object collides with anything:</li></ol></div><pre class="programlisting">      void OnCollisionEnter(Collision col) 
      { 
          Fracture(); 
      } </pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>The Ball's velocity is saved every frame to the <code class="literal">float lastRigidBodyVelocity</code> variable (in the <code class="literal">FixedUpdate()</code> function):</li></ol></div><pre class="programlisting">      void FixedUpdate () { 
          lastRigidBodyVelocity = rb.velocity; 
      } </pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Assign the script to the <strong class="userinput"><code>Ball</code></strong> game object and drag the <strong class="userinput"><code>BallFractured</code></strong> prefab onto the <strong class="userinput"><code>Fractured Object Prefab</code></strong> field in the <strong class="userinput"><code>Inspector</code></strong>.</li><li>Play the game to see the effect:</li></ol></div><div class="mediaobject"><img src="/graphics/9781785883910/graphics/3a539c8f-9632-48df-9e2c-889e64b3f931.png" /></div><p>Before and after collision</p><p></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec285"></a>How it works...</h3></div></div></div><p>two objects, a normal one and a fractured one built out of a number of pieces. The normal object works as any other game object in our game. The fractured game object is spawned only when we destroy the normal object. We save the normal object's velocity (its rigid body velocity in this example) every frame to be able to add this velocity to our spawned, fractured pieces. This makes them continue movement after the <span>normal</span><a id="id325526786" class="indexterm"></a> object was destroyed.</p><p>In this recipe, we created two objects, a normal one and a fractured one built out of a number of pieces. The normal object works as any other game object in our game. The fractured game object is spawned only when we destroy the normal object. We save the normal object's velocity (its rigid body velocity in this example) every frame to be able to add this velocity to our spawned, fractured pieces. This makes them continue movement after the normal object was destroyed. There's more...</p><p>You can use this simple technique to create even more complex objects (destructible barrels where each plank is a separate object is a good example). There are also different fracture systems available on the Asset Store (try searching for "fracture," "shatter," or "destructible").</p></div></div>