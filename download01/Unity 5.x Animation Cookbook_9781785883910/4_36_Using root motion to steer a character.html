<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec40"></a>Using root motion to steer a character</h2></div></div><hr /></div><p>In this recipe, we will use animations to move and steer our <span>character</span><a id="id325532258" class="indexterm"></a>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec113"></a>Getting ready</h3></div></div></div><p>To use root motion for steering, you need to prepare a <span>character</span><a id="id325532308" class="indexterm"></a> with at least four animations: <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, and <strong class="userinput"><code>WalkRight</code></strong>. <strong class="userinput"><code>WalkRight</code></strong> and <strong class="userinput"><code>WalkLeft</code></strong> should make the character walk in circles (clockwise and counterclockwise). You don't need to create a full circle, just make sure that the start and end poses of the animation look similar. As always, all the animations should have contact points of the feet in the same normalized time. Make sure not to switch the left and right foot. If you start the <strong class="userinput"><code>WalkForward</code></strong> animation with the left foot forward, both <strong class="userinput"><code>WalkLeft</code></strong> and <strong class="userinput"><code>WalkRight</code></strong> animations should also start with the left foot forward, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785883910/graphics/106eb75e-e0d3-4f66-b755-0e04808eac77.png" /></div><p>Steering animations using root motion</p><p>You can also use the example project; go to the <code class="literal">Chapter 04 Character movement\Recipe 03 Using root motion to steer a character</code> directory. You can find the <code class="literal">Example.unity</code> scene there, with a <strong class="userinput"><code>Humanoid</code></strong> character already animated in the scene's <strong class="userinput"><code>Hierarchy</code></strong>. You can start the game and use the <span class="emphasis"><em>WSAD</em></span> keys to move the character relative to the camera. In the <code class="literal">Rigs</code> directory, you can find the <code class="literal">Humanoid.fbx</code> character with all the required animations.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec114"></a>How to do it...</h3></div></div></div><p>To use root motion for steering, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import your character with <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, and <strong class="userinput"><code>WalkRight</code></strong> root motion animations into Unity.</li><li>Select the character asset file and go to the <strong class="userinput"><code>Inspector</code></strong>. Make sure the <strong class="userinput"><code>Animation Type</code></strong> is set properly for your character (<strong class="userinput"><code>Generic</code></strong> or <strong class="userinput"><code>Humanoid</code></strong>). If you are using a <strong class="userinput"><code>Generic</code></strong> character, make sure to set its <strong class="userinput"><code>Root Node</code></strong>.</li><li>Go to the <strong class="userinput"><code>Animation</code></strong> tab and select the <strong class="userinput"><code>Idle</code></strong> animation. Select all the <strong class="userinput"><code>Bake Into Pose</code></strong> options and set the <strong class="userinput"><code>Base Upon</code></strong> option of the <strong class="userinput"><code>Root Transform Rotation</code></strong> to <strong class="userinput"><code>Original</code></strong>.</li><li>For the <strong class="userinput"><code>WalkForward</code></strong> animation, select the same options as for the <strong class="userinput"><code>Idle</code></strong> animation, but uncheck <strong class="userinput"><code>Bake Into Pose</code></strong> for <strong class="userinput"><code>Root Transform Position (XZ)</code></strong>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>For the <strong class="userinput"><code>WalkLeft</code></strong> and <strong class="userinput"><code>WalkRight</code></strong> animations, set all the option the same as for the <strong class="userinput"><code>WalkForward</code></strong> animation, but additionally uncheck the <strong class="userinput"><code>Bake Into Pose</code></strong> option for <strong class="userinput"><code>Root Transform Rotation</code></strong>.</li><li>Set the <strong class="userinput"><code>Loop Time</code></strong> options to true for these animations.</li><li>If your animations don't loop perfectly, you can try out the <strong class="userinput"><code>Loop Pose</code></strong> option. It will force the start and end poses to loop.</li><li>Apply the <strong class="userinput"><code>import</code></strong> settings.</li><li>Place your <span>character</span><a id="id325531729" class="indexterm"></a> into a scene.</li><li>Select it in the <strong class="userinput"><code>Hierarchy</code></strong> and add a <strong class="userinput"><code>Capsule Collider</code></strong> to it. You may need to adjust the <strong class="userinput"><code>Capsule Collider</code></strong> properties to better fit your character. In our examples, we <span>need</span><a id="id325531749" class="indexterm"></a> to set the <strong class="userinput"><code>Height</code></strong> property to 2 units and the <span class="emphasis"><em>Y</em></span> axis in the <strong class="userinput"><code>Center</code></strong> property to 1 unit.</li><li>Add a <strong class="userinput"><code>Rigidbody</code></strong> component to the character and set its <strong class="userinput"><code>Constraints</code></strong> to <strong class="userinput"><code>Freeze Rotation</code></strong> in every axis.</li><li>Navigate to the Animator component of the character (it is added automatically for animated game objects). Set <strong class="userinput"><code>Update Mode</code></strong> to <strong class="userinput"><code>Animate Physics</code></strong>. Make sure the <strong class="userinput"><code>Apply Root Motion</code></strong> option is checked in the Animator component.</li><li>Create an Animator Controller asset for the character.</li><li>Drag and drop the <strong class="userinput"><code>Idle</code></strong> animation into the Animator Controller to make it the default state.</li><li>Create <code class="literal">float</code><strong class="userinput"><code>Speed</code></strong> and <code class="literal">float</code><strong class="userinput"><code>Direction</code></strong> parameters in the Animator Controller.</li><li>Right-click on the empty space in the Animator Controller and choose <strong class="userinput"><code>Create State</code></strong> | <strong class="userinput"><code>New From Blend Tree</code></strong>.</li><li>Click on the <strong class="userinput"><code>Blend Tree</code></strong> and change its name in the <strong class="userinput"><code>Inspector</code></strong> to <strong class="userinput"><code>Steering</code></strong>.</li><li>Double-click on the <strong class="userinput"><code>Blend Tree</code></strong> to open its settings.</li><li>Click on the plus button and choose the <strong class="userinput"><code>Add Motion Field</code></strong> option three times.</li><li>Set the <strong class="userinput"><code>Parameter</code></strong> of the <strong class="userinput"><code>Blend Tree</code></strong> to <strong class="userinput"><code>Direction</code></strong>; we will only use the <strong class="userinput"><code>Direction</code></strong> parameter for blending walk animations.</li><li>Drag and drop the <strong class="userinput"><code>WalkLeft</code></strong> animation in the first (upper) field, the <strong class="userinput"><code>WalkForward</code></strong> in the second (middle) field, and <strong class="userinput"><code>WalkRight</code></strong> in the third (lower) field.</li><li>Uncheck the <strong class="userinput"><code>Automate Thresholds</code></strong> option.</li><li>Set the <strong class="userinput"><code>WalkLeft</code></strong> animation <strong class="userinput"><code>Threshold</code></strong> to -45, <strong class="userinput"><code>WalkForward</code></strong> animation <strong class="userinput"><code>Threshold</code></strong> to 0, and the <strong class="userinput"><code>WalkRight</code></strong> animation <strong class="userinput"><code>Threshold</code></strong> to 45.</li><li>Double-click on the empty space in the Animator Controller to get out of the <strong class="userinput"><code>Blend Tree</code></strong> settings.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="25" type="1"><li>Create two transitions:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Idle</code></strong> | <strong class="userinput"><code>Steering</code></strong> with the condition set to <strong class="userinput"><code>Speed</code></strong> parameter greater than 0.5, <strong class="userinput"><code>Has Exit Time</code></strong> set to false, and <strong class="userinput"><code>Transition Duration</code></strong> set to 0.2 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>Steering</code></strong> | <strong class="userinput"><code>Idle</code></strong> with the condition set to <strong class="userinput"><code>Speed</code></strong> parameter less than 0.5, <strong class="userinput"><code>Has Exit Time</code></strong> set to false, and <strong class="userinput"><code>Transition Duration</code></strong> set to 0.2 seconds.</li></ul></div></li><li>Write a script to set the <strong class="userinput"><code>Speed</code></strong> and <strong class="userinput"><code>Direction</code></strong> parameters of our Animator <span>Controller</span><a id="id325532333" class="indexterm"></a> and assign that script to the character.</li><li>You can find the script in the provided Unity project in the <code class="literal">Scripts</code> directory of this recipe. It is called <code class="literal">RootMotionSteering.cs</code>.</li><li>In this script, we make the character move relative to the camera. In the <code class="literal">Update()</code> function, first we get and store player input in two variables, <code class="literal">hor</code> (for <code class="literal">Horizontal</code> input) and <code class="literal">ver</code> (for <code class="literal">Vertical</code> input):</li></ol></div><pre class="programlisting">       hor = Input.GetAxis("Horizontal"); 

       ver = Input.GetAxis("Vertical"); </pre><div class="orderedlist"><ol class="orderedlist arabic" start="29" type="1"><li>As we want to move the <span>character</span><a id="id325532380" class="indexterm"></a> relative to the camera, we're using the camera's forward and right axis to build a desired movement vector. Our camera is not completely horizontal (it can face slightly down, for instance), so first we need to calculate <code class="literal">cameraHorizontalForward</code> by taking the normal camera forward vector, setting its <span class="emphasis"><em>Y</em></span> axis to 0, and normalizing the vector (so it has a length of 1):</li></ol></div><pre class="programlisting">        cameraHorizontalForward = new 
        Vector3(cameraTransform.forward.x,
        0f, cameraTransform.forward.z).normalized; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="30" type="1"><li>In this script, <code class="literal">cameraTransform</code> is a <code class="literal">public Transform</code> variable to which we attach our in-game camera.</li><li>Next we calculate the <code class="literal">desiredMoveDirection</code>: this is a vector pointing in the direction that we would like to move our character. This vector points directly to the right axis of the camera when the player holds the right arrow, to the left of the camera when player holds the left arrow, to the horizontal version of camera's forward axis (<code class="literal">cameraForwardHorizontal</code>) when the player holds the up arrow, and to the opposite direction of that vector when player holds the down arrow:</li></ol></div><pre class="programlisting">       desiredMoveDirection = ver * cameraHorizontalForward + hor *
       cameraTransform.right; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="32" type="1"><li>Next we calculate the angle between our character's forward vector and our <code class="literal">desiredMoveDirection</code> vector. We will use this value to set the <strong class="userinput"><code>Direction</code></strong> parameter in the Animator Controller. The <code class="literal">Vector3.Angle()</code> method returns an angle between two vectors. This <span>angle</span><a id="id325532445" class="indexterm"></a> is always positive (greater than 0). Therefore, we use the dot product of the <code class="literal">desiredMoveDirection</code> and <code class="literal">transform.right</code> (our character's right axis) vectors to determine whether the <code class="literal">desiredMoveDirection</code> points to the right or to the left of the <span>character</span><a id="id325532464" class="indexterm"></a> (the dot product is greater than 0 for vectors pointing in the same direction and less than 0 for vectors pointing in the opposite direction). We use the <code class="literal">Mathf.Sign()</code> method to make sure our dot product value equals -1 or 1. The result is an angle from -180 to 180 degrees; we store the value in the <code class="literal">float direction</code> variable:</li></ol></div><pre class="programlisting">         direction = Vector3.Angle(transform.forward,
         desiredMoveDirection) *
         Mathf.Sign(Vector3.Dot(desiredMoveDirection,
         transform.right)); </pre><div class="orderedlist"><ol class="orderedlist arabic" start="33" type="1"><li>Then we calculate a <code class="literal">float speed</code> variable's value; it is simply the magnitude of our <code class="literal">desiredMoveVector</code>. The <code class="literal">speed</code> variable is used to set the <strong class="userinput"><code>Speed</code></strong> parameter in our Animator Controller:</li></ol></div><pre class="programlisting">        speed = desiredMoveDirection.magnitude; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="34" type="1"><li>Lastly, we use the calculated <code class="literal">direction</code> and <code class="literal">speed</code> values and set them in our Animator Controller, with a <code class="literal">dampTime</code> parameter of the <code class="literal">SetFloat()</code> method set to 0.2 seconds to smooth out the blends. The <code class="literal">anim</code> variable stores the reference to the Animator component of our character and is set in the <code class="literal">Start()</code> function:</li></ol></div><pre class="programlisting">       anim.SetFloat("Direction", direction, 0.2f, Time.deltaTime); 
       anim.SetFloat("Speed", speed, 0.2f, Time.deltaTime); </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec115"></a>How it works...</h3></div></div></div><p>Root motion steering works the same way as the root motion movement. We are using the rotation of the root bone to rotate the character. In our example, the character is walking in circles, so its hips are rotating during the animation. That data is then used to rotate the whole character.</p><p>Again, to make the walk animations blend properly, you have to make sure that they all start with the same leg and that the feet contact poses are in the same normalized time as the animation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip10"></a>Note</h3><p>If you are using a <strong class="userinput"><code>Humanoid</code></strong> rig, it is enough to create only forward and left animations. Then you can create a new animation clip in the character <strong class="userinput"><code>Import Settings</code></strong> in the <strong class="userinput"><code>Animation</code></strong> tab (you need to click on the plus button in the <strong class="userinput"><code>Clips</code></strong> section). When you choose the <strong class="userinput"><code>WalkLeft</code></strong> animation as the source, set it to <strong class="userinput"><code>Mirror</code></strong> and set its <strong class="userinput"><code>Cycle Offset</code></strong> to 0.5; you should get a proper <strong class="userinput"><code>WalkRight</code></strong> animation.</p></div></div></div>