<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec39"></a>Using root motion to drive Rigid Body characters' movement with animations</h2></div></div><hr /></div><p>This recipe describes a very important concept called <span>root motion</span><a id="id325289099" class="indexterm"></a>. It allows the extraction of <span>translation</span><a id="id325289108" class="indexterm"></a> and rotation data from an animation and applies it to our character in the game.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec109"></a>Getting ready</h3></div></div></div><p>To use <span>root motion</span><a id="id325289123" class="indexterm"></a>, first you need to create a <span>character</span><a id="id325292785" class="indexterm"></a> with a walk or run animation, that has translation in it; see the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785883910/graphics/793ada1e-e28e-4b34-bdfe-2b514c01dca5.png" /></div><p>Frames of a run animation using root motion. The character is animated with root node translation</p><p>If you are using a <strong class="userinput"><code>Humanoid</code></strong> character, the hip bone is used as the root node, the one describing root motion. So hip translation will describe the translation of the character in game (you can still have motion in the <span class="emphasis"><em>Y</em></span> axis as we can then adjust it in the <strong class="userinput"><code>Import</code></strong> settings). Its rotation will describe character rotation in the game. If you are using a <strong class="userinput"><code>G</code></strong>eneric character, you need to choose the <strong class="userinput"><code>Root Node</code></strong> manually in the <strong class="userinput"><code>Import</code></strong> settings. Select the model, go to <strong class="userinput"><code>Inspector</code></strong>, click on the <strong class="userinput"><code>Rig</code></strong> tab, set the <strong class="userinput"><code>Animation Type</code></strong> to <strong class="userinput"><code>Generic</code></strong>, and select the <strong class="userinput"><code>Root Node</code></strong> from its drop-down menu (it contains the whole bone hierarchy of your rig).</p><p>You can also download the provided example Unity project and go to <code class="literal">Chapter 04 Character movement\Recipe 02 Using root motion to drive rigid body characters movement with animations</code> directory. You will find a scene called <code class="literal">Example.unity</code> there, with a <strong class="userinput"><code>Humanoid</code></strong> game object in the <strong class="userinput"><code>Hierarchy</code></strong>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip9"></a>Note</h3><p>If you play the game, you can move the character with <span class="emphasis"><em>WSAD</em></span> or the arrow keys and run with <span class="emphasis"><em>Shift</em></span>. The movement is described by root motion, but steering is done with scripts (we simply rotate the character). In the <code class="literal">Rigs</code> directory, you can find the imported <code class="literal">Humanoid.fbx</code> file with all the required animations.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec110"></a>How to do it...</h3></div></div></div><p>To move a using animations, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import your <span>character</span><a id="id325509862" class="indexterm"></a> with <span>root motion</span><a id="id325522876" class="indexterm"></a> animations into Unity. We are using three animations in this example: <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkRoot</code></strong>, and <strong class="userinput"><code>RunRoot</code></strong>.</li><li>Select the character asset file and go to the <strong class="userinput"><code>Inspector</code></strong>. Make sure the Animation Type is set properly for your character (<strong class="userinput"><code>Generic</code></strong> or <strong class="userinput"><code>Humanoid</code></strong>). If you are using a <strong class="userinput"><code>Generic</code></strong> character, make sure to set its <strong class="userinput"><code>Root Node</code></strong>.</li><li>Go to the <strong class="userinput"><code>Animation</code></strong> tab and select the <strong class="userinput"><code>Idle</code></strong> animation. Select all the <strong class="userinput"><code>Bake Into Pose</code></strong> options. This bakes all the root motion data into the animation and makes it completely stationary. We don't want the <strong class="userinput"><code>Idle</code></strong> animation to move or rotate our character. You may also set the <strong class="userinput"><code>Base Upon</code></strong> option of the <strong class="userinput"><code>Root Transform Rotation</code></strong> to <strong class="userinput"><code>Original</code></strong>. This will make your character stand in the same pose as authored in the 3D software.</li><li>For <strong class="userinput"><code>WalkRoot</code></strong> and <strong class="userinput"><code>RunRoot</code></strong> animations, select the same options as for the Idle animation, but uncheck <strong class="userinput"><code>Bake Into Pose</code></strong> for <strong class="userinput"><code>Root Transform Position (XZ)</code></strong>. This will make our character move in the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> axes only. The <span class="emphasis"><em>Y</em></span> movement of the root node and its rotation will be baked into the animation and will not be stored as root motion anymore.</li><li>Set the <strong class="userinput"><code>Loop Time</code></strong> options to true for all animations.</li><li>Apply the <strong class="userinput"><code>import</code></strong> settings.</li><li>Place your character onto a scene.</li><li>Select it in the <strong class="userinput"><code>Hierarchy</code></strong> and add a <strong class="userinput"><code>Capsule Collider</code></strong> to it. You may need to adjust the <strong class="userinput"><code>Capsule Collider</code></strong> properties to better fit your character. In our examples, we need to set the <strong class="userinput"><code>Height</code></strong> property to 2 units and the <span class="emphasis"><em>Y</em></span> axis in the <strong class="userinput"><code>Center</code></strong> property to 1 unit.</li><li>Add a <strong class="userinput"><code>Rigidbody</code></strong> component to the character and set its <strong class="userinput"><code>Constraints</code></strong> to <strong class="userinput"><code>Freeze Rotation</code></strong> in every axis.</li><li>Navigate to the Animator component of the character (it is added automatically for animated game objects). Set <strong class="userinput"><code>Update Mode</code></strong> to <strong class="userinput"><code>Animate Physics</code></strong>. Make sure the <strong class="userinput"><code>Apply Root Motion</code></strong> option is checked in the Animator component.</li><li>Create an Animator Controller asset for the character.</li><li>Drag and drop the <strong class="userinput"><code>Idle</code></strong> animation into the Animator Controller to make it the default state.</li><li>Create a <code class="literal">float</code><strong class="userinput"><code>DesiredSpeed</code></strong> parameter in the Animator Controller.</li><li>Right-click on the empty space in the Animator Controller and choose <strong class="userinput"><code>Create State</code></strong> | <strong class="userinput"><code>New From Blend Tree</code></strong>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>Click on the <strong class="userinput"><code>Blend Tree</code></strong> and change its name in the <strong class="userinput"><code>Inspector</code></strong> to <strong class="userinput"><code>WalkAndRun</code></strong>.</li><li>Double-click on the <strong class="userinput"><code>Blend Tree</code></strong> to open its settings.</li><li>Click on the <strong class="userinput"><code>Plus</code></strong> button and choose the <strong class="userinput"><code>Add Motion Field</code></strong> option twice.</li><li>Drag and drop your <strong class="userinput"><code>WalkRoot</code></strong> animation in the first (upper) field and your <strong class="userinput"><code>RunRoot</code></strong><span>animation</span><a id="id325540288" class="indexterm"></a> in the second (lower) field.</li><li>Uncheck the <strong class="userinput"><code>Automate Thresholds</code></strong> option.</li><li>Set the <strong class="userinput"><code>WalkRoot</code></strong><span>animation</span><a id="id325540341" class="indexterm"></a><strong class="userinput"><code>Threshold</code></strong> to <code class="literal">1</code> and <strong class="userinput"><code>RunRoot</code></strong> animation <strong class="userinput"><code>Threshold</code></strong> to <code class="literal">2</code>.</li><li>Double-click on the empty space in the Animator Controller to get out of the <strong class="userinput"><code>Blend Tree</code></strong> settings.</li><li>Create two transitions:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Idle</code></strong> | <strong class="userinput"><code>WalkAndRun</code></strong> with the condition set to <strong class="userinput"><code>DesiredSpeed</code></strong> parameter greater than 0.5, <strong class="userinput"><code>Has Exit Time</code></strong> set to false, and <strong class="userinput"><code>Transition Duration</code></strong> set to 0.2 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>WalkAndRun</code></strong> | <strong class="userinput"><code>Idle</code></strong> with the condition set to <strong class="userinput"><code>DesiredSpeed</code></strong> parameter less than 0.5, <strong class="userinput"><code>Has Exit Time</code></strong> set to false, and <strong class="userinput"><code>Transition Duration</code></strong> set to 0.2 seconds.</li></ul></div></li><li>Write a script to set the <strong class="userinput"><code>DesiredSpeed</code></strong> parameter and assign it to the character. Play the game to see the effect (make sure your scene has a floor with a collider to prevent your character from falling down).</li><li>You can also use the <code class="literal">MoveAndSteer.cs</code> script from the <code class="literal">Scripts</code> directory in this recipe. In the <code class="literal">Update()</code> function, we get the player input and save the values in <code class="literal">hor</code> and <code class="literal">ver</code> variables:</li></ol></div><pre class="programlisting">        hor = Input.GetAxis("Horizontal"); 

        ver = Input.GetAxis("Vertical"); </pre><div class="orderedlist"><ol class="orderedlist arabic" start="25" type="1"><li>Then we use the <code class="literal">Rotate()</code> method to rotate our character in the global <span class="emphasis"><em>Y</em></span> axis (<code class="literal">Vector3.up</code>) based on the <code class="literal">hor</code> variable and a <code class="literal">public float</code><code class="literal">rotationSpeed</code> variable (set to 90 degrees per second):</li></ol></div><pre class="programlisting">        transform.Rotate(Vector3.up * hor * rotationSpeed * 
        Time.deltaTime); </pre><div class="orderedlist"><ol class="orderedlist arabic" start="26" type="1"><li>We modify the <code class="literal">desiredSpeed</code> variable based on player input (we check if the player holds the <span class="emphasis"><em>Shift</em></span> key):</li></ol></div><pre class="programlisting">        if (Input.GetKey(KeyCode.LeftShift) || 
        Input.GetKey(KeyCode.RightShift)) 
        { 
            desiredSpeed = 2f; 
        } 
        else 
        { 
            desiredSpeed = 1f; 
        } </pre><div class="orderedlist"><ol class="orderedlist arabic" start="27" type="1"><li>Finally, we use the vertical axis input stored in the <code class="literal">ver</code> variable and our <code class="literal">desiredSpeed</code> value to set the <strong class="userinput"><code>DesiredSpeed</code></strong> parameter in the Animator Controller (which moves our character using root motion):</li></ol></div><pre class="programlisting">        anim.SetFloat("DesiredSpeed", desiredSpeed * ver, 0.2f, 
        Time.deltaTime); </pre><div class="orderedlist"><ol class="orderedlist arabic" start="28" type="1"><li>We use the <code class="literal">SetFloat()</code> method with the <code class="literal">dampTime</code> parameter set to 0.2 seconds. That smooths out the changes of the parameter, which results in smoother blends between run and walk animations. The <code class="literal">anim</code> variable stores the reference to the Animator component and is set in the <code class="literal">Start()</code> function.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec111"></a>How it works...</h3></div></div></div><p>The traditional approach to animation in games required all the movement animations to be done "in place." Characters were only moved with code (in Unity, with the <code class="literal">transform.Translate()</code> and <code class="literal">transform.Rotate()</code> methods, by changing the <code class="literal">rigidbody.velocity</code> vector, or by using the <code class="literal">rigidbody.ApplyForce()</code> method). Animations were merely visual effects and the game could work without a single animation being played. In the root motion approach, animations drive the movement of a character. The translation and rotation data is captured from the root node (a bone in the rig's hierarchy) and applied to the whole character in game. There are a few pros and cons to each approach:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Traditional approach</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Root motion approach</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pros
</p><p> </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Small number of animations</li><li style="list-style-type: disc">You can prototype without a single animation</li><li style="list-style-type: disc">You can adjust the speed of the character easily</li></ul></div></td><td style="border-bottom: 0.5pt solid ; "><p>Pros
</p><p> </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Looks <span>more</span><a id="id325532199" class="indexterm"></a> natural, there is no foot sliding</li><li style="list-style-type: disc">You can create complex moves and even game mechanics with animations</li><li style="list-style-type: disc">You can have irregular movements such as a wounded or zombie walk</li></ul></div></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Cons
</p><p> </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Hard to remove foot sliding</li><li style="list-style-type: disc">Special attacks and evasion moves have to be programmed</li><li style="list-style-type: disc">Looks "last gen"</li></ul></div></td><td style=""><p>Cons
</p><p> </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Requires a bigger number of animations</li><li style="list-style-type: disc">You can't move your character without an animation</li><li style="list-style-type: disc">Longer prototyping iterations</li></ul></div></td></tr></tbody></table></div><p>There are a few <span>important</span><a id="id325532245" class="indexterm"></a> options regarding <span>root motion</span><a id="id325532253" class="indexterm"></a> in the <strong class="userinput"><code>Animation Import Settings</code></strong>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Root Transform Rotation</code></strong>: This option captures the rotation of the root node and applies it to the whole game object. You can set it to <strong class="userinput"><code>Bake Into Pose</code></strong> to disable the root motion rotation. With this option selected, the rotation will be treated as a visual effect of the animation and will not be applied to the game object. You should set it to true for every animation that shouldn't rotate the character. You can set the <strong class="userinput"><code>Based Upon</code></strong> option to one of the following options:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Original</code></strong>: This is the original root node rotation from the animation file.</li><li style="list-style-type: disc"><strong class="userinput"><code>Body Orientation</code></strong>: This alters the original rotation to make the character's upper body face the <span class="emphasis"><em>Z</em></span> axis of the game object (the forward axis). You can also set the <strong class="userinput"><code>Offset</code></strong> option to offset the rotation.</li></ul></div></li><li style="list-style-type: disc"><strong class="userinput"><code>Root Transform Position Y</code></strong>: This option captures the vertical movement of the root node and applies it to the whole game object. You can set it to <strong class="userinput"><code>Bake Into Pose</code></strong> to disable the root motion in the <span class="emphasis"><em>Y</em></span> axis. With this option selected, the <span class="emphasis"><em>Y</em></span> axis motion will be treated as a visual effect of the animation and will not be applied to the game object. You should set it to true for every "on ground" animation (unless it's a jump). You can set the <strong class="userinput"><code>Based Upon</code></strong> option to the following options:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Original</code></strong>: This is the original root node <span class="emphasis"><em>Y</em></span> axis motion from the animation file.</li><li style="list-style-type: disc"><strong class="userinput"><code>Center Of Mass</code></strong>: This aligns the center of mass with the root node vertical position.</li><li style="list-style-type: disc"><strong class="userinput"><code>Feet</code></strong>: This keeps the feet aligned with the vertical root node position. You can also set the <strong class="userinput"><code>Offset</code></strong> option to offset the vertical root node position.</li></ul></div></li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Root Transform Position XZ</code></strong> : This option captures the horizontal (<span class="emphasis"><em>XZ</em></span>) movement of the root node and applies it to the whole game object. You can set it to <strong class="userinput"><code>Bake Into Pose</code></strong> to disable the <span>root motion</span><a id="id325531774" class="indexterm"></a> in the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> axis. With this option selected, horizontal motion will be treated as a visual effect of the animation and will not be applied to the game object. You should set it to true for all stationary <span>animations</span><a id="id325531789" class="indexterm"></a> (such as <strong class="userinput"><code>Idle</code></strong>). You can set the <strong class="userinput"><code>Based Upon</code></strong> option to the following options:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Original</code></strong>: This is the original root node horizontal motion from the animation file.</li><li style="list-style-type: disc"><strong class="userinput"><code>Center Of Mass</code></strong>: This aligns the center of mass with the root node horizontal position. You can also set the <strong class="userinput"><code>Offset</code></strong> option to offset the horizontal root node position.</li></ul></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec112"></a>There's more...</h3></div></div></div><p>In Unity, you can combine root motion and traditional approaches very easily. In fact, we are doing it in this recipe. We control the movement of our character with root motion but we steer it with the <code class="literal">transform.Rotate()</code> method. You can also create a character with traditional movement ("in place" animations with all the <strong class="userinput"><code>Bake Into Pose</code></strong> options set to true for walk and run animations) and root motion actions such as attacks and evade moves.</p></div></div>