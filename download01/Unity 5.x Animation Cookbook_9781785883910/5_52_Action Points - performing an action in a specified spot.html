<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec55"></a>Action Points - performing an action in a specified spot</h2></div></div><hr /></div><p><span>Action Points</span><a id="id325241216" class="indexterm"></a> are a common concept used for characters in games that have to perform a certain action in a certain spot. You will find a lot of them in RPG games where NPCs populate towns and perform different actions creating an illusion of a living community. We are going to address a simple case of an <span>Action Point</span><a id="id325241224" class="indexterm"></a> in this recipe.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec167"></a>Getting ready</h3></div></div></div><p>We are going to use a character with three animations: <strong class="userinput"><code>Walk</code></strong>, <strong class="userinput"><code>Idle</code></strong>, and <strong class="userinput"><code>Action</code></strong>. We are also going to use the <code class="literal">SetSpeedFromAgent.cs</code> script from the <span class="emphasis"><em>Using Blend Trees to blend walk and run animations</em></span> recipe in <span>Chapter 5</span>, <span class="emphasis"><em>Character Movement</em></span>. You can also open the provided example Unity project and go to the <code class="literal">Chapter 05 Character actions and expressions\Recipe 05 Action points performing an action in a specified spot</code> directory. You will find an <code class="literal">Example.scene</code> scene there. Play the game to see the effect—the Humanoid character will approach an Action Point and perform a pick up animation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec168"></a>How to do it...</h3></div></div></div><p>To create a simple <span>Action Point</span><a id="id325241556" class="indexterm"></a>, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the character to Unity.</li><li>Put it on the scene and add a <strong class="userinput"><code>NavMesh</code></strong> Agent component to it.</li><li>Bake the <strong class="userinput"><code>NavMesh</code></strong> in the scene.</li><li>Create an Animator Controller and assign it to the character's Animator component.</li><li>Create a <code class="literal">float </code><strong class="userinput"><code>Speed</code></strong> parameter and a <code class="literal">Trigger </code><strong class="userinput"><code>Action</code></strong> parameter in the controller.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Drag and drop the <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>Walk</code></strong>, and <span>Action</span><a id="id325526664" class="indexterm"></a> animations to the controller. Make sure that the <strong class="userinput"><code>Idle</code></strong> animation is the default state.</li><li>Create four transitions (see the following image):
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Idle</code></strong> | <strong class="userinput"><code>Walk</code></strong> with one condition: <strong class="userinput"><code>Speed</code></strong> parameter greater than 0.5. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition</code></strong><strong class="userinput"><code>Duration</code></strong> set to around 0.1 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>Walk</code></strong> | <strong class="userinput"><code>Idle</code></strong> with one condition: <strong class="userinput"><code>Speed</code></strong> parameter less than 0.5. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.1 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>Any State</code></strong> | <strong class="userinput"><code>Action</code></strong> with one condition: <strong class="userinput"><code>Action</code></strong> triggers parameter. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.1 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>Action</code></strong> | <strong class="userinput"><code>Idle</code></strong> with no conditions: <strong class="userinput"><code>Has Exit Time</code></strong> should be set to true and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.1 seconds.</li></ul></div></li></ol></div><div class="mediaobject"><img src="/graphics/9781785883910/graphics/01397e55-1553-4fd9-8652-3d6ff48071f8.png" /></div><p>Animator Controller with Action state used by the Action Point</p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Create a new script and call it <code class="literal">ActionPoint.cs</code>.</li><li>In that script, we have an <code class="literal">IEnumerator PerformAction()</code> coroutine that handles the <strong class="userinput"><code>Action Point</code></strong> usage (it is started in the <code class="literal">Start()</code> function). In this coroutine, we first check if our character is close enough to the <strong class="userinput"><code>Action Point</code></strong>. If not, we set the <strong class="userinput"><code>NavMesh Agent's</code></strong> destination to the <strong class="userinput"><code>Action Point's</code></strong> position, wait one frame, and check again:</li></ol></div><pre class="programlisting">        while ((agentTransform.position - 
        transform.position).sqrMagnitude &gt; actionDistance * 
        actionDistance) 
        { 
            agent.SetDestination(transform.position); 
            agent.Resume(); 
            yield return null; 
        }  </pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>The <code class="literal">agentTransform</code> variable holds the reference to the character's transform. The <code class="literal">actionDistance</code> is the distance from the <strong class="userinput"><code>Action Point</code></strong> in which our character should start performing the action.</li><li>When our character is closer to the <strong class="userinput"><code>Action Point</code></strong> than the <code class="literal">actionDistance</code>, we stop the <strong class="userinput"><code>NavMesh</code></strong> Agent and check if we want to match the character's position and/or rotation to our <strong class="userinput"><code>Action Point</code></strong> before the character starts playing the action animation. If not, we start playing the animation right away:</li></ol></div><pre class="programlisting">        agent.Stop(); 
        if (!matchBeforeAction) 
        { 
            anim.SetTrigger(actionTrigger); 
        } </pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Next we check if we want to match character's position and/or rotation with <strong class="userinput"><code>Action Point's</code></strong> position/rotation. If so, we use linear interpolation to match the position and/or rotation. If the position and/or rotation of the character are close enough to the <strong class="userinput"><code>Action Point's</code></strong> position/rotation, we set the character's position/rotation to be exactly the same as <strong class="userinput"><code>Action Point's</code></strong> position/rotation:</li></ol></div><pre class="programlisting">        while (matchRotation == true || matchRotation == true) 
        { 
            yield return null; 
            if (matchPosition &amp;&amp; (agentTransform.position - 
            transform.position).sqrMagnitude &gt; 0.01f) 
            { 
                agentTransform.position = 
                Vector3.Lerp(agentTransform.position, 
                transform.position, Time.deltaTime * 
                lerpSpeed); 
            } 
            else 
            { 
                matchPosition = false; 
                agentTransform.position = 
                transform.position; 
            } 
            if (matchRotation &amp;&amp; 
            Vector3.Angle(agentTransform.forward, 
            transform.forward) &gt; 1f) 
            { 
                agentTransform.rotation = 
                Quaternion.Lerp(agentTransform.rotation, 
                transform.rotation, Time.deltaTime * 
                lerpSpeed); 
            }  
            else 
            { 
                agentTransform.rotation = 
                transform.rotation; 
                matchRotation = false; 
            } 
        } </pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Lastly, we check if we want to play the animation after the character's position and/or rotation was matched with the Action Point. If so, we play the animation now (as the character position and/or rotation was adjusted):</li></ol></div><pre class="programlisting">        if (matchBeforeAction) 
        { 
            anim.SetTrigger(actionTrigger); 
        } </pre><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Save the script.</li><li>Create a new empty game object, call it <strong class="userinput"><code>Action Point</code></strong>, and place it in the scene, where the character should perform the action.</li><li>Attach the script to the <strong class="userinput"><code>Action Point</code></strong> game object. Drag and drop the character to the <strong class="userinput"><code>Agent</code></strong> field of the script's component.</li><li>You may need to adjust the <strong class="userinput"><code>Action Distance</code></strong> value of the script. You can also set the <strong class="userinput"><code>Match Position</code></strong>, <strong class="userinput"><code>Match Rotation</code></strong>, and <strong class="userinput"><code>Match Before Action</code></strong> options to achieve different results.</li><li>Play the game to see the effect.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec169"></a>How it works...</h3></div></div></div><p>The <code class="literal">ActionPoint.cs</code> script's role is to tell the character where to go and what animation to play. The <code class="literal">PerformAction()</code> coroutine also adjusts the character's position and rotation to match the position and rotation of the <strong class="userinput"><code><span>Action</span><a id="id325241438" class="indexterm"></a> Point</code></strong>. We use the simple <code class="literal">Lerp()</code> function here for both the position and the rotation. In most cases, it's enough.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec170"></a>There's more...</h3></div></div></div><p>You may also use the <code class="literal">MatchTarget()</code> function to interpolate the character's position and rotation and match it with the <strong class="userinput"><code>Action Point</code></strong>. We were using this technique in the <span class="emphasis"><em>Adding animation to off-mesh links</em></span> recipe in <span><a class="link" href="#" linkend="ch04">Chapter 4</a></span>, <span class="emphasis"><em>Character Movement</em></span>. In such cases, it would be best to have a special approach animation in which the character approaches the <strong class="userinput"><code><span>Action Point</span><a id="id325241477" class="indexterm"></a></code></strong>.</p><p>You may also want to use the randomized actions concept for creating <strong class="userinput"><code>Action Points</code></strong> with random actions. The concept is described in the <span class="emphasis"><em>Using Blend Trees to create randomized actions</em></span> recipe. Instead of creating random actions, you can also prepare a <code class="literal">public enum Action</code> variable containing all your actions as enumerations and a <code class="literal">pu</code> variable to store the <code class="literal">Action</code> in the Actionable Action <strong class="userinput"><code>actionPointAction</code></strong> variable to store the Action in the <strong class="userinput"><code>Action Point</code></strong>. Then you need to set the <strong class="userinput"><code>RandomAction</code></strong> parameter (as described in the mentioned recipe) to the <code class="literal">(float) actionPointAction</code> value. This will allow you to use <strong class="userinput"><code>Blend Trees</code></strong> for performing specified actions (instead of random ones).</p><p>Also, in many cases, you will need to divide your actions into three steps:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code><span>Pre-Action</span><a id="id325241528" class="indexterm"></a></code></strong>: This animation can be used to approach the <strong class="userinput"><code>Action Point</code></strong> or as a "state transition" animation. For instance, when we want our character to sit on a chair it is good to have a <strong class="userinput"><code>Pre-Action</code></strong> animation of the character sitting (transition from <strong class="userinput"><code>Idle</code></strong> to <strong class="userinput"><code>Sitting</code></strong> states).</li><li style="list-style-type: disc"><strong class="userinput"><code><span>Looped-Action</span><a id="id325241895" class="indexterm"></a></code></strong>: A looped animation suitable for this Action Point. In our sitting example, that would be a looped sitting animation. It can also be a series of animations (our character can, for instance, sit and eat or sit and drink).</li><li style="list-style-type: disc"><strong class="userinput"><code><span>Post-Action</span><a id="id325241906" class="indexterm"></a></code></strong>: This is an animation that transitions from the <strong class="userinput"><code>Looped-Action</code></strong> animation to the <strong class="userinput"><code>Idle</code></strong> animation. In our example, it would be a character getting up from the chair.</li></ul></div></div></div>