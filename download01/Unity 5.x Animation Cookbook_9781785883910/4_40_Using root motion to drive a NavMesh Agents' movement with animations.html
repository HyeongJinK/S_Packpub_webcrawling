<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec44"></a>Using root motion to drive a NavMesh Agents' movement with animations</h2></div></div><hr /></div><p>In this recipe, we will use <span>root motion</span><a id="id325531890" class="indexterm"></a> to move and steer a character with a Nav<span>Mesh Agent component</span><a id="id325531898" class="indexterm"></a>. This can be used to get rid of foot sliding in this type of character.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec128"></a>Getting ready</h3></div></div></div><p>We are going to use the same character as in the previous recipe with all its animations. You should have a character with at least the <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, and <strong class="userinput"><code>WalkRight</code></strong> animations ready and set up in the Animator Controller the same way as in the <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe. You can also go to the <code class="literal">Chapter 04 Character movement\Recipe 07 Using root motion to drive Navmesh Agents movement with animations</code> directory. You will find an <code class="literal">Example.unity</code> scene there. Open it, play the game, and click on the ground to make the characters move using <strong class="userinput"><code>NavMesh</code></strong> Agents and root motion.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec129"></a>How to do it...</h3></div></div></div><p>To use <span>root motion</span><a id="id325532116" class="indexterm"></a> for moving and steering a character with <span>Nav Mesh</span><a id="id325532124" class="indexterm"></a> Agent component, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the character with the <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, and <strong class="userinput"><code>WalkRight</code></strong> animations and set it up the same way as in the <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe, but don't write the <code class="literal">RootMotionSteering.cs</code> script as we will create a new one.</li><li>Add the Nav Mesh Agent component to the character. Make sure it also has the <strong class="userinput"><code>Capsule Collider</code></strong> component and the <strong class="userinput"><code>Rigidbody</code></strong> component with frozen rotation in every axis. Also make sure that the Animator component's <strong class="userinput"><code>Apply Root Motion</code></strong> option is set to true and <strong class="userinput"><code>Update Mode</code></strong> set to <strong class="userinput"><code>Animate Physics</code></strong> (the same way as in the <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe).</li><li>Bake the <strong class="userinput"><code>NavMesh</code></strong> in the scene. To do so, make sure your ground model has a collider attached (you can use the <strong class="userinput"><code>Mesh Collider</code></strong> component). Then go to <strong class="userinput"><code>Window</code></strong> | <strong class="userinput"><code>Navigation</code></strong>. Select the ground in your scene and set it to <strong class="userinput"><code>Navigation Static</code></strong> in the <strong class="userinput"><code>Object</code></strong> tab of the <strong class="userinput"><code>Navigation</code></strong> window. Click on the <strong class="userinput"><code>Bake</code></strong> button at the bottom of the <strong class="userinput"><code>Navigation</code></strong> window. After a short while, <strong class="userinput"><code>NavMesh</code></strong> should be baked (it is visible in the scene as a light blue, semitransparent mesh covering the ground model). It is needed for our <strong class="userinput"><code>NavMesh</code></strong> Agent to work.</li><li>If your character is using any scripts from this book, remove them from its <strong class="userinput"><code>Inspector</code></strong> (we don't need the <strong class="userinput"><code>Jump</code></strong>, <strong class="userinput"><code>RootMotionSteering</code></strong>, and <strong class="userinput"><code>SetRawDirectionAndSpeed</code></strong> scripts).</li><li>Create a new script and call it <code class="literal">NavMeshAgentWithRigidBody.cs</code>. We will use both the <strong class="userinput"><code>NavMesh</code></strong> Agent and the <strong class="userinput"><code>Rigidbody</code></strong> components in this script.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>In the <code class="literal">Update()</code> function of the script, we first disable updating rotation and position in the <strong class="userinput"><code>NavMesh</code></strong> Agent. That will prevent the agent from moving our character's transform. Then we calculate the <code class="literal">float direction</code> variable's value. We do it in a very similar way to what we did in the <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe, but instead of creating our own <code class="literal">desiredMoveDirection</code> vector, we are using the <strong class="userinput"><code>NavMesh</code></strong> Agent's <code class="literal">desiredVelocity</code> vector. This vector describes the speed and direction the agent would like to move with:</li></ol></div><pre class="programlisting">        agent.updatePosition = false; 
        agent.updateRotation = false; 
 
        direction = Vector3.Angle(transform.forward, 
        agent.desiredVelocity) * 
        Mathf.Sign(Vector3.Dot(agent.desiredVelocity, 
        transform.right)); </pre><p>In the <span>preceding</span><a id="id325549051" class="indexterm"></a> code <code class="literal">agent</code> is the variable in which we store the reference to the <span>Nav Mesh Agent component</span><a id="id325550873" class="indexterm"></a>. We set this reference in the <code class="literal">Start()</code> function.</p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Next we calculate the <code class="literal">float speed</code> variable value: it's simply the magnitude of the <code class="literal">agent.desiredVelocity</code> vector. We also set the <strong class="userinput"><code>Direction</code></strong>, <strong class="userinput"><code>Speed</code></strong>, <strong class="userinput"><code>DirectionRaw</code></strong>, and <strong class="userinput"><code>SpeedRaw</code></strong> parameters in our Animator Controller using the <code class="literal">anim</code> variable that stores the reference to the Animator component. The <code class="literal">anim</code> variable is set in the <code class="literal">Start()</code> function. Lastly, we set the <code class="literal">agent.nextPosition</code> to be the same as our transform position every frame. This prevents the agent from moving away from our character's transform.</li><li>Save the script and attach it to the character.</li><li>We also need a script to tell the <strong class="userinput"><code>NavMesh</code></strong> Agent where we want to go. There is a <code class="literal">ClickToMove.cs</code> script in the <code class="literal">Shared Scripts</code> folder in the provided Unity example. In the <code class="literal">Update()</code> function, we use the <code class="literal">agent.SetDestination()</code> method when the player presses the left mouse button. A ray is cast from the mouse cursor position in the main camera's forward direction. If the ray hits a collider, the hit position is used to set the new destination for the <strong class="userinput"><code>NavMesh</code></strong> Agent:</li></ol></div><pre class="programlisting">        if (Input.GetKeyDown(KeyCode.Mouse0)) 
        { 
            if (Physics.Raycast(Camera.main.ScreenPointToRay(
            Input.mousePosition), out hit)) 
            { 
                agent.SetDestination(hit.point); 
            } 
        } </pre><p>In the preceding code <code class="literal">agent</code> is a <code class="literal">public NavMeshAgent</code> variable that stores the reference to the <span>Nav Mesh Agent component</span><a id="id325531995" class="indexterm"></a>. We assign this reference manually in the <strong class="userinput"><code>Inspector</code></strong> by dragging the game object with the Nav Mesh Agent component to the <strong class="userinput"><code>Agent</code></strong> field of the script. The <code class="literal">hit</code> variable is a global <code class="literal">RaycastHit</code> variable that is used by the <code class="literal">Physics.Raycast()</code> method to store the ray cast result.</p><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Save the script and attach it to the character. Drag and drop the character game object to the <strong class="userinput"><code>Agent</code></strong> field of the script (the script is attached to the same game object but can be attached to any game object).</li><li>Play the game and click on the ground to see the character move using both <strong class="userinput"><code>NavMesh</code></strong> Agent and root motion.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec130"></a>How it works...</h3></div></div></div><p>This recipe has a few key elements that make it work:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>NavMesh and NavMesh Agent</strong></span>: Nav Mesh Agent component is used to navigate in the game level with a baked <strong class="userinput"><code>NavMesh</code></strong>. Without one of those elements, our character wouldn't be able to move effectively with point and click input.</li><li style="list-style-type: disc"><span class="strong"><strong>Disabling the agent's updateRotation and updatePosition</strong></span>: By default, <strong class="userinput"><code>NavMesh</code></strong> Agents update the rotation and position of a game object. To use root motion, we need to disable this feature and update the game object's position and rotation with the root node animation instead.</li><li style="list-style-type: disc"><span class="strong"><strong>Rigid Body and Animator with Apply Root Motion set to true</strong></span>: We use Rigid Body to have collisions between all the objects in the game (not only other <strong class="userinput"><code>NavMesh</code></strong> Agents) and we use the <strong class="userinput"><code>Apply Root Motion</code></strong> option in the Animator to make the character move with root node animation.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec131"></a>There's more...</h3></div></div></div><p>In the <code class="literal">Scripts</code> directory of this recipe, you can also find a <code class="literal">NavAgent.cs</code> script that uses root motion without the <strong class="userinput"><code>Rigidbody</code></strong> component. The <code class="literal">Update()</code> function of the script is very similar to the <code class="literal">NavMeshAgentWithRigidBody.cs</code> script that we were using in this recipe, but we enable updating the position by the Nav Mesh Agent component. We only disable rotation updating. We add a <code class="literal">OnAnimatorMove()</code> function to the script. This method is called every frame after Unity finishes evaluating all the states in the Animator.</p><p>In that function, we set the <code class="literal">agent.velocity</code> vector to be the same as the velocity of the root node. We also update the transform rotation to be the same as the root node's rotation:</p><pre class="programlisting">        void OnAnimatorMove() 
        { 
            agent.velocity = anim.deltaPosition /  
            Time.deltaTime; 
     
            transform.rotation = anim.rootRotation; 
        } </pre></div></div>