<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec48"></a>Using root motion for climbing</h2></div></div><hr /></div><p>In this recipe, we will use <span>root motion</span><a id="id325531685" class="indexterm"></a> animations to <span>climb</span><a id="id325531693" class="indexterm"></a> a ladder.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec143"></a>Getting ready</h3></div></div></div><p>We are going to use the same character as in the <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe with the <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, and <strong class="userinput"><code>WalkRight</code></strong> animations. You should prepare four additional animations: <strong class="userinput"><code>ToClimb</code></strong> (it should start with idle and end with <strong class="userinput"><code>ClimbIdle</code></strong> and should be done "in place" without hip movement), <strong class="userinput"><code>ClimbIdle</code></strong> (a looped animation where our character is idle on the ladder), <strong class="userinput"><code>ClimbUp</code></strong> (a looped animation, where our character moves one ladder step up; it starts and ends with <strong class="userinput"><code>ClimbIdle</code></strong> pose), and <strong class="userinput"><code>ClimbEnd</code></strong> (an animation similar to the <strong class="userinput"><code>EdgeGrabClimb</code></strong> from the <span class="emphasis"><em>Using triggers to grab an edge while jumping</em></span> recipe). We are going to use the <code class="literal">RootMotionSteering.cs</code> script from the <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe to make the character move. You also need a ladder model with which your <strong class="userinput"><code>ClimbUp</code></strong> animation is synced. You can also go to the <code class="literal">Chapter 04 Character movement\Recipe 11 Using root motion for climbing</code> directory. You will find an <code class="literal">Example.unity</code> scene there. Open it, play the game, and walk near the ladder and keep the up arrow pressed to start climbing.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec144"></a>How to do it...</h3></div></div></div><p>To use <span>root motion</span><a id="id325532126" class="indexterm"></a> for <span>climb</span><a id="id325532258" class="indexterm"></a>ing, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the character with <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, <strong class="userinput"><code>WalkRight</code></strong>, <strong class="userinput"><code>ToClimb</code></strong>, <strong class="userinput"><code>ClimbIdle</code></strong>, <strong class="userinput"><code>ClimbUp</code></strong>, and <strong class="userinput"><code>ClimbEnd</code></strong> animations.</li><li>Create a new Animator Controller identical to the one from <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe (with <strong class="userinput"><code>Idle</code></strong> and <strong class="userinput"><code>Steering</code></strong> states).</li><li>Add the <strong class="userinput"><code>Rigidbody</code></strong> component to the character and freeze its rotations.</li><li>Add the <strong class="userinput"><code>Capsule Collider</code></strong> component to the character and make sure its <strong class="userinput"><code>Height</code></strong> and <strong class="userinput"><code>Center</code></strong> properties are set correctly (the <strong class="userinput"><code>Capsule Collider</code></strong> starts at your character's feet).</li><li>Attach the <code class="literal">RootMotionSteering.cs</code> script to the character. It should now move (make sure to have a collider on the ground).</li><li>Drag and drop the <strong class="userinput"><code>ToClimb</code></strong>, <strong class="userinput"><code>ClimbIdle</code></strong><span class="strong"><strong>,</strong></span><strong class="userinput"><code>ClimbUp</code></strong>, and <strong class="userinput"><code>ClimbEnd</code></strong> animations into the controller.</li><li>Create a <code class="literal">bool</code><strong class="userinput"><code>Climb</code></strong> parameter and a <code class="literal">bool</code><strong class="userinput"><code>ClimbUp</code></strong> parameter in the controller.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Create seven <span>additional</span><a id="id325532635" class="indexterm"></a> transitions (see the following screenshot):
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Idle</code></strong> | <strong class="userinput"><code>To<span>Climb</span><a id="id325532723" class="indexterm"></a></code></strong> with one condition: <strong class="userinput"><code>Climb</code></strong> parameter set to true. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.1 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>Steering</code></strong> | <strong class="userinput"><code>ToClimb</code></strong> with one condition: <strong class="userinput"><code>Climb</code></strong> parameter set to true. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.1 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>ToClimb</code></strong> | <strong class="userinput"><code>ClimbIdle</code></strong> with no conditions: <strong class="userinput"><code>Has Exit Time</code></strong> should be set to true and <strong class="userinput"><code>Transition Duration</code></strong> set to 0.1 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>ClimbIdle</code></strong> | <strong class="userinput"><code>ClimbUp</code></strong> with one condition: <strong class="userinput"><code>ClimbUp</code></strong> parameter set to true. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.1 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>ClimbUp</code></strong> | <strong class="userinput"><code>ClimbIdle</code></strong> with one condition: <strong class="userinput"><code>ClimbUp</code></strong> parameter set to false. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to true and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.1 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>ClimbUp</code></strong> | <strong class="userinput"><code>ClimbEnd</code></strong> with one condition: <strong class="userinput"><code>Climb</code></strong> parameter set to false. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to true and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.1 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>ClimbEnd</code></strong> | <strong class="userinput"><code>Idle</code></strong> with no conditions: <strong class="userinput"><code>Has Exit Time</code></strong> should be set to true and <strong class="userinput"><code>Transition Duration</code></strong> set to 0.1 seconds.</li></ul></div></li></ol></div><div class="mediaobject"><img src="/graphics/9781785883910/graphics/655977d1-ea6f-4c8c-8b40-5296fd6f1696.png" /></div><p>Animator Controller for climbing</p><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Create two triggers (game objects with <strong class="userinput"><code>Box Collider</code></strong> components set to <strong class="userinput"><code>Is Trigger</code></strong>), <strong class="userinput"><code>ClimbStart</code></strong> and <strong class="userinput"><code>ClimbEnd,</code></strong> in the scene. One should be near the start of the <span>ladder</span><a id="id325550882" class="indexterm"></a> and the other near the end of it. Also create a <strong class="userinput"><code>RootTarget</code></strong> game object: it <span>will</span><a id="id325550893" class="indexterm"></a> be used to adjust the position of our character to match the ladder, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781785883910/graphics/b43c7ae3-4a02-4e3a-a74b-12987b1c9f49.png" /></div><p>RootTarget game object, ClimbStart, and ClimbEnd triggers placement</p><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Create a new <code class="literal">Climb.cs</code> script. Write a <code class="literal">public void StartClimbing(Transform startNode)</code> function in it. This function will be called from the <code class="literal">ClimbStart</code> trigger. In it, we turn off the rigid body physics, set the <code class="literal">climbNode</code> (the transform we want to adjust our position to), set the <strong class="userinput"><code>Climb</code></strong> parameter in the controller to start playing the <strong class="userinput"><code>ToClimb</code></strong> animation, and start an <code class="literal">AdjustPosition</code> coroutine to adjust our character's position:</li></ol></div><pre class="programlisting">        rb.isKinematic = true; 
        climbNode = startNode; 
        anim.SetBool("Climb", true); 
        StartCoroutine("AdjustPosition"); 
                </pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Then write the <code class="literal">IEnumerator AdjustPosition()</code> co-routine in which we check if our character's position is close enough to the <code class="literal">climbNode's</code> position. If not, we adjust the position and rotation using the <code class="literal">Lerp</code> method. After we finish adjusting the position, we set a <code class="literal">canClimb</code> flag to true to turn on the climbing input in the <code class="literal">Update()</code> function:</li></ol></div><pre class="programlisting">        while((transform.position - 
        climbNode.position).magnitude &gt; 0.05f) 
        { 
             yield return null; 
             transform.position = 
             Vector3.Lerp(transform.position, 
             climbNode.position, Time.deltaTime * lerpSpeed);           
             transform.rotation = 
             Quaternion.Lerp(transform.rotation, 
             climbNode.rotation, Time.deltaTime * lerpSpeed); 
         } 
          transform.position = climbNode.position; 
          transform.rotation = climbNode.rotation; 
          canClimb = true;            </pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Next we write a <code class="literal">public void EndClimbing()</code> function that will be called from the <code class="literal">ClimbStop</code> trigger game object. In the function, we disable the climb input, set the <strong class="userinput"><code>Climb</code></strong> parameter to false in our controller, and start a <code class="literal">ReEnableMovement</code> coroutine to turn the rigid body physics back on:</li></ol></div><pre class="programlisting">        canClimb = false; 
        anim.SetBool("Climb", false); 
        StartCoroutine("ReEnableMovement");</pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Our <code class="literal">IEnumerator ReEnableMovement()</code> coroutine waits a certain amount of seconds set by the <code class="literal">public float climbEndAnimLenght</code> variable. After that, it turns the rigid body physics back on:</li></ol></div><pre class="programlisting">        yield return new WaitForSeconds(climbEndAnimLenght); 
        rb.isKinematic = false;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>In the <code class="literal">Update()</code> function of the script, we handle the climb input:</li></ol></div><pre class="programlisting">        if (canClimb &amp;&amp; Input.GetAxis("Vertical") &gt; 0f) 
        { 
           anim.SetBool("ClimbUp", true); 
        } 
        else 
        { 
           anim.SetBool("ClimbUp", false); 
        }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>Assign the script to our character and create two more scripts (one for each of our triggers). Name them <code class="literal">ClimbStartTrigger.cs</code> and <code class="literal">ClimbEndTrigger.cs</code>. Both scripts have one just function: <code class="literal">void OnTriggerEnter(Collider other)</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="16" type="1"><li>In the <code class="literal">ClimbStartTrigger.cs</code> script, we check if the entering object has the <code class="literal">Player</code> tag. If so, we get the <code class="literal">Climb</code> script component from that object and call the <code class="literal">StartClimbing(Transform startNode)</code> function on it. We <span>pass</span><a id="id325532004" class="indexterm"></a> a <code class="literal">public Transform startNode</code> object as the parameter. Our <strong class="userinput"><code>RootTarget</code></strong><span>game</span><a id="id325532018" class="indexterm"></a> object is assigned to this variable:</li></ol></div><pre class="programlisting">        if (other.gameObject.CompareTag("Player")) 
        { 
           Climb climbScript = 
           other.gameObject.GetComponent&lt;Climb&gt;(); 
           climbScript.StartClimbing(startNode); 
        }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="17" type="1"><li>In the <code class="literal">ClimbEndTrigger.cs</code>, we call the <code class="literal">StopClimbing()</code> function on the <code class="literal">Climb</code> script component:</li></ol></div><pre class="programlisting">        if (other.gameObject.CompareTag("Player")) 
        { 
            Climb climbScript = 
            other.gameObject.GetComponent&lt;Climb&gt;(); 
            climbScript.EndClimbing(); 
        }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="18" type="1"><li>Assign the <code class="literal">ClimbStartTrigger.cs</code> script to the <strong class="userinput"><code>ClimbStart</code></strong> trigger game object and the <code class="literal">ClimbEndTrigger.cs</code> script to the <strong class="userinput"><code>ClimbEnd</code></strong> game object.</li><li>Assign the <strong class="userinput"><code>RootTarget</code></strong> game object to the <strong class="userinput"><code>Start Node</code></strong> field of the <strong class="userinput"><code>ClimbStartTrigger</code></strong> script component in the <strong class="userinput"><code>ClimbStart</code></strong> game object's <strong class="userinput"><code>Inspector</code></strong>.</li><li>Play the game and approach the ladder (make sure you enter the <strong class="userinput"><code>ClimbStart</code></strong> trigger). You may need to adjust the <strong class="userinput"><code>RootTarget</code></strong>, <strong class="userinput"><code>ClimbStart</code></strong>, and <strong class="userinput"><code>ClimbEnd</code></strong> positions and the <code class="literal">climbEndAnimLenght</code> variable's value to match your needs. You may also need to adjust the root movement in the <strong class="userinput"><code>ClimbUp</code></strong> animation and animation's import settings: mostly the <strong class="userinput"><code>Bake Into Pose</code></strong> options (for instance, you may need to set this option for your <strong class="userinput"><code>ClimbUp</code></strong> animation's <strong class="userinput"><code>Root Transform Position (XY)</code></strong> and <strong class="userinput"><code>Root Transform Rotation</code></strong>).</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec145"></a>How it works...</h3></div></div></div><p>In this recipe, we turn off the rigid body physics when our character starts climbing. After that we use the root motion from our <strong class="userinput"><code>ClimbUp</code></strong> animation to make the character <span>climb</span><a id="id325532853" class="indexterm"></a> the ladder. This animation is looped, which lets us control the length of the ladder. After it reaches the <strong class="userinput"><code>ClimbEnd</code></strong> trigger, we play a <strong class="userinput"><code>ClimbEnd</code></strong> animation to get the <span>character</span><a id="id325532868" class="indexterm"></a> onto the platform to which the ladder is attached.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec146"></a>There's more...</h3></div></div></div><p>With this approach, the character will start to desynchronize with the ladder when the ladder is high enough. The animation error cumulates after each loop (and also when we transition to the <strong class="userinput"><code>ClimbIdle</code></strong> animation while climbing). I suggest three ways in which we can improve this feature:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>One long animation instead of a loop</strong></span>: Instead of using a looped animation, we can prepare several long animations for different ladder lengths. Using the <code class="literal">animator.speed</code> variable, we can set the playback speed of the whole Animator component in runtime. If we set it to 0 while player is not holding the up arrow, it will pause the animation. Unfortunately, this approach pauses all the animations. We can get around this by creating a <strong class="userinput"><code>Blend Tree</code></strong> with our <strong class="userinput"><code>LongClimbLadder</code></strong> animation with <strong class="userinput"><code>Time Scale</code></strong> set to 0 in the first <strong class="userinput"><code>Motion Field</code></strong> and the same animation at full speed in the second <strong class="userinput"><code>Motion Field</code></strong>. Then you can create a parameter to control the blending between those two animations to stop the player on the ladder. You can also add a third <strong class="userinput"><code>Motion Field</code></strong> with the <strong class="userinput"><code>Time Scale</code></strong> set to -1 to make the character go down the ladder.</li><li style="list-style-type: disc"><span class="strong"><strong>MatchTarget() solution</strong></span>: We can use the <code class="literal">animator.MatchTarget()</code> function to match the character's root node with our ladder's steps. Say our ladder has steps of height 30cm and our <strong class="userinput"><code>ClimbUp</code></strong> animation has roughly 30 cm root motion up. We can count the <strong class="userinput"><code>ClimbUp</code></strong> loops in runtime (with an Animation Event) and save them in a variable (let's name it <code class="literal">numberOfLoops</code>). Then we call <code class="literal">MatchTarget()</code> every time we play another loop of the <strong class="userinput"><code>ClimbUp</code></strong> animation. We set the <code class="literal">targetPosition's</code> Y component in the <code class="literal">MatchTarget()</code> function to be equal to <code class="literal">numberOfLoops * 0.3f</code>. That should synchronize our character with the ladder better.</li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Use IK</strong></span>: Finally, we can use IK for hands and feet to match the ladder's steps. The built-in <code class="literal">void OnAnimatorIK(int layerIndex)</code> function is a good solution. We have to use the <code class="literal">animator.SetIKPosition()</code> and <code class="literal">animator.SetIKPositionWeight()</code> functions to set goals for hands and feet. It is a good idea to create an <strong class="userinput"><code>Animation Curve</code></strong> in the <strong class="userinput"><code>ClimbUp</code></strong> animation and use its value in the <code class="literal">animator.SetIKPositionWeight()</code> function. You can find more about IK in the <span class="emphasis"><em>Using IK for interacting with scene objects</em></span> recipe in <span><a class="link" href="#" linkend="ch05">Chapter 5</a></span>, <span class="emphasis"><em>Character Actions and Expressions</em></span>.</li></ul></div></div></div>