<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec49"></a>Using root motion to create flying characters</h2></div></div><hr /></div><p>We've seen a lot of "hovering" monsters in games in the past, but creatures <span>flying</span><a id="id325289099" class="indexterm"></a> in full 3D space are still a quite fresh and tasty feature. Creating a behavior of such a monster with code is challenging, but we can use animations to make it both easy and great looking.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec147"></a>Getting ready</h3></div></div></div><p>To create a <span>flying</span><a id="id325289114" class="indexterm"></a> creature in this recipe, we need one animation without root motion, <strong class="userinput"><code>Idle</code></strong> (hovering in place), and nine animations with root motion: <strong class="userinput"><code>FlyingForward</code></strong> (flying straight forward), <strong class="userinput"><code>FlyingForwardUp</code></strong> (flying forward and increasing altitude at the same time), <strong class="userinput"><code>FlyingForwardDown</code></strong> (flying forward and decreasing altitude at the same time), <strong class="userinput"><code>FlyingLeft</code></strong> (flying left in circles-the same way as the <strong class="userinput"><code>WalkLeft</code></strong> animation in previous recipes), <strong class="userinput"><code>FlyingRight</code></strong> (flying right in circles), <strong class="userinput"><code>FlyingLeftUp</code></strong> (flying left in circles with increasing altitude), <strong class="userinput"><code>FlyingLeftDown</code></strong> (flying left in circles with decreasing altitude), <strong class="userinput"><code>FlyingRightUp</code></strong> (flying right in circles with increasing altitude), and <strong class="userinput"><code>FlyingRightDown</code></strong> (flying right in circles with decreasing altitude). All these animations should have the same length and synchronized wing motion if possible. You can also go to the <code class="literal">Chapter 04 Character movement\Recipe 12 Using root motion to create flying characters</code> directory. You will find an <code class="literal">Example.unity</code> scene there. Open it and play the game to see a flying bird (it has a patrol route).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec148"></a>How to do it...</h3></div></div></div><p>To create a <span>flying</span><a id="id325509756" class="indexterm"></a> creature, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the <span>character</span><a id="id325509811" class="indexterm"></a> with all required animations. Set the <strong class="userinput"><code>Idle</code></strong> animation <strong class="userinput"><code>Bake Into Pose</code></strong> options to true.</li><li>Create a new Animator Controller.</li><li>Create three parameters in the controller: <strong class="userinput"><code>Speed</code></strong>, <strong class="userinput"><code>DirectionHor</code></strong>, and <strong class="userinput"><code>DirectionVer</code></strong>.</li><li>Create a new <strong class="userinput"><code>Blend Tree</code></strong> in the controller and double-click on it to enter its settings. Set its parameter to <strong class="userinput"><code>Speed</code></strong>.</li><li>Add one <strong class="userinput"><code>Motion Field</code></strong> and one <strong class="userinput"><code>Blend Tree</code></strong> to the currently selected <strong class="userinput"><code>Blend Tree</code></strong>. Uncheck the <strong class="userinput"><code>Automate Thresholds</code></strong> option and set the first threshold to 0 and the second one to 1.</li><li>Assign the <strong class="userinput"><code>Idle</code></strong> animation to the <strong class="userinput"><code>Motion Field</code></strong>.</li><li>Click on the second <strong class="userinput"><code>Blend Tree</code></strong> (that connected to the first one). Set its type to <strong class="userinput"><code>2D Freeform Cartesian</code></strong>.</li><li>Set the first parameter (X) of the second<strong class="userinput"><code>Blend Tree</code></strong> to <strong class="userinput"><code>DirectionHor</code></strong> and the second one (Y) to <strong class="userinput"><code>DirectionVer</code></strong>.</li><li>Add nine <strong class="userinput"><code>Motion Fields</code></strong> to the second <strong class="userinput"><code>Blend Tree</code></strong>.</li><li>Set the Motion Fields as follows (also see the following screenshot):
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>FlyLeftDown</code></strong>: Pos X set to -45, Pos Y set to -45</li><li style="list-style-type: disc"><strong class="userinput"><code>FlyLeft</code></strong>: Pos X set to -45, Pos Y set to 0</li><li style="list-style-type: disc"><strong class="userinput"><code>FlyLeftUp</code></strong>: Pos X set to -45, Pos Y set to 45</li><li style="list-style-type: disc"><strong class="userinput"><code>FlyForwardDown</code></strong>: Pos X set to 0, Pos Y set to 45</li><li style="list-style-type: disc"><strong class="userinput"><code>FlyForward</code></strong>: Pos X set to 0, Pos Y set to 0</li><li style="list-style-type: disc"><strong class="userinput"><code>FlyForwardUp</code></strong>: Pos X set to 0, Pos Y set to 45</li><li style="list-style-type: disc"><strong class="userinput"><code>FlyRightDown</code></strong>: Pos X set to 45, Pos Y set to -45</li><li style="list-style-type: disc"><strong class="userinput"><code>FlyRight</code></strong>: Pos X set to 45, Pos Y set to 0</li><li style="list-style-type: disc"><strong class="userinput"><code>FlyRightUp</code></strong>: Pos X set to 45, Pos Y set to 45</li></ul></div></li></ol></div><div class="mediaobject"><img src="/graphics/9781785883910/graphics/2791402d-db13-496c-91f2-41898edfeb94.png" /></div><p>Nested Blend Tree and a two dimensional Blend Tree used for flying</p><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Close the Animator Controller.</li><li>Add the <strong class="userinput"><code>Rigidbody</code></strong> component to the character, freeze its rotations, and turn off its gravity.</li><li>Add the <strong class="userinput"><code>Sphere Collider</code></strong> component to the character and make sure its <strong class="userinput"><code>Radius</code></strong> and <strong class="userinput"><code>Center</code></strong> properties are set correctly (it should encapsulate the whole character).</li><li>Set the <strong class="userinput"><code>Animator</code></strong> component's <strong class="userinput"><code>Update Mode</code></strong> to <strong class="userinput"><code>Animate Physics</code></strong> and make sure the <strong class="userinput"><code>Apply Root Motion</code></strong> option is checked.</li><li>Create a new script and call it <code class="literal">FlyingPatrol.cs</code>.</li><li>In that script, we have two functions. The first function is <code class="literal">PatrolCheck()</code>, which checks the distance to the current patrol point (a game object in the scene) and assigns a new patrol point if our character is close enough to the current patrol point. All patrol points are stored in the <code class="literal">public Transform[] patrolPoints</code> array.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="17" type="1"><li>In the second function, called <code class="literal">CalculateDirectionsAndSpeed()</code>, we first calculate the <code class="literal">desiredMoveDirection</code> vector. This is a vector starting at our character's <code class="literal">transform.position</code> and ending at <code class="literal">currentPatrolPoint.position</code>. We use this vector to calculate the <code class="literal">speed</code> value (it's the magnitude of this vector). After that we calculate the <code class="literal">horizontalDirection</code> vector by setting our <code class="literal">desiredMoveDirection</code> vector's Y component to 0. We use the <code class="literal">horizontalDirection</code> vector to calculate the <code class="literal">horizontalAngle</code>. We check the sign of the angle with the <code class="literal">Vector3.Dot()</code> and <code class="literal">Mathf.Sign()</code><span>functions</span><a id="id325531720" class="indexterm"></a>, similar to what we did in the <span class="emphasis"><em>Using <span>root motion</span><a id="id325531731" class="indexterm"></a> to steer a character</em></span> recipe. This is the angle between the <code class="literal">horizontalDirection</code> and our character's <code class="literal">transform.forward</code> vector. Next we calculate the <code class="literal">verticalAngle</code>. We use those calculated values to set the <strong class="userinput"><code>DirectionHor</code></strong>, <strong class="userinput"><code>DirectionVer</code></strong>, and <strong class="userinput"><code>Speed</code></strong> parameters in our Animator Controller. We use quite large <code class="literal">dampTime</code> values here to make the blends smoother:</li></ol></div><pre class="programlisting">       desiredMoveDirection = currentPatrolPoint.position -
            transform.position;
            speed = desiredMoveDirection.magnitude;
            horizontalDirection = new Vector3(desiredMoveDirection.x,
              0f, desiredMoveDirection.z).normalized;
            horizontalAngle = Vector3.Angle(horizontalDirection,
              transform.forward) * Mathf.Sign(
            Vector3.Dot(horizontalDirection, transform.right));
            verticalAngle = Vector3.Angle(desiredMoveDirection,
              horizontalDirection) * Mathf.Sign(
            Vector3.Dot(desiredMoveDirection, transform.up));
                 
           anim.SetFloat("Speed", speed, 0.25f, Time.deltaTime);
           anim.SetFloat("DirectionHor", horizontalAngle, 0.5f,
            Time.deltaTime); 
           anim.SetFloat("DirectionVer", verticalAngle, 0.5f,
            Time.deltaTime);          </pre><div class="orderedlist"><ol class="orderedlist arabic" start="18" type="1"><li>In the <code class="literal">Update()</code> function of our script, we call both the <code class="literal">PatrolCheck()</code> and <code class="literal">CalculateDirectionsAndSpeed()</code> functions.</li><li>Assign the script to our character.</li><li>Create several patrol points (empty game objects) and assign them to the <code class="literal">Patrol Points</code> array in our character's <code class="literal">Flying Patrol</code> script component.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec149"></a>How it works...</h3></div></div></div><p>This recipe uses a very similar concept to the <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe. The only difference is that here we are also using vertical movement and a slightly more complicated <strong class="userinput"><code>Blend Tree</code></strong>. This is a 2D version of a <strong class="userinput"><code>Blend Tree</code></strong> that blends animations using two parameters instead of one. This way we can feed <strong class="userinput"><code>DirectionHor</code></strong> and <strong class="userinput"><code>DirectionVer</code></strong> parameters to it to blend both horizontal and vertical movements.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec150"></a>There's more...</h3></div></div></div><p>Our character is not very smart-it can collide with objects, but it cannot do any path finding. You can implement a 3D path finding solution (based on a graph of points in space, for instance) or use one from the Asset Store. You can also use Unity's standard built-in <strong class="userinput"><code>NavMesh</code></strong> Agent to find the path on the terrain and only control the height of the character.</p><p>You can also switch between <span>flying</span><a id="id325532214" class="indexterm"></a> and walking modes by setting a target point on the ground for the character to land, checking the ground with a <code class="literal">Physics.Raycast()</code> method, and turning the gravity back on and implementing the <span class="emphasis"><em>Using <span>root motion</span><a id="id325532229" class="indexterm"></a> to steer a character</em></span> recipe to move the character when grounded.</p><p>Â </p></div></div>