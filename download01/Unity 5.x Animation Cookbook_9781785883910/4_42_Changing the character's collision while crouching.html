<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec46"></a>Changing the character's collision while crouching</h2></div></div><hr /></div><p>In this recipe, we will learn how to change our <span>character's</span><a id="id325531890" class="indexterm"></a> collision while crouching. This way our character will be able to enter low areas (such as vent shafts).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec135"></a>Getting ready</h3></div></div></div><p>We are going to use the same character as in the <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe with all its animations (<strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, and <strong class="userinput"><code>WalkRight</code></strong>). Additionally, you should prepare those four animations in a crouch state (<strong class="userinput"><code>IdleCrouch</code></strong>, <strong class="userinput"><code>WalkLeftCrouch</code></strong>, <strong class="userinput"><code>WalkForwardCrouch</code></strong>, and <strong class="userinput"><code>WalkRightCrouch</code></strong>). We are going to use the <code class="literal">RootMotionSteering.cs</code> script from the preceding mentioned recipe. You also need an obstacle in your scene. It should have a passage underneath. The passage's ceiling should be low enough so that the character cannot go through it without crouching. We don't need any other scripts to start. You can also go to the <code class="literal">Chapter 04 Character movement\Recipe 09 Changing the characters collision while crouching</code> directory. You will find an <code class="literal">Example.unity</code> scene there. Open it, play the game, and try to walk through a stone arch on the scene. The character will automatically crouch. You can also make him crouch by holding the <span class="emphasis"><em>C</em></span> key.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec136"></a>How to do it...</h3></div></div></div><p>To change the size of a collider while crouching, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the <span>character</span><a id="id325532131" class="indexterm"></a> with <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, <strong class="userinput"><code>WalkRight</code></strong>, <strong class="userinput"><code>IdleCrouch</code></strong><span class="strong"><strong>,</strong></span><strong class="userinput"><code>WalkLeftCrouch</code></strong><span class="strong"><strong>,</strong></span><strong class="userinput"><code>WalkForwardCrouch</code></strong>, and <strong class="userinput"><code>WalkRightCrouch</code></strong> animations.</li><li>Create a new Animator Controller.</li><li>Right-click on the empty space of the controller and choose <strong class="userinput"><code>Create State</code></strong> | <strong class="userinput"><code>New From Blend Tree</code></strong>. We need two such states. Name one of them <strong class="userinput"><code>Idle</code></strong> and the second one <strong class="userinput"><code>Steering</code></strong>.</li><li>Create three <code class="literal">float</code> parameters in the controller: <strong class="userinput"><code>Speed</code></strong>, <strong class="userinput"><code>Direction</code></strong>, and <strong class="userinput"><code>Crouch</code></strong>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Create two transitions:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Idle</code></strong> | <strong class="userinput"><code>Steering</code></strong> with one condition: <strong class="userinput"><code>Speed</code></strong> parameter value greater than 0.5. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.2 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>Steering</code></strong> | <strong class="userinput"><code>Idle</code></strong> with one condition: <strong class="userinput"><code>Speed</code></strong> parameter value less than 0.5. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to <span>around</span><a id="id325532725" class="indexterm"></a> 0.2 seconds.</li></ul></div></li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Double-click on the <strong class="userinput"><code>Idle</code></strong> state. Set the <strong class="userinput"><code>Blend Tree Parameter</code></strong> to <strong class="userinput"><code>Crouch</code></strong>, add two <strong class="userinput"><code>Motion</code></strong> fields, and uncheck the <strong class="userinput"><code>Automate Thresholds</code></strong> option. Set the first <strong class="userinput"><code>Threshold</code></strong> to 0 and the second one to 1. Assign the <strong class="userinput"><code>Idle</code></strong> animation to the first <strong class="userinput"><code>Motion</code></strong> field and <strong class="userinput"><code>IdleCrouch</code></strong> to the second one, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781785883910/graphics/1c580aa9-6d68-48b7-93f5-8e85c3d964a7.png" /></div><p>Idle and IdleCrouch animations blending with a Blend Tree</p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Double-click on the empty space in the controller to get out of the Blend Tree settings.</li><li>Double-click on the <strong class="userinput"><code>Steering Blend Tree</code></strong>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Set the <strong class="userinput"><code>Blend Tree Parameter</code></strong> to <strong class="userinput"><code>Crouch</code></strong> and add two new Blend Trees (instead of Motion fields). Uncheck <strong class="userinput"><code>Automate Thresholds</code></strong> and set the first one to 0 and the second one to 1. Click on the first added Blend Tree and set its <strong class="userinput"><code>Parameter</code></strong> to <strong class="userinput"><code>Direction</code></strong>. Add three Motion fields. Uncheck the <strong class="userinput"><code>Automate Thresholds</code></strong> option. Set the first <strong class="userinput"><code>Threshold</code></strong> to -45, the second one to 0, and the third one to 45. Assign the <strong class="userinput"><code>WalkLeft</code></strong> animation to the first motion field, the <strong class="userinput"><code>WalkForward</code></strong> animation to the second one, and the <strong class="userinput"><code>WalkRight</code></strong> animation to the third one. Do the same for the second added Blend Tree, but assign <strong class="userinput"><code>WalkLeftCrouch</code></strong>, <strong class="userinput"><code>WalkForwardCrouch</code></strong>, and <strong class="userinput"><code>WalkRightCrouch</code></strong> animations instead, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781785883910/graphics/75c987a1-2b87-4adb-ba1a-ff6b7177bddd.png" /></div><p>Nested Blend Trees used for normal and crouch states</p><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Close the Animator Controller and assign it to our character's Animator component.</li><li>Assign the <code class="literal">RootMotionSteering.cs</code> script (follow the <span class="emphasis"><em>Using root motion to steer a character</em></span> recipe if necessary), <strong class="userinput"><code>Rigidbody</code></strong> component, and a <strong class="userinput"><code>Capsule Collider</code></strong> component to our character.</li><li>Create a new script and call it <code class="literal">Crouch.cs</code>.</li><li>In the <code class="literal">Update()</code> function of the script, we first check the <span class="emphasis"><em>height of the ceiling</em></span> above our <span>character's</span><a id="id325550904" class="indexterm"></a> head. To do so, we use the <code class="literal">Physics.Raycast()</code> function. We cast a ray from a position 25 cm above our character's feet (to avoid hitting ground obstacles) and the ray has a length of 2 meters. If the ray hits anything, we set the <code class="literal">cantStandUp</code> variable to true. It is used later in the script:</li></ol></div><pre class="programlisting">        cantStandUp = Physics.Raycast(transform.position + 
        Vector3.up * 0.25f, Vector3.up, 2f);</pre><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Next we check if player holds the <span class="emphasis"><em>C</em></span> key or if our character cannot stand up. If so, we set the <code class="literal">Crouch</code> parameter to play the crouch animations. We also scale down the <strong class="userinput"><code>Capsule Collider</code></strong> attached to the character (we get the reference to this component in the <code class="literal">Start()</code> function and save it in the <code class="literal">capsule</code> variable). We check if the <strong class="userinput"><code>Capsule Collider</code></strong> isn't scaled down already with the <code class="literal">capsule.height &gt; 1.5f</code> line. This is because we don't want to scale the capsule every frame (especially if it was already scaled down):</li></ol></div><pre class="programlisting">       if (Input.GetKey(KeyCode.C) || cantStandUp) 
       { 
           anim.SetFloat("Crouch", 1f, 0.25f, 
           Time.deltaTime); 
           if (capsule.height &gt; 1.5f) 
           { 
               capsule.height = 1f; 
               capsule.center = new Vector3(0f, 0.5f, 0f); 
           } 
        }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>Next we scale back the capsule and stop playing the crouch animations if the player doesn't hold the <span class="emphasis"><em>C</em></span> key and the <code class="literal">cantStandUp</code> variable is false. Again we check if the capsule was scaled down and only then do we scale it up again:</li></ol></div><pre class="programlisting">        else 
        { 
              anim.SetFloat("Crouch", 0f, 0.25f, 
              Time.deltaTime); 
              if (capsule.height &lt; 1.5f) 
              { 
                  capsule.height = 2f  
                  capsule.center = new Vector3(0f, 1f, 0f);          
              } 
        } 
                </pre><div class="orderedlist"><ol class="orderedlist arabic" start="16" type="1"><li>Assign the script to the character and play the game to see the effect. Make sure your scaled down <strong class="userinput"><code>Capsule Collider</code></strong> fits under the obstacle you have on your scene. You may need to adjust the <code class="literal">capsule.height</code> and <code class="literal">capsule.center</code> values in the preceding script accordingly.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec137"></a>How it works...</h3></div></div></div><p>This recipe uses a very simple concept: a character's collider scaling in runtime. Every collider other than a <strong class="userinput"><code>Mesh Collider</code></strong> has public variables describing its shape. You can <span>alter</span><a id="id325532038" class="indexterm"></a> them in runtime to achieve interesting results such as crouching. You shouldn't scale a static object's colliders and you should try to avoid scaling colliders of objects that have no <strong class="userinput"><code>Rigidbody</code></strong> component (as stated by Unity, this has a bigger impact on the physics engine).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec138"></a>There's more...</h3></div></div></div><p>You can also use Animation Curves to scale the collider. To do so, create the <strong class="userinput"><code>Animation Curve</code></strong> and an Animator Controller parameter with the same name as the curve has. Get the value of the parameter in scripts by calling the <code class="literal">animator.GetFloat("ParameterName")</code> function, where <code class="literal">animator</code> is the variable that holds reference to the Animator component and <code class="literal">ParameterName</code> is your parameter (and curve) name. Next, use the value to scale the collider. This way you can create single animations with changing collider size. A good example of such an animation would be a roll.</p></div></div>