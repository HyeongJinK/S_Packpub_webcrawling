<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec47"></a>Adding animation to off-mesh links</h2></div></div><hr /></div><p>In Unity characters with Nav Mesh Agent component can navigate in the scene using pre-baked <strong class="userinput"><code>NavMesh</code></strong>. There are cases when <strong class="userinput"><code>NavMesh</code></strong> can have some discontinuities, for instance when we have a chasm or a cliff in the scene. In such cases, we can define the so-called <span class="strong"><strong>Off Mesh Links</strong></span> to tell the character that he can jump over the chasm or drop from a cliff and continue navigation. In this recipe, we will use a <span>character</span><a id="id325289110" class="indexterm"></a> with a Nav Mesh Agent component and animate the <span>off-mesh</span><a id="id325289118" class="indexterm"></a> transitions using root motion.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec139"></a>Getting ready</h3></div></div></div><p>We are going to use the same character as in the <span class="emphasis"><em>Using root motion to drive NavMesh Agents' movement with animations</em></span> recipe with the <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, and <strong class="userinput"><code>WalkRight</code></strong> animations. Additionally, you should prepare a single <strong class="userinput"><code>JumpOffMesh</code></strong> animation with forward root motion transition (starting and ending with an <strong class="userinput"><code>Idle</code></strong> pose). We are going to use the <code class="literal">NavMeshAgentWithRigidBody.cs</code> and <code class="literal">ClickToMove.cs</code> scripts from the previously mentioned recipe to make the character move. You also need a chasm on your scene for the character to jump over. You can also go to the <code class="literal">Chapter 04 Character movement\Recipe 10 Adding animation to off-mesh links</code> directory. You will find an <code class="literal">Example.unity</code> scene there. Open it, play the game, and try to walk to the other floating island. The character will automatically play a jump animation to traverse to the other side.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec140"></a>How to do it...</h3></div></div></div><p>To use root motion for off-mesh links, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the character with <strong class="userinput"><code>Idle</code></strong>, <strong class="userinput"><code>WalkLeft</code></strong>, <strong class="userinput"><code>WalkForward</code></strong>, <strong class="userinput"><code>WalkRight</code></strong>, and <strong class="userinput"><code>JumpOffMesh</code></strong> animations.</li><li>Create a new Animator Controller.</li><li>Right-click on the empty space of the controller and choose <strong class="userinput"><code>Create State</code></strong> | <strong class="userinput"><code>New From Blend Tree</code></strong>. We need two such states. Name one of them <code class="literal">Idle</code> and the second one <code class="literal">Steering.</code></li><li>Create two <code class="literal">float</code> parameters in the controller, <strong class="userinput"><code>Speed</code></strong> and <strong class="userinput"><code>Direction</code></strong><span class="strong"><strong>,</strong></span> and one bool parameter, <strong class="userinput"><code>JumpOffMesh</code></strong>.</li><li>Create two transitions:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Idle</code></strong> | <strong class="userinput"><code>Steering</code></strong> with one condition: <strong class="userinput"><code>Speed</code></strong> parameter value greater than 0.5. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.2 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>Steering</code></strong> | <strong class="userinput"><code>Idle</code></strong> with one condition: <strong class="userinput"><code>Speed</code></strong> parameter value less than 0.5. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.2 seconds.</li></ul></div></li><li>Set the <strong class="userinput"><code>Idle</code></strong> animation in the <strong class="userinput"><code>Idle</code></strong> state.</li><li>Double-click on the <strong class="userinput"><code>Steering</code></strong> Blend Tree.</li><li>Set the <strong class="userinput"><code>Parameter</code></strong> of the <strong class="userinput"><code>Blend Tree</code></strong> to <strong class="userinput"><code>Direction</code></strong>: we will only use the <strong class="userinput"><code>Direction</code></strong> parameter for blending walk animations.</li><li>Drag and drop <strong class="userinput"><code>WalkLeft</code></strong> animation in the first (upper) field, <strong class="userinput"><code>WalkForward</code></strong> in the second (middle) field, and <strong class="userinput"><code>WalkRight</code></strong> in the third (lower) field.</li><li>Uncheck the <strong class="userinput"><code>Automate Thresholds</code></strong> option.</li><li>Set the <strong class="userinput"><code>WalkLeft</code></strong> animation threshold to -45, <strong class="userinput"><code>WalkForward</code></strong> animation <strong class="userinput"><code>Threshold</code></strong> to 0, and <strong class="userinput"><code>WalkRight</code></strong> animation <strong class="userinput"><code>Threshold</code></strong> to 45.</li><li>Double-click on the empty space in the Animator Controller to get out of the <strong class="userinput"><code>Blend Tree</code></strong> settings.</li><li>Drag and drop your <strong class="userinput"><code>JumpOffMesh</code></strong> animation into the controller.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Create two transitions:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Any State</code></strong> | <strong class="userinput"><code>JumpOffMesh</code></strong> with one condition: <strong class="userinput"><code>JumpOffMesh</code></strong> parameter set to true. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to false and <strong class="userinput"><code>Transition Duration</code></strong> set to around 0.2 seconds.</li><li style="list-style-type: disc"><strong class="userinput"><code>JumpOffMesh</code></strong> | <strong class="userinput"><code>Idle</code></strong> with no conditions. <strong class="userinput"><code>Has Exit Time</code></strong> should be set to true and <strong class="userinput"><code>Transition</code></strong><strong class="userinput"><code>Duration</code></strong> set to around 0.2 seconds.</li></ul></div></li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>Close the Animator Controller.</li><li>Put your character on the scene. Add a <strong class="userinput"><code>Rigidbody</code></strong> component to it and freeze its rotation. Add a Nav Mesh Agent component and a <strong class="userinput"><code>Capsule Collider</code></strong> component (make sure the <strong class="userinput"><code>Height</code></strong> and <strong class="userinput"><code>Center</code></strong> properties are set correctly for it). Attach the <code class="literal">NavMeshAgentWithRigidBody.cs</code> script to the character.</li><li>Add the <code class="literal">ClickToMove.cs</code> script to the character and assign its <strong class="userinput"><code>NavMesh</code></strong> Agent to the <strong class="userinput"><code>Agent</code></strong> field of the script.</li><li>Create a new off-mesh link. To do so, create three <strong class="userinput"><code>Empty</code></strong> game objects and name them <strong class="userinput"><code>Link</code></strong>, <strong class="userinput"><code>Start</code></strong>, and <strong class="userinput"><code>End</code></strong>. Add the <span>OffMeshLink</span><a id="id325531934" class="indexterm"></a> component to the <strong class="userinput"><code>Link</code></strong> object. Drag and drop the <strong class="userinput"><code>Start</code></strong> game object into the <strong class="userinput"><code>Start</code></strong> field of the <strong class="userinput"><code>OffMeshLink</code></strong><span>component</span><a id="id325532133" class="indexterm"></a> and the <strong class="userinput"><code>End</code></strong> game object to the <strong class="userinput"><code>End</code></strong> field of the component (see the following image). Bake the <strong class="userinput"><code>NavMesh</code></strong> (your ground game object has to have a collider and has to be set to <strong class="userinput"><code>NavMesh Static</code></strong> in the <strong class="userinput"><code>Navigation</code></strong> window, <strong class="userinput"><code>Object</code></strong> tab).</li></ol></div><div class="mediaobject"><img src="/graphics/9781785883910/graphics/870354b0-134e-4b0d-9656-6d8c6ddc5a48.png" /></div><p>Off Mesh Link placement and baked NavMesh</p><div class="orderedlist"><ol class="orderedlist arabic" start="19" type="1"><li>Uncheck the <strong class="userinput"><code>Auto Traverse Off Mesh Link</code></strong> option in the Nav Mesh Agent component of the character.</li><li>Create a new script and call it <code class="literal">MathOffmeshLink.cs</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="21" type="1"><li>In the <code class="literal">Update()</code> function of the script, we first save the current animator state info to a <code class="literal">currentAnimState</code> variable. Then we check if our agent is on an off mesh link. If so, we set the <strong class="userinput"><code>JumpOffMesh</code></strong><code class="literal">bool</code> parameter in the controller to play the <strong class="userinput"><code>JumpOffMesh</code></strong> animation. Then we calculate the <code class="literal">targetPosition</code> of our character by using the agent's off mesh link end position. Next we calculate the <code class="literal">targetRotation</code> of our character:</li></ol></div><pre class="programlisting">        currentAnimState = anim.GetCurrentAnimatorStateInfo(0); 
        if (agent.isOnOffMeshLink) 
        { 
             anim.SetBool("JumpOffMesh", true); 
             targetPos = agent.currentOffMeshLinkData.endPos; 
             targetDirection = targetPos - transform.position; 
             targetDirection.y = 0f; 
             targetRot = 
             Quaternion.LookRotation(targetDirection); 
        } 
                </pre><div class="orderedlist"><ol class="orderedlist arabic" start="22" type="1"><li>Next we check if our character is playing the <strong class="userinput"><code>JumpOffMesh</code></strong> animation. If so, we turn our <strong class="userinput"><code>Rigidbody</code></strong> component to kinematic (to disable collisions and gravity) and we use the <code class="literal">MatchTarget()</code> function on the Animator component. This function <span class="emphasis"><em>stretches</em></span> the animation to match the target position and rotation. We set our <code class="literal">targetBodyPart</code> to the character's root. We set the <code class="literal">startNormalizedTime</code> and <code class="literal">endNormalizedTime</code> parameters to 0.25 and 0.75, respectively, because we transition to and from the animation and it takes some time, so we shouldn't start the target matching from the very beginning and we should stop it a bit earlier. You may need to adjust those settings in your particular case.</li><li>Our script has also a <code class="literal">public void CompleteOffMeshLink()</code> function. It is called by an Animation Event from the <strong class="userinput"><code>JumpOffMesh</code></strong> animation. This function call the <code class="literal">CompleteOffMeshLink()</code> function on the Nav Mesh Agent component. That tells the component that we've finished handling the off mesh link traversing. Our event also sets the <strong class="userinput"><code>JumpOffMesh</code></strong><code class="literal">bool</code> parameter in the controller to <code class="literal">false</code> (that prevents our character from jumping again) and turns the rigid body physics back on:</li></ol></div><pre class="programlisting">         agent.CompleteOffMeshLink()
         anim.SetBool("JumpOffMesh", false); 
         rb.isKinematic = false;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="24" type="1"><li>Our <code class="literal">rb</code> variable is set in the <code class="literal">Start()</code> function and holds the reference to the <strong class="userinput"><code>Rigidbody</code></strong> component. The <code class="literal">agent</code> variable is also set when the game starts and holds the reference to our Nav Mesh Agent component.</li><li>Assign the script to the character.</li><li>Add an event few frames before the end of the <strong class="userinput"><code>JumpOffMesh</code></strong> animation and choose the <code class="literal">CompleteOffMeshLink()</code> function in it. Refer to the <span class="emphasis"><em>Using triggers to grab an edge while jumping</em></span> recipe, step 16, if needed.</li><li>Play the game and try to traverse the chasm to see the effect.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec141"></a>How it works...</h3></div></div></div><p>The key to this recipe is the <code class="literal">anim.MatchTarget()</code> function. It smoothly stretches the <span>animation's</span><a id="id325531779" class="indexterm"></a> root motion to match the given position and rotation. With the <code class="literal">agent.isOnOffMeshLink</code> flag, we check every frame if our character is trying to traverse an off mesh link. If so, we simply play our <strong class="userinput"><code>JumpOffMesh</code></strong> animation and use the <code class="literal">anim.MatchTarget()</code> function to match the end position of our off mesh link. This works only if the <strong class="userinput"><code>Auto Traverse <span>Off Mesh Links</span><a id="id325531799" class="indexterm"></a></code></strong> option is disabled in the Nav Mesh Agent Component. After we finish playing our animation, we call the <code class="literal">agent.CompleteOffMeshLink()</code> function to tell the Nav Mesh Agent component that it can continue path finding.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec142"></a>There's more...</h3></div></div></div><p>You don't have to use root motion and the <code class="literal">Animator.MatchTarget()</code> function for off mesh links. You can also write your own custom solution for moving the agent from the off mesh link's start to the off mesh link's end position. You could, for instance, teleport the character with a cool effect.</p></div></div>