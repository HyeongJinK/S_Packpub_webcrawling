<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec54"></a>Using Quaternion.LookRotation() and Animator.SetLookAtPosition() methods to make characters follow an object with their gaze</h2></div></div><hr /></div><p>Sometimes you need a <span>character</span><a id="id325241269" class="indexterm"></a> to look at an object in the game, for instance, at the camera. To do so, we can use two methods: <code class="literal"><span>Quaternion.LookRotation</span><a id="id325241348" class="indexterm"></a>()</code> and <code class="literal"><span>Animator.SetLookAtPosition</span><a id="id325241358" class="indexterm"></a>()</code>. We will cover both in this recipe (the second one is covered in the <span class="emphasis"><em>There's more...</em></span> section).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec163"></a>Getting ready</h3></div></div></div><p>To follow this recipe, you need a character with one <strong class="userinput"><code>Idle</code></strong> animation. You can also go to the <code class="literal">Chapter 05 Character actions and expressions\Recipe 04 Using LookRotation and SetLookAtPosition methods to make characters follow an object with their gaze</code> directory. Open the <code class="literal">Example.scene</code> scene there. You will find the <strong class="userinput"><code>HumanoidLookAt</code></strong> and <strong class="userinput"><code>HumanoidIKLookAt</code></strong> game objects there. The first one uses a generic <code class="literal">LookAt()</code> method and the second one uses the <code class="literal">Animator.SetLookAtPosition()</code> function. To see the effect, play the game, switch to the <strong class="userinput"><code>Scene</code></strong> View, and move the <strong class="userinput"><code>Target</code></strong> game object around (a red shiny sphere).</p><div class="mediaobject"><img src="/graphics/9781785883910/graphics/7596e2de-4852-457d-b28e-e469335aee06.png" /></div><p>Characters looking at the Target game object</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec164"></a>How to do it...</h3></div></div></div><p>To make <span>character</span><a id="id325241598" class="indexterm"></a>s follow an object with their gaze, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the character into Unity and place it in a scene.</li><li>Make sure to create an Animator Controller with at least one animation, or use an existing one.</li><li>To use the first<code class="literal"><span>Quaternion.LookRotation</span><a id="id325289094" class="indexterm"></a>()</code> method, create a new script and call it <code class="literal">CharacterLookAt.cs</code>.</li><li>In that script, we <span>use</span><a id="id325289109" class="indexterm"></a> the void <code class="literal">LateUpdate()</code> function to alter bone rotation after all animations are evaluated. In that function, we first check if a <code class="literal">public</code><code class="literal">float weight</code> variable is less than or equal to 0. If so, we don't do anything (we turn off the <strong class="userinput"><code>look at</code></strong> behavior):</li></ol></div><pre class="programlisting">        if (weight &lt;= 0f) 
        { 
            return; 
        } </pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>If that is not true, we calculate our desired <code class="literal">lookDirection</code>. This is a vector in which our character should look. We calculate it by subtracting our <code class="literal">public Transform bone</code> position from the <code class="literal">public Transform target</code> position. This vector is then damped in time using the <code class="literal">SmoothDamp()</code> function. This prevents it from sudden changes. We use a <code class="literal">public float</code><code class="literal">dampTime</code> variable to determine the time in which we smooth the vector out. The <code class="literal">dampVelocity</code> vector is class member variable required by the <code class="literal">SmoothDamp()</code> function to store the changes in the <code class="literal">lookDirection</code> vector between frames:</li></ol></div><pre class="programlisting">        lookDirection = Vector3.SmoothDamp(lookDirection, 
        target.position - bone.position, ref dampVelocity, 
        dampTime); </pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Next we check if the angle between our desired <code class="literal">lookDirection</code> vector and the character's <code class="literal">transform.forward</code> vector is greater than our <code class="literal">public float maxAngle</code> value. If so, we calculate the <code class="literal">finalLookVector</code>. This is our character's <code class="literal">transform.forward</code> vector, which is rotated toward the desired <code class="literal">lookDirection</code> vector by the <code class="literal">maxAngle</code> degrees. This way we create a <span class="emphasis"><em>cone of vision</em></span> for our character and prevent it from breaking the neck joint. We need to use the <code class="literal">MathfDeg2Rad</code> constant to change our <code class="literal">maxAngle</code> degrees to radians because the <code class="literal">Vector3.RotateTowards()</code> function uses radians instead of degrees. If the angle between <code class="literal">lookDirection</code> and <code class="literal">transform.forward</code> is less than or equal to <code class="literal">maxAngle</code>, we don't alter the <code class="literal">lookDirection:</code></li></ol></div><pre class="programlisting">        if (Vector3.Angle(lookDirection, transform.forward) &gt; 
        maxAngle) 
        { 
            finalLookVector = 
            Vector3.RotateTowards(transform.forward, 
            lookDirection, Mathf.Deg2Rad*maxAngle, 0.5f); 
        } 
        else 
        { 
            finalLookVector = lookDirection; 
        } </pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Finally, we calculate the <code class="literal">Quaternion rotation</code> value by using the <code class="literal">Quaternion.LookRotation()</code> method and multiplying its result by a <code class="literal">public Vector3 additinalRotation</code> value. First we need to turn this <code class="literal">Vector3</code> into a <code class="literal">Quaternion</code> by using the <code class="literal">Quaternion.Euler()</code> function. Multiplying two quaternions is simply adding an additional rotation. We need to use the <code class="literal">additionalRotation</code> vector because, in most cases, the head bone's forward axis doesn't match the face of our character. By applying an additional rotation of +90 or -90 degrees in one of the axes (<span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>, or <span class="emphasis"><em>Z</em></span>), we can make the script work for every rig. After calculating the rotation, we linearly interpolate the current <code class="literal">bone.rotation</code> value to our calculated <code class="literal">rotation</code> using the <code class="literal">weight</code> value. This way we can turn the <strong class="userinput"><code>look at</code></strong> on and off easily:</li></ol></div><pre class="programlisting">        rotation = Quaternion.LookRotation(finalLookVector) * 
        Quaternion.Euler(additionalRotation); 
        bone.rotation = Quaternion.Lerp(bone.rotation, rotation, 
        weight); </pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Save the script and add it to the character.</li><li>Drag and drop the head bone of the character to the <strong class="userinput"><code>Bone</code></strong> field in the script's <strong class="userinput"><code>Inspector</code></strong>.</li><li>Drag and drop the <strong class="userinput"><code>look at</code></strong> target transform to the <strong class="userinput"><code>Target</code></strong> field in the script's <strong class="userinput"><code>Inspector</code></strong>.</li><li>You may need to adjust the <strong class="userinput"><code>Additional Rotation</code></strong> field. Experiment in <strong class="userinput"><code>Play Mode</code></strong> with +90 or -90 values in different axes to find a matching value. Modifying one axis at a time should be enough.</li><li>Move the target transform in <strong class="userinput"><code>Play Mode</code></strong> to see the effect (you can do it in the <strong class="userinput"><code>Scene</code></strong> View).</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec165"></a>How it works...</h3></div></div></div><p>In this recipe, we are using a <code class="literal"><span>Quaternion.LookRotation</span><a id="id325241660" class="indexterm"></a>()</code> method that creates a rotation, which <span>works</span><a id="id325241670" class="indexterm"></a> the same way as we would use the <code class="literal">Transform.LookAt()</code> function. It is applied to the head bone's transform. Our <span>character</span><a id="id325241682" class="indexterm"></a>'s rig and all its bones are standard transforms in Unity. We can modify their rotation or position as we would with other game objects, but we need to do it in the <code class="literal">LateUpdate()</code> function because all the animations have to be evaluated first. We cannot modify any of the bones' transforms in the <code class="literal">Update()</code> function because all our modifications would be overwritten by the animations.</p><p>The <code class="literal">Quaternion.LookRotation()</code> function creates a rotation that makes a transform forward axis point to the desired direction. In most cases, the head bone's forward axis doesn't match the face of the character; thus, we need to apply an additional rotation. To do so, we use the <code class="literal">public Vector3 additionalRotation</code> variable.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec166"></a>There's more...</h3></div></div></div><p>For humanoid characters, we can use the IK approach. To do so, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Make sure to check the IK Pass option in the Animator Controller's layer properties.</li><li>Create a new script and call it <code class="literal">CharacterLookAtIK.cs</code>.</li><li>Create a void <code class="literal">OnAnimatorIK(int layerIndex)</code> function in that script. This function is called in the <strong class="userinput"><code>IK Pass</code></strong> after all animations are evaluated.</li><li>In that script, we use the <code class="literal">SetLookAtPosition()</code> and <code class="literal">SetLookAtWeight()</code> functions on the Animator component. We use a <code class="literal">public Transform target</code> variable to set the <strong class="userinput"><code>look at</code></strong> position and a <code class="literal">public float weight</code> variable to set the weight of the <strong class="userinput"><code>look at</code></strong>. We also use the <code class="literal">Vector3.SmoothDamp()</code> method to damp any sudden changes in the position of our target:</li></ol></div><pre class="programlisting">        targetPosition = Vector3.SmoothDamp(targetPosition, 
        target.position, ref dampVelocity, dampTime); 
        anim.SetLookAtPosition(targetPosition); 
        anim.SetLookAtWeight(weight); </pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Save the script and assign it to the character.</li><li>Assign the <strong class="userinput"><code>Target</code></strong> game object to the <strong class="userinput"><code>Target</code></strong> field in the script's <strong class="userinput"><code>Inspector</code></strong>. Make sure to set the <strong class="userinput"><code>Weight</code></strong> field to <code class="literal">1</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Play the <span>game</span><a id="id325241798" class="indexterm"></a> and <span>move</span><a id="id325241806" class="indexterm"></a> the <strong class="userinput"><code>Target</code></strong> game object to see the result (you can do it in the <strong class="userinput"><code>Scene</code></strong> View).</li><li>To <span>turn</span><a id="id325241825" class="indexterm"></a> the <strong class="userinput"><code>look at</code></strong> on and off smoothly, interpolate the <code class="literal">weight</code> value in time using the <code class="literal">Mathf.Lerp()</code> function.</li></ol></div></div></div>