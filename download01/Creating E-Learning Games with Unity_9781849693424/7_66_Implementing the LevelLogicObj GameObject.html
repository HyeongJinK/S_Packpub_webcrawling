<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec66"></a>Implementing the LevelLogicObj GameObject</h2></div></div><hr /></div><p>When<a id="id392" class="indexterm"></a> instantiated, the <code class="literal">LevelLogicObj</code> object will be detected as soon as the player and racers enter the LevellogicObj's trigger <a id="id393" class="indexterm"></a>volume. When three racers have crossed the finish line, it will determine if the player has met the objectives of the race or not, and it will enable either the pass or fail retry pop up. In order to implement the <code class="literal">LevelLogicObj</code> object, we need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a cube game object named <code class="literal">LevelLogicObj</code>. Scale, orient, and position it so that it surrounds the finish line in the level as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_07_09.png.jpg" /></div></li><li><p>Make sure it has a <span class="strong"><strong>Box Collider</strong></span> component and that the <span class="strong"><strong>Is Trigger</strong></span> checkbox is checked as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_07_10.png.jpg" /></div></li><li><p>We want to use the <code class="literal">DecisionMgr</code> class to track the progress of the racers, which means<a id="id394" class="indexterm"></a> we need to add an instance of <code class="literal">npcScript</code> to this object.</p></li><li><p>Don't worry<a id="id395" class="indexterm"></a> about the fact that the <code class="literal">LevelLogicObj</code> object is not specifically an NPC; if an existing tool is appropriate, don't reinvent the wheel!</p></li><li><p>Create a new script called <code class="literal">listData</code>. Modify it so that it inherits from <code class="literal">npcCondition</code> (just as the rest of the conditions we have developed so far). Add a public list of GameObjects called <code class="literal">_ListData</code> as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">public List&lt;GameObject&gt; _ListData;</pre></div></li><li><p>By inheriting from <code class="literal">npcCondition</code>, we now have a designer tweakable array that can be associated with <code class="literal">DecisionMgr</code> at runtime. Just don't forget to add the additional <code class="literal">using</code> directive for the list as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Generic;</pre></div></li><li><p>Add an instance of <code class="literal">listData</code> to the <code class="literal">LevelLogicObj</code> object, and then drag-and-drop the script component into the first interaction's condition reference field.</p></li><li><p>The first logical operation that <code class="literal">LevelLogicObj</code> needs to do is, when a character or the player enters the <code class="literal">triggerVolume</code>, a reference to that GameObject should be stored in the data container. In our example, that container is <code class="literal">listData</code>. We need to implement a way to detect and insert. So, create a new script named <code class="literal">condition_OnEnter</code>, and add an instance of it to the <code class="literal">LevelLogicObj</code> object.</p></li><li><p>Modify the <code class="literal">condition_OnEnter</code> condition script so that it inherits from <code class="literal">npcCondition</code> rather than <code class="literal">monobehavior</code> as with the rest of our condition classes as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">public class condition_onEnter : npcCondition;</pre></div></li><li><p>Give the <code class="literal">condition_OnEnter</code> class a public reference to a GameObject called <code class="literal">trackObj</code>. This will hold a reference to the most recent GameObject that enters the trigger volume. This can be done with the following line of code:</p><div class="informalexample"><pre class="programlisting">public GameObject trackObj;</pre></div></li><li><p>Add a private<a id="id396" class="indexterm"></a> Boolean variable named <code class="literal">hasEntered</code>, and initialize it to <code class="literal">false</code>. This will be used to track whether an object is actually inside the volume (rather than only having entered this frame):</p><div class="informalexample"><pre class="programlisting">private bool hasEntered = false;</pre></div></li><li><p>Now recall <a id="id397" class="indexterm"></a>that the <code class="literal">OnTriggerEnter</code>/<code class="literal">OnTriggerExit</code> callbacks are returned from the physics system rather than our DecisionMgr system. In order to interface the two, we will implement <code class="literal">OnTriggerEnter</code> and <code class="literal">OnTriggerExit</code> and then pass the relevant information outward.</p></li><li><p>The <code class="literal">OnTriggerEnter</code> method should simply set <code class="literal">hasEntered</code> to <code class="literal">true</code>, and it should set <code class="literal">trackObj</code> to <code class="literal">other.gameObject</code> as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void OnTriggerEnter(collider other)
{
  hasEntered = true;
  trackObj = other.gameObject;
}</pre></div></li><li><p>The <code class="literal">OnTriggerEnter</code> method should conversely set <code class="literal">hasEntered</code> to <code class="literal">false</code>, and it should nullify <code class="literal">trackObj</code> as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void OnTriggerExit(Collider other)
{
  hasEntered = false;
  trackObj = null;
}</pre></div></li><li><p>Lastly, the <code class="literal">eval()</code> method for this condition should be implemented to return the <code class="literal">hasEntered</code> variable. Recall from when we first developed the npcCondition system that the keyword override is used when declaring this <code class="literal">eval()</code> method to tell the Unity C# compiler that this implementation of the method corresponds to the interface declared in the <code class="literal">npcCondition</code> base class. In this way, we have now paired the PhysX trigger system with our DecisionMgr. When <a id="id398" class="indexterm"></a>the <span class="strong"><strong>Is Trigger</strong></span> checkbox fires the <code class="literal">OnTriggerEnter()</code> method even when the player or racer crosses the finish line, it will pass the reference from the GameObject that entered the trigger to this condition class. This can be accomplished with the following code snippet:</p><div class="informalexample"><pre class="programlisting">public override bool eval()
{
  return hasEntered;
}</pre></div></li><li><p>Setting our attention on the response we need to write, let's create a new script named <code class="literal">response_insert</code> and add an instance of it to <code class="literal">LeveLLogicObj</code>.</p></li><li><p>Modify the <a id="id399" class="indexterm"></a>script so that it inherits from <code class="literal">npcResponse</code> rather than <code class="literal">Monobehavior</code>. Don't forget to add the <code class="literal">[System.Serializable]</code> flag to the script.</p></li><li><p>Add a public <code class="literal">npcCondition</code> variable named data, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">public npcCondition data</pre></div></li><li><p>At this point, we recognize that in our base <code class="literal">npcReponse</code> and <code class="literal">npcCondition</code> classes, we need to track the paired response or condition from the interaction. As such, go into these classes now, and add a public <code class="literal">conditionAssociation</code> to <code class="literal">npcResponse</code> and add a public <code class="literal">responseAssociation</code> to <code class="literal">npcCondition</code>.</p></li><li><p>Switching back to <code class="literal">response_Insert</code>, we start to implement the <code class="literal">dispatch()</code> method. We first get <code class="literal">condition_OnEnter()</code> associated with this response's interaction and check if the GameObject that actually entered is an NPC racer or the player. We determine this by checking the tag on the object that entered as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">condition_onEnter cOE = (conditionAssciation as condition_onEnter);
  bool bIsPlayer = (cOE).trackObj.CompareTag("Player");
  bool bIsRacer = (cOE).trackObj.CompareTag("Character");</pre></div></li><li><p>If the object that entered is either a racer or player, insert the GameObject reference into the <code class="literal">listData</code> condition wrapper. For safety, we only insert a GameObject if it has not already been inserted into the list as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">listData rlist = (data as listData);
  if (!rlist._a.Contains(coe.trackObj))
    rlist._listData.Add(cOE.trackObj);</pre></div></li><li><p>If a racer (not the player) entered the finish line, we set the racer to paused so that it doesn't keep traversing its <code class="literal">SplinePath</code> as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">  (if bIsRacer)
  {
  (cOE).trackObj.GetComponent&lt;npcScript&gt;().SetState(npcScript.npcState.pause);</pre></div></li><li><p>Now <a id="id400" class="indexterm"></a>that <code class="literal">reponse_insert</code> has been implemented, drag-and-drop the <code class="literal">listData</code> script from the <code class="literal">LevelLogicObj</code> object to the data field on this script. Then, drag-and-drop the instance of this script from <code class="literal">LevelLogicObj</code> to the second response field of LevelLogicObj's DecisionMgr.</p></li><li><p>For the third <a id="id401" class="indexterm"></a>condition, we need to create a new condition script called <code class="literal">condition_listFull</code>. Go ahead and make a new script; change its base class to <code class="literal">npcCondition</code> and add an instance to <code class="literal">LevelLogicObj</code> as usual.</p></li><li><p>Add a public variable to this script to track the number of entries that will represent <code class="literal">full,</code> and a public <code class="literal">npcCondition</code> called <code class="literal">data</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">public int numEntries;
public npcCondition data;</pre></div></li><li><p>Drag-and-drop <code class="literal">listData</code> from the <code class="literal">LevelLogicObj</code> GameObject to the data field on <code class="literal">condition_listFull</code>.</p></li><li><p>Inside the implementation of <code class="literal">eval()</code>, <code class="literal">condition_isFull</code> does its work. If data is not null, it extracts the number of entries from the listData's list through its count member as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (data != null)
{
  int count = (data as listData)._listData.Count;</pre></div></li><li><p>If the count of the <code class="literal">listData</code> component's list array equals the <code class="literal">numEntries</code> value on this script, the return value is set to <code class="literal">true</code>. Otherwise, it remains <code class="literal">false</code> as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">if (count == numEntries)
  rval = true;</pre></div></li><li><p>Now that <code class="literal">condition_listFull</code> is complete, let's create the response that will occur when the list is found to be true—<code class="literal">response_ShowRaceResultsPopup</code>. This script will check the status of the mission, and enable the correct pop up on the main camera to achieve the desired gameflow.</p></li><li><p>Create a new<a id="id402" class="indexterm"></a> script named <code class="literal">response_ShowRaceResultsPopup</code>, change its base class to <code class="literal">npcResponse</code>, and add an instance of it to <code class="literal">LevelLogicObj</code>.</p></li><li><p>Add the following five public member variables to this script:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>An npcCondition named <code class="literal">data</code></p></li><li style="list-style-type: disc"><p>A GameObject named <code class="literal">player</code></p></li><li style="list-style-type: disc"><p>A gameMgr named <code class="literal">gm</code></p></li><li style="list-style-type: disc"><p>A GameObject named <code class="literal">passPopup</code></p></li><li style="list-style-type: disc"><p>A GameObject named <code class="literal">retryPopup</code></p></li></ul></div><p>The <code class="literal">response_ShowRaceResultsPopup</code> class will use the <code class="literal">GameManager</code> reference, and based on the data condition and result, it will enable either <code class="literal">passPopup</code> or <code class="literal">retryPopup</code>.</p></li><li><p>Edit <code class="literal">response_ShowRaceResultsPopup</code> so that its base is <code class="literal">npcResponse</code>.</p></li><li><p>Drag-and-drop<a id="id403" class="indexterm"></a> the <code class="literal">listData</code> component from <code class="literal">LevelLogicObj</code> to the data field of this script.</p></li><li><p>Drag-and-drop the <code class="literal">GameMgr</code> script from the GameObject to the <span class="strong"><strong>Gm</strong></span> field of this script. Recall that this GameObject lives as a child of the <span class="strong"><strong>_global</strong></span> GameObject.</p></li><li><p>Drag-and-drop the <code class="literal">player1</code> reference from beneath <span class="strong"><strong>_global</strong></span> to the player reference in this response script.</p></li><li><p>Drag-and-drop the <span class="strong"><strong>popup_Level2Finish</strong></span> pop up from beneath <span class="strong"><strong>MainCamera</strong></span> (which is beneath <span class="strong"><strong>_global</strong></span>) to the <span class="strong"><strong>pass</strong></span> reference field of this script.</p></li><li><p>Drag-and-drop the <span class="strong"><strong>popup_Level2Repeat</strong></span> pop up from beneath <span class="strong"><strong>MainCamera</strong></span> to the <span class="strong"><strong>fail</strong></span> reference field of this script. At this point your component should look somewhat like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_07_11.png.jpg" /></div></li><li><p>Inside this script, the <code class="literal">dispatch()</code> method does the brunt of the work. We compute if the player is first by checking if the <code class="literal">player</code> reference is equal to the first cell in the <code class="literal">listData</code> component's list array, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">  bool playerIsFirst = (data as listData)._listData[0] == player;</pre></div></li><li><p>If the player is <a id="id404" class="indexterm"></a>first, and we can locate the <code class="literal">missionMgr</code> script from the game, we point the camera looking up (to make sure the pop up is shown with a nice effect) as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">  if (mm)
    Camera.main.Getcomponent&lt;GameCam&gt;().LookUp();</pre></div></li><li><p>We then<a id="id405" class="indexterm"></a> check the <code class="literal">missionMgr</code> script for the status of the first mission. At this point, we know the game is done because the list is full, but the player may or may not have got 100 percent. If the player achieved 100 percent on the quiz, it means that the first mission is complete, and hence we should activate the pass pop up as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">  if (mm.isMissionComplete(0) == true)
  {
    passPopup.SetActive(true);
  }</pre></div></li><li><p>Otherwise, we activate the fail pop up as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">else
{
  fail.Popup.SetActive(true)
}</pre></div></li><li><p>Excellent! At this point, <code class="literal">DecisionMgr</code> is fully populated and should look somewhat like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_07_12.png.jpg" /></div></li><li><p>Congratulations! The <code class="literal">LevelLogicObj</code> evaluates the conditions of inserting a character during the <code class="literal">OnEnter()</code> method and<a id="id406" class="indexterm"></a> of displaying the correct pop up when the list is full. We use <code class="literal">DecisionMgr</code> rather<a id="id407" class="indexterm"></a> than the mission system to show how a pipeline can be built that allows complex game logic to be developed simply from parts that can be manipulated inside of Unity.</p></li></ol></div></div>