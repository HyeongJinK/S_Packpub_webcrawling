<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec50"></a>Implementing the SplineMgr class</h2></div></div><hr /></div><p>Recall from <a id="id286" class="indexterm"></a>our requirements that our NPC needs to be able to walk about the world along an arbitrary path. A convenient way to author the curve information would be by placing waypoints in the scene in the Unity3D Editor. Then, by interpolating between these points, we can apply smooth motion to the NPC object. It turns out that our <code class="literal">SplineMgr</code> is able to generate a curve that interpolates through all of the waypoints (or <code class="literal">ControlPoints</code>) in a set. Great news!</p><p>There are numerous types of splines in the mathematical world; each one has its own unique properties. Some of them don't interpolate any but get really close. Others will interpolate the first and the last, and approximate the middle two. By using a specific type of spline in our calculations (Catmull-Rom to be precise—named after the scientists who invented the formulation), we can guarantee that our curve will always interpolate all waypoints; the math<a id="id287" class="indexterm"></a> inside our <code class="literal">GetPointOnCurve()</code> function returns a point on the Catmull-Rom spline curve.</p><p>We can implement the <code class="literal">SplineMgr</code> class using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Our <code class="literal">SplineMgr</code> keeps a list of control points / waypoints for processing. These can be added to this list individually or in a batch via <code class="literal">splineNodeRoot</code> (this is simply an empty GameObject with a collection of control points in its hierarchy—a convenient way to encapsulate control point data).</p></li><li><p>The <code class="literal">SplineMgr</code> class has two types of playback. One of them evaluates the curve at a constant frame rate, and the other at a constant (more or less) arc length. The first way is good for curves that need to start and stop at a precise time. The tradeoff is that the curve may accelerate and decelerate as the control points move closer and farther away from one another.</p></li><li><p>The second playback mode is useful when the nature of the motion needs to be of constant velocity. However, the tradeoff with this playback type is that the total time to evaluate the curve is stretched:</p><div class="informalexample"><pre class="programlisting">public enum ePlaybackType
{
  invalid = -1,
  none = 0,
  const_dt = 1, //interpolate spline at constant speed
  const_dist = 2 //interpolate spline at constant distance steps
};</pre></div></li><li><p>A single variable of the type <code class="literal">ePlayback</code> encodes the type of interpolation that the spline will use to generate points on the curve:</p><div class="informalexample"><pre class="programlisting">public ePlaybackType type = ePlaybackType.const_dt;</pre></div></li><li><p>A second enumeration encodes the playback mode that the <code class="literal">SplineMgr</code> class will use to generate points on the curve. The loop will continue the playback in an infinite cycle. The <code class="literal">oneShot</code> mode will play the spline once and then finish. The <code class="literal">ComputingDebugPath</code> and <code class="literal">ComputingDebugPath_Finished</code> modes are used while evaluating the spline to generate points on the <code class="literal">lineRenderer</code> component:</p><div class="informalexample"><pre class="programlisting">public enum ePlaybackMode
{
  invalid = -1, //error spline interpolation
  none = 0, //not spline interpolation
  oneshot = 1, //play once and finish
  loop = 2, //loop continuously
  oneshot_finished = 4,//when  oneshot is done
  computingDebugPath = 5, //internal
  computingDebugPath_finished = 6 //internal
};</pre></div></li><li><p>The <code class="literal">start()</code> method in the <code class="literal">SplineMgr</code> class performs two primary tasks:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>It allocates a new GameObject to move along the curve in front of the <code class="literal">HeadObj</code> object. This is to facilitate looking ahead of the curve when the NPC is in the <code class="literal">patrol</code> mode and walking along the spline.</p></li><li style="list-style-type: disc"><p>It also checks if a <code class="literal">splineNodeRoot</code> has been assigned to the spline. If it has, this triggers an automatic waypoint / control point installation into the <code class="literal">SplineMgr</code> class:</p><div class="informalexample"><pre class="programlisting">TargetObj = new GameObject();
nHead = 0;
if (splineNodeRoot)
  InstallSplineNodes(); </pre></div></li></ul></div></li><li><p>The <code class="literal">InstallSplineNodes()</code> method is an internal private method that takes a <a id="id288" class="indexterm"></a>GameObject, extracts all child game objects, and then populates the <code class="literal">ControlPoints</code> list with these GameObjects as waypoints. The algorithm has three steps.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, the <code class="literal">ControlPoints</code> list is cleared:</p><div class="informalexample"><pre class="programlisting">ControlPoints.Clear ();</pre></div></li><li><p>Using an internal function in Unity, we return an array of all the child objects of the <code class="literal">splineRootNode</code>:</p><div class="informalexample"><pre class="programlisting">Transform[] allChildren = splineNodeRoot.GetComponentsInChildren&lt;Transform&gt;();</pre></div></li><li><p>We iterate over this list of child nodes (as they are the waypoints in our spline) and add them to the <code class="literal">ControlPoints</code> list. Note that this list will include the <code class="literal">splineNodeRoot</code>, so we need to check that we don't add this to the waypoints:</p><div class="informalexample"><pre class="programlisting">foreach (Transform child in allChildren)
{
  // do what you want with the transform
  if (child != splineNodeRoot.transform)
    ControlPoints.Add(child.gameObject);
}</pre></div></li></ol></div></li><li><p>The <code class="literal">ComputeDebugPath()</code> method iterates over the waypoints array before the game starts and fills in the <code class="literal">lineRenderer</code> component on the NPC. The <code class="literal">lineRenderer</code> component is then used to display the path if the <code class="literal">showPath</code> flag is set.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Before the method starts, it caches the playback mode and playback type that the user sets in the editor. We do this so that the system can set <code class="literal">playbackMode</code> to <code class="literal">ComputePath</code> while the <code class="literal">debugPath</code> is calculated:</p><div class="informalexample"><pre class="programlisting">// store settings
ePlaybackMode pbm = this.playbackMode;
ePlaybackType pbt = this.type;</pre></div></li><li><p>We then loop over a preset number of samples in the <code class="literal">lineRenderer</code> component, sampling the <code class="literal">splinePath</code> and storing these samples in the <code class="literal">debugPath</code>:</p><div class="informalexample"><pre class="programlisting">SetPlaybackMode(splineMgr.ePlaybackMode.computingDebugPath);
for (int i = 0 ; i &lt; 1024; i++)
{
  Vector3 p = getPointOnCurve();
  debugPath.SetPosition(i, p);
  if (IsFinished() == true)
  {
    debugPath.SetVertexCount(i-1);
    break;
  }
}</pre></div></li><li><p>Once the <a id="id289" class="indexterm"></a>path is calculated and the <code class="literal">lineRenderer</code> component is filled with values of line segments (from the <code class="literal">debugPath.SetPosition()</code> call earlier), we restore <code class="literal">playbackMode</code> and <code class="literal">playbacktype</code> from the user:</p><div class="informalexample"><pre class="programlisting">// restore values
playbackMode = pbm;
Playbacktype = pbt;
vOut = 0.5f * ((2.0f*p1) + (-p0+p2)*t + (2.0f*p0 - 5.0f*p1 + 4.0f*p2 - p3)*t2 + (-p0 + 3.0f*p1 - 3.0f*p2 + p3)*t3);</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip05"></a>Tip</h3><p>The <code class="literal">PointOnCurve()</code> method is the workhorse of the <code class="literal">SplineMgr</code> class. It takes four control points as input (<code class="literal">p0</code>, <code class="literal">p1</code>, <code class="literal">p2</code>, <code class="literal">p3</code>), and given a value of <code class="literal">t</code> from (0, 1), it returns a point on the curve. The polynomial equation in this function is derived from the Catmull-Rom spline basis matrix (other splines would have a different formula for computing a point on the curve; the important point is that our formula derived from that matrix).</p></div></li></ol></div></li><li><p>In the <code class="literal">FixedUpdate()</code> method, we call a custom <code class="literal">eval()</code> method, which evaluates the spline. We call this during <code class="literal">FixedUpdate()</code> to simplify the <code class="literal">t</code> calculations in <code class="literal">PointOnCurve()</code>, eliminating the need to multiply by elapsed time. Had we decided to evaluate the spline during <code class="literal">Update()</code>, we would need to evaluate the curve on a point that was also a factor of the elapsed time:</p><div class="informalexample"><pre class="programlisting">// Update is called once per frame
void FixedUpdate ()
{
  if ((playbackMode != ePlaybackMode.computingDebugPath) &amp;&amp; (playbackMode != ePlaybackMode.none))
    eval ();
}</pre></div></li><li><p>The <code class="literal">eval()</code> method is <a id="id290" class="indexterm"></a>where the <code class="literal">SplineMgr</code> system evaluates the curve from being called every <code class="literal">FixedUpdate()</code>. Depending on the playback mode, it will either evaluate every frame or pause.</p></li><li><p>Recall that <code class="literal">SplineMgr</code> supports two playback types, <code class="literal">const_dt</code> and <code class="literal">const_distance</code>. In the <code class="literal">const_dt</code> mode, the spline is evaluated at <code class="literal">t+dt</code> every time <code class="literal">FixedUpdate()</code> is called:</p><div class="informalexample"><pre class="programlisting">if (type == ePlaybackType.const_dt) 
  t += dt;</pre></div></li><li><p>If the playback type is <code class="literal">const_dist</code>, the <code class="literal">SplineMgr</code> class will dynamically adjust the <code class="literal">dt</code> value for each frame so that the distance from the previous point on the curve to the next point on the curve is approximately equal to <code class="literal">target_arclength</code>. We use sequential search instead of binary search because it is less prone to getting stuck in high curvature segments.</p></li><li><p>Recall that a spline curve is defined over four control points. To build a longer curve composed of more points, we use a sliding window technique and construct tangent curves.</p><p>Every frame, we update <code class="literal">t</code> by <code class="literal">dt</code> (or dynamic <code class="literal">dt</code>) and find a point on the curve for the relevant four control points. The four points that we pass into the spline evaluation method are the four points around the current moving windows view of the <code class="literal">ControlPoints</code> list:</p><div class="informalexample"><pre class="programlisting">// extract interpolated point from spline
//Vector3 vOut = new Vector3(0.0f, 0.0f, 0.0f);
vOut = Vector3.zero;
Vector3 p0 = ControlPoints[nHead].transform.position;
Vector3 p1 = ControlPoints[nHead+1].transform.position;
Vector3 p2 = ControlPoints[nHead+2].transform.position;
Vector3 p3 = ControlPoints[nHead+3].transform.position;</pre></div></li><li><p>Once <code class="literal">t</code> exceeds <code class="literal">1.0</code>, this signals to slide <code class="literal">nHead</code> (the start of the window) up by <code class="literal">1</code>. Then, based on the playback mode, we either loop, stop, or handle the end of curve scenario<a id="id291" class="indexterm"></a> in another appropriate way. Rather than setting <code class="literal">t</code> back to zero on a rollover, we subtract <code class="literal">1.0</code> instead. This way, we can capture the difference if <code class="literal">t</code> ever ends up slightly greater than <code class="literal">1.0</code> but less than <code class="literal">dt</code>; it happens more than you'd think, and doing this results in a smoother and more accurate curve:</p><div class="informalexample"><pre class="programlisting">if (t &gt; 1.0f)
{
  t -= 1.0f;
  nHead++;
}</pre></div></li><li><p>The <code class="literal">SplineMgr</code> class then translates the GameObject reference in <code class="literal">headObj</code> to the new position on the curve:</p><div class="informalexample"><pre class="programlisting">// update headObj
vOut = PointOnCurve(t, p0, p1, p2, p3);
if (HeadObj)
  HeadObj.transform.position = vOut;</pre></div></li><li><p>The <code class="literal">SplineMgr</code> class also translates a second GameObject along the curve. The <code class="literal">TargetObj</code> object gets updated slightly in front of <code class="literal">headObj</code> and is used by the NPC to face forward when walking along the curve:</p><div class="informalexample"><pre class="programlisting">// update lookObj
if (TargetObj)
{
  Vector3 tgtPos = Vector3.zero;
  tgtPos = PointOnCurve (t+dt, p0, p1, p2, p3);
  TargetObj.transform.position = tgtPos;
}</pre></div></li></ol></div><p>Congratulations, we have now written a robust spline system for our NPCs and other moving objects! But how do we use it?</p></div>