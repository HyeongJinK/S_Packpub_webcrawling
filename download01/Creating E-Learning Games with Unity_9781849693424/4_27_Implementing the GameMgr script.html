<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec30"></a>Implementing the GameMgr script</h2></div></div><hr /></div><p>Let's implement<a id="id230" class="indexterm"></a> the <code class="literal">GameMgr</code> script so that it can manage the loading (and future unloading) of scene files and assets. Implementing this in a flexible way now will make our game more extensible when we have future levels to add. It can be implemented by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Recall that we have already created an empty script named <code class="literal">GameMgr</code> and attached it to the <code class="literal">Game</code> GameObject. If you have not already done this, no worries; just create a new script now, and attach it.</p></li><li><p>In order <a id="id231" class="indexterm"></a>for <code class="literal">GameMgr</code> to do its job, it will act as a mediator between <code class="literal">popupMenu</code> and the scene files of the game. When <code class="literal">GameMgr</code> receives a message to change its state, it will load and unload the appropriate scene files.</p></li><li><p>It is important that at this point we have added the <code class="literal">LEVEL1</code> scene file to the build settings; if you have not yet done this, make sure it has been added now.</p></li><li><p>We will use a custom enumeration in this class to build a state machine. This is a data structure that will let us build a model of how all scene files in the game interact with one another (which loads first, which stays persistent, which loads next, and so on). For complex systems later in the game, we will use this concept repeatedly.</p></li><li><p>We add an entry for both scene files we have created as well as a special error value that we can use to trap potential data problems. Extending this enumeration is as simple as adding more entries to this structure and assigning new entries a new unique integer as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public enum eGameState
{
  eGS_Invalid = -1, //used to encode error condition when 
    setting gamestate
  eGS_MainMenu = 0,//a state to encode being in the mainmenu
  eGS_Level1 = 1//a state to encode being in level1
}</pre></div></li><li><p>For <code class="literal">GameMgr</code> to be able to detect when a state change occurs, we will require two variables: one for the GameState and one for the <code class="literal">GameState</code> on the previous time the <code class="literal">Update()</code> loop ran. By checking each frame if the <code class="literal">GameState</code> has changed, we can detect when to load a new level as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public eGameState gameState;
private eGameState _prevGameState;</pre></div><p>While we don't want the user to be able to set <code class="literal">prevGameState</code> ever from the inspector, we allow the GameState to be adjusted by the user for debugging purposes.</p></li><li><p>In the <code class="literal">Start()</code> method of this class, we initialize <code class="literal">GameState</code> and <code class="literal">prevGameState</code> to the same value as shown in the following code. With an initial value of <code class="literal">eGS_MainMenu</code>, this corresponds to the main menu scene (which is the one we will default to when we load the <code class="literal">MAIN</code> scene). How convenient! Note that since both the previous and current GameStates are the same, <code class="literal">GameMgr</code> will not try and load a new scene file right away:</p><div class="informalexample"><pre class="programlisting">GameState = eGameState.eGS_MainMenu
prevGameState = eGameState.eGS_MainMenu;</pre></div></li><li><p>We create a <a id="id232" class="indexterm"></a>public method to allow other systems to set the state as shown in the following code. By ensuring that we always use this function rather than assigning to state directly, it will allow us to change state to private later on (once the game is done) without having to change the code elsewhere:</p><div class="informalexample"><pre class="programlisting">public void SetState(eGameState gs)
{
  GameState = gs;
} </pre></div></li><li><p>In the <code class="literal">Update()</code> loop<a id="id233" class="indexterm"></a>, the code will check if <code class="literal">GameState</code> is not equal to <code class="literal">prevGameState</code>. When this happens, it means that in this frame, the <code class="literal">GameState</code> was changed by another system and that <code class="literal">GameMgr</code> should change levels. To perform the state change, the code will invoke a custom private method <code class="literal">ChangeState()</code><a id="id234" class="indexterm"></a> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">void Update() {
   if (GameState != prevGameState)
   {
      ChangeState(gameState);
   }
   prevGameState = GameState;
}</pre></div></li><li><p>The <code class="literal">ChangeState()</code> method checks the current game state (guaranteed to have just changed this frame) as shown in the following code. We use a switch statement to handle selection of conditional logic based on the value of the new, current game state. Switch is a variation on the compound if/else structure you may have seen before; when there are multiple options to select from, switch is regarded by many as being easier to read and maintain:</p><div class="informalexample"><pre class="programlisting">GameState = gs;
switch(gameState)</pre></div></li><li><p>We don't need to do anything at this point for the case where we switch states to <code class="literal">MainMenu</code> (since we only allow this state on start by default). Recall that <code class="literal">PopupMainMenu</code> switches to <code class="literal">LEVEL1</code> GameState on click. We handle this by calling <code class="literal">Application.LoadLevelAdditive("LEVEL1")</code>. This line of code loads the scene file by name (so long as it has been added to the build) and adds all of the game objects from that scene to the current scene. The net result of this will be a scene file with two game objects at the top level; <code class="literal">_global</code> (and all of its children) and <code class="literal">_level1</code> (and all of its children). Since we never<a id="id235" class="indexterm"></a> duplicate objects between scene files, we now have a complete playable scene as shown in the following code:</p><div class="informalexample"><pre class="programlisting">   case(eGameState.eGS_Level1):
   {
      Application.LoadLevelAdditive("LEVEL1");
      break;
   };</pre></div></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note03"></a>Note</h3><p>If you have Unity3D Pro, you can replace <code class="literal">Application.LoadLevelAdditive()</code> with <code class="literal">Application.LoadLevelAdditiveAsync()</code>, which will make the level transition appear smoother for large levels (since it doesn't block the renderer). If you accidentally use <code class="literal">LoadLevelAsync()</code> or <code class="literal">LoadLevel()</code>, you will find that the objects that were previously loaded will be deleted when the new level loads up (possibly <code class="literal">_global</code> and its children in our case).</p></div><p>Congratulations! We now have written a game state manager class <code class="literal">GameMgr</code>, which uses the mediator pattern to selective load scene files that correspond to different levels in our game.</p></div>