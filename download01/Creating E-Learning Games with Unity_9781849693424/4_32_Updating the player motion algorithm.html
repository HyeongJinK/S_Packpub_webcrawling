<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec35"></a>Updating the player motion algorithm</h2></div></div><hr /></div><p>To make our game<a id="id243" class="indexterm"></a> character move through the level more smoothly, we will modify the motion algorithm. Instead of relying on gravity on the rigid body to keep the player anchored to the ground, we will cast a ray downward and glue the player to the polygon directly below. In this way, the curvature of the terrain will play less of a role in restricting the player. This can be achieved by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Switch to the <code class="literal">MAIN</code> scene, and double click on the <code class="literal">PlayerControls</code> script on the player. In the <code class="literal">UpdateMovement()</code> method, directly after the <code class="literal">CharacterController.Move()</code> method is called, declare a <code class="literal">RayCastHit</code> class named <code class="literal">hitInfo</code> as shown in the following code. This class will be used to return the position of the polygon from a raycast that is directly below the player. By invoking a raycast downward, we can check what other GameObject is intersected and use this information to glue the player to the ground directly at the point of contact:</p><div class="informalexample"><pre class="programlisting">RayCastHit hitInfo;</pre></div></li><li><p>We<a id="id244" class="indexterm"></a> create a new ray that points straight down from the player. We use the player's transform to determine the downward direction rather than the world transform so that even if the player is rotated, the raycast will always look down relative to the character as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Ray r = new Ray(this.transform.position, -Vector3.up);</pre></div></li><li><p>We query the physics system by casting the previous ray and allowing the PhysX integration to return the polygon that this raycast has hit, through the <code class="literal">hitinfo</code> variable, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Physics.Raycast( r, out hitinfo);</pre></div></li><li><p>Finally, we set the <span class="strong"><strong>y</strong></span> position of the character to the <span class="strong"><strong>y</strong></span> position of the poly that was hit in the raycast, plus an offset. We do this by creating a <code class="literal">new Vector3</code> variable to assign to the <code class="literal">transform.position</code> variable as we cannot assign to just a single component of this value type. The offset that we use to raise the character in the <span class="strong"><strong>y</strong></span> direction is the height of the player's collision capsule as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.transform.position = new 
  Vector3(this.transform.position.x, hitinfo.point.y + 
  (this.collider as CapsuleCollider).height, 
  this.transform.position.z);</pre></div></li></ol></div></div>