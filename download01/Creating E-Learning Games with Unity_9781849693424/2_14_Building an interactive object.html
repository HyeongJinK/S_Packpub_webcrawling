<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>Building an interactive object</h2></div></div><hr /></div><p>With these <a id="id66" class="indexterm"></a>requirements in mind, let's build the framework for an interactive object that can be collected by the player.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec10"></a>Implementing the CustomGameObj script</h3></div></div></div><p>We will begin <a id="id67" class="indexterm"></a>with the <code class="literal">CustomGameObj</code> class. This<a id="id68" class="indexterm"></a> class allows us to specify how an interactive object will behave when placed in the inventory, by giving it a unique type that is relevant for our game. Create the script by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start from the codebase built in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introduction to E-Learning and the Three Cs of 3D Games</em></span>, to create a new subfolder in the <code class="literal">assets</code> folder named <code class="literal">Chapter 2</code>.</p></li><li><p>Using the new script wizard, right-click on it and create a new C# script named <code class="literal">CustomGameObject</code>.</p></li><li><p>We will also add a public enumerated type to this class called <code class="literal">CustomObjectType</code>. If you recall, an enumeration is just a list of identifiers of the integer type that share a common logical relationship with one another, such as the types of an object! Not only will this make discerning the type of this object easy to read in the code, but it also serves as an interface to describe the classification of this object. We will use this information to determine some custom rules while adding GameObjects to the inventory. To begin, we will start with a few different types of objects, where an object of the <code class="literal">Coin</code> type will accumulate in the same slot in the inventory. This holds true for objects of the type <code class="literal">Ruby</code>, <code class="literal">Diamond</code>, and so on as well. Unique objects will be added in their own slot in <code class="literal">InventoryMgr</code> as follows:</p><div class="informalexample"><pre class="programlisting">Public enum CustomObjectType
{
  Invalid = -1,
  Unique = 0,
  Coin = 1,
  Ruby = 2,
  Emerald = 3,
  Diamond = 4

}</pre></div></li><li><p>A variable of the <code class="literal">CustomObject</code> type is added to this class to store the current type from the set discussed in the previous step. We use the <code class="literal">public</code> keyword so that a user can directly set the value of this variable inside the Unity Editor on an instance of the object:</p><div class="informalexample"><pre class="programlisting">public CustomObjectTypeobjectType CustomObjectType objectType;</pre></div></li><li><p>A public variable of the <code class="literal">string</code> type is added so that Unity users can add some descriptive text to the object while designing them, as shown in the following code; this can be very helpful while debugging or trying to identify the objects inside the editor:</p><div class="informalexample"><pre class="programlisting">public string displayName;</pre></div></li><li><p>Declare a method <a id="id69" class="indexterm"></a>named <code class="literal">validate()</code>, which will be used to assign the <code class="literal">unnamed_object</code> string to the <code class="literal">displayName</code> field if one has not been assigned in the editor, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void validate()
{
  if (displayName == "")
    displayName = "unnamed_object";
}</pre></div></li></ol></div><p>Congratulations! <a id="id70" class="indexterm"></a>We now have a container for the <code class="literal">CustomGameObject</code> information that our inventory system will use. To continue, let's create the <code class="literal">InteractiveObj</code> script.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec11"></a>Implementing the InteractiveObj script</h3></div></div></div><p>The <code class="literal">InteractiveObj</code> script<a id="id71" class="indexterm"></a> declares<a id="id72" class="indexterm"></a> a class that enables simple animation and permits <a id="id73" class="indexterm"></a>player interactions. Perform the following steps to create the script:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To use the new script wizard, right-click inside the <code class="literal">Chapter2</code> folder of the <span class="strong"><strong>Project</strong></span> tab and add a C# script named <code class="literal">InteractiveObj</code>.</p></li><li><p>To enable our interactive object to rotate about its own axis at a user specified rate, we need to add two parameters: a rotation axis and a rotation speed, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public Vector3 rotAxis;
public float rotSpeed;</pre></div></li><li><p>We will add a private reference to the <code class="literal">customGameObject</code> component for this <code class="literal">GameObject</code> so that we don't have to look it up at runtime. This can be done with the following line of code:</p><div class="informalexample"><pre class="programlisting">private customGameObject gameObjectInfo;</pre></div></li><li><p>We will also add an <code class="literal">ObjectInteraction</code> member variable. This will be the code that specifies what will happen to our <code class="literal">gameObject</code> when the player interacts with it. There may be many interactions that an interactive object can implement; we will start our example with <code class="literal">OnCloseEnough</code> and will complete this in the <code class="literal">OnTriggerEnter</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public objectInteraction OnCloseEnough;</pre></div></li><li><p>In the<a id="id74" class="indexterm"></a> <code class="literal">Start()</code> method,<a id="id75" class="indexterm"></a> we will search for the <code class="literal">CustomGameObject</code> component attached to <code class="literal">gameObject</code>. If it is found, we will store the reference in the <code class="literal">gameObjectInfo</code> private variable. Remember to always check that <code class="literal">gameObjectInfo</code> is not null so that debugging the code is a straightforward process, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">gameObjectInfo = this.gameObject.GetComponent&lt;customGameObject&gt;();
  if (gameObjectInfo) 
    gameObjectInfo.validate();</pre></div></li><li><p>In the<a id="id76" class="indexterm"></a> <code class="literal">Update()</code> method, we will apply a simple rotation to the object around the specified <code class="literal">rotAxis</code> parameter. We will rotate the object with the speed <a id="id77" class="indexterm"></a>given in <code class="literal">rotSpeed</code> multiplied by <code class="literal">Time.deltaTime</code> so that the number of rotations is a function of the elapsed time rather than the frame time, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">transform.Rotate(rotAxis, rotSpeed * Time.deltaTime);</pre></div></li><li><p>The <code class="literal">OnTriggerEnter()</code> method<a id="id78" class="indexterm"></a> will be invoked whenever the collider of this object collides with another collider in the world; incidentally, if we set <code class="literal">IsTrigger=false</code> on our <code class="literal">gameObject</code>, the <code class="literal">OnCollisionEnter()</code> method<a id="id79" class="indexterm"></a> will be dispatched instead of <code class="literal">OnTriggerEnter()</code>. Note, for Unity to dispatch either of these callbacks, we must remember to add a <span class="strong"><strong>Rigidbody</strong></span> component to the GameObject of <code class="literal">InteractiveObj</code> at the design time in the editor.</p></li><li><p>Note, when Unity dispatches this callback, it passes in another parameter of the <code class="literal">collider</code> type. This collider is the collider of the object that entered the trigger volume. Convenient! The signature looks as follows:</p><div class="informalexample"><pre class="programlisting">OnTriggerEnter(other collider)
{
}</pre></div></li><li><p>In this method, we check that the other object (the <code class="literal">gameObject</code> that has just entered this collider) has a tag equal to <code class="literal">Player</code>, as shown in the next line of code. This is how we ensure that our trigger only responds to entities that we specify (we must remember to set the tag on the player <code class="literal">gameObject</code> to <code class="literal">Player</code>):</p><div class="informalexample"><pre class="programlisting">if (other.gameObject.tag == "Player")</pre></div></li><li><p>If the <code class="literal">OnCloseEnough</code> object interaction is not null, we dereference it and invoke the <code class="literal">handleInteraction()</code> method. In our example, this method does the work of inserting objects into the inventory as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (OnCloseEnough != null)
{
    OnCloseEnough.handleInteraction();
}</pre></div></li></ol></div><p>Congratulations! <a id="id80" class="indexterm"></a>We now have a class that implements an interactive object. Let's continue further with an <code class="literal">ObjectInteraction</code> script that this class can utilize.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec12"></a>Implementing the ObjectInteraction script</h3></div></div></div><p>The <code class="literal">ObjectInteraction</code> class<a id="id81" class="indexterm"></a> defines <a id="id82" class="indexterm"></a>how the interactive object will be manipulated when an interaction occurs between the object and the player. Perform the following steps to implement this:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Two enumerations are required to specify the action and the type of action. The action will be what we do with the item (put in inventory and use) initially, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public enum InteractionAction
{
  Invalid = -1, 
  PutInInventory = 0, 
  Use = 1, 
}</pre></div></li><li><p>The corresponding type specializes this behavior by determining if the object is unique or can be accumulated with other interactive objects of the similar type. A unique interaction specifies that <code class="literal">ObjectIneraction</code> will insert this interactive object in a unique slot in <code class="literal">InventoryMgr</code>, while an accumulate interaction specifies that <code class="literal">ObjectInteraction</code> will insert this item (and increase the quantity) in the first available slot that matches the type set in <code class="literal">CustomGameObj</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public enum InteractionType
{ 
  Invalid = -1, 
  Unique = 0, 
  Accumulate = 1, 
}</pre></div></li><li><p>We keep the following two public variables to store the two enumerations discussed in the previous step:</p><div class="informalexample"><pre class="programlisting">public InteractionAction interaction;
public InteractionType interactionType;</pre></div></li><li><p>We also<a id="id83" class="indexterm"></a> keep a <code class="literal">Texture</code> variable to store the icon that will be displayed in the inventory for this GameObject as follows:</p><div class="informalexample"><pre class="programlisting">public Texture tex; </pre></div></li><li><p>The <code class="literal">HandleInteraction()</code> method<a id="id84" class="indexterm"></a> of this class works on the interactive object that<a id="id85" class="indexterm"></a> this script is attached to. To begin, we get the <code class="literal">InventoryMgr</code> component off the player if it can be found. Don't worry that we haven't created the <code class="literal">InventoryMgr</code> yet; we will!</p><div class="informalexample"><pre class="programlisting">if (player)
  iMgr = player.GetComponent&lt;InventoryMgr&gt;();</pre></div></li><li><p>As we extend the number of interaction types that our game supports, this method will grow. For now, if <code class="literal">PutIninventory</code> is the type, we will delegate <code class="literal">i=InventoryMgr</code> to add this <code class="literal">InteractiveObj</code> to its collection as follows:</p><div class="informalexample"><pre class="programlisting">if (interaction == InteractionAction.PutInInventory)    
{ 
  if (iMgr) 
    iMgr.Add(this.gameObject.GetComponent&lt;interactiveObj ();
}</pre></div></li></ol></div><p>Congratulations! You have implemented an <code class="literal">ObjectInteraction</code> class that operates on the <code class="literal">InteractiveObj</code> class. Let's continue by implementing the <code class="literal">InventoryItem</code> class.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec13"></a>Implementing the InventoryItem script</h3></div></div></div><p>The<a id="id86" class="indexterm"></a> <code class="literal">InventoryItem</code> class is<a id="id87" class="indexterm"></a> the base item <a id="id88" class="indexterm"></a>container that the <code class="literal">InventoryMgr</code> collection is built from. It contains a reference to <code class="literal">GameObject</code> that has been inserted in the inventory (via the <code class="literal">ObjectInteraction</code> class). It also has a copy of the texture to display in the inventory as well as the number of objects that a particular <code class="literal">InventoryItem</code> represents, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public Texture displayTexture;
public GameObject item;
public int quantity;</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>Scripts that inherit from <code class="literal">monobehavior</code> can be fully manipulated by the Unity3D Editor; they can be attached to GameObjects, have the property values saved, among other things. This class does not inherit from <code class="literal">monobehavior</code>; as it is an internal helper class for <code class="literal">InventoryMgr</code>. It never has to be attached to GameObject (a programmer or designer would not normally want to attach one of these to a 3D object because it doesn't need a <code class="literal">Transform</code> component to do its work). This class only acts as the glue between the interactive objects that have been collected and the UI button that <code class="literal">InventoryMgr</code> displays for these objects' custom type. Hence, this class does not derive from any base class. This allows us to declare a list of these objects directly inside <code class="literal">InventoryMgr</code>.</p></div><p>To make the<a id="id89" class="indexterm"></a> class show up in the inspector (in <code class="literal">InventoryMgr</code>), we need to add back some of the functionality that would have been<a id="id90" class="indexterm"></a> included, had we inherited from <code class="literal">monobehavior</code>; namely, the serialization of its properties. Hence, we add the following code decoration before the class declaration:</p><div class="informalexample"><pre class="programlisting">[System.Serializable]</pre></div><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_02_04.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec14"></a>Implementing the InventoryMgr script</h3></div></div></div><p>The<a id="id91" class="indexterm"></a> <code class="literal">InventoryMgr</code> class <a id="id92" class="indexterm"></a>contains <a id="id93" class="indexterm"></a>the system that manages the <code class="literal">InteractiveObj</code> classes that the player collects. It displays inventory items in an inventory panel at the bottom of the screen. It has a method for adding inventory items and displaying inventory at the bottom of the screen. Perform the following steps to implement the <code class="literal">InventoryMgr</code> script:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To begin, <a id="id94" class="indexterm"></a>recall that the class declaration for this system follows the same pattern as the others that were created with the new script wizard. Until this point, however, we haven't included any other namespaces than the default two: <code class="literal">UnityEngine</code> and <code class="literal">System.Collections</code>. For this class, note that we add <code class="literal">using System.Collections.Generic</code> in the code. Doing this gives us access to the <code class="literal">List&lt;&gt;</code> datatype in our scripts, which we will need to store the collection of inventory objects, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class InventoryMgr : MonoBehaviour {

public List&lt;InventoryItem&gt; inventoryObjects = new List&lt;InventoryItem&gt;();</pre></div></li><li><p>The <code class="literal">InventoryMgr</code> class<a id="id95" class="indexterm"></a> also has parameters that describe the way in which the constraints on the UI will be displayed, along with a reference to the <code class="literal">MissionMgr</code> script, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public int numCells;
public float height;
public float width;
public float yPosition;
private MissionMgr missionMgr;</pre></div></li><li><p>In the <code class="literal">Start()</code> method<a id="id96" class="indexterm"></a>, when this class is first created, we will find the object in the scene named <span class="strong"><strong>Game</strong></span>, and store a reference to the <code class="literal">MissionMgr</code> script that is attached to it, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">void Start () {
  GameObject go = GameObject.Find ("Game");
  if (go)
    missionMgr = go.GetComponent&lt;MissionMgr&gt;();
}</pre></div></li><li><p>The <code class="literal">Add()</code> method<a id="id97" class="indexterm"></a> is used by <code class="literal">ObjectInteraction.handleInteraction()</code> to insert an <code class="literal">InteractiveObj</code> in the inventory (when it is picked up). Recall that the signature looks as follows:</p><div class="informalexample"><pre class="programlisting">public void Add(InteractiveObj iObj)
{
  ObjectInteraction oi = iObj.OnCloseEnough;</pre></div></li><li><p>Based on the <code class="literal">ObjectInteraction</code> type specified in the interaction, the <code class="literal">Add()</code> method will behave in specialized ways, and a <code class="literal">switch</code> statement is used to select <a id="id98" class="indexterm"></a>which specific behavior to use. If the <code class="literal">ObjectInteraction</code> type is <code class="literal">Unique</code>, then <code class="literal">InventoryMgr</code> inserts this <code class="literal">InteractiveObj</code> in the first available slot, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">switch(oi.interactionType)
{
   case(ObjectInteraction.interactionType.Unique):
   {
      // slot into first available spot
      Insert(iObj);
   }
   break;</pre></div></li><li><p>If the <code class="literal">ObjectInteraction</code> type is <code class="literal">Accumulate</code>, then <code class="literal">InventoryMgr</code> will insert this in the<a id="id99" class="indexterm"></a> first slot that matches the <code class="literal">CustomGameObject</code> type on the interactive object. To determine this matching, we first store a reference to the <code class="literal">CustomGameObject</code> script on the interactive object that is being inserted. If this object does not have a <code class="literal">CustomGameObject</code> script, we assume the type is <code class="literal">Invalid</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">case(ObjectInteraction.InteractionType.Accumulate):
{
  bool inserted = false;

  // find object of same type, and increase
  CustomGameObject cgo = iObj.gameObject.GetComponent&lt;CustomGameObject&gt;();

  CustomGameObject.CustomObjectType ot = CustomGameObject.CustomObjectType.Invalid;

  if (cgo != null)
    ot = cgo.objectType;</pre></div></li><li><p>The <code class="literal">InventoryMgr</code> class then loops over all inventory objects in the list. If it finds an object that has a matching <code class="literal">CustomGameObject</code> type to the interactive object that is being inserted, it increases the quantity property on that <code class="literal">InventoryObj</code>. If a match is not found, then <code class="literal">InventoryObj</code> is permitted to be inserted in the list as if it were a unique item, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; inventoryObjects.Count; i++)
{
CustomGameObject cgoi = inventoryObjects[i].item.GetComponent
&lt;CustomGameObject&gt;();
CustomGameObject.CustomObjectType io = CustomGameObject.CustomObjectType.Invalid;
  if (cgoi != null)
    io = cgoi.objectType;

  if (ot == io)
  {
    inventoryObjects[i].quantity++;
    // add token from this object to missionMgr
    // to track, if this obj as a token
    MissionToken mt = iObj.gameObject.GetComponent&lt;MissionToken&gt;();
   
    if (mt != null)
       missionMgr.Add(mt);

    iObj.gameObject.SetActive(false);
    inserted = true;
    break;
    }
  }</pre></div></li><li><p>Note, <a id="id100" class="indexterm"></a>if the types of the object match any existing object on the list, we do some book keeping. <a id="id101" class="indexterm"></a>We increase its number as well as copy the texture reference that we will display in the inventory. We will also disable the object (to stop it from rendering and interacting with the world) by setting its active flag to <code class="literal">false</code> and then we leave the loop, as shown in the following code. We will declare the <code class="literal">MissionToken</code> script later in this chapter:</p><div class="informalexample"><pre class="programlisting">  if (ot == io) 
  { 
    inventoryObjects[i].quantity++; 
missionTokenmt = iObj.gameObject.GetComponent&lt;MissionToken&gt;(); iObj.gameObject.SetActive (false);
    inserted = true; 
  }</pre></div></li><li><p>An important aspect to note here is that we need to check if there is a <code class="literal">MissionToken</code> script attached to this <code class="literal">InteractiveObj</code>. If there is one, then we will add <a id="id102" class="indexterm"></a>it to <code class="literal">MissionMgr</code>. In this way, we will complete the communication between the two management systems in this chapter. Later, we will see how <code class="literal">MissionMgr</code> searches for complete missions and rewards the player using mechanics similar to those discussed earlier:</p><div class="informalexample"><pre class="programlisting">  if (mt != null) 
    missionMgr.Add(mt); </pre></div></li><li><p>The <code class="literal">Insert()</code> method<a id="id103" class="indexterm"></a> of <code class="literal">InventoryMgr</code> is used to perform the actual insertion work in the list of inventory objects. It is declared with the following signature:</p><div class="informalexample"><pre class="programlisting">void Insert(InteractiveObj iObj){
}</pre></div></li><li><p>This method <a id="id104" class="indexterm"></a>first allocates a new <code class="literal">InventoryItem</code> with the <code class="literal">new</code> operator. We have to use <code class="literal">new</code> instead of <code class="literal">Object.Instantiate</code> to create a new instance of this class because this class does not inherit from <code class="literal">Object</code>. With a new instance of <code class="literal">InventoryItem</code> available for use, we will populate its properties with the data from <code class="literal">InteractiveObj</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">InventoryItem ii = new InventoryItem();
  ii.item = iObj.gameObject;
  ii.quantity = 1;</pre></div></li><li><p>Then, we will disable GameObject of <code class="literal">InteractiveObj</code> (just in case it is still enabled), and finally add the <code class="literal">InventoryItem</code> to the list with a direct call to <code class="literal">inventoryObjects.add</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  ii.item.SetActive (false);
  inventoryObjects.Add (ii);</pre></div></li><li><p>Lastly, just in case there is <code class="literal">MissionToken</code> attached to this GameObject from some other code path, we will extract the token and add it to <code class="literal">MissionMgr</code> for tracking, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  MissionToken mt = ii.item.GetComponent&lt;MissionToken&gt;();
  if (mt != null)
    missionMgr.Add(mt);</pre></div></li></ol></div><p>And this completes the work on the <code class="literal">Insert()</code> method.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec01"></a>Implementing the DisplayInventory method</h4></div></div></div><p>Let's<a id="id105" class="indexterm"></a> continue <a id="id106" class="indexterm"></a>our work by developing <code class="literal">InventoryMgr</code> as <a id="id107" class="indexterm"></a>we program the method that will display all of the inventory objects on screen by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The <code class="literal">DisplayInventory()</code> method is declared with the following signature:</p><div class="informalexample"><pre class="programlisting">void DisplayInventory() {
}</pre></div></li><li><p>This method also walks through the collection, but instead of checking the type of object, it will display a series of GUI buttons on the screen. It will also show <code class="literal">displayTexture</code> for the item in each inventory. As the position of the inventory cells are relative to the screen, we need to calculate the button positions based on the screen width and height, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">float sw = Screen.width; 
float sh = Screen.height; </pre></div></li><li><p>We will also store a reference to the texture we will display in each cell, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Texture buttonTexture = null; </pre></div></li><li><p>Then<a id="id108" class="indexterm"></a>, for clarity, we will store the number of cells in a local integer to display as shown in the following code:</p><div class="informalexample"><pre class="programlisting">int totalCellsToDisplay = inventoryObjects.Count;</pre></div></li><li><p>We will loop over all the cells and extract the texture and quantity in each <code class="literal">InventoryItem</code> in the collection, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i&lt;totalCellsToDisplay; i++) 
{
  InventoryItem ii = InventoryObjects[i]; 
  t = ii.displayTexture; 
  int quantity = ii.quantity; </pre></div><p>The result of this code is shown as follows:</p><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_02_02.jpg" /></div></li><li><p>We will compute the total length of all the cells that we want to display. This is used in <a id="id109" class="indexterm"></a>the code to render the cells centered in the middle of the screen horizontally. Recall that the width and height hold the individual cell width and height:</p><div class="informalexample"><pre class="programlisting">float totalCellLength = sw – (numcells * width); </pre></div><p>As <code class="literal">InventoryMgr</code> loops over all <code class="literal">InventoryObjects</code>, we draw a new rectangle for each item to be displayed on the screen. To do this, we need to know the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> coordinates of the upper-left corner of the rectangle, the height and width of an individual rectangle, and the texture. The <span class="emphasis"><em>y</em></span> height doesn't vary since the inventory is a horizontal row on screen, and the cell height and width don't vary since the cells are uniform by design. The texture will change, but we can use the cached value. So, we need to focus our attention on the <span class="emphasis"><em>x</em></span> coordinate for a centered array of varying length.</p></li><li><p>It turns<a id="id110" class="indexterm"></a> out that we can use this formula. The <code class="literal">totalCellLength</code> parameter is the amount of white space horizontally when all the cells are aligned on one side. If we subtract half of this, we get the starting coordinate that will be positioned half on the right and half on the left equally. Considering that width and height are the dimensions of the individual buttons for display and that <span class="emphasis"><em>i</em></span> is the loop index for the loop we are discussing, then adding <code class="literal">(width*i)</code> ensures that the subsequent <span class="emphasis"><em>x</em></span> coordinates vary horizontally across the array, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">float xcoord = totalCellLength – 0.5f*(totalCellLength) +(width*i); </pre></div></li><li><p>The rectangle <a id="id111" class="indexterm"></a>that corresponds to the shape of the button we want to display is then calculated with the following formula. Note that its position on the screen is a function of <span class="emphasis"><em>i</em></span>, the loop index, as well as <span class="emphasis"><em>y</em></span>, the screen width and height, and the button width and height:</p><div class="informalexample"><pre class="programlisting">Rect r = new Rect(totalCellLength - 0.5f*(totalCellLength) + (width*i), yPosition*sh, width, height);</pre></div><p>With all of these quantities now calculated, we will display the button with the <code class="literal">GUI.button(r, buttonTexture)</code> method, as shown in the following code. We will check for a <code class="literal">true</code> return value from this function because this is how we track when the user clicks on a button:</p><div class="informalexample"><pre class="programlisting">if (GUI.Button(r, buttonTexture)) 
{ 
  // to do – handle clicks there
} </pre></div></li><li><p>Recall that we need to display the number of items with each button. We do this with the <code class="literal">GUI.Label</code> method in a way analogous to the previous code. We will compute a second rectangle for the quantity that mirrors the cell for the button, but we will use half the cell width and height to position the rectangle in the upper-left corner for a nice effect!</p></li><li><p>We will <a id="id112" class="indexterm"></a>convert the quantity field of the current <code class="literal">InventoryItem</code> class to a string with the built-in function called <code class="literal">ToString()</code> that the integer implements, and we will pass this to the <code class="literal">GUI.Label</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Istring s = quantity.ToString()
GUI.Label(r2, s); </pre></div></li><li><p>To display UI textures and elements on the screen, Unity provides a special callback method to place our UI code whenever the UI is refreshed. This method is called <code class="literal">OnGui()</code> and has the following signature:</p><div class="informalexample"><pre class="programlisting">void OnGUI(){
}</pre></div></li><li><p>We invoke our <code class="literal">DisplayInventory()</code> method inside the <code class="literal">void OnGUI()</code> method that Unity provides because this method draws the <code class="literal">InventoryItems</code> list of <code class="literal">InventoryMgr</code> to the screen in the form of UI buttons. This callback is where all drawing and GUI-related processing occurs, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">void OnGUI() 
{ 
  DisplayInventory();
}</pre></div><p>We could modify this code slightly to draw the maximum number of cells in the inventory rather than the total number of filled <code class="literal">InventoryMgr</code> cells. We must be careful to not dereference past the end of the collection if we have been doing so!</p></li></ol></div><p>Congratulations! <a id="id113" class="indexterm"></a>We now have a working <code class="literal">InventoryMgr</code> system that can interface with interactive objects and collect them based on their custom type! While we touched briefly on the <code class="literal">MissionToken</code> class in this explanation, we need to develop a system for tracking the abstract mission objectives and rewarding the player on achieving success. This requires multiple classes. The result of performing these steps is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_02_06.jpg" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Implementing the MissionMgr script</h3></div></div></div><p>The <a id="id114" class="indexterm"></a>
<code class="literal">MissionMgr</code> class <a id="id115" class="indexterm"></a>tracks the<a id="id116" class="indexterm"></a> user's progress through abstract objectives. These objectives will be learning objectives that satisfy the game design. The pattern we use to manage missions will be similar to <code class="literal">InventoryMgr</code>; however, this system will be in charge of comparing the player's objectives with a master list of missions and with what is required to complete each one. To develop it, let's perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To accomplish this work, <code class="literal">MissionMgr</code> will need two lists. One list to hold all of the missions that the player could try and solve and another for the current tokens that the player has acquired (through interacting with interactive objects, for instance). The <code class="literal">MissionTokens</code> collection is allocated at runtime and set <a id="id117" class="indexterm"></a>to empty so that the player always starts having accomplished nothing; <a id="id118" class="indexterm"></a>we could develop a way later to load and save the mission progress via this system. The missions' list will be populated at runtime in the editor and saved, so we don't want to initialize this at runtime:</p><div class="informalexample"><pre class="programlisting">Public List&lt;mission&gt; missions; 
Public List&lt;missionToken&gt; missionTokens = new List&lt;missionTokens&gt;(); </pre></div></li><li><p>The <code class="literal">MissionMgr</code> implements three methods that allow it to perform its role and interface with other game systems:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Add(missionToken)</code>: This<a id="id119" class="indexterm"></a> method adds a newly acquired <code class="literal">MissionToken</code> to the collection. This collection will be queried while trying to determine if a mission has been completed. In <code class="literal">Add()</code>, we use a similar methodology as the <code class="literal">Add()</code> method for <code class="literal">InventoryMgr</code>. In this case, assume that the token is unique and search for a duplicate by iterating over all of the tokens for the current mission <code class="literal">m</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">bool uniqueToken = true; 
for (int i = 0; i&lt;missionTokens.Count; i++) 
{ 
  //… 
}</pre></div><p>If a duplicate is found, namely, a token is found in the collection with the same <code class="literal">id</code> field as the add candidate, we abort the operation as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (missionTokens[i].id == mt.id) 
{ 
  // duplicate token found, so abort the insert 
  uniqueToken = false; 
  break; 
} </pre></div><p>If a duplicate is not found, we add this token to the list as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (uniqueToken) 
{  
  missionTokens.add(mt); 
} </pre></div></li><li style="list-style-type: disc"><p><code class="literal">Validate(mission)</code>: This <a id="id120" class="indexterm"></a>method will compare <code class="literal">currentToken</code> set to a specific mission. If it has been found to have been satisfied, the system is notified. To do this, we will use a search pattern<a id="id121" class="indexterm"></a> similar to the one used in the <code class="literal">Add()</code> method and start by assuming<a id="id122" class="indexterm"></a> the mission is complete; only this time we will use a double-nested loop! This is because to validate a mission means to search, individually, for each token in the current mission against all of the tokens the user has collected so far. This is done as shown in the following code:</p><div class="informalexample"><pre class="programlisting">bool missionComplete = true; 
for (intinti = 0; I &lt; m.tokens.Count; i++)
{ 
  bool tokenFound = false; 
  for (int j = 0; j &lt; missionTokens.count ; j++) 
  {
    // if tokens match, tokenFound = true
  }
}</pre></div><p>By assuming the token will not be found initially, we are required to search for a matching token ID. If we don't find it, it automatically means that the mission cannot be complete, and we don't have to process any more comparisons, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (tokenFound == true))
{ 
  missionComplete = false;
  break;
}</pre></div></li><li style="list-style-type: disc"><p><code class="literal">ValidateAll()</code>: This <a id="id123" class="indexterm"></a>methods invokes <code class="literal">Validate()</code> on all user-defined missions if they are not already complete. If any mission is found to be completed, a reward is instantiated for the player through the <code class="literal">InvokeReward()</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">void ValidateAll() {

  for (int i = 0; i &lt; missions.Count; i++)
  {
    Mission m = missions[i];

    // validate missions…
  }
}</pre></div><p>We will sequentially search through all user-defined missions that have not already been completed (no need to do this once a mission is done). This enumeration will be defined in the <code class="literal">Mission</code> script, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (m.status != mission.missionStatus.MS_Completed) 
{ 
  bool missionSuccess = Validate(m);</pre></div><p>If the mission has been validated as being complete, the mission implements an <code class="literal">InvokeReward()</code> method to reward the user, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (missionSuccess == true) 
{ 
  m.InvokeReward(); 
}</pre></div></li></ul></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>Implementing the Mission script</h3></div></div></div><p>The <code class="literal">Mission</code> class<a id="id124" class="indexterm"></a> is the<a id="id125" class="indexterm"></a> container for <code class="literal">MissionTokens</code>. It implements a state that helps us specialize how a mission should be treated by the game (for instance, we may want to have the player acquire a mission but not start it). This class has a number of state variables for future extension such as <code class="literal">activated</code>, <code class="literal">visible</code>, and <code class="literal">points</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>As with the <code class="literal">InventoryItem</code> class, the <code class="literal">Mission</code> class is a helper class that only the <code class="literal">MissionMgr</code> class uses. Hence, it does not inherit from <code class="literal">monobehavior</code>. Therefore, the class signature must include the <code class="literal">[System.Serializable]</code> tag as before:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

[System.Serializable]
public class Mission {</pre></div></li><li><p>This class also implements an enumeration to describe the state of a particular mission. This is used to encode whether a state is invalid, acquired, in progress, or solved so that <code class="literal">MissionMgr</code> can handle the mission appropriately, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public enum missionStatus
{
  MS_Invalid = -1,
  MS_Acquired = 0,
  MS_InProgress = 1,
  MS_Completed = 2
};</pre></div></li><li><p>The public<a id="id126" class="indexterm"></a> variable status is an instance variable of the status enumerated type in this class. We will use this initially to make sure that once a mission is complete, <code class="literal">MissionMgr</code> no longer tries to validate it. This can be done with the following code:</p><div class="informalexample"><pre class="programlisting">Public missionStatus status; </pre></div></li><li><p>The specific elements that comprise a mission are the mission tokens that the user puts in the tokens' collection. This is a collection of logical pieces that comprises a complete objective in the game. This list will be compared against the players' acquired tokens in <code class="literal">MissionMgr</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Public List&lt;missionTokens&gt; tokens; </pre></div></li><li><p>The <code class="literal">points</code> and <code class="literal">reward</code> public variables are used to store the numerical score and the in-game rewards that are given to the user when a mission is completed. Note, <code class="literal">GameObject reward</code> could be used as a completion callback, in addition to a reference to a Prefab item for the user to pick up, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public int points;
public GameObject reward;</pre></div></li><li><p>The <code class="literal">displayName</code> public variable is used by the user in the Unity3D Editor as a place for a helpful string to describe the mission's nature, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public string displayName;</pre></div><p>This class implements one method: the <code class="literal">InvokeReward()</code> method. This function will spawn a new <code class="literal">gameObject</code> into the world that has been set in the editor. Through this mechanism, the player can be rewarded with points, a new object or objective can appear in the world, or any other outcome can be encapsulated in a Unity <code class="literal">Prefab</code> object.</p></li><li><p>Once a mission <a id="id127" class="indexterm"></a>has been validated and <code class="literal">InvokeReward</code> has been called, the mission itself is disabled and its status is set to <code class="literal">Completed</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.status = missionStatus.MS_Completed; </pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Implementing the MissionToken script</h3></div></div></div><p>The <a id="id128" class="indexterm"></a>
<code class="literal">MissionToken</code> class <a id="id129" class="indexterm"></a>stores the information for an individual mission component. This class acts as a container for this abstract data. We give it an ID, a title that is human readable, and a description. By giving each <code class="literal">MissionToken</code> a unique ID, we give the <code class="literal">Mission</code> class a powerful way of tracking the mission progress. This class is used in a way by which the user adds instances of this component to various interactive objects that can be manipulated by the player, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Public int id; 
Public string title; 
Public string description; </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec18"></a>Implementing the SimpleLifespanScript</h3></div></div></div><p>The <a id="id130" class="indexterm"></a>
<code class="literal">SimpleLifespanScript</code> class <a id="id131" class="indexterm"></a>is a simple helper class that can be used in conjunction with the <code class="literal">Instantiate()</code> method to instantiate a GameObject in the world that will have a specified but finite lifespan. We use it to enable an instance of a Prefab that is live for a set period of time and then destroys itself as a reward for completing a mission. By attaching this to the reward that is displayed when a mission is completed, the prompt is given a set duration on the screen after which it disappears.</p><p>Specifically, the <code class="literal">seconds</code> parameter is the time for which the object will survive before self destruction, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Public float seconds </pre></div><p>In the <code class="literal">update</code> method, we count this value by the actual time elapsed in each frame (from <code class="literal">Timer.deltaTime</code>). Once this reaches zero, we destroy the object and all the scripts attached to it (including the <code class="literal">simpleLifespanScript</code>), as shown in the following code:</p><div class="informalexample"><pre class="programlisting">seconds -= Time.deltaTime; 
if (seconds &lt;= 0.0f) 
  GameObject.Destroy(this.gameObject); </pre></div><p>Congratulations! We now have a robust set of scripts for <code class="literal">MissionMgr</code>, missions, tokens, and rewards. Let's<a id="id132" class="indexterm"></a> apply what we have built in an example that exercises the mission system, the inventory system, and interactive objects.</p></div></div>