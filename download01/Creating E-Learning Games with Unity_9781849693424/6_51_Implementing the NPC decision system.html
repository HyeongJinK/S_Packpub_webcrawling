<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec52"></a>Implementing the NPC decision system</h2></div></div><hr /></div><p>The NPCs in our e-learning game will need to be able to interact with the player and the world in addition to following a user-defined path. While the path-following code was easily encapsulated in one <a id="id295" class="indexterm"></a>file, we will see that a general purpose solution to the first problem requires a more intricate design.</p><p>Our solution will be modeled around and function similarly to a question-and-answer system. A number of classes will be required for implementation:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">npcCondition</code>: This<a id="id296" class="indexterm"></a> is the base class for a question that the NPCs logic will ask about the player or the world.</p></li><li style="list-style-type: disc"><p><code class="literal">npcResponse</code>: This is the<a id="id297" class="indexterm"></a> base class for a response that the NPCs logic will invoke if a condition is found to be true.</p></li><li style="list-style-type: disc"><p><code class="literal">npcInteraction</code>: This<a id="id298" class="indexterm"></a> container class will house the association of a condition with a response. It will be responsible for testing if the condition is true (whatever the condition may be) and for invoking the appropriate response when that happens.</p></li><li style="list-style-type: disc"><p><code class="literal">npcDecisionMgr</code>: This<a id="id299" class="indexterm"></a> class is the brain of the NPC. It will house a collection of interactions and will ask these interactions to evaluate themselves. Since each interaction responds to the state of the world individually, the brain only needs to delegate this responsibility to each interaction! Simple, right?</p><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_06_09.jpg" /></div></li></ul></div><p>To prove that our <code class="literal">DecisionMgr</code> system works, <a id="id300" class="indexterm"></a>we will need a few more specialization helper classes. These will help us see the system in action and validate its behavior.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">condition_closerThanThresh</code>: This is a<a id="id301" class="indexterm"></a> condition script that checks if the distance from object A to object B is less than a parameter. If it is, it returns true.</p></li><li style="list-style-type: disc"><p><code class="literal">condition_fartherThanThresh</code>: This<a id="id302" class="indexterm"></a> is a condition script that checks if the distance from object A to object B is greater than a parameter. If it is, it returns true.</p></li><li style="list-style-type: disc"><p><code class="literal">response_changeState</code>: This<a id="id303" class="indexterm"></a> is a response script that changes the state of an NPC to the state parameter.</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec51"></a>Implementing the npcCondition script</h3></div></div></div><p>The<a id="id304" class="indexterm"></a> <code class="literal">npcCondition</code> class<a id="id305" class="indexterm"></a> is the base class for all questions that an NPC might ask about the player or the state of the world.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new class in the editor using the new class wizard. Name it <code class="literal">npcCondition</code>.</p></li><li><p>Open the script in MonoDevelop, and change the class declaration. Add the word <code class="literal">abstract</code> in front of <code class="literal">public</code> so that it reads the following. We use the keyword <code class="literal">abstract</code> because this class will be used to just declare an interface. We will use this class as a common base for all of the condition classes our game will have for NPCs:</p><div class="informalexample"><pre class="programlisting">abstract public class npcCondition : MonoBehaviour{ </pre></div></li><li><p>Using the <code class="literal">abstract</code> keyword, declare an interface method named <code class="literal">eval()</code> with the following syntax:</p><div class="informalexample"><pre class="programlisting">abstract public bool eval(); </pre></div></li><li><p>By designing <code class="literal">npcCondition</code> as an interface class, we are telling Unity that there will be a base class named <code class="literal">npcCondition</code>. Other conditions will be added to the game, and they will have different behaviors for sure, but one common element is that they all have a method named <code class="literal">eval()</code>, which they all implement in a unique way. In this way, each condition class can specialize its behavior through the <code class="literal">eval()</code> method, and no matter what is being evaluated, by returning <code class="literal">true</code>, we can pass a message to the <code class="literal">DecisionMgr</code> class that a condition has become true and that we need to invoke a response script.</p></li></ol></div><p>In this way, we will need only to call <code class="literal">eval()</code> on <code class="literal">npcCondition</code> in the code, without the need to know specifically the type of condition being evaluated. This simplifies our code complexity immensely, allowing our condition code to be polymorphic, which is a good thing!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec52"></a>Implementing the npcResponse script</h3></div></div></div><p>The <a id="id306" class="indexterm"></a>
<code class="literal">npcResponse</code> class<a id="id307" class="indexterm"></a> is the base class for all responses that an NPC might invoke when a condition is found to be <code class="literal">true</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new class in the editor using the new class wizard. Name it <code class="literal">npcResponse</code>.</p></li><li><p>As seen previously, open the script in MonoDevelop, and change the class declaration; add the world <code class="literal">abstract</code> in front of the public so that it reads the following:</p><div class="informalexample"><pre class="programlisting">abstract public class npcResponse : MonoBehaviour{ </pre></div></li><li><p>Using the <code class="literal">abstract</code> keyword, declare an interface method named <code class="literal">dispatch()</code> with the following syntax:</p><div class="informalexample"><pre class="programlisting">abstract public bool dispatch(); </pre></div></li><li><p>As seen previously, by designing <code class="literal">npcResponse</code> as an interface class, we are telling Unity that there will be a base class named <code class="literal">npcResponse</code>. Other responses will be added to the game, and they will have different behaviors for sure, but one common element is that they all have a method named <code class="literal">dispatch()</code>, which they all implement in a unique way.</p></li></ol></div><p>In this way, we will need only to call <code class="literal">dispatch()</code> on <code class="literal">npcResponse</code> in the code, without the need to know specifically the implementation of response that is being dispatched. This simplifies our code complexity immensely and allows our response code to be polymorphic as with the conditions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec53"></a>Implementing the npcInteraction script</h3></div></div></div><p>The<a id="id308" class="indexterm"></a> <code class="literal">npcInteraction</code> class<a id="id309" class="indexterm"></a> forms an association between a condition and a response; it is in fact a container for both a condition to test and a response to invoke if the condition is true. Remember, it could be any specific condition or response since those two classes are interfaces.</p><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_06_10.jpg" /></div><p>Perform the following steps to implement the <code class="literal">npcInteraction</code> script:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new <a id="id310" class="indexterm"></a>class in the editor. Name it <code class="literal">npcInteraction</code>.</p></li><li><p>Unlike <a id="id311" class="indexterm"></a>the <code class="literal">npcCondition</code>, <code class="literal">npcReponse</code> classes, and most other classes to date, we will not derive this class from <code class="literal">MonoBehaviour</code>. Inheriting from <code class="literal">MonoBehaviour</code> is useful when you want to place your script onto a GameObject, and in most cases this is desired. For this script, we will not want to do that (you will see why in a moment). So remove the <code class="literal">MonoBehavior</code> line from the class declaration, and add the <code class="literal">[System.Serializable]</code> tag so that it resembles the following:</p><div class="informalexample"><pre class="programlisting">[System.Serializable]
public class npcInteraction {</pre></div><p>Adding the <code class="literal">Serializable</code> attribute is necessary when we don't inherit from <code class="literal">MonoBehaviour</code> because serialization is one of many features that <code class="literal">MonoBehaviour</code> provides to the child classes. We explicitly tag this class as serializable because we want to be able to save the instances of our class data in the editor. The difference here is that this script will not be attachable as a component on a GameObject but rather will appear in place in other classes as a member variable.</p></li><li><p>Add a public reference to <code class="literal">npcCondition</code> and <code class="literal">npcResponse</code>. Whenever this condition evaluates to <code class="literal">true</code>, the interaction class will dispatch the response:</p><div class="informalexample"><pre class="programlisting">public npcCondition condition;
public npcResponse response;</pre></div></li><li><p>We also add an activated Boolean to allow us to selectively enable and disable interactions based on the state of the game:</p><div class="informalexample"><pre class="programlisting">public bool active;</pre></div></li><li><p>The method <code class="literal">eval()</code> is <a id="id312" class="indexterm"></a>where <a id="id313" class="indexterm"></a>the brunt of the work in the interaction class is performed. It first checks if the interaction is active. If it is, and if there is a condition, it will evaluate the condition and check if that condition is true or not:</p><div class="informalexample"><pre class="programlisting">if (active == true)
{
  if (condition != null)
  {
    if (condition.eval() == true)
    { ...</pre></div></li><li><p>Recall that the <code class="literal">npcCondition</code> reference could be any specialization of <code class="literal">npcCondition</code> so that the implementation of the <code class="literal">eval()</code> function could appear in any child class as long as it has been assigned in the inspector.</p></li><li><p>If the condition returns <code class="literal">true</code>, we check if a response class has been associated in the inspector. If it has been dispatched, we dispatch the response!</p><div class="informalexample"><pre class="programlisting">if (response != null)
  rval = response.dispatch();</pre></div></li></ol></div><p>Congratulations! We have implemented a container class that associates a generic condition with a generic response. We use the abstract keyword in the base class so that child classes that derive from <code class="literal">npcCondition</code> and <code class="literal">npcResponse</code> can all freely be connected to <code class="literal">npcInteraction</code>. Now let's look at how to connect our interactions together.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec54"></a>Implementing the npcDecisionMgr script</h3></div></div></div><p>This class is<a id="id314" class="indexterm"></a> the <a id="id315" class="indexterm"></a>brain of the NPC. It contains a collection of the interactions that are constantly evaluated. If any condition is determined to be <code class="literal">true</code>, the appropriate response is dispatched. To construct it, we need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new script named <code class="literal">npcDecisionMgr</code>.</p></li><li><p>As with <code class="literal">npcInteraction</code>, edit the class declaration to remove the inheritance from <code class="literal">MonoBehaviour</code>, and add explicit serialization so that the class data can be saved in the editor:</p><div class="informalexample"><pre class="programlisting">[System.Serializable]
public class npcDecisionMgr{</pre></div></li><li><p>A public list of <code class="literal">npcInteraction</code> is exposed to the inspector. In here, a collection of condition/response pairs can be added for later evaluation. In this way, a whole set of logical interactions can be added to a character—all from within the editor!</p><div class="informalexample"><pre class="programlisting">public List&lt;NpcInteraction&gt; interactions;</pre></div></li><li><p>The <code class="literal">eval()</code> method is <a id="id316" class="indexterm"></a>used to visit each NPC interaction in the list, where each one is evaluated in turn; recall this checks the <code class="literal">condition.eval()</code> method for the condition member of the interaction:</p><div class="informalexample"><pre class="programlisting">foreach (npcInteraction e in interactions)
{
  e.eval();
}</pre></div></li></ol></div><p>Congratulations! <a id="id317" class="indexterm"></a>You have completed writing the <code class="literal">DecisionMgr</code> class for the NPC. This is the class that will contain all of the logic for the NPC—what it will query in the world, and how it will respond to those queries.</p></div></div>