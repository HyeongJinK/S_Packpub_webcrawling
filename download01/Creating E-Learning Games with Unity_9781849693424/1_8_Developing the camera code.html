<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec14"></a>Developing the camera code</h2></div></div><hr /></div><p>In our <a id="id23" class="indexterm"></a>3D game, the <a id="id24" class="indexterm"></a>main camera mode will follow a third-person algorithm. This means that it will follow the player from behind, trying to keep the player on screen and centered in view at all times. Before we start developing the camera, we need to think about the basic requirements of our game in order to be able to program the camera to achieve good cinematographic results. This list of requirements will grow over time; however, by considering the requirements early on, we build an extensible system throughout the course of this book by applying good system design in our software. In no particular order, we list the requirements of a good camera system as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>It needs to be able to track the hero at a pleasing distance and speed and in an organic way</p></li><li style="list-style-type: disc"><p>It needs to be able to transition in an appealing way, from tracking various objects</p></li><li style="list-style-type: disc"><p>It needs to be able to frame objects in the field of view, in a cinematic and pleasing way</p></li></ul></div><p>Starting with an initial camera and motion system based on the Unity3D examples, we will extend these over time. We do this not only because it is instructive but also with the aim of extending them and making them our own over time. With these requirements in mind, let's build the camera code. Before we do, let's consider some pseudocode for the algorithm.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec08"></a>Implementing GameCam.cs</h3></div></div></div><p>The <code class="literal">GameCam</code> script <a id="id25" class="indexterm"></a>is the class that we will attach<a id="id26" class="indexterm"></a> our <code class="literal">MainCamera</code> object to; it will be responsible for the motion of our in-game camera and for tracking the player on screen. The following five steps describe our <code class="literal">GameCam</code> camera algorithm:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>For every frame that our camera updates, if we have a valid <code class="literal">trackObj</code> GameObject reference, do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Cache the facing angle and the height of the object we are tracking.</p></li><li><p>Cache the current facing angle and height of the camera (the <code class="literal">GameObject</code> that this script is attached to).</p></li></ol></div></li><li><p>Linearly interpolate from current facing to desired facing according to a dampening factor.</p></li><li><p>Linearly interpolate from current height to desired height according to another dampening factor.</p></li><li><p>Place the camera behind the track object, at the interpolated angle, facing the track object so that the object of interest can be seen in view, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_01_05.jpg" /></div></li></ol></div><p>Now let's implement<a id="id27" class="indexterm"></a> this algorithm in C# code by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Right click on the <code class="literal">Chapter1 assets</code> folder and select <span class="strong"><strong>Create New C# Script</strong></span>. Name it <code class="literal">GameCam</code> and add it to the <code class="literal">Main Camera</code> object.</p></li><li><p>Create a public <code class="literal">GameObject</code> reference called <code class="literal">TrackObj</code> with the following code. This will point to the <code class="literal">GameObject</code> that this camera is tracking at any given time, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public GameObject trackObj;</pre></div></li><li><p>Create the following four public float variables that will allow adjustment of the camera behavior in the object inspector. We will leave these uninitialized and then find working default values with the inspector, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Public float height; 
Public float desiredDistance;
Public float heightDamp; 
Public float rotDamp; </pre></div><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_01_07.jpg" /></div></li><li><p>Recall that the <code class="literal">Update()</code><a id="id28" class="indexterm"></a> loop of any GameObject gets called repeatedly while the game simulation is running, which makes this method a great candidate in which we can put our main camera logic. Hence, inside the <code class="literal">Update()</code> loop of this script, we will call a <code class="literal">UpdateRotAndTrans()</code> custom method<a id="id29" class="indexterm"></a>, which will contain the actual camera logic. We will place this logic inside the <code class="literal">UpdateRotAndTrans()</code> method<a id="id30" class="indexterm"></a>. This method will update the rotation (facing angle) and translation (position) of the camera in the world; this is how <code class="literal">GameCam</code> will accomplish the stated goal of moving in the world and tracking the player:</p><div class="informalexample"><pre class="programlisting">void Update() { 
  UpdateRotAndTrans(); 
} </pre></div></li><li><p>Above the update loop, let's implement the <a id="id31" class="indexterm"></a>
<code class="literal">UpdateRotAndTrans()</code> method as follows:</p><div class="informalexample"><pre class="programlisting">void UpdateRotAndTrans () { 
  // to be filled in
} </pre></div></li><li><p>Inside<a id="id32" class="indexterm"></a> this method, step 1 of our algorithm is accomplished with a sanity check on <code class="literal">trackObj</code>. By checking for null and reporting an error to <code class="literal">debugLog</code>, we can make catching bugs much easier by looking at the console. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (trackObj) { 
} 
else { 
  Debug.Log("GameCamera:Error,trackObj invalid");
}</pre></div></li><li><p>Step 2 of our algorithm is to store the desired rotation and height in two local float variables. In the case of the height, we offset the height of<code class="literal"> trackObj</code> by an exposed global variable <code class="literal">height</code> so that we can adjust the specifics of the object as shown in the following code (sometimes an object may have its transform 0 at the ground plane, which would not look pleasing, we need numbers to tweak):</p><div class="informalexample"><pre class="programlisting">DesiredRotationAngle = trackObj.transform.eulerAngles.y; 
DesiredHeight = trackObj.transform.position.y + height; </pre></div></li><li><p>We also need to store the local variants of the preceding code for processing in our algorithm. Note the simplified but similar code compared to the code in the previous step. Remember that the <code class="literal">this</code> pointer is implied if we don't explicitly place it in front of a component (such as <code class="literal">transform</code>):</p><div class="informalexample"><pre class="programlisting">float RotAngle = transform.eulerAngles.y; 
float Height = transform.position.y; </pre></div></li><li><p>Step 3 of our algorithm is where we do the actual <span class="strong"><strong>LERP</strong></span> (<span class="strong"><strong>linear interpolation</strong></span>)<a id="id33" class="indexterm"></a> of the current and destination values for y-axis rotation and height. Remember that making use of the LERP method between two values means having to calculate a series of new values between the start and end that differs between one another by a constant amount.</p><p>Remember that Euler angles are the rotation about the cardinal axes, and Euler <span class="emphasis"><em>y</em></span> indicates the horizontal angle of the object. Since these values change, we smooth out the current rotation and height more with a smaller dampening value, and we tighten the interpolation with a larger value.</p><p>Also note that we multiply <code class="literal">heightDamp</code> by <code class="literal">Time.deltaTime</code> in order to make the height interpolation frame rate independent, and instead dependent on elapsed time, as follows:</p><div class="informalexample"><pre class="programlisting">RotAngle = Mathf.LerpAngle 
(RotAngle, DesiredRotationAngle, rotDamp); 
Height = Mathf.Lerp 
(Height, DesiredHeight, heightDamp * Time.deltaTime); </pre></div></li><li><p>The fourth <a id="id34" class="indexterm"></a>and last step in our <code class="literal">GameCam</code> algorithm is to compute the position of the camera.</p><p>Now that we have an interpolated rotation and height, we will place the camera behind <code class="literal">trackObject</code> at the interpolated height and angle. To do this, we will take the facing vector of <code class="literal">trackObject</code> and scale it by the negative value of <code class="literal">desiredDistance</code> to find a vector pointing in the opposite direction to <code class="literal">trackObject</code>; doing this requires us to convert <code class="literal">eulerAngles</code> to <code class="literal">Quaternion</code> to simplify the math (we can do it with one API function!).</p><p>Adding this to the <code class="literal">trackObject</code> position and setting the height gives the desired offset behind the object, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Quaternion CurrentRotation = Quaternion.Euler 
(0.0f, RotAngle, 0.0f);
Vector3 pos = trackObj.transform.position; 
pos -= 
CurrentRotation * Vector3.forward * desiredDistance; 
pos.y = Height; 
transform.position = pos;</pre></div></li><li><p>As a final step, we point the <code class="literal">LookAt</code> GameObject reference of the camera to the center of <code class="literal">trackObject</code> so that it is always precisely in the middle of the field of view. It is most important to never lose the object you are tracking in a 3D game. This is critical!</p><div class="informalexample"><pre class="programlisting">transform.LookAt (trackObj.transform.position);</pre></div><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_01_03.jpg" /></div></li></ol></div><p>Congratulations! <a id="id35" class="indexterm"></a>We have now written our first <code class="literal">camera</code> class that can smoothly track a rotating and translating object. To test this class, let's set the following default values in the <span class="strong"><strong>Inspector</strong></span> pane as seen in the previous screenshot:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>TrackObj</strong></span>: Set this to the <span class="strong"><strong>Player1</strong></span> object by dragging-and-dropping the object reference from the <span class="strong"><strong>Hierarchy</strong></span> tab to the <code class="literal">trackObj</code> reference in the object inspector.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Height</strong></span>: Set this to <code class="literal">0.25</code>. In general, the lower the camera, the more dramatic the effect but the less playable the game will be (because the user can see less of the world on screen).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Desired Distance</strong></span>: Set this to <code class="literal">4</code>. At this setting, we can see the character framed nicely on screen when it is both moving and standing still.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Rot Damp</strong></span>: Set this to <code class="literal">0.01</code>. The smaller this value, the looser and more interesting the rotation effect. The larger this value, the more tense the spring in the interpolation.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Height Damp</strong></span>: Set this to <code class="literal">0.5</code>. The smaller this value, the looser and more interesting the height blending effect.</p></li></ul></div><p>Once the player<a id="id36" class="indexterm"></a> controls are developed (refer to the next section), try experimenting with these values and see what happens.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip02"></a>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books you have purchased via your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div>