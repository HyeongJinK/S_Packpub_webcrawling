<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec29"></a>An introduction to Finite State Machines</h2></div></div><hr /></div><p>A common strategy in game play programming (and computer science in general) is to model a system in terms of discrete objects and their interactions with one another. To do this requires us to understand what the participants are in a system, how they operate in different scenarios, and how they change states.</p><p>The <span class="strong"><strong>Finite State Machine</strong></span> (<span class="strong"><strong>FSM</strong></span>)<a id="id224" class="indexterm"></a> is one such technique. With this, the idea is to model the behavior of the object in a number of code blocks. Inside each one, you put the specific code for that block that makes it unique. You also determine what scenarios cause an object to switch from one block (state) to another. Because each state is an encapsulation, it makes your code extensible and maintainable (which is a great thing!).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec39"></a>Implementing an FSM in a game</h3></div></div></div><p>While there are <a id="id225" class="indexterm"></a>many ways of programming an FSM, we will commonly encounter two strategies as game programmers on our e-learning example. Each one has its own unique structural components, benefits, and drawbacks.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec40"></a>The switch case FSM</h3></div></div></div><p>In this <a id="id226" class="indexterm"></a>form, <a id="id227" class="indexterm"></a>we require three components:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>An enumeration to list the states: Each individual element in the enumerated type corresponds to a single state in the FSM model. For example, an FSM with three states could be implemented in the enumeration <code class="literal">eMyState</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public enum eMyState {
  STATE_INVALD = -1, // an error state which can be used to 
    encode the logic for processing an error condition
  STATE_A = 0, // an arbitrary state in an FSM
  STATE_B = 1, // a second arbitrary state
  STATE_C = 2 // a third arbitrary state, et cetera
};</pre></div><p>Note that we make the enumeration public so that other client classes can have access (to set the state). Also note that we have four distinct states for an FSM with three logical states as it is useful to encode an error state in our type for -1. A variable of type <code class="literal">eMyState</code> is declared in the class to store the current value of the state.</p></li><li style="list-style-type: disc"><p>A switch case block: This structure allows the program to jump to the current state/block (as indicated from the enumeration) to invoke the code for that state as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Switch (state) {
   case(eMyState.STATE_A):
   {
      // code for STATE A here
      break;
   }

   case(eMyState.STATE_B):
   {
      // code for STATE B here
      break;
   }

   case(eMyState.STATE_C):
   {
      // code for STATE C here 
      break;
   }

   Default:
   {
      // handle fatal error
      break;
   }
}</pre></div></li><li style="list-style-type: disc"><p>A system for encoding and switching state: Two variables of type <code class="literal">eMyState</code> are used. <a id="id228" class="indexterm"></a>One to encode current state and one to encode previous tick state. The previous tick state updates itself to current state on every frame of the update loop. When the current state is not the same as the previous tick state, it means that we have changed state and need to update the current state var:</p><div class="informalexample"><pre class="programlisting">if (gameState != _prevGameState)
{
   ChangeState(gameState);
}
_prevGameState = gameState;</pre></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec41"></a>Classes implementation of FSM</h3></div></div></div><p>In this second<a id="id229" class="indexterm"></a> form of FSM, an individual C# class is used for each state. This class's update loop then holds the body of the code for that state's specialization. Changing states is performed the same way as in the previous example. An enumeration is also used to give other systems in the codebase a means of setting states.</p></div></div>