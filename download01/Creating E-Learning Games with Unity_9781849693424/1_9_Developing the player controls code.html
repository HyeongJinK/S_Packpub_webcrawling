<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec15"></a>Developing the player controls code</h2></div></div><hr /></div><p>The third <a id="id37" class="indexterm"></a>system we need to implement<a id="id38" class="indexterm"></a> is the controls or how the character will respond to the user input. As a first pass, we need to be able to move our player in the world, so we will implement walk forward, walk backwards, walk left, and walk right. Luckily for us, Unity gives us an input system with axes so that we can write our control code once, and it will work with any devices that have an axis (such as keyboard or joypad). Of course, the devil is in the detail and keyboard controls behave differently from joypads, so we will write our code for keyboard input as it is the most responsive and most ubiquitous device. Once this script is finished, its behavior in combination with the <code class="literal">GameCam</code> script will control how the player motion feels in the game.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec09"></a>Implementing PlayerControls.cs</h3></div></div></div><p>For every <a id="id39" class="indexterm"></a>frame our <a id="id40" class="indexterm"></a>player updates, perform the following steps that describe our PlayeControls algorithm:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Store the forward and right vectors of the current camera.</p></li><li><p>Store the raw axis input from the controller (keyboard or joystick). These values will range from <code class="literal">-1.0</code> to <code class="literal">1.0</code>, corresponding to full left or right, or full forward or backwards. Note that<a id="id41" class="indexterm"></a> if you use a joystick, the rate of change of these values will generally be much slower than if a keyboard is used, so the code that processes it must be adjusted accordingly.</p></li><li><p>Apply<a id="id42" class="indexterm"></a> the raw input to transform the current camera basis vectors and compute a camera relative target direction vector.</p></li><li><p>Interpolate the current movement vector towards the target vector and damp the rate of change of the movement vector, storing the result away.</p></li><li><p>Compute the displacement of the camera with <span class="emphasis"><em>movement * movespeed</em></span> and apply this to the camera.</p></li><li><p>Rotate the camera to the current move direction vector.</p></li></ol></div><p>Now let's implement this algorithm in C# code:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Right click on the <code class="literal">Chapter1 assets</code> folder and select <span class="strong"><strong>Create New C# Script</strong></span>. Name it <code class="literal">PlayerControls.cs</code>. Add this script to <code class="literal">GameObject</code> of <span class="strong"><strong>Player1</strong></span> by dragging-and-dropping it onto the object.</p></li><li><p>Add a <code class="literal">CharacterController</code> component to the player's <code class="literal">GameObject</code> component as well. If Unity asks you whether you want to replace the box collider, agree to the change.</p></li><li><p>Create <code class="literal">public Vector3 moveDirection</code> that will be used to store the current actual direction vector of the player. We initialize it to the zero vector by default as follows:</p><div class="informalexample"><pre class="programlisting">public Vector3 moveDirection = Vector3.zero;</pre></div></li><li><p>Create three public float variables: <code class="literal">rotateSpeed</code>, <code class="literal">moveSpeed</code>, and <code class="literal">speedSmoothing</code>. The first two are coefficients of motion for rotation and translation, and the third is a factor that influences the smoothing of <code class="literal">moveSpeed</code>. Note that <code class="literal">moveSpeed</code> is private because this will only be computed as the result of the smoothing calculation between <code class="literal">moveDirection</code> and <code class="literal">targetDirection</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public Float rotateSpeed;
private float moveSpeed = 0.0f;
public float speedSmoothing = 10.0f;</pre></div></li><li><p>Inside the update <a id="id43" class="indexterm"></a>loop of this script, we will call a custom method called <code class="literal">UpdateMovement()</code><a id="id44" class="indexterm"></a>. This method will contain the code that actually reads input from the user and moves the player in the game as shown in the following code:</p><div class="informalexample"><pre class="programlisting">void Update() {
  UpdateMovement()
}</pre></div></li><li><p>Above<a id="id45" class="indexterm"></a> the update loop, let's implement the <code class="literal">UpdateMovement()</code> method as follows:</p><div class="informalexample"><pre class="programlisting">void UpdateMovement () { 
  // to be filled in
}</pre></div></li><li><p>Inside this method, step 1 is accomplished by storing the horizontal projection of the forward and right vectors of the current camera as follows:</p><div class="informalexample"><pre class="programlisting">Vector3 cameraForward = Camera.mainCamera.transform.TransformDirection
(Vector3.forward); </pre></div></li><li><p>We project onto the horizontal plane because we want the character's motion to be parallel to the horizontal plane rather than vary with the camera's angle. We also use <code class="literal">Normalize</code> to ensure that the vector is well formed, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">cameraForward.y = 0.0f; 
cameraForward.Normalize(); </pre></div><p>Also, note the trick whereby we find the right vector by flipping the x and z components and negating the last component. This is faster than extracting and transforming the right vector, but returns the same result shown in the following code:</p><div class="informalexample"><pre class="programlisting">Vector3 cameraRight = new Vector3
(cameraForward.z, 0.0f, -cameraForward.x); </pre></div></li><li><p>We store the raw axis values from Unity's <code class="literal">Input</code> class. Recall that this is the class that handles input for us, from which we can poll button and axes values. For <code class="literal">h</code> (which has a range from <code class="literal">-1</code> to <code class="literal">1</code>), the value between this range corresponds to an amount of horizontal displacement on the analog stick, joystick, or a keypress, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">float v = Input.GetAxisRaw("Vertical"); </pre></div><p>For v (which ranges from <code class="literal">-1</code> to <code class="literal">1</code>), the value between this range corresponds to an amount of vertical displacement of the analog stick, joystick, or a different keypress.</p><div class="informalexample"><pre class="programlisting">float h = Input.GetAxisRaw("Horizontal"); </pre></div></li></ol></div><p>To see the <a id="id46" class="indexterm"></a>keybindings,<a id="id47" class="indexterm"></a> please check the input class settings under <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>ProjectSettings</strong></span> | <span class="strong"><strong>Input</strong></span>. There, under the <span class="strong"><strong>Axes</strong></span> field in the object inspector, we can see all of the defined axes in the input manager class, their bindings, their names, and their parameters.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We compute the target direction vector for the character as proportional to the user input (v, h). By transforming (v, h) into camera space, the result is a world space vector that holds a camera relative motion vector that we store in <code class="literal">targetDirection</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Vector3 targetDirection =
 h * cameraRight + v * cameraForward; </pre></div></li><li><p>If this target vector is non-zero (when the user is moving, and hence <code class="literal">v</code>, <code class="literal">h</code> are non-zero), we update <code class="literal">moveDirection</code> by rotating it smoothly (and by a small magnitude), towards <code class="literal">moveTarget</code>. By doing this in every frame, the actual direction eventually approximates the target direction, even as <code class="literal">targetDirection</code> itself changes.</p><p>We keep <code class="literal">moveDirection</code> normalized because our move speed calculation assumes a unit direction vector as shown in the following code:</p><div class="informalexample"><pre class="programlisting">moveDirection = Vector3.RotateTowards 
(moveDirection, targetDirection, rotateSpeed * Mathf.Deg2Rad * Time.deltaTime, 1000);
moveDirection = moveDirection.normalized; </pre></div></li><li><p>We smoothly LERP the speed of our character up and down, trailing the actual magnitude of the <code class="literal">targetDirection</code> vector. This is to create an appealing effect that reduces jitter in the player and is crucial when we are using keyboard controls, where the variance in <code class="literal">v</code> and <code class="literal">h</code> raw data is at its highest, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">float curSmooth = 
speedSmoothing * Time.deltaTime;
float targetSpeed = Mathf.Min
(targetDirection.magnitude, 1.0f);
moveSpeed = Mathf.Lerp 
(moveSpeed, targetSpeed, curSmooth);</pre></div></li><li><p>We <a id="id48" class="indexterm"></a>compute the displacement <a id="id49" class="indexterm"></a>vector for the player in this frame with <span class="emphasis"><em>movementDirection * movespeed</em></span> (remember that <code class="literal">movespeed</code> is smoothly interpolated and <code class="literal">moveDirection</code> is smoothly rotated toward <code class="literal">targetDirecton</code>).</p><p>We scale displacement by <code class="literal">Time.delta</code> time (the amount of real time that has elapsed since the last frame). We do this so that our calculation is time dependent rather than frame rate dependent as shown in the following code:</p><div class="informalexample"><pre class="programlisting">Vector3 displacement = 
moveDirection * moveSpeed * Time.deltaTime;</pre></div></li><li><p>Then, we move the character by invoking the <code class="literal">move</code> method on the <code class="literal">CharacterController</code> component of the player, passing the <code class="literal">displacement</code> vector as a parameter as follows:</p><div class="informalexample"><pre class="programlisting">this.GetComponent&lt;CharacterController&gt;()
.Move(displacement);</pre></div></li><li><p>Finally, we assign the rotation of <code class="literal">MoveDirection</code> to the rotation of the transform as follows:</p><div class="informalexample"><pre class="programlisting">transform.rotation = Quaternion.LookRotation (moveDirection);</pre></div><div class="mediaobject"><img src="/graphics/9781849693424/graphics/3424OS_01_04.jpg" /></div></li></ol></div><p>Congratulations! You have now written your first player controls class that can read user input from multiple <a id="id50" class="indexterm"></a>axes <a id="id51" class="indexterm"></a>and use that to drive a rotating and translating character capsule. To test this class, let's set the following default values in the <span class="strong"><strong>Inspector</strong></span> pane as seen in the previous screenshot:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Track Obj</strong></span>: Set this to the <span class="strong"><strong>Player1</strong></span> object by dragging-and-dropping the object reference from the <span class="strong"><strong>Hierarchy</strong></span> tab to the <code class="literal">trackObj</code> reference in the object inspector.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Height</strong></span>: Set this to <code class="literal">0.25</code>. In general, the lower the camera, the more dramatic the effect, but the less playable the game will be (because the user can see less of the world on screen).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Desired Distance</strong></span>: Set this to <code class="literal">4</code>. At this setting, we can see the character framed nicely on screen when it is both moving and standing still.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Rot Damp</strong></span>: Set this to <code class="literal">0.01</code>. The smaller this value, the looser and more interesting the rotation effect. The larger this value, the more tense the spring in the interpolation.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Height Damp</strong></span>: Set this to <code class="literal">0.5</code>. The smaller this value, the looser and more interesting the height blending effect.</p></li></ul></div><p>Try experimenting with the following values and see what happens:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Rotate Speed</strong></span> : Set the default to <code class="literal">100</code>. The higher the value, the faster the player will rotate when the horizontal axis is set to full left or right.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Speed Smoothing</strong></span>: Set the default to <code class="literal">10</code>. The higher this value, the smoother the character's acceleration and deceleration.</p></li></ul></div><p>Try experimenting with these values to understand their effect on the player's motion behavior.</p></div></div>