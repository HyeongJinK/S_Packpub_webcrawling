<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec49"></a>Creating the NPC GameObject</h2></div></div><hr /></div><p>To develop and test our <a id="id281" class="indexterm"></a>NPC systems, we need a simple Prefab to represent our NPC character. Once this is working, we will be able to add polish to the game by replacing it with a more visually appealing model and by adding animation. To<a id="id282" class="indexterm"></a> begin with, create a capsule with a scaled hat similar to the player Prefab placeholder.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec50"></a>Implementing the npcScript class</h3></div></div></div><p>The <code class="literal">npcScript</code> class <a id="id283" class="indexterm"></a>will encode the base state machine for NPCs. To develop a robust non-player character system requires a model of the behavior we want to present to the player. Once we have a model, we can build an FSM that meets our functional needs. We shall list these requirements in the following part.</p><p>In our e-learning game, the non-player characters will need to do the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Travel about the world in a smooth, realistic way</p></li><li style="list-style-type: disc"><p>When approached by the player, the NPC should stop and face the player to interact</p></li><li style="list-style-type: disc"><p>When the player leaves the NPC or finishes the interaction, it should continue moving about the world</p></li></ul></div><p>Based on these requirements, it is clear that we will need a number of states that we can encode in a public enumeration. To prove that the NPC framework works and meets our design needs, we will implement the <code class="literal">patrol</code> and <code class="literal">turnToPlayer</code> states as a minimum viable product for the NPC system. Once these are working, it will be clear that the system works and that the reader can then extend the system with more behaviors:</p><div class="informalexample"><pre class="programlisting">public enum npcState
{
  invalid = -1, //enum to encode error npc state
  none = 0,// enum to encode npc having no state
  idle = 1,// enum encoding npc waiting idly
  patrol = 2,// enum for npc patrolling about
  turnToPlayer = 3,// enum for npc to face player
  InteractWithPlayer = 4,// enum for npc interacting with player
  Celebrate = 5,// enum for npc celebrating
  Disappointed = 6 //enum for npc acting disappointed
};</pre></div><p>Perform the following steps to implement the <code class="literal">npcScript</code> class:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>A private variable of the type <code class="literal">npcState</code>, named <code class="literal">state</code>, will track the value of this enum for each NPC instance:</p><div class="informalexample"><pre class="programlisting">private npcState state; </pre></div></li><li><p>In order for our NPC to be able to follow a parametric curve when patrolling, we give the <code class="literal">npcScript</code> class a <code class="literal">SplineMgr</code> class to interpolate a user-defined path. A public <code class="literal">showPath</code> Boolean is also provided for debugging:</p><div class="informalexample"><pre class="programlisting">public bool showPath;
public SplineMgr path; </pre></div></li><li><p>An instance<a id="id284" class="indexterm"></a> of a data-driven system for detecting scenarios and dispatching responses at runtime is also added to the <code class="literal">npcScript</code> class. This class will act as the brain of the NPC, deciding when to change states based on the state of the game world:</p><div class="informalexample"><pre class="programlisting">public npcDecisionMgr decisionMgr;</pre></div></li><li><p>Each time an in-game NPC is activated, the <code class="literal">start()</code> script will first compute the debug path visualization for the spline and then set the NPC into the <code class="literal">patrol</code> mode so that it will start walking. The <code class="literal">computeDebugPath</code> method will walk through the spline from the start to the end and store a series of line segments that the debug line renderer can use to draw the spline when we need to visualize it. The second line of code sets the NPC into the <code class="literal">patrol</code> state, which tells the NPC to follow the spline path. We will discuss splines later in this chapter:</p><div class="informalexample"><pre class="programlisting">path.computeDebugPath();
SetState(npcState.patrol);</pre></div></li><li><p>The <code class="literal">npcScript</code> class implements a <code class="literal">SetState(newstate s)</code> method to allow the client code to change the state of the NPC. A <code class="literal">switch</code> statement implementation provides a means of specializing one-off code that executes once when the state actually switches. This is how we implement the <code class="literal">OnEnter</code> event for each state in the enumeration.</p></li><li><p>When entering the <code class="literal">patrol</code> state, we set the head of the <code class="literal">SplineMgr</code> class to the NPC GameObject. This permits the <code class="literal">SplineMgr</code> class to attach the NPC to the curve and update its position each frame. We also set the playback mode on the <code class="literal">SplineMgr</code> class to loop so that when the NPC reaches the end of the curve, it will loop back to the start; other modes exhibit different playback behavior along the curve:</p><div class="informalexample"><pre class="programlisting">path.HeadObj = this.gameObject;
path.SetPlaybackMode(splineMgr.ePlaybackMode.loop);</pre></div></li><li><p>When entering the <code class="literal">turnToPlayer</code> state, we set the playback mode of the <code class="literal">SplineMgr</code> class to none. This has the effect of stopping the velocity of the NPC model:</p><div class="informalexample"><pre class="programlisting">path.SetPlaybackMode (SplineMgr.ePlaybackMode.none);</pre></div></li><li><p>The <code class="literal">npcScript</code> class implements an <code class="literal">Update()</code> method, (which all classes that inherit from <code class="literal">MonoBehavior</code> need to implement), which has four logical segments that are computed for each frame.</p></li><li><p>First, the distance from the player and the NPC is calculated. This quantity is stored for later processing:</p><div class="informalexample"><pre class="programlisting">if (player)
{
  Vector3 v = h.transform.position -
    this.transform.position;
  distanceToHero = v.magnitude;
}</pre></div></li><li><p>A <code class="literal">switch</code> statement <a id="id285" class="indexterm"></a>permits specialization of the code that the NPC needs to perform for each frame. In the <code class="literal">patrol</code> state, the NPC looks at the point in front of itself; this is a quantity that the <code class="literal">SplineMgr</code> class conveniently returns for us by evaluating the spline at a point slightly further ahead on the curve than the <code class="literal">HeadObj</code> itself:</p><div class="informalexample"><pre class="programlisting">this.transform.LookAt(path.TargetObj.transform.position);</pre></div></li><li><p>While in the <code class="literal">turnToPlayer</code> state, the NPC looks at the player position:</p><div class="informalexample"><pre class="programlisting">this.transform.LookAt (player.transform.position);</pre></div></li><li><p>If there is a <code class="literal">decisionMgr</code> class instance attached to the NPC, the <code class="literal">npcScript</code> allows it to evaluate all of its conditions for potential dispatch:</p><div class="informalexample"><pre class="programlisting">if (decisionMgr != null)
  decisionMgr.eval (); </pre></div></li><li><p>Lastly, depending on the state of the <code class="literal">showPath</code> Boolean, we either enable or disable the <code class="literal">lineRenderer</code> component for the spline curve:</p><div class="informalexample"><pre class="programlisting">this.GetComponent&lt;LineRenderer&gt;().enabled = showPath;</pre></div></li></ol></div><p>Congratulations! You have just written the <code class="literal">npcScript</code> base framework for a non-player character class. As you can see, the power of this choreography class is derived from the FSM, and the work is delegated to the <code class="literal">DecisionMgr</code> and <code class="literal">SplineMgr</code> classes.</p></div></div>