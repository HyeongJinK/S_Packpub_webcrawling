<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec35"></a>Background tasks and Coroutines</h2></div></div><hr /></div><p>Next up in the fabulous journey of scripting, we will cover the treacherous realm of background tasks. We use the background tasks to start something (in the background) so that it is runs independently of the normal game update and draw cycle.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note49"></a>Note</h3><p>Coroutines, by default, run on the same thread as the normal game loop. If you are not careful, they can stop your game from running. (You can dispatch them on to separate threads in Unity Pro to offset the work in order to improve the performance.)</p><p>For more information on Coroutines and the default execution order of methods, refer to the article in the Unity docs at <a class="ulink" href="https://docs.unity3d.com/Documentation/Manual/ExecutionOrder.html" target="_blank">https://docs.unity3d.com/Documentation/Manual/ExecutionOrder.html</a>.</p></div><p>The following diagram shows that we can have a second process that runs alongside our main game:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_06.jpg" /></div><p>This is usually used for systems that are continually running and not for the main events on the screen, such as AI, a background trading system, or even a continual web-service-gathering data for the game.</p><p>Unity also has the ability to synchronize these background threads with a simple function that pauses the operation (or returns the control back to Unity) until the next frame of the game is drawn (<code class="literal">WaitForEndOfFrame</code> or <code class="literal">WaitForFixedUpdate</code>), which gives you a pattern like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_07.jpg" /></div><p>The benefit of this is that you can wait for the last update or draw cycle to finish before running your process. You might do this if you want to render what is drawn on the screen to an image and either save it to a disk or upload it to a web service or website.</p><p>The Unity documents provide a good example of using this behavior; you can find them at <a class="ulink" href="https://docs.unity3d.com/Documentation/ScriptReference/WaitForEndOfFrame.html" target="_blank">https://docs.unity3d.com/Documentation/ScriptReference/WaitForEndOfFrame.html</a>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec57"></a>Enter Coroutines</h3></div></div></div><p>The proper way to implement long-running tasks in Unity is through the use of a feature called Coroutines. In simple words, Coroutines are Unity's way of launching code in the background, but they do have a few caveats and features around them though.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note50"></a>Note</h3><p>Remember, Coroutines, run on the same thread as the normal game loop and use the same resources as the game loop (albeit at the same time). To enable threading (running processes on separate processors or pipelines, distributing the workload), you will need Unity Pro. Sorry to reiterate this, but it's a very important point to mention.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec58"></a>IEnumerator</h3></div></div></div><p>At their core, Coroutines are just normal methods, but they are implemented using a particular generic interface named <code class="literal">IEnumerator</code> as their return type. This enables Unity to track the method's state through several iterations (runs).</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip31"></a>Tip</h3><p>Don't confuse <code class="literal">IEnumerator</code> with <code class="literal">IEnumerable</code> when defining your Coroutines; otherwise, you will find that they won't work.</p></div><p>To create a basic Coroutine, you simply need to set up the method as shown in the following code:</p><div class="informalexample"><pre class="programlisting">IEnumerator MyCoroutine()
{
  //Do something
  //Then return
  yield return null;

}</pre></div><p>This would create a simple single-use Coroutine that would perform a single function, and when it's finished, it will die and go away.</p><p>A more common pattern is to have a loop of some kind within the function that will not finish until some condition is met; this is done by either using a <code class="literal">while</code> or <code class="literal">for</code> loop as follows:</p><div class="informalexample"><pre class="programlisting">IEnumerator MyCoroutine (){
  bool complete = false;
  while (!complete)
  {
    //Do some repetitive task
    //When done set complete to true

    //Then return control after each step
    yield return null;
  }
}</pre></div><p>The preceding code will simply run in the background until the condition is met; for example, a timer that is counting down should stop when it reaches 0.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec59"></a>Yielding</h3></div></div></div><p>The Coroutines and IEnumerator feature are perfectly valid, but C# added a new operator in Version 2 (Unity now supports V4) called the <code class="literal">yield</code> operator. The <code class="literal">yield</code> operator suspends the current method on the current instruction line until the operation is complete; however, it also allows the CPU to continue in between each result that is returned by the called method or the instruction. The following example will pause the loop for two seconds in between the iterations while retuning the control back to the process.</p><p>Here's an example; say we have a function to print 10 lines:</p><div class="informalexample"><pre class="programlisting">IEnumerator Print10Lines()
{
  for (int i = 0; i &lt; 10; i++)
  {
    print("Line" + i.ToString());
    yield return new WaitForSeconds(2);
  }
}</pre></div><p>When the preceding code runs, it will simply loop 10 times, and each time it will print out the line number. However, before continuing, it will wait for 2 seconds.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note51"></a>Note</h3><p>Do not confuse <code class="literal">IEnumerator</code> with <code class="literal">IEnumerable</code>. Coroutines and the <code class="literal">yield</code> keyword only work in a method that returns an <code class="literal">IEnumerator</code> feature. This is an easy mistake that can leave you scratching your head for hours.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec60"></a>Starting Coroutines</h3></div></div></div><p>There are actually two types of Coroutines (it is best to think of them in that way, even though they are actually the same thing): those that are just launched (<code class="literal">fire</code> and <code class="literal">forget</code>) and those that can be managed. The difference is just in the way they are called. The <code class="literal">fire</code> and <code class="literal">forget</code> Coroutine functions are simply called by using the following code:</p><div class="informalexample"><pre class="programlisting">StartCoroutine(MyCoroutine()); //or
StartCoroutine(MyCoroutine(MyParameter)); //to use parameters</pre></div><p>In the preceding code, the <code class="literal">MyCoroutine</code> function is started using the <code class="literal">delegate</code> method. Once started, it will not finish until either the function ends or <code class="literal">StopAllCoroutines()</code> is called. Now, start the Coroutine using the following code:</p><div class="informalexample"><pre class="programlisting">StartCoroutine("MyCoroutine"); //or 
StartCoroutine("MyCoroutine", myParameter); //to use parameters</pre></div><p>In the preceding code, you specify the name of your Coroutine function and the method's name using a string. This enables you to stop the Coroutine from running anytime (and from anywhere) using the following code:</p><div class="informalexample"><pre class="programlisting">StopCoroutine("MyCoroutine");</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note52"></a>Note</h3><p>Currently, there are some enhancements being made in Unity that will enable you to stop the Coroutines that are called using the method's name. It is not clear yet whether this will be in the 4.x or 5.x timescales. Keep watching!</p></div><p>The invocation path is something to be kept in mind. You might ask why not just use the second method all the time. The answer is simple. Unity has to use slower methods to discover the method it needs to track when you provide the Coroutine's name as a string; just passing the method's name is quicker and smoother. The best advice would be to use each type according to its strengths. Only use the string launch method when you need to manage a background task and use the method names when it is a short-lived function that is solely aimed at accomplishing a single task. For everything else, just weigh up the pros and cons of each approach as you implement it.</p><p>Coroutines can be powerful additions to the arsenal of your game's framework, but they need to be implemented wisely; too many additions to your game (obviously) will just grind to a halt. If you only ever use the <code class="literal">fire</code> and <code class="literal">forget</code> Coroutines, you won't be able to stop them without shutting down all the rest as well (including those you started by naming them as a string).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec61"></a>Closing the gap</h3></div></div></div><p>So now that we understand how we call Coroutines, to make the <code class="literal">Print10Lines</code> method described earlier, we will call it as follows:</p><div class="informalexample"><pre class="programlisting">void Example1()
{
  StartCoroutine(Print10Lines());
  print("I started printing lines");
}</pre></div><p>As explained, the preceding code will kick off the <code class="literal">Print10Lines</code> function and then continue forward while the routing to print the lines continues simultaneously. On the other hand, the following code will print 10 lines, and only after it is finished will it continue and notify you that printing has finished:</p><div class="informalexample"><pre class="programlisting">IEnumerator Example2()
{
  yield return StartCoroutine(Print10Lines());
  print("I have finished printing lines");
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip32"></a>Tip</h3><p>Any method that has a return type of <code class="literal">IEnumerator</code> has to be called using one of the <code class="literal">StartCoroutine</code> methods; just calling any method with <code class="literal">IEnumerator</code> on its own will do nothing. So, keep this in mind if you are wondering why something is not being called.</p></div></div></div>