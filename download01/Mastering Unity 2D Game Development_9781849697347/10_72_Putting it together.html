<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec67"></a>Putting it together</h2></div></div><hr /></div><p>Following on from the previous chapter, we will continue on our journey of the battle and kick off with some target practice.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec123"></a>Preparing the BattleManager script</h3></div></div></div><p>As we<a id="id868" class="indexterm"></a> prepare to attack our foe, we recognize that the player can only target one Goblin at a time with his trusty sword or axe (there could be some splash damage or knock - on attack later, but let's focus on our player's attack first). So, we'll add some variables to <code class="literal">BattleManager</code> to manage this.</p><p>We will also add some other elements to spruce up the battle, such as a selection circle or a target identifier, and add a variable to set a prefab for this.</p><p>So, open the <code class="literal">BattleManager</code> script and add the following variables to the top of the class:</p><div class="informalexample"><pre class="programlisting">private string selectedTargetName;
private EnemyController selectedTarget;
public GameObject selectionCircle;
private bool canSelectEnemy;

bool attacking = false;

public bool CanSelectEnemy
{
  get
  {
    return canSelectEnemy;
  }
}

public int EnemyCount
{
  get
  {
    return enemyCount;
  }
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note120"></a>Note</h3><p>We haven't created the <code class="literal">EnemyController</code> class yet, so it will show as an error. We will add that next.</p></div><p>So, we<a id="id869" class="indexterm"></a> have added properties to hold the selected target as we did with the selected weapon, a flag, and a property to track whether we can actually select an enemy (as the player needs to select a weapon first); additionally, we've added a variable to maintain a record of just how many enemies are left in the battle, which the enemy AI will use to decide how chicken they are or not.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip73"></a>Tip</h3><p>Instantiating prefabs in the code requires the prefab to be in the <code class="literal">Resources</code> folder, because they are associated with the asset-bundling features. With Unity Pro, you can also download the asset bundles from the Web and include them in your project at runtime. With the free version, however, you can only use what is in your project already.</p><p>For single objects, it's easier to attach a prefab to the editor and use it from there (either on an existing class or a static editor class).</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec124"></a>Beefing up the enemy</h3></div></div></div><p>At the<a id="id870" class="indexterm"></a> moment, <code class="literal">Goblin</code> is just a sprite drawn on the screen with an AI system that just sits idle in the background. So, let's expand on this and give our Goblins some muscle power. Player, be warned!</p><p>As stated previously, to keep the player engaged, you need to have a varied amount of enemies in <a id="id871" class="indexterm"></a>the battle, and they need to be challenging enough to make the player think and apply tactics.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec59"></a>The enemy profile/controller</h4></div></div></div><p>First, we'll <a id="id872" class="indexterm"></a>create a new profile for the enemies, starting off with a<a id="id873" class="indexterm"></a> new enumeration for the enemy class. Create a <a id="id874" class="indexterm"></a>new C# script named <code class="literal">EnemyClass</code> in <code class="literal">Assets\Scripts\Classes</code> and<a id="id875" class="indexterm"></a> replace its contents with the following code:</p><div class="informalexample"><pre class="programlisting">public enum EnemyClass
{
  Goblin,
  Ork,
  NastyPeiceOfWork
}</pre></div><p>I've used just a couple of examples, as we will only be using the <code class="literal">Goblin</code> for now. Next, create a new <code class="literal">Enemy</code> C# script in the same folder, as follows:</p><div class="informalexample"><pre class="programlisting">public class Enemy : Entity
{

  public EnemyClass Class;
}</pre></div><p>The preceding code just extends the base <code class="literal">Entity</code> class for our enemies and adds the <code class="literal">EnemyClass</code> enumeration we just created.</p><p>Now that we have a profile for the enemy, we need a controller to make the enemy perform actions in a controlled way. So, create another C# script named <code class="literal">EnemyController</code> in <code class="literal">Assets\Scripts</code>, starting with the following variables:</p><div class="informalexample"><pre class="programlisting">using System.Collections;
using UnityEngine;

public class EnemyController : MonoBehaviour {

  private BattleManager battleManager;
  public Enemy EnemyProfile;
  Animator enemyAI;

  public BattleManager BattleManager
  {
    get
      {
        return battleManager;
      }
      set
      {
        battleManager = value;
      }
  }
}</pre></div><p>The <a id="id876" class="indexterm"></a>preceding code gives us the missing <code class="literal">EnemyController</code> class that we used in the <code class="literal">BattleManager</code> script with the following properties:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A tight <a id="id877" class="indexterm"></a>reference to the <code class="literal">BattleManager</code> script, which is needed because the enemies are directly affected by the battle as it is <a id="id878" class="indexterm"></a>ensued</p></li><li style="list-style-type: disc"><p>The <a id="id879" class="indexterm"></a>enemy profile</p></li><li style="list-style-type: disc"><p>A reference to the AI animator controller we created in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Encountering Enemies and Running Away</em></span></p></li></ul></div><p>As the AI needs information about the battle, we need to ensure that it has kept each frame up to date. So, for this, we add an <code class="literal">UpdateAI</code> method and call it from the <code class="literal">Update</code> method to keep the AI up to date, as follows:</p><div class="informalexample"><pre class="programlisting">void Update()
{
  UpdateAI();
}

public void UpdateAI()
{
  if (enemyAI != null &amp;&amp; EnemyProfile != null)
  {
    enemyAI.SetInteger("EnemyHealth", EnemyProfile.Health);
    enemyAI.SetInteger("PlayerHealth", GameState.CurrentPlayer.Health);
    enemyAI.SetInteger("EnemiesInBattle", battleManager.EnemyCount);
  }
}</pre></div><p>The preceding code just sets the properties of the AI to the current values. As the values change, the AI will react based on the transitions that are defined. For example, if the Goblin's health <a id="id880" class="indexterm"></a>drops below <code class="literal">2</code> and the player's health is greater <a id="id881" class="indexterm"></a>than <code class="literal">2</code>, it will transition to <code class="literal">Run Away</code>. Granted we are <a id="id882" class="indexterm"></a>not doing anything with the states yet, but we will come <a id="id883" class="indexterm"></a>on to that later.</p><p>Next, we need to grab the reference to the AI that is currently configured against the game object that will be used by the previous <code class="literal">UpdateAI</code> function in the <code class="literal">Awake</code> method:</p><div class="informalexample"><pre class="programlisting">void Awake()
{
  enemyAI = GetComponent&lt;Animator&gt;();
  if (enemyAI == null)
  {
    Debug.LogError("No AI System Found");
  }
}</pre></div><p>There are several logging options in Unity, from the basic <code class="literal">Log</code> to the more detailed <code class="literal">LogWarning</code> and <code class="literal">LogError</code>. These logging options provide us with more detail while debugging our project, so use them wisely.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip74"></a>Tip</h3><p>To save sanity when you are adding more content to the game, it is worthwhile to add <code class="literal">Debug</code> comments, surrounding them with important components or scripts required by an object. Using them this way does not affect the performance and can save you hours of searching for the reason for a crash because you forgot to add something.</p><p>However, as stated before, do not use <code class="literal">Debug.Log</code> extensively or in the normal operation of your game. This is because it kills the performance!</p><p>Another approach is to write your own utility function to perform logging, which can be controlled by a single flag. So, instead of <code class="literal">Debug.Log</code>, you will call <code class="literal">DebugUtility.Log</code> or <code class="literal">DebugUtility.LogWarning</code>, which will then call <code class="literal">Debug.Log</code> if it was enabled. This allows you to place the logging code throughout your project and have a single place where you can turn it all on or off.</p><p>Nice tip from our reviewer, Fredrik Kellerman!</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec60"></a>Updating the Goblin prefab</h4></div></div></div><p>The <span class="strong"><strong>Goblin</strong></span> prefab we created earlier now needs this new <code class="literal">EnemyController</code> class attached<a id="id884" class="indexterm"></a> to it. Select the <span class="strong"><strong>Goblin</strong></span> prefab from <code class="literal">Assets\Prefabs\Characters</code>, click on the <span class="strong"><strong>Add Component</strong></span> button in the <span class="strong"><strong>Inspector</strong></span> window, and <a id="id885" class="indexterm"></a>navigate to <span class="strong"><strong>Scripts</strong></span> | <span class="strong"><strong>EnemyController</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_06.jpg" /></div><p>Once added, the updated <span class="strong"><strong>Goblin</strong></span> will look like the following screenshot in the <span class="strong"><strong>Inspector</strong></span> window:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_07.jpg" /></div><p>As you<a id="id886" class="indexterm"></a> can see, we cannot currently edit the <span class="strong"><strong>Enemy Profile</strong></span> tab from the editor (as this requires a custom inspector, which will be covered in <a class="link" href="#" linkend="ch11">Chapter 11</a>, <span class="emphasis"><em>Onward Wary Traveler</em></span>). Hence, we are doing it through the code. You can <a id="id887" class="indexterm"></a>use a scriptable object asset and assign it to the tab, and I've already shown you how to do this. Feel free to change it later if you wish.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec61"></a>Setting up the enemy profile in the code</h4></div></div></div><p>Returning<a id="id888" class="indexterm"></a> back to the <code class="literal">BattleManager</code> script, the area<a id="id889" class="indexterm"></a> where we push our Goblins into action is<a id="id890" class="indexterm"></a> in the <code class="literal">SpawnEnemies</code> coroutine. Now, instead of just throwing sprites at the screen, we can add some real danger to the mix for our humble player and his itty-bitty sword using the following code:</p><div class="informalexample"><pre class="programlisting">IEnumerator SpawnEnemies()
{
  //Spawn enemies in over time
  for (int i = 0; i &lt; enemyCount; i++)
  {
    var newEnemy = (GameObject)Instantiate(EnemyPrefabs[0]);
    newEnemy.transform.position = new Vector3(10, -1, 0);
    yield return StartCoroutine(
    MoveCharacterToPoint(EnemySpawnPoints[i], newEnemy));
    newEnemy.transform.parent = EnemySpawnPoints[i].transform;

<span class="strong"><strong>    var controller = newEnemy.GetComponent&lt;EnemyController&gt;();</strong></span>

<span class="strong"><strong>    controller.BattleManager = this;</strong></span>

<span class="strong"><strong>    var EnemyProfile = ScriptableObject.CreateInstance&lt;Enemy&gt;();</strong></span>
<span class="strong"><strong>    EnemyProfile.Class = EnemyClass.Goblin;</strong></span>
<span class="strong"><strong>    EnemyProfile.Level = 1;</strong></span>
<span class="strong"><strong>    EnemyProfile.Damage = 1;</strong></span>
<span class="strong"><strong>    EnemyProfile.Health = 2;</strong></span>
<span class="strong"><strong>    EnemyProfile.Name = EnemyProfile.Class + " " + i.ToString();</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>    controller.EnemyProfile = EnemyProfile;</strong></span>
  }
  BattleStateManager.SetBool("BattleReady", true);
}</pre></div><p>Now, as<a id="id891" class="indexterm"></a> we loop through the number of enemies<a id="id892" class="indexterm"></a> being added to the battle, we grab the <code class="literal">EnemyController</code> class attached to the <span class="strong"><strong>Goblin</strong></span> prefab, create a new <code class="literal">EnemyProfile</code> class, give <a id="id893" class="indexterm"></a>it some values, and finally initialize the controller with the new <code class="literal">EnemyProfile</code> class.</p><p>Ideally, you should change this generation to something that is a bit more structured instead of just initializing it this way, but you should get the picture.</p><p>Now that we have a stronger opponent, let's select it and start with the attack.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec125"></a>Selecting a target</h3></div></div></div><p>Like <a id="id894" class="indexterm"></a>with <code class="literal">CommandBar</code>, the player needs some visual representation to confirm whether their actions actually have an effect in the game. To this end, let's add some selection logic for our enemies and a nice visual effect in 2D. First, we'll create the prefab for this with a little animation and then get ready to attach our <code class="literal">BattleManager</code> script<a id="id895" class="indexterm"></a> using the variable we added earlier.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec62"></a>The selection circle prefab</h4></div></div></div><p>First <a id="id896" class="indexterm"></a>off, I created the following selection circle <a id="id897" class="indexterm"></a>with my graphics skills (aka programmer art :D ):</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_08.jpg" /></div><p>This is nothing fancy, but it will look better once we get it in the game. So, add <code class="literal">SelectionCircle.png</code> to your project from the assets that accompany this title to <code class="literal">Assets\Sprites\Props</code>.</p><p>Next, we'll create a prefab of this sprite in our scene for later use. This simply sets up how we want to use it visually, and since we are going to use it several times over in the scene, using prefabs means that there will only be one instance with many copies.</p><p>Now, drag the <code class="literal">SelectionCircle</code> image on to the scene (if it doesn't work, you are looking at the game view, which means that you need to switch to the <span class="strong"><strong>Scene</strong></span> tab) and set the properties as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_09.jpg" /></div><p>Finally, drag<a id="id898" class="indexterm"></a> the object from the <span class="strong"><strong>Scene</strong></span> hierarchy<a id="id899" class="indexterm"></a> into <code class="literal">Assets\Prefabs\Props</code> to create the prefab, ensuring its name is <code class="literal">SelectionCircle</code>. Then, delete the object from the scene as we no longer need it.</p><p>Now, in the <span class="strong"><strong>Battle</strong></span> scene, in the editor, select the <span class="strong"><strong>BattleManager</strong></span> game object in the <span class="strong"><strong>Project</strong></span> hierarchy; once you do this, drag the <code class="literal">SelectionCircle</code> prefab on to the <span class="strong"><strong>Selection Circle</strong></span> property for the <code class="literal">BattleManager</code> script to attach it to the <span class="strong"><strong>BattleManager</strong></span> game object.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec63"></a>Adding selection logic to the EnemyController class</h4></div></div></div><p>With<a id="id900" class="indexterm"></a> everything set up in the <a id="id901" class="indexterm"></a>
<span class="strong"><strong>BattleManager</strong></span> game object, we <a id="id902" class="indexterm"></a>can now return to the <code class="literal">EnemyController</code> script and repeat the process we used with <code class="literal">CommandButton</code> so the player can click on the Goblins to highlight them.</p><p>First, we need a couple of properties in the <code class="literal">EnemyController</code> script to keep a reference to our <code class="literal">SelectionCircle</code> prefab and determine whether the current enemy is selected or not. So, add the following to the top of the <code class="literal">EnemyController</code> class:</p><div class="informalexample"><pre class="programlisting">  private bool selected;
  GameObject selectionCircle;</pre></div><p>Now, to liven the selection process a bit, let's add some spin to the selection circle when it is<a id="id903" class="indexterm"></a> on the screen. To do this, we'll <a id="id904" class="indexterm"></a>add a simple coroutine to <a id="id905" class="indexterm"></a>constantly update the selection circles' rotation transform (simple and effective). We could have used the 2D animation system to do the same thing, but it's a bit too much for a simple rotation (unless you want to do more fancy things with the selection circle, such as add particles, have the circle jump up and down while spinning, and so on).</p><p>So, in the <code class="literal">EnemyController</code> script, add the following coroutine function:</p><div class="informalexample"><pre class="programlisting">IEnumerator SpinObject(GameObject target)
{
  while (true)
  {
    target.transform.Rotate(0, 0, 180 * Time.deltaTime);
    yield return null;
  }
}</pre></div><p>Nothing fancy; you just need to rotate the object on its <span class="emphasis"><em>z</em></span> axis over time.</p><p>If you want the circle to spin faster or slower, just alter the amount of <span class="emphasis"><em>z</em></span> axis rotation you apply. Here, I have it set to spin 180 degrees every second, one full spin every 2 seconds.</p><p>Next, when the player clicks, we use the combination of the <code class="literal">BoxCollider2D</code> and <code class="literal">OnMouseDown</code> functions to select the Goblin and display the selection circle.</p><p>Add a new <code class="literal">BoxCollider2D</code> component to the <span class="strong"><strong>Goblin</strong></span> prefab and then add the following function to the <code class="literal">EnemyController</code> script:</p><div class="informalexample"><pre class="programlisting">void OnMouseDown()
{
  if (battleManager.CanSelectEnemy)
  {
    var selection = !selected;
    battleManager.ClearSelectedEnemy();
    selected = selection;
    if (selected)
    {
      selectionCircle = (GameObject)GameObject.Instantiate(battleManager.selectionCircle);
      selectionCircle.transform.parent = transform;

      selectionCircle.transform.localPosition = Vector3.zero;
      StartCoroutine("SpinObject", selectionCircle);
      battleManager.SelectEnemy(this, EnemyProfile.Name);
    }
  }
}</pre></div><p>Here, we store what the current state of the selected Goblin is (if we click on the same one <a id="id906" class="indexterm"></a>twice, unselect it); make sure <a id="id907" class="indexterm"></a>there are no other Goblins <a id="id908" class="indexterm"></a>selected (you may want to change this behavior if you have weapons that can target more than one enemy). If it is a new selection, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a clone of the <code class="literal">SelectionCircle</code> prefab.</p></li><li><p>Set its transform and position local to the selected Goblin.</p></li><li><p>Start <code class="literal">SelectionCircle</code>, spinning with its coroutine.</p></li><li><p>Tell the <span class="strong"><strong>BattleManager</strong></span> game object that we have selected a target to destroy.</p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note121"></a>Note</h3><p>The new functions don't exist on the <code class="literal">BattleManager</code> script yet, so we will return to those shortly.</p></div><p>Like with <code class="literal">CommandButtons</code>, we need a final function to clear the selection state of this enemy if required, so add the <code class="literal">ClearSelection</code> method to the <code class="literal">EnemyController</code> script, as follows:</p><div class="informalexample"><pre class="programlisting">public void ClearSelection()
{
  if (selected)
  {
    selected = false;
    if (selectionCircle != null) 
    DestroyObject(selectionCircle);
    StopCoroutine("SpinObject");
  }
}</pre></div><p>We are done with the <code class="literal">EnemyController</code> script now.</p><p>To finish off the selection logic, let's return to the <code class="literal">BattleManager</code> script and add the two missing functions as follows:</p><div class="informalexample"><pre class="programlisting">public void SelectEnemy(EnemyController enemy, string name)
{
  selectedTarget = enemy;
  selectedTargetName = name;
}

public void ClearSelectedEnemy()
{
  if (selectedTarget != null)
  {
    var enemyController = selectedTarget.GetComponent&lt;EnemyController&gt;();
    enemyController.ClearSelection();
    selectedTarget = null;
    selectedTargetName = string.Empty;
  }
}</pre></div><p>Both<a id="id909" class="indexterm"></a> the functions are very<a id="id910" class="indexterm"></a> simple. They either set the two<a id="id911" class="indexterm"></a> variables we created earlier for the <code class="literal">selectedTarget</code> and the <code class="literal">selectedTargetName</code> variables, or clear these values, get the <code class="literal">EnemyController</code> component for the selected target, and use the <code class="literal">ClearSelection</code> function we just added.</p><p>However, we still can't select the enemy to attack yet, as our <code class="literal">BattleManager</code> script does not let us do it. Since we want to control the flow of what the player does, we do not enable this until they have first selected a weapon; if there is no selected weapon, there is no enemy selection.</p><p>To enable you to select an enemy and then progress on to the battle, we need to update our <code class="literal">OnGUI</code> method again for the additional actions. So, alter the <code class="literal">case BattleState.Player_Move</code> section of the <code class="literal">OnGUI</code> method as follows:</p><div class="informalexample"><pre class="programlisting">case BattleState.Player_Move:
if (GUI.Button(new Rect(10, 10, 100, 50), "Run Away"))
{
  GameState.PlayerReturningHome = true;
  NavigationManager.NavigateTo("World");
}
if (selectedWeapon == null)
{
  GUI.Box(new Rect((Screen.width / 2) - 50,10,100,50),"Select Weapon");
}
<span class="strong"><strong>else if (selectedTarget == null)</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  GUI.Box(new Rect((Screen.width / 2) - 50, 10, 100, 50), "Select Target");</strong></span>
<span class="strong"><strong>  canSelectEnemy = true;</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>else</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  if (GUI.Button(new Rect((Screen.width / 2) - 50, 10, 100, 50), "Attack " + selectedTargetName))</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    canSelectEnemy = false;</strong></span>
<span class="strong"><strong>    battleStateManager.SetBool("PlayerReady", true);</strong></span>
<span class="strong"><strong>    MessagingManager.Instance.BroadcastUIEvent(true);</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
break;</pre></div><p>Now the<a id="id912" class="indexterm"></a> battle can ensue. The player<a id="id913" class="indexterm"></a> selects a weapon and a<a id="id914" class="indexterm"></a> target, and they have a nice (well, a nice GUI) button to tap to say they are happy with their choice. So, let the battle commence.</p><p>We also inform anyone listening to the GUI events that the GUI is now locked, and the player cannot do anything until it is their turn again.</p><p>Now, when you run the project, the flow of the battle will be as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The battle begins.</p></li><li><p>The introduction is played, informing the player about the impending doom.</p></li><li><p>The player is asked to select a weapon.</p></li><li><p>The selected weapon is highlighted.</p></li><li><p>The player is asked to select a target.</p></li><li><p>The selected enemy gets the red ring of death circling their feet, and they probably get a sense of foreboding.</p></li><li><p>The <code class="literal">Battle</code> state manager gets informed that the player has completed their move <a id="id915" class="indexterm"></a>and that they are<a id="id916" class="indexterm"></a> ready by setting<a id="id917" class="indexterm"></a> the <code class="literal">PlayerReady</code> property in the state machine to <code class="literal">true</code>.</p></li></ol></div><p>So, when you run the project, your scene should look like this:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_11.jpg" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec126"></a>Attack! Attack!</h3></div></div></div><p>Now that the<a id="id918" class="indexterm"></a> player has committed themselves into the fray, we can play through their selected action. For now, this is just a single action, but if you have more characters/moves, then this could be extended further.</p><p>As the attack is a loop that is played until the player (or his party) runs out of attacks, we use a simple coroutine to perform the attack itself. So, let's add the following function to the <code class="literal">BattleManager</code> script:</p><div class="informalexample"><pre class="programlisting">IEnumerator AttackTarget()
{
  int Attacks = 0;
  attacking = true;
  bool attackComplete = false;
  while (!attackComplete)
  {
    GameState.CurrentPlayer.Attack(selectedTarget.EnemyProfile);
    selectedTarget.UpdateAI();
    Attacks++;
    if (selectedTarget.EnemyProfile.Health &lt; 1 || Attacks &gt; GameState.CurrentPlayer.NoOfAttacks)
    {
      attackComplete = true;
    }
    yield return new WaitForSeconds(1);
  }
}</pre></div><p>The following<a id="id919" class="indexterm"></a> is what the previous code is doing:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>It sets the initial states for the battle. It tells us how many attacks have been performed, the fact that we are attacking (disable non-attacking code such as the GUI), and that the attack has not yet finished.</p></li><li><p>Then, until we are finished, we keep attacking:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>We call the <code class="literal">Attack</code> function for the player against the selected enemy (this was defined in the <code class="literal">Entity</code> class; all the attacks are standard, so if you want to modify them, ensure they are done correctly in the class so that all the attacks are the same)</p></li><li style="list-style-type: disc"><p>We update the AI state for the selected enemy (let them have access to bad news, if any)</p></li></ul></div></li><li><p>If the enemy is dead or the player has run out of attacks, mark the battle as complete.</p></li><li><p>Wait for the end of the frame to attack again or end the loop.</p></li></ol></div><p>It's all very neat logic and central in one place. If you are unsure about what is happening in a battle, then you only have one place to check (unless it's about damage).</p><p>All that is left is to call this function now when the player clicks on the Attack button in the <code class="literal">Update</code> method of the <span class="strong"><strong>BattleManager</strong></span> game object. So, update the <code class="literal">case BattleState.Player_Attack</code> section as follows:</p><div class="informalexample"><pre class="programlisting">case BattleState.Player_Attack:
<span class="strong"><strong>  if (!attacking)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    StartCoroutine(AttackTarget());</strong></span>
<span class="strong"><strong>  }</strong></span>
  break;</pre></div><p>Now that the attack <a id="id920" class="indexterm"></a>has commenced and no doubt some Goblins were at least hurt in the ensuing battle, let us provide the player with some visual feedback.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec127"></a>The pesky Goblin reacts with 3D particles</h3></div></div></div><p>The player has made his or her move, and the Goblin has been affected in some way; it would be nice to see what happened.</p><p>In this<a id="id921" class="indexterm"></a> case, the player's sword (or axe, if you added the axe) has a damage level of <code class="literal">5</code> and the player's strength is only <code class="literal">1</code>; however, this will still give him a total attack damage of <code class="literal">6</code>. The lazy Goblin didn't get any armor today while he was out pillaging in the woods with his pals (unless he's alone and they ditched him), and his default health is of <code class="literal">1</code>. The formula for this is as follows:</p><p><span class="emphasis"><em>Health 1 – Attack Strength 6 = dead</em></span></p><p>So, the poor Goblin has to go and meet his maker in the worst way possible. This brings us to one of the last troublesome issues with the new 2D system, that is, particles. To make the death animation nice, we are going to add a particle effect when the Goblin is killed along with some other animation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec64"></a>Mixing up 2D and 3D</h4></div></div></div><p>Now, as<a id="id922" class="indexterm"></a> all of the 2D rendering in Unity is <a id="id923" class="indexterm"></a>actually performed in 3D with some nice jazzy helpers<a id="id924" class="indexterm"></a> to make it look seamless, it is possible to add 3D objects to your 2D scenes. This is possible, provided you still follow the normal pattern to balance the performance in your scene; a large 2D scene that performs well is still going to have its performance slaughtered if you throw lots of complex 3D models in the background. It is no different than 3D in that respect.</p><p>However, what you do have to be content with is the drawing order (a good old z buffer fighting <a id="id925" class="indexterm"></a>for its return) of 3D elements in the scene as if they were <a id="id926" class="indexterm"></a>2D. The area that is most <a id="id927" class="indexterm"></a>impacted<a id="id928" class="indexterm"></a> by this are <span class="strong"><strong>particle effects</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec65"></a>Particle effects and 2D</h4></div></div></div><p>Like <a id="id929" class="indexterm"></a>other 3D elements, particle<a id="id930" class="indexterm"></a> effects will work fine in a 2D scene, provided <a id="id931" class="indexterm"></a>you set them up correctly. To show this, we are going to define a new particle effect to use in our Goblin's death scene. We will also add a new sprite to mark the Goblin's demise and leave its mark on the world.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note122"></a>Note</h3><p>Surprisingly, however, unlike the GUI system, particles can understand sprites. So, we don't need to mess with the texture import settings when using sprites for particle effects.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec66"></a>Adding the deathly sprites</h4></div></div></div><p>In <a id="id932" class="indexterm"></a>the <code class="literal">Sample</code> assets folder, you will <a id="id933" class="indexterm"></a>find the following two sprites:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_10.jpg" /></div><p>Now perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add<a id="id934" class="indexterm"></a> the blood splat to <code class="literal">Assets\Sprites\FX</code>.</p></li><li><p>Add the<a id="id935" class="indexterm"></a> tombstone to <code class="literal">Assets\Sprites\Props</code> and set its <span class="strong"><strong>Pivot</strong></span> field to <span class="strong"><strong>Bottom</strong></span> so that it is the same as all the Character sprites.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec67"></a>Creating the material for the particle effect</h4></div></div></div><p>For<a id="id936" class="indexterm"></a> particle effects to <a id="id937" class="indexterm"></a>work, they need a material defined, not just the raw <a id="id938" class="indexterm"></a>texture/sprite itself. So, navigate to <code class="literal">Assets\Materials</code> (create it if you haven't done so already) and right-click on it to create a new material and name it <code class="literal">BloodSplatter</code>.</p><p>Next, click on the <span class="strong"><strong>Select</strong></span> button on the material properties in the <span class="strong"><strong>Inspector</strong></span> window for the new <code class="literal">BloodSplatter</code> material and select the <code class="literal">bloodSplat.png</code> image we just imported.</p><p>Lastly, change the shader the material uses to the <span class="strong"><strong>Transparent/Diffuse</strong></span> shader (this is because our sprite has transparent sections. If we didn't use a shader that supports transparency, any section that is transparent would be drawn in black) by clicking on the dropdown next to the <span class="strong"><strong>Shader</strong></span> property of the <code class="literal">BloodSplatter</code> material, and then navigate to <span class="strong"><strong>Transparent</strong></span> | <span class="strong"><strong>Diffuse</strong></span>.</p><p>Your material should now look like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_12.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec68"></a>Restructuring the Goblin prefab</h4></div></div></div><p>Now,<a id="id939" class="indexterm"></a> because of the way the 2D <a id="id940" class="indexterm"></a>animation system works, animating child objects from a parent is fine; animating the child of child objects does not work, and also animating both the parent and the child does not work as well. Basically, the transforms and parentage do not play nice together.</p><p>This isn't a big issue; it just means you need to plan ahead more when you create objects that will have multiple sprites or supporting objects that will all interact on the same animation.</p><p>To start off, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new and empty game object in the scene called <code class="literal">GoblinEnemy</code>.</p></li><li><p>Drag the existing <span class="strong"><strong>Goblin</strong></span> prefab from <code class="literal">Assets\Prefabs\Characters</code> on to the scene as a child of the new and empty game object (so we can reuse it); be sure to reset the transform on the new child.</p></li><li><p>Delete the old prefab; we don't need it any more.</p></li><li><p>Remove the <code class="literal">Animator</code>, <code class="literal">EnemyController</code>, and <code class="literal">Box Collider 2D</code> scripts from the old <span class="strong"><strong>Goblin</strong></span> prefab and add them on to the new and empty game object called <code class="literal">GoblinEnemy</code>, setting them up as before. There are some components you can drag between game objects; then, there are others that you need to remove and re-add manually. It's trial and error to see which components support this behavior. In this instance, the <code class="literal">EnemyController</code> script can be dragged over. Now, you should be left with just the sprite renderer on the Goblin game object.</p></li><li><p>Check that <code class="literal">Box Collider 2D</code> on the <span class="strong"><strong>GoblinEnemy</strong></span> game object is positioned over the Goblin, adjusting the <span class="strong"><strong>Center X &amp; Y</strong></span> values.</p></li><li><p>Drag the <span class="strong"><strong>Tombstone</strong></span> sprite from <code class="literal">Assets\Sprites\Props</code> on to the <code class="literal">GoblinEnemy</code> game object. Set its position transform to <span class="strong"><strong>0</strong></span> for all the values, set <span class="strong"><strong>Scale transform</strong></span> where <span class="strong"><strong>X</strong></span> is <span class="strong"><strong>0.2</strong></span> and <span class="strong"><strong>Y</strong></span> is <span class="strong"><strong>0.2</strong></span>, and set <span class="strong"><strong>Sorting Layer</strong></span> to <code class="literal">Player</code>.</p></li><li><p>Set the color of the Tombstone SpriteRenderer where <span class="strong"><strong>A</strong></span> (alpha) is <span class="strong"><strong>0</strong></span> (click on the color box and reduce the <span class="strong"><strong>A</strong></span> scale to <span class="strong"><strong>0</strong></span>); we don't want to see it by default.</p></li><li><p>Create another empty game object and call it <code class="literal">BloodParticles</code>, then drag it to the <code class="literal">GoblinEnemy</code> game object as a child. Make sure to also set its position transform to <span class="strong"><strong>0</strong></span> for all the values.</p></li></ol></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip75"></a>Tip</h3><p>If you are using Unity 4.5, you can create child game objects quicker by selecting the <code class="literal">GoblinEnemy</code> game object, the <span class="strong"><strong>Create Empty Child</strong></span> option under <span class="strong"><strong>GameObject</strong></span>, or the hotkey <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>N</em></span>.</p></div><p>This gives a nice new framework for the life cycle of the Goblin's enemy; it also allows you to use the same layout but switch out the particles you use in death scenes or the marker<a id="id941" class="indexterm"></a> that they leave behind <a id="id942" class="indexterm"></a>in death.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec69"></a>Adding the particles</h4></div></div></div><p>Now on <a id="id943" class="indexterm"></a>to the crux of this section. Select<a id="id944" class="indexterm"></a> the <span class="strong"><strong>BloodParticles</strong></span> game object and add a new particle system by clicking on <span class="strong"><strong>Add Component</strong></span> and selecting <span class="strong"><strong>Particle System</strong></span> under <span class="strong"><strong>Effects</strong></span>.</p><p>Straightaway, we can see a problem.</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_13.jpg" /></div><p>When the particles render, by default, they are always rendered behind the 2D view, and no setting in the editor, by default, can change that for 3D renderers. It is only available for a 2D sprite renderer.</p><p>To resolve this, we need to apply a script to either the particle system itself or when we play the particle system in the code. For simplicity's sake, I've implemented it as a script on the particle system; this way, it is always in effect, and I do not need to worry about configuring it.</p><p>So, create a new script called <code class="literal">ParticleSortingLayer</code> in <code class="literal">Assets\Scripts</code> and replace its contents with the following:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

[ExecuteInEditMode]
public class ParticleSortingLayer : MonoBehaviour
{

  void Awake()
  {
    var particleRenderer = GetComponent&lt;Renderer&gt;();
    particleRenderer.sortingLayerName = "GUI";
  }
}</pre></div><p>Here, the<a id="id945" class="indexterm"></a> script simply sets the sorting layer on<a id="id946" class="indexterm"></a> the underlying renderer for the particle system; in this case, I've hardcoded it to the GUI sprite layer.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note123"></a>Note</h3><p>The <code class="literal">[ExecuteinEditMode]</code> attribute just enables you to see the effect in the editor <a id="id947" class="indexterm"></a>as well. More on editor functionality is covered in <a class="link" href="#" linkend="ch11">Chapter 11</a>, <span class="emphasis"><em>Onward Wary Traveler</em></span>.</p></div><p>Script libraries, such as the awesome <span class="strong"><strong>UnityToolbag</strong></span> by Nick Gravelyn, also provide the previous functionality <a id="id948" class="indexterm"></a>and are worked into a more reusable script; it's well worth checking it out at <a class="ulink" href="https://github.com/nickgravelyn/UnityToolbag" target="_blank">https://github.com/nickgravelyn/UnityToolbag</a>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip76"></a>Tip</h3><p>Another<a id="id949" class="indexterm"></a> one of these libraries will also expose the hidden <code class="literal">SortingLayer</code> properties for 3D renderers in the editor. For more information, you can read about it at <a class="ulink" href="https://github.com/nickgravelyn/UnityToolbag/tree/master/SortingLayer" target="_blank">https://github.com/nickgravelyn/UnityToolbag/tree/master/SortingLayer</a>.</p></div><p>Now just attach this script to the particle system and it will be transformed into what is shown in the following screenshot, with the particles now in front of the background:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_15.jpg" /></div><p>Now that <a id="id950" class="indexterm"></a>we have our particle system working <a id="id951" class="indexterm"></a>and rendering, we can configure it for the game. The following are all the settings we need to change:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Name</strong></span>: <code class="literal">BloodParticles</code></p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Rotation</strong></span>: <code class="literal">X: -90</code></p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Duration</strong></span>: <code class="literal">1.00</code></p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Looping</strong></span>: <code class="literal">false</code> (unchecked)</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Start lifetime</strong></span>: <code class="literal">0.5</code></p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Speed</strong></span>: <code class="literal">2 / 3</code> (random between two constants)</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Start Rotation</strong></span>: <code class="literal">10 / 50</code> (random between two constants)</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Gravity Multiplier</strong></span>: <code class="literal">0.5</code></p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Inherit Velocity</strong></span>: <code class="literal">200</code></p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Play On Awake</strong></span>: <code class="literal">false</code> (unchecked)</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Shape</strong></span>: <code class="literal">Radius: 0.2</code></p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Color Over Lifetime</strong></span>: <code class="literal">Gradient – Alpha (v) 255 -&gt; 0</code></p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Size over Lifetime</strong></span>: <code class="literal">progressive curve</code></p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Renderer</strong></span>: <code class="literal">Material: BloodSplatter material</code></p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note124"></a>Note</h3><p>To change a value to an alternate setting, such as <span class="strong"><strong>Random Between Two Constants</strong></span>, use the drop-down button to the right of the property:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_16.jpg" /></div></div><p>The curve <a id="id952" class="indexterm"></a>editor appears at the bottom<a id="id953" class="indexterm"></a> of the particle editor inspector.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip77"></a>Tip</h3><p>Check the sample project in the <code class="literal">Chapter9-10</code> folder for what the completed particle system looks like in the <span class="strong"><strong>Inspector</strong></span> window.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec70"></a>The death animation</h4></div></div></div><p>Now<a id="id954" class="indexterm"></a> that we have all the parts constructed<a id="id955" class="indexterm"></a> for our live Goblin and some extra bits for his death, let's create a new <code class="literal">GoblinDeath</code> animation and add it to our Goblin's AI.</p><p>With our new <code class="literal">GoblinEnemy</code> structure in the <span class="strong"><strong>Project</strong></span> hierarchy, select it and bring up the <span class="strong"><strong>Animation</strong></span> tab (<span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Animation</strong></span> in the menu). Then, click on the <span class="strong"><strong>Clip</strong></span> dropdown and select <span class="strong"><strong>[Create New Clip]</strong></span>. When prompted, save the new animation in <code class="literal">Assets\Animation\Clips</code> and call it <code class="literal">GoblinDeath</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip78"></a>Tip</h3><p>If the <span class="strong"><strong>Clip</strong></span> dropdown is grayed out, then remember to click on the <span class="strong"><strong>Record</strong></span> button to enable editing.</p></div><p>The <a id="id956" class="indexterm"></a>following is what we are aiming for in the <a id="id957" class="indexterm"></a>animation, a simple alpha transition to fade the Goblin out and then fade the tombstone in:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_17.jpg" /></div><p>To recreate this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Click on <span class="strong"><strong>0:00</strong></span> on the timeframe to select the start point.</p></li><li><p>Make sure the record button is enabled.</p></li><li><p>Select the <span class="strong"><strong>Goblin</strong></span> game object in the hierarchy.</p></li><li><p>Open the <span class="strong"><strong>Color</strong></span> editor for the <span class="strong"><strong>SpriteRenderer</strong></span> (by clicking on the color box) and alter the <span class="strong"><strong>A</strong></span> (alpha) value; it doesn't matter to what. This just adds the property to the animation curve.</p></li><li><p>At position <span class="strong"><strong>0:00</strong></span>, set the value of <span class="strong"><strong>Goblin : Sprite Renderer.Color.a</strong></span> to <span class="strong"><strong>1</strong></span>.</p></li><li><p>At position <span class="strong"><strong>0:30</strong></span>, set the value of <span class="strong"><strong>Goblin : Sprite Renderer.Color.a</strong></span> to <span class="strong"><strong>0.5</strong></span>.</p></li><li><p>At position <span class="strong"><strong>1:00</strong></span>, set the value of <span class="strong"><strong>Goblin : Sprite Renderer.Color.a</strong></span> to <span class="strong"><strong>0</strong></span>.</p></li><li><p>Select the position <span class="strong"><strong>0:00</strong></span> in the timeframe.</p></li><li><p>Select the <span class="strong"><strong>Tombstone</strong></span> game object in the hierarchy.</p></li><li><p>Open the <span class="strong"><strong>Color</strong></span> editor for the SpriteRender and alter the <span class="strong"><strong>A</strong></span> (alpha) value.</p></li><li><p>At position <span class="strong"><strong>0:00</strong></span>, set the value of <span class="strong"><strong>Tombstone: Sprite Renderer.Color.a</strong></span> to <span class="strong"><strong>0</strong></span>.</p></li><li><p>At position <span class="strong"><strong>0:30</strong></span>, set the value of <span class="strong"><strong>Tombstone: Sprite Renderer.Color.a</strong></span> to <span class="strong"><strong>0</strong></span> (you might have to set it to <span class="strong"><strong>1</strong></span> first and then reset it back to <span class="strong"><strong>0</strong></span> to stick).</p></li><li><p>At position <span class="strong"><strong>1:00</strong></span>, set the value of <span class="strong"><strong>Tombstone: Sprite Renderer.Color.a</strong></span> to <span class="strong"><strong>0.5</strong></span>.</p></li><li><p>At position <span class="strong"><strong>1:30</strong></span>, set the value of <span class="strong"><strong>Tombstone: Sprite Renderer.Color.a</strong></span> to <span class="strong"><strong>1</strong></span>.</p></li></ol></div><p>This gives<a id="id958" class="indexterm"></a> us the positions we want; however, if <a id="id959" class="indexterm"></a>you look at the curve for the <span class="strong"><strong>Tombstone</strong></span> fade - in animation, it will not look quite right, as shown here:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_27.jpg" /></div><p>This is just because the curve system is doing its best to figure out what you want based on your recordings. To give us a flatter line at the beginning of our animation and a more linear line while the tombstone fades in, we just need to override the default behavior for the first two animation keys. To do this, we set the tangents for each animation key appropriately, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Switch to the <span class="strong"><strong>Curves</strong></span> view by clicking on the <span class="strong"><strong>Curves</strong></span> button; then, right-click <a id="id960" class="indexterm"></a>on the animation key (a small diamond in the view) for <span class="strong"><strong>Tombstone: Sprite Renderer.Color.a</strong></span> at <a id="id961" class="indexterm"></a>the position <span class="strong"><strong>0:00</strong></span> and select <span class="strong"><strong>Right Tangent</strong></span> | <span class="strong"><strong>Constant</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_28.jpg" /></div></li><li><p>Right-click on the key of <span class="strong"><strong>Tombstone: Sprite Renderer.Color.a</strong></span> at the position <span class="strong"><strong>0:30</strong></span> and select <span class="strong"><strong>Left Tangent</strong></span> | <span class="strong"><strong>Linear</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_29.jpg" /></div></li></ol></div><p>This gives us a nice overlapping transition between the Goblin and the Tombstone. The Goblin fades out, and halfway through this, the Tombstone fades in and our curve now looks better, as it appears in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_30.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec71"></a>Adding particles to the animation</h4></div></div></div><p>So that <a id="id962" class="indexterm"></a>the particles are played at<a id="id963" class="indexterm"></a> the beginning of the animation, we need to add<a id="id964" class="indexterm"></a> an <span class="strong"><strong>Animation</strong></span> event to the timeline. When the event is fired, it will call a custom function against the object it is attached to.</p><p>Sadly, we still cannot call particle systems directly from the Animator Dope sheet, so we have to work around this with these Animation events.</p><p>Before we can add the event, we first need to add the function and its corresponding code of the particle system to the <code class="literal">EnemyController</code> script that the animator is working from.</p><p>First, add a new variable to the top of the class to store a reference to the particle system:</p><div class="informalexample"><pre class="programlisting">private ParticleSystem bloodsplatterParticles;</pre></div><p>Next, we will grab the reference to the particle system from the component added to the game object the script is attached to in the <code class="literal">Awake</code> function:</p><div class="informalexample"><pre class="programlisting">void Awake()
{
<span class="strong"><strong>  bloodsplatterParticles = GetComponentInChildren&lt;ParticleSystem&gt;();</strong></span>
<span class="strong"><strong>  if (bloodsplatterParticles == null)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    Debug.LogError("No Particle System Found");</strong></span>
<span class="strong"><strong>  }</strong></span>
  enemyAI = GetComponent&lt;Animator&gt;();
  if (enemyAI == null)
  {
    Debug.LogError("No AI System Found");
  }
}</pre></div><p>Finally, we <a id="id965" class="indexterm"></a>will add the following <a id="id966" class="indexterm"></a>function that will cause the particle system <a id="id967" class="indexterm"></a>to play (and also clear the selected enemy from <code class="literal">BattleManager</code>):</p><div class="informalexample"><pre class="programlisting">void ShowBloodSplatter()
{
  bloodsplatterParticles.Play();
  ClearSelection();
  if (battleManager != null)
  {
    battleManager.ClearSelectedEnemy();
  }
  else
  {
    Debug.LogError("No BattleManager");
  }
}</pre></div><p>With these in place, we return to the <span class="strong"><strong>Animation</strong></span> view, right-click on <span class="strong"><strong>0:00</strong></span> in the dark gray bar of the timeline, and select <span class="strong"><strong>Add Animation Event</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_18.jpg" /></div><p>This will bring up the <span class="strong"><strong>Edit Animation Event</strong></span> window, shown in the following screenshot, where you can select the function we just created:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_19.jpg" /></div><p>Now, <a id="id968" class="indexterm"></a>when the animation <a id="id969" class="indexterm"></a>begins, it will also trigger the particle effect to<a id="id970" class="indexterm"></a> start spawning and explode the blood particles in a very tastily manner.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec72"></a>Connecting the dots</h4></div></div></div><p>If you<a id="id971" class="indexterm"></a> now select the <span class="strong"><strong>GoblinEnemy</strong></span> game object<a id="id972" class="indexterm"></a> in the <span class="strong"><strong>Hierarchy</strong></span> window and open the <span class="strong"><strong>Animator</strong></span> tab (<span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Animator</strong></span> in the menu), you will see the new animation clip as a new state in the <span class="strong"><strong>GoblinAI</strong></span> animator sheet.</p><p>However, it is not connected to anything just yet, as we want to play the animation when the Goblin dies. We just need to hook this up to the <span class="strong"><strong>Any </strong></span>state for when the Goblin's health drops to <code class="literal">0</code> or below.</p><p>So, right-click on the <span class="strong"><strong>Any</strong></span> state, create a new transition, and connect it to the new <span class="strong"><strong>GoblinDeath</strong></span> state. Then, set the condition for this transition so that <span class="strong"><strong>EnemyHealth</strong></span> is less than <span class="strong"><strong>1</strong></span>.</p><p>To tidy things up, we also need to fix the transition from the <span class="strong"><strong>Idle</strong></span> state to the <span class="strong"><strong>Any</strong></span> state because we only want the Any state to be used when the Goblin is leaving the scene (either in a box or as fast as his little legs will take him). This is because the Idle state is the default state and it will begin there, so we only need control when the Goblin goes into a defense mode or attacks the player. To do this, we need to perform the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Remove<a id="id973" class="indexterm"></a> the transition between<a id="id974" class="indexterm"></a> the Idle state and the Any state.</p></li><li><p>Add a new transition from <span class="strong"><strong>Attack</strong></span> to <span class="strong"><strong>Idle</strong></span> with the condition <span class="strong"><strong>playerSeen = false</strong></span>.</p></li><li><p>Add a new transition from <span class="strong"><strong>Defend</strong></span> to <span class="strong"><strong>Idle</strong></span> with the condition <span class="strong"><strong>playerSeen = false</strong></span>.</p></li></ol></div><p>This closes the loop a bit more cleanly between the action and exit states (it also stops a bug where the state machine could hop directly from <span class="strong"><strong>Idle</strong></span> to <span class="strong"><strong>Death</strong></span>).</p><p>The final Goblin AI Animator view should now look like this:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_20.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec73"></a>Making the new GoblinEnemy game object a prefab and adding it to the battle</h4></div></div></div><p>Now<a id="id975" class="indexterm"></a> that we have the new<a id="id976" class="indexterm"></a> base for the Goblin, drag the <span class="strong"><strong>GoblinEnemy</strong></span> game object to <code class="literal">Assets\Prefabs\Characters</code> (delete the old one if you haven't already). When it's created, delete the original <code class="literal">GameObject</code> from the <span class="strong"><strong>Project</strong></span> hierarchy as we will only use the prefab from now on.</p><p>Check over all the game objects in the prefab to ensure all the position transforms are set to <span class="strong"><strong>0</strong></span>, <span class="strong"><strong>0</strong></span>, <span class="strong"><strong>0</strong></span>. This will avoid too much head-scratching when they don't draw in the correct place.</p><p>Return <a id="id977" class="indexterm"></a>to the <span class="strong"><strong>BattleManager</strong></span> game object and add the new prefab to the <span class="strong"><strong>EnemyPrefabs</strong></span> property of the <a id="id978" class="indexterm"></a>
<code class="literal">BattleManager</code> script. We need to replace the one we just deleted.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec74"></a>Houston, we have a problem!</h4></div></div></div><p>Despite <a id="id979" class="indexterm"></a>our best laid-out plans, we actually have problems now; if you run the project at this point, you will notice two very annoying bugs:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The Goblins spawn into the battle horrendously and die instantly</p></li><li style="list-style-type: disc"><p>Their death isn't finite as they keep dying repeatedly</p></li></ul></div><p>Now, this isn't truly a problem for our budding adventurer and is arguably fun to watch, but this isn't what we were really going for; there should at least be some challenge.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch10lvl4sec11"></a>Mecanim AI considerations</h5></div></div></div><p>The <a id="id980" class="indexterm"></a>answer to the first problem is simple enough: it takes time for <code class="literal">EnemyController</code> to update the <span class="strong"><strong>EnemyAI</strong></span> state machine for the first <a id="id981" class="indexterm"></a>time (several frames actually, just a Unity thing). As the AI isn't updated, the initial state of <span class="strong"><strong>EnemyHealth</strong></span> is <span class="strong"><strong>0</strong></span>. So, when the state machine starts, the initial condition for the transition to <span class="strong"><strong>GoblinDeath</strong></span> is met because <span class="strong"><strong>EnemyHealth</strong></span> is less than <span class="strong"><strong>2</strong></span>. To resolve this, simply set the default state machine's value for <span class="strong"><strong>EnemyHealth</strong></span> to something more than the default condition, as shown in the following screenshot (for example, I set the default value to <code class="literal">5</code>):</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_31.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip79"></a>Tip</h3><p>When<a id="id982" class="indexterm"></a> using the Mecanim system for AI, be <a id="id983" class="indexterm"></a>sure to always check your default values for properties.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch10lvl4sec12"></a>Animation, states, and looping</h5></div></div></div><p>The <a id="id984" class="indexterm"></a>second issue is a bit more conventional and just requires a <a id="id985" class="indexterm"></a>bit more knowledge about the new animation system, as by default, all the animations will loop forever.</p><p>To stop <a id="id986" class="indexterm"></a>an animation from looping, you would normally just transition it to another animation state in the Mecanim animator view when it is complete (the condition <span class="strong"><strong>Exit Time = 0.9</strong></span>). However, in this case, our animation is the final resting state, and as stated, with nowhere to go, the animation state will just loop forever.</p><p>To change this, we simply need to alter the animation clip's import settings to denote it is a static animation and not a looping one (by turning off looping).</p><p>So, navigate to <code class="literal">Assets\Animation\Clips</code> and select the <span class="strong"><strong>GoblinDeath</strong></span> animation clip. Then, in the <span class="strong"><strong>Inspector</strong></span> window, uncheck the <span class="strong"><strong>Loop Time</strong></span> option as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_10_32.jpg" /></div><p>There are several other import properties for animation clips, but these are mainly for 3D models.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec128"></a>The final run-through</h3></div></div></div><p>Running<a id="id987" class="indexterm"></a> the project now in the battle scene won't get you <a id="id988" class="indexterm"></a>very far unfortunately; you will need to switch back to the home scene and play through from there. You can perform the following actions in your game:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Beginning at home.</p></li><li><p>Going to the shop and buying a weapon.</p></li><li><p>Leaving the shop and going to the big bad world.</p></li><li><p>Wandering until you encounter a battle.</p></li><li><p>Selecting a weapon to attack with.</p></li><li><p>Selecting a Goblin enemy.</p></li><li><p>Clicking on <span class="strong"><strong>Attack</strong></span>.</p></li></ol></div><p>Once this is done, only then will you be able to see how the full effect of the battle animation will unfold.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip80"></a>Tip</h3><p>Alternatively, add a code set in <code class="literal">Debug</code> style to the <code class="literal">BattleManager</code> script to give the player a sword when the script starts; just don't leave it there when you run your game properly.</p></div></div></div>