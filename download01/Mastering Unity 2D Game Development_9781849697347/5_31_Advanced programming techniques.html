<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec33"></a>Advanced programming techniques</h2></div></div><hr /></div><p>As part of this chapter, we start to go in depth with some advanced programming techniques. These enable us to structure our code better and add management to our game project instead of just adding game objects to the scene.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec52"></a>Singletons and managers</h3></div></div></div><p>Any project of a sufficient size and complexity is going to run into issues related to managing your game objects as and when they are added and removed from a scene. If you don't get your design right from the start, you are setting yourself up for a world of mess later. A common way to handle this is to use one of the three patterns, single instance managers, singletons, or a dependency system, to manage these controllers for you.</p><p>There are two main ways through which you can implement the singleton pattern in Unity. The first way is to use a public static parameter within a class to maintain the runtime class. This also allows any other script to access it from anywhere in the game and is useful if you want other events to cause the manager to do something, for example, things related to conversation systems or traps. You can also use an empty game object in the scene and attach a singleton pattern script to it. However, you could cause conflicts if you add more than one pattern.</p><p>Managers, on the other hand, are just central scripts that are particular to an individual scene to control and maintain the flow of the scene for one or many items.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec30"></a>The manager approach – using empty game objects</h4></div></div></div><p>Whereas singletons are game wide, there is often a cause for just a scene-based manager. Implementing this using an empty game object is very easy. Simply use <span class="strong"><strong>Create Empty</strong></span> from the <span class="strong"><strong>GameObject</strong></span> menu or the keyboard shortcut, as shown in the following screenshot. The placement of the new game object is up to you. If your controller's position is important (like with an enemy spawner), place it where you want the objects to spawn from. If not, it doesn't matter; it just needs to be in the scene somewhere. As it's an empty game object, it will not be drawn.</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_01.jpg" /></div><p>Then, create your manager script in the normal way. For example, the following script simply spawns the configurable enemy objects from a collection according to a simple repeating interval:</p><div class="informalexample"><pre class="programlisting">public class EnemySpawnManager : MonoBehaviour
{
  public float spawnTime = 5f;
  //The amount of time between each spawn.
  public float spawnDelay = 3f;
  //The amount of time before spawning starts.
  public GameObject[] enemies;
  //Array of enemy prefabs.


  void Start ()
  {
    //Start calling the Spawn function repeatedly after a delay.
    InvokeRepeating("Spawn", spawnDelay, spawnTime);
  }


  void Spawn ()
  {
    //Instantiate a random enemy.
    int enemyIndex = Random.Range(0, enemies.Length);
    Instantiate(enemies[enemyIndex], 
    transform.position, transform.rotation);
  }
}</pre></div><p>Then, simply attach your script to the new empty game object. For it to function, you will need to assign the prefabs of the types of enemies you want to appear in the scene by attaching them to the <span class="strong"><strong>Enemies</strong></span> property, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_02.jpg" /></div><p>You could also extend the manager to keep track of the game objects it creates; additionally, instead of creating new objects each time, you can just allocate an object from a pool, thereby removing the need to create and destroy objects over time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec31"></a>The singleton approach – using the C# singleton pattern</h4></div></div></div><p>The manager approach is fine in most cases, but you have to control each instance of the controller where it is placed. Moreover, you cannot interact with it or trigger it without more configurations added to the <code class="literal">manager</code> class, and then either binding the manager to other objects or using the dreaded <code class="literal">Find</code> function.</p><p>If you need a true manager, a better approach is to employ the singleton pattern for a <code class="literal">manager</code> class; refer to the following example:</p><div class="informalexample"><pre class="programlisting">public class MySingletonManager : MonoBehaviour {

  //Static singleton property
  public static MySingletonManager Instance {
    get; private set;
  }
  //public property for manager
  public string MyTestProperty = "Hello World";

  void Awake()
  {
    //Save our current singleton instance
    Instance = this;
  }

  //public method for manager
  public void DoSomethingAwesome()
  { }
}</pre></div><p>The preceding code is just a very basic singleton implementation, which you can attach to any game object in the scene.</p><p>Then, you can access the properties and functions within the singleton script by simply calling the following method from anywhere within your project:</p><div class="informalexample"><pre class="programlisting">//Set the public property of the singleton
MySingletonManager.Instance.MyTestProperty = "World Hello";

//Run the public method from the singleton
MySingletonManager.Instance.DoSomethingAwesome();</pre></div><p>The class can run like any other class with updates, fixed updates, and so on. It can also be expanded very quickly.</p><p>One of the other common uses of this pattern is the use of global variables for your project. However, if you intend to use your singleton class across the scenes, you will also need to ensure that it is not destroyed when the scene unloads with a simple update. This is done by calling <code class="literal">DontDestroyOnLoad</code> when you initialize the class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class MySingletonManager : MonoBehaviour {

  //static singleton property
  public static MySingletonManager Instance { get; private set; }

  //public property for manager
  public string MyTestProperty = "Hello World";

  void Awake()
  {
    //First we check if there are any other instances conflicting
    if (Instance != null &amp;&amp; Instance != this)
    {
      //Destroy other instances if they are not the same
      Destroy(gameObject);
    }

    //Save our current singleton instance
    Instance = this;

    //Make sure that the instance is not destroyed
    //between scenes (this is optional)
    DontDestroyOnLoad(gameObject);
  }

  //public method for manager
  public void DoSomethingAwesome()
  {    }
}</pre></div><p>There are more complicated setups for singletons. If you so wish, you can read them at <a class="ulink" href="http://wiki.unity3d.com/index.php/Singleton" target="_blank">http://wiki.unity3d.com/index.php/Singleton</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note46"></a>Note</h3><p>There is another pattern named <span class="strong"><strong>Dependency Injection</strong></span>. A more robust way to handle the need of manager– or factory–type requirements in any project is to implement an <span class="strong"><strong>Inversion of Control</strong></span> (<span class="strong"><strong>IoC</strong></span>) pattern, such as Dependency Injection.</p><p>Dependency Injection is a large subject, so we won't cover it in this book. The goal here is to make you aware of all the options when architecting your project. If you would like more detailed information on Dependency Injection, I'd recommend the post at <a class="ulink" href="http://blog.sebaslab.com/ioc-container-for-unity3d-part-2/" target="_blank">http://blog.sebaslab.com/ioc-container-for-unity3d-part-2/</a> to start with, and then you can work up from there.</p><p>Dependency Injection is a very powerful tool when employed correctly and can make your project a lot easier, so it is worth looking at it if you are serious. However, care is needed in its use, and it should not be used everywhere; it should only be used where it solves a particular problem.</p><p>A good Unity-based IoC framework is <span class="strong"><strong>StrangeIOC</strong></span>, which can be found at <a class="ulink" href="http://strangeioc.github.io/strangeioc/TheBigStrangeHowTo.html" target="_blank">http://strangeioc.github.io/strangeioc/TheBigStrangeHowTo.html</a>.</p></div></div></div></div>