<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec49"></a>Putting it together</h2></div></div><hr /></div><p>As you would expect, we need to create a new scene for our battles. There is a choice to make whether you want to create several scenes for different battle areas or define one generic scene and randomize the contents of that scene to add variation. Obviously there are pros and cons to each approach, but ultimately the choice is up to you.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec86"></a>Building the new scene</h3></div></div></div><p>For now, we <a id="id634" class="indexterm"></a>will keep things simple and just create a new scene and then<a id="id635" class="indexterm"></a> configure it as our battle area. So, add a new scene called <span class="strong"><strong>Battle</strong></span> to the project and make it look pretty with some additional background scene elements.</p><p>For this example, I have used the Fantasy background (<code class="literal">Environments\Fantasy\Background01.png</code>) with some of the environmental assets from our asset pack to create the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_04.jpg" /><div class="caption"><p>The Fantasy background from the free assets pack with the sprite's X scale set to 1.5 to better fit the camera</p></div></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip47"></a>Tip</h3><p>Remember<a id="id636" class="indexterm"></a> to group your additional environmental assets under a single empty game object to keep them tidy in the <span class="strong"><strong>Project</strong></span> hierarchy, and also set the sprite layer and order appropriately for all elements, including the background texture.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec87"></a>Adding the first enemy</h3></div></div></div><p>We need to <a id="id637" class="indexterm"></a>create a prefab for our first enemy. Doing so is simple. First, let's start with the goblin character in the asset pack (<code class="literal">Fantasy_Pack\01_Characters\05.png</code>), split its sprite up using <span class="strong"><strong>Sprite Editor</strong></span>, drag sprite image <code class="literal">05_03</code> on to the scene, and then rename the new game object to <code class="literal">Goblin</code>. The enemy would look as the following diagram:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_05.jpg" /></div><p>With the <a id="id638" class="indexterm"></a>character in place, it's time to give the nasty little fellow some logic; we won't use this just yet in this chapter but it's good to have it from the beginning (see <a class="link" href="#" linkend="ch10">Chapter 10</a>, <span class="emphasis"><em>The Battle Begins</em></span>, for the applied AI).</p><p>So create a new animator controller called <code class="literal">GoblinAI.controller</code> and place it in <code class="literal">Assets\Animation\Controllers</code>, which gives us the basic Animator view, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_06.jpg" /></div><p>Next, we need some parameters to control the state machine, so add the following parameters to the controller by clicking on the <span class="strong"><strong>+</strong></span> symbol on the parameters bar and selecting the <a id="id639" class="indexterm"></a>correct data type, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_07.jpg" /></div><p>The parameters to be added and their data types are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">EnemiesInBattle</code>: Int</p></li><li style="list-style-type: disc"><p><code class="literal">PlayerHealth</code>: Int</p></li><li style="list-style-type: disc"><p><code class="literal">EnemyHealth</code>: Int</p></li><li style="list-style-type: disc"><p><code class="literal">PlayerSeen</code>: Bool</p></li><li style="list-style-type: disc"><p><code class="literal">PlayerAttacking</code>: Bool</p></li></ul></div><p>Now that we have some input parameters, next up we need our states. So, create the states shown in the following screenshot on the current animation layer by right-clicking and navigating to <span class="strong"><strong>Create State</strong></span> | <span class="strong"><strong>Empty</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_08.jpg" /></div><p>The states to be added are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Idle</p></li><li style="list-style-type: disc"><p>Run Away</p></li><li style="list-style-type: disc"><p>Attack</p></li><li style="list-style-type: disc"><p>Defend</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note87"></a>Note</h3><p>You <a id="id640" class="indexterm"></a>should <a id="id641" class="indexterm"></a>note that the first state will be <a id="id642" class="indexterm"></a>colored orange, whereas the rest are colored grey. This is <a id="id643" class="indexterm"></a>simply because the first one you create becomes the default state (the state the state machine will start with). You can change the default state at any time by right-clicking on it and selecting <span class="strong"><strong>Set As Default</strong></span>.</p></div><p>So with the<a id="id644" class="indexterm"></a> parameters and states in place, all that is left is to connect everything up and finalize the state machine. So as we did in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Getting Animated</em></span>, we need to create some transitions between the states along with the conditions for those transitions, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_09.jpg" /></div><p>As seen in the <a id="id645" class="indexterm"></a>previous screenshot, the states and their transitions are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Idle -&gt; Attack – PlayerSeen = true</code></p><p>Goblin attacks player when he sees him</p></li><li style="list-style-type: disc"><p><code class="literal">Idle -&gt; Defend – PlayerSeen = true and PlayerAttacking = true</code></p><p>If the player attacks first when they are seen by the Goblin, then defend</p></li><li style="list-style-type: disc"><p><code class="literal">Attack -&gt; Defend – PlayerAttacking = true</code></p><p>Switch to defend if the player attacks</p></li><li style="list-style-type: disc"><p><code class="literal">Defend -&gt; Attack – PlayerAttacking = false</code></p><p>As soon as the player stops attacking, switch back to attack</p></li><li style="list-style-type: disc"><p><code class="literal">Any State -&gt; Idle – PlayerSeen = false</code></p><p>If the Goblin loses sight of the player at any time, go back to idle</p></li><li style="list-style-type: disc"><p><code class="literal">Any State -&gt; Run Away – EnemyHealth &lt; 2 and PlayerHealth &gt; 2</code></p><p>The Goblin is basically a coward; if at any time its health drops too low and the player is a lot healthier, then it will run away as fast as its little legs will take it</p></li></ul></div><p>Now that<a id="id646" class="indexterm"></a> we have our AI state machine for our Goblin, select the <span class="strong"><strong>Goblin</strong></span> game object in the <span class="strong"><strong>Scene</strong></span> hierarchy and add a new <span class="strong"><strong>Animator</strong></span> Component in the <span class="strong"><strong>Inspector</strong></span> menu and drag the newly created animator to it, which should now look like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_10.jpg" /></div><p>Now that we have our Goblin set up, we just need to create a prefab from it. So drag the <span class="strong"><strong>Goblin</strong></span> game object from the <span class="strong"><strong>Scene</strong></span> hierarchy and place it in <code class="literal">Assets\Prefabs\Characters</code>. You can now delete the original in the scene as we don't need it anymore.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note88"></a>Note</h3><p>If you<a id="id647" class="indexterm"></a> ever need to change or add to a prefab, you can do this at any time by selecting the prefab and updating it in the <span class="strong"><strong>Inspector</strong></span> menu. This will automatically update any scene object created from the prefab. However, if you add the prefab to the scene and then change it, the changes you make will only be for that instance in the scene and will not update the prefab.</p><p>As noted in the previous chapter, you can also update the prefab from the instance by clicking on the <span class="strong"><strong>Apply</strong></span> button.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec88"></a>Spawning the horde</h3></div></div></div><p>Now that <a id="id648" class="indexterm"></a>we have our Goblin enemy, we need to be able to randomly drop some into the battle. For this, we need to set up some spawning points (because we don't want them to appear just anywhere) and a script to manage them.</p><p>So first create a new empty game object in the scene and call it <code class="literal">SpawnPoints</code>. This is just a container to keep the spawn points all together. Next, create nine more empty game objects, make them children of the <code class="literal">SpawnPoints</code> game object, and then name them <code class="literal">Spawn1</code>, <code class="literal">Spawn2</code>, and so on, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_11.jpg" /></div><p>Now, position each Goblin in the scene where you want it to appear.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip48"></a>Tip</h3><p>While doing this, I find that adding the prefab manually to each spawn point and then positioning it makes it a lot easier to find the right spot. However, remember that the order in which you add them to the scene is important as it affects what order they are drawn in.</p><p>You can also alternatively add an editor script to the object to make it easy to use in an editor. See <a class="link" href="#" linkend="ch11">Chapter 11</a>, <span class="emphasis"><em>Onward Wary Traveller</em></span>, for more information on editor scripts.</p></div><p>After a <a id="id649" class="indexterm"></a>bit of tinkering, I ended up with the following (I also added a hero character for effect):</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_12.jpg" /><div class="caption"><p>An example scene where 8 Goblins (out of the possible 9) have spawned in</p></div></div><p>Now we know where the Goblins are going to appear; we just need to get them there, so we'll manage this with a <code class="literal">BattleManager</code> script.</p><p>The purpose of this script is to manage the life cycle of the battle scene, from setting up the battle scene to taking turns to attack and finalizing the battle once complete.</p><p>We start off by creating a new <code class="literal">BattleManager</code> C# script and placing it at the top of the project <code class="literal">Assets</code> folder along with the other managers (if you wish, you can create a separate <code class="literal">Managers</code> folder and organize them there). As this script only works when we are in a battle, there is no need to make it a singleton. Battles come and go and they should only last for the length of the current battle.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note89"></a>Note</h3><p>For now, we will just set up the framework for the battle scene and get it populated. Our poor hero has no chance to defend himself yet, so we'll just let him run away with his tail firmly between his legs.</p></div><p>First, we'll add some variables that we can configure from the scene using the following code:</p><div class="informalexample"><pre class="programlisting">    public GameObject[] EnemySpawnPoints;
    public GameObject[] EnemyPrefabs;
    public AnimationCurve SpawnAnimationCurve;</pre></div><p>These lines<a id="id650" class="indexterm"></a> maintain the spawn points the battle manager knows about, the possible enemy prefabs it can spawn into the scene, and a curve that we can use later to control how we animate the Goblins. More on this later.</p><p>Next, we have some control variables to manage the battle as it ensues. This is done using the following code:</p><div class="informalexample"><pre class="programlisting">    private int enemyCount;
    
    enum BattlePhase
    {
        PlayerAttack,
        EnemyAttack
    }
    private BattlePhase phase;
    </pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note90"></a>Note</h3><p>These states are only temporary. In <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Getting Ready to Fight</em></span>, and <a class="link" href="#" linkend="ch10">Chapter 10</a>, <span class="emphasis"><em>The Battle Begins</em></span>, we will build on this for a more full-fledged system using Mecanim.</p></div><p>We keep a count of how many enemies are active in the scene as well as what phase the battle is in at the moment (along with our own enumeration of the states the battle can be in; you can always add more). Finally, we have a flag to monitor whether the enemy characters have actually started fighting.</p><p>Now when the script is run, it needs to initialize the battle arena; so add the following code to the <code class="literal">Start</code> method:</p><div class="informalexample"><pre class="programlisting">    void Start () {
        // Calculate how many enemies
        enemyCount = Random.Range(1, EnemySpawnPoints.Length);
        // Spawn the enemies in
        StartCoroutine(SpawnEnemies());
        // Set the beginning battle phase
        phase = BattlePhase.PlayerAttack;
    }</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note91"></a>Note</h3><p>As this is a one-time coroutine, we are just initializing it with the method definition instead of the string name of the method. There is no need to stop it since it only runs till all the Goblins are in the scene and then stops.</p></div><p>Keeping things <a id="id651" class="indexterm"></a>simple for now, we generate a random number of Goblins who will attack (or be found wandering round the wood waiting to be chopped). Then, we spawn them in using a coroutine and start battle with the player going first.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note92"></a>Note</h3><p>Since we simply need a fixed random number and we are only doing it at the beginning of the scene, we are just using the Unity <code class="literal">Random</code> function. If we needed a more complex random selection or more frequent selection, we would change this to something more complex or preloaded.</p></div><p>Now that we know how many Goblins we need in the battle, we can spawn them in. I've used a coroutine here so we can animate them one by one as follows:</p><div class="informalexample"><pre class="programlisting">    IEnumerator SpawnEnemies()
    {
        // Spawn enemies in over time
        for (int i = 0; i &lt; enemyCount; i++)
        {
            var newEnemy =
                (GameObject)Instantiate(EnemyPrefabs[0]);
            newEnemy.transform.position = new Vector3(10, -1, 0);

            yield return StartCoroutine(
                MoveCharacterToPoint(
                    EnemySpawnPoints[i], newEnemy));

            newEnemy.transform.parent =
                EnemySpawnPoints[i].transform;
        }
    }</pre></div><p>Here, we loop through how many Goblins we'll need, create a new instance using the prefab we created earlier, set its position off screen, and then animate it on to the screen using yet another coroutine (shown in the following code). When the coroutine finishes animating, we anchor it to the spawn point it was meant for.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note93"></a>Note</h3><p>I made the Enemy prefabs into an array, so we can support multiple types of enemies in the battle.</p></div><p>So that the <a id="id652" class="indexterm"></a>Goblins don't appear, we use the <code class="literal">AnimationCurve</code> parameter we added to the script and a coroutine to move the Goblin from off screen to its intended spawn point, as follows:</p><div class="informalexample"><pre class="programlisting">IEnumerator MoveCharacterToPoint(GameObject destination, 
GameObject character)
{
    float timer = 0f;
    var StartPosition = character.transform.position;
    if (SpawnAnimationCurve.length &gt; 0)
    {
        while (timer &lt; SpawnAnimationCurve.keys[
            SpawnAnimationCurve.length - 1].time)
        {
            character.transform.position = 
                Vector3.Lerp(StartPosition, 
                    destination.transform.position, 
                        SpawnAnimationCurve.Evaluate(timer));

            timer += Time.deltaTime;
            yield return new WaitForEndOfFrame();
        }
    }
    else
    {
        character.transform.position = 
            destination.transform.position;
    }
}</pre></div><p>Using the same logic we used in the previous chapter when moving the character on the map, we work out where the game object is starting from and then use a <code class="literal">while</code> loop to keep the <a id="id653" class="indexterm"></a>game object moving until it finally reaches its destination. However, to improve things, this time we base the loop on the length of the <code class="literal">AnimationCurve</code> parameter we have defined for this transition.</p><p>This allows greater flexibility and allows us to have more complex and longer animations.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>First we check whether there are animation steps (keys) within <code class="literal">AnimationCurve</code> (if you want something to just pop in to place, then don't configure a curve)</p></li><li style="list-style-type: disc"><p>If there are keys in the animation, then we keep iterating until we reach the last key in the animation based on the time of that step and our current iteration time</p></li></ul></div><p>Then within the loop, we use <code class="literal">Lerp</code> for the position of the object from start to finish using the animation curve to control its time and rate.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note94"></a>Note</h3><p>We only go to the next animation step when the next frame is ready (using the <code class="literal">WaitForEndOfFrame</code> function) else the animation would happen all at once; so we<a id="id654" class="indexterm"></a> do it gradually each frame.</p><p>You could use <code class="literal">yield return null</code>; however, this happens indeterminately and could cause the coroutine to be called several times per frame depending on how long the last render/draw took. Since this is a smooth animation, we need to process it for each frame. If it is another operation that just needs controlled cycles/iterations, returning <code class="literal">null</code> may be preferred.</p></div><p>Next, we <a id="id655" class="indexterm"></a>need to give the player a way to interact with the battle scene, so we'll add some GUI buttons that only appear if we are in the player's battle phase. We need the following code to do this:</p><div class="informalexample"><pre class="programlisting">void OnGUI()
{
    if (phase == BattlePhase.PlayerAttack)
    {
        if (GUI.Button(new Rect(10, 10, 100, 50), "Run Away"))
        {
            NavigationManager.NavigateTo("World");
        }
    }
}</pre></div><p>Now, add a new empty game object to the battle scene, name it <code class="literal">BattleManager</code>, and then attach the new script to it. Once there, we can configure it by adding the spawn points we created earlier to <code class="literal">EnemySpawnPoints</code> and the Goblin prefab to the <code class="literal">EnemyPrefabs</code> parameter along with the Spawn Animation Curve, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_07_13.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec51"></a>Getting back home</h3></div></div></div><p>Now, as the <a id="id656" class="indexterm"></a>player hits the yellow streaked button to run away (obviously skipped his ninja skill training back home), we see a very obvious problem: the map scene is starting afresh back at home. This is simply because we are not tracking where the player left the previous scene.</p><p>There are two ways to handle this: either we record where exactly everything is in every scene and where the player enters and exits, or we can simply track the last known position (or possibly a mixture of the two?).</p><p>For now, let us simply implement the last known position method. To do this, we are going to need a central place to remember everything about our game world (well, at least the important bits we want to track), such as the player's stats, options and preferences they have set, and where they have been in the world. Some of these will need saving for the next time the player runs the game and some are just for the current instantiation, but we will cover saving and loading later in <a class="link" href="#" linkend="ch11">Chapter 11</a>, <span class="emphasis"><em>Onward Wary Traveller</em></span>.</p><p>The settings we need don't have to be part of any scene, actively tracked in the scene, or even interact with other game components. So we don't need a class that implements <code class="literal">MonoBehaviour</code> or <code class="literal">ScriptableObject</code>; we do, however, need it to be around all the time and not be reloaded in every scene. For this, we need a very simple <code class="literal">static</code> class (we implemented one of these earlier in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>The Big Wild World</em></span>, with <code class="literal">NavigationManager</code>).</p><p>Create a <a id="id657" class="indexterm"></a>new C# script in <code class="literal">Assets\Scripts\Classes</code> called <code class="literal">GameState</code> and populate it with the following code:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Generic;
using UnityEngine;

public static class GameState {

    public static Player CurrentPlayer = ScriptableObject.CreateInstance&lt;Player&gt;();
    public static bool PlayerReturningHome;
    public static Dictionary&lt;string, Vector3&gt; LastScenePositions = new Dictionary&lt;string, Vector3&gt;();
}</pre></div><p>Here, we have<a id="id658" class="indexterm"></a> some simple static properties to:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Track the player's stats</p></li><li style="list-style-type: disc"><p>A flag to note whether the player is running home away from a battle</p></li><li style="list-style-type: disc"><p>A dictionary to record the scenes the player has been to and the last position they were in that scene</p></li></ul></div><p>Simple enough, but to avoid unnecessary code duplication I have also added some helper methods to<a id="id659" class="indexterm"></a> the <code class="literal">GameState</code> class to manage and simplify the use of the <code class="literal">LastScenePositions</code> dictionary (to save time later).</p><p>So add the following code to the end of the <code class="literal">GameState</code> class:</p><div class="informalexample"><pre class="programlisting">    public static Vector3 GetLastScenePosition(string sceneName)
    {
        if (GameState.LastScenePositions.ContainsKey(sceneName))
        {
            var lastPos = GameState.LastScenePositions[sceneName];
            return lastPos;
        }
        else
        {
            return Vector3.zero;
        }
    }

    public static void SetLastScenePosition(
        string sceneName, Vector3 position)
    {
        if (GameState.LastScenePositions.ContainsKey(sceneName))
        {
            GameState.LastScenePositions[sceneName] = position;
        }
        else
        {
            GameState.LastScenePositions.Add(sceneName, position);
        }
    }</pre></div><p>The preceding code is fairly similar but it ensures simple and effective use of any dictionary <a id="id660" class="indexterm"></a>class, checking the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>When you request a value from the dictionary, it checks whether it exists first and then returns it</p></li><li style="list-style-type: disc"><p>If the value doesn't exist in the dictionary yet, it returns a default value</p></li><li style="list-style-type: disc"><p>When you add a new value to the dictionary, it checks whether it already exists, and if it does, then it updates the existing value</p></li><li style="list-style-type: disc"><p>If the value does not exist when you try to add it, it just adds it to the dictionary</p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip50"></a>Tip</h3><p>Dictionaries are powerful when used correctly: you can find values by index (in this case a string) or you can find them by ID (like in arrays). You can even loop over dictionaries with for or foreach loops.</p><p>However, depending on how you use them, they may not perform well and can also generate garbage, so use them carefully.</p><p>For more details, see the C# article at <a class="ulink" href="http://blogs.msdn.com/b/shawnhar/archive/2007/07/02/twin-paths-to-garbage-collector-nirvana.aspx" target="_blank">http://blogs.msdn.com/b/shawnhar/archive/2007/07/02/twin-paths-to-garbage-collector-nirvana.aspx</a>. The article is based on XNA<a id="id661" class="indexterm"></a> but rings true for any C# platform.</p><p>There are also considerations when you need to serialize the values from a dictionary since they are handled differently on some platforms, and in some cases not even supported for serialization.</p></div><p>With the <code class="literal">GameState</code> class in place, we just need to update the <code class="literal">MapMovement</code> script for the map to <a id="id662" class="indexterm"></a>load the last position if one exists, and save the last position when exiting the scene (and in any other scene that will need the logic).</p><p>So, update the <code class="literal">MapMovement</code> script's <code class="literal">Awake</code> method with the following code:</p><div class="informalexample"><pre class="programlisting">void Awake()
{
    this.collider2D.enabled = false;
    var lastPosition =
      GameState.GetLastScenePosition(Application.loadedLevelName);

    if (lastPosition != Vector3.zero)
    {
        transform.position = lastPosition;
    }
}</pre></div><p>The previous code simply looks for a last position for the current scene, and if there is one, it moves the player to it.</p><p>Similarly, when closing the scene, we just need to store the last position. To do this, we add an <code class="literal">OnDestroy</code> method as<a id="id663" class="indexterm"></a> follows and save the player's current position:</p><div class="informalexample"><pre class="programlisting">void OnDestroy()
{
    GameState.SetLastScenePosition(
        Application.loadedLevelName, transform.position);
}</pre></div></div></div>