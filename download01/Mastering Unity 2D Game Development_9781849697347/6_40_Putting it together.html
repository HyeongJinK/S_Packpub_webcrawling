<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec41"></a>Putting it together</h2></div></div><hr /></div><p>Moving on from theory, we need to look at something to put on our map of the world, such as somewhere for our player to travel to and explore.</p><p>We not only need to provide graphical support in the game to open up areas on the map or just show the journey between two points, but we also need to connect these points with scenes in our game.</p><p>Now, we have already started the coding framework behind our places manager with the creation of the <code class="literal">NavigationManager</code> script, which keeps track of all the places available in<a id="id501" class="indexterm"></a> the world for our player to travel to. Just add a few more routes for the manager to look after and that's up and running.</p><p>Then, there is the visual side. As we want a common way to create places/markers on the map, we can start to use prefabs in Unity so that we only have to design them once and then just reuse them on our map.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec72"></a>Adding the map</h3></div></div></div><p>Start off by <a id="id502" class="indexterm"></a>copying your <code class="literal">world</code> texture into your project <code class="literal">Assets</code> folder in <code class="literal">Assets\Sprites\Environment</code>, and use any image you wish to use or generate one from <a class="ulink" href="http://donjon.bin.sh/fantasy/world/" target="_blank">http://donjon.bin.sh/fantasy/world/</a> or <a class="ulink" href="http://donjon.bin.sh/world/" target="_blank">http://donjon.bin.sh/world/</a> like I have done.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note66"></a>Note</h3><p>The following screenshot, which displays a map image, is included in the download associated with this title (<code class="literal">Sample_Assets\Worldmap.png</code>).</p></div><p>With that in place, create a new scene in <code class="literal">Assets\Scene</code> and call it <code class="literal">World</code> (this has to be the same as the name used in your <code class="literal">NavigationManager</code> script). In your scene, drag your <code class="literal">world</code> texture to the hierarchy <a id="id503" class="indexterm"></a>and update your <code class="literal">MainCamera</code> GameObject to show the starting region for your world.</p><p>As the <code class="literal">world</code> texture I have used is rather large, I have set this to the top-left region of the map as <a id="id504" class="indexterm"></a>shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_10.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec73"></a>Adding places of interest</h3></div></div></div><p>With the <a id="id505" class="indexterm"></a>world that the player can travel to in place, we need to add the player to the map and some places of interest.</p><p>Adding the player is simple; just create a new empty game object and call it <code class="literal">player</code>, then add the <code class="literal">Rigidbody2D</code> and <code class="literal">BoxCollider2D</code> components to it so that it will be able to interact with other points on the map. (You could use location testing, but it's simpler to use the physics system and it's not much overhead.)</p><p>Finally, it's best for the player to have something to see moving when traveling, so add a <span class="strong"><strong>Sprite Renderer</strong></span> to the player game object and use a sprite image that suits it. I used the running hero sprite for effect but you could use whatever you wish.</p><p>You should end up with something like the following:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_13.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec74"></a>Creating the MapPoint prefabs for reuse</h3></div></div></div><p>Creating <a id="id506" class="indexterm"></a>prefabs is very easy; just start creating a game object as you would do normally and once you are happy with the result, drag the whole object to the project view. The beauty is that just about anything can become a prefab for reuse in your game.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note67"></a>Note</h3><p>When you create a prefab and use it in your scene, any changes to the prefab will be automatically updated on all the objects you created with that prefab. However, changes to those objects themselves do not update the prefab or any other copies. All changes are one way from the prefab itself.</p><p>If you want to <a id="id507" class="indexterm"></a>update the prefab, select the <span class="strong"><strong>Prefab</strong></span> option in the editor and change it. Alternatively, select an instance in the scene, change the required properties, and then click on <span class="strong"><strong>Apply</strong></span> to save the changes back to the prefab, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_15.jpg" /></div><p>This will only affect existing components and properties that were already on the prefab. To add new components or scripts to the prefab, you must edit the prefab itself.</p></div><p>The <a id="id508" class="indexterm"></a>following screenshot shows a game object setup for a place of interest on our map as an empty game object with a simple <code class="literal">BoxCollider2D</code> component (set as a trigger). We can also see the <code class="literal">NavigationPrompt</code> script we used in earlier chapters to bring up the traveling GUI.</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_05.jpg" /></div><p>Finally, rename the new prefab to <code class="literal">MapPoint</code> so that we know what the prefab is for in our folder structure.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note69"></a>Note</h3><p>With a collider set as a trigger, it will cause the <code class="literal">OnTrigger</code> functions (<code class="literal">OnTriggerEnter2D</code> and <code class="literal">OnTriggerExit2D</code>) to be called in scripts as opposed to the normal <code class="literal">OnCollision</code> functions (<code class="literal">OnCollisionEnter2D</code> and <code class="literal">OnCollisionExit2D</code>). Bear this in mind when applying scripts that rely on a collider. We will update our <code class="literal">NavigationPrompt</code> script accordingly.</p></div><p>With the<a id="id509" class="indexterm"></a> prefab created, just drag it to the project's <span class="strong"><strong>Assets</strong></span> window in <code class="literal">Assets\Prefabs\Environment</code>. You will get a new <code class="literal">Prefab</code> asset for a map's place of interest, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_06.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note70"></a>Note</h3><p>Note that prefabs are always highlighted in blue, both in the project asset and hierarchy views. This makes them very easy to identify.</p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip41"></a>Tip</h3><p>Always reset the position transform for prefabs to <code class="literal">0</code>; this makes it a whole lot easier when reusing them.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note71"></a>Note</h3><p>For the sake of simplicity, I've kept the example simple, but you could expand on it to include a sprite renderer and use an additional image per place to identify it. Some great examples of map point icons can be found at <a class="ulink" href="http://calthyechild.deviantart.com/art/Fantasy-Map-TutorialxResources-258559867" target="_blank">http://calthyechild.deviantart.com/art/Fantasy-Map-TutorialxResources-258559867</a>, which provides some great free resources and images.</p></div><p>Once the prefab is created, we can start to use it since this game object has now become the first instance of our <code class="literal">MapPoint</code> prefab. So, rename it to <code class="literal">Home</code> and place it over the town where<a id="id510" class="indexterm"></a> the player starts, and then create a new tag for <code class="literal">Home</code> so that we can add it to our <code class="literal">NavigationManager</code> script.</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_14.jpg" /></div><p>Next, create a new instance of our <code class="literal">MapPoint</code> prefab by dragging the prefab on to the scene and placing it over the town of Kirkidw (or any suitable place on the map near your start point; it's up to you to pick your own destination town). Rename it to <code class="literal">Kirkidw</code> and create/set a tag with the same name.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note72"></a>Note</h3><p>As highlighted earlier, if you wish, you can also add a sprite to the place's game object to highlight the town's position on the map. If you want, you can add the sprite renderer to the prefab and change the sprite image on each instance appropriately. If it's a common image, then just set the sprite on the prefab.</p></div><p>For the best results and to make the scene easy to read, add any new map points as children of the background texture (worldmap); this keeps the points of interest both anchored to the texture and neatly organized.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec75"></a>Updating the NavigationPrompt script</h3></div></div></div><p>The map <a id="id511" class="indexterm"></a>points we have defined are set as triggers. We use triggers when we do not want any physics interactions between the collider and other rigid bodies; all we want is to be notified that one collider has moved over (in the case of 2D) or interacted with another collider.</p><p>As we are now using triggers, we need to swiftly update our <code class="literal">NavigationPrompt</code> script to work with triggers. So, open the <code class="literal">NavigationPrompt</code> script and add the following function in it:</p><div class="informalexample"><pre class="programlisting">void OnTriggerEnter2D(Collider2D col)
{
  //Only allow the player to travel if allowed
  if (NavigationManager.CanNavigate(this.tag))
  {
    showDialog = true;
  }
}</pre></div><p>The function in the preceding code does exactly the same as the <code class="literal">OnCollisionEnter2D</code> function, which we already have, but this will now respond to the colliders that have been set as triggers using the <code class="literal">is Trigger</code> flag.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec76"></a>Updating the NavigationManager script</h3></div></div></div><p>As the player<a id="id512" class="indexterm"></a> can now venture out of town, we need to update our <code class="literal">NavigationManager</code> script with additional places to visit, including our home town. We can do this simply by adding additional routes to our <code class="literal">NavigationManager</code> script as follows:</p><div class="informalexample"><pre class="programlisting">public static Dictionary&lt;string, Route&gt; RouteInformation = new Dictionary&lt;string, Route&gt;() {
  { "World", new Route {
    RouteDescription = "The big bad world", CanTravel = true}},
  { "Cave", new Route {
    RouteDescription = "The deep dark cave", CanTravel = false}}<span class="strong"><strong>,</strong></span>
<span class="strong"><strong>  { "Home", new Route {</strong></span>
<span class="strong"><strong>    RouteDescription = "Home sweet home", CanTravel = true}},</strong></span>
<span class="strong"><strong>  { "Kirkidw", new Route {</strong></span>
<span class="strong"><strong>    RouteDescription = "The grand city of Kirkidw", CanTravel = true}},</strong></span>
};</pre></div><p>Nice and easy; although you should note one small flaw. We use the scene name as a way to identify<a id="id513" class="indexterm"></a> the area that we want to travel to and currently our home scene is<a id="id514" class="indexterm"></a> called <span class="strong"><strong>Main</strong></span>. So, rename the <code class="literal">Main</code> scene to <code class="literal">Home</code>, which should leave you with the following scenes in <code class="literal">Assets\Scenes</code>:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_16.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec77"></a>Traveling by click or touch</h3></div></div></div><p>With the map set up, we can head into the land of scripting to handle the players. Additionally (as highlighted earlier), we also need to ensure that the player doesn't move when the<a id="id515" class="indexterm"></a> navigation GUI is displayed.</p><p>Before we<a id="id516" class="indexterm"></a> begin, you should recall earlier that I mentioned about<a id="id517" class="indexterm"></a> screen and world space conversion and the need to convert 3D (Vector3) coordinates to 2D (either a Vector2 or a Vector3 with the <code class="literal">Z</code> value set to zero) else our calculations will be off. As our map will be controlled by click or touch (to spice things up a bit), we need to be able to access where the player has interacted on our map.</p><p>To this end, I added a set of extension methods to a new class called <code class="literal">WorldExtensions</code> in <code class="literal">Assets\Scripts\Classes</code>, replacing its contents with the following:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
public static class WorldExtensions
{
  public static Vector3 ToVector3_2D(this Vector3 coordinate)
  {
    return new Vector3(coordinate.x, coordinate.y, 0);
  }

  public static Vector2 GetScreenPositionIn2D(this Vector3 screenCoordinate)
  {
    Vector3 wp = Camera.main.ScreenToWorldPoint(screenCoordinate);
    return new Vector2(wp.x, wp.y);
  }

  public static Vector3 GetScreenPositionFor2D(this Vector3 screenCoordinate)
  {
    Vector3 wp = Camera.main.ScreenToWorldPoint(screenCoordinate);
    return wp.ToVector3_2D();
  }
}</pre></div><p>The following <a id="id518" class="indexterm"></a>extensions at the end of the current script are just for simplicity, but <a id="id519" class="indexterm"></a>you could define them<a id="id520" class="indexterm"></a> anywhere:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Convert any Vector3 in to a 2D Vector3 with a zero <code class="literal">z</code> value</p></li><li style="list-style-type: disc"><p>Convert a screen space coordinate and return a Vector2 for 2D</p></li><li style="list-style-type: disc"><p>Convert a screen space coordinate and return a Vector3 with a zero <code class="literal">z</code> value for 2D</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note73"></a>Note</h3><p>The <code class="literal">this</code> keyword<a id="id521" class="indexterm"></a> signifies that this is an extension method, allowing the function to be accessed by calling the function normally:</p><div class="informalexample"><pre class="programlisting">var clickPoint = WorldExtensions.GetScreenPositionFor2D(Input.mousePosition);</pre></div><p>Otherwise, you could directly access the function from the type identified by the <code class="literal">this</code> keyword:</p><div class="informalexample"><pre class="programlisting">var clickPoint = Input.mousePosition<span class="strong"><strong>.GetScreenPositionFor2D();</strong></span>
</pre></div><p>Extension methods are a very powerful and easy way to extend functions and methods<a id="id522" class="indexterm"></a> on to existing object types. For more information on extension methods, visit <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/bb383977.aspx" target="_blank">http://msdn.microsoft.com/en-gb/library/bb383977.aspx</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec44"></a>Managing input</h4></div></div></div><p>With our<a id="id523" class="indexterm"></a> helpers in place, next we'll create a new <code class="literal">MapMovement</code> script in<a id="id524" class="indexterm"></a> the project under <code class="literal">Assets\Scripts</code> and replace its contents with the following:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class MapMovement : MonoBehaviour
{
  Vector3 StartLocation;
  Vector3 TargetLocation;
  float timer = 0;
  bool inputActive = true;
}</pre></div><p>The properties are just there to track the progress of the player, and there is a flag to track when the GUI is active.</p><p>Next, we can add the input handling functions to the script in the <code class="literal">Update</code> method. Whenever you are giving an input, it's better to use <code class="literal">Input</code> as it gives more accurate results, as shown in the following script:</p><div class="informalexample"><pre class="programlisting">void Update () {

  if (inputActive &amp;&amp; Input.GetMouseButtonUp(0))
  {
    StartLocation = transform.position.ToVector3_2D();
    timer = 0;
    TargetLocation = WorldExtensions.GetScreenPositionFor2D(Input.mousePosition);
  }
  else if (inputActive &amp;&amp; Input.touchCount == 1)
  {
    StartLocation = transform.position.ToVector3_2D();
    timer = 0;
    TargetLocation = WorldExtensions.GetScreenPositionFor2D(Input.GetTouch(0).position);
  }
}</pre></div><p>The process is very simple; test whether the user has clicked the mouse (<code class="literal">Input.GetMouseButtonUp(0)</code>) or touched the screen (<code class="literal">Input.touchCount == 1</code>). The value could be greater than <code class="literal">1</code>, but we want just one touch in this case. When they do so, record the current position of the player as the start point, and where the user has touched or clicked as the end point (target).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note76"></a>Note</h3><p>Input, as you will find in Unity, is not completely unified. You have to code and manage touch and mouse separately.</p></div><p>Now that we have a place to move the player to, we just need to add the ability to move the player once we have selected a target location and get the player moving on his merry way. So, add the following to the end of the previous <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">  if (TargetLocation != Vector3.zero &amp;&amp; TargetLocation != transform.position &amp;&amp; TargetLocation != StartLocation)
  {
    transform.position = Vector3.Lerp(StartLocation, TargetLocation, timer);
    timer += Time.deltaTime;
  }</pre></div><p>In the preceding<a id="id525" class="indexterm"></a> code, we simply check whether the user has selected a destination and check that we are not there already. If everything is fine, then we just keep <a id="id526" class="indexterm"></a>updating the player's position using the <code class="literal">Lerp</code> function<a id="id527" class="indexterm"></a> gradually over time.</p><p>With that done, simply add the script to the player game object we created in our scene earlier and run the project.</p><p>Although it works, you should instantly see one issue: when the players starts on the map, they are actually interacting with the place on the map they started from (<code class="literal">Home</code> in this case). Because it is interacting with that place already, this causes the navigation prompt to appear and asks them whether they want to go home.</p><p>As our player is not a scaredy cat and wants to venture further, let's fix that.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec45"></a>Managing input priorities</h4></div></div></div><p>When<a id="id528" class="indexterm"></a> organizing your map navigation, input prioritization is <a id="id529" class="indexterm"></a>an important point. When you have both GUI input and player input challenging for control, you should be able to manage which is currently active at any one time; otherwise, if both are active, you will get unexpected or duplicate results.</p><p>For instance, once you have your player moving using the mouse/touch, then the GUI to travel to that destination pops up and accepts input in both the GUI and the map movement at the same time. Hence, when you click on a button to travel or stay, then the map character will also move.</p><p>To combat this, the simplest and best way is to reuse our <code class="literal">MessagingManager</code> script with a new message to handle whether the GUI is taking input or the game is.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note77"></a>Note</h3><p>It may be advantageous to have both the GUI and game input working at the same time, for example, in situations where you have in-game buttons for actions. In these cases, you would test where on the screen the player interacted to decide which area gets the input. However, when the pause menu or alternate screen appears, you are still going to need to handle input priority.</p></div><p>So in the <code class="literal">MessagingManager</code> script, we add the following new handler to manage the GUI events. We also need to track whether the GUI is displayed or not, so we also need to manage a parameter for the event using a Boolean (<code class="literal">true</code> means GUI is displayed and <code class="literal">false</code> means GUI is hidden):</p><div class="informalexample"><pre class="programlisting">private List&lt;Action&lt;bool&gt;&gt; uiEventSubscribers = new List&lt;Action&lt;bool&gt;&gt;();</pre></div><p>Then, like<a id="id530" class="indexterm"></a> before, we need a subscribing and broadcasting function for<a id="id531" class="indexterm"></a> the new event:</p><div class="informalexample"><pre class="programlisting">// Subscribe method for UI manager
public void SubscribeUIEvent(Action&lt;bool&gt; subscriber)
{
  uiEventSubscribers.Add(subscriber);
}

// Broadcast method for UI manager
public void BroadcastUIEvent(bool uIVisible)
{
  foreach (var subscriber in uiEventSubscribers.ToArray())
  {
    subscriber(uIVisible);
  }
}

// Unsubscribe method for UI manager
public void UnSubscribeUIEvent(Action&lt;bool&gt; subscriber)
{
  uiEventSubscribers.Remove(subscriber);
}

// Clear subscribers method for manager
public void ClearAllUIEventSubscribers()
{
  uiEventSubscribers.Clear();
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note78"></a>Note</h3><p>You will note we only use a copy of the subscribers array. This is to ensure that the loop does not fall over when new subscriptions are added or existing ones are removed while it is progressing through the loop. It is unlikely in this scenario; however, it is a good practice to follow either this option or use locking methods to ensure that the array cannot be updated when the listis being traversed.</p></div><p>This ensures that when GUI events happen (if the game is paused and a pause menu is displayed or, as in this case, when the travel prompt appears), the GUI system just has one place to <a id="id532" class="indexterm"></a>tell all scenes and objects that are listening through messaging<a id="id533" class="indexterm"></a> when the GUI is in focus in the game (everyone else stop talking, GUI has the floor), and when it's finished</p><p>So, next we need <a id="id534" class="indexterm"></a>to update our <code class="literal">NavigationPrompt</code> script to broadcast when the GUI is displayed and when it is hidden. First, let's refactor a bit and add a new method that controls what happens when the dialog state needs to change:</p><div class="informalexample"><pre class="programlisting">void DialogVisible(bool visibility)
{
  showDialog = visibility;
  MessagingManager.Instance.BroadcastUIEvent(visibility);
}</pre></div><p>This just sets the <code class="literal">showDialog</code> flag we were using to the new state and then follows up by sending a broadcast of the new state (<code class="literal">true</code> means visible and <code class="literal">false</code> means not invisible). Next, wherever we previously changed the <code class="literal">showDialog</code> flag, we need to update it to use the new helper function. So, change the <code class="literal">showDialog</code> flag to the following:</p><div class="informalexample"><pre class="programlisting">showDialog = false -&gt; DialogVisible(false);

showDialog = true -&gt; DialogVisible(true);</pre></div><p>Next, we need to update the <code class="literal">MapMovement</code> script to add in the messaging handlers so that the script knows when the GUI is displayed. So, add<a id="id535" class="indexterm"></a> the following <code class="literal">Start</code> function to subscribe to the <code class="literal">MapMovement</code> script for the new UI events:</p><div class="informalexample"><pre class="programlisting">void Start()
{
  MessagingManager.Instance.SubscribeUIEvent(UpdateInputAction);
}</pre></div><p>Then, add the corresponding function to toggle the <code class="literal">inputActive</code> flag we created earlier:</p><div class="informalexample"><pre class="programlisting">private void UpdateInputAction(bool uiVisible)
{
  inputActive = !uiVisible;
}</pre></div><p>This just updates the <code class="literal">inputActive</code> property whenever the GUI informs us that it's onscreen.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note79"></a>Note</h3><p>If you<a id="id536" class="indexterm"></a> haven't done it yet, update the <code class="literal">MessagingManager</code> script based on the example in the <span class="emphasis"><em>Managing input</em></span> section to<a id="id537" class="indexterm"></a> add the new UI event handler. Additionally, update the <code class="literal">NavigationPrompt</code> script to inform the message handler when the GUI is visible.</p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip42"></a>Tip</h3><p>If you like Lamdas, you could actually write the preceding code to subscribe to the <code class="literal">MessagingManager</code> line as follows:</p><div class="informalexample"><pre class="programlisting">MessagingManager.Instance.SubscribeUIEvent(uiVisible =&gt; inputActive = !uiVisible);</pre></div><p>However, I've kept it simple in the project for all to read and it's a good practice to keep them separate in case you need to add more handling.</p><p>For more<a id="id538" class="indexterm"></a> information on Lamdas, see the MSDN article at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/bb397687.aspx" target="_blank">http://msdn.microsoft.com/en-gb/library/bb397687.aspx</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec46"></a>Managing input order</h4></div></div></div><p>If you run the <a id="id539" class="indexterm"></a>code at this point, you will notice that all the changes we <a id="id540" class="indexterm"></a>just made did not actually fix the problem. When we click on the play button, the player still moves to the click position. The reason for this is very simple: your machine is just too darn quick.</p><p>Basically, when you click on the GUI button, the UI event is fired. In the <code class="literal">MapMovement</code> script, however, it receives this straightaway and changes the <code class="literal">inputActive</code> flag. Then, when the <code class="literal">Update</code> method<a id="id541" class="indexterm"></a> is called, the script thinks the UI has already gone away and receives the same click action and then proceeds to move the player.</p><p>We can handle this in one of two ways—either we can change the script execution order (visit <a class="ulink" href="http://docs.unity3d.com/Manual/class-ScriptExecution.html" target="_blank">http://docs.unity3d.com/Manual/class-ScriptExecution.html</a> for more details, but this can become quite messy to manage), or we can simply update the <code class="literal">inputActive</code> flag at the end of the <code class="literal">Update</code> loop.</p><p>To keep things simple, let's do the latter. So, create the following new property at the top of the <code class="literal">MapMovement</code> script:</p><div class="informalexample"><pre class="programlisting">bool inputReady = true;</pre></div><p>Then, instead of updating the <code class="literal">inputActive</code> flag directly, you would update the new flag instead. This allows us to delay the change in the input status for the script. So, update the <code class="literal">UpdateInputAction</code> method as follows:</p><div class="informalexample"><pre class="programlisting">private void UpdateInputAction(bool uiVisible)
{
  <span class="strong"><strong>inputReady</strong></span> = !uiVisible;
}</pre></div><p>Finally, at the<a id="id542" class="indexterm"></a> end of the <code class="literal">Update</code> method, we would set the <code class="literal">inputActive</code> flag to<a id="id543" class="indexterm"></a> the value of the new <code class="literal">inputReady</code> flag after checking all the user input and allowing the screen prompt to close first:</p><div class="informalexample"><pre class="programlisting">inputActive = inputReady;</pre></div><p>Now when you run the project and the GUI is displayed, clicking on the play button no longer causes the player to move as well.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec47"></a>Getting curvy</h4></div></div></div><p>If you recall, back in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Getting Animated</em></span>, I showed you the animation curves that<a id="id544" class="indexterm"></a> can alter how a sprite or inspector value can be<a id="id545" class="indexterm"></a> changed over time. You can also use these just about anywhere in Unity. So, we'll apply this to our <code class="literal">MapMovement</code> script to control how the player transits from his start position to his destination. To do this, simply add a new <code class="literal">public</code> parameter to the top of the <code class="literal">MapMovement</code> script (this can work on any script implementing <code class="literal">MonoBehaviour</code>) as follows:</p><div class="informalexample"><pre class="programlisting">public AnimationCurve MovementCurve;</pre></div><p>When viewed from the editor, this will give you the custom inspector for an animation curve as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_07.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note80"></a>Note</h3><p>You have to configure the curve initially from the editor for it to do anything; the default is simply a flat line with no movement.</p></div><p>When you click<a id="id546" class="indexterm"></a> on the curve, you will get the animation <a id="id547" class="indexterm"></a>curve editor, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_08.jpg" /></div><p>By default, no<a id="id548" class="indexterm"></a> curve is defined and you have to configure a new<a id="id549" class="indexterm"></a> curve. In the preceding screenshot, you can see a basic linear curve that grows over time. But this being an editor, you can apply just whatever kind of curve you want—either start with one of the presets at the bottom of the editor or start altering the curve by adding new animation keys (by right clicking on the curve and selecting <span class="strong"><strong>Add key</strong></span>) and changing the curve characteristics. You can even create something as wacky as the one shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_09.jpg" /></div><p>With your curve parameter available and configured, we can then alter our previous <code class="literal">Lerp</code> function in the <code class="literal">MapMovement</code> script to use the curve parameter as follows:</p><div class="informalexample"><pre class="programlisting">if (TargetLocation != Vector3.zero &amp;&amp; TargetLocation != transform.position &amp;&amp; TargetLocation != StartLocation)
{
  transform.position = Vector3.Lerp(StartLocation, TargetLocation, <span class="strong"><strong>MovementCurve.Evaluate(timer));</strong></span>
  timer += Time.deltaTime;
}</pre></div><p>This, now <a id="id550" class="indexterm"></a>gives us the ability to control how the <code class="literal">Lerp</code> function behaves at a very fine level.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip44"></a>Tip</h3><p>This<a id="id551" class="indexterm"></a> curve could be updated procedurally to alter the curve if there are mountains or other difficult terrain to maneuver over, or you could switch from doing a fixed input (as shown in the following code) and use more physics/forces to alter the interaction between the player and the terrain.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec48"></a>Fixing the start location</h4></div></div></div><p>To ensure that the hero doesn't actually run home on seeing the big bad wild world, we just need to <a id="id552" class="indexterm"></a>simply stop him looking at home until he has <a id="id553" class="indexterm"></a>actually gone far enough from home to actually miss it. To do this, we simply need to disable the collider on the player until he is not colliding with home anymore. We will perform the following steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Achieving the start location is simple; just add a new property to the <code class="literal">MapMovement</code> script to track whether the player has actually started travelling yet. The code is as follows:</p><div class="informalexample"><pre class="programlisting">bool startedTravelling = false;</pre></div></li><li><p>Next, we ensure that when the map scene starts, the player's <code class="literal">BoxCollider2D</code> component is actually turned off. We do this in the <code class="literal">Awake</code> function before anything is updated or checked. The code is as follows:</p><div class="informalexample"><pre class="programlisting">void Awake()
{
  this.collider2D.enabled = false;
}</pre></div></li><li><p>Next, we change <a id="id554" class="indexterm"></a>our <code class="literal">Update</code> function to take note of the new flag and also perform the check as follows:</p><div class="informalexample"><pre class="programlisting">void Update()
{
  if (TargetLocation != Vector3.zero &amp;&amp; TargetLocation != transform.position &amp;&amp; TargetLocation != StartLocation)
  {
    transform.position = Vector3.Lerp(StartLocation, TargetLocation, MovementCurve.Evaluate(timer));
    timer += Time.deltaTime;
  }
<span class="strong"><strong>  if (startedTravelling &amp;&amp; Vector3.Distance(StartLocation, transform.position.ToVector3_2D()) &gt; 0.5)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    this.collider2D.enabled = true;</strong></span>
<span class="strong"><strong>    startedTravelling = false;</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Here, we added another statement after the movement code to test whether the following conditions are satisfied:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Has<a id="id555" class="indexterm"></a> the player has started<a id="id556" class="indexterm"></a> travelling yet? If not, do nothing.</p></li><li style="list-style-type: disc"><p>Is the distance between the place the player started at and the hero's current position far enough (in world space values)? If yes, then re-enable the player collider.</p></li></ul></div><p>So once the player has moved a sufficient distance, the hero will then be able to interact with places on the map again.</p></li><li><p>Finishing off, we need to update the <code class="literal">StartTravelling</code> flag whenever the player taps or clicks a destination, or else the collider will never get enabled by the preceding code. So, update the <code class="literal">Update</code> function to set this appropriately by setting the following in both of the <code class="literal">if</code> statements:</p><div class="informalexample"><pre class="programlisting">if (inputActive &amp;&amp; Input.GetMouseButtonUp(0))
{
  StartLocation = transform.position.ToVector3_2D();
  timer = 0;
  TargetLocation = WorldExtensions.GetScreenPositionFor2D(Input.mousePosition);
  <span class="strong"><strong>startedTravelling = true;</strong></span>
}
else if (inputActive &amp;&amp; Input.touchCount &gt; 0)
{
  StartLocation = transform.position.ToVector3_2D();
  timer = 0;
  TargetLocation = WorldExtensions.GetScreenPositionFor2D(Input.GetTouch(0).position);
<span class="strong"><strong>  startedTravelling = true;</strong></span>
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec49"></a>Traveling too far</h4></div></div></div><p>The last snag to watch out for is when the player shoots straight through the town we are currently prompting them about and continues going. Thankfully, this one is very easy to handle.</p><p>We just need to check when our input has been disabled by the GUI by checking the new <code class="literal">inputReady</code> flag. If the input has only just been disabled, we do this by updating the end of the <code class="literal">Update</code> method in our <code class="literal">MapMovement</code> script as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  if (!inputReady &amp;&amp; inputActive)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    TargetLocation = this.transform.position;</strong></span>
<span class="strong"><strong>    Debug.Log("Stopping Player");</strong></span>
<span class="strong"><strong>  }</strong></span>
  inputActive = inputReady;
}</pre></div><p>So, when the UI event has turned off the <code class="literal">inputReady</code> flag but has not yet been synchronized with the <code class="literal">inputActive</code> flag, we simply stop the player in their tracks and fix their target position to their current position.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec78"></a>Transitions</h3></div></div></div><p>When you are<a id="id557" class="indexterm"></a> transitioning between scenes/levels within Unity, it can appear a bit jarring to the player when a scene just freezes and then another one pops up. Even when you make the loading of the scene as fast as possible, there is still a flicker on the screen that is not smooth or fluid (as designers like to say).</p><p>Thankfully, we can easily fix this by adding some code to manage the transition between the towns and world in our game. We will do this by adding a <code class="literal">Fading</code> manager to our game.</p><p>To start off, in the same way as we did with the <code class="literal">Conversation</code> manager in the previous chapter, we will create a new class and apply our singleton framework to it. This is simply because there should only ever be one agent in our game managing the fading of a scene so it does not cause an issue if a player enters and then immediately exits a scene.</p><p>So, create a new <code class="literal">FadeinOutManager</code> C# script in the root of your project's <code class="literal">Assets\Scripts</code> folder and replace its contents with the following code to create a singleton manager that can be used by any scene: </p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class FadeInOutManager : Singleton&lt;FadeInOutManager&gt;{
// guarantee this will be always a singleton only – 
// can't use the constructor!
  protected FadeInOutManager() { } 
}</pre></div><p>With this in place, we can start building the manager. First, start off with some properties as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  // The texture to display when fading
  private Material fadeMaterial;
  // Fading parameters
  private float fadeOutTime, fadeInTime;
  private Color fadeColor;
 
  //Place holder for the level you will be navigating to 
//(by name or index)
  private string navigateToLevelName = "";
  private int navigateToLevelIndex = 0;
 
  //State to control if a level is fading or not, 
  //including public property if access through code
  private bool fading = false;
  public static bool Fading
  {
    get { return Instance.fading; }
  }</pre></div><p>The properties are documented and used to control how long the fade should last when leaving the current scene into the next; there is an additional <code class="literal">Material</code> property so that you can use <a id="id558" class="indexterm"></a>different textures to display on the screen when fading (maybe your game logo). Finally, there are some tracking properties if you are using the class to navigate scenes by index or scene name.</p><p>With the<a id="id559" class="indexterm"></a> properties in place, we now need the following initialization code:</p><div class="informalexample"><pre class="programlisting">  void Awake () {
    //Setup a default blank texture for fading if none is supplied
    fadeMaterial = new Material("Shader \"Plane/No zTest\" {" +
      "SubShader { Pass { " +
      "    Blend SrcAlpha OneMinusSrcAlpha " +
      "    ZWrite Off Cull Off Fog { Mode Off } " +
      "    BindChannels {" +
      "      Bind \"color\", color }" +
      "} } }");
  }</pre></div><p>In the previous code, we are simply setting up a default fading material in case you don't pass one as a parameter.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note81"></a>Note</h3><p>At the moment, this material would be overwritten the first time the manager is used to fade with a new material (defaults to the last material used). If you want to apply a material in the editor or use a prefab material, then remove or update this section of code.</p></div><p>Next, as we <a id="id560" class="indexterm"></a>need to draw our fading image (the image is a part of the material, even if it's only a black color) to the whole screen, we are going to need a little helper function to do that using some of Unity's primitive drawing functions.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note82"></a>Note</h3><p>Primitives, in graphics terms, refers to when you manually draw lines, quads, or shapes <a id="id561" class="indexterm"></a>using manually-created vertexes, vertices, and indexes. For more information about the editor, visit <a class="ulink" href="https://docs.Unity3D.com/Documentation/Manual/PrimitiveObjects.html" target="_blank">https://docs.Unity3D.com/Documentation/Manual/PrimitiveObjects.html</a>. For<a id="id562" class="indexterm"></a> more information on using the low-level graphics library in scripting, visit <a class="ulink" href="https://docs.Unity3D.com/Documentation/ScriptReference/GL.html" target="_blank">https://docs.Unity3D.com/Documentation/ScriptReference/GL.html</a>.</p></div><p>Now, you can create a new C# class to hold the following <code class="literal">drawing</code> function if you wish, but I have simply appended it to the <code class="literal">FadeInOutManager</code> script. Use whichever method suits you; I kept it in <code class="literal">FadeInOutManager</code> because it's integral to the operation of that function. It's still static, so it is still reusable wherever I need it. The code of the required class is as follows:</p><div class="informalexample"><pre class="programlisting">public static class DrawingUtilities
{
  //Helper utility to draw a full screen texture
  public static void DrawQuad(
    Material aMaterial, 
    Color aColor, 
    float aAlpha)
  {
    aColor.a = aAlpha;
    aMaterial.SetPass(0);
    GL.PushMatrix();
    GL.LoadOrtho();
    GL.Begin(GL.QUADS);
    GL.Color(aColor);
    GL.Vertex3(0, 0, -1);
    GL.Vertex3(0, 1, -1);
    GL.Vertex3(1, 1, -1);
    GL.Vertex3(1, 0, -1);
    GL.End();
    GL.PopMatrix();
  }
}</pre></div><p>This is just a <a id="id563" class="indexterm"></a>very basic function using the low-level graphics library (the GL library, more information about this library can be found at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GL.html" target="_blank">http://docs.unity3d.com/ScriptReference/GL.html</a>) to define a simple 2D plane that will be<a id="id564" class="indexterm"></a> displayed in front of the camera. On that plane, I set the material/texture that will be drawn with it and then adjust the alpha (transparency) of the plane. To see how this is used, let's add the following core fading coroutine to the manager:</p><div class="informalexample"><pre class="programlisting">  private IEnumerator Fade()
  {
    float t = 0.0f;
    while (t &lt; 1.0f)
    {
      yield return new WaitForEndOfFrame();
      t = Mathf.Clamp01(
        t + Time.deltaTime / fadeOutTime);
          DrawingUtilities.DrawQuad(
            fadeMaterial, 
            fadeColor, 
            t);
    }
    if (navigateToLevelName != "")
      Application.LoadLevel(navigateToLevelName);
    else
      Application.LoadLevel(navigateToLevelIndex);
    while (t &gt; 0.0f)
    {
      yield return new WaitForEndOfFrame();
      t = Mathf.Clamp01(t -                   Time.deltaTime / fadeInTime);
      DrawingUtilities.DrawQuad(
        fadeMaterial,
        fadeColor,
        t);
    }
    fading = false;
  }</pre></div><p>This coroutine is <a id="id565" class="indexterm"></a>very simple and yet so powerful; walking through it, what happens is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>When the fade starts, we define a fading value and set it to zero.</p></li><li><p>Then, we run a while loop that runs until our fade value is <code class="literal">1</code> (full fade). In this loop, we perform the following actions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Wait for the last frame to be drawn (keeps it smooth)</p></li><li style="list-style-type: disc"><p>Update our fade value based on how much time has passed against how long the fade should last</p></li><li style="list-style-type: disc"><p>We use the <code class="literal">Mathf.Clamp01</code> function to ensure the value does not go <a id="id566" class="indexterm"></a>above a certain range, limiting it to a maximum value</p></li><li style="list-style-type: disc"><p>Then, we use the drawing function we created earlier to draw a plane/quad to the screen using our fading value as the alpha value</p></li></ul></div></li><li><p>When fading out has completed, we load the next level as normal. However, we check whether we have used an index or a name for the scene selection.</p></li><li><p>Finally, we repeat step 2, but this time fading in instead of out by looping our fading value to 0.</p></li><li><p>When finished, we set the fading flag to <code class="literal">false</code> to indicate that the script execution is complete.</p></li></ol></div><p>Now, it is <a id="id567" class="indexterm"></a>very important how we launch this coroutine because it could be interrupted at any time, either by exiting the game or by another fade being requested before the last fade finished. To be able to stop it from anywhere in the game, we need to ensure it is only launched using its string name. This allows us to use the <code class="literal">StopAllCoroutines</code> function<a id="id568" class="indexterm"></a> to kill it.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip45"></a>Tip</h3><p>As stated in the previous chapter, if you have long running coroutines, always ensure they can be started using their string names. Use method/delegate names only for short-lived coroutines.</p></div><p>All that's left to<a id="id569" class="indexterm"></a> complete our <code class="literal">FadeInOutManager</code> script is the public function that scenes will be able to use to kick off the process. The code for this script is as follows:</p><div class="informalexample"><pre class="programlisting">private void StartFade(
  float aFadeOutTime, 
  float aFadeInTime, 
  Color aColor)
{
  fading = true;
  Instance.fadeOutTime = aFadeOutTime;
  Instance.fadeInTime = aFadeInTime;
  Instance.fadeColor = aColor;
  StopAllCoroutines();
  StartCoroutine("Fade");
}</pre></div><p>As you can see, when fading starts, we set the flag to denote fading has started, capture the values for the manager used to control the fading motion, stop any existing coroutines from running that might be from the existing scene or a previous fading action, and kick off the <code class="literal">Fade</code> coroutine.</p><p>Then, we need the following public static (available anywhere) function that you can use to start the level fading process:</p><div class="informalexample"><pre class="programlisting">public static void FadeToLevel(
  string aLevelName, 
  float aFadeOutTime, 
  float aFadeInTime, 
  Color aColor)
{
  if (Fading) return;
  Instance.navigateToLevelName = aLevelName;
  Instance.StartFade(aFadeOutTime, aFadeInTime, aColor);
}</pre></div><p>I've included <a id="id570" class="indexterm"></a>many more overloads for the manager in the sample project. So, it is as flexible as it needs to be for the game, including the ability to pass a material to change the fading image, specify alternate fading values, or fade to another level by index instead of name.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec50"></a>Updating level loading to use fading</h4></div></div></div><p>Next, in order<a id="id571" class="indexterm"></a> to actually navigate to the<a id="id572" class="indexterm"></a> world, we need to enable our <code class="literal">NavigationManager</code> script<a id="id573" class="indexterm"></a> to actually load our next scene and use the new <code class="literal">FadeInOutManager</code> to transition smoothly.</p><p>So, open up the <code class="literal">NavigationManager</code> script in <code class="literal">Assets\Scripts\Navigation</code> and look for the following lines:</p><div class="informalexample"><pre class="programlisting">    public static void NavigateTo(string destination)
    {
        //Application.LoadLevel(destination); &lt;- commented out for now as we have nowhere to go :D
    }</pre></div><p>Update the previous lines with the following lines:</p><div class="informalexample"><pre class="programlisting">    public static void NavigateTo(string destination)
    {
        FadeInOutManager.FadeToLevel(
          destination, 
          2f, 
          2f, 
          Color.black); 
    }</pre></div><p>Now, if you return to the town scene and run it and try to leave the town for the Big Bad world, it will fail—but in a nice way.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note83"></a>Note</h3><p>If you still have the messaging scripts attached to the <code class="literal">RightBorder</code> game object (the right-most bounds of the town), you'll notice a Greybeards conversation will start. This is because of the simplistic nature of the messaging system. Just remove the scripts from that object for now to stop that.</p></div><p>The <a id="id574" class="indexterm"></a>reason is simple, because we haven't told <a id="id575" class="indexterm"></a>Unity we have any scenes in our<a id="id576" class="indexterm"></a> game yet. You have only been effectively testing whatever scene you have been in at the moment.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec79"></a>Updating build settings to include new scenes</h3></div></div></div><p>To add new <a id="id577" class="indexterm"></a>scenes, we need to set up the Build Settings options for our project to tell it we have some additional scenes to choose from. Open <span class="strong"><strong>Build Settings</strong></span> by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Build Settings</strong></span> from the main menu or use <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>B</em></span> on the keyboard. The <span class="strong"><strong>Build Settings</strong></span> window looks as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_11.jpg" /></div><p>From <a id="id578" class="indexterm"></a>here, you control how each platform will be built and what is contained within the build. It's also used to change the default editor settings and screen aspects (as described in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>The Game World</em></span>) that are available. We will cover more on this later in <a class="link" href="#" linkend="ch12">Chapter 12</a>, <span class="emphasis"><em>Deployment and Beyond</em></span>, when we start building for platforms such as Windows, Windows Phone, iOS, or Android.</p><p>As you can<a id="id579" class="indexterm"></a> see in the following screenshot, the <span class="strong"><strong>Scenes In Build</strong></span> list is currently empty. So when we run the game, it will just run the current scene in the editor. To update this list, either drag the scenes from the project hierarchy or use the <span class="strong"><strong>Add Current</strong></span> button to add the scene you are currently viewing. So, add the two current scenes into the <span class="strong"><strong>Scenes In Build</strong></span> list as shown here:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_06_12.jpg" /></div><p>Now, one important thing to note is the order of the scenes. As you may expect, Unity will always start the project with scene <span class="strong"><strong>0</strong></span>, so be sure that the town is the first scene in the list. You can do this by simply dragging the scenes up or down.</p><p>Now, when you start the game from the town and run screaming from the town, you will nicely fade out from the town into the Big Bad world.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip46"></a>Tip</h3><p>This ordering of scenes is very useful and powerful. Some developers like to put levels in order so that they can use the index to progress through.</p><p>However, another trick if you are having trouble with a particular scene in your game when running on a device is to reorder the scenes in the build so that the troublesome one is the starting scene. This saves you from having to keep playing through till you get to that scene or writing code to accelerate you. Granted, you need to ensure whatever settings required for the scene are set on load if you debug this way.</p></div></div></div>