<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec26"></a>Working with the camera</h2></div></div><hr /></div><p>If you try <a id="id355" class="indexterm"></a>and move the player left and right at the moment, our hero happily bobs along. However, you will quickly notice that we run into a problem: the hero soon disappears from the edge of the screen. To solve this, we need to make the camera follow the hero.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip21"></a>Tip</h3><p>When creating new scripts to implement something, remember that just about every game that has been made with Unity has most likely implemented either the same thing or something similar. Most just get on with it, but others and the Unity team themselves are keen to share their scripts to solve these challenges. So in most cases, we will have something to work from. Don't just start a script from scratch (unless it is a very small one to solve a tiny issue) if you can help it; here's some resources to get you started:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Unity<a id="id356" class="indexterm"></a> sample projects: <a class="ulink" href="http://unity3d.com/learn/tutorials/modules" target="_blank">http://unity3d.com/learn/tutorials/modules</a></p></li><li style="list-style-type: disc"><p>Unity <a id="id357" class="indexterm"></a>Patterns: <a class="ulink" href="http://unitypatterns.com/" target="_blank">http://unitypatterns.com/</a></p></li><li style="list-style-type: disc"><p>Unity wiki<a id="id358" class="indexterm"></a> scripts section: <a class="ulink" href="http://wiki.Unity3d.com/index.php/Scripts" target="_blank">http://wiki.Unity3d.com/index.php/Scripts</a> (also check other stuff for detail)</p></li></ul></div><p>Once you become more experienced, it is better to just use these scripts as a reference and try to create your own and improve on them, unless they are from a maintained library such as <a class="ulink" href="https://github.com/nickgravelyn/UnityToolbag" target="_blank">https://github.com/nickgravelyn/UnityToolbag</a>.</p></div><p>To make<a id="id359" class="indexterm"></a> the camera follow the players, we'll take the script from the Unity 2D sample and modify it to fit in our game. This script is nice because it also includes a Mario style buffer zone, which allows the players to move without moving the camera until they reach the edge of the screen.</p><p>Create a new script called <code class="literal">FollowCamera</code> in <code class="literal">Assets\Scripts</code>, remove the <code class="literal">Start</code> and <code class="literal">Update</code> functions, and then add the following properties:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class FollowCamera : MonoBehaviour {

  // Distance in the x axis the player can move before the
  // camera follows.
  public float xMargin = 1.5f;

  // Distance in the y axis the player can move before the 
  // camera follows.
  public float yMargin = 1.5f;

  // How smoothly the camera catches up with its target 
  // movement in the x axis.
  public float xSmooth = 1.5f;

  // How smoothly the camera catches up with its target
  // movement in the y axis.
  public float ySmooth = 1.5f;

  // The maximum x and y coordinates the camera can have.
  public Vector2 maxXAndY;

  // The minimum x and y coordinates the camera can have.
  public Vector2 minXAndY;

  // Reference to the player's transform.
  public Transform player;
}</pre></div><p>The variables<a id="id360" class="indexterm"></a> are all commented to explain their purpose, but we'll cover each as we use them.</p><p>First off, we need to get the player object's position so that we can track the camera to it by discovering it from the object it is attached to. This is done by adding the following code in the <code class="literal">Awake</code> function:</p><div class="informalexample"><pre class="programlisting">    void Awake()
    {
        // Setting up the reference.
        player = GameObject.Find("Player").transform;
  if (player == null)
  {
    Debug.LogError("Player object not found");
  }

    }</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Tip</h3><p>An alternative to discovering the player this way is to make the player property <code class="literal">public</code> and then assign it in the editor. There is no right or wrong way—just your preference.</p><p>It is also a good practice to add some element of debugging to let you know if there is a problem in the scene with a missing reference, else all you will see are errors such as object not initialized or variable was null.</p></div><p>Next, we need a couple of helper methods to check whether the player has moved near the edge of the camera's bounds as defined by the <span class="strong"><strong>Max X and Y</strong></span> variables. In the following code, we will use the settings defined in the preceding code to control how close you can get to the end result:</p><div class="informalexample"><pre class="programlisting">    bool CheckXMargin()
    {
        // Returns true if the distance between the camera and the
  // player in the x axis is greater than the x margin.
        return Mathf.Abs
(transform.position.x - player.position.x) &gt; xMargin;
    }
 
    bool CheckYMargin()
    {
        // Returns true if the distance between the camera and the
  // player in the y axis is greater than the y margin.
        return Mathf.Abs
(transform.position.y - player.position.y) &gt; yMargin;
    }</pre></div><p>To finish this <a id="id361" class="indexterm"></a>script, we need to check each frame when the scene is drawn to see whether the player is close to the edge and update the camera's position accordingly. Also, we need to check if the camera bounds have reached the edge of the screen and not move it beyond.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec44"></a>Comparing Update, FixedUpdate, and LateUpdate</h3></div></div></div><p>There is<a id="id362" class="indexterm"></a> usually a lot of <a id="id363" class="indexterm"></a>debate<a id="id364" class="indexterm"></a> about which update method <a id="id365" class="indexterm"></a>should<a id="id366" class="indexterm"></a> be <a id="id367" class="indexterm"></a>used within<a id="id368" class="indexterm"></a> a <a id="id369" class="indexterm"></a>Unity game. To put it simply, the <code class="literal">FixedUpdate</code> method is <a id="id370" class="indexterm"></a>called on a regular basis throughout the lifetime of the<a id="id371" class="indexterm"></a> game and is generally used for physics and<a id="id372" class="indexterm"></a> time sensitive code. The <code class="literal">Update</code> method, however, is only called after the end of each frame that is drawn to the screen, as the time taken to draw the screen can vary (due to the number of objects to be drawn and so on). So, the <code class="literal">Update</code> call ends up being fairly irregular.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note32"></a>Note</h3><p>For more detail on the difference between <code class="literal">Update</code> and <code class="literal">FixedUpdate</code> see the Unity Learn tutorial video at <a class="ulink" href="http://unity3d.com/learn/tutorials/modules/beginner/scripting/update-and-fixedupdate" target="_blank">http://unity3d.com/learn/tutorials/modules/beginner/scripting/update-and-fixedupdate</a>.</p></div><p>As the player is being moved by the physics system, it is better to update the camera in the <code class="literal">FixedUpdate</code> method:</p><div class="informalexample"><pre class="programlisting"> void FixedUpdate()
    {
        // By default the target x and y coordinates of the camera
        // are it's current x and y coordinates.
        float targetX = transform.position.x;
        float targetY = transform.position.y;
 
        // If the player has moved beyond the x margin...
        if (CheckXMargin())
            // the target x coordinate should be a Lerp between
            // the camera's current x position and the player's
 // current x position.
            targetX = Mathf.Lerp(transform.position.x,
 player.position.x, xSmooth * 
Time.fixedDeltaTime ); 
        // If the player has moved beyond the y margin...
        if (CheckYMargin())
            // the target y coordinate should be a Lerp between
            // the camera's current y position and the player's
            // current y position.
            targetY = Mathf.Lerp(transform.position.y,
              player.position.y, ySmooth * 
                Time. fixedDeltaTime );
 
        // The target x and y coordinates should not be larger
        // than the maximum or smaller than the minimum.
        targetX = Mathf.Clamp(targetX, minXAndY.x, maxXAndY.x);
        targetY = Mathf.Clamp(targetY, minXAndY.y, maxXAndY.y);

        // Set the camera's position to the target position with
        // the same z component.
        transform.position = 
         new Vector3(targetX, targetY, transform.position.z);
    }</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"></a>Tip</h3><p>As they say, every game is different and how the camera acts can be different for every game. In a lot of cases, the camera should be updated in the <code class="literal">LateUpdate</code> method<a id="id373" class="indexterm"></a> after all drawing, updating, and physics are complete. This, however, can be a double-edged sword if you rely on math calculations that are affected in the <code class="literal">FixedUpdate</code> method, such as Lerp. It all comes down to tweaking your camera system to work the way you need it to do.</p></div><p>Once <a id="id374" class="indexterm"></a>the <a id="id375" class="indexterm"></a>script<a id="id376" class="indexterm"></a> is <a id="id377" class="indexterm"></a>saved, just<a id="id378" class="indexterm"></a> attach<a id="id379" class="indexterm"></a> it<a id="id380" class="indexterm"></a> to <a id="id381" class="indexterm"></a>the <span class="strong"><strong>Main Camera</strong></span> element by dragging the script to it or by <a id="id382" class="indexterm"></a>adding a script component to the camera and selecting the script.</p><p>Finally, we just need to configure the script and the camera to fit our game size as follows:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_18.jpg" /></div><p>Set the orthographic <span class="strong"><strong>Size</strong></span> of the camera to <code class="literal">2.7</code> and the <span class="strong"><strong>Min X</strong></span> and <span class="strong"><strong>Max X</strong></span> sizes to <code class="literal">5</code> and <code class="literal">-5</code> respectively.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec45"></a>The perils of resolution</h3></div></div></div><p>When dealing<a id="id383" class="indexterm"></a> with cameras, there is always one thing that will trip us up as soon <a id="id384" class="indexterm"></a>as we try to build for another platform—resolution.</p><p>By default, the Unity player in the editor runs in the <span class="strong"><strong>Free Aspect</strong></span> mode as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_19.jpg" /></div><p>The <span class="strong"><strong>Aspect</strong></span> mode (from the <span class="strong"><strong>Aspect</strong></span> drop-down) can be changed to represent the resolutions<a id="id385" class="indexterm"></a> supported by each platform you can target. The following is<a id="id386" class="indexterm"></a> what you get when you switch your build target to each platform:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_20.jpg" /></div><p>To change<a id="id387" class="indexterm"></a> the build target, go into your project's <span class="strong"><strong>Build Settings</strong></span> by <a id="id388" class="indexterm"></a>navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Build Settings</strong></span> or by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>B</em></span>, then select a platform and click on the <span class="strong"><strong>Switch Platform</strong></span> button. This is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_26.jpg" /></div><p>When you <a id="id389" class="indexterm"></a>change the <span class="strong"><strong>Aspect</strong></span> drop-down to view in one of these resolutions, you<a id="id390" class="indexterm"></a> will notice how the aspect ratio for what is drawn to the screen changes by either stretching or compressing the visible area. If you run the editor player in full screen by clicking on the <span class="strong"><strong>Maximize on Play</strong></span> button (<span class="inlinemediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_27.jpg" /></span>) and then clicking on the play icon, you will see this change more clearly. Alternatively, you can run your project on a target device to see the proper perspective output.</p><p>The reason I bring this up here is that if you used fixed bounds settings for your camera or game objects, then these values may not work for every resolution, thereby putting your settings <a id="id391" class="indexterm"></a>out of range or (in most cases) too undersized. You can handle<a id="id392" class="indexterm"></a> this by altering the settings for each build or <a id="id393" class="indexterm"></a>using <span class="strong"><strong>compiler predirectives</strong></span> such as <code class="literal">#if UNITY_METRO</code> to force the default depending on the build (in this example, Windows 8).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note33"></a>Note</h3><p>You can read more about compiler predirectives in <a class="link" href="#" linkend="ch12">Chapter 12</a>, <span class="emphasis"><em>Deployment and Beyond</em></span>. Alternatively<a id="id394" class="indexterm"></a>, check the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/PlatformDependentCompilation.html" target="_blank">http://docs.unity3d.com/Manual/PlatformDependentCompilation.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec46"></a>A better FollowCamera script</h3></div></div></div><p>If you are <a id="id395" class="indexterm"></a>only targeting one device/resolution or your background<a id="id396" class="indexterm"></a> scrolls indefinitely, then the preceding manual approach works fine. However, if you want it to be a little more dynamic, then we need to know what resolution we are working in and how much space our character has to travel. We will perform the following steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We will change the <code class="literal">min</code> and <code class="literal">max</code> variables to <code class="literal">private</code> as we no longer need to configure them in the <span class="strong"><strong>Inspector</strong></span> window. The code is as follows:</p><div class="informalexample"><pre class="programlisting">    // The maximum x and y coordinates the camera can have.
    private Vector2 maxXAndY;

    // The minimum x and y coordinates the camera can have.
    private Vector2 minXAndY;</pre></div></li><li><p>To work out how much space is available in our town, we need to interrogate the rendering size of our background sprite. So, in the <code class="literal">Awake</code> function, we add the following lines of code:</p><div class="informalexample"><pre class="programlisting">    // Get the bounds for the background texture - world size
    var backgroundBounds = GameObject.Find("background").renderer.bounds;</pre></div></li><li><p>In the <code class="literal">Awake</code> function, we <a id="id397" class="indexterm"></a>work out our resolution and viewable space by interrogating the <code class="literal">ViewPort</code> method on the camera and converting it to the same coordinate type as the sprite. This is done using the following code:</p><div class="informalexample"><pre class="programlisting">    // Get the viewable bounds of the camera in world 
    // coordinates
    var camTopLeft = camera.ViewportToWorldPoint(new Vector3(0, 0, 0));
    var camBottomRight = camera.ViewportToWorldPoint(new Vector3(1, 1, 0));</pre></div></li><li><p>Finally, in the <code class="literal">Awake</code> function, we update the <code class="literal">min</code> and <code class="literal">max</code> values using the texture size and camera real-world bounds. This is done using the following lines of code:</p><div class="informalexample"><pre class="programlisting">    // Automatically set the min and max values
    minXAndY.x = backgroundBounds.min.x - camTopLeft.x;
    maxXAndY.x = backgroundBounds.max.x - camBottomRight.x;</pre></div></li></ol></div><p>In the end, it is <a id="id398" class="indexterm"></a>up to your specific implementation for the type of game <a id="id399" class="indexterm"></a>you are making to decide which pattern works for your game.</p></div></div>