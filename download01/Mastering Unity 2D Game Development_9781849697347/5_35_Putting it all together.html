<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec37"></a>Putting it all together</h2></div></div><hr /></div><p>Right, after all of that "brain input", let's start applying it to our game. In this chapter, we are aiming to add an NPC or two, give them something to talk about, and maybe add some special reactions.</p><p>If you haven't done so already, import the other character sprites and set up their animations as well. You can either add them to the scene or just create some prefabs in your <span class="strong"><strong>Project</strong></span> view:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_12.jpg" /></div><p>I've added the following characters (shown in the preceding screenshot):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Greandal</strong></span> (left): This character is the local barkeeper and mayor of our lone village</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Olaf</strong></span> (right): This character is your hero's best friend and an all-round troublemaker</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Greybeard</strong></span> (center): This character is the strange wizard from the east</p></li></ul></div><p>With these characters in place, we need to start adding some character to our NPCs as well as add our hero. In <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Character Building</em></span>, we outlined some classes to describe and manage the entities in the game, so let's bring them in now.</p><p>We could also do with a little tidying up of our <code class="literal">scripts</code> folder since we are generating a lot more content now. To do this, perform the following steps:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Under <code class="literal">Assets\Scripts</code>, create four new folders: <code class="literal">Classes</code>, <code class="literal">Examples</code>, <code class="literal">Messaging</code>, and <code class="literal">Navigation</code> (the <code class="literal">Examples</code> folder isn't actually needed, but if you want to keep the code that is generated thus far in this chapter, we will place them here).</p></li><li style="list-style-type: disc"><p>Copy the <code class="literal">Entity</code> and <code class="literal">Player</code> scripts to the new <code class="literal">Classes</code> folder or create them if you haven't already.</p></li><li style="list-style-type: disc"><p>Copy the scripts from this chapter (<code class="literal">Delegates</code>, <code class="literal">Events</code>, <code class="literal">Coroutines</code>, <code class="literal">ScriptingObject</code>) to the <code class="literal">Examples</code> folder, or just delete them as they are not for the game itself. If you didn't create them, just ignore this step.</p></li><li style="list-style-type: disc"><p>Move the <code class="literal">Messaging</code> scripts to the <code class="literal">Messaging</code> folder, and likewise, the <code class="literal">Navigation</code> scripts to the <code class="literal">Navigation</code> folder.</p></li></ul></div><p>Starting with Greybeard, add him on the left-hand side of the scene, next to the cave. This is because in the next section, he is going to stop our hero from entering the cave, as it is just too dangerous for such an impetuous youth.</p><p>To do this (using the lessons we have learned already), perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new game object and name it <code class="literal">Greybeard</code>.</p></li><li><p>If you haven't done so already, import the <code class="literal">04.png</code> character spritesheet and use <span class="strong"><strong>Sprite Editor</strong></span> to slice it up.</p></li><li><p>Give it a <span class="strong"><strong>Sprite Renderer</strong></span> component using the <span class="strong"><strong>04_3</strong></span> sprite from the <span class="strong"><strong>04</strong></span> wizard's spritesheet.</p></li><li><p>Create an idle animation for Greybeard using the <span class="strong"><strong>04_03</strong></span> and <span class="strong"><strong>04_06</strong></span> sprites so it appears that Greybeard is fidgeting (optional); then, add it to a new <span class="strong"><strong>Animator</strong></span> component and add that to the Greybeard's game object.</p></li><li><p>Finally, add a <span class="strong"><strong>Box Collider 2D</strong></span> component with the settings shown in the following screenshot. This is so that the collider is of the same width as that of Greybeard himself but with a larger height so that the player can collide with it. Also, set the <span class="strong"><strong>Is Trigger</strong></span> property to true/checked.</p></li></ol></div><p>The final result should look something like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_13.jpg" /></div><p>I added an animation that shows he is fidgeting on the spot. This is just because most old wizards are very crotchety, especially when  they have to guard a cave full of dangerous monsters.</p><p>A few things to note while adding Greybeard are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If you put Greybeard on the <span class="strong"><strong>Player</strong></span> layer as I have done, the player will appear behind him. As this is not what we expect, set the sorting order for the <span class="strong"><strong>Player</strong></span> to <span class="strong"><strong>10</strong></span> so he appears in front.</p></li><li style="list-style-type: disc"><p>While running the game, if the hero bumps into Greybeard, he can fall backwards. If this happens, it is just because the <span class="strong"><strong>Player</strong></span> object does not have the <span class="strong"><strong>Fixed Angle</strong></span> parameter checked in the <span class="strong"><strong>Rigid Body 2D</strong></span> component.</p></li><li style="list-style-type: disc"><p>NPC colliders should be set to <span class="strong"><strong>Triggers</strong></span>. We want to be able to control whether the NPC should stop the player or not through the script instead of the physics system. So, on Greybeard's <span class="strong"><strong>Box Collider 2D</strong></span>, check <span class="strong"><strong>Is Trigger</strong></span>.</p></li></ul></div><p>With this done, start building up the rest of your town using the skills you have learned so far. The following screenshot is what I came up with:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_14.jpg" /></div><p>A few things to note are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Organize your game hierarchy in a sensible manner so you can quickly find the things you need to manage. In the preceding screenshot, I created empty game objects for <span class="strong"><strong>Environment</strong></span> items, such as houses and bushes. I also created an empty game object container for NPCs.</p></li><li style="list-style-type: disc"><p>Put the items on a layer that makes sense and then order the sprites on that layer appropriately.</p></li></ul></div><p>Don't spend too long crafting the animation (unless you want to); all in all, the scene in the preceding screenshot took about 10 minutes to put together.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note57"></a>Note</h3><p>If you check the sample project, I also added a pacing animation for Greandal using curves. We did this just to show how worried the mayor is about the state of affairs going on outside the town and all the rampaging beasts.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec65"></a>Getting the NPC's talking</h3></div></div></div><p>So far in this chapter, we have our populated town with characters, buildings, and so on. Therefore, let's give our hero something to talk about.</p><p>While building a conversation system for any game, there are many factors to consider, which are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>How long a conversation is going to be (we don't want the player to get bored with miles of text)?</p></li><li style="list-style-type: disc"><p>How many parties are likely to be involved in any discussion?</p></li><li style="list-style-type: disc"><p>Is this a flat one-sided conversation (such as a cutscene) or will the player be allowed to make decisions?</p></li><li style="list-style-type: disc"><p>Are there going to be branches in the conversation so that the conversation will change based on the player's response?</p></li><li style="list-style-type: disc"><p>How much content do you expect to be used in conversations (only text, video, cutscenes, animation, and so on)? All of this content will decide just how extensible your system needs to be.</p></li><li style="list-style-type: disc"><p>Will the conversation need to support any outbound triggers or states? Will the conclusion of a conversation unlock a door or grant the player with some experience or items?</p></li></ul></div><p>There are lots of other factors that will affect both the design and implementation of a robust conversation for your game, so think about it carefully before touching the code.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p><span class="strong"><strong>A working example</strong></span></p><p>For this book, we are going to build a basic conversation system that is enough to meet the goals of the project at hand. However, I am explaining each part along the way, so if you want to expand on it, you can.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec35"></a>The conversation object</h4></div></div></div><p>When we want to start talking in the game, we first need to decide what you want to include in that conversation. You can include the following things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The name of the character who is speaking</p></li><li style="list-style-type: disc"><p>The text of the conversation</p></li><li style="list-style-type: disc"><p>An image of the character talking</p></li><li style="list-style-type: disc"><p>Choices</p></li><li style="list-style-type: disc"><p>The position of chat</p></li></ul></div><p>The more you look at it, the more you can dream about what you want to include. You just need to remember the <span class="strong"><strong>KISS</strong></span> principle (<span class="strong"><strong>Keep it simple, stupid</strong></span>), that is, start small and then build on it.</p><p>So, create a new C# script, name it <code class="literal">ConversationEntry</code> in <code class="literal">Scripts\Classes</code>, and populate it with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

[System.Serializable]
public class ConversationEntry {
  public string SpeakingCharacterName;
  public string ConversationText;
  public Sprite DisplayPic;
}</pre></div><p>This gives us just the basics for our conversation system with regards to who's speaking, an optional picture that can be displayed in the conversation, and most importantly, the conversation text to be displayed.</p><p>We also tag this class with the <code class="literal">System.Serializable</code> code attribute so that the Unity serializer knows what to do with it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec36"></a>Saving and serializing the object for later</h4></div></div></div><p>With our core conversation entry object generated, we can start to store the conversations in the <code class="literal">.asset</code> files for use in our game and also make it possible to create the conversations outside of Unity if you wish.</p><p>As a conversation is (usually) more than just an opening line, we need a management object that will support several lines/entries of the conversation and a couple of switches to denote whether the conversation has already been played. This way, if you have multiple conversations configured for a character, it will simply play the next conversation and not repeat itself. You could just track this on the object where you attach the conversations to, but this is cleaner.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip34"></a>Tip</h3><p>As a rule of thumb, you should always keep flags, settings, or properties for a thing with another thing. If you start having variables to track the state of a thing elsewhere, it can get very messy. The only time this is not true is when a thing is meant to be shared across multiple objects.</p><p>Also note that the <code class="literal">ScriptableObject</code> entities are a fickle beast. They let us attach them to the game objects, and they can be automatically serialized and saved as part of the project. However, they are fixed assets that should only be edited in the editor. If you need to alter them as part of the game, you will need to save and store that change of state separately.</p><p>This is just a simple note to remember when architecting such things.</p></div><p>So, create another C# class in <code class="literal">Scripts\Classes</code> named <code class="literal">Conversation</code> and populate it with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class Conversation : ScriptableObject {

  public ConversationEntry[] ConversationLines;   
}</pre></div><p>Now the first thing you will note is that this class is derived from a scriptable object class. As described earlier, this is what enables us to use Unity's serialization methods and store them as a <code class="literal">.asset</code> file.</p><p>We are not done yet as we need that final hook to enable us to create these (at least initially) in the editor.</p><p>Earlier, I showed you all of the code needed to create the asset for serialization, but this is rather a lot of code to be generated all the time. So, it's better to place that logic in a separate helper class that we can reuse rather than repeat ourselves all the time.</p><p>Earlier, with the <code class="literal">PositionManager</code> example, we created assets in the editor and reused them. You can reuse that code if you wish, but to simplify things, I added a little helper script to the example project in <code class="literal">Assets\Scripts\Classes</code>. The <code class="literal">CustomAssetUtility</code> class does all the work that the preceding code does. It also uses the C# generics so that it can be reused for any type of <code class="literal">SerializableObject</code> you want to throw at it. You don't have to use the class I provided; you can just use the code earlier instead if you wish, just replace the code where the helper function is used.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note59"></a>Note</h3><p>The C# generics is a fairly advanced C# topic, which we won't go into in this book. If you want to know more, check out <a class="ulink" href="http://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx</a>; alternatively, it will be better to try <span class="emphasis"><em>The C# Programming Yellow Book</em></span>, <span class="emphasis"><em>Rob Miles</em></span>, <span class="emphasis"><em>Department of Computer Science</em></span>, <span class="emphasis"><em>The University of Hull</em></span>, which is a fantastic C# primer book available at <a class="ulink" href="http://www.robmiles.com/c-yellow-book/" target="_blank">http://www.robmiles.com/c-yellow-book/</a>.</p></div><p>To show how we use this, let's create our editor script, which will create the conversation assets for us. Create a new folder in <code class="literal">Assets\Scripts</code> named <code class="literal">Editor</code>. In this folder, create a new script named <code class="literal">ConversationAssetCreator</code> in the <code class="literal">Editor</code> folder under <code class="literal">Assets\Scripts</code> and then replace its contents with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEditor;
using UnityEngine;

public class ConversationAssetCreator : MonoBehaviour {

  [MenuItem("Assets/Create/Conversation")]
  public static void CreateAsset()
  {
    CustomAssetUtility.CreateAsset&lt;Conversation&gt;();
  }
}</pre></div><p>So, by using the helper function, instead of all the tangle of code to first generate our asset and then save it, we simply call our utility, tell it the type of asset we want to create (in angle brackets), and away it goes. I have crated the utility as well so that it can also take a string parameter if you want to force the folder you want to create the asset in; otherwise, it will take whatever is currently selected in the editor.</p><p>To test this out, create a new folder in the <code class="literal">Asset</code> folder named <code class="literal">Resources</code> (so we can call assets directly from the code if we so wish) and then create another folder in <code class="literal">Resources</code> named <code class="literal">Conversations</code>. This just keeps all our conversations in one place and doesn't clutter up the hierarchy. If you so wish, you could create further subfolders to identify characters, places, or whatever else you fancy. It won't have an impact on the running of the game; it will just keep it tidy.</p><p>With the <code class="literal">Conversation</code> folder under <code class="literal">Assets\Resources\</code> selected, click on <span class="strong"><strong>Create</strong></span> in the <span class="strong"><strong>Project</strong></span> menu and you should see a new option named <span class="strong"><strong>Conversation</strong></span> (as you can see in the script earlier, this is what we named it as). When you click on it, a new <span class="strong"><strong>Conversation</strong></span> asset should appear, as shown in the following screenshot, which is ready for you to start configuring:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_15.jpg" /></div><p>Feel free to set up your new conversation in whichever way you like or check the sample in the project I've created for Greybeard. Name the conversation <code class="literal">GreybeardWarning</code> and give it the lines shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_16.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec37"></a>The Conversation Component</h4></div></div></div><p>The last thing we need is a simple component to be able to attach conversations to a character or other game object in keeping with the Unity-component-based way of building games.</p><p>So, create a new class in the <code class="literal">Classes</code> folder under <code class="literal">Assets\Scripts</code> named <code class="literal">ConversationComponent</code> and replace its contents with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class ConversationComponent : MonoBehaviour {

  public Conversation[] Conversations;

}</pre></div><p>Nothing's complicated for now; the preceding code just holds an array of the possible conversations that the game object can have. Ideally, you would want to expand on this for a fuller conversation system, such as a pointer to the next conversation, or a way to track how many conversations have taken place, and so on.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec66"></a>Building a basic conversation system</h3></div></div></div><p>In order for our conversation assets to be of any use, we need a mechanism to play these conversations on the screen and have the user interact with them (if that's how your game rolls). For this, we need another manager that will take in conversations from characters and display them on the screen. If we had any logic, branching, or decisions in our conversations, it will handle those too.</p><p>Now, there are two basic approaches that we could take with the conversation system: one being reactive (where we use a messaging system to notify the manager that a conversation needs to take place) and one being just a utility (where scripts can request for a conversation to take place). Both are valid approaches, and it really comes down to personal preference as to which one you want to implement. To keep things simple, let's create the basic utility first and then point out where it can be enhanced.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec38"></a>The manager</h4></div></div></div><p>If we create our conversation manager as we did before with the messaging manager, we start with the simple singleton framework. However, we will lean on one of the great examples from <span class="strong"><strong>Unity Wiki</strong></span> as our base.</p><p>In the sample project under <code class="literal">Assets\Scripts\Classes</code>, you will find a <code class="literal">Singleton</code> class that was sourced from <a class="ulink" href="http://wiki.unity3d.com/index.php/Singleton" target="_blank">http://wiki.unity3d.com/index.php/Singleton</a>. This simply saves us time and code while creating singleton objects for use in our games and ensures they always have the same consistency.</p><p>With this in place, we can define our <code class="literal">Conversation</code> manager quite simply. Create a new C# script in <code class="literal">Assets\Scripts</code> named <code class="literal">ConversationManager</code> and replace its contents with the following code:</p><div class="informalexample"><pre class="programlisting">using System.Collections;
using UnityEngine;

public class ConversationManager : Singleton&lt;ConversationManager &gt;
{
  //Guarantee this will always be a singleton only – 
  //can't use the constructor!
  protected ConversationManager () {} 

}</pre></div><p>Now that we have our manager, we can start adding functionalities to it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec39"></a>Starting a conversation</h4></div></div></div><p>We want it to take a conversation item we have and do something with it because we have a manager. So, create a new function as follows:</p><div class="informalexample"><pre class="programlisting">public void StartConversation(Conversation conversation)
{}</pre></div><p>This enables us to start a new conversation anywhere in the code by using the following code:</p><div class="informalexample"><pre class="programlisting">ConversationManager.Instance.StartConversation(conversation);</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec40"></a>Displaying the conversation</h4></div></div></div><p>The manager is in place and we have a method to start a conversation, but it's not doing much right now. So, let's add some simple logic to display the text of the conversation on the screen. We will keep it simple since we are going to look into more complex GUI-related functionalities in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Shopping for Weapons</em></span>.</p><p>Starting things off, we need some new properties in <code class="literal">ConversationManager</code> to control what needs to be displayed. So, open up the <code class="literal">ConversationManager</code> script and add the following properties to it:</p><div class="informalexample"><pre class="programlisting">//Is there a conversation going on
bool talking = false;

//The current line of text being displayed
ConversationEntry currentConversationLine;

//Estimated width of characters in the font
int fontSpacing = 7;

//How wide does the dialog window need to be
int conversationTextWidth;

//How high does the dialog window need to be
int dialogHeight = 70;</pre></div><p>Each property explains its use, but everything will become clear as we add the rest of the functionality. Next, we'll add a Coroutine that will take a <code class="literal">Conversation</code> object and loop through all the lines to be displayed. Add the following function to the <code class="literal">ConversationManager</code> script:</p><div class="informalexample"><pre class="programlisting">IEnumerator DisplayConversation(Conversation conversation)
{
  talking = true;
  foreach (var conversationLine in conversation.ConversationLines)
  {
    currentConversationLine = conversationLine;
    conversationTextWidth = currentConversationLine.ConversationText.Length * fontSpacing;
    yield return new WaitForSeconds(3);
  }
  talking = false;
}</pre></div><p>This simple Coroutine takes the conversation passed to it and loops through each of the individual lines of the conversation's text. Before we start, we set the <code class="literal">talking</code> flag to denote that a conversation is in progress; then, for each conversation line, we perform the following tasks:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Set a pointer to the current conversation item in the list with the <code class="literal">currentConversationLine</code> property</p></li><li style="list-style-type: disc"><p>Figure out how long the text is to gauge how big our display area needs to be</p></li><li style="list-style-type: disc"><p>Wait for three seconds before moving on to the next conversation item</p></li><li style="list-style-type: disc"><p>When we run out of conversation lines, we set the <code class="literal">talking</code> flag to <code class="literal">false</code> to show that we have finished</p></li></ul></div><p>So, we have a Coroutine looping through the text. The next thing to do is to use this information to display it on the screen. For this, we need an <code class="literal">OnGUI</code> method in our script as follows:</p><div class="informalexample"><pre class="programlisting">void OnGUI()
{
  if (talking)
  {
    //Layout start
    GUI.BeginGroup(new Rect(Screen.width / 2 - conversationTextWidth / 2, 50, conversationTextWidth + 10, dialogHeight));

    //The background box
    GUI.Box(new Rect(0, 0, conversationTextWidth + 10, dialogHeight), "");

    //The character name
    GUI.Label(new Rect(10, 10, conversationTextWidth + 30, 20), currentConversationLine.SpeakingCharacterName);

    //The conversation text
    GUI.Label(new Rect(10, 30, conversationTextWidth + 30, 20), currentConversationLine.ConversationText);

    //Layout end
    GUI.EndGroup();
  }
}</pre></div><p>Like the navigation prompt in the previous chapter, we simply draw a GUI region, give it a background texture with the box using the default style, and then show two labels: one for the character who is speaking and one for the text of the conversation.</p><p>So, when the <code class="literal">talking</code> flag is set, Unity will know that it has to start drawing our conversation GUI on the screen.</p><p>To finish this off, we need to call the Coroutine from our <code class="literal">public</code> method, which other scripts can use to start a conversation:</p><div class="informalexample"><pre class="programlisting">public void StartConversation(Conversation conversation)
{
  //Start displaying the supplied conversation
  if (!talking)
  {
    StartCoroutine(DisplayConversation(conversation));
  }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec41"></a>Adding more</h4></div></div></div><p>There are two simple areas where we can take this further. We can use the sprite image and the style that we specified in the conversation item.</p><p>Adding the image is fairly simple; we just need to create enough space to display the image and then draw it.</p><p>Sadly, one of the areas that the new sprite system has not been merged with is the existing GUI system. It still relies on textures and not sprites. We can still work with it, but it means we have to select the sprite's texture from the spritesheet manually while drawing images. To do this, we use the <code class="literal">DrawTextureWithTexCoords</code> GUI function.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip35"></a>Tip</h3><p>A word of warning though: the <code class="literal">DrawTextureWithTexCoords</code> function uses scaled coordinates while picking the section of the image you want to display. This usually trips up developers as it is not very well documented. The coordinates in the <span class="strong"><strong>Sprite</strong></span> object are not scaled, so you have to convert them manually.</p></div><p>First, add a couple of properties to display the image using the following code:</p><div class="informalexample"><pre class="programlisting">//Offset space needed for character image
public int displayTextureOffset = 70;

//Scaled image rectangle for displaying character image
Rect scaledTextureRect;</pre></div><p>The offset is to create space within our display region for the image, whereas the other property is to hold the scaling information to indicate that we need to pick our sprite from the spritesheet since the Unity system doesn't handle sprites.</p><p>Next, we need to calculate the scaling factor for the image for each conversation line, just in case we are using different sizes of textures for each character in the conversation. So, update the <code class="literal">DisplayConversation</code> Coroutine method with the following code:</p><div class="informalexample"><pre class="programlisting">IEnumerator DisplayConversation(Conversation conversation)
{
  talking = true;
  foreach (var conversationLine in conversation.ConversationLines)
  {
    currentConversationLine = conversationLine;
    conversationTextWidth = currentConversationLine.ConversationText.Length * fontSpacing;

    scaledTextureRect = new Rect( currentConversationLine.DisplayPic.textureRect.x / currentConversationLine.DisplayPic.texture.width,

      currentConversationLine.DisplayPic.textureRect.y / currentConversationLine.DisplayPic.texture.height,

      currentConversationLine.DisplayPic.textureRect.width / currentConversationLine.DisplayPic.texture.width,

      currentConversationLine.DisplayPic.textureRect.height / currentConversationLine.DisplayPic.texture.height);

    yield return new WaitForSeconds(3);
  }
  talking = false;
  yield return null;
}</pre></div><p>Lastly, we just need to update the <code class="literal">OnGUI</code> method to make space for the image using the <code class="literal">offset</code> method and then add it to the draw list as follows:</p><div class="informalexample"><pre class="programlisting">void OnGUI()
{
  if (talking)
  {
    //Layout start
    GUI.BeginGroup(new Rect(Screen.width / 2 - conversationTextWidth / 2, 50, conversationTextWidth + displayTextureOffset + 10,dialogHeight));

    //The background box
    GUI.Box(new Rect(0, 0, conversationTextWidth + displayTextureOffset + 10,dialogHeight), "");

    //The character name
    GUI.Label(new Rect(displayTextureOffset, 10, conversationTextWidth + 30, 20), currentConversationLine.SpeakingCharacterName);

    //The conversation text
    GUI.Label(new Rect(displayTextureOffset, 30, conversationTextWidth + 30, 20), currentConversationLine.ConversationText);

    //The character image
    GUI.DrawTextureWithTexCoords(new Rect(10, 10, 50, 50), currentConversationLine.DisplayPic.texture, scaledTextureRect);

    //Layout end
    GUI.EndGroup(); 
  }
}</pre></div><p>Note that the use of the <code class="literal">DrawTextureWithTexCoords</code> function and not the standard <code class="literal">DrawTexture</code> function is normally preferred in GUI drawing. This is because we are selecting the texture to be drawn from our spritesheet and we have to use scaled coordinates to pick the image as that is what the function uses. The <code class="literal">Rect</code> coordinates used in the <code class="literal">Sprite</code> object's <code class="literal">textureRect</code> property (the picking coordinates) are unscaled.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec67"></a>Connecting the dots</h3></div></div></div><p>So now that we have something to talk about, we just need to be able to attach it to the characters and then start displaying it on the screen for the player to interact with.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note60"></a>Note</h3><p>This book will cover the GUI system in more depth in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Shopping for Weapons</em></span>, so it will just include some basics here. You can come back and update your styles here later if you wish.</p></div><p>First, we need an empty class for our NPCs, which is derived from the <code class="literal">Entity</code> object. So, create a new C# script named <code class="literal">Npc</code> in the <code class="literal">Classes</code> folder under <code class="literal">Assets\Scripts</code> and replace its contents with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
public class Npc : MonoBehaviour
{
  public string Name;
  public int Age;
  public string Faction;
  public string Occupation;
  public int Level;
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip36"></a>Tip</h3><p>As NPCs are things in the real world that we generate and place into the scene, we actually need to break the convention to inherit from the <code class="literal">Entity</code> class. This is actually a limitation in Unity because we can only use scripts that derive from <code class="literal">MonoBehaviour</code> can be attached to GameObjects in a scene. If you try to attach a class that uses or derives from <code class="literal">ScriptableObject</code>, the editor will throw an error. So as we are adding NPCs in our scene in the editor, we need to use a separate script.</p><p>If you were generating the towns procedurally or loading them from a pre-built save file, then you could still use <code class="literal">ScriptableObject</code>-based classes. For more information on that, see <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Encountering Enemies and Running Away</em></span>.</p></div><p>With that created, add the script to our three NPCs in our scene. (Don't forget to name your characters in the <span class="strong"><strong>Inspector</strong></span> pane as well.)</p><p>Next, add the <span class="strong"><strong>Conversation Component</strong></span> to the Greybeard's <span class="strong"><strong>NPC</strong></span> and then drag the conversation we just built to that character in the <span class="strong"><strong>Conversations</strong></span> array.</p><p>The <span class="strong"><strong>Inspector</strong></span> pane should now look like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_17.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note61"></a>Note</h3><p>To make the <span class="strong"><strong>Inspector</strong></span> pane look a bit prettier, be sure to check out the editor extensions in <a class="link" href="#" linkend="ch10">Chapter 10</a>, <span class="emphasis"><em>The Battle Begins</em></span>.</p></div><p>So now that our character has a script and that we have the <code class="literal">ConversationManager</code> set up, we just need to trigger the conversation when the hero tries to enter the dark cave.</p><p>At the moment, the <code class="literal">NavigationManager</code> script that we used will let the player go anywhere. So first let's update that and add a bit more flexibility and configuration for the routes that the player can follow.</p><p>Open up the <code class="literal">NavigationManager</code> script in the <code class="literal">Navigation</code> folder under <code class="literal">Assets\Scripts</code> and create a new <code class="literal">struct</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public struct Route
{
  public string RouteDescription;
  public bool CanTravel;
}</pre></div><p>The preceding code now enables us to have a simple mechanism to say whether a route is traversable or not. (In real scenarios, this should be serialized or it should have a manager for the player to remember where the player has traveled; otherwise, it is never going to get unlocked.)</p><p>Next, we need to update the <code class="literal">RouteInformation</code> variable to use this new <code class="literal">struct</code> method and update the information for the two destinations that we have already configured in our manager. This should enable us to state that you can travel to the big bad world but not to the cave as follows:</p><div class="informalexample"><pre class="programlisting">public static Dictionary&lt;string, <span class="strong"><strong>Route</strong></span>&gt; RouteInformation = new Dictionary&lt;string, Route&gt;() {
  { "World", <span class="strong"><strong>new Route { RouteDescription = "The big bad world", CanTravel = true}</strong></span>
  },
  { "Cave01", <span class="strong"><strong>new Route { RouteDescription = "The deep dark cave", CanTravel = false}</strong></span>
  },
};</pre></div><p>As we are now using a <code class="literal">struct</code> method for our destination information, we also need to update the <code class="literal">GetRouteInfo</code> method to access the dictionary correctly and return the routes' description if found; we do this using the following code:</p><div class="informalexample"><pre class="programlisting">public static string GetRouteInfo(string destination)
{
  return RouteInformation.ContainsKey(destination) ? 
    RouteInformation[destination].RouteDescription :
    null;
}</pre></div><p>With that in place, all we need to do is check whether the <code class="literal">CanTravel</code> flag is true when the system requests, and if you're allowed to travel, update the <code class="literal">CanNavigate</code> method with the following code:</p><div class="informalexample"><pre class="programlisting">public static bool CanNavigate(string destination)
{
  return RouteInformation.ContainsKey(destination) ? 
    RouteInformation[destination].CanTravel : 
    false;
}</pre></div><p>Here, we simply look at the destination from our route information and return with information on whether the player is allowed to travel there or not.</p><p>Now, when you try to go to the cave, you won't get the prompt from <code class="literal">NavigationManager</code> whether you want to travel to it or not.</p><p>To finish off, we just need to get the Greybeard NPC to listen for the message that the player will leave and then start his most troublesome conversation. So, remove the <code class="literal">MessagingClientReceiver</code> script (that was created in the <span class="emphasis"><em>Messaging</em></span> section) from the left border (the cave) that you set up earlier and add it to the Greybeard NPC game object.</p><p>Now, Greybeard is subscribing to and receiving the messages for the player leaving. Next, update the <code class="literal">MessagingClientReceiver</code> script (in the <code class="literal">Messaging</code> folder under <code class="literal">Assets\Scripts</code>) and update the <code class="literal">ThePlayerIsTryingToLeave</code> method with the following code:</p><div class="informalexample"><pre class="programlisting">void ThePlayerIsTryingToLeave()
{
  var dialog = GetComponent&lt;ConversationComponent&gt;();
  if (dialog != null)
  {
    if (dialog.Conversations != null &amp;&amp; dialog.Conversations.Length &gt; 0)
    {
      var conversation = dialog.Conversations[0];
      if (conversation != null)
      {
        ConversationManager.Instance.StartConversation (conversation);
      }
    }
  }
}</pre></div><p>Here, we now look to see if a <code class="literal">ConversationComponent</code> script is on the game object it is attached to. If it is, we see if there are any conversations defined for this NPC; if yes, we call the <code class="literal">ConversationManager</code> script and ask it to start the first conversation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note62"></a>Note</h3><p>Granted, this is a simple example and should be extended in a full system to track conversations that are played or conditions that need to be met for a conversation to be played.</p><p>At the moment, the conversation system will keep on going even after you have left the vicinity of the character you are talking with.</p></div><p>Now, if you run the project and try to enter the cave, the grumpy old Greybeard will pipe up and harass you, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_05_18.jpg" /></div></div></div>