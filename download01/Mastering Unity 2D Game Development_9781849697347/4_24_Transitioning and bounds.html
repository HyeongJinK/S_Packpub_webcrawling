<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec27"></a>Transitioning and bounds</h2></div></div><hr /></div><p>So our <a id="id400" class="indexterm"></a>camera follows our player, but our hero can still walk off the screen<a id="id401" class="indexterm"></a> and keep going forever, so let us stop that from happening.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec47"></a>Towns with borders</h3></div></div></div><p>As you <a id="id402" class="indexterm"></a>saw in the preceding section, you can use Unity's camera logic to figure out where things are on the screen. You can also do more complex ray testing to check where things are, but I find these are overly complex unless you depend on that level of interaction.</p><p>The simpler answer is just to use the native Box2D physics system to keep things in the scene. This might seem like overkill, but the 2D physics system is very fast and fluid, and it is simple to use.</p><p>We already added the physics components, <code class="literal">Rigidbody 2D</code> (to apply physics) and a <code class="literal">Box Collider 2D</code> (to detect collisions) to the player in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Character Building</em></span>. So, we can make use of these components straight away by adding some additional collision objects to stop the player running off.</p><p>To do this and to keep things organized, we will add three empty game objects (either by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span>, or by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> +<span class="emphasis"><em>N</em></span>) to the scene (one parent and two children) to manage these collision points, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_28.jpg" /></div><p>I've named <a id="id403" class="indexterm"></a>them <span class="strong"><strong>WorldBounds</strong></span> (parent) and <span class="strong"><strong>LeftBorder</strong></span> and <span class="strong"><strong>RightBorder</strong></span> (children) for reference. Next, we will position each of the child game objects to the left- and right-hand side of the screen, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_29.jpg" /></div><p>Next, we will<a id="id404" class="indexterm"></a> add a <span class="strong"><strong>Box Collider 2D</strong></span> to each border game object and increase its height just to ensure that it works for the entire height of the scene. I've set the <span class="strong"><strong>Y</strong></span> value to <code class="literal">5</code> for effect, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_30.jpg" /></div><p>The end<a id="id405" class="indexterm"></a> result should look like the following screenshot with the two new colliders highlighted in green:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_31.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>Alternatively, you could have just created one of the children, added the box collider, duplicated it (by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Duplicate</strong></span> or by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span>), and moved it. If you have to create multiples of the same thing, this is a handy tip to remember.</p></div><p>If you<a id="id406" class="indexterm"></a> run the project now, then our hero can no longer escape this town on his own. However, as we want to let him leave, we can add a script to the new <code class="literal">Boundary</code> game object so that when the hero reaches the end of the town, he can leave.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec48"></a>Journeying onwards</h3></div></div></div><p>Now that we<a id="id407" class="indexterm"></a> have collision zones on our town's borders, we can hook into this by using a script to activate when the hero approaches.</p><p>Create a<a id="id408" class="indexterm"></a> new C# script called <code class="literal">NavigationPrompt</code>, clear its contents, and populate it with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class NavigationPrompt : MonoBehaviour {

  bool showDialog;

  void OnCollisionEnter2D(Collision2D col)
  {
    showDialog = true;
  }

  void OnCollisionExit2D(Collision2D col)
  {
    showDialog = false;
  }
}</pre></div><p>The preceding code gives us the framework of a collision detection script that sets a flag on and off if the character interacts with what the script is attached to, provided it has a physics<a id="id409" class="indexterm"></a> collision component. Without it, this script would do<a id="id410" class="indexterm"></a> nothing and it won't cause an error.</p><p>Next, we will do something with the flag and display some GUI when the flag is set. So, add the following extra function to the preceding script:</p><div class="informalexample"><pre class="programlisting">    void OnGUI()
    {
      if (showDialog)
      {
        //layout start
        GUI.BeginGroup(new Rect(Screen.width / 2 - 150, 50, 300, 250));

        //the menu background box
        GUI.Box(new Rect(0, 0, 300, 250), "");

        // Information text
        GUI.Label(new Rect(15, 10, 300, 68), "Do you want to travel?");

        //Player wants to leave this location
        if (GUI.Button(new Rect(55, 100, 180, 40), "Travel"))
        {
          showDialog = false;

          // The following line is commented out for now 
          // as we have nowhere to go :D
          //Application.LoadLevel(1);

        //Player wants to stay at this location
        if (GUI.Button(new Rect(55, 150, 180, 40), "Stay"))
        {
          showDialog = false;
        }

        //layout end
        GUI.EndGroup();
      }
    }</pre></div><p>The function<a id="id411" class="indexterm"></a> itself is very simple and only activates if the <code class="literal">showDialog</code> flag is set to <code class="literal">true</code> by the collision detection. Then, we will perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <code class="literal">OnGUI</code> method, we <a id="id412" class="indexterm"></a>set up a dialog window region with some text and two buttons.</p></li><li><p>One button asks if the player wants to travel, which would load the next area (commented out for now as we only have one scene), and close the dialog.</p></li><li><p>One button simply closes the dialog if the hero didn't actually want to leave. As we haven't stopped moving the player, the player can also do this by moving away.</p></li></ol></div><p>If you now add the <code class="literal">NavigationPrompt</code> script to the two world border (<code class="literal">LeftBorder</code> and <code class="literal">RightBorder</code>) game objects, this will result in the following simple UI whenever the player collides with the edges of our world:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_32.jpg" /></div><p>We can<a id="id413" class="indexterm"></a> further enhance this by <span class="emphasis"><em>tagging</em></span> or <span class="emphasis"><em>naming</em></span> our borders to indicate a destination. I prefer tagging, as it does not interfere with how my scene looks in the project hierarchy; also, I can control what tags are available and prevent accidental mistyping.</p><p>To tag a<a id="id414" class="indexterm"></a> game object, simply select a <span class="strong"><strong>Tag</strong></span> using the drop-down list in the <span class="strong"><strong>Inspector</strong></span> when you select the game object in the scene or project. This is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_33.jpg" /></div><p>If you haven't set up your tags yet or just wish to add a new one, select <span class="strong"><strong>Add Tag</strong></span> in the drop-down menu; this will open up the <span class="strong"><strong>Tags and Layers</strong></span> window of <span class="strong"><strong>Inspector</strong></span>. Alternatively, you<a id="id415" class="indexterm"></a> can call up this window by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Tags and layers</strong></span> in the menu. It is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_34.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p>You can only edit or change user-defined tags. There are several other tags that are system defined. You can use these as well; you just cannot change, remove, or edit them. These include <code class="literal">Player</code>, <code class="literal">Respawn</code>, <code class="literal">Finish</code>, <code class="literal">Editor Only</code>, <code class="literal">Main Camera</code>, and <code class="literal">GameController</code>.</p></div><p>As you can see from the preceding screenshot, I have entered two new tags called <span class="strong"><strong>The Cave</strong></span> and <span class="strong"><strong>The World</strong></span>, which are the two main exit points from our town.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>Unity also adds an extra item to the arrays in the editor. This helps you when you want to add more items; it's annoying when you want a fixed size but it is meant to help. When the project runs, however, the correct count of items will be exposed.</p></div><p>Once these are set up, just return to the <span class="strong"><strong>Inspector</strong></span> for the two borders, and set the right one to <span class="strong"><strong>The World</strong></span> and the left to <span class="strong"><strong>The Cave</strong></span>.</p><p>Now, I was quite specific in how I named these tags, as you can now reuse these tags in the script to both aid navigation and also to notify the player where they are going. To do this, simply update the <code class="literal">Do you want to travel to</code> line to the following:</p><div class="informalexample"><pre class="programlisting">//Information text
GUI.Label(new Rect(15, 10, 300, 68), "Do you want to travel to <span class="strong"><strong>" +</strong></span> <span class="strong"><strong>  this.tag + "?"</strong></span>);</pre></div><p>Here, we<a id="id416" class="indexterm"></a> have simply appended the dialog as it is presented to the user with the name of the destination we set in the tag. Now, we'll get a more personal message, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_35.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec49"></a>Planning for the larger picture</h3></div></div></div><p>Now for small games, the preceding implementation is fine; however, if you are planning a larger <a id="id417" class="indexterm"></a>world with a large number of interactions, provide complex decisions to prevent the player continuing unless they are ready.</p><p>As the following diagram shows, there are several paths the player can take and in some cases, these is only one way. Now, we could just build up the logic for each of these individually as shown in the screenshot, but it is better if we build a separate navigation system so that we have everything in one place; it's just easier to manage that way.</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_04_36.jpg" /></div><p>This separation is a fundamental part of any good game design. Keeping the logic and game functionality separate makes it easier to maintain in the future, especially when you need to take internationalization into account (but we will learn more about that later).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note37"></a>Note</h3><p>Now, we'll change to using a manager to handle all the world/scene transitions, and simplify the tag names we use as they won't need to be displayed.</p><p>So, <span class="strong"><strong>The Cave</strong></span> will be renamed as just <span class="strong"><strong>Cave</strong></span>, and we will get the text to display from the navigation manager instead of the tag.</p></div><p>So, by separating out the core decision making functionality out of the prompt script, we can build the core manager for navigation. Its primary job is to maintain where a character can travel and information about that destination.</p><p>First, we'll update the tags we created earlier to simpler identities that we can use in our navigation manager (update <span class="strong"><strong>The Cave</strong></span> to <code class="literal">Cave</code> and <span class="strong"><strong>The World</strong></span> to <code class="literal">World</code>).</p><p>Next, we'll create a new C# script called <code class="literal">NavigationManager</code> in <code class="literal">Assets\Scripts</code>, and<a id="id418" class="indexterm"></a> then replace its contents with the following lines of code:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Generic;
public static class NavigationManager
{


  public static Dictionary&lt;string,string&gt; RouteInformation = new Dictionary&lt;string,string&gt;()
  {
    { "World", "The big bad world"},
    { "Cave", "The deep dark cave"},
  };

  public static string GetRouteInfo(string destination)
  {
    return RouteInformation.ContainsKey(destination) ? RouteInformation[destination] : null;
  }

  public static bool CanNavigate(string destination)
  {
    return true;
  }

  public static void NavigateTo(string destination)
  {
    // The following line is commented out for now 
    // as we have nowhere to go :D
    //Application.LoadLevel(destination);
  }
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p>Notice the <code class="literal">?</code> and <code class="literal">:</code> operators in the following statement:</p><div class="informalexample"><pre class="programlisting">RouteInformation.ContainsKey(destination) ? RouteInformation[destination] : null;</pre></div><p>These operators are C# conditional operators. They are effectively the shorthand of the following:</p><div class="informalexample"><pre class="programlisting">if(RouteInformation.ContainsKey(destination))
{
  return RouteInformation[destination];
}
else
{
  return null;
}</pre></div><p>Shorter, neater, and much nicer, don't you think?</p><p>For more information, see the MSDN C# page at <a class="ulink" href="http://bit.ly/csharpconditionaloperator" target="_blank">http://bit.ly/csharpconditionaloperator</a>.</p></div><p>The script is very basic for now, but contains several following key elements that can be expanded <a id="id419" class="indexterm"></a>to meet the design goals of your game:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">RouteInformation</code>: This is a list of all the possible destinations in the game in a<a id="id420" class="indexterm"></a> dictionary.</p><p>A static list of possible destinations in the game, and it is a core part of the manager as it knows everywhere you can travel in the game in one place.</p></li><li style="list-style-type: disc"><p><code class="literal">GetRouteInfo</code>: This is a basic information extraction function.</p><p>A <a id="id421" class="indexterm"></a>simple controlled function to interrogate the destination list. In this example, we just return the text to be displayed in the prompt, which allows for more detailed descriptions that we could use in tags. You could use this to provide alternate prompts depending on what the player is carrying and whether they have a lit torch, for example.</p></li><li style="list-style-type: disc"><p><code class="literal">CanNavigate</code>: This is a test to see if navigation is possible.</p><p>If you <a id="id422" class="indexterm"></a>are going to limit a player's travel, you need a way to test if they can move, allowing logic in your game to make alternate choices if the player cannot. You could use a different system for this by placing some sort of block in front of a destination to limit choice (as used in the likes of Zelda), such as an NPC or rock. As this is only an example, we can always travel and add logic to control it if you wish.</p></li><li style="list-style-type: disc"><p><code class="literal">NavigateTo</code>: This is a function to instigate navigation.</p><p>Once<a id="id423" class="indexterm"></a> a player can travel, you can control exactly what happens in the game: does navigation cause the next scene to load straight away (as in the script currently), or does the current scene fade out and then a traveling screen is shown before fading the next level in? Granted, this does nothing at present as we have nowhere to travel to.</p></li></ul></div><p>The script<a id="id424" class="indexterm"></a> you will notice is different to the other scripts used so far, as it is a static class. This means it sits in the background, only exists once in the game, and is accessible from anywhere. This pattern is useful for fixed information that isn't attached to anything; it just sits in the background waiting to be queried.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Tip</h3><p>Later, we will cover more advanced types and classes to provide more complicated scenarios.</p></div><p>With this class in place, we just need to update our previous script (and the tags) to make use of this new manager. Update the <code class="literal">NavigationPrompt</code> script as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Update<a id="id425" class="indexterm"></a> the <code class="literal">collision</code> function to only show the prompt if we can travel. The code is as follows:</p><div class="informalexample"><pre class="programlisting">void OnCollisionEnter2D(Collision2D col)
{
  //Only allow the player to travel if allowed
  if (NavigationManager.CanNavigate(this.tag))
  {
    showDialog = true;
  }
}</pre></div></li><li><p>When the dialog shows, display the more detailed destination text provided by the manager for the intended destination. The code is as follows:</p><div class="informalexample"><pre class="programlisting">//Dialog detail - updated to get better detail
GUI.Label(new Rect(15, 10, 300, 68), "Do you want to travel to " + NavigationManager.GetRouteInfo(this.tag) + "?");</pre></div></li><li><p>If the player wants to travel, let the manager start the travel process. The code is as follows:</p><div class="informalexample"><pre class="programlisting">//Player wants to leave this location
if (GUI.Button(new Rect(55, 100, 180, 40), "Travel"))
{
  showDialog = false;
  NavigationManager.NavigateTo(this.tag);
}</pre></div></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"></a>Note</h3><p>The<a id="id426" class="indexterm"></a> functionality I've shown here is very basic and it is intended to make you think about how you would need to implement it for your game. With so many possibilities available, I could fill several chapters on this kind of subject alone.</p></div></div></div>