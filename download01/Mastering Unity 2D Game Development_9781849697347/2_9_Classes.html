<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec14"></a>Classes</h2></div></div><hr /></div><p>Architecting the core of your game from the beginning is an often-skipped process. Because we're too<a id="id115" class="indexterm"></a> eager to just get on and build our game, let's jump straight in and start placing assets in a scene, adding them as we go. This kind of practice is fine for prototypes (mostly, however, even with prototypes, a level of architecture is usually required). When building your actual product, however, without setting up a proper architecture from the beginning, you are heading toward a world of utter mess.</p><p>When we say architecture, it doesn't mean that you need to design everything (but it helps). You just need to ensure that you plan what you are going to build before you build it instead of thinking about stuff and checking Google for information on how to do it. Even if you are using some kind of an agile method, you should have a good framework and goal for each sprint as you plan for each sprint. This will guide you on what should be done and when, not just designing the project on the fly.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>The object-orientated design</h3></div></div></div><p>Unity in itself is a fully <span class="strong"><strong>object-orientated</strong></span> (<span class="strong"><strong>OO</strong></span>) system<a id="id116" class="indexterm"></a> with strict interfaces to ensure that the engine knows what to expect and when, so why shouldn't your game<a id="id117" class="indexterm"></a> follow the same pattern? Unity is also<a id="id118" class="indexterm"></a> component-based, which is something else to take into account while designing how your game will be put together.</p><p>At the core of any object-orientated design, the focus is on reusability. If a set of attributes is repeatedly used across multiple objects, then they should be separated into one common class and shared in much the same way we do with code refactoring; in addition to this, you should also reduce the amount of code that is lying about doing the same job. This means that we can more easily make changes to this base set without having to re-edit all the classes that might need those attributes. The following diagram shows two approaches of using a base class to define common attributes over multiple code implementations:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_02_10.jpg" /></div><p>Another facet of OO is to employ interfaces to govern exactly how a class should look if you have multiple objects of the same type. For example, you have <a id="id119" class="indexterm"></a>an <code class="literal">Enemy</code> class structure that defines how enemies in general should work; then, using that same structure, you specify<a id="id120" class="indexterm"></a> all the enemy implementations, such as zombies, spiders, and white-fanged rabbits. Interfaces can also define behaviors or methods on a class, so you can ensure that all the classes that implement that interface will always have the same common abilities, such as all the enemies will have <code class="literal">patrol</code>, <code class="literal">Fight</code>, and <code class="literal">run away</code> methods. This means that if you have an enemy object, it will always have those methods attached to them when you refer to them in the code.</p><p>The following diagram shows how you can plan for multiple inheritances, allowing you to add a common behavior pattern to each group of entities:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_02_11.jpg" /></div><p>Knowing this helps us design our game effectively and ensures that we architect it correctly from the beginning.</p><p>We'll discuss these<a id="id121" class="indexterm"></a> patterns in more detail when we implement them in the following sections.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec18"></a>The game structure</h3></div></div></div><p>To keep in line <a id="id122" class="indexterm"></a>with the preceding architecture set, we'll design the layout of the class to support a flexible structure that will be easily extended in the future.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec14"></a>The common game object</h4></div></div></div><p>As almost every entity in our <a id="id123" class="indexterm"></a>game will have statistics and some basic behaviors, we start with a generic object (<code class="literal">Entity</code>) to define the attributes that all the entities<a id="id124" class="indexterm"></a> in our game<a id="id125" class="indexterm"></a> will have. As there is only one entity type, we don't need to set up an interface for this object as all the other game objects will just use this one definition, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_02_13.jpg" /></div><p>This shows that we have<a id="id126" class="indexterm"></a> several common attributes for things such as<a id="id127" class="indexterm"></a> health and strength. This <code class="literal">Entity</code> object<a id="id128" class="indexterm"></a> is implemented<a id="id129" class="indexterm"></a> in the code as follows in a C# script called <span class="strong"><strong>Entity</strong></span> in the <code class="literal">Assets\Scripts</code> folder:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
public class Entity : ScriptableObject
{
  public string Name;
  public int Age;
  string Faction;
  public string Occupation;
  public int Level = 1;
  public int Health = 2;
  public int Strength = 1;
  public int Magic = 0;
  public int Defense = 0;
  public int Speed = 1;
  public int Damage = 1;
  public int Armor = 0;
  public int NoOfAttacks = 1;
  public string Weapon;
  public Vector2 Position;
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"></a>Note</h3><p>The entity class is <a id="id130" class="indexterm"></a>inherited from a specialized class called <code class="literal">ScriptableObject</code>. This is essential to know how we will use<a id="id131" class="indexterm"></a> it in the game. We will cover<a id="id132" class="indexterm"></a> <code class="literal">ScriptableObject</code> in more detail in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>NPCs and Interactions</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec01"></a>The player object</h5></div></div></div><p>Basing the player's character on the <code class="literal">Entity</code> object makes the definition of the player a lot simpler. So, you only<a id="id133" class="indexterm"></a> need<a id="id134" class="indexterm"></a> to focus on what<a id="id135" class="indexterm"></a> is specific to the player's character itself, that is, the differences between the player and all the other game entities.</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_02_14.jpg" /></div><p>So, the player character we see here is the only one who has <span class="strong"><strong>Inventory</strong></span>, <span class="strong"><strong>Money</strong></span>, and <span class="strong"><strong>Skills</strong></span> since they are specific to our hero's work in our game. This is implemented in the following <a id="id136" class="indexterm"></a>code with the<a id="id137" class="indexterm"></a> player inheriting all the properties from the<a id="id138" class="indexterm"></a> <code class="literal">Entity</code> class in another new C# script called <span class="strong"><strong>Player</strong></span> in the <code class="literal">Assets\Scripts</code> folder:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
public class Player : Entity
{
  public string[] Inventory;
  public string[] Skills;
  public int Money;
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note09"></a>Note</h3><p>Preferably, all the<a id="id139" class="indexterm"></a> attributes of any class should be of the read-only type outside of the class itself (unless there is a very good reason for it). This is to ensure that you don't mistakenly change a class's value without knowing why. It might sound easier to just keep updating everything, but at some point, while you are debugging, you will want to know why things are changing. If any code updates these values, then you will literally spend hours trying to find why. If you need to change values, then you need to implement behaviors (see the following sections).</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec15"></a>More later</h4></div></div></div><p>To show you how to build the architecture progressively in this project, we will add more classes to each section; we'll keep things simple and build the project with a strong foundation.</p><p>We already have our base entity in place from which all the game entities as well as our player are driven, so<a id="id140" class="indexterm"></a> let's look at implementing them further.</p></div></div></div>