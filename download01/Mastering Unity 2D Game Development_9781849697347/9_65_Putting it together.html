<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec61"></a>Putting it together</h2></div></div><hr /></div><p>Now as I stated earlier, this section is going to be <span class="emphasis"><em>big</em></span> and full of surprises. Some things are just what you need to do in order to flex Unity in the way we want to use it. Others are real gotchas that can leave you scratching your head and searching for the answer endlessly.</p><p>We'll start with the<a id="id794" class="indexterm"></a> battle state machine, getting the player ready for the battle and then following up with some GUI interaction for the player to use in order to begin his or her assault in the battle. In the next chapter, we'll close the loop in the player's battle process and progress the state machine over to the opponents.</p><p>Let's begin!</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec117"></a>The battle state manager</h3></div></div></div><p>Starting back in our <span class="strong"><strong>Battle</strong></span> scene, we<a id="id795" class="indexterm"></a> need to replace our temporary state machine with a proper one using all of Mecanim's handy features. Although we will still only be using a fraction of the functionality with the RPG sample, I advise you to investigate and read more about its capabilities.</p><p>Navigate to <code class="literal">Assets\Animation\Controllers</code> and create a new <span class="strong"><strong>Animator Controller</strong></span> called <code class="literal">BattleStateMachine</code>, and then we can begin putting together the battle state machine. The following screenshot shows you the states, transitions, and properties that we will need:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_09_04.jpg" /></div><p>As shown in the <a id="id796" class="indexterm"></a>preceding screenshot, we have created eight states to control the flow of a battle with two Boolean parameters to control its transition.</p><p>The transitions are defined as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>From <span class="strong"><strong>Begin_Battle</strong></span> to <span class="strong"><strong>Intro</strong></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>BattleReady = true (Transition Duration = 0)</p></li></ul></div></li><li style="list-style-type: disc"><p>From <span class="strong"><strong>Intro</strong></span> to <span class="strong"><strong>Player_Move</strong></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Exit Time = 0.9 (Transition Duration = 2)</p></li></ul></div></li><li style="list-style-type: disc"><p>From <span class="strong"><strong>Player_Move</strong></span> to <span class="strong"><strong>Player_Attack</strong></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>PlayerReady = true (Transition Duration = 0)</p></li></ul></div></li><li style="list-style-type: disc"><p>From <span class="strong"><strong>Player_Attack</strong></span> to <span class="strong"><strong>Change_Control</strong></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>PlayerReady = false (Transition Duration = 2)</p></li></ul></div></li><li style="list-style-type: disc"><p>From <span class="strong"><strong>Change_Control</strong></span> to <span class="strong"><strong>Enemy_Attack</strong></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Exit Time = 0.9 (Transition Duration = 2)</p></li></ul></div></li><li style="list-style-type: disc"><p>From <span class="strong"><strong>Enemy_Attack</strong></span> to <span class="strong"><strong>Player_Move</strong></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>BattleReady = true (Transition Duration = 2)</p></li></ul></div></li><li style="list-style-type: disc"><p>From <span class="strong"><strong>Enemy_Attack</strong></span> to <span class="strong"><strong>Battle_Result</strong></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>BattleReady = false (Transition Time = 2)</p></li></ul></div></li><li style="list-style-type: disc"><p>From <span class="strong"><strong>Battle_Result</strong></span> to <span class="strong"><strong>Battle_End</strong></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Exit Time = 0.9 (Transition Time = 5)</p></li></ul></div></li></ul></div><p>Summing up, <a id="id797" class="indexterm"></a>what we have built is a steady flow of battle, which can be summarized as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The battle begins and we show a little intro clip to tell the player about the battle</p></li><li style="list-style-type: disc"><p>Once the player has control, we wait for them to finish their move</p></li><li style="list-style-type: disc"><p>We then perform the player's move and switch the control over to the Enemy AI</p></li><li style="list-style-type: disc"><p>If there are any enemies left, they get to attack the player (if they are not too scared and have not run away)</p></li><li style="list-style-type: disc"><p>If the battle continues, we switch back to the player, otherwise we show the battle result</p></li><li style="list-style-type: disc"><p>We show the result for 5 seconds (or until the player hits a key), then finish the battle and return the player to the world together with whatever loot and experience they have gained</p></li></ul></div><p>This is just a simple flow, which can be extended as much as you want, and as we continue, you will see all the points where you could expand it.</p><p>With our animator state machine created, we now just need to attach it to our battle manager so it will be available when the battle runs; follow the ensuing steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open up the <span class="strong"><strong>Battle</strong></span> scene.</p></li><li><p>Select the <span class="strong"><strong>BattleManager</strong></span> game object in the project hierarchy and add an <code class="literal">Animator</code> component to it.</p></li><li><p>Now drag the <span class="strong"><strong>BattleStateMachine</strong></span> animator controller we just created into the <code class="literal">Controller</code> property of the <code class="literal">Animator</code> component.</p></li></ol></div><p>The preceding <a id="id798" class="indexterm"></a>steps attaches our new battle state machine to our battle engine. Now, we just need to be able to reference the <span class="strong"><strong>BattleStateMachine</strong></span> Mecanim state machine from <code class="literal">BattleManager</code> script. To do this, open up the <code class="literal">BattleManager</code> script in <code class="literal">Assets\Scripts</code> and add the following variable to the top of the class:</p><div class="informalexample"><pre class="programlisting">private Animator battleStateManager;</pre></div><p>Then, to capture the configured <code class="literal">Animator</code> component in our <code class="literal">BattleManager</code> script, we add the following to the <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">void Start () {
<span class="strong"><strong>         battleStateManager = GetComponent&lt;Animator&gt;();</strong></span>
<span class="strong"><strong>        if (battleStateManager == null)</strong></span>
<span class="strong"><strong>        {</strong></span>
<span class="strong"><strong>            Debug.LogError("No battlemanager Animator found");</strong></span>
<span class="strong"><strong>        }</strong></span>
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note108"></a>Note</h3><p>Sadly, we have to assign it this way because all the functionality to interrogate the <span class="strong"><strong>Animator Controller</strong></span> is built in to the <code class="literal">Animator</code> component. We cannot simply attach the controller directly to our <code class="literal">BattleManager</code> script and use it.</p></div><p>Now that it's all wired up, let's start using it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec118"></a>Getting to the state manager in the code</h3></div></div></div><p>Now that we have our <a id="id799" class="indexterm"></a>state manager running in Mecanim, we just need to be able to access it from the code. However, at first glance, there is a barrier to achieving this. The reason being that the Mecanim system uses hashes (integer ID keys for objects) not strings to identify states within its engine (still not clear why, but for performance reasons probably). To access the states in Mecanim, Unity provides a hashing algorithm to help you, which is fine for one-off checks but a bit of an overhead when you need per-frame access.</p><p>A simple solution to this is to generate and cache all the state hashes when we start and then use the cache to talk to the Mecanim engine.</p><p>First, let's remove the placeholder code from <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Encountering Enemies and Running Away</em></span>, for the old <code class="literal">enum</code> state machine, so remove the following code from the top of the <code class="literal">BattleManager</code> script:</p><div class="informalexample"><pre class="programlisting">enum BattlePhase
{
  PlayerAttack,
  EnemyAttack
}
private BattlePhase phase;</pre></div><p>Also, remove the following line from the <code class="literal">Start</code> method:</p><div class="informalexample"><pre class="programlisting">phase = BattlePhase.PlayerAttack;</pre></div><p>There is still a <a id="id800" class="indexterm"></a>reference in the <code class="literal">OnGUI</code> method, but we will replace that shortly; feel free to remove it as well now if you wish.</p><p>Now, to begin working with our new state machine, we need a replica of the available states we have defined in our Mecanim state machine. For this, we just need an enumeration using the same names (you can create this either as a new C# script or simply place it in the <code class="literal">BattleManager</code> class), as follows:</p><div class="informalexample"><pre class="programlisting">public enum BattleState
{
  Begin_Battle,
  Intro,
  Player_Move,
  Player_Attack,
  Change_Control,
  Enemy_Attack,
  Battle_Result,
  Battle_End
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note109"></a>Note</h3><p>It may seem strange to have a duplicate of your states in the state machine and in the code; however, at the time of writing, it is necessary. Mecanim does not expose the names of the states outside of the engine other than through using hashes. You can either use this approach and make it dynamic, or extract the state hashes and store them in a dictionary for use.</p><p>Mecanim makes the managing of state machines very simple under the hood, and it is extremely powerful, much better than trawling through code every time you want to update the state machine.</p></div><p>Next, we need a location to cache the hashes the state machine needs and a property to keep the current state so we don't constantly query the engine for a hash. So, add a new <code class="literal">using</code> statement to the beginning of the <code class="literal">BattleManager</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">using System.Collections;
<span class="strong"><strong>using System.Collections.Generic;</strong></span>
using UnityEngine;</pre></div><p>Then, add the following variables to the top of the <code class="literal">BattleManager</code> class:</p><div class="informalexample"><pre class="programlisting">private Dictionary&lt;int, BattleState&gt; battleStateHash = new Dictionary&lt;int, BattleState&gt;();
private BattleState currentBattleState;</pre></div><p>Finally, we <a id="id801" class="indexterm"></a>just need to interrogate the animator state machine we have created. So create a new <code class="literal">GetAnimationStates</code> method in the <code class="literal">BattleManager</code> class as follows:</p><div class="informalexample"><pre class="programlisting">void GetAnimationStates()
{
  foreach (BattleState state in (BattleState[])System.Enum.GetValues(typeof(BattleState)))
  {
    battleStateHash.Add(Animator.StringToHash("Base Layer." + state.ToString()), state);
  }
}</pre></div><p>This simply generates a hash for the corresponding animation state in Mecanim and stores the resultant hashes in a dictionary that we can use without having to calculate them at runtime when we need to talk to the state machine.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note110"></a>Note</h3><p>Sadly, there is no way at runtime to gather the information from Mecanim as all the classes for interrogating the animator are only available in the editor.</p><p>You could gather the hashes from the animator and store them in a file to avoid this, but it won't save you much.</p></div><p>To complete this, we just need to call the new method in the <code class="literal">Start</code> function of the <code class="literal">BattleManager</code> script by adding the following:</p><div class="informalexample"><pre class="programlisting">GetAnimationStates();</pre></div><p>Now that we have our states, we can use them in our running game to control both the logic that is applied and the GUI elements that are drawn to the screen.</p><p>Now add the <code class="literal">Update</code> function to the <code class="literal">BattleManager</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">void Update()
{
  currentBattleState = battleStateHash[battleStateManager.GetCurrentAnimatorStateInfo(0).nameHash];

  switch (currentBattleState)
  {
    case BattleState.Intro:
      break;
    case BattleState.Player_Move:
      break;
    case BattleState.Player_Attack:
      break;
    case BattleState.Change_Control:
      break;
    case BattleState.Enemy_Attack:
      break;
    case BattleState.Battle_Result:
      break;
    case BattleState.Battle_End:
      break;
    default:
      break;
  }
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip62"></a>Tip</h3><p>In Unity 5, you will have to use the  fullPathHash property instead of just nameHash when checking an animator state.</p><p>Thankfully this is the only change required in this entire title that is needed for Unity 5* :D (*at the time of writing).</p></div><p>This code gets <a id="id802" class="indexterm"></a>the current state from the animator state machine once per frame and then sets up a choice (<code class="literal">switch</code> statement) for what can happen based on the current state. (Remember, it is the state machine that decides which state follows which in the Mecanim engine, not nasty nested <code class="literal">if</code> statements everywhere in code.)</p><p>Next, replace/add the <code class="literal">OnGUI</code> function with the same pattern to control which GUI elements would be displayed, as follows:</p><div class="informalexample"><pre class="programlisting">void OnGUI()
{
  switch (currentBattleState)
  {
    case BattleState.Begin_Battle:
      break;
    case BattleState.Intro:
      break;
    case BattleState.Player_Move:
      break;
    case BattleState.Player_Attack:
      break;
    case BattleState.Change_Control:
      break;
    case BattleState.Enemy_Attack:
      break;
    case BattleState.Battle_Result:
      break;
    default:
      break;
  }
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip63"></a>Tip</h3><p>If you need a quick way to generate a <code class="literal">switch</code> statement code from an <code class="literal">enum</code> state (as shown in the preceding code), there is a simple shortcut to do so using Visual Studio's built-in snippets:</p><p>Just type <code class="literal">switch</code> and when the snippet prompt appears, tab it twice. Then, type in the property name that has a type of an <code class="literal">enum</code> state (the c<code class="literal">urrentBattleState</code> property in this case which is of the type, <code class="literal">BattleState</code>). Finally, hit the down arrow key and your case statements will be automatically generated for you!</p><p>Neat, eh!</p></div><p>With these in<a id="id803" class="indexterm"></a> place, we are ready to start adding in some battle logic.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec119"></a>Starting the battle</h3></div></div></div><p>As it stands, the <a id="id804" class="indexterm"></a>state machine is waiting at the <code class="literal">Begin_Battle</code> state for us to kick things off. Obviously, we want to do this when we are ready and all the pieces on the board are in place.</p><p>When the current <span class="strong"><strong>Battle</strong></span> scene we added in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Encountering Enemies and Running Away</em></span>, starts, we load up the player and randomly spawn in a number of enemies into the fray using a coroutine function called <code class="literal">SpawnEnemies</code>. So, only when all the nasty goblins are ready and waiting to be chopped down do we want to kick things off.</p><p>To tell the state machine to start the battle, we simple add the following line just after the end of the <code class="literal">for</code> loop in the <code class="literal">SpawnEnemies IEnumerator</code> coroutine function:</p><div class="informalexample"><pre class="programlisting">battleStateManager.SetBool("BattleReady", true);</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note111"></a>Note</h3><p>Do not ask me why we can affect the properties just by using their string names and cannot do the same with the states; it just baffles me. I hope they change this in a future release.</p></div><p>Now when <a id="id805" class="indexterm"></a>everything is in place, the battle will finally begin.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec120"></a>Adding a little flair</h3></div></div></div><p>In an ode to the<a id="id806" class="indexterm"></a> fantastic game <span class="emphasis"><em>Star Command</em></span> (<a class="ulink" href="http://www.starcommandgame.com/" target="_blank">http://www.starcommandgame.com/</a>), when a battle starts there is a little introductory animation that introduces the two parties in battle, I added the <code class="literal">Intro</code> state sequence, which currently just displays a <a id="id807" class="indexterm"></a>message about the battle.</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_09_21.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip64"></a>Tip</h3><p>I was going to add a full animation to zoom and highlight the player and the goblins and then show the <code class="literal">vs</code> message, but I'll leave that up to you to play with. Can't have all the fun now, can I?</p></div><p>Currently, the state machine pauses at the <code class="literal">Intro</code> state for a few seconds, so while it's paused, let's add a simple GUI dialog to tell the player about the impending battle. Simply add the following to the <code class="literal">case</code> line of the <code class="literal">Intro</code> state in the <code class="literal">OnGUI</code> function:</p><div class="informalexample"><pre class="programlisting">case BattleState.Intro:
<span class="strong"><strong>  GUI.Box(new Rect((Screen.width / 2) - 150 , 50, 300, 50), "Battle between Player and Goblins");</strong></span>
  break;</pre></div><p>Now the player is informed that a battle is about to happen whether they like it or not (and now he cannot run away again, yet!).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note112"></a>Note</h3><p>Now when you run the game in the Unity editor and bring up the <span class="strong"><strong>Animator</strong></span> tab, you will see that the animation states change as the battle commences; it changes from <span class="strong"><strong>Begin</strong></span> | <span class="strong"><strong>Intro</strong></span> | <span class="strong"><strong>Player_Move</strong></span>, indicating that it's now the player's turn to act.</p></div><p>If you wish, you <a id="id808" class="indexterm"></a>can also re-add the <span class="strong"><strong>Run Away</strong></span> button for the player into the <code class="literal">Player_Move</code> state in the <code class="literal">OnGUI</code> function as well:</p><div class="informalexample"><pre class="programlisting">case BattleState.Player_Move:
<span class="strong"><strong>  if (GUI.Button(new Rect(10, 10, 100, 50), "Run Away"))</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    GameState.PlayerReturningHome = true;</strong></span>
<span class="strong"><strong>    NavigationManager.NavigateTo("World");</strong></span>
<span class="strong"><strong>  }</strong></span>
  break;</pre></div><p>As the battle is now in progress and the control is being passed to the player, we need some interaction from the user. So let's give them something to click on with a smarter GUI.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec121"></a>Bring on the GUI</h3></div></div></div><p>Before we can start acting on the state machine, we first need to add something for the player to interact with, namely, the weapons the player possesses to knock those pesky goblins into the middle of the next week.</p><p>To do this, we will add a nice 2D graphical command bar with button placements using the 2D system instead of the <a id="id809" class="indexterm"></a>aging Unity GUI system. The following is a sample of what we will be building:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_09_05.jpg" /></div><p>The system is also flexible and dynamic enough to work in any portion of the screen, with any number of buttons, even with multiple columns and rows if you wish.</p><p><code class="literal">CommandBar</code> (the container) manages the placement, and the state of the bar can contain any number of command buttons; each button will display the item it is managing and its input control.</p><p>As the command bar and<a id="id810" class="indexterm"></a> command buttons are codependent, our code won't compile until they are both implemented, so let's start with the <code class="literal">CommandBar</code> class and then add the button definition to it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note113"></a>Note</h3><p>The command bar and button code was refactored and updated to 2D from an existing open source project; it can be found at <a class="ulink" href="http://github.com/fholm/unityassets/tree/master/ActionBars" target="_blank">github.com/fholm/unityassets/tree/master/ActionBars</a>.</p><p>The full 3D implementation also has several other features you might like to implement in the command bar, such as cooldowns, multiselects, and descriptors. So check it out if you wish.</p><p>You might also want to check out the rest of Fredrik's other free assets in the repository.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec52"></a>The command bar</h4></div></div></div><p>Starting <a id="id811" class="indexterm"></a>with the <a id="id812" class="indexterm"></a>command bar manager, create a C# script called <code class="literal">CommandBar</code> in <code class="literal">Assets\Scripts</code> and replace its contents with the following class definition and properties:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class CommandBar : MonoBehaviour {

  private CommandButton [] commandButtons;

  public float buttonSize = 1.28f;
  public float buttonRows = 1;
  public float buttonColumns = 6;
  public float buttonRowSpacing = 0;
  public float buttonColumnSpacing = 0;

  public Sprite DefaultButtonImage;
  public Sprite SelectedButtonImage;

  private float ScreenHeight;
  private float ScreenWidth;
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note114"></a>Note</h3><p>Remember, where <code class="literal">CommandButton</code> is referenced, it will show as an error until we add the <code class="literal">CommandButton</code> class to the next section.</p></div><p>The <a id="id813" class="indexterm"></a>properties <a id="id814" class="indexterm"></a>should speak for themselves: an array for the buttons that the bar is managing, settings related to button's positioning, two images to use for the base button backdrops, and finally a couple of properties to manage the screen's real estate that the command bar will be drawn in.</p><p>Next, we need a few controlled properties. These will be accessible in the code but not visible in the editor because they are not marked as <code class="literal">[SerializeField]</code>:</p><div class="informalexample"><pre class="programlisting">public int Layer
{
  get { return gameObject.layer; }
}

float Width
{
  get
  {
    return (buttonSize * buttonColumns) + Mathf.Clamp((button ColumnSpacing * (buttonColumns - 1)), 0, int.MaxValue);
  }
}

float Height
{
  get
  {
    return (buttonSize * buttonRows) + Mathf.Clamp((button ColumnSpacing * (buttonRows - 1)), 0, int.MaxValue);
  }
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note115"></a>Note</h3><p>For more information about class attributes and editor tags, such as <code class="literal">[SerializeField]</code>, check out <a class="link" href="#" linkend="ch12">Chapter 12</a>, <span class="emphasis"><em>Deployment and Beyond</em></span>, and <a class="link" href="#" linkend="appA">Appendix</a>, <span class="emphasis"><em>Additional Resources</em></span>.</p></div><p>The <a id="id815" class="indexterm"></a>preceding code just enables us to discover the layer the command bar is<a id="id816" class="indexterm"></a> assigned to and ensure any child elements we add can be assigned to the same layer. The remaining expose the calculated width and height for the entire command bar.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip65"></a>Tip</h3><p>If you create a public variable, it will be visible in the code and the editor, for example:</p><div class="informalexample"><pre class="programlisting">public float myPublicVariable;</pre></div><p>If you create a private variable, it will only be visible within the current class in the code, for example:</p><div class="informalexample"><pre class="programlisting">private float myPrivateVariable;</pre></div><p>If you create a variable property with a public property getter (<code class="literal">get</code>), it will be visible to any reference in the class but <span class="emphasis"><em>not</em></span> in the editor, for example:</p><div class="informalexample"><pre class="programlisting">private float myPrivateVariable;
public float  myPublicProperty
{
  get { return  myPrivateVariable; }
}</pre></div><p>The pattern you use is up to you, based on how you need to access/control the property.</p><p>You can also customize the visibility of the properties in the editor using the <code class="literal">([SerializeField]</code> and <code class="literal">[HideinInspector]}</code> attributes; more information on this will be provided in <a class="link" href="#" linkend="ch12">Chapter 12</a>, <span class="emphasis"><em>Deployment and Beyond</em></span>, and <a class="link" href="#" linkend="appA">Appendix</a>, <span class="emphasis"><em>Additional Resources</em></span>.</p></div><p>To ensure that we can also anchor the command bar to a region on the screen, we will enable it to be placed relative to a fixed position such as top-left and bottom-right. To do this, we will first need a new <code class="literal">enum</code> state for all the positions we are going to support. So, create a new script in <code class="literal">Assets\Scripts\Classes</code> called <code class="literal">ScreenPositionAnchorPoint</code> and replace its contents with the following:</p><div class="informalexample"><pre class="programlisting">public enum ScreenPositionAnchorPoint 
{
    TopLeft,
    TopCenter,
    TopRight,
    MiddleLeft,
    MiddleCenter,
    MiddleRight,
    BottomLeft,
    BottomCenter,
    BottomRight
}</pre></div><p>Now <a id="id817" class="indexterm"></a>returning to the <code class="literal">CommandBar</code> script, we can add the following <a id="id818" class="indexterm"></a>variables to the top of the script to track the desired anchor point on the screen using this new <code class="literal">enum</code>:</p><div class="informalexample"><pre class="programlisting">public bool anchor = true;
public Vector2 anchorOffset = Vector2.zero;
public ScreenPositionAnchorPoint  anchorPoint = ScreenPositionAnchorPoint.BottomCenter;</pre></div><p>Then, to work out where exactly on the screen the command bar should be based on this anchor point, we just need a simple helper function. So, add the following to the bottom of the <code class="literal">CommandBar</code> script:</p><div class="informalexample"><pre class="programlisting">Vector2 CalculateAnchorScreenPosition()
{
  Vector2 position = Vector2.zero;

  switch (anchorPoint)
  {
    case ScreenPositionAnchorPoint.BottomLeft:
      position.y = -(ScreenHeight / 2) + Height;
      position.x = -(ScreenWidth / 2) + buttonSize;
      break;

    case ScreenPositionAnchorPoint.BottomCenter:
      position.y = -(ScreenHeight / 2) + Height;
      position.x = -(Width / 2);
      break;

    case ScreenPositionAnchorPoint.BottomRight:
      position.y = -(ScreenHeight / 2) + Height;
      position.x = (ScreenWidth / 2) - Width;
      break;

    case ScreenPositionAnchorPoint.MiddleLeft:
      position.y = (Height / 2);
      position.x = -(ScreenWidth / 2) + buttonSize;
      break;

    case ScreenPositionAnchorPoint.MiddleCenter:
      position.y = (Height / 2);
      position.x = -(Width / 2);
      break;

    case ScreenPositionAnchorPoint.MiddleRight:
      position.y = (Height / 2);
      position.x = (ScreenWidth / 2) - Width;
      break;
    case ScreenPositionAnchorPoint.TopLeft:
      position.y = (ScreenHeight / 2) - Height;
      position.x = -(ScreenWidth / 2) + buttonSize;
      break;

    case ScreenPositionAnchorPoint.TopCenter:
      position.y = (ScreenHeight / 2) - Height;
      position.x = -(Width / 2);
      break;

    case ScreenPositionAnchorPoint.TopRight:
      position.y = (ScreenHeight / 2) - Height;
      position.x = (ScreenWidth / 2) - Width;
      break;
  }
  return anchorOffset + position;
}</pre></div><p>With all <a id="id819" class="indexterm"></a>the settings in place for the command bar, we next need to <a id="id820" class="indexterm"></a>initialize it. So, add an <code class="literal">Awake</code> function as follows:</p><div class="informalexample"><pre class="programlisting">void Awake()
{
  ScreenHeight = Camera.main.orthographicSize * 2;
  ScreenWidth = ScreenHeight * Screen.width / Screen.height;
}</pre></div><p>This simply displays the current screen's size, which will be used to scale the command bar to the screen.</p><p>Finally, to complete the initialization, we need to set up the available buttons based on the settings for the command bar. This is done in three parts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Looping<a id="id821" class="indexterm"></a> through the columns and rows for the<a id="id822" class="indexterm"></a> command bar</p></li><li style="list-style-type: disc"><p>Creating new command bar buttons for each position</p></li><li style="list-style-type: disc"><p>Aligning the display position for each button</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note116"></a>Note</h3><p>Like with the inventory system, there is a cooperative relationship between the <code class="literal">CommandBar</code> class and its command bar buttons. So, the code won't be compiled until we are done. Bear this in mind as we progress.</p></div><p>First we need to be able to create a button, so add the following function:</p><div class="informalexample"><pre class="programlisting">CommandButton CreateButton()
{
  // Create our new game object
  GameObject go = new GameObject("CommandButton");

  // Add components
  go.AddComponent&lt;SpriteRenderer&gt;();
  go.AddComponent&lt;BoxCollider2D&gt;();

  go.transform.parent = transform;

  // Init
  CommandButton button = go.AddComponent&lt;CommandButton&gt;();
  button.Init(this);

  return button;
}</pre></div><p>This function performs the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Creates a new empty game object (and names it <code class="literal">CommandButton</code>)</p></li><li style="list-style-type: disc"><p>Adds two game components (<code class="literal">SpriteRenderer2D</code> and<code class="literal"> BoxCollider2D</code>) that are required for the <code class="literal">CommandButton</code> game object to function; more on this later</p></li><li style="list-style-type: disc"><p>Makes the button a child of the command bar by setting its parent transform</p></li><li style="list-style-type: disc"><p>Creates and assigns the <code class="literal">CommandButton</code> script we created earlier to the new button</p></li><li style="list-style-type: disc"><p>Calls the <code class="literal">Init</code> function of the button (this doesn't exist yet; we will come back to this later)</p></li><li style="list-style-type: disc"><p>Once everything is<a id="id823" class="indexterm"></a> ready, it returns the new <code class="literal">CommandButton</code> game object to whoever called it</p></li></ul></div><p>Now we<a id="id824" class="indexterm"></a> have the ability to create buttons; we will also need the ability to re-position them within the command bar. For this, we will add another function:</p><div class="informalexample"><pre class="programlisting">void InitButtonPositions()
{
  int i = 0;
  float xPos = 0;
  float yPos = 0;

  for (int r = 0; r &lt; buttonRows; ++r)
  {
    xPos = 0;

    for (int c = 0; c &lt; buttonColumns; ++c)
    {
      commandButtons[i].transform.localScale = new Vector3(buttonSize, buttonSize, 0);
      commandButtons[i].transform.localPosition = new Vector3(xPos, yPos, 0);

      i++;
      xPos += buttonSize + buttonColumnSpacing;
    }

    yPos -= buttonSize + buttonRowSpacing;
  }
}</pre></div><p>This function will simply loop through all the buttons assigned to the command bar and then scale and position them accordingly. We then have a set of arranged buttons within the command bar according to the row and column settings we configured.</p><p>With all the helper functions<a id="id825" class="indexterm"></a> defined, we can now actually complete the<a id="id826" class="indexterm"></a> initialization of the <code class="literal">CommandBar</code> class. To do this, add the following function:</p><div class="informalexample"><pre class="programlisting">void InitCommandButtons()
{
  commandButtons = new CommandButton[(int)buttonRows * (int)buttonColumns];

  for (int i = 0; i &lt; commandButtons.Length; i++)
  {
    var newButton = CreateButton();

    if (i &lt; GameState.CurrentPlayer.Inventory.Count)
    {
      newButton.AddInventoryItem(GameState.CurrentPlayer.Inventory[i]);     }

    commandButtons[i] = newButton;

  }

  InitButtonPositions();
}</pre></div><p>Here, we simply set up the button array based on the configured rows and columns, and then added a new empty command bar button to each element using the preceding <code class="literal">CreateButton</code> function. Once all the buttons have been created, we then use the <code class="literal">InitButtonPositions</code> function to position them correctly within the command bar.</p><p>Then, if the player has any weapons in their inventory, it will add that item to the button using a simple helper function (which we'll add in the next section).</p><p>All that is left is to ensure that the command bar is positioned correctly on the screen according to the anchor point. To do this, we first need another helper function to set the position:</p><div class="informalexample"><pre class="programlisting">void SetPosition(float x, float y)
{
  transform.position = new Vector3(x, y, 0);
}</pre></div><p>We put this in a separate function so that if we need to apply offsets for the <code class="literal">CommandBar</code> class for different platforms, we can do it from this central helper instead of doing it throughout the code.</p><p>With the new helper in <a id="id827" class="indexterm"></a>place, we need to replace/add the <code class="literal">Update</code> function that will ensure the bar<a id="id828" class="indexterm"></a> is drawn to the correct portion of the screen's space:</p><div class="informalexample"><pre class="programlisting">void Update () {
  Vector2 position = Vector2.zero;

  if (anchor)
  {
    position = CalculateAnchorScreenPosition();
  }
  else
  {
    position = transform.position;
  }
  SetPosition(position.x, position.y);
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note117"></a>Note</h3><p>We still use the <code class="literal">SetPosition</code> function <a id="id829" class="indexterm"></a>here as this method places the command bar relative to the position in the screen space we want it to be drawn in. This still may need further offsetting if a particular platform is needed, such as Ouya or Xbox.</p></div><p>With this, each frame simply gets the intended position of the command bar, either from the anchor point or the position set in the editor, and uses our helper function to push it to the correct part of the screen.</p><p>Finishing off, we need to call our <code class="literal">InitCommandButtons</code> function in the preceding code when the script starts:</p><div class="informalexample"><pre class="programlisting">void Start () {
  InitCommandButtons();
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec53"></a>The command button</h4></div></div></div><p>Next we'll add <a id="id830" class="indexterm"></a>the <code class="literal">CommandButton</code> class; firstly create a new C# script in <code class="literal">Assets\Scripts</code> called <code class="literal">CommandButton</code> and replace its contents with the following:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

[RequireComponent(typeof(SpriteRenderer))]
[RequireComponent(typeof(BoxCollider2D))]
public class CommandButton : MonoBehaviour
{
  private CommandBar commandBar;
  public InventoryItem Item;
  bool selected;
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note118"></a>Note</h3><p>Note the additional attributes placed on this class for the <code class="literal">SpriteRender</code> and <code class="literal">BoxCollider2D</code> components. This is just Unity's way of stating that these items are mandatory for this object when used in the scene. If you forget, Unity will warn you.</p></div><p>We have defined a tight reference for the <code class="literal">CommandBar</code> class that the button is a child of so that the button knows what is controlling it and they can communicate accordingly. This enables the button to tell the <code class="literal">CommandBar</code> class when it is selected, and the <code class="literal">CommandBar</code> class will be able to clear its selection, if need be.</p><p>We also have a property for <code class="literal">InventoryItem</code> as we are going to use this bar to activate items for use in the battle (the player's sword), and lastly, a flag to track whether the button is selected or not.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip69"></a>Tip</h3><p>As described, we are using tight coupling between the button and the command bar because of their relationship, as opposed to the loose coupling we did before using messaging. We will still use messaging for some actions, but we will do that later.</p><p>It's important to understand when you should tightly couple objects and when you shouldn't using the appropriate pattern as required.</p><p>Basically, if a parent needs to manage its children, then you should tightly couple them so they can communicate effectively. If the two objects have no direct relationship, then either of them uses static functions, central state classes, or messaging to route information between them.</p></div><p>Next, we'll add the <code class="literal">Init</code> function <a id="id831" class="indexterm"></a>that we called earlier to the <code class="literal">CreateButton</code> function:</p><div class="informalexample"><pre class="programlisting">public void Init(CommandBar commandBar)
{
  this.commandBar = commandBar;
  gameObject.layer  = commandBar.Layer;

  var collider = gameObject.GetComponent&lt;BoxCollider2D&gt;();
  collider.size = new Vector2(1f, 1f);

  var renderer = gameObject.GetComponent&lt;SpriteRenderer&gt;();
  renderer.sprite = commandBar.DefaultButtonImage;
  renderer.sortingLayerName = "GUI";
  renderer.sortingOrder = 5;
}</pre></div><p>When initializing<a id="id832" class="indexterm"></a> the button's contents, we are setting up all the components this object has assigned to it; they are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>First we define a tight reference for the <code class="literal">CommandBar</code> class itself because each button is managed by the <code class="literal">CommandBar</code> class.</p></li><li style="list-style-type: disc"><p>Next we set the layer of the new button to be the same as the command bar.</p></li><li style="list-style-type: disc"><p>Then we get the <code class="literal">BoxCollider2D</code> game object and set its size appropriately. (The default is actually the same as we are setting it, but it is worth being prudent and ensuring it is the size we want; don't assume!)</p></li><li style="list-style-type: disc"><p>Finally, we get <code class="literal">SpriteRenderer</code>, give it the default button image, and set its sorting parameters as required; if this is not the case, you won't see it because it will be drawn behind everything else.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note119"></a>Note</h3><p>In an odd peculiarity (that can leave you scratching your head for hours), if you try setting up the preceding code in line with where you are using it (in the <code class="literal">CommandBar</code> script) instead of within the class script (as in the preceding code), it will not actually work. It will create the new game object, but anything else just gets forgotten when used. Try it for yourself if you wish.</p></div><p>So now we can manage what the <code class="literal">InventoryItem</code> button is managing; we'll add another function to do this in a controlled way. This is because there is a fair amount of setup required in order for us to display the item on top of the button:</p><div class="informalexample"><pre class="programlisting">public void AddInventoryItem(InventoryItem item)
{
  this.Item = item;
  var childGO = new GameObject("InventoryItemDisplayImage");
  var renderer = childGO.AddComponent&lt;SpriteRenderer&gt;();
  renderer.sprite = item.Sprite;
  renderer.sortingLayerName = "GUI";
  renderer.sortingOrder = 10;
  renderer.transform.parent = this.transform;
  renderer.transform.localScale *= 4;
}</pre></div><p>So when the <code class="literal">CommandBar</code> class requests to put <code class="literal">InventoryItem</code> in a button, it creates a new empty <a id="id833" class="indexterm"></a>game object and adds a sprite renderer to it with the relevant <a id="id834" class="indexterm"></a>settings for it to display. We also keep a reference for the item being displayed so that we can reuse its properties later (like how much damage our sword would bring about).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec54"></a>Adding the command bar to the scene</h4></div></div></div><p>Open up the <span class="strong"><strong>Battle</strong></span> <a id="id835" class="indexterm"></a>scene if you haven't <a id="id836" class="indexterm"></a>done so already so that we can add the new<a id="id837" class="indexterm"></a> command bar to the <span class="strong"><strong>Battle</strong></span> scene. The command bar we have built is part of the battle controller, so we will add the new script to the <code class="literal">BattleManager</code> game object as a second script.</p><p>So, select the <code class="literal">BattleManager</code> game object and either drag the <code class="literal">CommandBar</code> script to it, or click on <span class="strong"><strong>Add Component</strong></span> and navigate to <span class="strong"><strong>Scripts</strong></span> | <span class="strong"><strong>Command Bar</strong></span>; the inspector should now look as follows:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_09_22.jpg" /></div><p>Next, we'll need the<a id="id838" class="indexterm"></a> images for our buttons. In <a id="id839" class="indexterm"></a>the assets that accompany this title, you <a id="id840" class="indexterm"></a>will find a <code class="literal">button1.png</code> spritesheet that contains four button highlights, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_09_23.jpg" /></div><p>Add this to the<a id="id841" class="indexterm"></a> project in the <code class="literal">UI</code> folder<a id="id842" class="indexterm"></a> under <code class="literal">Assets\Sprites\</code> from the assets included with this title, set <span class="strong"><strong>Sprite Mode</strong></span> to <span class="strong"><strong>Multiple</strong></span>, and<a id="id843" class="indexterm"></a> open up <span class="strong"><strong>Sprite Editor</strong></span>. Next, use the <span class="strong"><strong>Grid</strong></span> slicing mode and set both the pixel size settings for <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> to <code class="literal">128</code>; this gives us a nice 2 x 2 split of the sprite with our four button images as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_09_24.jpg" /></div><p>Now if we return to the <code class="literal">CommandBar</code> script we added to our <code class="literal">BattleManager</code> script, we can configure it as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849697347/graphics/7347OT_09_25.jpg" /></div><p>You can play <a id="id844" class="indexterm"></a>with these settings if you wish to<a id="id845" class="indexterm"></a> meet your own style and flavor. If you run the<a id="id846" class="indexterm"></a> project now, six new buttons will appear floating at the top-right corner of our screen.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip70"></a>Tip</h3><p>Granted, unless you visit the shop first, no weapons will appear in the command bar. What I recommend (unless you want to keep visiting the shop you keep testing) is to add a new property to the <code class="literal">CommandBar</code> script so that you can add a <code class="literal">debug </code>inventory item, as follows:</p><div class="informalexample"><pre class="programlisting">public InventoryItem debugItem;</pre></div><p>Then, add this item to the players inventory when the script starts, as follows:</p><div class="informalexample"><pre class="programlisting">  void Awake()
  {
  #if UNITY_EDITOR
    GameState.CurrentPlayer.AddinventoryItem(debugItem);
  #endif
  }</pre></div><p>This way you will always see a weapon while you're testing, and it will only be added to the editor, thanks to the <code class="literal">#if UNITY_EDITOR</code> precompiler directive.</p><p>For more details on the precompiler directives <a id="id847" class="indexterm"></a>supported in Unity, see <a class="ulink" href="http://docs.unity3d.com/Manual/PlatformDependentCompilation.html" target="_blank">http://docs.unity3d.com/Manual/PlatformDependentCompilation.html</a>.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec122"></a>Selecting the weapon</h3></div></div></div><p>Now that we have our<a id="id848" class="indexterm"></a> command bar with a selection of buttons and items to display, it would be good if we could actually use it as well.</p><p>The pattern I opted for with this bar is to make it so you can only select a single button at a time (clicking on another button will clear any existing selected items). This is just one pattern of course, and you could update/modify the code in this section as you wish. For now, let's see what's involved in managing this selection and also inform the battle manager that something has been selected.</p><p>In brief, what we will do is the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Use the <code class="literal">OnMouseDown</code> function on a command button to detect a user's click</p></li><li style="list-style-type: disc"><p>This will cause a message to be fired to tell the <code class="literal">BattleManager</code> state that a button has been clicked</p></li><li style="list-style-type: disc"><p>The <code class="literal">BattleManager</code> state will then take whichever inventory item has been selected and use it as an active weapon</p></li><li style="list-style-type: disc"><p>If the user clicks on another button, this will override the previous selection, even if it is empty</p></li></ul></div><p>So let's see what's involved in doing that.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec55"></a>Selecting a command button</h4></div></div></div><p>To complete the story of the button, we need to <a id="id849" class="indexterm"></a>add a couple of handlers to let it be clicked; change its selection state, the button's sprite, and a function to safely clear the button's selection state.</p><p>First, we'll add the <code class="literal">UpdateSelection</code> function to the <code class="literal">CommandButton</code> script:</p><div class="informalexample"><pre class="programlisting">void UpdateSelection()
{
  var renderer = gameObject.GetComponent&lt;SpriteRenderer&gt;();
  renderer.sprite = selected ? commandBar.SelectedButtonImage : commandBar.DefaultButtonImage;
}</pre></div><p>Here, we simply <a id="id850" class="indexterm"></a>get the <code class="literal">SpriteRenderer</code> component or the button itself (not its child item) and assign the correct button sprite, either the selected or unselected image configured for the command bar.</p><p>Next, we add the <code class="literal">ClearSelection</code> function:</p><div class="informalexample"><pre class="programlisting">public void ClearSelection()
{
  selected = false;
  UpdateSelection();
}</pre></div><p>This simply sets the selected state to <code class="literal">false</code> and then calls the <code class="literal">UpdateSelection</code> function to set the button sprite appropriately.</p><p>Finally, we add the <code class="literal">OnMouseDown</code> function to react to the <code class="literal">BoxCollider2D</code> component we have on the button and receive <span class="emphasis"><em>clicked</em></span> events:</p><div class="informalexample"><pre class="programlisting">void OnMouseDown()
{
  if (commandBar.CanSelectButton)
  {
    selected = !selected;
    UpdateSelection();

    commandBar.Selectbutton(selected ? this : null);
  }
}</pre></div><p>So now when the user clicks, it will flip the selected state for the button and then call the <code class="literal">UpdateSelection</code> function to set the correct button sprite. You will note that this function depends on a property in the <code class="literal">CommandBar</code> script that doesn't exist yet. This is there so that if for some reason the command bar is disabled or input is not allowed, then we can ignore any clicks; we'll add this shortly.</p><p>Once the user has selected the button, we tell the command bar about it. We then let it manage what happens to the selection after that. We could handle it within the button itself, but this would mean lots of complicated code in this very simple class; it's best to leave it up to the manager. This function doesn't exist yet in the command bar, so let's add it now.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec56"></a>Managing the selections from the command bar</h4></div></div></div><p>As the command bar<a id="id851" class="indexterm"></a> manages all the buttons that can be selected and we only want one item to be selected at a time (in the weapon bar at least), we need a way to unselect all the buttons (if the player changes their mind and wants to select another button). The buttons do not know about each other; only the command bar knows about all its children. This might also be used to clear any selections once we move on to a different phase of the battle.</p><p>First we need some additional variables and properties to manage what is selected in the command bar, so open up the <code class="literal">CommandBar</code> script and add the following variables to the top of the script, just under the existing variables:</p><div class="informalexample"><pre class="programlisting">private bool canSelectButton = true;
private CommandButton selectedButton;

public bool CanSelectButton
{
  get
  {
    return canSelectButton;
  }
}</pre></div><p>Now we can track which button is currently selected.</p><p>As we will need a way to clear the current selection (for the enemies turn or the player's next turn) to avoid having to duplicate the code everywhere, we will reuse the <code class="literal">ResetSection</code> function to set a new selection if we have one. So let's add this public function as follows:</p><div class="informalexample"><pre class="programlisting">public void ResetSelection(CommandButton button)
{
  if (selectedButton != null)
  {
    selectedButton.ClearSelection();
  }
  selectedButton = button;
}</pre></div><p>This will simply clear the existing selection if there is one and then track the new selection. If the user has simply cleared their last selection, then this would just be <code class="literal">null</code>.</p><p>Now we just need to be able <a id="id852" class="indexterm"></a>to actually select a button, but first we need a few things.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec57"></a>Updating the BattleManager state with selections</h4></div></div></div><p>Now that the <a id="id853" class="indexterm"></a>command bar can select and deselect buttons, we need to be able to tell the <code class="literal">BattleManager</code> state that the player has selected a weapon. For this, we'll use messaging as there is no direct relationship between the command bar and the <code class="literal">BattleManager</code> state.</p><p>First we'll need to beef up the <code class="literal">MessagingManager</code> script with a new event we want to publish as we have done previously with the Dialog and UI events.</p><p>So, open up the <code class="literal">MessagingManager</code> script and add the following:</p><div class="informalexample"><pre class="programlisting">private List&lt;Action&lt;InventoryItem&gt;&gt; inventorySubscribers = new List&lt;Action&lt;InventoryItem&gt;&gt;();

// Subscribe method for Inventory manager
public void SubscribeInventoryEvent
(Action&lt;InventoryItem&gt; subscriber)
{
  if (inventorySubscribers != null)
  {
    inventorySubscribers.Add(subscriber);
  }
}

// Broadcast method for Inventory manager
public void BroadcastInventoryEvent(InventoryItem itemInUse)
{
  foreach (var subscriber in inventorySubscribers)
  {
    subscriber(itemInUse);
  }
}

// Unsubscribe method for Inventory manager
public void UnSubscribeInventoryEvent(Action&lt;InventoryItem&gt; subscriber)
{
  if (inventorySubscribers != null)
  {
    inventorySubscribers.Remove(subscriber);
  }
}

// Clear subscribers method for Inventory manager
public void ClearAllInventoryEventSubscribers()
{
  if (inventorySubscribers != null)
  {
    inventorySubscribers.Clear();
  }
}</pre></div><p>With the <a id="id854" class="indexterm"></a>message in place, we just need to broadcast this new message when the player selects a button. We will add a new <code class="literal">SelectButton</code> method to the <code class="literal">CommandBar</code> script to complete the journey, as follows:</p><div class="informalexample"><pre class="programlisting">public void Selectbutton(CommandButton button)
{
  if (selectedButton != null)
  {
    selectedButton.ClearSelection();
  }
  selectedButton = button;
  if (selectedButton != null)
  {
    MessagingManager.Instance.BroadcastInventoryEvent(selectedButton.Item);
  }
  else
  {
    MessagingManager.Instance.BroadcastInventoryEvent(null);
  }
}</pre></div><p>To finish off the <code class="literal">CommandBar</code> script while we are updating its messaging, let's also subscribe to the UI event's message and link it to the <code class="literal">canSelectbutton</code> variable/property we added earlier.</p><p>So, create a new delegate method called <code class="literal">SetCanSelectButton</code>:</p><div class="informalexample"><pre class="programlisting">void SetCanSelectButton(bool state)
{
  canSelectButton = !state;
}</pre></div><p>Then, update the <code class="literal">Start</code> function in the <code class="literal">CommandBar</code> script as follows:</p><div class="informalexample"><pre class="programlisting">void Start () {
  InitCommandButtons();
<span class="strong"><strong>  MessagingManager.Instance.SubscribeUIEvent(SetCanSelectButton);</strong></span>
}</pre></div><p>Don't forget to<a id="id855" class="indexterm"></a> unsubscribe the event from it as well when the command bar is destroyed by adding the <code class="literal">OnDestroy</code> method:</p><div class="informalexample"><pre class="programlisting">void OnDestroy()
{
  if (MessagingManager.Instance != null)
  {
    MessagingManager.Instance.UnSubscribeUIEvent(SetCanSelectButton);
  }
}</pre></div><p>Now whenever the UI is locked, we ensure that no further button presses are allowed, such as for events when the player has attacked the enemy.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec58"></a>Updating the BattleManager state with a weapon</h4></div></div></div><p>Finally, we<a id="id856" class="indexterm"></a> return to the <code class="literal">BattleManager</code> script and decide what to do with this new weapon the user has selected. First we need a variable to store the selected weapon in, so add the following to the top of the <code class="literal">BattleManager</code> script with the rest of the variables:</p><div class="informalexample"><pre class="programlisting">private InventoryItem selectedWeapon;</pre></div><p>Next we need a handler function to store the new selected weapon:</p><div class="informalexample"><pre class="programlisting">private void InventoryItemSelect(InventoryItem item)
{
  selectedWeapon = item;
}</pre></div><p>Then, we have to wire up this function to the event we are broadcasting from the <code class="literal">BattleManage</code>r state in the <code class="literal">Start</code> method:</p><div class="informalexample"><pre class="programlisting">MessagingManager.Instance.SubscribeInventoryEvent(InventoryItemSelect);</pre></div><p>Now we know what the player is fighting with, let's update the UI with some instructions.</p><p>So far, <a id="id857" class="indexterm"></a>when the battle starts in the state machine, an intro is shown and then two seconds later, it is the player's turn; however, at the moment, the player is completely unaware of this, so let's update the <code class="literal">OnGUI</code> method in the <code class="literal">BattleManager</code> script as follows:</p><div class="informalexample"><pre class="programlisting">void OnGUI()
{
  switch (currentBattleState)
  {
    case BattleState.Begin_Battle:
      break;
    case BattleState.Intro:
<span class="strong"><strong>      GUI.Box(new Rect((Screen.width / 2) - 150, 50, 300, 50), "Battle between Player and Goblins");</strong></span>
      break;
    case BattleState.Player_Move:
      if (GUI.Button(new Rect(10, 10, 100, 50), "Run Away"))
      {
        GameState.PlayerReturningHome = true;
        NavigationManager.NavigateTo("World");
      }

<span class="strong"><strong>      if (selectedWeapon == null)</strong></span>
<span class="strong"><strong>      {</strong></span>
<span class="strong"><strong>        GUI.Box(new Rect((Screen.width / 2) - 50, 10, 100, 50), "Select Weapon");</strong></span>
<span class="strong"><strong>      }</strong></span>
      break;
    case BattleState.Player_Attack:
      break;
    case BattleState.Change_Control:
      break;
    case BattleState.Enemy_Attack:
      break;
    case BattleState.Battle_Result:
      break;
    default:
      break;
  }
}</pre></div><p>In the <code class="literal">Intro</code> part, we <a id="id858" class="indexterm"></a>display a simple message to inform the player about the battle, and when it is the player's turn, we display the <span class="strong"><strong>Select Weapon</strong></span> message until they have selected one.</p></div></div></div>