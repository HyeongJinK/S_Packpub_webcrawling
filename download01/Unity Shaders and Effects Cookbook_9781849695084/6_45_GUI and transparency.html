<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec46"></a>GUI and transparency</h2></div></div><hr /></div><p>Now that we<a id="id422" class="indexterm"></a> have covered the basics of creating transparent <a id="id423" class="indexterm"></a>Shaders and learned how we can control the order in which objects are drawn, let's take a look at a practical production scenario in which we would need to use transparency and have control over the order in which the transparent objects are drawn.</p><p>Creating GUIs for Unity is definitely a huge task. One could use the Built-in <code class="literal">OnGUI()</code> function<a id="id424" class="indexterm"></a> to create their GUI using a bunch of 2D images with alpha, and let Unity draw the images to the screen. Or, one could create an actual 3D GUI system in which you can actually see your GUI elements in the scene view, inside the Unity editor. We are going to take a look at this last approach. We need to be able to use a sheet of 2D images and place them onto 3D objects in our scene, so they can be used as GUI elements for a game.</p><p>We are also going to take a look at some issues that will pop up when using a 3D GUI approach, such as drawing order, and learn a simple way in which we can solve these issues.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec124"></a>Getting ready</h3></div></div></div><p>For this <a id="id425" class="indexterm"></a>recipe we will be creating a very simple GUI example, <a id="id426" class="indexterm"></a>and so we are going to need to construct a sheet of GUI elements for our scene. When a GUI is created in this 3D manner, a texture sheet is created in order to save on the amount of textures we have to use. This means that all button graphics, icon graphics, and in some cases even text graphics are laid out onto a single texture with its alpha channel set to mask out where the texture sheet should be transparent and where it's opaque or semi-transparent. Refer to the following screenshot of the texture sheet we will be using for this recipe:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_15.jpg" /></div><p>So let's start to construct our mock GUI for our Shader writing. This will allow us to simulate the kinds of things we have to think about when working on a GUI system for a production.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Construct a GUI texture sheet similar to the texture sheet seen in the preceding screenshot. Make sure to include the alpha texture in the alpha channel of the texture sheet.</p></li><li><p>We also have to create some simple geometry for our GUI. In our case, Maya was used to generate the meshes that the GUI elements sit on.</p></li><li><p>Create a new scene in Unity and place a plane and a directional light into the scene.</p></li><li><p>Then, create a new Shader and a new Material for our mock GUI and assign the Shader to the Material.</p></li><li><p>Now, we simply assign our Material to our GUI objects in our scene to complete the setup process.</p></li><li><p>When completed with the previous steps, your scene should look similar to the following screenshot. You are more than welcome to use the scene that is included with this book, but it is always a good practice to create your own:</p></li></ol></div><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_16.jpg" /></div><p>Not very interesting to look at and our alpha isn't creating the transparency effect we need in order to have a real game GUI. We need to create our GUI Shader in order for us to create a more elegant looking GUI. So let's do that now.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec125"></a>How to do it…</h3></div></div></div><p>In order for our <a id="id427" class="indexterm"></a>GUI to have transparency, we need to create the Shader<a id="id428" class="indexterm"></a> so that we can tell Unity that these objects are transparent.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>As usual, we need to populate our <code class="literal">Properties</code> block with the appropriate properties so that we can interact with our Shader in the Unity editor.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_17.jpg" /></div></li><li><p>We then need to move down to our <code class="literal">SubShader</code> block and start it by setting the type of render queue we are going to be using and setting up the lighting model. You'll also notice that we have introduced some new tags to our <code class="literal">SubShader</code> block. We will cover these in the next section. For now, enter the following code at the top of your <code class="literal">SubShader</code> block:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_18.jpg" /></div></li><li><p>After <a id="id429" class="indexterm"></a>our <code class="literal">SubShader</code> tags have been declared, we<a id="id430" class="indexterm"></a> need to move on to our <code class="literal">#pragma</code> directives or statements, and declare our own custom lighting model and add some new arguments we haven't seen before. This will allow us to create a completely unlit surface and let the full color of the texture sheet drive the look of our GUI:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_19.jpg" /></div></li><li><p>Our next step is to make the connection between the values in our <code class="literal">Properties</code> block to the variables in our <code class="literal">CGPROGRAM</code> block:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_20.jpg" /></div></li><li><p>After all of our Shader setup is completed, we have to write our <span class="strong"><strong>unlit lighting model</strong></span>
<a id="id431" class="indexterm"></a>. This is fairly simple and is simply passing the color value of the texture sheet to our <code class="literal">SurfaceOutput</code> struct:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_21.jpg" /></div></li><li><p>As always, if we are going to be using textures, we have to make sure that we get the UVs for that texture inside the <code class="literal">Input</code> struct:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_22.jpg" /></div></li><li><p>Finally, we simply sample our texture and alpha values, and pass them to the <code class="literal">SurfaceOutput</code> struct inside the <code class="literal">surf()</code> function:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_23.jpg" /></div><p>When <a id="id432" class="indexterm"></a>finished with the Shader, you should see <a id="id433" class="indexterm"></a>something very similar to the following screenshot, although if you are using your own custom geometry and texture sheet, your scene will look different. Apart from that, the Shader should be generating an effect of an unlit surface with alpha transparency:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_24.jpg" /></div><p>You'll <a id="id434" class="indexterm"></a>notice though that we are getting a small<a id="id435" class="indexterm"></a> error in our GUI. Our background box, just behind our buttons, is actually rendering over our <span class="strong"><strong>Play Game</strong></span> button. This is because the meshes are so close together that Unity is having a hard time discerning which object to draw first. Since the order is currently being determined by the distance from the camera, Unity is displaying the background box over the button.</p></li><li><p>In order for us to fix this issue, we are going to have to change the render queue on a per-material basis. We can't simply change the render queue in the Shader, as this would cause us to have to write a Shader for each queue level. We need individual control over our Materials. So, we have to write a small C# script that will allow us to achieve this effect. Let's do that now.</p></li><li><p>We first need to create a new C# script in order for us to achieve this fix to our GUI Shader.</p></li><li><p>Once you have created the script, double-click on it to open it up in MonoDevelop.</p></li><li><p>Our first order of business here is to tell this script to run in the editor so that we can see the effects of us changing the queue value in real time in the scene view. To achieve this, we need to declare the <code class="literal">[ExecuteInEditMode]</code> attribute before our class declaration:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_25.jpg" /></div></li><li><p>In order <a id="id436" class="indexterm"></a>for us to change the queue level in real time, we <a id="id437" class="indexterm"></a>need to create a new variable that we can change in the object's <span class="strong"><strong>Inspector</strong></span>. So, we declare a new variable with the name <code class="literal">queueValue</code> and make it public so that it displays in the <span class="strong"><strong>Inspector</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_26.jpg" /></div></li><li><p>We then move on to our <code class="literal">Update()</code> function<a id="id438" class="indexterm"></a> and first see if the object that this script is attached to has a Material assigned to it:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_27.jpg" /></div></li><li><p>Finally, using an <code class="literal">if()</code> statement we then check to make sure our <code class="literal">curMaterial</code> variable has a Material reference in it and that it is not null. This is just to prevent any unnecessary error messages from popping up in the console window.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_28.jpg" /></div></li></ol></div><p>With the <a id="id439" class="indexterm"></a>script completed, you can now assign it to any of our GUI <a id="id440" class="indexterm"></a>elements, and adjust the queue value on the fly in the editor and see the drawing order change. Our GUI scene is now complete and all of our GUI elements are drawing in the right order. We have given ourselves a fine amount of control over the objects in our GUI, very similar to layers in Photoshop, all by creating a Shader and a small script.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_29.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec126"></a>How it works…</h3></div></div></div><p>Beginning <a id="id441" class="indexterm"></a>with the GUI Shader, we have introduced a couple of <a id="id442" class="indexterm"></a>new <code class="literal">SubShader</code> tags that allow us to fine tune how our Shader works with the Unity renderer. By declaring <code class="literal">"IgnoreProjector"="True"</code>, we are telling Unity that we don't want any projector type materials or textures to affect our objects or Shader. This is because we want the GUI to be separate from our scene. All the scene effects, such as projectors, should only affect objects in our game and not our GUI. The <code class="literal">"IgnoreProjector"</code> tag is one way to achieve this.</p><p>Our second new tag is the <code class="literal">"RenderType"="Transparent"</code>. Similar to the <code class="literal">"Queue"</code> tag, this tag categorizes the Shader into the transparent category for Unity's camera effects, just so Unity can give you a more organized way of sorting your objects.</p><p>The last new element to our Shader is the addition of<code class="literal"> novertexlights</code> to the <code class="literal">#pragma</code> directive. This parameter tells Unity that we do not want to use any per-vertex lights or Spherical Harmonics to light our objects. In fact, we do not want to use any lights at all; so we can use this parameter to make our Shader a bit cheaper, which is exactly what we are going for when developing a 3D GUI system.</p><p>Turning our attention to the render queue script we created, the script is simply getting access to the Material attached to our object by using the <code class="literal">transform.renderer.sharedMaterial</code> code. If a Material is in fact attached to the object that the script is assigned to, that line of code will return the Material. If it cannot find a Material, it will return null.</p><p>We then check to see if the script found the Material and change the value of the render queue. If it does not find a Material, we just send a debug message to the console to make the user aware that the object needs a Material.</p><p>This is obviously a simple example of how much control you can have with transparency and the render queue, but this does gives the foundational knowledge you will need to create more robust systems of your own!</p></div></div>