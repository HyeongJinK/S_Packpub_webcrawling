<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec33"></a>Normal maps and reflections in Unity3D</h2></div></div><hr /></div><p>There are situations <a id="id279" class="indexterm"></a>where you are going to want to have the normal also perturb the reflected Cubemap. Let's say you want to simulate a surface like frosted glass, or the surface of an ice cube. You couldn't model in all the details of the surface and expect it to run at 60 fps in your game. We have to use normal maps to fake the effects of higher resolution details, so we need to learn how to pass the normal map information to the reflection effect.</p><p>To accomplish this task, we are going to look at another built-in parameter to the Input struct that will pass in the modified surface normal, generated by the normal mapping technique. So, let's see how we need to modify the <code class="literal">Input</code> struct to produce this effect.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec84"></a>Getting ready</h3></div></div></div><p>Let's create a new, fresh scene by following the next few steps.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Again, we will need a Cubemap to produce our reflection effects. So you can either use the Cubemap from the previous recipes, or generate a new one. The Cubemap we will be using for this recipe, which is included in the sample code for this book, is shown here:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_19.jpg" /></div></li><li><p>We will also <a id="id280" class="indexterm"></a>need a normal map to produce our normal-mapped reflections.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_25.jpg" /></div></li><li><p>Finally, create a new scene with an object, a ground plane, and a directional light, and the create a new Shader and Material. This will allow us to see our Shader and validate that it is working.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec85"></a>How to do it…</h3></div></div></div><p>Now, let's write our Shader code so that we can learn how to add normal maps to a reflective Shader.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's add the properties that we will need to give us the ability to add our own custom Cubemap and normal map. This step should start to seem pretty familiar to you now. You always want to set yourself up with the appropriate properties to let you develop your Shaders. Add the following code to <a id="id281" class="indexterm"></a>your <code class="literal">Properties</code> block in your new Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_26.jpg" /></div></li><li><p>We then need to declare the properties in the <code class="literal">SubShader</code> block so that we can access the data from our <code class="literal">Properties</code> block.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_27.jpg" /></div></li><li><p>The <code class="literal">Input</code> struct then needs to be updated to include the following code. This is where the real magic of normal-mapped reflections happens. By using the <code class="literal">INTERNAL_DATA</code> statement, we can access the surface normal after it has been modified by the normal map:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_28.jpg" /></div></li><li><p>Finally, we need to modify our <code class="literal">surf()</code> function with the following code to get our normal-mapped reflection:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_29.jpg" /></div></li></ol></div><p>The following<a id="id282" class="indexterm"></a> screenshot shows the result of using a normal map to affect the reflection effect:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_17.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec86"></a>How it works…</h3></div></div></div><p>You will notice that this Shader looks very similar to the last Shader we wrote, with one very important difference. We want to use a per-pixel normal map to modify our reflected Cubemap. In order to do this, you have to have the surface normal of the object after the <a id="id283" class="indexterm"></a>normal map has been applied to the Shader. This means that after the lines of code, we need to write:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_30.jpg" /></div><p>Once those lines of code in the Shader have been calculated, the normal on the surface of the model will have been modified; hence, we need to use it to perturb our reflection. We can access this modified normal by declaring <code class="literal">INTERNAL_DATA</code> in our <code class="literal">Input</code> struct, and then using <code class="literal">WorldReflectionVector(IN, o.Normal)</code> as the look-up information for our Cubemap. This is another built-in function that Unity has provided for us, so that we don't have to do the laborious coding ourselves. We can concentrate on just writing the meat of the Shader that produces our desired effects.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec87"></a>There's more…</h3></div></div></div><p>There are quite a few other built-in functions we can access in our <code class="literal">Input</code> struct, and we will most assuredly use them in future chapters; but the following table describes what each of these built-in functions does and how to use them. You can also go to <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaders.html" target="_blank">http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaders.html</a> to get more information about these built-in functions:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /></colgroup><tbody><tr><td style="" align="left" valign="top">
<p>
<code class="literal">float3 viewDir</code>
</p>
</td><td style="" align="left" valign="top">
<p>Will contain view direction, for computing Parallax effects, rim lighting, and so on.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">float4 COLOR</code>
</p>
</td><td style="" align="left" valign="top">
<p>Will contain interpolated per-vertex color.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">float4 screenPos</code>
</p>
</td><td style="" align="left" valign="top">
<p>Will contain screen-space position for reflection effects. Used by WetStreet shader in Dark Unity, for example.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">float3 worldPos</code>
</p>
</td><td style="" align="left" valign="top">
<p>Will contain world space position.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">float3 worldRefl</code>
</p>
</td><td style="" align="left" valign="top">
<p>Will contain world reflection vector if Surface Shader does not write to <code class="literal">o.Normal</code>. See Reflect-Diffuse shader for example.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">float3 worldNormal</code>
</p>
</td><td style="" align="left" valign="top">
<p>Will contain world normal vector if Surface Shader does not write to <code class="literal">o.Normal</code>.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">float3 worldRef; INTERNAL_DATA</code>
</p>
</td><td style="" align="left" valign="top">
<p>Will contain world reflection vector if Surface Shader writes to <code class="literal">o.Normal</code>. To get the reflection vector based on per-pixel normal map, use <code class="literal">WorldReflectionVector (IN, o.Normal)</code>. See Reflect-Bumped shader for example.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>
<code class="literal">float3 worldNormal; INTERNAL_DATA</code>
</p>
</td><td style="" align="left" valign="top">
<p>Will contain world normal vector if Surface Shader writes to <code class="literal">o.Normal</code>. To get the normal vector based on per-pixel normal map, use <code class="literal">WorldNormalVector (IN, o.Normal)</code>.</p>
</td></tr></tbody></table></div></div></div>