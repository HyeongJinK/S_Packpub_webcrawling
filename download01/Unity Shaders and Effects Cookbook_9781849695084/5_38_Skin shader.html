<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec40"></a>Skin shader</h2></div></div><hr /></div><p>Skin shaders <a id="id350" class="indexterm"></a>are always in high demand during the course of a game production, that is if your game production has characters with some sort of organic skin. This section is going to look at a skin shader approach that can be used in production. It isn't by any means the most accurate, but it does the trick and can produce some really nice effects.</p><p>Before we begin though, we need to understand what our skin surface has to do. This information will arm us with the knowledge we can use to break our Shader into its components, so that we can program in the different effects.</p><p>We can break the skin into four different components. This isn't the law of the land but you can get a very nice skin effect by concentrating on these four. They are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Sub-surface scattering</strong></span>: This is the <a id="id351" class="indexterm"></a>effect of the skin becoming very thin or very clear, such that the light behind it is creating a coloring effect. For skin this is usually a reddish hue to simulate the blood vessels being exposed. Here, we are going to learn how to calculate the curvature of a surface using its normal map.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Diffuse</strong></span>: As <a id="id352" class="indexterm"></a>you can imagine the effects of diffuse is not just a simple gray scale value when it comes to skin. We will still use the technique of dotting the light vector with the normal vector, but we need to utilize our BRDF technique to give more artistic control over how the light is affected while being distributed over the surface.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Specular</strong></span>: Specular <a id="id353" class="indexterm"></a>for skin is pretty tricky, as it is being controlled by how oily the surface is. We can still utilize the Specular tricks we have learned so far, but we want to add in our Fresnel and rim lighting techniques to control where the Specular is placed. This will distribute the Specular in a more realistic fashion. We could also use a lookup texture to control how the Specular is shaped, but we are going to implement a basic Specular for this recipe as we have covered how to do a Specular lookup in the previous chapter.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Blurred normals</strong></span>: The reason<a id="id354" class="indexterm"></a> a lot of skin shaders for games don't look that realistic or too plastic is because the normals of the normal map are reading at a very high-detail level and that is great when it comes to the Specular component, as we want to capture all that detail. But when we are talking about the diffuse component of the skin, we need a nice soft transition of colors.</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec108"></a>Getting ready</h3></div></div></div><p>So, now let's get our scene <a id="id355" class="indexterm"></a>prepared and gather some assets so <a id="id356" class="indexterm"></a>that we can have them ready as we implement the different components of our Shader.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene, Shader, and Material. Make sure to attach the Shader to the Material and assign the material to your object. It would be best if you can have a model of a head, but if not, that's okay, you can still use a sphere, as we have been using for the previous chapters.</p></li><li><p>We will also need a BRDF texture to calculate our diffuse colors. There is a BRDF texture that comes with this book, located on the book's support page at <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a>. Your BRDF texture will need to simulate the coloring of skin for the different tones of the skin. Here, we will be simulating a Caucasian skin so that our BRDF texture looks like the following:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_20.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec109"></a>How to do it…</h3></div></div></div><p>Now let's take<a id="id357" class="indexterm"></a> a look at how we construct our Shader. We<a id="id358" class="indexterm"></a> are going to step through each of the blocks of code, and then explain the key concepts in the next section.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To begin with, we need to fill our <code class="literal">Properties</code> block to get our different tweakable properties set up and give us a way to pass our textures to the Shader. We are now starting to get a lot of properties in our Shaders. This is the point in which you would want to speak with your artists and see if you can pack textures so that you don't need to have a bunch of sliders, but for our purposes this will suffice.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_22.jpg" /></div></li><li><p>We then need to declare a few <code class="literal">#pragma</code> statements, as this Shader requires quite a bit of processing and specific features of CGFX. So we need to enter in the following into our <code class="literal">SubShader</code> block, in order to remove any unwanted compiling errors. These will be explained in the next section:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_23.jpg" /></div></li><li><p>Our <a id="id359" class="indexterm"></a>Shader needs to have access to the <a id="id360" class="indexterm"></a>data being passed into our properties so that we can use the values that a user of this Shader will set. So we need to declare the corresponding property name in our <code class="literal">SubShader</code> block.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_24.jpg" /></div></li><li><p>In order for us to completely take advantage of the power of Surface Shaders, we will need to declare our own <code class="literal">SurfaceOutput</code> struct. This lets us pass data back and forth between our custom lighting function and our surface function. If we were to use just the built-in <code class="literal">SurfaceOutput</code> struct, we wouldn't be able to pass the blurred normals out to our lighting function, as well as the curvature value, which we are calculating on a per-pixel level.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_25.jpg" /></div></li><li><p>To <a id="id361" class="indexterm"></a>complete the base structure of our<a id="id362" class="indexterm"></a> Shader, we need to declare our <code class="literal">Input</code> struct and fill it with some useful built-in data. In this case, we will need the world position of each vertex of our model as well as the world normals and as we are using a normal map for this Shader, we have to declare the <code class="literal">INTERNAL_DATA</code> line so that we can get the normals after the normal map has been applied to the surface.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_26.jpg" /></div></li><li><p>With all the data set up, we can now begin to write our custom lighting function. We do this by first <a id="id363" class="indexterm"></a>declaring the lighting models function called <code class="literal">LightingSkinShader()</code>.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_27.jpg" /></div></li><li><p>We can now fill our lighting model with the appropriate calculations to produce our skin lighting. To start it, we will get all of our vectors in order and normalized so that we are dealing with unit vectors. Make sure this code goes inside the lighting model function.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_28.jpg" /></div></li><li><p>With the vectors <a id="id364" class="indexterm"></a>ready, we can produce the values for our BRDF texture lookup.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_29.jpg" /></div></li><li><p>Next up is our Fresnel and rim lighting components.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_30.jpg" /></div></li><li><p>Then, <a id="id365" class="indexterm"></a>we create our Specular component just as we had done it in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Making Your Game Shine with Specular</em></span>.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_31.jpg" /></div></li><li><p>With all our calculations done for our lighting model, we can now combine them up and pass the result over to the surface function.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_32.jpg" /></div></li><li><p>Finally, we get to our <code class="literal">surf()</code> function where we get all of our texture information, <a id="id366" class="indexterm"></a>calculate the blurred normals, and <a id="id367" class="indexterm"></a>produce the curvature value for our model based off of the normal map.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_33.jpg" /></div></li></ol></div><p>With all the components combined in our Surface Shader, our skin shader should look like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_21.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec110"></a>How it works…</h3></div></div></div><p>For most of the <a id="id368" class="indexterm"></a>Shader we have already seen how to <a id="id369" class="indexterm"></a>implement its components, but there are a few components that are new to us. To begin with, we have declared a new type of struct called <code class="literal">SurfaceOutputSkin</code>, while we have seen this before, we will cover it here once more here.</p><p>The <code class="literal">SurfaceOutputSkin</code> struct is our own custom struct that both the lighting function and the surf() function can use as a means of passing data from the surf() function to the lighting function. Think of it like a transport. When we assign values to the struct inside of the <code class="literal">surf()</code> function, they get stored in the variables inside that struct. We can then use that data inside the lighting function to perform more per-pixel lighting.</p><p>The next component that is new to us is the curvature calculation. We are basically measuring the amount of change between the normals of the surface. So as the curvature of the surface changes, so does the angle between the normals on that surface. We can use this data to find the areas of highest curvature and get a black and white value from the calculation.</p><p>This calculation introduces two new built-in CGFX functions that will return for us the necessary data to find this change in the surface curvature. The first is the <code class="literal">fwidth()</code> function. In our Shader, you will notice that we are sending in a vector as the argument to the<a id="id370" class="indexterm"></a> <code class="literal">fwidth()</code> function. This will return for us how quickly the vector is changing over the surface of the object. So, we end up with a vector that represents the curvature of the surface. Here is the link to the Cg standard library description: <a class="ulink" href="http://http.developer.nvidia.com/Cg/fwidth.html" target="_blank">http://http.developer.nvidia.com/Cg/fwidth.html</a>.</p><p>Using the <code class="literal">fwidth()</code> function from the Cg standard functions, we can get information about the curvature of the surface of our model.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_61.jpg" /></div><p>We then don't need the complete vector; we just want to find its magnitude on a per-pixel basis. So, we can use the <code class="literal">length()</code> function<a id="id371" class="indexterm"></a> as this will return for us the length of the vector as a float value. Here is the description of the length function from the Cg standard library: <a class="ulink" href="http://http.developer.nvidia.com/Cg/length.html" target="_blank">http://http.developer.nvidia.com/Cg/length.html</a>.</p><p>Using <a id="id372" class="indexterm"></a>the <code class="literal">length()</code> function, we can find out the <a id="id373" class="indexterm"></a>magnitude of the per-pixel curvature vector and get a float value that will drive how we look up our BRDF texture.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_62.jpg" /></div><p>With that data processed, we simply divide the two floats and multiply the result by another float value, passed to us from our<a id="id374" class="indexterm"></a> <code class="literal">CurveScale</code> property, to give control over how intense the curvature effect is.</p><p>The final result of our complete curvature calculation in our skin shader is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_63.jpg" /></div><p>Finally, <a id="id375" class="indexterm"></a>our last new function that we are utilizing to get a<a id="id376" class="indexterm"></a> nice soft diffuse lighting on our skin is the <a id="id377" class="indexterm"></a>
<code class="literal">tex2Dbias()</code> function. This allows us to offset or move the current mip level to a lower or higher mip level using a property to allow control over how blurry the texture is. It's not that we are blurring the texture pixel for pixel, we are actually just selecting a lower mip level from our texture. For more information on mip maps and generating them, see this link to the Unity reference: <a class="ulink" href="http://docs.unity3d.com/Documentation/Manual/Textures.html" target="_blank">http://docs.unity3d.com/Documentation/Manual/Textures.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec111"></a>There's more…</h3></div></div></div><p>This particular implementation of a skin shader was inspired by a couple of Shaders found on the web. So we thought it proper to mention them here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Unity</strong></span>
<a id="id378" class="indexterm"></a>
<span class="strong"><strong> forums</strong></span>: <a class="ulink" href="http://forum.unity3d.com/threads/131626-Gritty-realistic-skin-shader" target="_blank">http://forum.unity3d.com/threads/131626-Gritty-realistic-skin-shader</a>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Skin </strong></span>
<a id="id379" class="indexterm"></a>
<span class="strong"><strong>Shader 3</strong></span>: <a class="ulink" href="http://wiki.unity3d.com/index.php?title=Skin_Shader_3" target="_blank">http://wiki.unity3d.com/index.php?title=Skin_Shader_3</a>.</p></li></ul></div></div></div>