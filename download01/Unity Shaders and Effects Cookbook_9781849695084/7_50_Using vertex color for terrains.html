<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec50"></a>Using vertex color for terrains</h2></div></div><hr /></div><p>One of the most common<a id="id468" class="indexterm"></a> uses of vertex information is by creating<a id="id469" class="indexterm"></a> more realistic-looking terrains or environments. This is done by using each channel of the RGBA vertex color to blend into different textures. This is very efficient since you don't have to import yet another texture to blend into the other textures. You'll see this technique in just about every game that deals with outdoor terrains and structures.</p><p>This particular recipe will demonstrate a more advanced way of performing this blend by using a grayscale image or heightmap to add more detail to the vertex blending.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec134"></a>Getting ready</h3></div></div></div><p>Let's take a moment to get our scene together and gather a few textures we will need:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create <a id="id470" class="indexterm"></a>a new scene and import a mesh from a<a id="id471" class="indexterm"></a> 3D application that has vertex colors applied to it. We used Maya for this example.</p></li><li><p>Place your imported mesh into the new scene and create a single directional light.</p></li><li><p>Finally, create a new Shader and Material. Then, assign the Shader to the Material and the Material to the imported mesh.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec135"></a>How to do it…</h3></div></div></div><p>Once you have your new scene created, double-click on the Shader to open it up in MonoDevelop.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's create the properties we will need in order to give the users of this Shader more control over the final visual effect:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_17.jpg" /></div></li><li><p>We then need to tell Unity that we will be including a vertex function in our Surface Shader with the following code:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_18.jpg" /></div></li><li><p>Let's then create variables that will connect our <code class="literal">CGPROGRAM</code> statements to our <code class="literal">Properties</code> block:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_19.jpg" /></div></li><li><p>Since we are going to be using a few more textures and our vertex colors, we will need to fill out the <code class="literal">Input</code> struct with a few more parameters:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_20.jpg" /></div></li><li><p>We then <a id="id472" class="indexterm"></a>need to create our vertex function. This<a id="id473" class="indexterm"></a> is simple since all we have to do in this Shader is get the vertex color and pass it to the <code class="literal">Input</code> struct:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_21.jpg" /></div></li><li><p>Now we can turn our attention to the <code class="literal">surf()</code> function. Here, we will need to sample the texture first so that we have them ready for the blending part of this function:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_22.jpg" /></div></li><li><p>We then want to process our blending value based on the red channel of our vertex colors and the heightmap:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_23.jpg" /></div></li><li><p>Our next step is to calculate a falloff value for our vertex blend, so that we can add one more level of detail to our texture blending:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_24.jpg" /></div></li><li><p>Finally, we <a id="id474" class="indexterm"></a>need to lerp our two textures with <a id="id475" class="indexterm"></a>our final blending value and pass the color to our <code class="literal">SurfaceOutput</code> struct:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_25.jpg" /></div></li></ol></div><p>When your Shader has completed compiling, you should see a result similar to the result in the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_26.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec136"></a>How it works…</h3></div></div></div><p>This<a id="id476" class="indexterm"></a> Shader is definitely a bit more complex, but you'll notice that we don't <a id="id477" class="indexterm"></a>have to do much in the vertex function itself. We are simply passing the vertex colors off to the <code class="literal">surf()</code> function, so we can perform per-pixel operations with our vertex colors. The reason for this, as you might be able to notice, is that the vertex colors by themselves do offer us enough visual detail to create very convincing blending. By default, the vertex colors create a very blocky blending that can only be fixed by adding more vertices to the mesh and that isn't always a feasible thing.</p><p>So, we take in the vertex colors and multiply it with a grayscale image that is the height of the base texture we want to blend another texture type over. By running the vertex colors and the heightmap through the algorithm in step 7, we can add another level of visual detail to our blending that fakes the effect of one texture type blending into the base texture type. In our case, the snow texture is blending into the little crevasses in our base stone texture.</p><p>This technique has recently been made popular by games such as Uncharted and Gears of War, and is now available for you to use in your game projects!</p></div></div>