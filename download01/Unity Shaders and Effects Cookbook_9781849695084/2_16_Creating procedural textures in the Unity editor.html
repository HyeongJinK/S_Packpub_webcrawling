<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Creating procedural textures in the Unity editor</h2></div></div><hr /></div><p>There are times when you want to dynamically create textures and modify their pixels at runtime, to produce different effects. These are usually called<a id="id132" class="indexterm"></a> <span class="strong"><strong>procedural texture effects</strong></span>. Instead of having to manually create some new texture inside an image editing application, you can create a set of pixels in a two-dimensional nature and apply that to a new texture. Then, take that new texture and pass it to the Shader itself to use in its calculations.</p><p>This technique can <a id="id133" class="indexterm"></a>be very useful for painting onto an <a id="id134" class="indexterm"></a>already-existing texture map, using a dynamically created texture map, to create some interaction between the gamer and the game environment. It can also be used as a decal type effect, or for creating procedural shapes used in the functions of the Shader. There are many situations in which you might want to create a new texture and fill it with some procedural pattern, and use it in your Shaders.</p><p>The process of creating dynamic textures does rely on creating a separate script that processes the texture for you, but it is something that you should know how to do, in terms of having a good set of techniques for your shading pipeline. Let's see how to set up a script that will send its dynamically-created texture to a Surface Shader.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec46"></a>Getting ready</h3></div></div></div><p>You will need to prepare yourself for this recipe by carrying out the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new C# script in your Unity project, and name it <code class="literal">ProceduralTexture</code>.</p></li><li><p>Create an empty GameObject in your scene, zero-out its <span class="strong"><strong>Position</strong></span> values, and assign the <code class="literal">ProceduralTexture.cs</code> script to it.</p></li><li><p>Next, create a new Shader, a new Material, and a new object that will hold our Shader and Material. Make sure you name the Shader and Material, so that you can find them easily.</p></li><li><p>With all of that set up, we are ready to create the code that will generate a parabola type shape, apply it to the texture, and give that texture to the Shader. By the end of the recipe you will have created a texture that looks like the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_28.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec47"></a>How to do it…</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a variable to control the height and width of our texture, and a <code class="literal">Texture2D</code> variable to store our generated texture. We will also need some <a id="id135" class="indexterm"></a>private variables to store <a id="id136" class="indexterm"></a>some data while the script is working.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_33.jpg" /></div></li><li><p>In the <code class="literal">Start()</code> function<a id="id137" class="indexterm"></a> of the script, we need to first check to see if the object, to which this script is attached does in fact have a Material assigned to it. If it does, we will call our custom function <code class="literal">GenerateParabola()</code> <a id="id138" class="indexterm"></a>and pass its return value back to our <code class="literal">Texture2D</code> variable:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_34.jpg" /></div></li><li><p>We <a id="id139" class="indexterm"></a>then need to declare <a id="id140" class="indexterm"></a>our custom function that will produce the desired effect for us:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_35.jpg" /></div></li><li><p>Finally, we fill our custom function with the algorithm that produces the parabola shape in the texture. Don't worry if this doesn't make sense yet; we will cover each line of code in the next section of this recipe.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_36.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec48"></a>How it works…</h3></div></div></div><p>The <a id="id141" class="indexterm"></a>script starts out simply by checking to see if this particular object in the scene actually has a material on it that we can assign a texture to. If it does, we assign our <code class="literal">currentMaterial</code> variable the return <a id="id142" class="indexterm"></a>value of<code class="literal"> transform.renderer.sharedMaterial</code>, which returns a Material.</p><p>We then move to our next <code class="literal">if()</code> statement and check to see if we have a valid Material. If we do, we call the<a id="id143" class="indexterm"></a> <code class="literal">GenerateParabola()</code> function, which will return a <code class="literal">Texture2D</code> for us.</p><p>Once the program has moved to the <code class="literal">GenerateParabola()</code> function, it begins by creating a new texture, using the new <code class="literal">Texture2D()</code> constructor, and passing in our <code class="literal">widthHeight</code> variables. The result of this action creates an empty texture that allows us to add in pixel colors for each pixel in <code class="literal">widthHeight</code> squared.</p><p>With the new texture, we calculate the center pixel position and store it in the <code class="literal">centerPixelPosition</code> variable.</p><p>We then start two <code class="literal">for</code> loops that will simply loop through each pixel in the new empty texture that we created. If you aren't familiar with the C# <code class="literal">for</code> loop, see <a class="ulink" href="http://msdn.microsoft.com/en-us/library/ch45axte.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ch45axte.aspx</a>.</p><p>Then, for each pixel at <code class="literal">Vector2(x,y)</code> currently selected in the loops, we measure its distance from the center pixel, using the <code class="literal">Vector2.Distance()</code> function. This function will return a float value for us. For instance, if the current pixel position in the loop is equal to <code class="literal">Vector2(32,32)</code>, we would get a distance value of 316.78, if we created a 512 x 512 texture. That is, the pixel distance is (32,32) from the center.</p><p>We <a id="id144" class="indexterm"></a>will then need to re-map the pixel distance to be within a range of 0. 0 to 1.0, so it can be used as a color value (Unity uses values from 0.0 to 1.0 as color values). All we have to do in order to achieve this <a id="id145" class="indexterm"></a>remapping is to divide the distance value by half the texture's width or height. So, in this case, we divide our distance by 256, since it is half the value 512. So, if we have a distance of 316.78, as we saw in the previous example, we would get a value of 1.23.</p><p>Now, we need to make sure we don't get any values above 1.0 or below 0.0, so we use the <code class="literal">Mathf.Clamp()</code> function<a id="id146" class="indexterm"></a>, which allows us to clamp the value to limits that you pass in as arguments. We passed in 0 and 1 to make sure we get a normalized value.</p><p>Finally, we invert the color by subtracting the current value from 1, and then pass that final value into the channels of a new color variable. See the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_55.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec49"></a>There's more…</h3></div></div></div><p>Now that you have seen how to generate pixel values by using just a little bit of vector math, think of all the other types of data you can generate and store into a texture. The following code demonstrates other types of data you can generate, by looking at the dot product of a world vector and the pixel direction from the center of the image.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Here is the math to create rings around the center of the texture:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_38.jpg" /></div></li><li><p>The following is the math for creating the dot product of the pixel direction as compared with the right and up world vectors:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_39.jpg" /></div></li><li><p>The following is the math for creating the angle of the pixel direction as compared to world directions:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_40.jpg" /></div></li></ol></div><p>The different results of processing the pixels with different vector and angle calculations can be seen in the following image.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_37.jpg" /></div></div></div>