<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec58"></a>Building Shaders with #define directives</h2></div></div><hr /></div><p>We have seen how<a id="id525" class="indexterm"></a> we can use Unity's built-in CgInclude <a id="id526" class="indexterm"></a>files, and we have seen how to construct our very own simple CgInclude file to house all of our lighting models, variables, and helper functions. Now, let's turn our focus to a more dynamic and efficient way to use CgIncludes to make our Shader more modular and to have states we can switch on and off as needed.</p><p>To demonstrate this we will change our Half Lambert lighting model we created in the last recipe, to include a definition for Half Lambert. So if we do decide to define a Shader with Half Lambert, our lighting model will update to a Half Lambert diffuse and not a standard <a id="id527" class="indexterm"></a>
<span class="strong"><strong>NdotL lighting model</strong></span>.</p><p>Let's see how this works in the following sections, using the assets we have already created. We will just modify their contents with just a little bit of code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec153"></a>How to do it…</h3></div></div></div><p>We begin this section by turning our focus over to our CgInclude file. We want to somehow tell the lighting model to have two states.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Our first state will be a normal NdotL diffuse lighting model and our second state will be a Half Lambert lighting model. Modify your CgInclude file to include the following code:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_09_15.jpg" /></div></li><li><p>Then <a id="id528" class="indexterm"></a>in our Shader, we need to <a id="id529" class="indexterm"></a>update the directives in our <code class="literal">CGPROGRAM</code> block:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_09_16.jpg" /></div></li><li><p>Save your CgInclude file and your Shader and return to Unity to let them compile. If all went well, you shouldn't see a difference. This is because we are telling Unity to define a directive called <code class="literal">HalfLambert</code>, and if it finds one in any of the included files it will use that snippet of code.</p></li><li><p>Return to your Shader and just comment out the new definition we made. Then save and return to Unity to let it compile.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_09_17.jpg" /></div></li></ol></div><p>If all went well, you should see that our Shader is now using a standard NdotL lighting model. This is because we aren't defining the <code class="literal">HalfLambert</code> directive anymore, so Unity will skip that snippet of code when compiled. This makes our Shader writing more flexible and more efficient, since we don't have to constantly re-write or delete out large sections of code. The<a id="id530" class="indexterm"></a> following screenshot shows the results of this new modularity in our Shader<a id="id531" class="indexterm"></a> writing:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_09_18.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec154"></a>How it works…</h3></div></div></div><p>As you can see, the amount of code needed at this point is really minimal. We can create many variations of our lighting models using these simple techniques. By using the <code class="literal">#ifdef</code> directive, we are telling Unity to look for the name of the definition following the <code class="literal">#ifdef</code> statement; in this case we used <code class="literal">HalfLambert</code>.</p><p>When we declare the <code class="literal">#define</code> directive in our Shader, it tells Unity that it needs to look for this definition in any of the included files. If it finds this particular definition then it will include that snippet of code until it finds a <code class="literal">#endif</code> directive. You can imagine how important the naming of these definitions becomes as you need to make sure you aren't using a definition already included.</p><p>The power of using <a id="id532" class="indexterm"></a>CgInclude files makes it more efficient to write Shaders, not only because we save on the amount of code we have to write in our actual Surface Shaders, but it becomes a way to store the vast amounts of lighting models. This makes it easier to recall a<a id="id533" class="indexterm"></a> lighting model or to modify it further with multiple states. Imagine trying to remember all of the lighting models from this book, or documenting them in a notepad for use later on. Using CgInclude files will make you a more productive Shader writer as well as more organized.</p></div></div>