<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec35"></a>Creating a simple dynamic Cubemap system</h2></div></div><hr /></div><p>We have learned a lot<a id="id295" class="indexterm"></a> of great information so far, but<a id="id296" class="indexterm"></a> our reflections don't really reflect the proper world as an object moves around the environment. For example, if you have an environment composed of multiple rooms and hallways, we couldn't bake out a Cubemap for the whole level and put it in a single Cubemap. That wouldn't reflect the proper environment from room to room. We would get a very static, uninteresting reflection.</p><p>There are a couple ways in which this can be solved such that the reflection of one room is different than that of the second room. The first and most basic way is to swap the Cubemap based off of positions in the rooms. So as you move from room to room, the Cubemap would swap out for the correct Cubemap for that room. The second way is to update the Cubemap in real time as the character moves about the environment, ultimately getting a new Cubemap every frame the game progresses. While the second option sounds more visually appealing, since you would see a pop between Cubemaps, it is rather expensive and so needs to be weighed against all the other resources your game will need.</p><p>This recipe is going to cover the first option and show you how you can set up a very simple system to swap between two Cubemaps based off of set positions in the environment. There is more information on creating a real-time reflection system in the last section of this recipe, so if you are interested and want to see the differences between these two techniques, then there you go!</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec91"></a>Getting ready</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We need <a id="id297" class="indexterm"></a>to create a new scene and place a ground plane and a sphere in the world. Plus, add a directional <a id="id298" class="indexterm"></a>light to get some lighting for our Shader.</p></li><li><p>Continue by adding two empty <code class="literal">GameObject</code> constructors to the scene and name them <code class="literal">pos001</code> and <code class="literal">pos002</code> respectively.</p></li><li><p>Let's then assign a new material to our sphere and attach the Fresnel Shader, which we just created in the last recipe, to our new Material. Your scene should now look like the next screenshot.</p></li><li><p>Finally, let's create a script and name it <code class="literal">SwapCubemaps.cs</code>.</p></li></ol></div><p>The following screenshot shows the result of our prepared scene that is ready for our dynamic reflection system:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_39.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec92"></a>How to do it…</h3></div></div></div><p>Once your scene is ready to go, we can begin to code up our reflection system by following the next few steps.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's begin by adding <code class="literal">[ExecuteInEditMode]</code> just before we declare our class.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_40.jpg" /></div></li><li><p>Then, we<a id="id299" class="indexterm"></a> need to declare a <a id="id300" class="indexterm"></a>few variables to store all the data in our system. We will explain these in the next section of this recipe.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_41.jpg" /></div></li><li><p>In order for us to visually see where our Cubemap positions are in space, we need to take advantage of the awesome <span class="strong"><strong>gizmos</strong></span> features<a id="id301" class="indexterm"></a> that Unity3D provides for us. So let's add the following code to the bottom of our script:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_42.jpg" /></div></li><li><p>Now, we need to create a new function that will determine which Cubemap we should <a id="id302" class="indexterm"></a>be using based off of the distance between each of the positions we have set <a id="id303" class="indexterm"></a>up:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_43.jpg" /></div></li><li><p>Finally, we just need to check every frame to see what the distance is between each of the positions in our environment and swap out the appropriate Cubemap in our Material:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_44.jpg" /></div></li></ol></div><p>Once you save the Shader, return to the Unity editor and let the Shader compile. When done, hit <span class="strong"><strong>Play</strong></span> and move the sphere back and forth. You should see a result similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_38.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec93"></a>How it works…</h3></div></div></div><p>We <a id="id304" class="indexterm"></a>simply start out this script by declaring the <code class="literal">[ExecuteInEditMode]</code> property for our class. This will tell Unity that we want to<a id="id305" class="indexterm"></a> run our Cubemap swapping script while it is in the editor, not just when we hit <span class="strong"><strong>Play</strong></span>. This will allow us to test out our Cubemap swapping without having to hit <span class="strong"><strong>Play</strong></span>—much faster workflow.</p><p>The script then has a few variables that we use to allow someone to input two Cubemaps and two positions, which we use to compare distances. Lastly, we have two private variables with which we keep track of the current material and the Cubemap while the program is running.</p><p>With our variables in place, we can then use the <code class="literal">OnDrawGizmos()</code> built-in function to actually display the positions of our transforms we let the users input. These positions will command the script as to when to swap out our Cubemaps.</p><p>We then get to the real meat of this program. We declare our own function/method that will calculate the distance our sphere is away from either of the two transforms we have, using <code class="literal">Vector3.Distance()</code>. It then checks to see which distance is smaller and returns a Cubemap for that position.</p><p>Finally, in the <code class="literal">Update()</code> function we get the current material from our sphere, or the object that this script is attached to, and simply assign the currently-selected Cubemap returned from our custom function.</p><p>This is just a <a id="id306" class="indexterm"></a>very simple script to illustrate the concept, but it could be expanded into a complete system, where you have multiple Cubemaps per room. The system can autogenerate all the Cubemaps for us at runtime, which would really be useful for games that can't afford a <a id="id307" class="indexterm"></a>full-real-time reflection system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec94"></a>There's more…</h3></div></div></div><p>You can also take a shot at creating a real-time reflection system, where a Cubemap is updated for every frame the game progresses. This is definitely a more visually appealing system, but does come at a cost to performance:</p><p>
<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Camera.RenderToCubemap.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Camera.RenderToCubemap.html</a>
</p></div></div>