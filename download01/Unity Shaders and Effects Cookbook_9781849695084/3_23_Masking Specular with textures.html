<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec27"></a>Masking Specular with textures</h2></div></div><hr /></div><p>Now that we have<a id="id184" class="indexterm"></a> taken a look at how to create a Specular effect for our <a id="id185" class="indexterm"></a>Shaders, let's start to take a look into the ways in which we can start to modify our Specular and give more artistic control over its final visual quality. In this next recipe, we will look at how we can use textures to drive our Specular and Specular power attributes.</p><p>The technique of using Specular textures is seen in most modern game development pipelines because it allows the 3D artists to control the final visual effect on a per-pixel basis. This provides us with a way in which we can have a mat-type surface and a shiny surface all in one Shader; or, we can drive the width of the Specular or the Specular power with another texture, to have one surface with a broad Specular highlight and another surface with a very sharp, tiny highlight.</p><p>There are many effects one can achieve by mixing his/her Shader calculations with textures, and giving artists the ability to control their Shader's final visual effect is key to an efficient pipeline. Let's see how we can use textures to drive our Specular lighting models. This recipe will introduce you to some new concepts, such as creating your own <code class="literal">Input</code> struct, and learning how the data is being passed around from the <code class="literal">output</code> struct, to the lighting function, to the <code class="literal">Input</code> struct, and to the <code class="literal">surf()</code> function. Understanding the flow of data between these core Surface Shader elements is core to a successful Shader pipeline.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec64"></a>Getting ready</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>We will need a new Shader, Material, and another object to apply our Shader and Material on to.</p></li><li style="list-style-type: disc"><p>With the Shader and Material connected and assigned to your object in your scene, double-click the Shader to bring it up in MonoDevelop.</p></li><li style="list-style-type: disc"><p>We will also need a Specular texture to use. Any texture will do as long as it has some nice variation in colors and patterns. The following screenshot shows the<a id="id186" class="indexterm"></a> textures we are using for <a id="id187" class="indexterm"></a>this recipe:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_25.jpg" /></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec65"></a>How to do it…</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, let's populate our <code class="literal">Properties</code> block with some new properties. Add the following code to your Shader's <code class="literal">Properties</code> block:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_18.jpg" /></div></li><li><p>We then need to add the corresponding variables to the subshader, so that we can access the data from the properties in our <code class="literal">Properties</code> block. Add the following code, just after the <code class="literal">#pragma</code> statement:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_19.jpg" /></div></li><li><p>Now we<a id="id188" class="indexterm"></a> have to add our own custom <code class="literal">Output</code> struct. This will allow us to store more data for use between <a id="id189" class="indexterm"></a>our surf function and our lighting model. Don't worry if this doesn't make sense just yet. We will cover the finer details of this <code class="literal">Output</code> struct in the next section of the recipe. Place the following code just after the variables in the <code class="literal">SubShader</code> block:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_20.jpg" /></div></li><li><p>Just after the <code class="literal">Output</code> struct we just entered, we need to add our custom lighting model. In this case, we have a custom lighting model called <code class="literal">LightingCustomPhong</code>. Enter the following code just after the <code class="literal">Output</code> struct we just created:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_21.jpg" /></div></li><li><p>In order for <a id="id190" class="indexterm"></a>our custom lighting model to work, we have to tell the <code class="literal">SubShader</code> block which lighting model <a id="id191" class="indexterm"></a>we want to use. Enter the following code to the <code class="literal">#pragma</code> statement so that it loads our custom lighting model:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_22.jpg" /></div></li><li><p>Since we are going to be using a texture to modify the values of our base Specular calculation, we need to store another set of UVs for that texture specifically. This is done inside the <code class="literal">Input</code> struct by placing the word <code class="literal">uv</code> in front of the variable's name that is holding the texture. Enter the following code just after your custom lighting model:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_23.jpg" /></div></li><li><p>To finish off the Shader, we just need to modify our <code class="literal">surf()</code> function with the following code. This will let us pass the texture information to our lighting model function, so that we can use the pixel values of the texture to modify our Specular values in the lighting model function:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_24.jpg" /></div></li></ol></div><p>The following<a id="id192" class="indexterm"></a> screenshot shows the result of masking our Specular calculations with a color texture and its channel information. We <a id="id193" class="indexterm"></a>now have a nice variation in Specular over the entire surface, instead of just a global value for the Specular:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_17.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec66"></a>How it works…</h3></div></div></div><p>This Shader is basically the same as Phong calculations, except that we are now going to modify our Specular with a per-pixel texture, giving our Specular much more visual interest and depth.</p><p>To do this, we need to be able to pass information from our surface function to our lighting functions. The reason is that we can't get the UVs of a surface within the lighting function. You can procedurally generate UVs in the lighting function but if you want to unpack a texture and get its pixel information, you have to use the <code class="literal">Input</code> struct, and the only way to access the data from the <code class="literal">Input</code> struct is to use the <code class="literal">surf()</code> function.</p><p>So to set up this data relationship, we have to create our own <code class="literal">SurfaceCustomOutput</code> struct. This struct is the container for all the final data in a Surface Shader and luckily for us, the lighting function <a id="id194" class="indexterm"></a>and the <code class="literal">surf()</code> function can both access the data from it. So if we create our own, we can add more data to it. The following code is our <code class="literal">SurfaceCustomOutput</code> struct in our Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_20.jpg" /></div><p>So, we add this to our Shader and we need to tell the <code class="literal">surf()</code> function and the lighting function that<a id="id195" class="indexterm"></a> they should use this struct instead of the built-in one. This is done by the following code:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_45.jpg" /></div><p>Notice how the <code class="literal">surf()</code> function and the lighting function now have the struct <code class="literal">SurfaceCustomOutput</code> for one of their arguments. We have also added a new entry into our <code class="literal">SurfaceOutput</code> struct called <code class="literal">SpecularColor</code>. This will allow us to store the per-pixel information from our Specular color texture and use it in our lighting function, instead of just multiplying a single global color over our whole Specular value.</p><p>We simply use the <code class="literal">tex2D()</code> function to get our texture information, and then pass that into our <code class="literal">SurfaceCustomOutput</code> struct by assigning <code class="literal">o.SpecularColor</code> the return value of the <code class="literal">tex2D()</code> function. Once that<a id="id196" class="indexterm"></a> is done, you can now access the texture information in the lighting function.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_24.jpg" /></div><p>This technique<a id="id197" class="indexterm"></a> is crucial for creating custom effects in your Shaders. Now you know how to access textures from the <code class="literal">surf()</code> function and use it in your lighting function. This allows you to create very high-quality, per-pixel effects in your Shader.</p></div></div>