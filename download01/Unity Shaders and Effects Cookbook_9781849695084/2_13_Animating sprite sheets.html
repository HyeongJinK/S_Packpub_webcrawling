<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>Animating sprite sheets</h2></div></div><hr /></div><p>Learning how to animate<a id="id83" class="indexterm"></a> a sprite sheet will always come in handy. It can be used for particle effects, or for flip-book effects, and is most commonly seen in 2D side scroller games.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"></a>Note</h3><p>A sprite sheet, also referred to as a <span class="strong"><strong>sprite atlas</strong></span>
<a id="id84" class="indexterm"></a>, if you aren't familiar with the term, is a big texture that has many smaller images embedded into it, and is sometimes referred to as an image sequence.</p></div><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_50.jpg" /></div><p>When you scroll over each of these smaller images in the sheet, you will get the effect of the content being animated. The concept is the same as making a flip book out of a sticky notepad or the frames on the film reel of a movie. If we cycle through each of the frames in our sprite sheet, we will create an animated effect.</p><p>This recipe will use a bit more math for the code, but no worries; we step through each new line of code and explain it thoroughly.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec33"></a>Getting ready</h3></div></div></div><p>In order for us to be able to test our Shader code we will need some art content. We will have to either make a sprite sheet ourselves or find one on the Internet. The sprite sheet doesn't have to be complicated, it just needs a sequence of images to flip through. There is also this sprite sheet included in the book's support page located at <a class="ulink" href="http://www.packtpub.com/support" target="_blank">www.packtpub.com/support</a>.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_14.jpg" /></div><p>Create a new <a id="id85" class="indexterm"></a>Material and a new Shader. Then set up your Material by placing it onto a plane in the Scene view. Then place the sprite sheet into the texture swatch of the Material.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec34"></a>How to do it…</h3></div></div></div><p>Let's get our sprite animation Shader working by entering the code in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create three new properties in the <code class="literal">Properties</code> block of the Shader. These will help us modify the system from the Materials <span class="strong"><strong>Inspector</strong></span> without having to hardcode values:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_08.jpg" /></div></li><li><p>Then store the input UVs into separate variables so that we can work with the values:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_09.jpg" /></div></li><li><p>Next we<a id="id86" class="indexterm"></a> need to get the width of each cell. In the sprite sheet, this takes up a value in the range 0 to 1, so we need to produce a percentage value:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_10.jpg" /></div></li><li><p>Next, we have to get the time component of our system that will give us the ability to move, or offset the UVs, from cell to cell:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_11.jpg" /></div></li><li><p>Finally, we create the offset UVs that we can feed into the <code class="literal">x</code> direction of our sprite sheet. You should now have a Shader that creates a flip book for you.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_12.jpg" /></div></li></ol></div><p>The following is the result of offsetting the UVs of an object inside a Surface Shader. Again, you will have to take our word for it that the image is animated:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_13.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec35"></a>How it works…</h3></div></div></div><p>The <a id="id87" class="indexterm"></a>calculation starts by storing the UVs being passed from the <code class="literal">Input</code> struct into a separate variable. You don't necessarily have to do this, as it is more of a preference choice rather than a hard rule—it's just a way of reading code. In this case we called our new variable <code class="literal">spriteUV</code>, and declared it as a type <code class="literal">float2</code>. This is because we need to store the <code class="literal">x</code> and <code class="literal">y</code> values of our meshe's UVs in one variable.</p><p>The next step takes the width of our current texture and divides it up into smaller bits using the <code class="literal">_CellAmount</code> property declared in the property block. So if we have a texture that is 512 in width, and we divided it into 16 cells, we would get a value of 32. This represents the number of pixels that each cell has for its width, but we also need to know what percentage each cell takes up. This is because UV values are always calculated in a range of 0 to 1 or 0 percent to 100 percent. So we take the <code class="literal">cellPixelWidth</code> variable and divide it by the width of the texture itself. If we dive the cell width of 32 pixels by the texture width of 512 pixels, we end up with a value of 0.06, or 6 percent of the total width of the texture. This represents the value by which we need to offset the UVs in order to move to the next cell of the sprite sheet.</p><p>Next, we need to calculate some values that increase with time but are whole numbers. For instance, a value that increases as 0, 1, 2, 3, 4, and so on, until it reaches the total number of cells we have in our sprite sheet. To do this we can use the <span class="strong"><strong>CGFX</strong></span>
<a id="id88" class="indexterm"></a> built-in function<a id="id89" class="indexterm"></a> called <code class="literal">fmod()</code>.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /></colgroup><thead><tr><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Function</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="" align="left" valign="top">
<p>
<code class="literal">fmod(x, y)</code>
<a id="id90" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>This returns the remainder of <code class="literal">x</code> / <code class="literal">y</code>, with the same sign as <code class="literal">x</code>.</p>
<p>If <code class="literal">y</code> is 0, the result is defined by the implementation.</p>
</td></tr></tbody></table></div><p>If we feed a value of <code class="literal">x</code> into the<a id="id91" class="indexterm"></a> <code class="literal">fmod()</code> function and divide it by the value of <code class="literal">y</code>, we get the remainder of that operation returned to us. So, if we use the <code class="literal">_Time</code> value for <code class="literal">x</code> and use the <code class="literal">_CellAmount</code> property value for <code class="literal">y</code>, we will get a return value that increases with time, and it will repeat once it is equal to the <code class="literal">_CellAmount</code> value.</p><p>With that type of <a id="id92" class="indexterm"></a>value generated, we then use the <code class="literal">ceil()</code> function<a id="id93" class="indexterm"></a> to make sure that the value is a whole number, instead of some decimal. This basically works by taking a number such as 1.5 and forcing it to be 2. This creates the number pattern 0, 1, 2, 3, 4,… all the way to the <code class="literal">_CellAmount</code> property value. Once it reaches that cell amount value, it starts over at 0.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /></colgroup><thead><tr><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Function</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="" align="left" valign="top">
<p>
<code class="literal">ceil(x)</code>
<a id="id94" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>Where the smallest integer is not less than <code class="literal">x</code>.</p>
</td></tr></tbody></table></div><p>Finally, we get the current <code class="literal">x</code> value from the input UV and add the product of the cell percentage and the current time value multiplied by the total cell amount. This will move our UVs from cell to cell, but we have to also scale our UV value so that only one cell is visible at any one particular time. To accomplish this, we simply multiply the result of the offset UV by the cell percentage, and we have our final UV value. All that needs to be done is to pass that new UV value into the UV value of the <code class="literal">tex2D</code> function for the texture.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec36"></a>There's more…</h3></div></div></div><p>You might have see it already, but you don't have to use only one of the offset directions. Just like we gave two directions to the offset in the previous scrolling UVs recipe, we can have a 2D animated sprite sheet. You simply need to add the <code class="literal">y</code> offset to the final offset value.</p><p>This is the same as the horizontal scrolling we set up, but now you can cycle through a larger sheet of images in multiple dimensions. While this shows just the number of things you can do on the Shader side of development, it might end up adding too many Shader instructions to your Shader. This means that it will eat up your application's performance.</p><p>To combat this, you can move the frame offset selection code to a C# script that talks to the Shader, and have the CPU drive that portion of the code. It really comes down to balancing your application when it's time to optimize, but it never hurts to think of elements that you may encounter in the future, and design your production around that. This book includes a C# script that demonstrates how a simple sprite animation system can be created using a script to pass data to a Shader. It basically does the time calculations for us, and passes only the time value to the Shader using the following code:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_51.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec37"></a>See also</h3></div></div></div><p>If you aren't up for creating a whole system for animating sprites yourself, there are many resources on the Asset Store that takes care of most, if not all, sprite animation needs. Here is a list of a few of those resources:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>SpriteManager</strong></span>
<a id="id95" class="indexterm"></a> <a id="id96" class="indexterm"></a>(Free):</p><p>
<a class="ulink" href="http://wiki.unity3d.com/index.php?title=SpriteManager" target="_blank">http://wiki.unity3d.com/index.php?title=SpriteManager</a>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>2D </strong></span>
<a id="id97" class="indexterm"></a>
<span class="strong"><strong>ToolKit</strong></span> <a id="id98" class="indexterm"></a>(Asset Store / $65.00):</p><p>
<a class="ulink" href="http://www.unikronsoftware.com/2dtoolkit/" target="_blank">http://www.unikronsoftware.com/2dtoolkit/</a>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Sprite </strong></span>
<a id="id99" class="indexterm"></a>
<span class="strong"><strong>Manager 2</strong></span> <a id="id100" class="indexterm"></a>(Asset Store / $150.00):</p><p>
<a class="ulink" href="http://anbsoft.com/middleware/sm2/" target="_blank">http://anbsoft.com/middleware/sm2/</a>
</p></li></ul></div><p>If you are looking for a good application to help you make sprites, here is a list of a few of them:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>TimelineFX</strong></span>
<a id="id101" class="indexterm"></a> ($46.79):</p><p>
<a class="ulink" href="http://www.rigzsoft.co.uk/" target="_blank">http://www.rigzsoft.co.uk/</a>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Anime Studio </strong></span>
<a id="id102" class="indexterm"></a>
<span class="strong"><strong>Pro</strong></span> ($199.99):</p><p>
<a class="ulink" href="http://anime.smithmicro.com/index.html" target="_blank">http://anime.smithmicro.com/index.html</a>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Adobe Flash</strong></span>
<a id="id103" class="indexterm"></a>
<span class="strong"><strong> Professional</strong></span> ($699.00):</p><p>
<a class="ulink" href="http://www.adobe.com/products/flash.html" target="_blank">http://www.adobe.com/products/flash.html</a>
</p></li></ul></div></div></div>