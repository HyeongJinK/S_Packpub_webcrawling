<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec29"></a>Creating an Anisotropic Specular type</h2></div></div><hr /></div><p>
<span class="strong"><strong>Anisotropic</strong></span> is a type of <a id="id213" class="indexterm"></a>Specular or reflection that simulates the <a id="id214" class="indexterm"></a>directionality of grooves in a surface, and modifies/stretches the Specular in the perpendicular direction. It is very useful when you want to simulate brushed metals, not a metal with a clear, smooth, polished surface. Imagine the Specular you see when you look at the data side of a CD or DVD, or the way Specular is shaped at the bottom of a pot or pan. You will notice that if you carefully examine the surface, you will see that there is a direction to the grooves in the surface, usually the way the metal was brushed. When you apply a Specular to that surface, you get a Specular stretched in the perpendicular direction.</p><p>This recipe will introduce you to the concept of augmenting your Specular highlights to achieve different types of brushed surfaces. In future recipes, we will look at ways in which we can use the concepts of this recipe to achieve other effects, such as stretched reflections and hair, but here we are going to learn the fundamentals of the technique first. We will be using this Shader as our reference for our own custom Anisotropic Shader:</p><p>
<a class="ulink" href="http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader" target="_blank">http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader</a>
</p><p>The following <a id="id215" class="indexterm"></a>screenshot shows examples of different types of Specular effects one can achieve by using Anisotropic Shaders in Unity:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_27.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec71"></a>Getting ready</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene with some objects and lights, so that we can visually debug our Shader.</p></li><li><p>Then, create a new Shader and Material, and hook them up to our objects.</p></li><li><p>Lastly, we will need some sort of normal map that will indicate the directionality of our Anisotropic Specular highlight.</p></li></ol></div><p>The following screenshot shows the Anisotropic normal map we will be using for this recipe. It is available from the book's support page at <a class="ulink" href="http://www.packtpub.com/support" target="_blank">www.packtpub.com/support</a>:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_29.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec72"></a>How to do it…</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We first<a id="id216" class="indexterm"></a> need to add the <a id="id217" class="indexterm"></a>properties we are going to need for our Shader. These will allow a lot of artistic control over the final appearance of the surface:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_30.jpg" /></div></li><li><p>We then need to make the connection between our <code class="literal">Properties</code> block and our <code class="literal">SubShader</code> block, so that we can use the data being provided by the <code class="literal">Properties</code> block:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_31.jpg" /></div></li><li><p>Now<a id="id218" class="indexterm"></a> we can create our lighting <a id="id219" class="indexterm"></a>function that will produce the correct Anisotropic effect on our surface:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_36.jpg" /></div></li><li><p>In order to use this new lighting function, we need to tell the subshader's <code class="literal">#pragma</code> statement to look for it instead of using one of the built-in lighting functions. We are also telling the Shader to target Shader model 3.0, so that we can have more space for textures in our program:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_37.jpg" /></div></li><li><p>We have also given the Anisotropic normal map its own UVs by declaring the following code in the <code class="literal">Input</code> struct. This isn't entirely necessary as we could just use the UVs from the main texture, but this gives us independent control over the tiling of our brushed metal effect, so that we can scale it to any size <a id="id220" class="indexterm"></a>we want.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_39.jpg" /></div></li><li><p>Finally, we <a id="id221" class="indexterm"></a>need to use the <code class="literal">surf()</code> function to pass the correct data to our lighting function. So we get the per-pixel information from our Anisotropic normal map and set our Specular parameters.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_40.jpg" /></div></li></ol></div><p>The following screenshot demonstrates the result of our Anisotropic Shader. The Anisotropic normal map allows us to give the surface direction and helps us disperse the Specular highlight around the surface:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_28.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec73"></a>How it works…</h3></div></div></div><p>Let's <a id="id222" class="indexterm"></a>break this <a id="id223" class="indexterm"></a>Shader down into its core components and explain why we are getting the effect we are getting. We will mostly be covering the custom lighting function here, as the rest of the Shader should be pretty self-explanatory at this point.</p><p>We first start by declaring our own <code class="literal">SurfaceCustomOutput</code> struct. We need to do this in order to get the per-pixel information from the Anisotropic normal map, and the only way we can do that in a Surface Shader, is to use a <code class="literal">tex2D()</code> function inside the <code class="literal">surf()</code> function.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_32.jpg" /></div><p>We can use the <code class="literal">SurfaceOutput</code> struct as a way of interacting between the lighting function and the surface function. In our case, we are storing the per-pixel texture information in the variable called <code class="literal">anisoTex</code> in our <code class="literal">surf()</code> function, and then passing that data to the <code class="literal">SurfaceAnisoOutput</code> struct by storing it in the <code class="literal">AnisoDirection</code> variable. Once we have that, we can use that per-pixel information in the lighting function, by using <code class="literal">s.AnisoDirection</code>.</p><p>With that data <a id="id224" class="indexterm"></a>connection set up, we can move on to our actual lighting calculations. This begins by getting the usual out of the way, the half vector, so that we don't have to do the full reflection calculation and the diffuse <a id="id225" class="indexterm"></a>lighting, which is the vertex normal dotted with the light vector or direction.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_33.jpg" /></div><p>Then we start the actual modification to the Specular to get the right look. We first dot the normalized sum of the vertex normal and the per-pixel vectors from our Anisotropic normal map with the <code class="literal">halfVector</code> calculated in the previous step. This gives us a float value that gives a value of <code class="literal">1</code> as the surface normal, modified by the Anisotropic normal map, as it becomes parallel with the <code class="literal">halfVector</code> and <code class="literal">0</code> as it is perpendicular. Finally, we modify this value with a <code class="literal">sin()</code> function so that we can basically get a darker middle highlight and ultimately a ring effect based off of the <code class="literal">halfVector</code>.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_34.jpg" /></div><p>Finally, we scale the effect of the <code class="literal">aniso</code> value by taking it to a power of <code class="literal">s.Gloss</code>, and then globally decrease its strength by multiplying it by <code class="literal">s.Specular</code>.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_35.jpg" /></div><p>This effect is <a id="id226" class="indexterm"></a>great for creating more advanced metal type surfaces, especially ones that are brushed and seem to have directionality to <a id="id227" class="indexterm"></a>them. It also works well for hair or any sort of soft surface with directionality to it. The following screenshot shows the result of just displaying the final Anisotropic lighting calculation:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_03_38.jpg" /></div></div></div>