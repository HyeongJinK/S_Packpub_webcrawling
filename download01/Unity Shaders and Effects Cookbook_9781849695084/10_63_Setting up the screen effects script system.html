<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec60"></a>Setting up the screen effects script system</h2></div></div><hr /></div><p>The process of creating<a id="id536" class="indexterm"></a> screen effects is one in which we grab a full screen image (or texture) use a Shader to process its pixels on the GPU, then send it back to Unity's renderer to apply it to the whole rendered image of the game. This allows us to perform per-pixel operations to the rendered image of the game in real time, giving us a more global artistic control.</p><p>Imagine if you had to go through and adjust each material on each object in your game to just adjust the contrast of the final look of your game. While not impossible, this would take a bit of labor to perform. By utilizing a screen effect, we can adjust the screen's final look as a whole, thereby giving us a more Photoshop-like control over our game's final appearance.</p><p>In order to get a screen effect system up and running we have to set up a single script to act as the courier of the game's current rendered image or what Unity calls the <a id="id537" class="indexterm"></a>
<span class="strong"><strong>render texture</strong></span>. By utilizing this script to pass the render texture to a Shader, we can create a flexible system to create screen effects. For our first screen effect, we are going to create a very simple grayscale effect, where we can make our game look black and white. Let's take a look at how this is done.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec155"></a>Getting ready</h3></div></div></div><p>In order to get our <a id="id538" class="indexterm"></a>screen effects system up and running, we need to begin by creating a few assets for our current Unity project. By doing this we will set ourselves up for the steps in the following sections:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the current project, we need to create a new C# script and call it <code class="literal">TestRenderImage.cs</code>.</p></li><li><p>Create a new Shader and call it <code class="literal">ImageEffect.shader</code>.</p></li><li><p>Create a simple sphere in the scene and assign it a new Material. This new Material can be anything, but for our example we decided to make a simple red, Specular Material.</p></li><li><p>Finally, create a new directional light and save the scene.</p></li></ol></div><p>With all of our assets ready, you should have a simple scene setup, which looks similar to the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_01.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec156"></a>How to do it…</h3></div></div></div><p>In order to make our <a id="id539" class="indexterm"></a>grayscale screen effect to work we need a script and a Shader. So, we will complete these two new items here and fill them with the appropriate code to produce our first screen effect. Our first task is to complete the C# script. This will get the whole system running. After that we will complete the Shader and see the results of our screen effect. Let's complete our script and Shader using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the <code class="literal">TestRenderImage.cs</code> C# script and let's begin by entering in a few variables that we will need to store important objects and data. Enter the following code into the very top of the <code class="literal">TestRenderImage</code> class:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_02.jpg" /></div></li><li><p>In order for us to edit the screen effect in real time, when the Unity editor isn't playing, we need to enter the following line of code just above the declaration of the<a id="id540" class="indexterm"></a> <code class="literal">TestRenderImage</code> class:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_03.jpg" /></div></li><li><p>Since our screen effect is using a Shader to perform the pixel operations on our screen image, we have to create a material to run the Shader. Without it, we can't access the properties of the Shader. For this we will create a C# property to check for a material, then create one if it doesn't find one. Enter the following <a id="id541" class="indexterm"></a>code just after the declaration of the variables from step 1:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_04.jpg" /></div></li><li><p>We now want to set up some checks in our script, to see if the current target platform that we are building the Unity game to actually supports image effects. If it doesn't find anything at the start of this script, the script will disable itself:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_05.jpg" /></div></li><li><p>To actually grab <a id="id542" class="indexterm"></a>the rendered image from the Unity renderer, we need to make use of the following built-in function that Unity provides us, <a id="id543" class="indexterm"></a>called <code class="literal">OnRenderImage()</code>. Enter the following code so we can have access to the current render texture:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_06.jpg" /></div></li><li><p>Our screen effect has a variable called <code class="literal">grayScaleAmount</code>, which we can use to control how much grayscale we want for our final screen effect. So, in this case, we need to make the value go from 0 – 1, where 0 is no grayscale effect and 1 is full grayscale effect. We will perform this operation in the<a id="id544" class="indexterm"></a> <code class="literal">Update()</code> function, so that it sets every frame this script is running on:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_07.jpg" /></div></li><li><p>Finally, we complete our script by doing a little bit of cleanup on objects we created when the script started:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_08.jpg" /></div></li></ol></div><p>At this point we can now apply this script to the camera if it compiled without errors in Unity. So, let's apply the <code class="literal">TestRenderImage.cs</code> script to our main camera in our scene. You should see the <code class="literal">grayScaleAmount</code> value and a field for a Shader, but the script throws an error to the <a id="id545" class="indexterm"></a>console window. It says that it is missing an instance to an object and so won't process appropriately. If you remember from step 4, we are doing some checks to see if we have a Shader and if the current platform supports the Shader. Since we haven't given the screen effect script a Shader to work with, then the <code class="literal">curShader</code> variable is just null, which throws the error. </p><p>Let's continue our screen effects system by completing the Shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To begin our Shader, we will populate our properties with some variables, so we can send data to this Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_09.jpg" /></div></li><li><p>Our Shader is now going to utilize pure Cg Shader code, instead of utilizing Unity's built-in Surface Shader code. This will make our screen effect more optimized as we only need to work with the pixels of the render texture. So, we will create a new pass block in our Shader and fill it with some new <code class="literal">#pragma</code> statements that we haven't seen before:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_10.jpg" /></div></li><li><p>In order to access the data being sent to the Shader from the Unity editor, we need to create the <a id="id546" class="indexterm"></a>corresponding variables in our <code class="literal">CGPROGRAM</code> statement:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_11.jpg" /></div></li><li><p>Finally, all we need to do is set up our pixel function, in this case called<a id="id547" class="indexterm"></a> <code class="literal">frag()</code>. This is where the meat of the screen effect is. This function will process each pixel of the render texture, and return a new image back to our <code class="literal">TestRenderImage.cs</code> script:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_12.jpg" /></div></li></ol></div><p>Once the Shader is complete, return to Unity and let it compile to see if any errors occurred. If not, assign the new Shader to the <code class="literal">TestRenderImage.cs</code> script, and change the value of the grayscale amount variable. You should see the game view go from a colored version of the game to a grayscale version of the game. The following image demonstrates this screen effect:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_13.jpg" /></div><p>With that complete, we now have an easy way to test out new screen effect shaders, without having to write our whole screen effect system over and over again. Let's dive a little deeper and learn about what's going on with the render texture and how it is processed throughout its existence.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec157"></a>How it works…</h3></div></div></div><p>To get a screen <a id="id548" class="indexterm"></a>effect up and running inside of Unity, we need to create a script and a Shader. The script drives the real-time update in the editor, but is also responsible for capturing the render texture from the main camera, and passing it to the Shader. Once the render texture gets to the Shader, we can use the Shader to perform per-pixel operations.</p><p>At the start of the script we perform a few checks to make sure the current selected build platform actually supports screen effects and the Shader itself. There are instances where a current platform will not support screen effects or the Shader that we are using. So the checks we do in the <code class="literal">Start()</code> function<a id="id549" class="indexterm"></a> make sure we don't get any errors, if the platform doesn't support the screen system.</p><p>Once the script passes those checks, we initiate the screen effects system by calling the built-in function<a id="id550" class="indexterm"></a> <code class="literal">OnRenderImage()</code>. This function is responsible for grabbing the render texture, giving it to the Shader using the <code class="literal">Graphics.Blit()</code> function, and <a id="id551" class="indexterm"></a>returning the processed image back to the Unity renderer. You can find out more information on these two functions at the following URLs:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>OnRenderImage</strong></span>
<a id="id552" class="indexterm"></a> (<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html</a>)</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Graphics.Blit</strong></span>
<a id="id553" class="indexterm"></a> (<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html</a>)</p></li></ul></div><p>Once the current render texture reaches the Shader, the Shader takes it, processes it through the <code class="literal">frag()</code> function, and returns the final color for each pixel.</p><p>You can see how powerful this becomes as it gives us Photoshop-like control over the final rendered image of our game. These screen effects work sequentially, like Photoshop layers in the camera. When <a id="id554" class="indexterm"></a>you place these screen effects one after the other, they will be processed in that order. These are just the bare bones steps to get a screen effect working, but it is the core of how the screen effects system works.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec158"></a>There's more…</h3></div></div></div><p>Now that we have our simple screen effect system up and running, let's take a look at some of the other useful<a id="id555" class="indexterm"></a> information we can obtain from Unity's renderer:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_43.jpg" /></div><p>We can actually get the depth of everything in our current game by turning on Unity's built-in depth mode. Once this is turned on, we can use the depth information for a lot of different effects. Let's take a look at how this is done:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new Shader and call it <code class="literal">SceneDepth_Effect</code>. Then double-click on this Shader to open it up in the MonoDevelop editor.</p></li><li><p>We will create the main texture property and a property to control the power of the scene depth effect. Enter the following code into your Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_44.jpg" /></div></li><li><p>Now we need to create the corresponding variables in our <code class="literal">CGPROGRAM</code> statement. We are going to add one more variable called <code class="literal">_CameraDepthTexture</code>. This is a built-in variable that Unity has provided us through the use of the <code class="literal">UnityCG</code> CgInclude file. It gives us the depth information<a id="id556" class="indexterm"></a> from the camera:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_45.jpg" /></div></li><li><p>We complete our depth shader by utilizing a couple more built-in functions that Unity provides us, the <code class="literal">UNITY_SAMPLE_DEPTH()</code> function and the<a id="id557" class="indexterm"></a> <code class="literal">linear01Depth()</code> function. The first function actually gets the depth information from our <code class="literal">_CameraDepthTexture</code> and produces a single <code class="literal">float</code> value for each pixel. The <code class="literal">Linear01Depth()</code> function<a id="id558" class="indexterm"></a> then makes sure that the values are within the 0 to 1 range. By taking this final depth value to a power, we can control where the mid-value on the 0 to 1 range sits in the scene based on the camera position:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_46.jpg" /></div></li><li><p>With our <a id="id559" class="indexterm"></a>Shader complete, let's turn our attention over to our screen effects script. We need to add the <code class="literal">depthPower</code> variable to the script so we can let users change the value in the editor:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_47.jpg" /></div></li><li><p>Our <code class="literal">OnRenderImage()</code> function<a id="id560" class="indexterm"></a> then needs to be updated so that it passes the right value to our Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_48.jpg" /></div></li><li><p>To complete our depth screen effect, we need to tell Unity to turn on the depth rendering inside the current camera. This is simply done by setting the main camera's <code class="literal">depthTextureMode</code> variable:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_49.jpg" /></div></li></ol></div><p>With all the code set up, save your script and Shader and return to Unity to let them both compile. If no errors were <a id="id561" class="indexterm"></a>encountered, you should see a similar result to the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_10_50.jpg" /></div></div></div>