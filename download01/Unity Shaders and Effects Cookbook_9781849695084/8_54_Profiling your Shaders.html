<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec53"></a>Profiling your Shaders</h2></div></div><hr /></div><p>Now that we know <a id="id489" class="indexterm"></a>how we can reduce the overhead that our Shaders might take up, let's take a look at how to find problematic Shaders in a scene where you might have a lot of Shaders, or a lot of objects, Shaders, and scripts, all running at the same time. To find a single object or a single Shader among a whole game can be quite daunting, but Unity provides us with its built-in Profiler. This allows us to actually see on a frame-by-frame basis what is happening in the game, and lets us see each item being used by the GPU and the CPU.</p><p>Using the Profiler we can isolate only items such as Shaders, geometry, and general rendering items by using their interface to create blocks of profiling jobs. We can filter out items till we are looking at the performance of just a single object. This then lets us see the effects on the CPU and GPU that the object has while it is performing its functions at runtime.</p><p>Let's take a look at the different sections of the Profiler and learn how to debug our scenes and most importantly our Shaders.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec140"></a>Getting ready</h3></div></div></div><p>Let's begin using our Profiler by getting a few assets ready and launching the <span class="strong"><strong>Profiler</strong></span> window:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's use the scene from the last recipe and launch the Unity Profiler from <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Profiler</strong></span> or by using <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>7</em></span>.</p></li><li><p>Let's also duplicate our sphere a couple more times to see how that affects our rendering.</p></li></ol></div><p>You should see something similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_02.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec141"></a>How to do it…</h3></div></div></div><p>To begin using the <a id="id490" class="indexterm"></a>Profiler, we will first take a look at some of the UI elements of this window. Before we hit play, let's take a look at how to get the information we need from the Profiler.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, click on the larger blocks in the <span class="strong"><strong>Profiler</strong></span> window called <span class="strong"><strong>GPU Usage</strong></span>, <span class="strong"><strong>CPU Usage</strong></span>, and <span class="strong"><strong>Rendering</strong></span>. You will find these blocks in the left-hand side of the upper window as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_16.jpg" /></div><p>Using these <a id="id491" class="indexterm"></a>blocks we can see different data specific to those major functions of our game. The <span class="strong"><strong>CPU Usage</strong></span> block shows us what most of our scripts are doing as well as the physics, and overall rendering. The <span class="strong"><strong>GPU Usage</strong></span> block gives us detailed information about the elements that are specific to our lighting, shadows, and render queues. Finally, the <span class="strong"><strong>Rendering</strong></span> block gives us information about the draw calls and amount of geometry we have in our scene at any one frame.</p><p>By clicking on each of these blocks, we can isolate out the type of data we see during our profiling session.</p></li><li><p>Now click on the tiny colored blocks inside one of these profile blocks and hit play or <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>P</em></span> to run the scene.</p><p>This lets us dive down even deeper into our profiling session, so that we can filter out what is being reported back for us. While the scene is running, uncheck all of the boxes except for <span class="strong"><strong>Opaque</strong></span> in the <span class="strong"><strong>GPU Usage</strong></span> block. Notice how we can now just see how much time is being used to render just the objects that are set to the render queue of <span class="strong"><strong>Opaque</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_17.jpg" /></div></li><li><p>Another great <a id="id492" class="indexterm"></a>function of the <span class="strong"><strong>Profiler</strong></span> window is the action of clicking-and-dragging in the graph view. This will automatically pause your game so that you can further analyze a certain spike in the graph, to find out exactly which items are causing the performance problem. Click-and-drag around in the graph view to pause the game and see the effect of using this functionality:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_18.jpg" /></div></li><li><p>Turning our attention now toward the lower half of the <span class="strong"><strong>Profiler</strong></span> window, you will notice that there is a drop-down item available, when we have the <span class="strong"><strong>GPU Usage</strong></span> block selected. We can expand this to get even more detailed information about the current active profiling session and in this case, more information about what the camera is currently rendering and how much time it is taking up:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_19.jpg" /></div><p>This gives us a<a id="id493" class="indexterm"></a> complete look into the inner workings of what Unity is processing at this particular frame. In this case we can see that our three spheres with our optimized Shader are taking roughly 0.14 milliseconds to draw to screen, they are taking up seven draw calls, and this process is taking 3.1 percent of the GPU's time every frame. It's this type of information we can use to diagnose and solve performance issues with regard to Shaders. Let's conduct a test to see the effects of adding one more texture to our Shader and blending two diffuse textures together<a id="id494" class="indexterm"></a> using a <code class="literal">lerp</code> function. You will see in the <span class="strong"><strong>Profiler</strong></span> window the effects pretty clearly.</p></li><li><p>Modify the <code class="literal">Properties</code> block of your Shader with the following code to give us another texture to use:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_20.jpg" /></div></li><li><p>Then let's feed our texture to our <code class="literal">CGPROGRAM</code> statement:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_21.jpg" /></div></li><li><p>Now it's time to update our <code class="literal">surf()</code> function accordingly so we blend our texture diffuse textures together:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_22.jpg" /></div></li></ol></div><p>Once you save your <a id="id495" class="indexterm"></a>modifications in your Shader and return to Unity's editor, we can run our game and see the increase in milliseconds of our new Shader. Press play once you have returned to Unity and let's take a look at the results in our <span class="strong"><strong>Profiler</strong></span> window:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_23.jpg" /></div><p>You can see now that the amount of time to render our <span class="strong"><strong>Opaque</strong></span> Shaders in this scene is taking 0.179 milliseconds, up from 0.140 milliseconds. By adding another texture and using the <code class="literal">lerp()</code> function, we increased the render time for our spheres. While it's a small change, imagine having 20 Shaders all working in different ways on different objects.</p><p>Using the <a id="id496" class="indexterm"></a>information given here you can more quickly pin point areas that are causing performance decreases, and solve those issues by using the techniques from the previous recipe.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec142"></a>How it works…</h3></div></div></div><p>While it's completely out of scope of this book to describe how this tool actually works internally, we can surmise that Unity has given us a way to view the computer's performance while our game is running. Basically this window is tied very tightly to the CPU and the GPU to give us real-time feedback of how much time is being taken for each of our scripts, our objects, and our render queues. Using this information we have seen that we can track the efficiency of our Shader writing to eliminate problematic areas and code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec143"></a>There's more…</h3></div></div></div><p>It is also possible to profile specifically for mobile platforms. Unity provides us with a couple of extra features when the Android or iOS build target is set in <span class="strong"><strong>Build Settings</strong></span>. We can actually get real-time information from our mobile devices while the game is running. This becomes very useful because you are able to profile directly on the device itself, instead of profiling directly in your editor. To find out more about this process, see Unity's documentation at the following link:</p><p>
<a class="ulink" href="http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html" target="_blank">http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html</a>
</p></div></div>