<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec37"></a>The Lit Sphere lighting model</h2></div></div><hr /></div><p>The <a id="id308" class="indexterm"></a>Lit Sphere lighting model is a really interesting <a id="id309" class="indexterm"></a>use of Image based lighting. We can actually use a 2D texture to completely bake in our lighting. It's the same effect as what you see in<a id="id310" class="indexterm"></a> Zbrush. If you are familiar with Zbrush's<a id="id311" class="indexterm"></a> MatCaps, the Lit Sphere works in the same way. We can create a texture that literally bakes in the way that the diffuse, the Specular, the reflection, and the rim lighting look, and use it to light our Shader. The only catch with this Shader is that since we have baked the lighting completely in, the lighting never changes, unless you swap to different textures throughout your environment, like we saw in the <span class="emphasis"><em>Simple Cubemap reflection in Unity3D</em></span> recipe in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Reflecting Your World</em></span>. So this Shader will not react to the lights in your environment, nor will it change as you move your view around your model. An example of a Lit Sphere texture lookup, usually referred to as a Sphere Map, is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_02.jpg" /></div><p>This means that this <a id="id312" class="indexterm"></a>Shader is good for creating nice diorama scenes or even to use in your game's cinematics where a camera is locked off and you need really complex lighting for your characters and environment.</p><p>So, let's take a look at how this type of lighting model is created and can be used inside Unity using Surface Shaders.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec95"></a>Getting ready</h3></div></div></div><p>To begin this<a id="id313" class="indexterm"></a> Shader, we need to learn how to create the textures that will become our lighting in our Shader. To do this we can use Photoshop, but it is much easier to use a little free tool, called MaCrea, found on the web at: <a class="ulink" href="http://www.taron.de/macrea" target="_blank">http://www.taron.de/macrea</a>; this is a great program offered for free to help you create these Lit Sphere maps. I would recommend watching the videos on Vimeo to get you acquainted with the MaCrea interface and workflows.</p><p>An introduction to MaCrea<a id="id314" class="indexterm"></a> is available at <a class="ulink" href="http://vimeo.com/14030320" target="_blank">http://vimeo.com/14030320</a>.</p><p>Once you have become familiar with the process of creating these Sphere maps, we can move on to the rest of this recipe. The following screenshot shows shows the MaCrea interface and a completed Lit Sphere created with the program:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_01.jpg" /></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene with a couple of objects, a plane, and a light.</p></li><li><p>Create a new Shader and Material. Then assign your Shader to your Material.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec96"></a>How to do it…</h3></div></div></div><p>With our scene assets<a id="id315" class="indexterm"></a> created and our Shader ready to go in<a id="id316" class="indexterm"></a> MonoDevelop, we can start to create our Lit Sphere shading model.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>As always, we need to set up our properties for our Surface Shader so that we can let the user of this Shader input different textures and change values. So, let's add the following code to our <code class="literal">Properties</code> block:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_04.jpg" /></div></li><li><p>Since this Shader is solely using the sphere map to light our model, we will not need the<a id="id317" class="indexterm"></a> <code class="literal">Lambert</code> lighting function, but we will need to declare our own <code class="literal">Unlit</code> lighting function<a id="id318" class="indexterm"></a>. We will also need to write a little bit of a vertex function in order for this Shader to work:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_05.jpg" /></div></li><li><p>Then as always, we need to make sure to declare our properties inside our <code class="literal">SubShader</code> block in order for us to utilize the user-given data from the <span class="strong"><strong>Inspector</strong></span> in the Unity editor.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_06.jpg" /></div></li><li><p>At this point, <a id="id319" class="indexterm"></a>we can create our <a id="id320" class="indexterm"></a>new <code class="literal">Lighting</code> function that will produce for us an Unlit lighting model. We have to do this, as in this case we do not want the lights to affect our Shader. We just want to cast the shadow from the object. So, we need to add the following <code class="literal">Lighting</code> function to our Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_07.jpg" /></div></li><li><p>We now need to populate our <code class="literal">Input</code> struct with some extra properties so that we can pass the information from our <code class="literal">vertex()</code> function<a id="id321" class="indexterm"></a> to our<a id="id322" class="indexterm"></a> <code class="literal">surf()</code> function:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_08.jpg" /></div></li><li><p>In order for us to look up the Sphere map correctly, we will need to multiply the tangent rotation matrix with the inverse transpose model view of the current model. This will give us the proper vectors with which we can apply the Sphere map texture. Don't worry if you don't understand what is happening here <a id="id323" class="indexterm"></a>in the vertex <a id="id324" class="indexterm"></a>shader, we will explain it more in the next section.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_09.jpg" /></div></li><li><p>Finally, we can fill out our <code class="literal">surf()</code> function with the appropriate calculations to produce the proper lookup values for our Sphere map texture and feed these into our <code class="literal">SurfaceOutput</code> struct. Again, the guts of this function will be explained in the next section:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_11.jpg" /></div></li></ol></div><p>The following <a id="id325" class="indexterm"></a>screenshot is the result of our <a id="id326" class="indexterm"></a>Shader using a sphere map, or as Zbrush calls them, MatCaps:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_03.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec97"></a>How it works…</h3></div></div></div><p>The real magic of this lighting model is actually happening inside the <code class="literal">vert()</code> function, when we assign <code class="literal">o.tan1</code> and <code class="literal">o.tan2</code> a new vector by multiplying the rotated tangent vector with the inverse transpose model view matrix. This calculation is actually bending the vectors such that they look up the sphere map in the correct way. So where does the inverse transpose model view matrix come from? It is yet another built-in value that Unity provides us, so we don't have to do the calculations for ourselves.</p><p>Unity has actually provided us with the most common transformation matrices that are usually seen in standard CGFX shaders. This is one of the benefits of using Surface Shaders, we don't have to write these position transformations ourselves. We simply call the built-in parameter.</p><p>But why do we need to use this particular transformation of the vertices? Understanding how these matrices work is definitely beyond the scope of this book, as this isn't meant to be a book about the heavy math of why objects render to screen in a real-time engine, but the simple explanation is that we need to take the vertices in object space and convert them to world space, so we can then map the sphere map on to our surface accordingly. Try to think of it as changing your spatial relationship to the model.</p><p>The vectors being <a id="id327" class="indexterm"></a>produced by the multiplication of the inverse transpose mode view and the rotated tangent normal are <a id="id328" class="indexterm"></a>shown in the following screenshot. We use these vectors to look up values in our Sphere map texture:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_05_59.jpg" /></div><p>Finally, we complete our Shader by simply using the values <code class="literal">IN.tan1</code> and <code class="literal">IN.tan2</code> as the UV values for our sphere map texture lookup. We can use these values from the <code class="literal">Input</code> structure because we populated them with data from the<a id="id329" class="indexterm"></a> <code class="literal">vert()</code> function.</p><p>This is a simple yet visually appealing way to achieve complex lighting situations. The only downside to using this technique is that the lighting doesn't update according to real lights. The lighting is always locked to the facing view direction of the camera, almost as if the texture is being projected on to the object in view.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec98"></a>See also</h3></div></div></div><p>As always, the Internet is a great resource to find out more information on many topics. We have included a few links that will give you more information and training on sphere maps and the Lit Sphere shading model.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>There is a great explanation in the <a id="id330" class="indexterm"></a>Cg tutorial online book here: <a class="ulink" href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter04.html" target="_blank">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter04.html</a>.</p></li><li style="list-style-type: disc"><p>You can find more information on all the built-in transformation matrices here: <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/SL-BuiltinStateInPrograms.html" target="_blank">http://docs.unity3d.com/Documentation/Components/SL-BuiltinStateInPrograms.html</a>.</p></li><li style="list-style-type: disc"><p>Information on reflections in <a id="id331" class="indexterm"></a>MaCrea can be found at: <a class="ulink" href="http://vimeo.com/14189456" target="_blank">http://vimeo.com/14189456</a>.</p></li><li style="list-style-type: disc"><p>Information on cell shading<a id="id332" class="indexterm"></a> in MaCrea can be found at: <a class="ulink" href="http://vimeo.com/14033777" target="_blank">http://vimeo.com/14033777</a>.</p></li></ul></div></div></div>