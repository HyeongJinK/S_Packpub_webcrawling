<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec55"></a>Introduction</h2></div></div><hr /></div><p>As we have taken our journey through the process of writing Shaders, we have seen how to achieve many varieties of techniques and effects, but we still write very similar code over and over again. When in a production environment, time is precious and creating Shaders quickly and efficiently in an iterative manner is crucial to meeting the demands of a game production. This is where CgInclude files come into play. They allow us to create a framework of code that can be re-used over and over again, making our Shader writing environment modular.</p><p>Actually, we have already been using a couple of built-in CgInclude files to write our Surface Shaders. Anytime we use the built-in Lambert or BlinnPhong lighting models, we are using code snippets and functions from CgInclude files that Unity has already created for us. This reduces the amount of coding we have to do at our end and keeps a nice level of consistency in your lighting and effects over all your Shaders.</p><p>By understanding and writing your own CgInclude files for your Shader development environment, the process of creating Shaders will become fast and easy to modify whenever needed. So let's continue our Shader writing journey by taking a look at what Unity has already provided us in terms of lighting models, functions, and built-in state variables.</p></div>