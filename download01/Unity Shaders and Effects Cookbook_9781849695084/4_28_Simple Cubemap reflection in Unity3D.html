<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec31"></a>Simple Cubemap reflection in Unity3D</h2></div></div><hr /></div><p>Now that we <a id="id254" class="indexterm"></a>know how to create our own custom Cubemaps, we can<a id="id255" class="indexterm"></a> now look at how we use this new texture type to simulate reflections in our Shaders. The concept of using Cubemaps for reflections is pretty simple actually, but provides a very powerful tool for your Shader effects. It works by using the normal from each vertex on the surface of the model to look up a position on the Cubemap textures. This lookup will return a color value that simulates the effect of the Cubemap being reflected on the surface of your object. That is the basic idea.</p><p>This particular recipe will take the first step into using Cubemaps for reflections. Unity actually provides us with ways to get the reflection vector automatically, so we don't have to calculate it ourselves. This is done inside the <code class="literal">Input</code> struct by using the built-in <span class="strong"><strong>worldRefl</strong></span> vector. This will help us in the lookup operation for our <span class="strong"><strong>Cubemap</strong></span> texture. So, this first step will give us the most bare-bones way of creating a reflection effect for your Surface Shaders.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec78"></a>Getting ready</h3></div></div></div><p>Before we <a id="id256" class="indexterm"></a>begin our Shader code, we need to set up a<a id="id257" class="indexterm"></a> simple scene by creating a few assets.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene, Material, and Shader. Make sure to give your new assets a name that easily identifies them.</p></li><li><p>Attach the new Shader to your new Material, and then assign your Material to your object.</p></li><li><p>Finally, create or gather a Cubemap that you can use for the Shader.</p></li></ol></div><p>The following screenshot shows the Cubemap we are using for this recipe. Yours could be different, but we just wanted to show what we are using to remove any confusion.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_07.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec79"></a>How to do it…</h3></div></div></div><p>Let's begin to code our Shader by following the next few steps.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First let's create some new properties in the <code class="literal">Properties</code> block. We will need a place to get our Cubemap texture and to control the amount of reflection:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_03.jpg" /></div></li><li><p>We <a id="id258" class="indexterm"></a>then need to make sure we create the <a id="id259" class="indexterm"></a>connection to the properties inside our <code class="literal">SubShader</code> block. This will allow us to access the data from our <code class="literal">Properties</code> block.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_04.jpg" /></div></li><li><p>In order for us to simulate the correct reflection angle to the surface, we will need to get some sort of vector data that will provide us with the proper world reflection directions. To do this, we can use another built-in feature of Unity's Surface Shaders. Inside the <code class="literal">Input</code> struct, the following code will give us a world reflection vector we can use in our Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_05.jpg" /></div></li><li><p>Finally, we just need to get the texture information from our Cubemap, using the <code class="literal">texCUBE()</code> function<a id="id260" class="indexterm"></a> and our new world reflection vector, given to us by the <code class="literal">Input</code> struct. Add the following code to <a id="id261" class="indexterm"></a>your <code class="literal">surf()</code> function:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_06.jpg" /></div></li></ol></div><p>A <a id="id262" class="indexterm"></a>result of creating our own custom Cubemap is<a id="id263" class="indexterm"></a> shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_01.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec80"></a>How it works…</h3></div></div></div><p>If all went well, you should see your Cubemap being reflected onto your object such that it samples the Cubemap just as a real reflective object would. This is all made possible because Unity3D has a built-in property for its Surface Shader's <code class="literal">Input</code> struct. The <code class="literal">worldRefl</code> property gives us the reflection vector we need to correctly sample our Cubemap. Just by simply using the <code class="literal">worldRefl</code> property inside our<a id="id264" class="indexterm"></a> <code class="literal">texCube()</code> function, we can easily sample the correct reflection view for our Cubemap.</p><p>The following<a id="id265" class="indexterm"></a> screenshot shows an example of what the reflection data, being passed to the <a id="id266" class="indexterm"></a>Shader, looks like when viewed with a debug script:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_04_08.jpg" /></div></div></div>