<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec54"></a>Modifying your Shaders for mobile</h2></div></div><hr /></div><p>Now that we have <a id="id497" class="indexterm"></a>seen quite a broad set of techniques for making<a id="id498" class="indexterm"></a> really optimized Shaders, let's take a look at writing a nice, high quality Shader targeted for a mobile device. It is actually quite easy to make a few adjustments to the Shaders we have written so that they run faster on a mobile device. This includes elements such as using the<a id="id499" class="indexterm"></a> <code class="literal">approxview</code> or <code class="literal">halfasview</code> lighting function variables. We can also reduce the amount of textures we need and even apply better compression for the textures we are using. By the end of this section, we will have a nicely optimized, normal-mapped Specular Shader for use in our mobile games.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec144"></a>Getting ready</h3></div></div></div><p>Before we begin, let's get a fresh new scene made up and fill it up with some objects to apply our mobile Shader to:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene and fill it with a default sphere and a single directional light.</p></li><li><p>Create a new Material and a Shader, and assign the Shader to the Material.</p></li><li><p>Finally assign the material to our sphere object in our scene.</p></li></ol></div><p>When completed you should have a scene similar to the one in the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_01.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec145"></a>How to do it…</h3></div></div></div><p>For this recipe we will <a id="id500" class="indexterm"></a>write a mobile-friendly Shader from scratch and discuss the elements that make it more mobile-friendly:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's first populate <a id="id501" class="indexterm"></a>our <code class="literal">Properties</code> block with the needed textures. In this case we are going to use a single diffuse texture with the gloss map in its alpha channel, plus a normal map and a slider for Specular intensity:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_24.jpg" /></div></li><li><p>Our next task is to set up our <code class="literal">#pragma</code> declarations. This will simply turn certain features of the Surface Shader on and off, ultimately making the Shader cheaper or more expensive:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_25.jpg" /></div></li><li><p>We then need to make the connection between our <code class="literal">Properties</code> block and our <code class="literal">CGPROGRAM</code> statements. Though, this time we are going to use the fixed variable type for our Specular-intensity slider to reduce its memory usage:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_26.jpg" /></div></li><li><p>In order for us to map our textures to the surface of our object, we need to get some UVs. In this case we are only going to get one set of UVs to keep the amount of data in our Shader down to a minimum:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_27.jpg" /></div></li><li><p>The next<a id="id502" class="indexterm"></a> step is to fill in our lighting function using<a id="id503" class="indexterm"></a> a few new input variables that are available to us by using the new <code class="literal">#pragma</code> declarations:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_28.jpg" /></div></li><li><p>Finally, we complete the Shader by creating the <code class="literal">surf()</code> function and processing the final color of our surface:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_29.jpg" /></div></li></ol></div><p>When completed with the code portion of this recipe, save your Shader and return to the Unity editor to let the Shader compile. If no errors occurred, you should see a result similar to the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_30.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec146"></a>How it works…</h3></div></div></div><p>So, let's begin<a id="id504" class="indexterm"></a> the description of this Shader by explaining what <a id="id505" class="indexterm"></a>it does and doesn't do. First, it excludes the deferred lighting pass. This means if you created a lighting function that was connected to the deferred renderer's prepass, it wouldn't use that particular lighting function and it would look for the default lighting function such as the ones we have been creating thus far in this book.</p><p>This particular Shader does not support light mapping by Unity's internal light mapping system. This just keeps the Shader from trying to find light maps for the object the Shader is attached to, making the Shader more performance-friendly, because it is not having to perform the light mapping check.</p><p>We included the <code class="literal">noforwardadd</code> declaration, so that we only process per-pixel textures with a single directional light. All other lights are forced to become per-vertex lights and will not be included in any per-pixel operations you might do in the <code class="literal">surf()</code> function.</p><p>Finally, we are using the <code class="literal">halfasview</code> declaration to tell Unity that we aren't going to use the main <code class="literal">viewDir</code> parameter found in a normal lighting function. We instead are going to use the half vector as the view direction and process our Specular with that. This becomes much faster for the Shader to process since it will be done on a per-vertex basis. It isn't completely accurate when it comes to simulating Specular in the real world, but visually on a mobile device it looks just fine and the Shader is more optimized.</p><p>Techniques such as these make a Shader more efficient and cleaner code-wise. Always make sure you are using only the data you need while weighing that against your target hardware and the visual quality the game requires. In the end, it becomes a cocktail of these techniques <a id="id506" class="indexterm"></a>that ultimately make up your Shaders for <a id="id507" class="indexterm"></a>your games.</p></div></div>