<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec52"></a>What is a cheap Shader?</h2></div></div><hr /></div><p>When first asked what a cheap Shader is<a id="id478" class="indexterm"></a>, it might be a little tough to answer, since there are many elements that go into the making of a more efficient Shader. It could be the amount of memory used up by your variables. It could be the amount of textures the Shader is using. It could also be that our Shader is working fine, but we can actually produce the same visual effect with half the amount of data, by reducing the amount of code we are using or the data we are creating. We are going to explore a few of these techniques in this recipe and show how they can be combined to make your Shader fast and efficient but still produce the high quality visuals everyone expects from games <a id="id479" class="indexterm"></a>today, whether mobile or PC.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec137"></a>Getting ready</h3></div></div></div><p>In order to get this recipe started, we need to gather a few resources together. So, let's perform the following tasks:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene and fill it with a simple sphere object and a single directional light.</p></li><li><p>Create a new Shader and Material and assign the Shader to the Material.</p></li><li><p>We then need to assign the Material we just created to our sphere object, in our new scene.</p></li><li><p>Finally, modify the Shader so that it uses a diffuse texture, a normal map, and includes your own custom lighting function:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_31.jpg" /></div></li></ol></div><p>This shows the result of<a id="id480" class="indexterm"></a> modifying our default Shader we created in step 1.</p><p>You should now have a setup similar to the following image. This setup will allow us to take a look at some of the basic concepts that go into optimizing Shaders using Surface Shaders in Unity:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_01.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec138"></a>How to do it…</h3></div></div></div><p>We are going to build a <a id="id481" class="indexterm"></a>simple diffuse Shader to take a look at a few ways in which you can optimize your Shaders in general.</p><p>First we'll optimize our variable types, so that they use less memory when they are processing data:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's begin with the <code class="literal">Input</code> struct in our Shader. Currently, our UVs are being stored in a variable of type <code class="literal">float2</code>. We need to change that to use <code class="literal">half2</code> instead:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_07.jpg" /></div></li><li><p>We can then move to our lighting function and reduce the variable's memory footprint by changing their types to the following:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_08.jpg" /></div></li><li><p>Finally, we can complete this optimization pass by updating the variables in our<a id="id482" class="indexterm"></a> <code class="literal">surf()</code> function:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_09.jpg" /></div></li><li><p>Now that we have <a id="id483" class="indexterm"></a>our variables optimized, we are going to take advantage of a built-in lighting function variable, so we can control how lights are processed by this Shader. By doing this, we can greatly reduce the amount of lights the Shader processes. Modify the <code class="literal">#pragma</code> statement in your Shader with the following code:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_10.jpg" /></div></li><li><p>We can optimize this further by sharing UVs between the normal map and the diffuse texture. To do this, we simply change the UV lookup in our <code class="literal">UnpackNormal()</code> function<a id="id484" class="indexterm"></a> to use the <code class="literal">_MainTex</code> UVs instead of the UVs of <code class="literal">_NormalMap</code>:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_11.jpg" /></div></li><li><p>Since we have removed the need for the normal map UVs, we need to make sure we remove the normal map UV code from the <code class="literal">Input</code> struct:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_12.jpg" /></div></li><li><p>Finally, we can further optimize this Shader by telling the Shader that it only works with certain renderers:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_13.jpg" /></div></li></ol></div><p>The result of our <a id="id485" class="indexterm"></a>optimization passes show us that we really don't notice a difference in the visual quality, but we have reduced the amount of time it takes for this Shader to be drawn to the screen. We will learn about finding out how much time it takes for a Shader to render in the next section, but the idea to focus on here is that we achieve the same result with less data. So keep this in mind when creating your Shaders. The following image shows us the final result of our Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_15.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec139"></a>How it works…</h3></div></div></div><p>Now that we have seen the ways in which we can optimize our Shaders, let's dive in a bit deeper and really understand why all of these techniques are working, and look at a couple of other techniques you can try for yourself.</p><p>Let's first focus <a id="id486" class="indexterm"></a>our attention to the size of the data that each variable is storing when we declare them. If you are familiar with programming, you will understand that you can declare values or variables with different sizes using data types. This means that a float actually has the maximum size in memory. Let's look at these variable types in more detail:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">float</code>: This is a full 32-bit precision value and is the slowest of the three different types we see here. It also has its corresponding values of <code class="literal">float2</code>, <code class="literal">float3</code>, and <code class="literal">float4</code>.</p></li><li style="list-style-type: disc"><p>
<code class="literal">half</code>: This is a reduced 16-bit floating point value and is suitable for storing UV values, color values, and is much faster than using a <code class="literal">float</code> value. It has its corresponding values like the <code class="literal">float</code> type, which are <code class="literal">half2</code>, <code class="literal">half3</code>, and <code class="literal">half4</code>.</p></li><li style="list-style-type: disc"><p>
<code class="literal">fixed</code>: This value is the smallest in size of the three types, but can be used for lighting calculations, colors, and has the corresponding values of <code class="literal">fixed2</code>, <code class="literal">fixed3</code>, and <code class="literal">fixed4</code>.</p></li></ul></div><p>Our second phase of optimizing our simple Shader was to declare the <code class="literal">noforwardadd</code> value to our <code class="literal">#pragma</code> statement. This is basically a switch that automatically tells Unity that any object with this particular Shader only receives per-pixel light from a single directional light. Any other lights that are calculated by this Shader will be forced to be processed as per-vertex lights using spherical harmonic values produced internally by Unity. This is especially obvious when we place another light in the scene to light our sphere object because our Shader is doing a per-pixel operation by using the normal map.</p><p>This is great, <a id="id487" class="indexterm"></a>but what if you wanted to have a bunch of directional lights in the scene and want to have control over which of those lights are used for the main per-pixel light? Well, if you notice, each light has a <span class="strong"><strong>Render Mode</strong></span> drop-down menu. If you click on this drop-down menu, you will see a couple of flags that can be set. These are <span class="strong"><strong>Auto</strong></span>, <span class="strong"><strong>Important</strong></span>, and <span class="strong"><strong>Not Important</strong></span>. By selecting a light, you can tell Unity that a light should be considered more as a per-pixel light, than a per-vertex light, by setting its render mode to <span class="strong"><strong>Important</strong></span> and vice versa. If you leave a light set to <span class="strong"><strong>Auto</strong></span>, you will let Unity decide the best course of action.</p><p>Place another light in your scene and remove the texture that is currently in the main texture for our Shader. You will notice that the second point light does not react with the normal map, only the directional light we created first. The concept here is that you save on per-pixel operations by just calculating all extra lights as vertex lights, and save performance by just calculating the main directional light as a per-pixel light. The following image visually demonstrates this concept as the point light is not reacting with the normal map:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_08_14.jpg" /></div><p>Finally, we did a bit of a cleanup and simply told the normal map texture to use the main texture's UV values, and we got rid of the line of code that pulled in a separate set of UV values specifically for the normal map. This is always a good way to simplify your code and clean up any unwanted data.</p><p>We also declared <code class="literal">exclude_pass: prepass</code> in our <code class="literal">#pragma</code> statement, so that this Shader wouldn't accept any custom lighting from the deferred renderer. This means we can only really use this Shader effectively in the forward renderer, which is set in the main camera's settings.</p><p>By taking a <a id="id488" class="indexterm"></a>bit of time, you will be amazed at how much a Shader can be optimized. You have seen how we can pack grayscale textures into a single RGBA texture, as well as using lookup textures to fake lighting. There are many ways in which a Shader can be optimized, which is why it is always an ambiguous question to ask in the first place; but knowing these different optimization techniques, you can cater your Shaders to your game and to your target platform, ultimately resulting in very streamlined Shaders and a nice steady frame rate.</p></div></div>