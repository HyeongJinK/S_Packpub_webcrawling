<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec45"></a>Depth sorting with render queues</h2></div></div><hr /></div><p>In order for us to truly <a id="id407" class="indexterm"></a>understand transparency, we need to take a look <a id="id408" class="indexterm"></a>at depth sorting or in simpler terms, the drawing order of objects. Unity allows us to control the order in which a particular object is drawn to the screen, so we can have a greater control of which objects render over other objects. You can think of the drawing order as being very similar to layers in Photoshop. Drawing order is especially important when dealing with transparency or elements such as user interface objects.</p><p>This recipe is going to start to reveal how you can utilize this layered approach to rendering your objects, using built-in tags provided to us by Unity. This is very important as you will gain a greater amount of control over how your objects are rendered to the game view.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec121"></a>Getting ready</h3></div></div></div><p>To get started, we will need to create a few assets in order for us to learn how we can use Unity's drawing order to give us more flexibility and control in our real time renders.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene and populate it with a couple of spheres, such that they are lined up in a row in whichever axis you want. Our goal is to take a look at how we can draw an object over another object regardless of its actual position in 3D space.</p></li><li><p>In order to see the effects of modifying an objects drawing order, we will need to have at least two Shaders. So let's create two new Shaders and name them appropriately. The demonstration Shaders are named <code class="literal">Depth001</code> and <code class="literal">Depth002</code>.</p></li><li><p>Your scene should look like the following screenshot. This set up will allow us to play with the order in which objects are drawn:</p></li></ol></div><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_11.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec122"></a>How to do it…</h3></div></div></div><p>The actual <a id="id409" class="indexterm"></a>Shader code to achieve this technique is quite<a id="id410" class="indexterm"></a> simple; it just requires two new lines of code that we haven't seen before.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We first need to declare which render queue this object will be drawn into and to do that we need to modify our <code class="literal">Tags{}</code> block<a id="id411" class="indexterm"></a>, just inside our<a id="id412" class="indexterm"></a> <code class="literal">SubShader()</code>:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_12.jpg" /></div></li><li><p>Next, we need to tell Unity that we want to control the order in which this object is drawn and that we don't want to write to the depth buffer. Add the following line of code just below the <code class="literal">Tags{}</code> line we added in the previous step:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_13.jpg" /></div></li><li><p>With that code entered into your Shader, we can now save and return to the Unity editor to let the Shader compile. When it is finished, you will notice that one of the spheres appears behind every other object, even though its actual position in 3D space is in front of every object in the scene. The following screenshot shows the result of our depth sorting shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084OT_06_14.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec123"></a>How it works…</h3></div></div></div><p>Unity, by <a id="id413" class="indexterm"></a>default, will sort your objects for you based off of the <a id="id414" class="indexterm"></a>distance from the camera. So as an object gets nearer to the camera, it is going to be drawn over all objects that are further away from the camera. For most cases this works out just fine for making games, but you will find certain situations where you will want to have more control over the sorting of your objects in your scene. Using the <code class="literal">Tags{}</code> block we can control this sorting.</p><p>Unity has provided us with some default render queues, each with a unique value that directs Unity when to draw the object to the screen. These built-in render queues are called <span class="strong"><strong>Background</strong></span>, <span class="strong"><strong>Geometry</strong></span>, <span class="strong"><strong>AlphaTest</strong></span>, <span class="strong"><strong>Transparent</strong></span>, and <span class="strong"><strong>Overlay</strong></span>. These queues weren't just created arbitrarily; they actually serve a purpose to make our lives easier when writing Shaders and interacting with the real time renderer. Refer to the following table for descriptions on the usage of each of these individual render queues:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /><col align="left" /></colgroup><thead><tr><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Render queue</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Render queue description</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Render queue value</p>
</th></tr></thead><tbody><tr><td style="" align="left" valign="top">
<p>Background<a id="id415" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>This render queue is rendered first. It is used for skyboxes and so on.</p>
</td><td style="" align="left" valign="top">
<p>
<code class="literal">1000</code>
</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Geometry<a id="id416" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>This is the default render queue. This is used for most objects. Opaque geometry uses this queue.</p>
</td><td style="" align="left" valign="top">
<p>
<code class="literal">2000</code>
</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>AlphaTest<a id="id417" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>Alpha-tested geometry uses this queue. It's different from the Geometry queue, as it's more efficient to render alpha-tested objects after all the solid objects are drawn.</p>
</td><td style="" align="left" valign="top">
<p>
<code class="literal">2450</code>
</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Transparent<a id="id418" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>This render queue is rendered after Geometry and AlphaTest queues in back-to-front order. Anything alpha-blended (that is, Shaders that don't write to depth buffer) should go here, for example glass and particle effects.</p>
</td><td style="" align="left" valign="top">
<p>
<code class="literal">3000</code>
</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Overlay<a id="id419" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>This render queue is meant for overlay effects. Anything rendered last should go here, for example lens flares.</p>
</td><td style="" align="left" valign="top">
<p>
<code class="literal">4000</code>
</p>
</td></tr></tbody></table></div><p>So once <a id="id420" class="indexterm"></a>you know which render queue your object belongs<a id="id421" class="indexterm"></a> to, you can assign it's built-in render queue tag. Our Shader used the Geometry queue, so we wrote <code class="literal">Tags{"Queue"="Geometry"}</code>. But we wanted to tell our object to draw behind everything in our Geometry queue but before the background queue. So we modified the <code class="literal">Tags{}</code> block to read <code class="literal">Tags{"Queue"="Geometry-20"}</code>. Doing this tells Unity that we want to consider this object as an opaque or solid object, but render it behind every other opaque object.</p><p>Lastly, we have to declare the <code class="literal">Zwrite</code> tag to our <code class="literal">SubShader</code> block. This tells Unity that we are going to override the depth sorting of our object, and we will be assigning a new value for its render queue. So, we simply set the <code class="literal">Zwrite</code> value to <code class="literal">off</code>.</p></div></div>