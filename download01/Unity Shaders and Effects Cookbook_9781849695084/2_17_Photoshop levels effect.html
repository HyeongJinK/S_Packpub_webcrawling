<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec22"></a>Photoshop levels effect</h2></div></div><hr /></div><p>If you have ever done <a id="id147" class="indexterm"></a>any sort of image editing, such as touching up a family photograph, making game textures, or digitally painting a picture, we are sure you understand the power of having levels to globally adjust your entire image. Well, it is completely possible to create Photoshop-like effects inside your Shaders as well.</p><p>All the different image editing tools and blending modes that you find in Photoshop are all described with a set of math operations. Ultimately, we are multiplying, adding, subtracting, and comparing pixel values with some other value, to finally get a return value. This return value then becomes the new pixel color in the image you're editing.</p><p>While we could write a whole book on just the different math recipes for the Photoshop effects, we are focusing on just levels here. We will cover more advanced blending modes in <a class="link" href="#" linkend="ch10">Chapter 10</a>, <span class="emphasis"><em>Screen Effects with Unity Render Textures</em></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec50"></a>Getting ready</h3></div></div></div><p>In order to complete this recipe, you will need to have a new Shader and Material created, and assign it to an object in a new Unity scene. You will also need a source texture with which to test out our level's code. You can also use the Materials that are included with this cookbook.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec51"></a>How to do it…</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following properties to the new Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_43.jpg" /></div></li><li><p>Make sure to also declare those properties as variables in your <code class="literal">CGPROGRAM</code> statement:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_44.jpg" /></div></li><li><p>Create a new variable to store only the red channel of our current <code class="literal">_MainTex</code> texture:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_45.jpg" /></div></li><li><p>Since the values<a id="id148" class="indexterm"></a> that are given to us by the <code class="literal">tex2D()</code> function<a id="id149" class="indexterm"></a> are in a range from 0.0 to 1.0, we need to re-map the range to 0.0 to 255.0.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_46.jpg" /></div></li><li><p>We then subtract our input black colors to bring all pixels to black as you slide the slider towards 255.0:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_47.jpg" /></div></li><li><p>Then we increase the whites of all pixels as we slide the input white slider towards 0.0, and take the result to a power of input gamma:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_48.jpg" /></div></li><li><p>Finally, we <a id="id150" class="indexterm"></a>multiply the new pixel value by the output white minus the output black, and then re-map the new pixel value to a range from 0.0 to 1.0:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_49.jpg" /></div></li></ol></div><p>The following image demonstrates the final effect of applying a level's procedure to our texture, through a Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_41.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec52"></a>How it works…</h3></div></div></div><p>The Shader's <code class="literal">surf</code> function starts by sampling a color texture using the <code class="literal">tex2D()</code> function and stores it in a variable called <code class="literal">c</code>. At this point, we want to start to work on the individual channels and modify each channel's pixels. To do this, we create a new variable <a id="id151" class="indexterm"></a>called <code class="literal">outRPixel</code> and assign it the value of <code class="literal">c.r * 255.0</code>. This will take the value from the range 0.0 to 1.0 to a value of 0.0 to 255.0.</p><p>The program then takes the current pixel value and subtracts the <code class="literal">_inBlack</code> property value, in order to darken the pixels value. We also make sure that the value doesn't go below 0.0 after the subtraction, by using the <code class="literal">max()</code> function, which gives us the maximum of two values.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /></colgroup><thead><tr><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Function</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="" align="left" valign="top">
<p>
<code class="literal">max( a, b )</code>
</p>
</td><td style="" align="left" valign="top">
<p>This returns the maximum of a and b</p>
</td></tr></tbody></table></div><p>We now want to take our modified pixel value and divide it by the new white point values. We can get the new white point value by subtracting the <code class="literal">_inBlack</code> value from the <code class="literal">_inWhite</code> value. This will simply raise the pixel value or make it brighter. This raised pixel value is then taken to a power of <code class="literal">_inGamma</code>, which basically allows you to move the midpoint value of the current pixel.</p><p>Finally, we modify the pixel again with the <code class="literal">_outWhite</code> and <code class="literal">_outBlack</code>, so you can have a final global control of what the minimum pixel value can be, as well as what the maximum pixel value can be. This result is then divided by 255.0, to get it back within the 0.0 to 1.0 range.</p><p>We take that final result and pass it to <code class="literal">o.Albedo</code> for our final diffuse color. When you play with the sliders in the Material's <span class="strong"><strong>Inspector</strong></span> tab, you notice that you have a lot of control over the texture's contrast and brightness.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec53"></a>There's more…</h3></div></div></div><p>We are sure you noticed, but we have a lot of duplicate code in our Shader. We can actually create a custom function within our Shader to clean our Shader code. This will help keep things clear and to make our Shader more efficient from a development standpoint. See the following custom function:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_56.jpg" /></div><p>By using this new function inside our Shader to process the final pixel level, we reduced our <code class="literal">surf</code> function Shader code to only three lines for all channels, instead of 15. This greatly cleans up our code and we now only have to make code changes in a single place, rather than three.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec54"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>More information on levels can be found <a id="id152" class="indexterm"></a>at <span class="emphasis"><em>GPU Gems</em></span> (<a class="ulink" href="http://http.developer.nvidia.com/GPUGems/gpugems_ch22.html" target="_blank">http://http.developer.nvidia.com/GPUGems/gpugems_ch22.html</a>)</p></li></ul></div></div></div>