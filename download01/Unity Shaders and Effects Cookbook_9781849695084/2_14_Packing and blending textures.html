<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>Packing and blending textures</h2></div></div><hr /></div><p>Textures are also useful for<a id="id104" class="indexterm"></a> storing loads of data, not just pixel colors as we generally tend to <a id="id105" class="indexterm"></a>think of them, but for storing multiple sets of pixels in both the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> directions and in the RGBA channels. We can actually pack multiple images into one single RGBA texture and use each of the R, G, B, and A components as individual textures themselves, by extracting each of those components in the Shader code.</p><p>The result of packing individual grayscale images into a single RGBA texture can be seen in the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_52.jpg" /></div><p>Why is this helpful? Well, in terms of the amount of actual memory your application takes up, textures are a large portion of your application's size. So, to begin reducing the size of your application, we can look at all of the images that we are using in our Shader and see if we can merge those textures into a single texture.</p><p>Any texture that is grayscale can be packed into one of the RGBA channels of another texture. This might sound a bit odd at first, but this recipe is going to demonstrate one of the uses for packing a texture and using those packed textures inside a Shader.</p><p>One example of using these packed textures is when you want to blend a set of textures together onto a single surface. You see this most often in terrain type Shaders, where you need to blend nicely into another texture using some sort of control texture, or the packed texture in this case. This recipe covers that technique and shows you how you can construct the beginnings of a nice four-texture blended terrain Shader.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec38"></a>Getting ready</h3></div></div></div><p>Let's create a new Shader file in your Shader folder, and then create a new Material for this Shader. The naming convention is entirely up to you for your Shader and Material files, so try your best to keep them organized and easy to reference later on.</p><p>Once you have your Shader and Material ready, create a new scene in which we can test our Shader.</p><p>You will also need to gather up four textures that you would want to blend together. These can be anything, but for a nice terrain Shader, you will want a grass, dirt, rocky dirt, and a rock texture.</p><p>These are the <a id="id106" class="indexterm"></a>color textures we will be using for this recipe, which are included with this book.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_42.jpg" /></div><p>Finally, we will also need a<a id="id107" class="indexterm"></a> blending texture that is packed with grayscale images. This will give us the four blending textures that we can use to direct how the color textures will be placed on the object surface.</p><p>We can use very intricate blending textures to create a very realistic distribution of terrain textures over a terrain mesh, as seen in the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_53.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec39"></a>How to do it…</h3></div></div></div><p>Let's learn how to use packed textures by entering the code shown in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We need to add a few properties to our <code class="literal">Properties</code> block. We will need five <code class="literal">sampler2D</code> objects, or textures, and two color properties.</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_16.jpg" /></div></li><li><p>We then <a id="id108" class="indexterm"></a>need to <a id="id109" class="indexterm"></a>create the <span class="strong"><strong>SubShader</strong></span> variables that will be our link to the data in the <code class="literal">Properties</code> block:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_17.jpg" /></div></li><li><p>So now we have our texture properties, and we are passing them into our <code class="literal">SubShader</code> function. In order to allow the user to change the tiling rates on a per-texture basis, we will need to modify our <code class="literal">Input</code> struct. This will allow us to use the tiling and offset parameters on each texture:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_18.jpg" /></div></li><li><p>In the <code class="literal">surf</code> function, get the texture information and store them into their own variables so we can work with the data in a clean, easy-to-understand way:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_19.jpg" /></div></li><li><p>Let's blend<a id="id110" class="indexterm"></a> each <a id="id111" class="indexterm"></a>of our textures together using the<a id="id112" class="indexterm"></a> <code class="literal">lerp()</code> function. It takes in three arguments, <code class="literal">lerp(value : a, value : b, blend: c)</code>. The <code class="literal">lerp</code> function takes in two textures and blends them with the float value given in the last argument:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_20.jpg" /></div></li><li><p>Finally, we multiply our blended textures with the color tint values and use the red channel to determine where the two different terrain tint colors go:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_21.jpg" /></div></li></ol></div><p>The result of blending together four terrain textures and creating a terrain tinting technique can be seen in the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_15.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec40"></a>How it works…</h3></div></div></div><p>This might seem<a id="id113" class="indexterm"></a> like quite a<a id="id114" class="indexterm"></a> few lines of code, but the concept behind blending is actually quite simple. For the technique to work we have to employ the <code class="literal">lerp()</code> built-in function from the CGFX standard library. This function allows us to pick a value between argument one and argument two by using argument three as the blend amount.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /></colgroup><thead><tr><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Function</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="" align="left" valign="top">
<p>
<code class="literal">lerp( a, b, f )</code>
<a id="id115" class="indexterm"></a>
</p>
</td><td style="" align="left" valign="top">
<p>Involves linear interpolation:</p>
<p>
<code class="literal">(1 – f )* a + b * f</code>
</p>
<p>Here, <code class="literal">a</code> and <code class="literal">b</code> are matching vector or scalar types. <code class="literal">f</code> can be either a scalar or a vector of the same type as <code class="literal">a</code> and <code class="literal">b</code>.</p>
</td></tr></tbody></table></div><p>So, for example, if we wanted to find the mid-value between 1 and 2, we could feed the value 0.5 as the third argument to the <code class="literal">lerp()</code> function and it would return the value 1.5. This works perfectly for our blending needs as the values of an individual channel in an RGBA texture are single float values, usually in the range of 0 to 1.</p><p>In the Shader, <a id="id116" class="indexterm"></a>we simply<a id="id117" class="indexterm"></a> take one of the channels from our blend texture and use it to drive the color that is picked in a <code class="literal">lerp</code> function, for each pixel. For instance, we take our grass texture and our dirt texture and use the red channel from our blending texture, and feed that into a <code class="literal">lerp()</code> function. This will give us the correct blended color result for each pixel on the surface.</p><p>A more visual representation of what is happening when using the <code class="literal">lerp()</code> function is shown in the following image:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_02_54.jpg" /></div><p>The Shader code simply uses the four channels of the blend texture, and all the color textures, to create a final blended texture. This final texture then becomes our color that we can multiply with our diffuse lighting.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec41"></a>See also</h3></div></div></div><p>The terrain for this recipe was created with World Machine. This is a great way to produce very complex terrain blending textures and meshes.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>World Machine</strong></span>
<a id="id118" class="indexterm"></a> ($189.00):</p><p>
<a class="ulink" href="http://www.world-machine.com/" target="_blank">http://www.world-machine.com/</a>
</p></li></ul></div></div></div>