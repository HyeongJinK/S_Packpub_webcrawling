<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec48"></a>Accessing a vertex color in a Surface Shader</h2></div></div><hr /></div><p>Let's begin this <a id="id446" class="indexterm"></a>chapter by taking a look at how we can <a id="id447" class="indexterm"></a>access the information of a model's vertex, using the vertex function within a Surface Shader. This will arm us with the knowledge to start utilizing the elements contained within a model's vertex, to create really useful and visually appealing effects.</p><p>A vertex in a vertex function can return information about itself that we need to be aware of. You can actually retrieve the vertices' normal directions as a <code class="literal">float3</code> value, the position of the vertex as <code class="literal">float3</code>, and you can even store color values in each vertex and return that color as <code class="literal">float4</code>. This is what we will take a look at in this recipe. We need to learn how to store color information and retrieve that stored color information, inside each vertex of a Surface Shader.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec127"></a>Getting ready</h3></div></div></div><p>In order to write <a id="id448" class="indexterm"></a>this Shader we are going to prepare a<a id="id449" class="indexterm"></a> few assets. The following steps will set us up for creating this vertex shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In order to view the colors of a vertex, we need to have a model that has had color applied to its vertices. While you could use Unity to apply colors, you would have to write a tool to allow an individual to apply the colors or write some scripts to achieve the color application. In the case of this recipe, we simply utilized Maya to apply the colors to our model. This model is available on the book's <span class="strong"><strong>Support</strong></span> page at <a class="ulink" href="http://www.packtpub.com/support" target="_blank">www.packtpub.com/support</a>.</p></li><li><p>Create a new scene and place the imported model into the scene.</p></li><li><p>Create a new Shader and Material. When completed, assign the Shader to the Material and then the Material to the imported model.</p></li></ol></div><p>Your scene should now look similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_01.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec128"></a>How to do it…</h3></div></div></div><p>With our<a id="id450" class="indexterm"></a> scene, the Shader, and the Material created and ready to go, we can begin to write the code for our Shader. Launch the <a id="id451" class="indexterm"></a>Shader by double-clicking on it in the <span class="strong"><strong>Project</strong></span> tab, in the Unity editor.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Since we are creating a very simple Shader we will not need to include <span class="emphasis"><em>any</em></span> properties, to our <code class="literal">Properties</code> block. We will still include a global tint color, just to stay consistent with the other Shaders in this book. Enter the following code into the <code class="literal">Properties</code> block of your Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_02.jpg" /></div></li><li><p>This next step tells Unity that we will be including a vertex function in our Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_03.jpg" /></div></li><li><p>As usual, if we have included properties in our <code class="literal">Properties</code> block, we must make sure to create a corresponding variable in our <code class="literal">CGPROGRAM</code> statement. Enter the following code just below the <code class="literal">#pragma</code> statement:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_04.jpg" /></div></li><li><p>We<a id="id452" class="indexterm"></a> now turn our attention to the <code class="literal">Input</code> struct. We <a id="id453" class="indexterm"></a>need to add a new variable in order for our <code class="literal">surf()</code> function to access the data given to us by our<a id="id454" class="indexterm"></a> <code class="literal">vert()</code> function:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_05.jpg" /></div></li><li><p>Now we can write our simple <code class="literal">vert()</code> function to gain access to the colors stored in each vertex of our mesh:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_06.jpg" /></div></li><li><p>Finally, we can use the vertex color data from our <code class="literal">Input</code> struct to be assigned to the <code class="literal">o.Albedo</code> parameters in the built-in <code class="literal">SurfaceOutput</code> struct:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_07.jpg" /></div></li><li><p>With our code completed, we can now re-enter the Unity editor and let the Shader compile. If all goes well, you should see something similar to the <a id="id455" class="indexterm"></a>following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_08.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec129"></a>How it works…</h3></div></div></div><p>Unity<a id="id456" class="indexterm"></a> provides us with a way to access the vertex information of the model to which a Shader is attached to. This gives us the power to modify things such as the vertices' position and color. With this recipe, we have imported a mesh from Maya (though just about any 3D software application can be used), where vertex colors were added to the verts. You'll notice that by importing the model, the default material will not display the vertex colors. We actually have to write a Shader to extract the vertex color and display it on the surface of the model. Unity provides us with a lot of built-in functionality when using Surface Shaders, which make the process of extracting this vertex information quick and efficient.</p><p>Our first task is to tell Unity that we will be using a vertex function when creating our Shader. We do this by adding the <code class="literal">vertex:vert</code> parameter to the <code class="literal">#pragma</code> statement of <code class="literal">CGPROGRAM</code>. This automatically makes Unity look for a vertex function named <code class="literal">vert</code>, when it goes to compile the Shader. If it doesn't find one, Unity will throw a compiling error and ask for you to add a <code class="literal">vert</code> function to your Shader.</p><p>That brings us to our next step. We have to actually code the <code class="literal">vert()</code> function, as seen in step 5. By having this function, we can access the built-in data struct called <code class="literal">appdata_full</code>. This built-in struct is where the vertex information is stored. So, we then extract the vertex color information by passing it to our <code class="literal">Input</code> struct, by adding the code <code class="literal">o.vertColor = v.color</code>.</p><p>The <code class="literal">o</code> variable represents<a id="id457" class="indexterm"></a> our <code class="literal">Input</code> struct and the <code class="literal">v</code> <a id="id458" class="indexterm"></a>variable is our <code class="literal">appdata_full</code> vertex data. In this case, we are simply taking the color information from the <code class="literal">appdata_full</code> struct and putting it into our <code class="literal">Input</code> struct. Once the vertex color is in our <code class="literal">Input</code> struct, we can use it in our <code class="literal">surf()</code> function. In the case of this recipe, we simply apply the color to the <code class="literal">o.Albedo</code> parameter in the built-in <code class="literal">SurfaceOutput</code> struct.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec130"></a>There's more…</h3></div></div></div><p>One can also access a fourth component from the <code class="literal">vert</code> color data. If you notice, the <code class="literal">vertColor</code> variable we declared in the <code class="literal">Input</code> struct is of type <code class="literal">float4</code>. This means we are also passing in the alpha value of the vertex colors. Knowing this, you can use it to your advantage, for the purpose of storing a fourth vertex color, to perform effects such as transparency, or to give yourself one more mask to blend in two textures. It's really up to you and your production to determine if you really need to use the fourth component, but it is worth mentioning here.</p><p>With Unity 4, we now have the ability to target Shaders to Directx 11. This is great, but it means that the compiling process for the Shaders is now a bit pickier. This means that we need to include one more line of code to our Shader, to initialize the output of the vertex information properly. The following code shows what the vertex function code looks like, if you are using Directx 11 in your Shader:</p><div class="mediaobject"><img src="/graphics/9781849695084/graphics/5084_07_27.jpg" /></div><p>By including this line of code, your vertex shader will not throw any warnings, which say that it won't compile to Directx 11 appropriately.</p></div></div>