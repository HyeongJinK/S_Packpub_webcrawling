<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec31"></a>Texture files</h2></div></div><hr /></div><p>The terms <span class="emphasis"><em>texture</em></span> and <span class="emphasis"><em>sprite</em></span> often get confused in game development, so it's worth making the distinction--a texture is simply an image file, a big list of color data telling the interpreting program what color each pixel of the image should be, whereas a sprite is the 2D equivalent of a mesh, which is often just a single <span class="emphasis"><em>quad</em></span> (a pair of triangles combined to make a rectangular mesh) that renders flat against the current Camera. There are also things called Sprite Sheets, which are large collections of individual images contained within a larger texture file, commonly used to contain the animations of a 2D character. These files can be split apart by tools, such as Unity's Sprite Atlas tool, to form individual textures for the character's animated frames.</p><p>Both meshes and sprites use textures to render an image onto its surface. Texture image files are typically generated in tools such as Adobe Photoshop or Gimp and then imported into our project in much the same way as audio files. At runtime, these files are loaded into memory, pushed to the GPU's VRAM, and rendered by a Shader over the target sprite or mesh during a given Draw Call.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec35"></a>Texture compression formats</h3></div></div></div><p>Much like audio files, Unity will import texture files with a default list of settings that tend to keep things simple and work okay in the general case, but there are many import settings available, allowing us to improve a texture's quality and performance with some custom tweaking. Of course, making changes is just as likely to reduce quality and performance if we blindly make changes without fully understanding the internal processes going on.</p><p>The first option is the file's <strong class="userinput"><code>Texture Type</code></strong>. This setting will determine what other options are available, particularly under the <strong class="userinput"><code>Advanced</code></strong> dropdown. Not all importing options are available to all types, so it is best to configure this option for the texture's intended purpose, whether it is set to <strong class="userinput"><code>Normal Map</code></strong>, <strong class="userinput"><code>Sprite</code></strong>, <strong class="userinput"><code>Lightmap</code></strong>, and so on, as this will reveal the options appropriate for that type:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/1a056921-9915-4e6f-88cf-36a23bd2141c.png" /></div><p>Similar to audio files, we can import texture files in multiple common formats (such as <code class="literal">.jpg</code>, and <code class="literal">.png</code>), but the actual compression format built into the application could be one of many different texture compression formats ideally suited for GPUs of the given platform. These formats represent different ways of organizing the texture's color information; this includes different numbers of bits used to represent each channel (the more bits used, the more colors that can be represented), different numbers of bits per-channel (for example, the red channel may use more bits than the green channel), different total number of bits used for all channels (more bits naturally mean larger textures and more disk and memory consumption), whether or not an alpha channel is included, and perhaps the most important, different ways of packing the data together, which can allow for efficient memory access for the GPU (or incredibly inefficient access if the wrong packing type is chosen!).</p><p>The simple way of altering compression is to use the <strong class="userinput"><code>Compression</code></strong> texture import option to select one among the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>None</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>Low Quality</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>Normal Quality</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>High Quality</code></strong></li></ul></div><p>Selecting <strong class="userinput"><code>None</code></strong> means that no compression will be applied. In this case, the final texture will still change format from the file type we imported, but it will select a format that makes no attempt at compression, and so we should see little or no quality loss at the expense of large texture files. The other three settings will pick a compression format, which, again, will vary depending on the platform, and Unity will try to pick a compression format that matches the option. For instance, selecting <strong class="userinput"><code>Low Quality</code></strong> will mean Unity picks a compression format that greatly reduces the texture size, but will generate some compression artifacts, while selecting <strong class="userinput"><code>High Quality</code></strong> will consume more memory with much larger texture sizes and minimal artifacting. Again, this is an automatic selection made by Unity.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note51"></a>Note</h3><p>The exact formats Unity picks for each platform for each of these <strong class="userinput"><code>Compression</code></strong> settings can be found at <a class="ulink" href="https://docs.unity3d.com/Manual/class-TextureImporterOverride.html" target="_blank">https://docs.unity3d.com/Manual/class-TextureImporterOverride.html</a>.</p></div><p>The exact compression format Unity chooses can be overridden, although the available options vary per platform, since practically every platform has its own custom formats that work best for it. If we click on one of the platform-specific tabs beside the <strong class="userinput"><code>Default</code></strong> tab (just above the <strong class="userinput"><code>Max Size</code></strong> option), we will expose settings for a specific platform and can choose the exact compression format we want Unity to use.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip52"></a>Note</h3><p>There is also the <strong class="userinput"><code>Crunch Compression</code></strong> setting, which will apply an additional level of lossy compression on top of the DXT compression format. This option is only revealed if the other compression settings resulted in a DXT level of compression. This setting can save even more space at the cost of potentially glaring compression artifacts, depending on the <strong class="userinput"><code>Compressor Quality</code></strong> setting.</p></div><p>Several of a texture's import settings are fairly mundane, such as determining whether the file contains an alpha channel, how to wrap the texture at its extents, filtering method, and maximum possible resolution of the file (a global limit so that we don't accidentally overscale the texture beyond its original size on certain platforms). However, there are several other interesting options in these import settings, which we will cover in other sections where appropriate.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec36"></a>Texture performance enhancements</h3></div></div></div><p>Let's explore some changes we can make to our texture files, which might help improve performance, depending on the situation and the content of the files we're importing. In each case, we'll explore the changes that need to be made and the overall effect they have, whether this results in a positive or negative impact on memory or CPU, an increase or decrease in the texture quality, and under what conditions we can expect to make use of these techniques.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec31"></a>Reduce texture file size</h4></div></div></div><p>The larger a given texture file, the more GPU Memory Bandwidth will be consumed, pushing the texture when it is needed. If the total memory pushed per second exceeds the graphics card's total Memory Bandwidth, then we will have a bottleneck, as the GPU must wait for all textures to be uploaded before the next rendering pass can begin. Smaller textures are naturally easier to push through the pipeline than larger textures, so we will need to find a good middle ground between high quality and performance.</p><p>A simple test to find out if we're bottlenecked in Memory Bandwidth is to reduce the resolution of our games most abundant and largest texture files and relaunch the Scene. If the frame rate suddenly improves, then the application was most likely bound by texture throughput. If the frame rate does not improve or improves very little, then either we still have some Memory Bandwidth to make use of or there are bottlenecks elsewhere in the Rendering Pipeline, preventing us from seeing any further improvement.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec32"></a>Use Mip Maps wisely</h4></div></div></div><p>There would be no point rendering small, distant objects, such as rocks and trees, with a high-detail texture if there's no way the player would ever be able to see that detail. Of course, they may see some slight improvement, but the performance cost may not be worth the minor detail increase. Mip Maps were invented as a way to solve this problem (as well as helping eliminate aliasing problems that were plaguing video games at around the same time), by pregenerating lower-resolution alternatives of the same texture and keeping them together in the same memory space. At runtime, the GPU picks the appropriate Mip Map level based on how large the surface appears within the perspective view (essentially based on the texel-to-pixel ratio when the object is rendered).</p><p>By enabling the <strong class="userinput"><code>Generate Mip Maps</code></strong> setting, Unity automatically handles the generation of these lower-resolution copies of the texture. These alternatives are generated using high-quality resampling and filtering methods within the Editor, rather than during runtime. There are several other options available for Mip Map generation, which can affect the quality of the generated levels, so some tweaking may be required to get a high quality set of Mip Maps. We will need to decide whether the time spent tweaking these values is worth it, since the whole purpose of Mip Maps is to intentionally reduce quality to save performance in the first place.</p><p>The following image shows how a 1024 x 1024 image that has been Mip Mapped into multiple lower-resolution duplicates:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/c6ae7b87-82cf-4913-9ffb-0dd9f42ac8d4.png" /></div><p>These images will be packed together to save space, essentially creating a final texture file that will be about 33 percent larger than the original image. This will cost some disk space and GPU Memory Bandwidth to upload. </p><p>It's possible to observe which Mip Map levels are being used by our application at certain points by changing the <strong class="userinput"><code>Draw Mode</code></strong> setting of the <strong class="userinput"><code>Scene</code></strong> window to <strong class="userinput"><code>Mipmaps</code></strong>. This will highlight textures in red if they are larger than they should be, given the player's current view (the extra detail is wasted), while being highlighted blue means that they are too small (the player is observing a low quality texture with a poor texel-to-pixel ratio).</p><p>Remember that Mip Mapping is only useful if we have textures that need to be rendered at varying distances from the Camera. If we have textures that always render at a common distance from the Main Camera, such that the Mip Mapped alternatives are never used, then enabling Mip Maps is just a waste of space. Similarly, if we happen to have a texture that always resolves to the same Mip Map level since the player's Camera never gets too close/far away to switch levels, then it would be wiser to simply downscale the original texture. </p><p>Good examples of this would be any texture file used in a 2D game, textures used by UI systems, or those used in a Skybox or distant background since, by design, these textures will always be about the same distance from the Camera, so Mip Mapping would be essentially pointless. Other good examples include objects that only appear near the player, such as player-centric Particle Effects, characters, objects that only appear near the player, and objects that only the player can hold/carry.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec33"></a>Manage resolution downscaling externally</h4></div></div></div><p>Unity puts a lot of effort into making things as easy to use as possible and provides us with the ability to place the project files from external tools to our project workspace, such as <code class="literal">.PSD</code> and <code class="literal">.TIFF</code> files, which are often large and split into multiple layered images. Unity automatically generates a texture file from the file's contents for the rest of the Engine to make use of, which can be very convenient, as we only need to maintain a single copy of the file through Source Control, and the Unity copy is automatically updated when an artist makes changes.</p><p>The problem is that the aliasing introduced by Unity's auto-texture generation and compression techniques from these files may not be as good as what the texture-editing tools we use could generate for us. Unity is very feature-rich and, first and foremost, focuses on being a game development platform, which means that it can have difficulty competing in areas that other software developers work on full time. Unity may be introducing artifacts through aliasing as a result of downscaling the image for us, and so we might find ourselves working around it by importing image files with a higher resolution than necessary just to keep the intended quality level. However, had we downscaled the image through the external application first, we might have suffered much less aliasing. In these cases, we may achieve an acceptable level of quality with a lower resolution, while consuming less overall disk and memory space.</p><p>We can either avoid using <code class="literal">.PSD</code> and <code class="literal">.TIFF</code> files within our Unity project as a matter of habit (storing them elsewhere and importing the downscaled version into Unity) or just perform some occasional testing to ensure that we're not wasting file size, memory, and GPU Memory Bandwidth using larger resolution files than necessary. This costs us some convenience in project file management, but can provide some significant savings for some textures, if we're willing to spend the time comparing the different downscaled versions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec34"></a>Adjust Anisotropic Filtering levels</h4></div></div></div><p>Anisotropic Filtering is a feature that improves the image quality of textures when they are viewed at very oblique (shallow) angles. The following screenshot shows the classic example of painted lines on a road with and without Anisotropic Filtering applied:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/ac4910d4-8c59-44a7-a869-0293dcb5b01d.png" /></div><p>In either case, the painted lines close to the Camera appear fairly clear, but things change as they get further away from the Camera. Without Anisotropic Filtering, the distant painted lines get more and more blurry and distorted, whereas these lines remain crisp and clear with Anisotropic Filtering applied.</p><p>The strength of Anisotropic Filtering applied to the texture can be hand-modified on a per-texture basis with the <strong class="userinput"><code>Aniso Level</code></strong> setting as well as globally enabled/disabled using the Anisotropic Textures option within the <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project</code></strong> | <strong class="userinput"><code>Quality</code></strong> settings.</p><p>Much like Mip Mapping, this effect can be costly and, sometimes, unnecessary. If there are textures in our Scene that we are certain will never be viewed at an oblique angle (such as distant background objects, UI elements, and billboard Particle Effect textures), then we can safely disable Anisotropic Filtering for them to save runtime overhead. We can also consider adjusting the strength of the Anisotropic Filtering effect on a per-texture basis to find the magic spot between quality and performance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec35"></a>Consider Atlasing</h4></div></div></div><p>Atlasing is the technique of combining lots of smaller, isolated textures together into a single, large texture file in order to minimize the number of Materials, and hence Draw Calls, we need to use. This is effectively a means to exploit Dynamic Batching. Conceptually, this technique is very similar to the approaches of minimizing Material usage you learned in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>The Benefits of Batching</em></span>.</p><p>Each unique Material will require an additional Draw Call, but each Material only supports a single primary texture. Of course, they can also support multiple secondary textures, such as Normal Maps and Emission Maps. However, by combining multiple primary textures into a single large texture file, we can minimize the number of Draw Calls used to render objects that share this texture:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/d5ec6b66-9559-4a34-85ce-eb1d67ec9067.png" /></div><p>Extra work is required to modify the UV coordinates used by the mesh or sprite object to only sample the portion of the larger texture file that it needs, but the benefits are clear; reducing Draw Calls results in reduction of CPU workload and improvement in the frame rate if our application is bottlenecked on CPU. Assuming that the merged texture file's resolution is equivalent to that of all of the combined images, there will be no loss of quality, and memory consumption will be essentially identical. Note that Atlasing does not result in reduced Memory Bandwidth consumption since the amount of data being pushed to the GPU would also be identical. It just happens to be bundled together in one bigger texture file.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip53"></a>Note</h3><p>Atlasing is only an option when all of the given textures require the same Shader. If some of the textures need unique graphical effects applied through Shaders, then they must be isolated into their own Materials and Atlased in separate groups.</p></div><p>Atlasing is a common tactic applied to UI elements and in games that feature a lot of 2D graphics. Atlasing becomes practically essential when developing mobile games with Unity since Draw Calls tend to be the most common bottleneck on those platforms. However, we would not want to generate these Atlas files manually. Life would be much simpler if we could continue to edit our textures individually and automate the task of combining them into a larger file.</p><p>Many GUI-related tools in the Unity Asset Store provide an automated texture-Atlasing feature. There are some stand-alone programs scattered across the internet, which can handle this work, and Unity can generate Atlases for Sprites in the form of Assets. These can be created via <strong class="userinput"><code>Asset</code></strong> | <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>Sprite Atlas</code></strong>. </p><p>Check out the Unity documentation to discover more about this useful feature at <a class="ulink" href="https://docs.unity3d.com/Manual/SpriteAtlas.html" target="_blank">https://docs.unity3d.com/Manual/SpriteAtlas.html</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip54"></a>Note</h3><p>Note that the Sprite Atlas feature effectively supplants the Sprite Packer tool from older versions of Unity.</p></div><p>Atlasing does not need to be applied to 2D graphics and UI elements, either. We can apply this technique to 3D meshes if we happen to be creating a lot of low-resolution textures. 3D games that feature simple texture resolutions, or a flat-shaded low-poly art style, are ideal candidates for Atlasing in this way.</p><p>However, because Dynamic Batching affects only non-animated meshes (that is, <code class="literal">MeshRenderer</code>, but not <code class="literal">SkinnedMeshRenderer</code>), there is no reason to combine texture files for animated characters into an Atlas. Since they are animated, the GPU needs to multiply each object's bones by the transform of the current animation state. This means a unique calculation is needed for each character, and they will result in an extra Draw Call regardless of any attempts we make to have them share Materials.</p><p>As a result, combining textures for animated characters should be done only as a matter of convenience and space saving; for example, in a flat-shaded low-poly art style game, where everything happens to use a common color palette, we can make some space savings using a single texture for the entire game world, objects, and characters.</p><p>The disadvantages of Atlasing are mostly in terms of development time and workflow costs. It requires a lot of effort to overhaul an existing project to make use of Atlasing, which can be a lot of work just to figure out whether it is worth the effort or not. In addition, we need to be aware of generating texture files, which are too large for the target platform.</p><p>Some devices (specifically mobile devices) have a relatively low limit on the size of textures that can be pulled into the lowest memory cache of the GPU. If the Atlased texture file is too large, then it must be broken up into smaller textures in order to fit the target memory space. If the device's GPU happens to need textures from different pieces of the Atlas every other Draw Call, then we not only will inflict a lot of cache misses, but also might find that we choke the Memory Bandwidth, as textures are constantly pulled from VRAM and the lower-level cache.</p><p>We would probably not have this problem if the Atlas was left as individual textures. The same texture swapping will occur, but will result in much smaller files being swapped at the cost of additional Draw Calls. Our best options at this stage would be to lower the Atlas resolution or generate multiple smaller Atlases to have better control over how they will be dynamically batched.</p><p>Atlasing is clearly not a perfect solution, and if it is not clear whether it would result in a performance benefit, then we should be careful not to waste too much time on its implementation. Speaking very generally, mobile games with a very simplistic 2D art style probably won't need to make use of Atlasing. However, mobile games attempting to compete with high quality assets or use any kind of 3D graphics should probably start integrating Atlasing from the very beginning of development, since it is likely that the project will reach texture throughput limits very quickly. They may even need to apply many per-platform and per-device optimizations in order to reach a wide audience.</p><p>Meanwhile, we should consider applying Atlasing to high-quality desktop games only if our Draw Call count exceeds reasonable hardware expectations since we will want many of our textures to maintain high resolutions for maximum quality. Low-quality Desktop games can probably afford to avoid Atlasing since Draw Calls are unlikely to be the biggest bottleneck.</p><p>Of course, no matter what the product is, if we're ever limited in CPU by too many Draw Calls and have already exhausted many of the alternative techniques, then Atlasing is a very effective performance enhancement in most cases.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec36"></a>Adjust compression rates for non-square textures</h4></div></div></div><p><span>Texture files are n</span>ormally stored in a square, <span class="emphasis"><em>power-of-two</em></span> format, meaning that their height and width are equal in length, and its size is a power of two. For example, typical sizes are 256 x 256 pixels, 512 x 512, 1024 x 1024, and so on.</p><p>It is possible to provide rectangular power-of-two textures (such as 256 x 512) or those with a non-power-of-two format (such as 192 x 192), but creating textures such as these is not recommended. Some GPUs require square texture formats, so Unity will compensate by automatically expanding the texture to include additional empty space in order to fit the form factor that the GPU expects, which will result in additional Memory Bandwidth costs, pushing what is essentially unused and useless data to the GPU. Other GPUs may support non-power-of-two textures, but it is likely to result in slower sampling than a square texture.</p><p>So, the first recommendation is to avoid non-square and/or non-power-of-two textures altogether. If the image can be placed within a square, power-of-two texture, and does not result in too much quality degradation due to squeezing/stretching, then we should apply those changes just to keep the CPU and GPU happy. As a second option, we can customize this scaling behavior in Unity through the texture file's <code class="literal">Non Power of 2</code> import setting, though because this is an automated process, it might not give us the graphical quality we expect.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec37"></a>Sparse Textures</h4></div></div></div><p>Sparse Textures, also known as <span class="strong"><strong>Mega-Textures</strong></span> or <span class="strong"><strong>Tiled-Textures</strong></span>, provide a way of effectively streaming texture data from disk at runtime. Relatively speaking, if the CPU performs operations in the order of seconds, then the disk would operate in the order of days. So, the common advice is that hard disk access during gameplay should be avoided as much as possible since any such technique risks inflicting more disk access than available, causing our application to grind to a halt.</p><p>However, Sparse Texturing offers some interesting performance-saving techniques if we're smart about starting data transfer for portions of the texture before we need them. Sparse Texturing is prepared by combining many textures into an enormous texture file, which would be far too large to load into graphics memory as a single texture file. This is similar to the concept of Atlasing, except the file containing the textures is incredibly large--for example,  32,768 x 32,768 pixels--and would contain considerable color detail, such as 32 bits per-pixel (this would result in a texture file that consumes 4 GBs of disk space). The idea is to save large amounts of runtime memory and Memory Bandwidth by hand-picking small subsections of the texture to load from disk dynamically, pulling them from the disk moments before they are needed in the game. The main cost of this technique is the file size requirement and the potentially continuous disk access. Other costs for this technique can be overcome, but normally take a great deal of Scene preparation work.</p><p>The game world needs to be created in such a way that it minimizes the amount of texture swapping taking place. In order to avoid very noticeable <span class="emphasis"><em>texture popping</em></span> problems, texture subsections must be pulled from a disk into RAM with just enough time to spare that the GPU does not need to wait before the transfer to VRAM can begin (in much the same way that it normally doesn't need to wait for ordinary texture files that are preloaded into RAM). This takes place in the design of the texture file itself by keeping common elements for a given Scene in the same general area of the texture, and the design of the Scene, by triggering new texture subsection loading at key moments during gameplay and making sure that disk access of the new tile is quickly located by the disk without extreme cache misses. If it is handled with care, then Sparse Texturing can result in impressive benefits in both Scene quality and memory savings.</p><p>It is a highly specialized technique in the gaming industry and has not yet been widely adopted partly because it requires specialized hardware and platform support and partly because it is difficult to pull it off well. The Unity documentation on Sparse Texturing has improved somewhat over time and provides an example Scene showing the effect at work, which can be found at <a class="ulink" href="http://docs.unity3d.com/Manual/SparseTextures.html" target="_blank">http://docs.unity3d.com/Manual/SparseTextures.html</a>.</p><p>For Unity developers who consider themselves advanced enough to experiment with Sparse Texturing, it might be worth taking the time to perform some research to check whether Sparse Texturing is right for their project since it promises some significant performance savings.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec38"></a>Procedural Materials</h4></div></div></div><p>Procedural Materials, also known as <span class="strong"><strong>Substances</strong></span>, are a means of procedurally generating textures at runtime by combining small, high-quality texture samples with custom mathematical formulas. The goal of Procedural Materials is to greatly minimize the application disk footprint at the cost of additional runtime memory and CPU processing during initialization to generate the texture via mathematical operations rather than static color data.</p><p>Texture files are, sometimes, the biggest disk space consumer of a game project, and it's fairly common knowledge that download times have a tremendous negative impact on the completed download rate and getting people to try our game (even if it's free). Procedural Materials offer us the ability to sacrifice some initialization and runtime processing power for much faster downloads. This is very important for mobile games that are trying to compete via graphical fidelity.</p><p>The Unity documentation on Procedural Materials is fairly extensive, so it is recommended to work through the documentation for a clearer picture of how Substances work and how they can provide us with performance benefits. Check out the following Unity documentation page for more information on Procedural Materials: <a class="ulink" href="http://docs.unity3d.com/Manual/ProceduralMaterials.html" target="_blank">http://docs.unity3d.com/Manual/ProceduralMaterials.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec39"></a>Asynchronous Texture Uploading</h4></div></div></div><p>The last texture import option we haven't covered is the <strong class="userinput"><code>Read/Write Enabled</code></strong> option. By default, this option is disabled, which is good, because this allows textures to make use of the Asynchronous Texture Uploading feature, which allows two benefits: the texture will be uploaded asynchronously from disk to RAM, and when the texture data is needed by the GPU, the transfer happens on the render thread, not the main thread. Textures will be pushed into a circular buffer, which pushes data to the GPU continuously so long as the buffer contains new data. If not, then it early-exits the process and waits until new texture data is requested.</p><p>Ultimately, this reduces the time spent preparing the Render States for each frame and allows more CPU resources to be spent on gameplay logic, the Physics Engine, and so on. Of course, some time is still spent on the main thread preparing the Render State, but moving the texture uploading task to a separate thread saves a significant chunk of CPU time on the main thread.</p><p>However, enabling read/write access to the texture essentially tells Unity we might be reading and editing this texture at any time. This implies that the GPU will need fresh access to it every time, so it will disable Asynchronous Texture Uploading for that texture; all uploading must occur on the main thread. We might want to enable this option for things such as simulating painting colors onto a canvas or writing image data from the internet into a premade texture, but the downside is that the GPU must always wait for any changes to be made to the texture before it can be uploaded since it cannot predict when those changes will happen.</p><p>In addition, Asynchronous Texture Uploading only works for textures we explicitly imported into the project and that were present during build time, since the feature only works if the texture was packed together into special streamable assets. Therefore, any textures generated via <span><code class="literal">LoadImage(byte[])</code>, texture assets imported/downloaded from external locations, or loaded from a <span class="emphasis"><em>Resources</em></span> folder via <code class="literal">Resources.Load()</code> (which all implicitly call <code class="literal">LoadImage(byte[])</code>  themselves) will not be converted into streamable content, and thus will be unable to make use of Asynchronous Texture Uploading.</span></p><p>It is possible to tweak both the upper limit on the maximum allowed time to spend on Asynchronous Texture Uploads and the total circular buffer size Unity should use to push the textures we want to upload. These settings can be tweaked under <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Quality</code></strong> | <strong class="userinput"><code>Other</code></strong> and are named <strong class="userinput"><code>Async Upload Time Slice</code></strong> and <strong class="userinput"><code>Async Upload Buffer Size</code></strong>, respectively. We should set the <strong class="userinput"><code>Async Upload Time Slice</code></strong> value to the maximum number of milliseconds we want Unity to spend on Asynchronous Texture Uploads on the render thread. It might be wise to set the <strong class="userinput"><code>Async Upload Buffer Size</code></strong> value to the largest texture file we might need to use, plus a little extra buffer if multiple fresh textures are needed in the same frame. The circular buffer that texture data is copied into will expand as needed, but this is often costly. Since we probably already know ahead of time how large we need that circular buffer to be, we might as well set it to the maximum expected size to avoid potential frame drops when it needs to resize the buffer.</p></div></div></div>