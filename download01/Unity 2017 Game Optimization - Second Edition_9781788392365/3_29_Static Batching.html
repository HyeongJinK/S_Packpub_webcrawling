<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec28"></a>Static Batching</h2></div></div><hr /></div><p>Unity offers a second batching mechanism through Static Batching. This batching feature is similar to Dynamic Batching in a couple of ways, such as which objects are batched is determined at runtime based on what's visible to the Camera, and the contents of these batches will vary from frame to frame. However, there is one very important difference: it only works on objects that are marked <strong class="userinput"><code>Static</code></strong>, hence the name <span class="emphasis"><em>Static</em></span> Batching.</p><p>The Static Batching system has its own set of requirements:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">As the name implies, the meshes must be flagged as <strong class="userinput"><code>Static</code></strong> (specifically, <strong class="userinput"><code>Batching Static</code></strong>)</li><li style="list-style-type: disc">Additional memory must be set aside for each mesh being statically batched</li><li style="list-style-type: disc">There is an upper limit on the number of vertices that can be combined in a static batch that varies per Graphics API and platform, which is around 32k-64k vertices (check out the documentation/aforementioned blog post for specifics)</li><li style="list-style-type: disc">The mesh instances can come from any source mesh, but they must share the same Material reference</li></ul></div><p>Let's cover some of these requirements in more detail.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec26"></a>The Static flag</h3></div></div></div><p>Static Batching can only be applied to objects with the <strong class="userinput"><code>static</code></strong> flag enabled or, more specifically, the <strong class="userinput"><code>Batching Static</code></strong> subflag (these subflags are known as <strong class="userinput"><code>StaticEditorFlags</code></strong>). Clicking on the small down-pointing arrow next to the <strong class="userinput"><code>Static</code></strong> option for a <code class="literal">GameObject</code> will reveal a dropdown of the <strong class="userinput"><code>StaticEditorFlags</code></strong>, which can alter the object's behavior for various <strong class="userinput"><code>Static</code></strong> processes.</p><p>An obvious side effect of this is that the object's transform cannot be changed, and, hence, any object wishing to make use of Static Batching cannot be moved, rotated, or scaled in any way.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"></a>Memory requirements</h3></div></div></div><p>The additional memory requirement for Static Batching will vary, depending on the amount of replication occurring within the batched meshes. Static Batching works by copying the data for all flagged and visible meshes into a single, large mesh data buffer, and passing it into the Rendering Pipeline through a single Draw Call, while ignoring the original mesh. If all of the meshes being statically batched are unique, then this would cost us no additional memory usage compared to rendering the objects normally, as the same amount of memory space is required to store the meshes.</p><p>However, since the data is effectively copied, these statically batched duplicates cost us additional memory equal to the number of meshes, multiplied by the size of the original mesh. Ordinarily, rendering one, ten, or a million clones of the same object costs us the same amount of memory, because they're all referencing the same mesh data. The only difference between objects in this case is the transform of each object. However, because Static Batching needs to copy the data into a large buffer, this referencing is lost, since each duplicate of the original mesh is copied into the buffer with a unique set of data with a hardcoded transform baked into the vertex positions.</p><p>Therefore, using Static Batching to render 1,000 identical tree objects will cost us 1,000 times more memory than rendering the same trees without Static Batching. This causes some significant memory consumption and performance issues if Static Batching is not used wisely.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec28"></a>Material references</h3></div></div></div><p>We are already aware that sharing Material references is a means of reducing Render State changes, so this requirement is fairly obvious. In addition, sometimes, we statically batch meshes that require multiple Materials. In this case, all meshes using a different Material will be grouped together in their own static batch and for each unique Material being used.</p><p>The downside to this requirement is that, at best, Static Batching can only render all of the static meshes using a number of Draw Calls equal to the number of Materials they need.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec29"></a>Static Batching caveats</h3></div></div></div><p>The Static Batching system has some additional drawbacks. Owing to how it approaches the batching solution, by combining meshes into a single greater mesh, the Static Batching system has a few caveats that we need to be aware of. These concerns range from minor inconveniences to major drawbacks, depending on the Scene:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Draw Call savings are not immediately visible from the <strong class="userinput"><code>Stats</code></strong> window until runtime</li><li style="list-style-type: disc">Objects marked <strong class="userinput"><code>Batching Static</code></strong> introduced in the Scene at runtime will not be automatically included in Static Batching</li></ul></div><p>Let's explore these problems in a little more detail.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec21"></a>Edit Mode debugging of Static Batching</h4></div></div></div><p>Trying to determine the overall effect that Static Batching will have on our Scene can be a little tricky since nothing is being Statically Batched while in <strong class="userinput"><code>Edit Mode</code></strong>. All of the magic happens during runtime, which can make it difficult to determine what benefits Static Batching would provide without manual testing. We should use the Frame Debugger to verify that our static batches are being properly generated, and that they contain the expected objects.</p><p>This can be especially problematic if we leave implementing this feature until late in the project lifecycle, where we can spend a lot of time launching, tweaking, and relaunching our Scene to ensure that we're getting the Draw Call savings we're expecting. Consequently, it is best to start working on Static Batching optimization early in the process of building a new Scene.</p><p>It goes without saying that static batch creation work is not completely trivial, and it may also massively inflate Scene initialization time if there are many batches to create and/or many large objects to batch.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec22"></a>Instantiating static meshes at runtime</h4></div></div></div><p>Any new objects we add into the Scene at runtime will not be automatically combined into any existing batch by the Static Batching system, even if they were marked as <strong class="userinput"><code>Batching Static</code></strong>. To do so would cause an enormous runtime overhead between recalculating the mesh and synchronizing with the Rendering Pipeline, so Unity does not even attempt to do it automatically.</p><p>For the most part, we should try to keep any meshes we want to be statically batched present in the original Scene file. However, if dynamic instantiation is necessary, or we are making use of additive Scene loading, then we can control static batch eligibility with the <code class="literal">StaticBatchUtility.Combine()</code> method. This utility method has two overloads: either we provide a root <code class="literal">GameObject</code>, in which case all child <code class="literal">GameObjects</code> with meshes will be turned into new static batch groups (multiple could be created if they share multiple Materials) or we provide a list of <code class="literal">GameObjects</code> and a root <code class="literal">GameObject</code>, and it will automatically attach them as children to the root and generate new static batch groups in the same manner.</p><p>We should profile our usage of this function, as it can be quite an expensive operation if there are many vertices to combine. It will also not combine the given meshes with any preexisting statically batched groups, even if they share the same Material. So we will not be able to save Draw Calls by instantiating or additively loading <strong class="userinput"><code>Static</code></strong> meshes that use the same Material as other statically batched groups already present in the Scene (it can only combine with meshes it was grouped with in the <code class="literal">Combine()</code> call).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip46"></a>Note</h3><p>Note that if any of the <code class="literal">GameObjects</code> we batch with the <code class="literal">StaticBatchUtility.Combine()</code> method are not marked as <strong class="userinput"><code>Static</code></strong> before batching, the <code class="literal">GameObjects</code> will remain non-<strong class="userinput"><code>Static</code></strong>, but the mesh itself will be <strong class="userinput"><code>Static</code></strong>. This means that we could accidentally move the <code class="literal">GameObject</code>, its <code class="literal">Collider</code> Component, and any other important objects, but the mesh will remain in the same location. Be careful about accidentally mixing <strong class="userinput"><code>Static</code></strong> and non-<strong class="userinput"><code>Static</code></strong> states in statically batched objects.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec30"></a>Static Batching summary</h3></div></div></div><p>Static Batching is a powerful, but dangerous tool. If we don't use it wisely, we can very easily inflict enormous performance losses via memory consumption (potentially leading to application crashes) and rendering costs on our application. It also takes a good amount of manual tweaking and configuration to ensure that batches are being properly generated, and that we aren't accidentally introducing any unintended side effects of using various <strong class="userinput"><code>Static</code></strong> flags. However, it does have a significant advantage in that it can be used on meshes of different shapes and enormous sizes, which Dynamic Batching cannot provide.</p></div></div>