<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec46"></a>Code compilation</h2></div></div><hr /></div><p>When we make changes to our C# code, it is automatically compiled when we switch back from our favorite IDE (which is typically either MonoDevelop or the much more feature-rich Visual Studio) to the Unity Editor. However, the C# code is not converted directly into Machine Code, as we would expect static compilers to do if we are using languages such as C++.</p><p>Instead, the code is converted into an intermediate stage called <span class="strong"><strong>Common Intermediate Language</strong></span> (<span class="strong"><strong>CIL</strong></span>), which is an abstraction above Native Code. This is how .NET can support multiple languages--each uses a different compiler, but they're all converted into CIL, so the output is effectively the same regardless of the language that we pick. CIL is similar to Java bytecode, upon which it is based, and the CIL code is entirely useless on its own, as CPUs have no idea how to run the instructions defined in this language.</p><p>At runtime, this intermediate code is run through the Mono <span class="strong"><strong>Virtual Machine</strong></span> (<span class="strong"><strong>VM</strong></span>), which is an infrastructure element that allows the same code to run against multiple platforms without the need to change the code itself. This is an implementation of the .NET <span class="strong"><strong>Common Language Runtime</strong></span> (<span class="strong"><strong>CLR</strong></span>). If we're running on iOS, we run on the iOS-based Virtual Machine infrastructure, and if we're running on Linux, then we simply use a different one that is better suited for Linux. This is how Unity allows us to write code once, and it works magically on multiple platforms.</p><p>Within the CLR, the intermediate CIL code will actually be compiled into Native Code on demand. This immediate Native compilation can be accomplished either by an <span class="strong"><strong>Ahead-Of-Time</strong></span> (<span class="strong"><strong>AOT</strong></span>) or <span class="strong"><strong>Just-In-Time</strong></span> (<span class="strong"><strong>JIT</strong></span>) compiler. Which one is used will depend on the platform that is being targeted. These compilers allow code segments to be compiled into Native Code, allowing the platform's architecture to complete the written instructions without having to write them ourselves. The main difference between the two compiler types is when the code is compiled.</p><p>AOT compilation is the typical behavior for code compilation and happens early (<span class="emphasis"><em>ahead of time</em></span>) either during the build process or in some cases during app initialization. In either case, the code has been precompiled and no further runtime costs are inflicted due to dynamic compilation since there are always Machine Code instructions available whenever the CPU needs them.</p><p>JIT compilation happens dynamically at runtime in a separate thread and begins just prior to execution (<span class="emphasis"><em>just in time</em></span> for execution). Often, this dynamic compilation causes the first invocation of a piece of code to run a little (or a lot) more slowly, because the code must finish compiling before it can be executed. However, from that point forward, whenever the same code block is executed, there is no need for recompilation, and the instructions run through the previously compiled Native Code.</p><p>A common adage in software development is that 90 percent of the work is being done by only 10 percent of the code. This generally means that JIT compilation turns out to be a net positive on performance than if we simply tried to interpret the CIL code directly. However, because the JIT compiler must compile code quickly, it is not able to make use of many optimization techniques that static AOT compilers are able to exploit.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note112"></a>Note</h3><p>Not all platforms support JIT compilation, but some scripting functionalities are not available when using AOT. Unity provides a complete list of these restrictions at <a class="ulink" href="https://docs.unity3d.com/Manual/ScriptingRestrictions.html" target="_blank">https://docs.unity3d.com/Manual/ScriptingRestrictions.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec100"></a>IL2CPP</h3></div></div></div><p>A few years ago, Unity Technologies was faced with a choice to either continue to support the Mono platform, which Unity was finding more and more difficult to keep up with, or implement their own scripting backend. They chose the latter option and multiple platforms now support <span class="strong"><strong>IL2CPP</strong></span>, which is short for  <span class="strong"><strong>Intermediate Language to C++</strong></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note113"></a>Note</h3><p>The Unity Technologies' initial post about IL2CPP, the reasoning behind the decision, and its long-term benefits can be found at <a class="ulink" href="https://blogs.unity3d.com/2014/05/20/the-future-of-scripting-in-unity/" target="_blank">https://blogs.unity3d.com/2014/05/20/the-future-of-scripting-in-unity/</a>.</p></div><p>IL2CPP is a scripting backend designed to convert Mono's CIL output directly into Native C++ code. This leads to improved performance since the application will now be running Native Code. This ultimately gives Unity Technologies more control of runtime behavior since IL2CPP provides its own AOT compiler and VM, allowing custom improvements to subsystems such as the GC and compilation process. IL2CPP does not intend to completely replace the Mono platform, but it is an additional tool we can enable, which improves part of the functionality that Mono provides.</p><p>Note that IL2CPP is automatically enabled for iOS and WebGL projects. For other platforms that support it, IL2CPP can be enabled under <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Player</code></strong> | <strong class="userinput"><code>Configure</code></strong> | <strong class="userinput"><code>Scripting Backend</code></strong>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note114"></a>Note</h3><p>A list of platforms currently supporting IL2CPP can be found at <a class="ulink" href="https://docs.unity3d.com/Manual/IL2CPP.html" target="_blank">https://docs.unity3d.com/Manual/IL2CPP.html</a>.</p></div></div></div>