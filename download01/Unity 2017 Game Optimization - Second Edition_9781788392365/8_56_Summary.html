<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec50"></a>Summary</h2></div></div><hr /></div><p>We've covered a humongous amount of theory and language concepts in this chapter, which have hopefully shed some light on how the internals of the Unity Engine and C# language work. These tools try their best to spare us from the burden of complex memory management, but there is still a whole host of concerns we need to keep in mind as we develop our game. Between the compilation processes, multiple Memory Domains, the complexities of Value types versus Reference types, passing by value versus passing by reference, boxing, Object Pooling, and various quirks within the Unity API, you have a lot of things to worry about. However, with enough practice, you will learn to overcome them without needing to keep referring to giant tomes such as this!</p><p>This chapter effectively concludes all of the techniques we can bestow that explicitly aim to improve application performance. However, optimizing your workflow is also enormously beneficial. As mentioned previously, the one constant cost of performance optimization work is development time. However, if you can speed up our development working, saving some time during the more tedious parts of the job, then hopefully you can save yourself enough time to actually implement as many optimization techniques we've talked about through this entire book as you can. There are a lot of neat little nuances to the Unity Engine that aren't well known or clearly documented and that only become apparent through experience with the Engine or by involving ourselves in it's community. As such, the next chapter will be full of hints and tips for improving how to manage your project and Scenes more effectively and how to make the most of the Unity Editor.</p><p> </p></div>