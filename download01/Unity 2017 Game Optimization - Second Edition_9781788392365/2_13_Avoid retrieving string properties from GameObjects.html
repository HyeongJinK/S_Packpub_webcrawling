<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec13"></a>Avoid retrieving string properties from GameObjects</h2></div></div><hr /></div><p>Ordinarily, retrieving a <code class="literal">string</code> property from an object is the same as retrieving any other reference type property in C#; it should be acquired with no additional memory cost. However, retrieving <code class="literal">string</code> properties from <code class="literal">GameObjects</code> is another subtle way of accidentally crossing over the Native-Managed Bridge.</p><p>The two properties of <code class="literal">GameObject</code> affected by this behavior are <code class="literal">tag</code> and <code class="literal">name</code>. Therefore, it is unwise to use either properties during gameplay, and you should only use them in performance-inconsequential areas, such as Editor Scripts. However, the Tag System is commonly used for runtime identification of objects, which can make this a significant problem for some teams.</p><p>For example, the following code would cause an additional memory allocation during every iteration of the loop:</p><pre class="programlisting">for (int i = 0; i &lt; listOfObjects.Count; ++i) {
  if (listOfObjects[i].tag == "Player") {
    // do something with this object
  }
}</pre><p>It is often a better practice to identify objects by their Components and class types and to identify values that do not involve <code class="literal">string</code> objects, but sometimes we're forced into a corner. Maybe we didn't know any better when we started, we inherited someone else's codebase, or we're using it as a workaround for something. Let's assume that, for whatever reason, we're stuck with the Tag system, and we want to avoid the Native-Managed Bridge overhead cost.</p><p>Fortunately, the <code class="literal">tag</code> property is most often used in comparison situations, and <code class="literal">GameObject</code> provide the <code class="literal">CompareTag()</code> method which is an alternative way to compare <code class="literal">tag</code> properties, which avoids the Native-Managed Bridge entirely.</p><p>Let's perform a simple test to prove how this simple change can make all the difference in the world:</p><pre class="programlisting">void Update() {

  int numTests = 10000000;

  if (Input.GetKeyDown(KeyCode.Alpha1)) {
    for(int i = 0; i &lt; numTests; ++i) {
      if (gameObject.tag == "Player") {
        // do stuff
      }
    }
  }

  if (Input.GetKeyDown(KeyCode.Alpha2)) {
    for(int i = 0; i &lt; numTests; ++i) {
      if (gameObject.CompareTag ("Player")) {
        // do stuff
      }
    }
  }
}</pre><p>We can execute these tests by pressing the <span class="emphasis"><em>1</em></span> and <span class="emphasis"><em>2</em></span> keys to trigger the respective for loop. Here are the results:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/296b4724-5d4a-4219-be5e-60264f38acc4.png" /></div><p>Looking at the Breakdown view for each spike, we can see two completely different outcomes:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/f238c18a-fc53-419f-9c78-5e88b9dd2f9a.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Note</h3><p>It's worth noting how the two spikes in the Timeline View appear relatively the same height, and yet one operation took twice as long as the other. The Profiler doesn’t have the vertical resolution necessary to generate relatively accurate peaks when we go beyond the 15FPS marker. Both would result in a poor gameplay experience anyway, so the accuracy doesn’t really matter.</p></div><p>Retrieving the <code class="literal">tag</code> property 10 million times (way more than makes sense in reality, but this is useful for comparison) results in about 400 Megabytes of memory being allocated just for <code class="literal">string</code> objects alone. We can see this memory allocation happening in the spike within the <strong class="userinput"><code>GC Allocated</code></strong> element in the Memory Area of the Timeline View. In addition, this process takes around 2,000 milliseconds to process, where another 400 milliseconds are spent on garbage collection once the <code class="literal">string</code> objects are no longer needed.</p><p>Meanwhile, using <code class="literal">CompareTag()</code> 10 million times costs around 1,000 milliseconds to process and causes no memory allocations, and hence no garbage collection. This is made apparent from the lack of spike in the <strong class="userinput"><code>GC Allocated</code></strong> element in the Memory Area. This should make it abundantly clear that we must avoid accessing the <code class="literal">name</code> and <code class="literal">tag</code> properties whenever possible. If Tag comparison becomes necessary, then we should make use of <code class="literal">CompareTag()</code>. Unfortunately, there is no equivalent for the <code class="literal">name</code> property, so we should stick to using Tags where possible.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Note</h3><p>Note that passing in a <code class="literal">string</code> literal, such as <code class="literal">"Player"</code>, into <code class="literal">CompareTag()</code> does not result in a runtime memory allocation, since the application allocates hardcoded strings like this during initialization and merely references them at runtime.</p></div></div>