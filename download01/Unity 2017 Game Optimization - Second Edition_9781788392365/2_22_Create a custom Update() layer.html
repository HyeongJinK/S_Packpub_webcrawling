<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec22"></a>Create a custom Update() layer</h2></div></div><hr /></div><p><span>Earl</span>ier in this chapter, in the </p><div class="blockquote"><blockquote class="blockquote"><p>Update, Coroutines and InvokeRepeating</p></blockquote></div><p> section, we discussed the relative pros and cons of using these Unity Engine features as a means of avoiding excessive CPU workload during most of our frames. Regardless of which of these approaches we might adopt, there is an additional risk of having lots of <code class="literal">MonoBehaviours</code> written to periodically call some function, which is having too many methods triggering in the same frame simultaneously.</p><p>Imagine thousands of <code class="literal">MonoBehaviours</code> that initialized together at the start of a Scene, each starting a Coroutine at the same time that will process their AI tasks every 500 milliseconds. It is highly likely that they would all trigger within the same frame, causing a huge spike in its CPU usage for a moment, which settles down temporarily and then spikes again a few moments later when the next round of AI processing is due. Ideally, we would want to spread these invocations out over time.</p><p>The following are the possible solutions to this problem:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Generating a random time to wait each time the timer expires or Coroutine triggers</li><li style="list-style-type: disc">Spread out Coroutine initialization so that only a handful of them are started at each frame</li><li style="list-style-type: disc">Pass the responsibility of calling updates to some God Class that places a limit on the number of invocations that occur each frame</li></ul></div><p>The first two options are appealing since they’re relatively simple and we know that Coroutines can potentially save us a lot of unnecessary overhead. However, as we discussed, there are many dangers and unexpected side effects associated with such drastic design changes.</p><p>A potentially better approach to optimize updates is to not use <code class="literal">Update()</code> at all, or more accurately, to use it only once. When Unity calls <code class="literal">Update()</code>, and in fact, any of its callbacks, it crosses the aforementioned Native-Managed Bridge, which can be a costly task. In other words, the processing cost of executing 1,000 separate <code class="literal">Update()</code> callbacks will be more expensive than executing one <code class="literal">Update()</code> callback, which calls into 1,000 regular functions. As we witnessed in the </p><div class="blockquote"><blockquote class="blockquote"><p>Remove empty callback definitions</p></blockquote></div><p> section, calling <code class="literal">Update()</code> thousands of times is not a trivial amount of work for the CPU to undertake, primarily because of the Bridge. We can, therefore, minimize how often Unity needs to cross the Bridge by having a God Class <code class="literal">MonoBehaviour</code> use its own <code class="literal">Update()</code> callback to call our own custom update-style system used by our custom Components.</p><p>In fact, many Unity developers prefer implementing this design right from the start of their projects, as it gives them finer control over when and how updates propagate throughout the system; this can be used for things such as menu pausing, cool time manipulation effects, or prioritizing important tasks and/or suspending low priority tasks if we detect that we’re about to reach our CPU budget for the current frame.</p><p>All objects wanting to integrate with such a system must have a common entry point. We can achieve this through an Interface Class with the <code class="literal">interface</code> keyword. Interface Classes essentially set up a contract whereby any class that implements the Interface Class Class must provide a specific series of methods. In other words, if we know the object implements an Interface Class, then we can be certain about what methods are available. In C#, classes can only derive from a single base class, but they can implement any number of Interface Classes (this avoids the <span class="emphasis"><em>deadly diamond of death</em></span> problem that C++ programmers will be familiar with).</p><p>The following Interface Class definition will suffice, which only requires the implementing class to define a single method called <code class="literal">OnUpdate()</code>:</p><pre class="programlisting">public interface IUpdateable {
  void OnUpdate(float dt);
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip37"></a>Note</h3><p>It’s common practice to start an Interface Class definition with a capital ‘I’ to make it clear that it is an Interface Class we’re dealing with. The beauty of Interface Classes is that they improve the decoupling of our codebase, allowing huge subsystems to be replaced, and as long as the Interface Class is adhered to, we will have greater confidence that it will continue to function as intended.</p></div><p>Next, we'll define a custom <code class="literal">MonoBehaviour</code> type which implements this Interface Class:</p><pre class="programlisting">public class UpdateableComponent : MonoBehaviour, IUpdateable {
  public virtual void OnUpdate(float dt) {}
}</pre><p>Note that we're naming the method <code class="literal">OnUpdate()</code> rather than <code class="literal">Update()</code>. We're defining a custom version of the same concept, but we want to avoid name collisions with the built-in <code class="literal">Update()</code> callback.</p><p>The <code class="literal">OnUpdate()</code> method of the <code class="literal">UpdateableComponent</code> class retrieves the current delta time (<code class="literal">dt</code>), which spares us from a bunch of unnecessary <code class="literal">Time.deltaTime</code> calls, which are commonly used in <code class="literal">Update()</code> callbacks. We've also made the function <code class="literal">virtual</code> to allow derived classes to customize it.</p><p>This function will never be called as it's currently being written. Unity automatically grabs and invokes methods defined with the <code class="literal">Update()</code> name, but has no concept of our <code class="literal">OnUpdate()</code> function, so we will need to implement something that will call this method when the time is appropriate. For example, some kind of <code class="literal">GameLogic</code> God Class could be used for this purpose.</p><p>During the initialization of this Component, we should do something to notify our <code class="literal">GameLogic</code> object of both its existence and its destruction so that it knows when to start and stop calling its <code class="literal">OnUpdate()</code> function.</p><p>In the following example, we will assume that our <code class="literal">GameLogic</code> class is a <code class="literal">SingletonComponent</code>, as defined earlier in the </p><div class="blockquote"><blockquote class="blockquote"><p>Singleton Components</p></blockquote></div><p> section, and has appropriate <code class="literal">static</code> functions defined for registration and deregistration. Bear in mind that it could just as easily use the aforementioned <code class="literal">MessagingSystem</code> to notify the <code class="literal">GameLogic</code> of its creation/destruction.</p><p>For <code class="literal">MonoBehaviours</code> to hook into this system, the most appropriate place is within their <code class="literal">Start()</code> and <code class="literal">OnDestroy()</code> callbacks:</p><pre class="programlisting">void Start() {
  GameLogic.Instance.RegisterUpdateableObject(this);
}

void OnDestroy() {
  if (GameLogic.Instance.IsAlive) {
    GameLogic.Instance.DeregisterUpdateableObject(this);
  }
}</pre><p>It is best to use the <code class="literal">Start()</code> method for the task of registration, since using <code class="literal">Start()</code> means that we can be certain all other pre-existing Components will have at least had their <code class="literal">Awake()</code> methods called prior to this moment. This way, any critical initialization work will have already been done on the object before we start invoking updates on it.</p><p>Note that because we're using <code class="literal">Start()</code> in a <code class="literal">MonoBehaviour</code> base class, if we define a <code class="literal">Start()</code> method in a derived class, it will effectively override the base class definition, and Unity will grab the derived <code class="literal">Start()</code> method as a callback instead. It would, therefore, be wise to implement a virtual <code class="literal">Initialize()</code> method so that derived classes can override it to customize initialization behavior without interfering with the base class's task of notifying the <code class="literal">GameLogic</code> object of our Component's existence.</p><p>The following code provides an example of how we might implement a virtual <code class="literal">Initialize()</code> method.</p><pre class="programlisting">void Start() {
  GameLogic.Instance.RegisterUpdateableObject(this);
  Initialize();
}

protected virtual void Initialize() {
  // derived classes should override this method for initialization code, and NOT reimplement Start()
}</pre><p>Finally, we will need to implement the <code class="literal">GameLogic</code> class. The implementation is effectively the same whether it is a <code class="literal">SingletonComponent</code> or a <code class="literal">MonoBehaviour</code>, and whether or not it uses the <code class="literal">MessagingSystem</code>. Either way, our <code class="literal">UpdateableComponent</code> class must register and deregister as <code class="literal">IUpdateable</code> objects, and the <code class="literal">GameLogic</code> class must use its own <code class="literal">Update()</code> callback to iterate through every registered object and call their <code class="literal">OnUpdate()</code> function.</p><p>Here is the definition for our <code class="literal">GameLogic</code> class:</p><pre class="programlisting">public class GameLogicSingletonComponent : SingletonComponent&lt;GameLogicSingletonComponent&gt; {
  public static GameLogicSingletonComponent Instance {
    get { return ((GameLogicSingletonComponent)_Instance); }
    set { _Instance = value; }
  }

  List&lt;IUpdateable&gt; _updateableObjects = new List&lt;IUpdateable&gt;();

  public void RegisterUpdateableObject(IUpdateable obj) {
    if (!_updateableObjects.Contains(obj)) {
      _updateableObjects.Add(obj);
    }
  }

  public void DeregisterUpdateableObject(IUpdateable obj) {
    if (_updateableObjects.Contains(obj)) {
      _updateableObjects.Remove(obj);
    }
  } 

  void Update()
  {
    float dt = Time.deltaTime;
    for (int i = 0; i &lt; _updateableObjects.Count; ++i) {
      _updateableObjects[i].OnUpdate(dt);
    }
  }
}</pre><p>If we make sure that all of our custom Components inherit from the <code class="literal">UpdateableComponent</code> class, then we've effectively replaced </p><div class="blockquote"><blockquote class="blockquote"><p>N</p></blockquote></div><p> invocations of the <code class="literal">Update()</code> callback with just one <code class="literal">Update()</code> callback, plus </p><div class="blockquote"><blockquote class="blockquote"><p>N</p></blockquote></div><p> virtual function calls. This can save us a large amount of performance overhead because even though we're calling virtual functions (which cost a small overhead more than a non-virtual function call because it needs to redirect the call to the correct place), we're still keeping the overwhelming majority of update behavior inside our Managed code and avoiding the Native-Managed Bridge as much as possible. This class can even be expanded to provide priority systems, to skip low-priority tasks if it detects that the current frame has taken too long, and many other possibilities.</p><p>Depending on how deep you already are into your current project, such changes can be incredibly daunting, time-consuming, and likely to introduce a lot of bugs as subsystems are updated to make use of a completely different set of dependencies. However, the benefits can outweigh the risks if time is on your side. It would be wise to do some testing on a group of objects in a Scene that is similarly designed to your current Scene files to verify that the benefits outweigh the costs.</p></div>