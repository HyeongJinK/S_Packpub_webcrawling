<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>Disable unused scripts and objects</h2></div></div><hr /></div><p><span>Scen</span>es can get pretty busy sometimes, especially when we're building large, open worlds. The more objects invoking code in an <code class="literal">Update()</code> callback, the worse things it will scale and the slower the game becomes. However, much of what is being processed may be completely unnecessary if it is outside of the player's view or simply too far away to matter. This may not be a possibility in large city-building simulation games, where the entire simulation must be processed at all times, but it is often possible in first-person and racing games since the player is wandering around a large expansive area, where non-visible objects can be temporarily disabled without having any noticeable effect on gameplay.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Disabling objects by visibility</h3></div></div></div><p><span>Some</span>times, we may want Components or <code class="literal">GameObjects</code> to be disabled when they're not visible. Unity comes with built-in rendering features to avoid rendering objects that are not visible to the player’s Camera view (through a technique known as <span class="emphasis"><em>Frustum Culling</em></span>, which is an automatic process) and to avoid rendering objects that are hidden behind other objects (occlusion culling, which will be discussed in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Dynamic Graphics</em></span>), but these are only rendering optimizations. It does not affect Components that perform tasks on the CPU, such as AI scripts, User Interface, and gameplay logic. We must control that behavior ourselves.</p><p>A good solution to this problem is using the <code class="literal">OnBecameVisible()</code> and <code class="literal">OnBecameInvisible()</code> callbacks. As the names imply, these callback methods are invoked when a renderable object has become visible or invisible with respect to any Cameras in our Scene. In addition, when there are multiple Cameras in a Scene (for example, a local multiplayer game), the callbacks are only invoked if the object becomes visible to any one Camera and becomes invisible to all Cameras. This means that the aforementioned callbacks will be called at exactly the right times we expect; if nobody can see it, <code class="literal">OnBecameInvisible()</code> gets called, and if at least one player can see it, <code class="literal">OnBecameVisible()</code> gets called.</p><p>Since the visibility callbacks must communicate with the Rendering Pipeline, the <code class="literal">GameObject</code> must have a renderable Component attached, such as a <code class="literal">MeshRenderer</code> or <code class="literal">SkinnedMeshRenderer</code>. We must ensure that the Components we want to receive the visibility callbacks from are also attached to the same <code class="literal">GameObject</code> as the renderable object and are not a parent or child <code class="literal">GameObject</code>, otherwise they won't be invoked.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip35"></a>Note</h3><p>Note that Unity also counts the hidden Camera of the <strong class="userinput"><code>Scene</code></strong> window toward the <code class="literal">OnBecameVisible()</code> and <code class="literal">OnBecameInvisible()</code> callbacks. If we find that these methods are not being invoked properly during Play Mode testing, ensure that you turn the <strong class="userinput"><code>Scene </code></strong>window Camera away from everything or disable the <strong class="userinput"><code>Scene</code></strong> window entirely.</p></div><p>To enable/disable individual Components with the visibility callbacks, we can add the following methods:</p><pre class="programlisting">void OnBecameVisible() { enabled = true; }
void OnBecameInvisible() { enabled = false; }</pre><p>Also, to enable/disable the entire <code class="literal">GameObject</code> the Component is attached to, we can implement the methods this way instead:</p><pre class="programlisting">void OnBecameVisible() { gameObject.SetActive(true); }
void OnBecameInvisible() { gameObject.SetActive(false); }</pre><p>Although, be warned that disabling the <code class="literal">GameObject</code> containing the renderable object, or one of its parents, will make it impossible for <code class="literal">OnBecameVisible()</code> to be called since there’s now no graphical representation for the Camera to see and trigger the callback with. We should place the Component on a child <code class="literal">GameObject</code>, and have the script disable that instead, leaving the renderable object always visible (or find another way to re-enable it later).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec18"></a>Disabling objects by distance</h3></div></div></div><p><span>In o</span>ther situations, we may want Components or <code class="literal">GameObjects</code> to be disabled after they are enough far away from the player such that they may be barely visible, but too far away to matter. A good candidate for this type of activity is roaming AI creatures that we want to see at a distance, but where we don't need it to process anything, and it can sit idle until we get closer.</p><p>The following code is a simple Coroutine that periodically checks the total distance from a given target object and disables itself if it strays too far away from it:</p><pre class="programlisting">[SerializeField] GameObject _target;
[SerializeField] float _maxDistance;
[SerializeField] int _coroutineFrameDelay;

void Start() {
  StartCoroutine(DisableAtADistance());
}

IEnumerator DisableAtADistance() {
  while(true) {
    float distSqrd = (transform.position - _target.transform.position).sqrMagnitude;
    if (distSqrd &lt; _maxDistance * _maxDistance) {
      enabled = true;
    } else {
      enabled = false;
    }

    for (int i = 0; i &lt; _coroutineFrameDelay; ++i) {
      yield return new WaitForEndOfFrame();
    }
  }
}</pre><p>We should assign the player's character object (or whatever object we want it to compare with) to the <code class="literal">_target</code> field in the <strong class="userinput"><code>Inspector</code></strong> window, define the maximum distance in <code class="literal">_maxDistance</code>, and modify the frequency with which the Coroutine is invoked using the <code class="literal">_coroutineFrameDelay</code> field. Any time the object goes further than <code class="literal">_maxDistance</code> distance away from the object assigned to <code class="literal">_target</code>, it will be disabled. It will be re-enabled if it returns within that distance.</p><p>A subtle performance-enhancing feature of this implementation is comparing against distance-squared instead of the raw distance. This leads us conveniently to our next section.</p></div></div>