<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec8"></a>Remove empty callback definitions</h2></div></div><hr /></div><p>The primary means of scripting in Unity is to write callback functions in classes derived from <code class="literal">MonoBehaviour</code>, which we know Unity will call when necessary. Perhaps the four most commonly used callbacks are <code class="literal">Awake()</code>, <code class="literal">Start()</code>, <code class="literal">Update()</code>, and <code class="literal">FixedUpdate()</code>.</p><p><code class="literal">Awake()</code> is called the moment a <code class="literal">MonoBehaviour</code> is first created, whether this occurs during Scene initialization or when a new <code class="literal">GameObject</code> containing the <code class="literal">MonoBehaviour</code> is instantiated at runtime from a Prefab. <code class="literal">Start()</code> will be called shortly after <code class="literal">Awake()</code> but before its first <code class="literal">Update()</code>. During Scene initialization, every <code class="literal">MonoBehaviour</code> Component's <code class="literal">Awake()</code> callback will be called before any of their <code class="literal">Start()</code> callbacks are.</p><p>After this, <code class="literal">Update()</code> will be called repeatedly, each time the Rendering Pipeline presents a new image. <code class="literal">Update()</code> will continue to be called provided the <code class="literal">MonoBehaviour</code> is still present in the Scene, it is still enabled, and its parent <code class="literal">GameObject</code> is active.</p><p>Finally, <code class="literal">FixedUpdate()</code> is called just prior to when the Physics Engine updates. Fixed Updates are used whenever we want activity similar in behavior to <code class="literal">Update()</code> but that isn’t tied directly to the render frame rate and is called more consistently over time.</p><p>Refer to the following page in the Unity documentation for an accurate picture of when various Unity callbacks are called: <a class="ulink" href="https://docs.unity3d.com/Manual/ExecutionOrder.html" target="_blank">https://docs.unity3d.com/Manual/ExecutionOrder.html</a>.</p><p>Whenever a <code class="literal">MonoBehaviour</code> is first instantiated in our Scene, Unity will add any defined callbacks to a list of function pointers, which it will call at key moments. However, it is important to realize that Unity will hook into these callbacks even if the function body is empty. The core Unity Engine has no awareness that these function bodies may be empty and only knows that the method has been defined and, therefore, that it must acquire it and then call it when necessary. Consequently, if we leave empty definitions of these callbacks scattered throughout the codebase, then they will waste a small amount of CPU due to the overhead cost of the engine invoking them.</p><p>This can be a problem since any time we create a new <code class="literal">MonoBehaviour</code> script file in Unity, it will automatically generate two boilerplate callback stubs for us for <code class="literal">Start()</code> and <code class="literal">Update()</code>:</p><pre class="programlisting">// Use this for initialization
void Start () {

}

// Update is called once per-frame
void Update () {

}</pre><p>It can be easy to accidentally leave these empty definitions on scripts that don't actually need them. An empty <code class="literal">Start()</code> definition is liable to cause any object to initialize a little slower, for no good reason. This effect may not be particularly noticeable for a handful of <code class="literal">MonoBehaviours</code>, but as development on the project continues and we populate our scenes with thousands of custom <code class="literal">MonoBehaviours</code> with lots of empty <code class="literal">Start()</code> definitions, it could start to become a problem, causing slow Scene initialization and wasting CPU time whenever a new Prefab is created via <code class="literal">GameObject.Instantiate()</code>.</p><p>Such calls typically happen during key gameplay events; for instance, when two objects collide, we might spawn a Particle Effect, create some floating damage text, play a sound effect, and so on. This can be a critical moment for performance because we've suddenly requested that the CPU makes a lot of complicated changes, but with only a finite amount of time to complete them before the current frame ends. If this process takes too long, then we would experience a frame drop as the Rendering Pipeline isn't allowed to present a new frame until all of the <code class="literal">Update()</code> callbacks (counted across all <code class="literal">MonoBehaviours</code> in the Scene!) have finished. Ergo, a bunch of empty <code class="literal">Start()</code> definitions being called at this time is a needless waste and could potentially cut into our tight time-budget at a critical moment.</p><p>Meanwhile, if our Scene contains thousands of <code class="literal">MonoBehaviours</code> with these empty <code class="literal">Update()</code> definitions, then we would be wasting a lot of CPU cycles every frame, potentially causing havoc on our frame rate.</p><p>Let's prove all of this with a simple test. Our test Scene should have <code class="literal">GameObjects</code> with two types of Component, <code class="literal">EmptyClassComponent</code> with no methods defined at all and <code class="literal">EmptyCallbackComponent</code> with an empty <code class="literal">Update()</code> callback defined:</p><pre class="programlisting">public class EmptyClassComponent : MonoBehaviour {
}

public class EmptyCallbackComponent : MonoBehaviour {
  void Update () {}
}</pre><p>The following are the test results for 30,000 Components of each type. If we enable all <code class="literal">GameObjects</code> with attached <code class="literal">EmptyClassComponents</code> during runtime, then nothing interesting happens under the CPU Usage Area of the <strong class="userinput"><code>Profiler</code></strong>. There will be a small amount of background activity, but none of this activity will be caused by the <code class="literal">EmptyClassComponents</code>. However, as soon as we enable all objects with <code class="literal">EmptyCallbackComponent</code>, we will observe a huge increase in CPU usage:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/71791191-6c8c-4fb5-bd3e-d5587e773496.png" /></div><p>It’s hard to imagine a Scene with more than 30,000 objects in it, but keep in mind that <code class="literal">MonoBehaviours</code> contain the <code class="literal">Update()</code> callback, not <code class="literal">GameObjects</code>. A single <code class="literal">GameObject</code> can contain multiple <code class="literal">MonoBehaviours</code> at once, and each of their children can contain even more <code class="literal">MonoBehaviours</code>, and so on. A few thousand or even a hundred empty <code class="literal">Update()</code> callbacks will inflict a noticeable impact on frame rate budget, for zero potential gain. This is particularly common with Unity UI Components which tend to attach a lot of different Components in a very deep hierarchy.</p><p>The fix for this is simple: delete the empty callback definitions. Unity will have nothing to hook into, and nothing will be called. Finding such empty definitions in an expansive codebase may be difficult, but if we use some basic regular expressions (known as <span class="emphasis"><em>regex</em></span>), we should be able to find what we're looking for relatively easily.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip21"></a>Note</h3><p>All common code-editing tools for Unity, such as MonoDevelop, Visual Studio, and even Notepad++, provide a way to perform a regex-based search on the entire codebase. Check out the tool's documentation for more information, since the method can vary greatly depending on the tool and its version.</p></div><p>The following regex search should find any empty <code class="literal">Update()</code> definitions in our code:</p><pre class="programlisting">void\s*Update\s*?\(\s*?\)\s*?\n*?\{\n*?\s*?\}</pre><p>This regex checks for a standard method definition of the <code class="literal">Update()</code> callback, while including any surplus whitespace and newline characters that can be distributed throughout the method definition.</p><p>Naturally, all of the above is also true for the non-boilerplate Unity callbacks, such as <code class="literal">OnGUI()</code>, <code class="literal">OnEnable()</code>, <code class="literal">OnDestroy()</code>, and <code class="literal">LateUpdate()</code>. The only difference is that only <code class="literal">Start()</code> and <code class="literal">Update()</code> are defined automatically in a new script. Check out the <code class="literal">MonoBehaviour</code> Unity Documentation page for a complete list of these callbacks at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a>.</p><p>It might also seem unlikely that someone generated so many empty versions of these callbacks in our codebase, but never say never. For example, if we use a common base class <code class="literal">MonoBehaviour</code> throughout all of our custom Components, then a single empty callback definition in that base class will permeate the entire game, which can cost us dearly. Be particularly careful of the <code class="literal">OnGUI()</code> method, as it can be invoked multiple times within the same frame or UI event.</p><p>Perhaps the most common source of performance problems in Unity scripting is to misuse the <code class="literal">Update()</code> callback by doing one or more of the following things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Repeatedly recalculating a value that rarely or never changes</li><li style="list-style-type: disc">Having too many Components perform work for a result which could be shared</li><li style="list-style-type: disc">Performing work far more often than is necessary</li></ul></div><p>It’s worth getting into the habit of remembering that literally every single line of code we write in an <code class="literal">Update()</code> callback, and in functions called by those callbacks, will eat into our frame rate budget. To hit 60 fps, we have 16.667 milliseconds to complete all of the work in all of our <code class="literal">Update()</code> callbacks, every frame. This seems like plenty of time when we start prototyping, but somewhere in the middle of development, we will probably start noticing things getting slower and less responsive because we’ve gradually been eating away at that budget, due to an unchecked desire to cram more stuff into our project.</p><p>Let’s cover some tips that directly address these problems.</p></div>