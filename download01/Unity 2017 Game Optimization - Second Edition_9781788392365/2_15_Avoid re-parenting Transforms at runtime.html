<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec15"></a>Avoid re-parenting Transforms at runtime</h2></div></div><hr /></div><p>In earlier versions of Unity (version 5.3 and older), the references to <code class="literal">Transform</code> Components would be laid out in memory in a generally random order. This meant that iteration over multiple <code class="literal">Transforms</code> was fairly slow due to the likelihood of cache-misses. The upside was that re-parenting a <code class="literal">GameObject</code> to another one wouldn't really cause a significant performance hit since the <code class="literal">Transforms</code> operated a lot like a Heap data structure which tend to be relatively fast at insertion and deletion. This behaviour wasn't something we could control, and so we simply lived with it.</p><p>However, since Unity 5.4 and beyond, the <code class="literal">Transform</code> Component's memory layout has changed significantly. Since then, a <code class="literal">Transform</code> Component's parent-child relationships have operated more like dynamic arrays, whereby Unity attempts to store all <code class="literal">Transforms</code> that share the same parent sequentially in memory inside a pre-allocated memory buffer and are sorted by their depth in the <strong class="userinput"><code>Hierarchy</code></strong> window beneath the parent. This data structure allows for much, much faster iteration across the entire group, which is particularly beneficial to multiple subsystems like physics and animation. The downside of this change is that if we re-parent a <code class="literal">GameObject</code> to another one, the parent must fit the new child within its pre-allocated memory buffer as well as sort all of these <code class="literal">Transforms</code> based on the new depth. Also, if the parent has not pre-allocated enough space to fit the new child, then it must expand its buffer to be able to fit the new child, and all of it's children, in depth-first order. This could take some time to complete for deep and complex <code class="literal">GameObject</code> structures.</p><p>When we instantiate a new <code class="literal">GameObject</code> through <code class="literal">GameObject.Instantiate()</code>, one of its arguments is the <code class="literal">Transform</code> we wish to parent the <code class="literal">GameObject</code> to, which is <code class="literal">null</code> by default, and which would place the <code class="literal">Transform</code> at the root of the  <strong class="userinput"><code>Hierarchy</code></strong> window. All <code class="literal">Transforms</code> at the root of the <strong class="userinput"><code>Hierarchy</code></strong> window need to allocate a buffer to store its current children as well as those that might be added later (child Transforms do not need to do this). But, if we then re-parent the Transform to another one immediately after instantiation, then it discards the buffer we just allocated! To avoid this, we should provide the parent <code class="literal">Transform</code> argument into the <code class="literal">GameObject.Instantiate()</code> call, which skips this buffer allocation step.</p><p>Another way to reduce the costs of this process is to make root <code class="literal">Transform</code> pre-allocate a larger buffer before we need it so that we don't need to both expand and re-parent another <code class="literal">GameObject</code> into the buffer in the same frame. This can be accomplished by modifying a <code class="literal">Transform</code> Component's <code class="literal">hierarchyCapacity</code> property. If we can estimate the number of child <code class="literal">Transforms</code> the parent will contain, then we can save a lot of unnecessary memory allocations.</p></div>