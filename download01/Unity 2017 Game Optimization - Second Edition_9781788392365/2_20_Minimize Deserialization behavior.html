<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec20"></a>Minimize Deserialization behavior</h2></div></div><hr /></div><p>Unity's Serialization system is mainly used for Scenes, Prefabs, ScriptableObjects and various Asset types (which tend to derive from ScriptableObject). When one of these object types is saved to disk, it is converted into a text file using the <span class="strong"><strong>Yet Another Markup Language</strong></span> (<span class="strong"><strong>YAML</strong></span>) format, which can be deserialized back into the original object type at a later time. All <code class="literal">GameObjects</code> and their properties get serialized when a Prefab or Scene is serialized, including <code class="literal">private</code> and <code class="literal">protected</code> fields, all of their Components as well as its child <code class="literal">GameObjects</code> and their Components, and so on.</p><p>When our application is built, this serialized data is bundled together in large binary data files internally called Serialized Files in Unity. Reading and deserializing this data from disk at runtime is an incredibly slow process (relatively speaking) and so all deserialization activity comes with a significant performance cost.</p><p>This kind of deserialization takes place any time we call <code class="literal">Resources.Load()</code> for a file path found under a folder named <span class="emphasis"><em>Resources</em></span>. Once the data has been loaded from disk into memory, then reloading the same reference later is much faster, but disk activity is always required the first time it is accessed. Naturally, the larger the data set we need to deserialize, the longer this process takes. Since every Component of a Prefab gets serialized, then the deeper the hierarchy is, the more data needs to be deserialized. This can be a problem for Prefabs with very deep hierarchies, Prefabs with many empty <code class="literal">GameObjects</code> (since every <code class="literal">GameObject</code> always contains at least a <code class="literal">Transform</code> Component), and particularly problematic for User Interface (UI) Prefabs, since they tend to house many more Components than a typical Prefab.</p><p>Loading in large serialized data sets like these could cause a significant spike in CPU the first time they are loaded, which tend to increase loading time if they're needed immediately at the start of the Scene. More importantly, they can cause frame drops if they are loaded at runtime. There are a couple of approaches we can use to minimize the costs of deserialization.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"></a>Reduce serialized object size</h3></div></div></div><p>We should aim to make our serialized objects as small as possible, or partition them into smaller data pieces we combine together piece-by-piece so that they can be loaded one piece at a time over time. This can be tricky to manage for Prefabs since Unity does not inherently support nested Prefabs, and so we would be implementing such a system ourselves, which is a notoriously difficult problem to solve in Unity. UI Prefabs are good candidates for separating into smaller pieces, since we don't normally need the entire UI at any given moment, and so we can usually afford to load them in one piece at a time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec20"></a>Load serialized objects asynchronously</h3></div></div></div><p>Prefabs and other serialized content can be loaded in asynchronously via <code class="literal">Resources.LoadAsync()</code>, which will offload reading from disk onto a worker thread that eases the burden on the main thread. It will take some time for the serialized object to become available, which can be checked by calling the <code class="literal">isDone</code> property on the <code class="literal">ResourceRequest</code> object returned by the previous method call.</p><p>This is not ideal for Prefabs we need immediately at the start of the game, but all future Prefabs are good candidates for asynchronous loading if we're willing to create systems that manage this behaviour.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec21"></a>Keep previously loaded serialized objects in memory</h3></div></div></div><p>As previously mentioned, once a serialized object has been loaded into memory, then it remains there and can be copied if we need it again later, such as instantiating more copies of a Prefab. We can free this data later with explicit calls to <code class="literal">Resources.Unload()</code>, which will release the memory space to be reused later. But, if we have a lot of surplus memory in the application's budget, then we could choose to keep this data in memory, which would reduce the need to reload it again from disk later. This naturally consumes a lot of memory with more and more serialized data, making it a risky strategy for memory management, and so we should only do this when necessary.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec22"></a>Move common data into ScriptableObjects</h3></div></div></div><p>If we have a lot of different Prefabs with Components that contain a lot of properties that tend to share data, such as game design values like hit points, strength, speed, and so on, then all of this data will be serialized into every Prefab that uses them. A better approach is to serialize this common data in a <code class="literal">ScriptableObject</code> which they load and use instead. This reduces the amount of data stored within the Serialized File for the Prefab and could significantly reduce the loading time of our scenes by avoiding too much repetitive work.</p></div></div>