<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec52"></a>Editor UI tips</h2></div></div><hr /></div><p>The following collection of tips relates to the Editor and its interface controls.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec126"></a>Script Execution Order</h3></div></div></div><p>We can prioritize which Scripts will have their <code class="literal">Update()</code> and <code class="literal">FixedUpdate()</code> callbacks called before others by navigating to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Script Execution Order</code></strong>. If we find ourselves trying to solve complex problems using this feature (with the exception of time-sensitive systems, such as audio processing), it implies that we've got some very fragile and tight coupling going on between our Components. From a software design perspective, this can be a warning sign that we might need to approach the problem from another angle. However, this can be helpful to use as a quick fix.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec127"></a>Editor files</h3></div></div></div><p>Integrating Unity projects with a Source Control solution can be a little tricky. The first step is to include <span class="emphasis"><em><span>.meta</span></em></span> files that Unity generates for various assets; if we don't do this, then anyone pulling data into their local Unity project must regenerate their own metadata files. This could potentially cause conflicts, so it is essential that everyone uses the same versions. This can be enabled by navigating to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Editor</code></strong> | <strong class="userinput"><code>Version Control</code></strong> | <strong class="userinput"><code>Mode</code></strong> | <strong class="userinput"><code>Visible Meta Files</code></strong>.</p><p>It can also be helpful to convert certain asset data into a text-only format, rather than binary data, to allow manual editing of data files. This turns many data files into the much more human-readable YAML format. For instance, if we're using Scriptable Objects to store custom data, we can use a text editor to search and edit these files without having to do it all through the Unity Editor and Serialization System. This can save a lot of time, especially when searching for a particular data value or performing multi-editing across different derived types. This option can be enabled by navigating to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Editor</code></strong> | <strong class="userinput"><code>Asset Serialization</code></strong> | <strong class="userinput"><code>Mode</code></strong> | <strong class="userinput"><code>Force Text</code></strong>.</p><p>The Editor has a log file, which can be accessed by opening the <strong class="userinput"><code>Console</code></strong> window (where log messages are printed), left-clicking on the <span class="emphasis"><em>hamburger</em></span> icon in the top-right corner (which looks like three thin horizontal lines), and selecting <strong class="userinput"><code>Open Editor Log</code></strong>. This can help us get more information about build failures. Alternatively, if we successfully built our project, it will contain a breakdown of compressed file sizes of all assets that were packed into the executable and ordered by size. This is an extremely helpful way of figuring out which assets consume the majority of our application footprint (hint: it's almost always texture files), and which files take up more space than we would expect.</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/7bc0eacf-d1bb-4ad3-8660-140fb6e40b18.png" /></div><p>Additional windows can be added to the Editor by right-clicking on the title of an existing window and selecting <strong class="userinput"><code>Add Tab</code></strong>. This also allows us to add duplicate windows, such as having more than one <strong class="userinput"><code>Project</code></strong> window or <strong class="userinput"><code>Inspector</code></strong> window open at a time. This can be particularly useful for moving files between different locations via multiple <strong class="userinput"><code>Project windows.</code></strong></p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/82a19ecb-da50-4a1c-bccf-6ad0971dee9a.png" /></div><p>Having duplicate <strong class="userinput"><code>Inspector</code></strong> windows can be kind of redundant since they'll show the exact same information when we click on a new object. However, by making use of the <span class="emphasis"><em>lock icon</em></span>, we can lock the given <strong class="userinput"><code>Inspector</code></strong> window to its current selection. When we select an object, all <strong class="userinput"><code>Inspector</code></strong> windows will update to show the object's data, except for any locked <strong class="userinput"><code>Inspector</code></strong> windows, which continue to show the data of the object they were locked to.</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/8b6b5a73-9f1a-4fc7-91bd-5338a05ea4e3.png" /></div><p>Common tricks that make use of window locking include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Using two of the same window (<strong class="userinput"><code>Inspector</code></strong>, <strong class="userinput"><code>Animation</code></strong>, and so forth) to compare two objects side by side or more easily copy data from one object to another.</li><li style="list-style-type: disc">Watching what happens to any dependent object if an object is tweaked during <strong class="userinput"><code>Play Mode.</code></strong></li><li style="list-style-type: disc">Selecting multiple objects in the <strong class="userinput"><code>Project</code></strong> window, then dragging and dropping them into a serialized array in the <strong class="userinput"><code>Inspector</code></strong> window without losing the original selection.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec128"></a>The Inspector window</h3></div></div></div><p>We can enter calculations into numeric <strong class="userinput"><code>Inspector</code></strong> window fields. For example, typing <code class="literal">4*128</code> into an <code class="literal">int</code> field will resolve the value to <code class="literal">512</code>, sparing us from having to pull out a calculator or do the math in our head.</p><p>Array elements can be duplicated and deleted from a list (in the same fashion as the hotkeys mentioned previously) by right-clicking on the root element and selecting <strong class="userinput"><code>Duplicate Array Element</code></strong> or <strong class="userinput"><code>Delete Array Element</code></strong>.</p><p>A Component's context menu can be accessed through both the small <span class="emphasis"><em>cog</em></span> icon in the upper-right corner or by right-clicking on the name of the Component. Every Component's context menu contains a <strong class="userinput"><code>Reset</code></strong> option, which resets all values back to their default, sparing us from having to reset values manually. This is useful when working with <code class="literal">Transform</code> Components, as this option will set the object's position and rotation to <code class="literal">(0,0,0)</code> and its scale to <code class="literal">(1,1,1)</code>.</p><p>It's commonly known that if a <code class="literal">GameObject</code> was spawned from a Prefab, then the entire object can be reverted back to its initial Prefab state using the <strong class="userinput"><code>Revert</code></strong> button at the top of the <strong class="userinput"><code>Inspector</code></strong> window. However, it's less well known that individual values can be reverted by right-clicking on the name of the value and selecting <strong class="userinput"><code>Revert Value to Prefab</code></strong>. This restores the selected value while leaving the rest untouched.</p><p>The <strong class="userinput"><code>Inspector</code></strong> window has a <strong class="userinput"><code>Debug Mode</code></strong> that can be accessed by left-clicking on the <span class="emphasis"><em>hamburger</em></span> icon next to the <span class="emphasis"><em>lock</em></span> icon and selecting <strong class="userinput"><code>Debug</code></strong>. This will disable all custom <strong class="userinput"><code>Inspector</code></strong> window drawing from Editor scripts and the like, and instead reveal all pieces of raw data within the given <code class="literal">GameObject</code> and its Components. Even <code class="literal">private</code> data fields become visible. Although they are grayed-out and cannot be modified through the <strong class="userinput"><code>Inspector</code></strong> window, this still gives us a useful way of examining the <code class="literal">private</code> data and other hidden values during <strong class="userinput"><code>Play Mode</code></strong>. The <strong class="userinput"><code><strong class="userinput"><code>Debug</code></strong> Mode</code></strong> of the <strong class="userinput"><code>Inspector</code></strong> window also reveals internal ObjectIDs, which can be useful if we're doing interesting things with Unity's Serialization System and want to resolve conflicts. Since Editor scripts are also disabled during this mode, it can be useful for debugging such scripts by comparing its internal data to what we are trying to reveal in our Editor script.</p><p>If we have an array of data elements serialized in the <strong class="userinput"><code>Inspector</code></strong> window, then they are typically labeled <strong class="userinput"><code>Element N</code></strong>, where <code class="literal">N</code> represents the array index of that element, starting from <code class="literal">0</code>. This can make it tricky to find a specific element if our array elements are a series of serialized classes or structs, which tend to have multiple children themselves. However, if the very first field in the object is a <code class="literal">string</code>, then the elements will be named after the value of the <code class="literal">string</code> field:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/62d5d71d-c985-424f-8296-ef244698ec60.png" /></div><p>When a mesh object is selected, the <strong class="userinput"><code>Preview</code></strong> subsection at the bottom of the <strong class="userinput"><code>Inspector</code></strong> window is often fairly small, making it hard to take a look at details in the mesh and how it will look when it appears in our Scene. However, if we right-click on the top bar of the <strong class="userinput"><code>Preview</code></strong> subsection, it will be detached and enlarged into a separate <strong class="userinput"><code>Preview</code></strong> window, making it much easier to see our mesh. We don't have to worry about setting the detached window back to its original home, as if the detached window is closed, then the <strong class="userinput"><code>Preview</code></strong> subsection will return to the bottom of the <strong class="userinput"><code>Inspector</code></strong> window.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec129"></a>The Project window</h3></div></div></div><p>The <strong class="userinput"><code>Project</code></strong> window's search bar allows us to filter for objects of a particular type by clicking on the small icon to the right of the search bar. This provides a list of different types we can filter by revealing all objects of that type within the entire project. However, selecting these options simply fills the search bar with a string of the <code class="literal">t:&lt;type&gt;</code> format, which applies the appropriate filter.</p><p>Thus, we can simply type the equivalent strings into the search bar for the sake of speed. For instance, typing <code class="literal">t:prefab</code> will filter for all Prefabs, no matter where they are found in the <strong class="userinput"><code>Hierarchy</code></strong> window. Similarly, <code class="literal">t:texture</code> will reveal textures, <code class="literal">t:scene</code> will reveal Scene files, and so on. Adding multiple search filters in the search bar will include objects of all types (it does not reveal objects that only satisfy both filters). These filters are modifiers in addition to name-based filtering, so adding a plain text string will cause a name-based search through the filtered objects. For example, <code class="literal">t:texture normalmap</code> will find all texture files that include the word <span class="emphasis"><em>normalmap</em></span> in their name.</p><p>If we're making use of Asset Bundles and the built-in labeling system, the <strong class="userinput"><code>Project</code></strong> window's search bar also allows us to hunt down bundled objects by their label using <code class="literal">l:&lt;label type&gt;</code>.</p><p>If a <code class="literal">MonoBehaviour</code> script contains serialized references (using <code class="literal">[SerializeField]</code> or <code class="literal">public</code>) to Unity assets, such as meshes and textures, then we can assign default values directly into the script itself. Select the script file in the <strong class="userinput"><code>Project</code></strong> window and the <strong class="userinput"><code>Inspector</code></strong> window should contain a field for the asset for us to drag and drop the default assignment into.</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/d410e907-2dee-40e7-b8bc-da2e04d47760.png" /></div><p>By default, the <strong class="userinput"><code>Project</code></strong> window splits files and folders into two columns and treats them separately. If we prefer the <strong class="userinput"><code>Project</code></strong> window to have a typical hierarchical folder and file structure, then we can set it to <strong class="userinput"><code>One Column Layout</code></strong> in its context menu (the hamburger icon at the top right). This can be a great space saver in some Editor layouts.</p><p>Right-clicking on any object in the <strong class="userinput"><code>Project</code></strong> window and selecting <strong class="userinput"><code>Select Dependencies</code></strong> will reveal all objects on which this asset relies in order to exist, such as textures, meshes, and <code class="literal">MonoBehaviour</code> script files. For Scene files, it will list all entities referenced within that Scene. This is helpful if we're trying to perform asset cleanup.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec130"></a>The Hierarchy window</h3></div></div></div><p>A lesser-known feature of the <strong class="userinput"><code>Hierarchy</code></strong> window is its ability to perform Component-based filtering within the currently active Scene. This can be accomplished by typing <code class="literal">t:&lt;component name&gt;</code>. For example, typing <code class="literal">t:light</code> inside the <strong class="userinput"><code>Hierarchy</code></strong> window search bar will reveal all objects in the Scene that contain a <code class="literal">Light</code> Component.</p><p>This feature is not case-sensitive, but the string we input must match the full Component name for the search to complete. Components that derive from the given type will also be revealed, so typing <code class="literal">t:renderer</code> will reveal all objects with derived Components such as <code class="literal">MeshRenderer</code> and <code class="literal">SkinnedMeshRenderer</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec131"></a>The Scene and Game windows</h3></div></div></div><p>The <strong class="userinput"><code>Scene</code></strong> window Camera is not visible from the <strong class="userinput"><code>Game</code></strong> window, but it is generally a lot easier to be moved around and placed through the use of the hotkeys mentioned previously. The Editor allows us to align the selected object to the same position and to rotate the <strong class="userinput"><code>Scene</code></strong> window Camera by navigating to <strong class="userinput"><code>GameObject</code></strong> | <strong class="userinput"><code>Align with View</code></strong> or pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>F</em></span> (<span class="emphasis"><em>Command</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>F</em></span>). This means that we can use the Camera controls to place the <strong class="userinput"><code>Scene</code></strong> window Camera where we would like our object to be and place the object there by aligning it with the Camera.</p><p>Similarly, we can align the <strong class="userinput"><code>Scene</code></strong> window Camera to the selected object by selecting <strong class="userinput"><code>GameObject</code></strong> | <strong class="userinput"><code>Align View to Selected</code></strong> (note that there is no hotkey for this on <span>either Windows or MacOS</span>). This is useful for checking whether the given object is pointing toward the right direction.</p><p>We can perform similar Component-based filtering on the <strong class="userinput"><code>Scene</code></strong> window, as we can with the <strong class="userinput"><code>Hierarchy</code></strong> window, using the <code class="literal">t:&lt;component&gt;</code> syntax within its search bar. This will cause the <strong class="userinput"><code>Scene</code></strong> window to only render objects containing the given Component (or those that derive from it). Note that this textbox is linked to the same textbox in the <strong class="userinput"><code>Hierarchy</code></strong> window, so anything we type in one will automatically affect the other, which is very helpful when searching for elusive objects.</p><p>At the very top right of the Unity Editor is a drop-down menu labeled <strong class="userinput"><code>Layers</code></strong>. This contains a Layer-based filtering and locking system for the <strong class="userinput"><code>Scene</code></strong> window. Enabling the <span class="emphasis"><em>eye</em></span> icon for a given <span>Layer</span> will show/hide all objects of that Layer within the <strong class="userinput"><code>Scene</code></strong> window. Toggling the lock icon will allow or prevent objects of the given Layer from being selected or modified (at least through the Editor UI).</p><p>This is helpful for things such as preventing someone from accidentally selecting and moving background objects that have been already situated in the perfect location:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/e4074f72-860f-4815-8779-d0cbdf9988f6.png" /></div><p>A commonly known and useful feature of the Editor is that <code class="literal">GameObjects</code> can be given special icons or labels to make them easier to find in the <strong class="userinput"><code>Scene</code></strong> window. This is particularly helpful for objects with no renderer but that we wish to find easily. For instance, objects such as Lights and Cameras have built-in icons that identify them in our <strong class="userinput"><code>Scene</code></strong> window more easily. However, the same gizmos can be revealed within the <strong class="userinput"><code>Game</code></strong> window by clicking on the <strong class="userinput"><code>Gizmos</code></strong> button at the top right of the <strong class="userinput"><code>Game</code></strong> window. The dropdown for this option determines what gizmos will be visible when this option is enabled.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec132"></a>Play Mode</h3></div></div></div><p>Since <strong class="userinput"><code>Play Mode</code></strong> changes are not automatically saved, it is wise to modify the tint color applied during <strong class="userinput"><code>Play Mode</code></strong> to make it blatantly obvious which mode we're currently working with. This value can be set by navigating to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Preferences</code></strong> | <strong class="userinput"><code>Colors</code></strong> | <strong class="userinput"><code>Playmode tint</code></strong>.</p><p>Changes can be saved from <strong class="userinput"><code>Play Mode</code></strong> simply using the clipboard. If we're tweaking an object in <strong class="userinput"><code>Play Mode</code></strong> and we're happy with its settings, then we can copy the object into the clipboard using <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> (<span class="emphasis"><em>Command</em></span> + <span class="emphasis"><em>C</em></span>) and paste it back into the Scene once <strong class="userinput"><code>Play Mode</code></strong> ends via <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>V</em></span> (<span class="emphasis"><em>Command</em></span> + <span class="emphasis"><em>V</em></span>).</p><p>All settings on the object at the time of the copy will be kept. The same can be done with individual values of entire Components using the <strong class="userinput"><code>Copy Component</code></strong> and <strong class="userinput"><code>Paste Component</code></strong> options in the Component's context menu. However, the clipboard can only contain data for one <code class="literal">GameObject</code>, Component, or value at a time.</p><p>Another approach, which allows us to save the data of multiple objects during <strong class="userinput"><code>Play Mode</code></strong>, is to create Prefabs from them by dragging and dropping them into the <strong class="userinput"><code>Project</code></strong> window at runtime once we're happy with the settings. If the original object was derived from a Prefab, and we wish to update it across all instances, then we only need to overwrite the old Prefab with the new one we created by dragging and dropping the copy on top of the original. Note that this also works while <strong class="userinput"><code>Play Mode</code></strong> is active, but it can be dangerous since there is no dialog popup to confirm the overwrite. Be very careful not to overwrite the wrong Prefab.</p><p>We can use the <strong class="userinput"><code>Frame Skip</code></strong> button (the button to the right of the <strong class="userinput"><code>Pause</code></strong> button in the Editor) to iterate one frame at a time. This can be useful for watching frame-by-frame physics or Gameplay behavior. Keep in mind that this causes both one Fixed Update and one Update to be called per iteration, in equal counts, which may not exactly reflect actual runtime behavior where we tend to have an unequal number of calls to these callbacks.</p><p>If the <strong class="userinput"><code>Pause</code></strong> button is enabled when <strong class="userinput"><code>Play Mode</code></strong> begins, then the game will be paused just after the very first frame, giving us a chance to observe any anomalies that occurred during initialization of our Scene.</p></div></div>