<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Load scenes additively and asynchronously</h2></div></div><hr /></div><p><span>Scenes</span> can be loaded either to replace the current Scene or can be loaded additively to add its contents to the current Scene without unloading the preceding one. This can be toggled via the <code class="literal">LoadSceneMode</code> argument of the <code class="literal">SceneManager.LoadScene()</code> family of functions. </p><p>Another mode of Scene loading is to complete it either synchronously or asynchronously, and there are good reasons to use both. Synchronous loading is the typical means of loading a Scene by calling <code class="literal">SceneManager.LoadScene()</code> where the main thread will block until the given Scene completes loading. This normally results in a poor user experience, as the game appears to freeze as the contents are loaded in (whether as a replacement or additively). This is best used if we want to get the player into the action as soon as possible, or we have no time to wait for Scene objects to appear. This would normally be used if we’re loading into the first level of the game or returning to the main menu.</p><p>For future Scene loading, however, we may wish to reduce the performance impact so that we can continue to keep the player in action. Loading a Scene can take a lot of work, and the larger the Scene, the longer it will take. However, the option of asynchronous additive loading offers a huge benefit; we can let the Scene gradually load in the background without causing significant impact on the user experience. This can be accomplished with <code class="literal">SceneManager.LoadSceneAsync()</code> combined with passing in <code class="literal">LoadSceneMode.Additive</code> for the loading mode argument.</p><p>It’s important to realize that scenes do not strictly follow the concept of a game level. In most games, players are normally trapped in one level at a time, but Unity can support multiple scenes being loaded simultaneously through additive loading, allowing each Scene to represent a small chunk of a level. Ergo, we could initialize the first Scene for the level (<span class="emphasis"><em>Scene-1-1a</em></span>), and as the player nears the next section, asynchronously and additively load in the next (<span class="emphasis"><em>Scene-1-1b</em></span>), and repeat this continuously as the player travels through the level.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip36"></a>Note</h3><p>Unity Technologies restructured the Scene system in a mid-release of Unity 5 into a global <code class="literal">SceneManager</code> class, although this was more of a naming convention change to make it clear that levels and scenes are not the same thing. The exact same features are available in older releases of Unity, just with a slightly different API through the <code class="literal">Application</code> class.</p></div><p>Exploiting this feature would require a system that either constantly checks the player’s position in the level until they get close or uses Trigger Volumes to broadcast a message that the player is nearing the next section and begin asynchronous loading at the appropriate time. Another important consideration is that the Scene's contents won’t appear immediately since asynchronous loading effectively spreads the loading out over a handful of frames in order to cause as little visible impact as possible. We need to make sure that we trigger asynchronous Scene loading with more than enough time to spare so that the player won’t see objects popping into the game.</p><p>Scenes can also be unloaded to clear them out of memory. This will save some memory or runtime performance in the form of removing any Components making use of <code class="literal">Update()</code> that we no longer need. Again, this can be done both synchronously and asynchronously with <code class="literal">SceneManager.UnloadScene()</code> and <code class="literal">SceneManager.UnloadSceneAsync()</code>. This can be an enormous performance benefit because we’re only using what we need due to the player’s location in the level, but note that it is not possible to unload small chunks of a monolithic Scene. If the original Scene file was enormous, then unloading it would unload everything. The original Scene would have to be broken up into smaller scenes and then loaded and unloaded as needed. Similarly, we should only begin to unload a Scene if we’re certain the player can no longer see its constituent objects, otherwise they would witness objects disappearing out of nowhere. One last consideration is that Scene unloading would trigger the destruction of many objects, which is likely to free up a lot of memory and trigger the garbage collector. An efficient use of memory is also important when making use of this tip.</p><p>This approach would require a significant amount of Scene redesign work, script writing, testing, and debugging, which is not to be underestimated, but the benefits of improving user experience are exceptional. Having seamless transitions between areas in a game is a benefit that is often praised by players and critics, because it doesn’t take the player out of the action. If we use it appropriately, it can save a significant amount of runtime performance, improving the user experience further.</p></div>