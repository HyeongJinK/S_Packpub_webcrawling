<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch05"></a>Chapter 5. Faster Physics</h2></div></div></div><p>Each of the performance-enhancing suggestions we've explored thus far have been primarily centered on reducing resource costs and avoiding frame rate issues. However, at its most fundamental level, seeking peak performance means improving the user experience. This is because every frame rate hiccup, every crash, and every system requirement that is too costly for a given market ultimately detracts from the quality of the product. Physics Engines are in a unique category of subsystems whose behavior and consistency contributes a major factor toward product quality, and spending the time to improve its behavior is often worth the cost.</p><p>If important collision events get missed, the game freezes while it calculates a complex physics event, or the player falls through the floor, then these have an obvious and significant negative impact on the quality of gameplay. A few glitches are often bearable, but continuous problems will get in the way of gameplay. This often results in pulling the player out of the experience, and it's a coin-toss whether the user finds it inconvenient, obnoxious, or hilarious. Unless our game is specifically targeting the Comedy Physics genre (games such as QWOP or Goat Simulator), these are situations we should strive to avoid.</p><p>Some games may not use physics at all, whereas others require the Physics Engine to handle a huge number of tasks during gameplay, such as collision detection between hundreds of objects, Trigger Volumes to initiate cutscenes, Raycasting for player attacks and UI behavior, gathering lists of objects in a given region, or even just using physics as eye candy with lots of physical particles flying around. Its importance also varies depending on the type of game being created. For example, it is essential in platformer and action games to tune the physics properly--how the player character reacts to input and how the world reacts to the player character are two of the most important aspects that make the game feel responsive and fun. Whereas, accurate physics may be somewhat less important in <span class="strong"><strong>Massively Multiplayer Online</strong></span> (<span class="strong"><strong>MMO</strong></span>) games, which tend to have limited physics interaction.</p><p>Therefore, in this chapter, we will cover ways to reduce CPU spikes, overhead, and memory consumption through Unity's Physics Engine, but also include ways to alter physics behavior with the aim of improving, or at least maintaining, gameplay quality while optimizing performance. In this chapter, we will cover the following areas:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Understanding how Unity's Physics Engine works:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Timesteps and FixedUpdates</li><li style="list-style-type: disc">Collider types</li><li style="list-style-type: disc">Collisions</li><li style="list-style-type: disc">Raycasting</li><li style="list-style-type: disc">Rigidbody active states</li></ul></div></li><li style="list-style-type: disc">Physics performance optimizations:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">How to structure Scenes for optimal physics behavior</li><li style="list-style-type: disc">Using the most appropriate types of Collider</li><li style="list-style-type: disc">Optimizing the Collision Matrix</li><li style="list-style-type: disc">Improving physics consistency and avoiding error-prone behavior</li><li style="list-style-type: disc">Ragdolls and other Joint-based objects</li></ul></div></li></ul></div></div>