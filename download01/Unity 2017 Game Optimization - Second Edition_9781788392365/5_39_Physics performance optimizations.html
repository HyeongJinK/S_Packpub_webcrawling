<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec36"></a>Physics performance optimizations</h2></div></div><hr /></div><p>Now that we have an understanding of the majority of features of the Unity Physics Engine, we can cover several optimization techniques to improve our game's physics performance.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec50"></a>Scene setup</h3></div></div></div><p>Firstly, there are a number of best practices we can apply to our Scenes to improve consistency of the physics simulation. Note that several of these techniques will not necessarily improve CPU or memory usage, but they will result in a reduced likelihood of instability from the Physics Engine.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec42"></a>Scaling</h4></div></div></div><p>We should try to keep all physics object scales in the world as close to <code class="literal">(1,1,1)</code> as we possibly can. By default, Unity assumes that we are trying to simulate gameplay equivalent to being on the surface of the Earth. The force of gravity at the surface of the Earth is 9.81 meters-per-second-squared, and hence the default gravity value is set to <code class="literal">-9.81</code> to match. 1 unit in Unity's world space is equivalent to 1 meter, and the negative sign means that it will pull the object downward. Our object sizes should reflect our effective world scale, since scaling them too large will cause gravity to appear to move the objects much more slowly than we would expect. If all of our objects are scaled five times too big, then gravity will appear to be five times weaker. The converse is also true; scaling objects too small will make them appear to fall too quickly and will not seem realistic.</p><p>We can tweak the world's implied scale by modifying the strength of gravity under <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Physics / Physics 2D</code></strong> | <strong class="userinput"><code>Gravity</code></strong>. However, note that any floating-point arithmetic will be more accurate with values closer to <code class="literal">0</code>, so if we have some objects that have scale values far above <code class="literal">(1,1,1)</code>, even if they match the implied world-scale, then we could still observe erratic physics behavior. So, early in the project, we should import and scale our most common physics objects around a scale value of <code class="literal">(1,1,1)</code> and then adjust the value of gravity to match. This will give us a reference point to work with as we introduce new objects.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec43"></a>Positioning</h4></div></div></div><p>Similarly, keeping all objects close to <code class="literal">(0,0,0)</code> in the world-space position will result in better floating-point accuracy, improving the consistency of the simulation. Space simulator and free-running games try to simulate incredibly large spaces and typically use a trick of either secretly teleporting the player back toward the center of the world or fixing their position there, in which case, either volumes of space are compartmentalized so that physics calculations are always calculated with values close to <code class="literal">0</code>, or everything else is moved to simulate travel, and the player's motion is only an illusion.</p><p>Most games are not at risk of introducing floating-point inaccuracy, since most game levels tend to last around 10 to 30 minutes, which doesn't give the player much time to travel absurdly long distances, but if we're working with exceptionally large Scenes or asynchronously loading Scenes throughout the course of the entire game to the point that the player travels tens of thousands of meters, then we may start to notice some strange physics behavior the further they travel.</p><p>So, unless we're already far too deep into our project such that changing and retesting everything at a late stage would be too much hassle, we should try to keep all of our physics objects close to <code class="literal">(0,0,0)</code>. Plus, this is good practice for our project workflow, as it makes it much quicker to find objects and tweak things in our game world.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec44"></a>Mass</h4></div></div></div><p>Mass is stored as a floating-point value under a <code class="literal">Rigidbody</code> Component's <code class="literal">mass</code> property, and documentation on its usage has changed a fair amount over the years due to updates in its Physics Engine. In the recent versions of Unity (late Unity 5 and early Unity 2017), we are essentially free to choose whatever we want the value <code class="literal">1.0</code> to represent and then scale other values appropriately.</p><p>Traditionally, a mass value of <code class="literal">1.0</code> is used to represent a mass of 1 kilogram, but we could decide that a human being has a mass of <code class="literal">1.0</code> (~130 kilogram), in which case, a car would be given a mass value of <code class="literal">10.0</code> (~1,300 kilogram), and physics collisions will resolve similarly to what we expect. The most important part is the relative difference in mass, which allows collisions between these objects to look believable without stressing the engine too much. Floating-point precision is also a concern, so we don't want to use large mass values that are too ridiculous.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip63"></a>Note</h3><p>Note that if we intend to use Wheel Colliders, their design assumes that a mass of <code class="literal">1.0</code> represents 1 kilogram, so we should assign our mass values appropriately.</p></div><p>Ideally, we would maintain mass values around <code class="literal">1.0</code> and ensure a maximum relative mass-ratio of around <code class="literal">100</code>. If two objects collide with a mass-ratio much greater than this, then large momentum differences can turn into sudden, immense velocity changes from the impulse, resulting in some unstable physics and potential loss of floating-point precision. Object pairs that have a significant scale difference should probably be culled with the Collision Matrix to avoid problems (more on this shortly).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip64"></a>Note</h3><p>Improper mass-ratios are the most common cause for physics instability and erratic behavior in Unity. This is particularly true when using Joints for objects such as Ragdolls.</p></div><p>Note that the force of gravity at the center of the Earth affects all objects equally, regardless of their mass, so it does not matter if we consider a mass property value of <code class="literal">1.0</code> to be the mass of a rubber ball or the mass of a warship. There's no need to adjust the force of gravity to compensate. What does matter, however, is the amount of air resistance the given object undergoes while falling (which is why a parachute falls slowly). So, to maintain realistic behavior, we may need to customize the <code class="literal">drag</code> property for such objects or customize the force of gravity on a per-object basis. For example, we could disable the <strong class="userinput"><code>Use Gravity</code></strong> checkbox and apply our own custom gravitational force during Fixed Updates.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec51"></a>Use Static Colliders appropriately</h3></div></div></div><p>As mentioned previously, the Physics Engine automatically generates two separate data structures to contain Static Colliders separately from Dynamic Colliders. Unfortunately, if new objects are introduced into the Static Collider data structure at runtime, then it must be regenerated, similar to calling <code class="literal">StaticBatchingUtility.Combine()</code> for Static Batching. This is likely to cause a significant CPU spike. This makes it vital that we avoid instantiating new Static Colliders during gameplay.</p><p>In addition, merely moving, rotating, or scaling Static Colliders also triggers this regeneration process and should be avoided. If we have Colliders that we wish to move around without reacting to other objects colliding with them in a physical way, then we should attach a Rigidbody to make it a Dynamic Collider and enable the <strong class="userinput"><code>Kinematic</code></strong> flag. This flag prevents the object from reacting to external impulses from inter-object collisions, similar to Static Colliders, except the object can still be moved through its <code class="literal">Transform</code> Component or through forces applied to its <code class="literal">Rigidbody</code> Component (preferably during Fixed Updates). Since a Kinematic object won't respond to other objects hitting it, it will tend to simply push other Dynamic Colliders out of its way as it moves.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip65"></a>Note</h3><p>It's for this reason that player character objects are often made into Kinematic Colliders.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec52"></a>Use Trigger Volumes responsibly</h3></div></div></div><p>As mentioned previously, we can treat our physics objects as normal Colliders or as Trigger Volumes. An important distinction between these two types is that the <code class="literal">OnCollider...()</code> callbacks provide a <code class="literal">Collision</code> object as a parameter to the callback, which contains useful information such as the exact location of collision (useful to position a Particle Effect) and the contact normal (useful if we want to manually move the object after the collision). Whereas, the <code class="literal">OnTrigger...()</code> callbacks do not provide this kind of information.</p><p>As a result, we should not try to use Trigger Volumes for collision-reactive behavior since we won't have enough information to make the collision appear accurate. Trigger Volumes are best used for their intended purpose of tracking when an object enters/exits a specific area, such as dealing with damage while a player stays in a lava pit, triggering a cutscene when a player enters a building, and initiating asynchronous loading/unloading of a Scene when the player approaches/moves far enough away from another major area.</p><p>If contact information is absolutely needed for a Trigger Volume collision, then common workarounds are to do any of the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Generate a rough estimate for the contact point by halving the distance between the Trigger Volume and colliding objects' center of mass (this assumes that they're of roughly equal size)</li><li style="list-style-type: disc">Perform a Raycast upon collision from the center of the Trigger Volume to the center of mass of the colliding object (works best if both of the objects are spherical)</li><li style="list-style-type: disc">Create a non-Trigger Volume object, give it an infinitesimally small mass (so that the colliding object is barely effected by its presence), and immediately destroy it upon collision (since collision with such a large mass differential will probably send this small object into orbit)</li></ul></div><p>Of course, each of these approaches have their drawbacks; limited physical accuracy, extra CPU overhead during collision, and/or additional Scene setup (and rather hacky-looking collision code), but they can be useful in a pinch.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec53"></a>Optimize the Collision Matrix</h3></div></div></div><p>As we know, the Physics Engine's Collision Matrix defines which objects assigned to certain Layers are allowed to collide with objects assigned to other Layers, or to put it more succinctly, which object collision pairs are even considered viable by the Physics Engine. Every other object-Layer pair is simply ignored by the Physics Engine, which makes this an important avenue for minimizing Physics Engine workload since it reduces the number of bounding volume checks that must be performed each and every Fixed Update and how many collisions would ever need to be processed during the lifecycle of the application (which would save on battery life for a mobile device).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip66"></a>Note</h3><p>Note that the Collision Matrix can be accessed through <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Physics (or Physics2D)</code></strong> | <strong class="userinput"><code>Layer Collision Matrix.</code></strong></p></div><p>The following screenshot shows a common Collision Matrix for an arcade shooter game:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/1ba9a113-4f68-47ef-a595-0b2f7412e436.png" /></div><p>In the preceding example, we have objects flagged as <strong class="userinput"><code>Player</code></strong>, <strong class="userinput"><code>Enemies</code></strong>, <strong class="userinput"><code>Player Missiles</code></strong>, <strong class="userinput"><code>Enemy Missiles</code></strong>, and <strong class="userinput"><code>Powerups</code></strong>, and we have minimized the number of possible inter-object collisions for the Physics Engine to check.</p><p>Starting with the first row of checkmarks labeled <strong class="userinput"><code>Player</code></strong>, we want the <strong class="userinput"><code>Player</code></strong> object to be able to collide with <strong class="userinput"><code>World</code></strong> objects, pickup <strong class="userinput"><code>Powerups</code></strong>, get hit by <strong class="userinput"><code>Enemy Missiles</code></strong>, and collide with <strong class="userinput"><code>Enemies</code></strong>. However, we do not want them to collide with their own <strong class="userinput"><code>Player Missiles</code></strong> or themselves (although there would probably only be one object in this Layer, anyway). Hence, the enabled checkboxes in the <strong class="userinput"><code>Player</code></strong> row reflect these requirements. We only want <strong class="userinput"><code>Enemies</code></strong> to collide with <strong class="userinput"><code>World</code></strong> objects and <strong class="userinput"><code>Player Missiles</code></strong>, so these are checked in the <strong class="userinput"><code>Enemies</code></strong> row. Note that the <strong class="userinput"><code>Player</code></strong>-to-<strong class="userinput"><code>Enemies</code></strong>collision pair would have been handled already by the previous row; hence there is no need for it to appear in the <strong class="userinput"><code>Enemies</code></strong> row. We also want both <strong class="userinput"><code>Player Missiles</code></strong> and <strong class="userinput"><code>Enemy Missiles</code></strong> to explode when they hit <strong class="userinput"><code>World</code></strong> objects, so these are marked, and finally we don't care about <strong class="userinput"><code>Powerups</code></strong> colliding with anything but the <strong class="userinput"><code>Player</code></strong>, nor do we want <strong class="userinput"><code>World</code></strong> objects to collide with other <strong class="userinput"><code>World</code></strong> objects, so no checkboxes are marked on the final two rows.</p><p>At any given moment, we might have a single <strong class="userinput"><code>Player</code></strong> object, 2 <strong class="userinput"><code>Powerups</code></strong>, 7 <strong class="userinput"><code>Player Missiles</code></strong>, 10 <strong class="userinput"><code>Enemies</code></strong>, and 20 <strong class="userinput"><code>Enemy Missiles</code></strong>, which is 780 potential collision pairs (this is calculated as each of 40 different objects could collide with 39 other ones, giving us 1,560 potential collision pairs, but then we divide the total by 2 to ignore duplicate pairs). By merely optimizing this matrix, we have reduced this to less than 100, for an almost 90% reduction in potential collision checks. Of course, the Unity Physics Engine efficiently culls away many of these object pairs if they are too far apart from one another, hence there is little to no chance that they could collide (this is calculated during a hidden process known as <span class="strong"><strong>Broadphase Culling</strong></span>), so the actual savings will probably never be this good, but it will free up some CPU cycles with next to no effort. Another big benefit is that it simplifies our game logic coding; there's no need to figure out what's supposed to happen if <strong class="userinput"><code>Powerups</code></strong> and <strong class="userinput"><code>Enemy Missiles</code></strong> collide if we tell the Physics Engine to ignore collisions between them.</p><p>We should perform logical sanity checks like this for all potential Layer combinations in the Collision Matrix to see whether we're wasting precious time checking for inter-object collisions between object pairs that aren't necessary. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec54"></a>Prefer Discrete collision detection</h3></div></div></div><p>Discrete collision detection is fairly cheap since teleporting objects once and performing a single overlap check between nearby object pairs is a fairly trivial amount of work to perform in a single timestep. The amount of calculation required to perform Continuous collision detection is significantly greater, since it involves interpolating both objects between their starting and ending positions, while analyzing for any slight bounding volume overlaps between these points as they might occur during the timestep.</p><p>Consequently, the <strong class="userinput"><code>Continuous</code></strong> collision detection option is an order of magnitude more expensive than the <strong class="userinput"><code>Discrete</code></strong> detection method, whereas the <strong class="userinput"><code>ContinuousDynamic</code></strong> collision detection setting is an order of magnitude even more expensive than <strong class="userinput"><code>Continuous</code></strong>. Having too many objects configured to use either of the Continuous collision detection types will cause serious performance degradation in complex Scenes. In either case, the costs are multiplied by the number of objects that need to be compared during any given frame and whether or not the comparison Collider is Static or Dynamic.</p><p>Ergo, we should favor the <strong class="userinput"><code>Discrete</code></strong> collision detection setting for the overwhelming majority of our objects, while using either of the Continuous collision detection settings only in extreme circumstances. The <strong class="userinput"><code>Continuous</code></strong> setting should be used when important collisions are frequently missed with the more static parts of our game world. For instance, if we wish to be certain that the player characters never fall through the game world or never accidentally teleport through walls if they move too quickly, then we might want to apply Continuous collision detection only for those objects. Finally, the <strong class="userinput"><code>ContinuousDynamic</code></strong> setting should only be used if the same situation applies and we wish to catch collisions between pairs of very fast moving Dynamic Colliders.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec55"></a>Modify the Fixed Update frequency</h3></div></div></div><p>In some cases, <strong class="userinput"><code>Discrete</code></strong> collision detection might not work well enough on a large scale. Perhaps our entire game revolves around a lot of small physics objects, and Discrete collision detection simply isn't catching enough collisions to maintain product quality. However, applying one of the Continuous collision detection settings to everything would be far too prohibitive on performance. In this case, there is one option we can try: we can customize the physics timestep to give the Discrete collision detection system a better chance of catching such collisions by modifying how frequently the engine checks for Fixed Updates.</p><p>As mentioned previously, Fixed Updates and physics timestep processing are strongly coupled; so, by modifying the frequency of Fixed Update checks, we not only change the frequency that the Physics Engine will calculate and resolve the next callback, but we also change how frequently the <code class="literal">FixedUpdate()</code> callbacks and Coroutines are being invoked. Consequently, changing this value can be risky if we're deep into our project and have a lot of behavior that depends on these callbacks since we will be changing a very important assumption about how often these methods are invoked.</p><p>Altering the Fixed Update frequency can be accomplished using the <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Time</code></strong> | <strong class="userinput"><code>Fixed Timestep</code></strong> property in the Editor or through the <code class="literal">Time.fixedDeltaTime</code> property in script code.</p><p>Reducing this value (increasing the frequency) will force the Physics Engine to process more frequently, giving it a better chance of catching collisions with Discrete collision detection. Naturally, this comes with an added CPU cost since we're invoking more <code class="literal">FixedUpdate()</code> callbacks and asking the Physics Engine to update more frequently, having it move objects and verify collisions more often.</p><p>Conversely, increasing this value (decreasing the frequency) provides more time for the CPU to complete other tasks before it must handle physics processing again, or looking at it from another perspective, giving the Physics Engine more time to process the last timestep before it begins processing the next one. Unfortunately, lowering the Fixed Update frequency would essentially lower the maximum velocity at which objects can move before the Physics Engine can no longer capture collisions with Discrete collision detection (depending on the objects' sizes). We might also start to see objects changing velocities in strange ways because it is essentially becoming a weaker approximation of real-world physics behavior.</p><p>This makes it absolutely vital to perform a significant amount of testing each time the Fixed Timestep value is changed. Even with a complete understanding of how this value works, it is difficult to predict what the overall outcome will look like during gameplay and whether the result is passable for quality purposes. Hence, changes to this value should be made early in the project's lifecycle and then made infrequently in order to get a sufficient amount of testing against as many physics situations as possible.</p><p>It might help to create a test Scene that flings some of our high-velocity objects at one another to verify that the results are acceptable and run through this Scene whenever Fixed Timestep changes are made. However, actual gameplay tends to be rather complex, with many background tasks and unanticipated player behavior that causes additional work for the Physics Engine or gives it less time to process the current iteration. Actual gameplay conditions are impossible to replicate in a vacuum. Also, there's no substitute for the real thing, so the more testing we can accomplish against the current value of Fixed Timestep, the more confident we can be that the changes meet acceptable quality standards.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip67"></a>Note</h3><p>Take it from someone who's in the career of developing software automation tools: automation of software testing is helpful in a lot of situations, but when it comes to <span class="emphasis"><em>real-time event and user input-driven applications, which synchronize with multiple hardware devices and complex subsystems such as Physics Engines, and which tend to change rapidly due to iterations on feedback</em></span>, the support and maintenance costs of automated testing often becomes more effort than its worth, making manual testing the most sensible approach.</p></div><p>We always have Continuous collision detection as a last resort to offset some of the resulting instability we're observing. Unfortunately, even if the changes are targeted, it is more likely that this will cause further performance issues than we started with due to the overhead costs of Continuous collision detection. It would be wise to profile our Scene before and after enabling Continuous collision detection to verify that the benefits are outweighing the costs.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec56"></a>Adjust the Maximum Allowed Timestep</h3></div></div></div><p>If we're regularly exceeding the Maximum Allowed Timestep (which, as a reminder, determines how much time the Physics Engine has to resolve a timestep before it must exit early), then it will result in some pretty bizarre-looking physics behavior. Rigidbodies will appear to slow down or jerk to a stop since the Physics Engine needs to keep exiting timestep calculations early before it has fully resolved its entire time quota. In this case, it is a clear sign that we need to optimize our physics behavior from other angles. However, at the very least, we can be confident that the threshold will prevent the game from completely locking up from a spike in the middle of physics processing.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip68"></a>Note</h3><p>Reminder: this setting can be accessed through <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Time</code></strong> | <strong class="userinput"><code>Maximum Allowed Timestep</code></strong>.</p></div><p>The default setting is to consume a maximum of 0.333 seconds, which would manifest itself as a very noticeable drop in frame rate (a mere 3 FPS) if it were exceeded. If you ever feel the need to change this setting, then you obviously have some big problems with your physics workload, so it is recommended that you only tweak this value if you have exhausted all other approaches.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec57"></a>Minimize Raycasting and bounding-volume checks</h3></div></div></div><p>All of the Raycasting methods are incredibly useful, but they are relatively expensive, particularly <code class="literal">CapsuleCast()</code> and <code class="literal">SphereCast()</code>. We should avoid calling these methods regularly within the <code class="literal">Update()</code> callbacks or Coroutines, saving them only for key events in our script code.</p><p>If we're making use of persistent line, ray, or area-of-effect collision areas in our Scene (examples include security lasers, continuously burning fires, beam weapons, and so on) and the object remains relatively stationary, then they would perhaps be better simulated using a simple Trigger Volume.</p><p>If such replacements are not possible and we truly need persistent casting checks using these methods, we should minimize the amount of processing each Raycast makes by exploiting <code class="literal">LayerMasks</code>. This is particularly true if we're making use of <code class="literal">Physics.RaycastAll()</code>. For example, a poorly optimized usage of this kind of Raycasting would look as follows:</p><pre class="programlisting">void PerformRaycast() {
  RaycastHit[] hits;
  hits = Physics.RaycastAll(transform.position, transform.forward, 
  100.0f);
  for (int i = 0; i &lt; hits.Length; ++i) {
    RaycastHit hit = hits[i];
    EnemyComponent e = hit.transform.GetComponent&lt;EnemyComponent&gt;();
    if (e.GetType() == EnemyType.Orc) {
        e.DealDamage(10);
    }
  }
}</pre><p>In the preceding example, we're collecting Raycast collision data for every object in the path of this Ray, but we're only processing its effects on objects which hold a specific <code class="literal">EnemyComponent</code>. Consequently, we're asking the Physics Engine to complete much more work than is necessary. </p><p>A better approach will be to use a different overload of <code class="literal">RaycastAll()</code>, which accepts a <code class="literal">LayerMask</code> value as an argument. This will filter collisions for the Ray in much the same way as the Collision Matrix so that it only tests against objects in the given Layer(s). The following code contains a subtle improvement by providing an additional <code class="literal">LayerMask</code> property; we would configure the <code class="literal">LayerMask</code> through the <strong class="userinput"><code>Inspector</code></strong> window for this Component, and it will filter the list much faster and only contain hits for objects matching the mask:</p><pre class="programlisting"><span class="strong"><strong>[SerializeField] LayerMask _layerMask;</strong></span>

void PerformRaycast() {
  RaycastHit[] hits;
  hits = Physics.RaycastAll(transform.position, transform.forward, 100.0f<span class="strong"><strong>, _layerMask</strong></span>);
  for (int i = 0; i &lt; hits.Length; ++i) {
    // as before ...
  }
}</pre><p>This optimization doesn't work as well for the <code class="literal">Physics.RaycastHit()</code> function since that version only provides ray collision information for the first object the Ray collides with, regardless of whether we're using a <code class="literal">LayerMask</code> or not.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note69"></a>Note</h3><p>Note that because the <code class="literal">RaycastHit</code> and <code class="literal">Ray</code> classes are managed by the Native memory space of the Unity Engine, they don't actually result in memory allocations that draw the attention of the <strong class="userinput"><code>Garbage Collector</code></strong>. We will learn more about such activity in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec58"></a>Avoid complex Mesh Colliders</h3></div></div></div><p>In order of collision detection efficiency, the various Colliders are Spheres, Capsules, Boxes, Convex Mesh Colliders, followed by Concave Mesh Colliders being far and away the most expensive. Collisions always involve pairs of objects, and the amount of work (math) needed to resolve the collision will depend on the complexity of both objects. Detecting collisions between two primitive objects can be reduced down to a relatively simple set of mathematical equations, which are highly optimized. Performing comparisons against a pair of Convex Mesh Colliders is a much more complex equation, making them an order of magnitude more expensive than collisions between two primitives. Then, there are collisions between two Concave Mesh Colliders, which are so complex that they cannot be reduced down to a simple formula and require collision checks to be resolved between each pair of triangles across both meshes, easily making them orders of magnitude more expensive than collisions between other Collider types. The amount of work involved scales similarly when we resolve collisions between shapes of different groups. For example, a collision between a primitive and Concave Mesh Collider would be slower than a collision between two primitives, but faster than a collision between two Concave Mesh Colliders.</p><p>There is also the question of whether one, or both, of the objects involved in the collision is moving (one of the objects being a Static Collider is easier to process than both objects being Dynamic Colliders). There is also the matter of how many of these objects are within our Scene since the total processing costs of collision detection will grow rapidly if we're not careful with how many shapes we introduce into the simulation.</p><p>A great irony between representing physics and graphics in 3D applications is how difficult it is to handle spherical and cube objects between the two of them. The perfect spherical mesh would require an infinite number of polygons to be generated, making such an object impossible to represent graphically.</p><p>However, handling collisions between two spheres in a Physics Engine is perhaps the simplest problem to solve for contact points and collisions (the contact point is always at the edge of either of the sphere's radius, and the contact normal is always the vector between their centers of mass). Conversely, a cube is one of the simplest objects to represent graphically (as little as 8 vertices and 12 triangles) and yet takes significantly more mathematics and processing power to find contact points and resolve collisions for (and the mathematics to resolve it depends on whether the collision occurred between faces, edges, corners, or a mixed pairing). Anecdotally, this implies that the most efficient way of creating the largest number of objects would be to populate our world with cube objects, which use spherical Colliders. However, this would make absolutely no sense to a human observer, as they would witness cubes rolling around like balls.</p><p>The previous anecdote serves as a reminder that the physical representation of an object does not necessarily need to match its graphical representation. This is beneficial, as a graphical mesh can often be condensed down into a much simpler shape, while still generating very similar physics behavior and simultaneously removing the need to use an overly complex Mesh Collider.</p><p>This separation of representations between graphics and physics allows us to optimize the performance of one system without (necessarily) negatively affecting the other. So long as there are no noticeable repercussions on gameplay (or we're willing to make the sacrifice), then we are free to represent complex graphical objects with much simpler physics shapes without players noticing. Also, if the player never notices, then no harm is done.</p><p>So, we can solve this problem in one of the two ways: either by approximating the physics behavior of the complex shape using one (or more) of the standard primitives or by using a much simpler Mesh Collider.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec45"></a>Use simpler primitives</h4></div></div></div><p>Most shapes can be approximated using one of the three primitive Colliders. In fact, we do not need to represent the object using only a single Collider. We are free to use several Colliders if they serve our needs for creating a complex collision shape by attaching additional child <code class="literal">GameObjects</code> with their own Colliders. This is almost always less expensive than using a single Mesh Collider and should be preferred.</p><p>The following image shows a handful of complex graphical objects represented by one or more simpler primitive Collider shapes:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/6a37979f-7e8c-4c8a-8479-92ad66c46bb1.png" /></div><p>Using a Mesh Collider for any one of these objects would be significantly more expensive than the primitive Colliders shown here due to the number of polygons they contain. It is worth exploring any and all opportunities to simplify our objects down using these primitives as much as we can, as they can provide significant performance gains.</p><p>For example, Concave Mesh Colliders are unique in that they can feature gaps or holes that allow other meshes to fall into, or even through them, which introduces opportunities for the objects to fall through the world if such Colliders are used for world collision areas. It is often better to place Box Colliders in strategic locations for this purpose.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec46"></a>Use simpler Mesh Colliders</h4></div></div></div><p>Similarly, the mesh assigned to a Mesh Collider does not necessarily need to match the graphical representation of the same object (Unity simply picks it as the default). This gives us an opportunity to assign a simpler mesh to the Mesh Collider's <code class="literal">mesh</code> property, which is different from the one we use for its graphical representation.</p><p>The following image shows an example of a complex graphical mesh that has been given a much more simplified mesh for its Mesh Collider:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/621a5ef0-97f4-4106-9d44-17bb1d54ecfc.png" /></div><p>Simplifying the rendered mesh into convex shapes with lower polygon counts in this way will greatly reduce the overhead needed to determine bounding volume overlaps with other Colliders. Depending on how well the original object is estimated, there should be minimal noticeable gameplay differences, especially in the case of this axe, which we expect to be moving quickly as creatures swing it during attacks, making it unlikely that players will notice the difference between the two meshes as Colliders. In fact, the simplified mesh is much less likely to be missed by Discrete collision detection and is also preferable for that reason.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec59"></a>Avoid complex physics Components</h3></div></div></div><p>Certain special physics Collider Components, such as <code class="literal">TerrainCollider</code>, <code class="literal">Cloth</code>, and <code class="literal">WheelCollider</code>, are orders of magnitude more expensive than all primitive Colliders and even Mesh Colliders in some cases. We should simply not include such Components in our Scenes unless they are absolutely necessary. For instance, if we have terrain objects in the distance that the player will never approach, there's little reason to include an attached <code class="literal">TerrainCollider</code>.</p><p>Games featuring <code class="literal">Cloth</code> Components should consider instantiating different objects without them when running in lower-quality settings, or simply animating cloth behavior (although it is totally understandable if the team has grown attached and fallen in love with how the stuff moves around).</p><p>Games using <code class="literal">WheelCollider</code> Components should simply try to use fewer Wheel Colliders. Large vehicles, with more than four wheels, may be able to simulate similar behavior using only four wheels, while faking the graphical representation of additional wheels.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec60"></a>Let physics objects sleep</h3></div></div></div><p>The Physics Engine's sleep feature can pose several problems for our game. Firstly, some developers don't realize that many of their Rigidbodies are sleeping during most of the lifetime of their application. This tends to lead developers to assume that they can get away with (for example) doubling the number of Rigidbodies in their game and the overall costs would simply double to match it. This is unlikely. The frequency of collisions and total accumulated time of active objects is more likely to increase in an exponential fashion rather than a linear one. This leads to unexpected performance costs every time new physics objects are introduced into the simulation. We should keep this in mind when we decide to increase the physical complexity of our Scenes.</p><p>Secondly, changing any properties on a <code class="literal">Rigidbody</code> Component at runtime, such as <code class="literal">mass</code>, <code class="literal">drag</code>, and <code class="literal">useGravity</code>, will also reawaken an object. If we're regularly changing these values (such as a game where object sizes and masses change over time), then they will remain active for longer periods of time than usual. This is also the case for applying forces, so if we're using a custom gravity solution (such as suggested in the <span class="emphasis"><em>Mass</em></span> section), we should try to avoid applying the gravitational force every Fixed Update, otherwise the object will be unable to fall asleep. We could check its mass-normalized-kinetic-energy (just take the value of <code class="literal">velocity.sqrMagnitude</code>) and manually disable our custom gravity when we detect that it is very low.</p><p>Thirdly, there is the danger of islands of sleeping physics objects being generated. Islands are created when a large number of Rigidbodies are touching one another and have gradually gone to sleep once the kinetic energy of the system has fallen low enough. However, because they're all still touching one another, as soon as one of these objects is awoken, it will start a chain reaction, awakening all other nearby Rigidbodies. Suddenly, we have a large spike in CPU usage because dozens of objects have re-entered the simulation. Even worse, because the objects are so close together, there will be many potential collision pairs that must keep being resolved until the objects fall asleep again.</p><p>Avoiding these situations is best done by reducing the complexity of our Scenes, but if we find ourselves unable to do so, we could look for ways to detect that islands are forming, and then strategically destroy/despawn some of them to prevent too many large islands from being generated. However, performing regular distance comparisons between all of our Rigidbodies is not a cheap task to accomplish and could be costly. The Physics Engine already performs such checks itself, during Broadphase Culling, but, unfortunately, Unity doesn't expose this data through the Physics Engine API. Any workarounds for this problem will be dependent on how the game is designed; for example, a game that requires the player to move lots of physics objects into an area (for example, a game that involves herding sheep into a pen) could choose to remove the sheep's Collider as soon as the player moves it into position, locking the object to its final destination, easing the workload on the Physics Engine and preventing islands from becoming a problem.</p><p>Sleeping objects can be a blessing and a curse. They can save us a lot of processing power, but if too many of them reawaken at the same time or our simulation is too busy to allow enough of them to fall asleep, then we could be incurring some unfortunate performance costs during gameplay. We should strive to limit these situations as much as possible by letting our objects enter the sleeping state as much as possible and avoiding grouping them together in large clusters.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip70"></a>Note</h3><p>Note that the sleep threshold can be modified under <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Physics</code></strong> | <strong class="userinput"><code>Sleep Threshold</code></strong>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec61"></a>Modify the Solver Iteration Count</h3></div></div></div><p>Using Joints, Springs, and other ways to connect Rigidbodies together are fairly complex simulations in Physics Engines. Owing to the codependent interactivity (internally represented as movement constraints) that occurs due to joining two objects together, the system must often make several attempts at solving the necessary mathematical equations. This multi-iteration approach is required to calculate an accurate result whenever there is a change in velocity to any single part of the object chain.</p><p>It, therefore, becomes a balancing act of limiting the maximum number of attempts the <span class="emphasis"><em>Solver</em></span> makes to resolve a particular situation versus how accurate a result we can get away with. We don't want the Solver to spend too much time on a single collision, because there are a lot of other tasks that the Physics Engine has to complete within the same iteration. However, we also don't want to reduce the maximum number of iterations too far, as it will only approximate what the final solution would have been, making its motion look much less believable than if it had been given more time to calculate the result.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note71"></a>Note</h3><p>The same Solver also gets involved when resolving inter-object collisions and contacts. It can almost always determine the correct result for simple collisions with a single iteration, with the exception of some very rare and complex collision situations with Mesh Colliders. It is mostly when attached objects will be affected through Joints that the Solver requires additional effort to integrate the final result.</p></div><p>The maximum number of iterations the Solver is allowed to attempt is called the <span class="emphasis"><em>Solver Iteration Count</em></span>, which can be modified under <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Physics</code></strong> | <strong class="userinput"><code>Default Solver Iterations</code></strong>. In most cases, the default value of six iterations is perfectly acceptable. However, games that include very complex Joint systems may wish to increase this count to suppress any erratic (or downright explosive) <code class="literal">CharacterJoint</code> behaviors, whereas some projects may be able to get away with reducing this count. Testing must be performed after changing this value to check whether the project still maintains the intended levels of quality. Note that this value is the <span class="emphasis"><em>default</em></span> Solver Iteration Count--the value that gets applied to any newly created Rigidbodies. We can change this value at runtime through the <code class="literal">Physics.defaultSolverIterations</code> property, but this still won't affect preexisting Rigidbodies. If necessary, we can modify their Solver Iteration Count after they are constructed through the <code class="literal">Rigidbody.solverIterations</code> property.</p><p>If we find our game regularly runs into jarring, erratic, and physics-breaking situations with complex Joint-based objects (such as Ragdolls), then we should consider gradually increasing the Solver Iteration Count until the problems are suppressed. These problems typically occur if our Ragdolls absorb too much energy from colliding objects and the Solver is unable to iterate the solution down to something reasonable before it is asked to give up. At this point, one of the Joints goes supernova, dragging the rest of them into orbit along with it. Unity has a separate setting for this problem, which can be found under <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Physics</code></strong> | <strong class="userinput"><code>Default Solver Velocity Iterations</code></strong>. Increasing this value will give the Solver more opportunity to calculate a sensible velocity during Joint-based object collisions and help to avoid the above scenario. Again, this is a default value, hence it is only applied to newly created Rigidbodies. The value can be modified at runtime through the <code class="literal">Physics.defaultSolverVelocityIterations</code> property and can be customized on specific Rigidbodies through the <code class="literal">Rigidbody.solverVelocityIterations</code> property.</p><p>In either case, increasing the number of iterations will consume more CPU resources during every Fixed Update where the Joint objects remain active.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note72"></a>Note</h3><p>Note that the Physics 2D settings for solver iterations are named <strong class="userinput"><code>Position Iterations</code></strong> and <strong class="userinput"><code>Velocity Iterations</code></strong>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec62"></a>Optimize Ragdolls</h3></div></div></div><p>Speaking of Joint-based objects, Ragdolls are incredibly popular features for good reason; they're tons of fun! Ignoring the morbidity of flinging corpses around a game world for the moment, there's something about watching a complex chain of objects flail around and smash into things that hits a lot of psychological fun buttons. This makes it very tempting to allow many Ragdolls to coexist within our Scene at the same time, but as we quickly discover, this risks an enormous performance hit when too many Ragdolls are in motion and/or collide with other objects due to the amount of iterations the Solver would need to resolve them all. So, let's explore some ways to improve the performance of Ragdolls.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec47"></a>Reduce Joints and Colliders</h4></div></div></div><p>Unity provides a simple Ragdoll-generation tool (the Ragdoll Wizard) under <strong class="userinput"><code>GameObject</code></strong> | <strong class="userinput"><code>3D Object</code></strong> | <strong class="userinput"><code>Ragdoll…</code></strong>. This tool can be used to create Ragdolls from a given object by selecting the appropriate child <code class="literal">GameObjects</code> to attach <code class="literal">Joint</code> and <code class="literal">Collider</code> Components to for any given body part or limb. This tool always creates 13 different Colliders and associated Joints (pelvis, chest, head, two Colliders per arm, and three Colliders per leg).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip73"></a>Note</h3><p>Note that a bug causes the Ragdoll Wizard not to complain if nothing is assigned to <strong class="userinput"><code>Left Foot</code></strong> or <strong class="userinput"><code>Right Foot</code></strong><code class="literal">Transform</code> Component references like it does for the rest of them, but Unity will throw a <code class="literal">NullReferenceException</code> if we try to create the mesh without them assigned. Ensure that all 13 <code class="literal">Transform</code> Component references have been assigned when we try to create a Ragdoll.</p></div><p>However, it's possible to use only seven Colliders (pelvis, chest, head, and one Collider per limb) to greatly reduce the overhead cost at the expense of Ragdoll realism. This can be achieved by deleting unwanted Colliders and manually reassigning the Character Joint's <code class="literal">connectedBody</code> properties to the proper parent joints (connect the arm Colliders to the chest, and connect the leg Colliders to the pelvis).</p><p>Note that we assign a <code class="literal">mass</code> value during Ragdoll creation using the Ragdoll Wizard. This mass value is spread across the various Joints as appropriate and, therefore, represents the total mass of the object. We should ensure that we don't apply a mass value too high or too low compared to other objects in our game to avoid potential instability.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec48"></a>Avoid inter-Ragdoll collisions</h4></div></div></div><p>The performance cost of Ragdolls grows exponentially when Ragdolls are allowed to collide with other Ragdolls, since any Joint collision requires the Solver to calculate the resultant velocity applied to all of the Joints connected to it and then each of the Joints connected to them, such that both Ragdolls must be completely resolved multiple times. Also, it gets significantly more complicated if multiple parts of the Ragdolls are likely to collide with one another during the same collision.</p><p>This is a tough task for the Solver to handle, so we should avoid it. The best way to do this is to simply use the Collision Matrix. It is wise to assign all Ragdolls to their own Layer and uncheck the corresponding checkbox in the Collision Matrix so that objects in the given Layer cannot collide with objects in the same Layer.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec49"></a>Replace, deactivate or remove inactive Ragdolls</h4></div></div></div><p>In some games, once a Ragdoll has reached its final <span class="emphasis"><em>destination</em></span>, we no longer need it to remain in the game world as an interactable object. We could then either deactivate, destroy, or replace the Ragdoll with a simpler alternative when they are no longer needed (a good trick is to replace them with the simpler version that uses only seven Joints as suggested earlier). Such simplifications are often implemented as a means of reducing overhead for weaker hardware/lower quality settings or as a compromise to allow more Ragdolls to coexist in our Scene. It could even be used dynamically if a particular number of Ragdolls is already present.</p><p>We would need some object to keep track of all of our Ragdolls, being notified any time a Ragdoll is created, keeping track of how many Ragdolls currently exist, watching each of them until they fall asleep through <code class="literal">RigidBody.IsSleeping()</code> and then do something appropriate with them. The same object could also choose to instantiate simpler Ragdoll variations if the Scene already contains more Ragdolls than is reasonable. This would be another good opportunity to make use of the Messaging System we explored in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>.</p><p>Whichever approach we choose to improve the performance of our Ragdolls will no doubt result in limiting Ragdolls as a gameplay feature, either by instantiating fewer of them, giving them less complexity, or giving them a shorter lifetime, but these are reasonable compromises to make given the performance-saving opportunities.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec63"></a>Know when to use physics</h3></div></div></div><p>The most obvious method to improve the performance of a feature is to avoid using it as much as possible. For all moveable objects in our game, we should take a moment to ask ourselves if getting the Physics Engine involved is even necessary. If not, we should look for opportunities to replace them with something simpler and less costly.</p><p>Perhaps we're using physics to detect whether the player fell into a kill-zone (water, lava, a death-plummet, and so on), but our game is simple enough that we only have kill-zones at a specific height. In this case, we could avoid physics Colliders altogether and get away with only checking whether the player's <span class="emphasis"><em>y</em></span>-position falls below a particular value.</p><p>Consider the following example--we're trying to simulate a meteor shower, and our first instinct was to have many falling objects that move via physics Rigidbodies, detect collisions with the ground via Colliders, and then generate an explosion at the point of impact. However, perhaps the ground is consistently flat or we have access to the Terrain's Height Map for some rudimentary collision detection. In this case, object travel could be simplified by manually tweening the objects' <code class="literal">transform.position</code> over time to simulate the same traveling behavior without requiring any Physics Components. In both cases, we can reduce the physics overhead by simplifying the situation and pushing the work into Script code.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip74"></a>Note</h3><p><span class="emphasis"><em>Tweening</em></span> is a common short-hand term for in-betweening, which is the act of interpolating variables from one value to another gradually over time. There are many useful (and free) tweening libraries available on the Unity Asset Store that can provide a lot of useful functionality. Although, be careful of potentially poor optimization in these libraries.</p></div><p>The reverse is also possible. There might be occasions where we're performing a great deal of calculation through Script code that could be handled through physics relatively simply. For example, we might have implemented an inventory system with many objects that can be picked up. When the player hits the <code class="literal">Pick Up Object</code> key, each of these objects might be compared against the player's position to figure out which object is the closest.</p><p>We could consider replacing all of the Script code with a single <code class="literal">Physics.OverlapSphere()</code> call to get nearby objects when the key is pressed, and then figure out the closest pickup object from the result (or, better yet, just automatically pick up all of them. Why make the player repeatedly click more than necessary?). This could greatly reduce the total number of objects that must be compared each time the key is pressed, although comparisons should be made to ensure that this is the case.</p><p>Ensure that you seek to remove unnecessary physics grunt work from your Scenes or use physics to replace behavior that is costly when performed through Script code. The opportunities are as wide and far reaching as your own ingenuity. The ability to recognize opportunities like this takes experience, but is a vital skill that will serve you well when saving performance in current and future game development projects.</p></div></div>