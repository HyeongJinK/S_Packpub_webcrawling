<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec12"></a>Faster GameObject null reference checks</h2></div></div><hr /></div><p>It turns out that performing a <code class="literal">null</code> reference check against a <code class="literal">GameObject</code> will result in some unnecessary performance overhead. <code class="literal">GameObjects</code> and <code class="literal">MonoBehaviours</code> are special objects compared to a typical C# object in that they have two representations in memory: one exists within the memory managed by the same system managing the C# code we write (Managed code), whereas the other exists in a different memory space which is handled separately (Native code). Data can move between these two memory spaces, but each time this happens will result in some additional CPU overhead and possibly an extra memory allocation.</p><p>This effect is commonly referred to as crossing the <span class="emphasis"><em>Native-Managed Bridge</em></span>. If this happens, it is likely to generate an additional memory allocation for an object’s data to get copied across the Bridge, which will require the Garbage Collector to eventually perform some automatic cleanup of memory for us. This subject will be explored in much more detail in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>, but for the time-being just consider that there are many subtle ways to accidentally trigger this extra overhead, and a simple <code class="literal">null</code> reference check against a <code class="literal">GameObject</code> is one of them:</p><pre class="programlisting">if (gameObject != null) {
  // do stuff with gameObject
}</pre><p>An alternative that generates a functionally equivalent output which operates around twice as quickly (although it does obfuscate the purpose of the code a little) is <code class="literal">System.Object.ReferenceEquals()</code>:</p><pre class="programlisting">if (!System.Object.ReferenceEquals(gameObject, null)) {
  // do stuff with gameObject
}</pre><p>This applies to both <code class="literal">GameObjects</code> and <code class="literal">MonoBehaviours</code>, as well as other Unity objects, which have both Native and Managed representations like the <code class="literal">WWW</code> class. However, some rudimentary testing reveals that either <code class="literal">null</code> reference check approach still consumes mere nanoseconds on an Intel Core i5 3570K processor. So, unless you are performing massive amounts of <code class="literal">null</code> reference checks, the gains might be marginal at best. However, this is a warning worth keeping in mind for the future, as it will come up a lot.</p></div>