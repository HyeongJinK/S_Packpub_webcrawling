<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec53"></a>Scripting tips</h2></div></div><hr /></div><p>The following tips are useful features to know when scripting.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec133"></a>General</h3></div></div></div><p>We can modify various templates of new script, Shader, and Compute Shader files. This can be helpful to remove the empty Update stubs, which as we covered in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>, can cause unnecessary runtime overhead. These files can be found in the following locations:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Windows:  <code class="literal">&lt;Unity install&gt;\Editor\Data\Resources\ScriptTemplates\</code></li><li style="list-style-type: disc">MacOS:  <code class="literal">/Applications/Unity/Editor/Data/Resources/ScriptTemplates/</code></li></ul></div><p>The <code class="literal">Assert</code> class allows for assert-based debugging, which some developers are more comfortable with as opposed to exception-based debugging. Check out the Unity documentation for more information on Asserts at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Assertions.Assert.html" target="_blank">http://docs.unity3d.com/ScriptReference/Assertions.Assert.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec134"></a>Attributes</h3></div></div></div><p>Attributes are very useful meta-level tags that can be given to almost any target in C#. They are most commonly used on fields and classes, allowing us to flag them with special properties so that they can be processed differently. Intermediate and advanced Unity developers will find it worthwhile to read the C# documentation on attributes and use their imagination to come up with their own attributes that help accelerate their workflow. There are quite a few attributes built in to the Unity engine that can be exceptionally useful when used in the right place.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip132"></a>Note</h3><p>Advanced users will note that attributes can also be given to enums, delegates, methods, parameters, events, modules, and even assemblies.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec113"></a>Variable attributes</h4></div></div></div><p>The <code class="literal">[Range]</code> attribute can be added to an integer or floating-point field to convert it to a slider in the <strong class="userinput"><code>Inspector</code></strong> window. We can give minimum and maximum values, thus limiting the range that the value can contain.</p><p>Normally, if a variable is renamed, even if we do a refactor through our IDE (whether its MonoDevelop or Visual Studio), then the values are lost as soon as Unity recompiles the <code class="literal">MonoBehaviour</code> and makes the appropriate changes to any instances of the Component. However, the <code class="literal">[FormerlySerializedAs]</code> attribute is incredibly helpful if we want to rename a variable that has been previously serialized, as it will copy the data from the variable named within the attribute into the given variable during compilation time. No more lost data due to renaming stuff!</p><p>Note that it is not safe to remove the <code class="literal">[FormerlySerializedAs]</code> attribute after the conversion is completed unless the variable has been manually changed and resaved into every relevant Prefab since the attribute was included. The <code class="literal">.prefab</code> data file will still contain the old variable name, and so it still needs the <code class="literal">[FormerlySerializedField]</code> attribute to figure out where to place the data the next time the file is loaded (for example, when the Editor is closed and reopened). Thus, this is a helpful attribute, but extended use does tend to clutter up our codebase a lot.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec114"></a>Class attributes</h4></div></div></div><p>The <code class="literal">[SelectionBase]</code> attribute will mark any <code class="literal">GameObject</code> the Component is attached to as the root of selection for the <strong class="userinput"><code>Scene</code></strong> window. This is especially useful if we have meshes that are children of other objects, as we might want the parent object to be selected with the first click, instead of the object with the <code class="literal">MeshRenderer</code> Component.</p><p>If we have Components with a strong dependency, we can use the <code class="literal">[RequireComponent]</code> attribute to force level designers to attach vital Components to the same <code class="literal">GameObject</code>. This ensures that any dependencies that our codebase relies on will be satisfied by designers, without having to write out a whole bunch of documentation for them.</p><p>The <code class="literal">[ExecuteInEditMode]</code> attribute will force the object's <code class="literal">Update()</code>, <code class="literal">OnGUI()</code>, and <code class="literal">OnRenderObject()</code> callbacks to be called even during <strong class="userinput"><code>Edit Mode</code></strong>. However, there are caveats, as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">Update()</code> method is only called if something changes in the Scene, such as moving the Camera around or changing an object property</li><li style="list-style-type: disc"><code class="literal">OnGUI()</code> is only called during <strong class="userinput"><code>Game</code></strong> window events, not for other window such as the <strong class="userinput"><code>Scene</code></strong> window</li><li style="list-style-type: disc"><code class="literal">OnRenderObject()</code> is called during any repaint event for the <strong class="userinput"><code>Scene</code></strong> and <strong class="userinput"><code>Game</code></strong> windows</li></ul></div><p>However, this attribute gives such objects a different set of event hooks and entry points compared to typical Editor scripts, so it still has its uses.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec135"></a>Logging</h3></div></div></div><p>We can add rich text tags to debug strings. Tags such as <code class="literal">&lt;size&gt;</code>, <code class="literal">&lt;b&gt;</code> (bold), <code class="literal">&lt;i&gt;</code> (italics), and <code class="literal">&lt;color&gt;</code> work on debug strings. This can be helpful for differentiating the different kinds of log messages and highlighting specific elements, as follows:</p><pre class="programlisting">Debug.Log ("&lt;color=red&gt;[ERROR]&lt;/color&gt;This is a &lt;i&gt;very&lt;/i&gt; &lt;size=14&gt;&lt;b&gt;specific&lt;/b&gt;&lt;/size&gt; kind of log message");</pre><div class="mediaobject"><img src="/graphics/9781788392365/graphics/28741f9b-2719-4517-a83a-7b09df3fb55c.png" /></div><p><span>Th</span>e <code class="literal">MonoBehaviour</code> class has a <code class="literal">print()</code> method for convenience, which does the same thing as <code class="literal">Debug.Log()</code>.</p><p>It can help to create a custom logger class, which automatically appends <code class="literal">\n\n</code> to the end of every log message. This will push away the unnecessary <code class="literal">UnityEngine.Debug:Log(Object)</code> clutter that tends to fill the <strong class="userinput"><code>Console</code></strong> window.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec136"></a>Useful links</h3></div></div></div><p>Unity Technologies provide many useful tutorials on the usage of various scripting features, which primarily target beginner- and intermediate-level developers. The tutorials can be found at <a class="ulink" href="https://unity3d.com/learn/tutorials/topics/scripting" target="_blank">https://unity3d.com/learn/tutorials/topics/scripting</a>.</p><p>There's a helpful post on Unity Answers, which provides a reference list that covers many of the different scripting and compilation errors we might run across during development, found at <a class="ulink" href="http://answers.unity3d.com/questions/723845/what-are-the-c-error-messages.html" target="_blank">http://answers.unity3d.com/questions/723845/what-are-the-c-error-messages.html</a>.</p><p>Nested Coroutines is an interesting and useful area of scripting that is not well documented. However, the following third-party blog post, which covers a lot of the interesting details, should be considered when working with Nested Coroutines:</p><p><a class="ulink" href="http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper" target="_blank">http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper</a></p><p>We can figure out when a particular feature was added to the Unity API by checking the API history page at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/40_history.html" target="_blank">http://docs.unity3d.com/ScriptReference/40_history.html</a>. This page currently shows API history only up to version 5.0.0. Hopefully, Unity Technologies will update this page someday, because it can sometimes be useful to know what features were added when we're trying to support multiple versions of Unity simultaneously.</p></div></div>