<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Avoid Find() and SendMessage() at runtime</h2></div></div><hr /></div><p>The <code class="literal">SendMessage()</code> method and family of <code class="literal">GameObject.Find()</code> methods are notoriously expensive and should be avoided at all costs. The <code class="literal">SendMessage()</code> method is about 2,000 times slower than a simple function call, and the cost of the <code class="literal">Find()</code> method scales very poorly with Scene complexity since it must iterate through every <code class="literal">GameObject</code> in the Scene. It is sometimes forgivable to call <code class="literal">Find()</code> during initialization of a Scene, such as during an <code class="literal">Awake()</code> or <code class="literal">Start()</code> callback. Even in this case, it should only be used to acquire objects that we know for certain already exist in the Scene and for scenes that have only a handful of <code class="literal">GameObjects</code> in them. Regardless, using either of these methods for interobject communication at runtime is likely to generate a very noticeable overhead and potentially dropped frames.</p><p>Relying on <code class="literal">Find()</code> and <code class="literal">SendMessage()</code> is typically symptomatic of poor design, inexperience in programming with C# and Unity, or just plain laziness during prototyping. Their usage has become something of an epidemic among beginner-level and intermediate-level projects, so much so that Unity Technologies feels the need to keep reminding users to avoid using them in a real game over and over again in their documentation and at their conferences. They only exist as a less <span class="emphasis"><em>programmer-y</em></span> way to introduce new users to interobject communication, and for some special cases where they can be used in a responsible way (which are few and far between). In other words, they’re so ridiculously expensive that they break the rule of not preoptimizing our code, and it’s worth going out of our way to avoid using them if our project is going beyond the prototyping stage (which is a distinct possibility since you’re reading this book).</p><p>To be fair, Unity targets a wide demographic of users, from hobbyists, students, professionals, to those with delusions of grandeur, and also in team sizes from individual developers to hundreds of people on the same team. This results in an incredibly wide range of software development ability. When you're starting out with Unity, it can be difficult to figure out on your own what you should be doing differently, especially given how the Unity engine does not adhere to the design paradigms of many other game engines we might be familiar with. It has some foreign and quirky concepts surrounding scenes and Prefabs, does not have a built-in <span class="emphasis"><em>God Class</em></span> entry point, nor any obvious raw data storage systems to work with.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note28"></a>Note</h3><p>A God Class is a fancy name for the first object we might create in our application and whose job would be to create everything else we need based on the current context (what level to load, which subsystems to activate, and so on). These can be particularly useful if we want a single centralized location that controls the order of events as they happen during the entire lifecycle of our application.</p></div><p>This is an important topic not just for performance, but also for any real-time event-driven system design (including, but not limited to games), so it is worth exploring the subject in some detail, evaluating some alternative methods for interobject communication.</p><p>Let's start by examining a worst case example, which uses both <code class="literal">Find()</code> and <code class="literal">SendMessage()</code> to communicate between objects, and then look into ways to improve upon it.</p><p>The following is a class definition for a simple <code class="literal">EnemyManagerComponent</code> that tracks a list of <code class="literal">GameObjects</code> representing enemies in our game, and provides a <code class="literal">KillAll()</code> method to destroy them all when needed:</p><pre class="programlisting">using UnityEngine;
using System.Collections.Generic;

class EnemyManagerComponent : MonoBehaviour {
  List&lt;GameObject&gt; _enemies = new List&lt;GameObject&gt;();

  public void AddEnemy(GameObject enemy) {
    if (!_enemies.Contains(enemy)) {
      _enemies.Add(enemy);
    }
  }

  public void KillAll() {
    for (int i = 0; i &lt; _enemies.Count; ++i) {
      GameObject.Destroy(_enemies[i]);
    }
    _enemies.Clear();
  }
}</pre><p>We would then place a <code class="literal">GameObject</code> in our Scene containing this Component, and name it <span class="emphasis"><em><span>EnemyManager</span></em></span>.</p><p>The following example method attempts to instantiate a number of enemies from a given Prefab, and then notifies the <span><span class="emphasis"><em>EnemyManager</em></span> </span>object of their existence:</p><pre class="programlisting">public void CreateEnemies(int numEnemies) {
  for(int i = 0; i &lt; numEnemies; ++i) {
    GameObject enemy = (GameObject)GameObject.Instantiate(_enemyPrefab, 
                       5.0f * Random.insideUnitSphere, 
                       Quaternion.identity);
    string[] names = { "Tom", "Dick", "Harry" };
    enemy.name = names[Random.Range(0, names.Length)];
    GameObject enemyManagerObj = GameObject.Find("EnemyManager");
    enemyManagerObj.SendMessage("AddEnemy", 
                                enemy, 
                                SendMessageOptions.DontRequireReceiver);
  }
}</pre><p>Initializing data and putting method calls inside any kind of loop, which always output to the same result, is a big red flag for poor performance, and when we're dealing with expensive methods, such as <code class="literal">Find()</code>, we should always look for ways to call them as few times as possible. Ergo, one improvement we can make is to move the <code class="literal">Find()</code> call outside of the <code class="literal">for</code>-loop and cache the result in a local variable so that we don’t need to keep reacquiring the <span><span class="emphasis"><em>EnemyManager</em></span></span> object over and over again.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip29"></a>Note</h3><p>Moving the initialization of the <code class="literal">names</code> variable outside of the <code class="literal">for</code>-loop is not necessarily critical, since the Compiler is often smart enough to realize it doesn't need to keep reinitializing data that isn't being changed elsewhere. However, it does often make code easier to read.</p></div><p>Another big improvement we can implement, is to optimize our usage of the <code class="literal">SendMessage()</code> method by replacing it with a <code class="literal">GetComponent()</code> call. This replaces a very costly method with an equivalent and much cheaper alternative.</p><p>This gives us the following result:</p><pre class="programlisting">public void CreateEnemies(int numEnemies) {
  GameObject enemyManagerObj = GameObject.Find("EnemyManager");
  EnemyManagerComponent enemyMgr = enemyManagerObj.GetComponent&lt;EnemyManagerComponent&gt;();
  string[] names = { "Tom", "Dick", "Harry" };

  for(int i = 0; i &lt; numEnemies; ++i) {
    GameObject enemy = (GameObject)GameObject.Instantiate(_enemyPrefab, 
                        5.0f * Random.insideUnitSphere, 
                        Quaternion.identity);
    enemy.name = names[Random.Range(0, names.Length)];
    enemyMgr.AddEnemy(enemy);
  }
}</pre><p>If this method is called during the initialization of the Scene, and we're not overly concerned with loading time, then we can probably consider ourselves finished with our optimization work.</p><p>However, we will often need new objects that are instantiated at runtime to find an existing object to communicate with. In this example, we want new enemy objects to register with our <code class="literal">EnemyManagerComponent</code> so that it can do whatever it needs to do to track and control the enemy objects in our Scene. We would also like the <span><span class="emphasis"><em>EnemyManager</em></span></span> to handle all enemy-related behavior, so that objects calling its functions don't need to perform work on its behalf. This will improve the <span class="emphasis"><em>Coupling </em></span>(how well our codebase separates related behavioru) and <span class="emphasis"><em>Encapsulation</em></span> (how well our classes prevent outside changes to the data they manage) of our application. The ultimate aim is to find a reliable and fast way for new objects to find existing objects in the Scene without unnecessary usage of the <code class="literal">Find()</code> method, so that we can minimize complexity and performance costs.</p><p>There are multiple approaches we can take to solving this problem, each with their own benefits and pitfalls:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Assign references to preexisting objects</li><li style="list-style-type: disc">Static Classes</li><li style="list-style-type: disc">Singleton Components</li><li style="list-style-type: disc">A global Messaging System</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec13"></a>Assigning references to pre-existing objects</h3></div></div></div><p>A simple approach to the problem of interobject communication is to use Unity's built-in Serialization System. Software design purists tend to get a little combative about this feature, since it breaks <span class="emphasis"><em>Encapsulation</em></span>; it makes any field (the C# term for a member variable) marked <code class="literal">private</code> act in a way that treats them like a <code class="literal">public</code> field. However, it is a very effective tool for improving development workflow. This is particularly true when artists, designers, and programmers are all tinkering with the same product, where each has wildly varying levels of computer science and software programming knowledge, and with some of whom would prefer to stay away from modifying code files. Sometimes, it's worth bending a few rules in the name of productivity.</p><p>Whenever we create a <code class="literal">public</code> field in a <code class="literal">MonoBehaviour</code>, Unity automatically serializes and exposes the value in the <strong class="userinput"><code>Inspector</code></strong> window when the Component is selected. However, <code class="literal">public</code> fields are always dangerous from a software design perspective. These variables can be changed through code at anytime from anywhere, making it hard to keep track of the variable and is liable to introduce a lot of unexpected bugs.</p><p>A better solution, is to take any <code class="literal">private</code> or <code class="literal">protected</code> member variable of a class and expose it to the <strong class="userinput"><code>Inspector</code></strong> window with the <code class="literal">[SerializeField]</code> attribute. The value will now behave like a <code class="literal">public</code> field with respect to the <strong class="userinput"><code>Inspector window, allowing us to change it through the Editor interface for convenience, but </code></strong>keeps the data safely encapsulated from other parts of our codebase. </p><p>For example, the following class exposes three <code class="literal">private</code> fields to the <strong class="userinput"><code>Inspector</code></strong> window:</p><pre class="programlisting">using UnityEngine;

public class EnemyCreatorComponent : MonoBehaviour {
  [SerializeField] private int _numEnemies;
  [SerializeField] private GameObject _enemyPrefab;
  [SerializeField] private EnemyManagerComponent _enemyManager;

  void Start() {
    for (int i = 0; i &lt; _numEnemies; ++i) {
      CreateEnemy();
    }
  }

  public void CreateEnemy() {
    _enemyManager.CreateEnemy(_enemyPrefab); 
  }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip30"></a>Note</h3><p>Note that the <code class="literal">private</code> access specifiers shown in the preceding code are redundant keywords in C#, since fields and methods default to <code class="literal">private</code> unless specified otherwise. However, it is often best practice to be explicit about the intended access level.</p></div><p>Looking at this Component in the <strong class="userinput"><code>Inspector</code></strong>window reveals three values, initially given default values of <code class="literal">0</code>, or <code class="literal">null</code>, which can be modified through the Editor interface:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/7a2a11af-0146-47da-8dc6-35809b2455f4.png" /></div><p>We can drag-and-drop a Prefab reference from the <strong class="userinput"><code>Project</code></strong> window into the <strong class="userinput"><code>Enemy Prefab</code></strong> field revealed in the <strong class="userinput"><code>Inspector</code></strong> window.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip31"></a>Note</h3><p>Note how Unity automatically takes a camel-cased field name and creates a convenient <strong class="userinput"><code>Inspector</code></strong> window name for it. <code class="literal">_numEnemies</code> becomes <strong class="userinput"><code><span>Num Enemie</span>s</code></strong>, <code class="literal">_enemyPrefab</code> becomes <strong class="userinput"><code><span>Enemy</span> Prefab</code></strong> and so on.</p></div><p>Meanwhile, the <code class="literal">_enemyManager</code> field is interesting because it is a reference to a specific <code class="literal">MonoBehaviour</code> class type. If a <code class="literal">GameObject</code> is dragged-and-dropped into this field, then it will refer to the <span>Component</span> on the given object as opposed to the <code class="literal">GameObject</code> itself. Note that if the <code class="literal">GameObject</code> does not contain the expected <code class="literal">MonoBehaviour</code>, then nothing will be assigned to the field.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip32"></a>Note</h3><p>A common usage of this Component reference technique is to obtain references to other Components attached to the very same <code class="literal">GameObject</code> a Component is attached to. This is an alternative means of caching Components with zero cost, as discussed in the section entitled <span class="emphasis"><em>Cache Component references</em></span> earlier in this chapter.</p></div><p>There is some danger to using this method. Much of our code would assume that a Prefab is assigned to a field that is used like a Prefab and a <code class="literal">GameObject</code> is assigned to a field that refers to an instance of a <code class="literal">GameObject</code>. However, since Prefabs are essentially <code class="literal">GameObjects</code>, any Prefab or <code class="literal">GameObject</code> can be assigned to a serialized <code class="literal">GameObject</code> reference field, which means we could assign the wrong type by accident.</p><p>If we do assign the wrong type then we could accidentally instantiate a new <code class="literal">GameObject</code> from an existing <code class="literal">GameObject</code> that was previously modified, or we could make changes to a Prefab, which would then change the state of all <code class="literal">GameObjects</code> instantiated from it. To make matters worse, any accidental changes to a Prefab become permanent since Prefabs occupy the same memory space whether Play Mode is active or not. This is the case even if the Prefab is only modified during Play Mode.</p><p>Therefore, this approach is a very team-friendly way of solving the problem of interobject communication, but it is not ideal due to all of the risks involved with team members accidentally leaving <code class="literal">null</code> references in place, assigning Prefabs to references that expect an instance of a <code class="literal">GameObject</code> from the Scene, or vice versa.</p><p>It is also important to note that not all objects can be serialized and revealed in the <strong class="userinput"><code>Inspector</code></strong> window. Unity can serialize all primitive data types (<code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">string</code>, and <code class="literal">bool</code>), various built-in types (<code class="literal">Vector3</code>, <code class="literal">Quaternion</code>, and so on); <code class="literal">enum</code>, <code class="literal">class</code>, <code class="literal">struct</code>, and various data structures containing other serializable types such as <code class="literal">List</code>. However, it is unable to serialize <code class="literal">static</code> fields, <code class="literal">readonly</code> fields, properties, and dictionaries.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip33"></a>Note</h3><p>Some Unity developers like to implement pseudo-serialization of dictionaries via two separate lists for keys and values, along with a Custom Editor script, or via a single list of <code class="literal">struct</code> objects, which contain both keys and values. Both of these solutions are a little clumsy, and rarely as performant as a proper dictionary, but they can still be useful.</p></div><p>Another solution to the problem of interobject communication is to try and make use of globally accessible objects in order to minimize the number of custom assignments we need to make.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec14"></a>Static Classes</h3></div></div></div><p>This approach involves creating a class that is globally accessible to the entire codebase at any time. Any kind of global <span class="emphasis"><em>manager</em></span> class is often frowned upon in software engineering circles, partly since the name <span class="emphasis"><em>manager</em></span> is vague and doesn't say much about what it's meant to do, but mostly because problems can be difficult to debug. Changes can occur from anywhere and at any point during runtime, and such classes tend to maintain state information that other systems rely upon. It is also perhaps the most difficult approach to change or replace, since many of our classes might contain direct function calls into it, requiring each to be modified at a future date if it were to be replaced. Despite all of these drawbacks, it is by far the easiest solution to understand and implement.</p><p>The Singleton design pattern is a common way of ensuring only one instance of a certain object type ever exists in memory. This design pattern is implemented by giving the class a <code class="literal">private</code> constructor, a <code class="literal">static</code> variable is maintained to keep track of the object instance, and the class can only be accessed through a <code class="literal">static</code> property it provides. Singletons can be useful for managing shared resources or <span class="emphasis"><em>heavy data traffic</em></span>, such as file access, downloads, data parsing, and messaging. A Singleton ensures that we have a single entry point for such activities, rather than having tons of different subsystems competing for shared resources and potentially bottlenecking one another.</p><p>Singletons don't necessarily have to be globally accessible objects--their most important feature is that only a single instance of the object exists at a time. However, the way that Singletons are primarily used in most projects is to be a global access point to some shared functionality, and are designed to be created once during application initialization, persist through the entire lifecycle of the application, and only destroyed during application shutdown. As such, a simpler way of implementing this kind of behavior in C# is to use a <span>Static Class</span>. In other words, implementing the typical Singleton design pattern in C# just provides the same behavior as a Static Class, but takes more time and code to implement.</p><p>A Static Class that functions in much the same way as the <code class="literal">EnemyManagerComponent</code> as demonstrated in the previous example, can be defined as follows:</p><pre class="programlisting">using System.Collections.Generic;
using UnityEngine;

public static class StaticEnemyManager {
  private static List&lt;Enemy&gt; _enemies;

  public static void CreateEnemy(GameObject prefab) {
    string[] names = { "Tom", "Dick", "Harry" };
    GameObject enemy = GameObject.Instantiate(prefab, 5.0f * 
    Random.insideUnitSphere, Quaternion.identity);
    Enemy enemyComp = enemy.GetComponent&lt;Enemy&gt;();
    enemy.gameObject.name = names[Random.Range(0, names.Length)];
    _enemies.Add(enemyComp);
  }

  public static void KillAll() {
    for (int i = 0; i &lt; _enemies.Count; ++i) {
      _enemies[i].Die();
      GameObject.Destroy(_enemies[i].gameObject);
    }
    _enemies.Clear();
  }
}</pre><p>Note that every method, property, and field in a Static Class must have the <code class="literal">static</code> keyword attached, which implies that only one instance of this object will ever reside in memory. This also means that its <code class="literal">public</code> methods and fields are accessible from anywhere. Static Classes, by definition, do not allow any non-<code class="literal">static</code> fields to be defined.</p><p>If a Static Class' fields need to be initialized (such as the <code class="literal">_enemies</code> field, which is initially set to <code class="literal">null</code>), then Static Class fields can be initialized inline like so:</p><pre class="programlisting">private static List&lt;Enemy&gt; _enemies = new List&lt;Enemy&gt;();</pre><p>However, if object construction needs to be more complicated than this, then Static Classes can be given a <code class="literal">static</code> constructor, instead. The Static Class' constructor is automatically called the moment the class is first accessed through any it's fields, properties, or methods, and can be defined like so:</p><pre class="programlisting">static StaticEnemyManager() {
  _enemies = new List&lt;Enemy&gt;();
  // more complicated initialization activity goes here
}</pre><p>This time we have implemented the <code class="literal">CreateEnemy()</code> method so that it handles much of the activity for creating an enemy object. However, the Static Class must still be given a reference to a Prefab from which it can instantiate an enemy object from. A Static Class can only contain <code class="literal">static</code> member variables, and therefore cannot easily interface with the <strong class="userinput"><code>Inspector</code></strong> window in the same way that <code class="literal">MonoBehaviours</code> can, therefore requiring the caller to provide some implementation-specific information to it. To solve this problem, we could implement a companion-Component for our Static Class to keep our code properly <span class="emphasis"><em>Decoupled</em></span>. The following code demonstrates what this class might look like:</p><pre class="programlisting">using UnityEngine;

public class EnemyCreatorCompanionComponent : MonoBehaviour {
  [SerializeField] private GameObject _enemyPrefab;

  public void CreateEnemy() {
    StaticEnemyManager.CreateEnemy(_enemyPrefab);
  }
}</pre><p>Despite these drawbacks, the <code class="literal">StaticEnemyManager</code> class illustrates a simple example of how a Static Class might be used to provide information or communication between external objects, providing a better alternative than using <code class="literal">Find()</code> or <code class="literal">SendMessage()</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Singleton Components</h3></div></div></div><p>As mentioned previously, Static Classes have difficulty interfacing with Unity-related functionality, and cannot directly make use of <code class="literal">MonoBehaviour</code> features, such as event callbacks, Coroutines, hierarchical design, and Prefabs. Also, since there's no object to select in the <strong class="userinput"><code>Inspector</code></strong> window, we lose the ability to inspect the a Static Class' data at runtime through the <strong class="userinput"><code>Inspector</code></strong> window, which can make debugging difficult. These are features that we may wish to make use of in our global classes.</p><p>A common solution to this problem is to implement a Component that acts like a Singleton--it provides <code class="literal">static</code> methods to grant global access, and only one instance of the <code class="literal">MonoBehaviour</code> is ever allowed to exist at any given time.</p><p>The following is the definition for a <code class="literal">SingletonComponent</code> class:</p><pre class="programlisting">using UnityEngine;

public class SingletonComponent&lt;T&gt; : MonoBehaviour where T : SingletonComponent&lt;T&gt; {
  private static T __Instance;

  protected static SingletonComponent&lt;T&gt; _Instance {
    get {
      if(!__Instance) {
        T [] managers = GameObject.FindObjectsOfType(typeof(T)) as T[];
        if (managers != null) {
          if (managers.Length == 1) {
            __Instance = managers[0];
            return __Instance;
          } else if (managers.Length &gt; 1) {
            Debug.LogError("You have more than one " + 
                            typeof(T).Name + 
                            " in the Scene. You only need " + 
                            "one - it's a singleton!");
            for(int i = 0; i &lt; managers.Length; ++i) {
              T manager = managers[i];
              Destroy(manager.gameObject);
            }
          }
        }
        GameObject go = new GameObject(typeof(T).Name, typeof(T));
        __Instance = go.GetComponent&lt;T&gt;();
        DontDestroyOnLoad(__Instance.gameObject);
      }
      return __Instance;
    }
    set {
      __Instance = value as T;
    }
  }
}</pre><p>This class works by creating a <code class="literal">GameObject</code> containing a Component of itself the first time it is accessed. Since we wish this to be a global and persistent object, we will need to call <code class="literal">DontDestroyOnLoad()</code> shortly after the <code class="literal">GameObject</code> is created. This is a special function that tells Unity that we want the object to persist between scenes for as long as the application is running. From that point onward, when a new Scene is loaded, the object will not be destroyed and will retain all of its data.</p><p>This class definition assumes two things. Firstly, because it is using <span class="emphasis"><em>generics</em></span> to define its behavior, it must be derived from in order to create a concrete class. Secondly, a method must be defined to assign the <code class="literal">_Instance</code> property (which in turns sets the private <code class="literal">__Instance </code> field) and cast it to/from the correct class type.</p><p>For example, the following is the minimum amount of code that is needed to successfully generate a new <code class="literal">SingletonComponent</code> derived class called <code class="literal">EnemyManagerSingletonComponent</code>:</p><pre class="programlisting">public class EnemyManagerSingletonComponent : SingletonComponent&lt; EnemyManagerSingletonComponent &gt; {
  public static EnemyManagerSingletonComponent Instance {
    get { return ((EnemyManagerSingletonComponent)_Instance); }
    set { _Instance = value; }
  }

  public void CreateEnemy(GameObject prefab) {
    // same as StaticEnemyManager
  }

  public void KillAll() {
    // same as StaticEnemyManager
  }
}</pre><p>This class can be used at runtime by having any other object access the <code class="literal">Instance</code> property at any time. If the Component does not already exist in our Scene, then the <code class="literal">SingletonComponent</code> base class will instantiate its own <code class="literal">GameObject</code> and attach an instance of the derived class to it as a Component. From that point forward, access through the <code class="literal">Instance</code> property will reference the Component that was created, and only one instance of this Component will exist at a time.</p><p>Note that this means we don't need to implement <code class="literal">static</code> methods in a Singleton Component class definition. For example, we could simply call <code class="literal">EnemyManagerSingletonComponent.Instance.KillAll()</code> to access the <code class="literal">KillAll()</code> method. </p><p>Note that it is possible to place an instance of a <code class="literal">SingletonComponent</code> in a <strong class="userinput"><code>Hierarchy</code></strong> window since it derives from <code class="literal">MonoBehaviour</code>. Although, be warned that the <code class="literal">DontDestroyOnLoad()</code> method would never be called, which would prevent the Singleton Component's <code class="literal">GameObject</code> from persisting when the next Scene is loaded. We will perhaps need to call <code class="literal">DontDestroyOnLoad()</code> in the derived class' <code class="literal">Awake()</code> callback to make this work, unless, of course, we actually want destructible <span>Singletons</span>. Sometimes it makes sense to allow such Singletons to be destroyed between scenes so that it can start fresh each time; it all depends on our particular use cases.</p><p>In either case, shutdown of a Singleton Component can be a little convoluted because of how Unity tears down scenes. An object's <code class="literal">OnDestroy()</code> callback is called whenever it is destroyed during runtime. The same method is called during application shutdown, whereby every Component on each <code class="literal">GameObject</code> has its <code class="literal">OnDestroy()</code> callback called by Unity. The same activities take place when we end Play Mode in the Editor, thus returning to Edit Mode. However, destruction of objects occurs in a random order, and we cannot assume that the <code class="literal">SingletonComponent</code> object will be the last object destroyed.</p><p>Consequently, if any object attempts to do anything with the Singleton Component in the middle of their <code class="literal">OnDestroy()</code> callback, then they may be calling the <code class="literal">SingletonComponent</code> object's <code class="literal">Instance</code> property. However, if the Singleton Component has already been destroyed prior to this moment, then a new instance of the <code class="literal">SingletonComponent</code> will be created in the middle of application shutdown. This can corrupt our Scene files, as instances of our Singleton Components will be left behind in the Scene. If this happens, then Unity will throw the following error message:</p><p>"<strong class="userinput"><code>Some objects were not cleaned up when closing the scene. (Did you spawn new GameObjects from OnDestroy?)</code></strong>"</p><p>The obvious workaround is to simply never call into a <code class="literal">SingletonComponent</code> object during any <code class="literal">MonoBehaviour</code> Component's <code class="literal">OnDestroy()</code> callback. However, there are some legitimate reasons we may wish to do so: most notable is that Singletons are often designed to make use of the <span>Observer</span> design pattern. This design pattern allows other objects to register/deregister with them for certain tasks, similar to how Unity latches onto callback methods, such as <code class="literal">Start()</code> and <code class="literal">Update()</code>, but in a more strict fashion.</p><p>With the Observer design pattern, objects will typically register with the system when they are created, will make use of it during runtime, and then either deregister from it during runtime when they are finished using it or deregister during their own shutdown for the sake of cleanup. We will see an example of this design pattern in the upcoming section, <span class="emphasis"><em>A global Messaging System</em></span>, but if we imagine a <code class="literal">MonoBehaviour</code> making use of such a system, then the most convenient place to perform shutdown deregistration would be within an <code class="literal">OnDestroy()</code> callback. Consequently, such objects are likely to run into the aforementioned problem, where a new <code class="literal">GameObject</code> for the <code class="literal">SingletonComponent</code> is accidentally created during application shutdown.</p><p>To solve this problem, we will need to make three changes. Firstly, we need to add an additional flag to the <code class="literal">SingletonComponent</code>, which keeps track of its active state and disable it at the appropriate times. This includes the Singleton's own destruction, as well as application shutdown (<code class="literal">OnApplicationQuit()</code> is another useful Unity callback for <code class="literal">MonoBehaviours</code>, which is called during this time):</p><pre class="programlisting">private bool _alive = true;
void OnDestroy() { _alive = false; }
void OnApplicationQuit() { _alive = false; }</pre><p>Secondly, we should implement a way for external objects to verify the Singleton's current state:</p><pre class="programlisting">public static bool IsAlive {
  get {
    if (__Instance == null)
      return false;
    return __Instance._alive;
  }
}</pre><p>Finally, any object that attempts to call into the Singleton during its own <code class="literal">OnDestroy()</code> method must first verify the state using the <code class="literal">IsAlive</code> property before calling instance, as follows:</p><pre class="programlisting">public class SomeComponent : MonoBehaviour {
  void OnDestroy() {
    if (MySingletonComponent.IsAlive) {
        MySingletonComponent.Instance.SomeMethod();
    }
  }
}</pre><p>This will ensure that nobody attempts to access the Singleton instance during destruction. If we don't follow this rule, then we will run into problems where instances of our Singleton object will be left behind in the Scene after returning to Edit Mode.</p><p>The irony of the <code class="literal">SingletonComponent</code> approach is that we are using a <code class="literal">Find()</code> call to determine whether or not one of these <code class="literal">SingletonComponent</code> objects already exists in the Scene before we attempt to assign the <code class="literal">__Instance</code> reference variable. Fortunately, this will only happen when the Singleton Component is first accessed, which is usually not a problem if there aren’t too many <code class="literal">GameObjects</code> in the Scene, but it's possible that the initialization of the Singleton Component may not necessarily occur during Scene initialization and can, therefore, cost us a performance spike at a bad moment during gameplay when an instance is first acquired and <code class="literal">Find()</code> gets called. The workaround for this is to have some God Class confirm that the important Singletons are instantiated during Scene initialization by simply accessing the <code class="literal"><span>Instance</span></code> property on each one.</p><p>Another downside to this approach is that if we later decide that we want more than one of these Singletons executing at once or we wish to separate out its behavior to be more modular, then there would be a lot of code that needs to change.</p><p>The final approach we will explore will attempt to solve many of the problems revealed by the previous solutions and provide a way to gain all of their benefits, by combining ease of implementation, ease of extension, and strict usage that also reduces the likelihood of human-error during configuration.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>A global Messaging System</h3></div></div></div><p>The final suggested approach to solve the problem of interobject communication is to implement a global Messaging System that any object can access and send messages through to any object that may be interested in listening to that specific type of message. Objects can send messages or listen for them (sometimes both!), and the responsibility is on the listener to decide what messages they are interested in. The message sender can broadcast the message without caring at all who is listening, and a message can be sent through the system regardless of the specific contents of the message. This approach is by far the most complex and may require some effort to implement and maintain, but it is an excellent long-term solution to keep our object communication modular, decoupled, and fast as our application gets more and more complex.</p><p>The kinds of message we wish to send can take many forms, including data values, references, instructions for listeners, and more, but they should all have a common, basic definition that our Messaging System can use to determine what the message is and who it is intended for.</p><p>The following is a simple class definition for a <code class="literal"><span>Message</span></code> object:</p><pre class="programlisting">public class Message {
  public string type;
  public Message() { type = this.GetType().Name; }
}</pre><p>The <code class="literal">Message</code> class' constructor caches the message's <code class="literal">type</code> in a local <code class="literal">string</code> property to be used later for cataloging and distribution purposes. Caching this value is important, as each call to <code class="literal">GetType().Name</code> will result in a new string being allocated, and we've previously learned that we want to minimize this activity as much as possible.</p><p>Any custom messages can contain whatever superfluous data they wish so long as they derive from this base class, which will allow it to be sent through our Messaging System. Take note that despite acquiring the <code class="literal">type</code> from the object during its base class constructor, the <code class="literal">name</code> property will still contain the name of the derived class, not the base class.</p><p>Moving on to our <code class="literal">MessagingSystem</code> class, we should define its features by what kind of requirements we need it to fulfill:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span>It shou</span>ld be globally accessible</li><li style="list-style-type: disc">Any object (<code class="literal">MonoBehaviour</code> or not) should be able to register/deregister as listeners to receive specific message types (that is, the Observer design pattern)</li><li style="list-style-type: disc">Registering objects should provide a method to call when the given message is broadcasted from elsewhere</li><li style="list-style-type: disc">The system should send the message to all listeners within a reasonable time frame, but not choke on too many requests at once</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec11"></a>A globally accessible object</h4></div></div></div><p>The first requirement makes the Messaging System an excellent candidate for a Singleton object, since we would only ever need one instance of the system. Although, it is wise to think long and hard if this is truly the case before committing to implementing a Singleton.</p><p>If we later decide that we want multiple instances of this object to exist, wish to allow the systems to be created/destroyed during runtime, or even wish to create test cases that allow us to fake or create/destroy them in the middle of a test, then it can be difficult task to refactor a Singleton out of our codebase. This is due to all of the dependencies we will gradually introduce to our code as we use the system more and more.</p><p>If we wish to avoid Singletons due to the above drawbacks, then it may be easier to create a single instance of the Messaging System during initialization and then pass it around from subsystem to subsystem as needed, or we might wish to go further and explore the concept of <span>Dependency Inj</span>ection, which attempts to solve problems like these. However, for the sake of simplicity, we will assume that a Singleton fits our needs and design our <code class="literal">MessagingSystem</code> class accordingly.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec12"></a>Registration</h4></div></div></div><p>The second and third requirements can be achieved by offering some public methods that allow registration with the Messaging System. If we force the listening object to provide us a delegate function to call when the message is broadcast, then this allows listeners to customize which method is called for which message. We can make our codebase very easy to understand if we name the delegate after the message it is intended to process.</p><p>In some cases, we might wish to broadcast a general notification message and have all listeners do something in response, such as an <span class="emphasis"><em>Enemy Created</em></span> message. Other times, we might be sending a message that specifically targets a single listener among a group. For example, we might want to send an <span class="emphasis"><em>Enemy Health Value Changed</em></span> message that is intended for a specific <span class="emphasis"><em>Health Bar</em></span> object that is attached to the enemy that was damaged. However, we may have many health bar objects in the Scene, all of which are interested in this message type, but each is only interested in hearing health update messages for the enemy they're providing health information for. So, if we implement a way for the system to stop checking after it has been handled, then we can probably save a good number of CPU cycles when there are many listeners waiting for the same message type.</p><p>The delegate we define should, therefore, provide a way to retrieve the message via an argument and return a response that determines whether or not processing for the message should stop if and when the listener is done with it. The decision on whether to stop processing or not can be achieved by returning a simple Boolean, where <code class="literal">true</code> implies that this listener has handled the message and the processing for the message must stop, and <code class="literal">false</code> implies that this listener has not handled the message and the Messaging System should try the next listener.</p><p>Here is the definition for the delegate:</p><pre class="programlisting">public delegate bool MessageHandlerDelegate(Message message);</pre><p>Listeners must define a method of this form and pass a delegate reference to the Messaging System during registration, thus providing a means for the Messaging System to tell the listening object when the message is being broadcast.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec13"></a>Message processing</h4></div></div></div><p>The final requirement for our Messaging System is that this object should have some kind of timing-based mechanism built in to prevent it from choking on too many messages at once. This means that, somewhere in the codebase, we will need to make use of <code class="literal">MonoBehaviour</code> event callbacks to tell our Messaging System to perform work during Unity's <code class="literal">Update()</code>, essentially enabling it to count time.</p><p>This could be achieved with the Static Class Singleton (which we defined earlier), which would require some other <code class="literal">MonoBehaviour</code>-based God Class to call into it, informing it that the Scene has been updated. Alternatively, we can use the Singleton Component to achieve the same thing, which has its own means of determining when <code class="literal">Update()</code> is called, and hence handle its workload independently of any God Class. The most notable difference between the two approaches is whether or not the system is dependent on the control of other objects and the various pros and cons of managing a Singleton Component (such that it won’t get destroyed between scenes; we don’t want to accidentally recreate it during shutdown).</p><p>The Singleton Component approach is probably the best, since there aren't too many occasions where we wouldn't want this system acting independently, even if much of our game logic depends upon it. For example, even if the game was paused, we wouldn't want the game logic to pause our Messaging System. We still want the Messaging System to continue receiving and processing messages so that we can, for example, keep UI-related Components communicating with one another while the gameplay is in a paused state.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec14"></a>Implementing the Messaging System</h4></div></div></div><p>Let's define our Messaging System by deriving from the <code class="literal">SingletonComponent</code> class and provide a method for objects to register with it:</p><pre class="programlisting">using System.Collections.Generic;
using UnityEngine;

public class MessagingSystem : SingletonComponent&lt;MessagingSystem&gt; {
  public static MessagingSystem Instance {
    get { return ((MessagingSystem)_Instance); }
    set { _Instance = value; }
  }

  private Dictionary&lt;string,List&lt;MessageHandlerDelegate&gt;&gt; _listenerDict = new Dictionary&lt;string,List&lt;MessageHandlerDelegate&gt;&gt;();

  public bool AttachListener(System.Type type, MessageHandlerDelegate handler) {
    if (type == null) {
      Debug.Log("MessagingSystem: AttachListener failed due to having no " + 
                "message type specified");
      return false;
    }

    string msgType = type.Name;
    if (!_listenerDict.ContainsKey(msgType)) {
      _listenerDict.Add(msgType, new List&lt;MessageHandlerDelegate&gt;());
    }

    List&lt;MessageHandlerDelegate&gt; listenerList = _listenerDict[msgType];
    if (listenerList.Contains(handler)) {
      return false; // listener already in list
    }

    listenerList.Add(handler);
    return true;
  }
}</pre><p>The <code class="literal">_listenerDict</code> field is a dictionary of strings mapped to lists containing <code class="literal">MessageHandlerDelegate</code>. This dictionary organizes our listener delegates into lists by which message type they wish to listen to. Thus, if we know what message type is being sent, then we can quickly retrieve a list of all delegates that have been registered for that message type. We can then iterate through the list, querying each listener to check whether one of them wants to handle it.</p><p>The <code class="literal">AttachListener()</code> method requires two parameters: a message type in the form of its <code class="literal">System.Type</code> and a <code class="literal">MessageHandlerDelegate</code> to send the message to when the given message type comes through the system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec15"></a>Message queuing and processing</h4></div></div></div><p>In order to process messages, our Messaging System should maintain a queue of incoming message objects so that we can process them in the order they were broadcast:</p><pre class="programlisting">private Queue&lt;Message&gt; _messageQueue = new Queue&lt;Message&gt;();

public bool QueueMessage(Message msg) {
  if (!_listenerDict.ContainsKey(msg.type)) {
    return false;
  }
  _messageQueue.Enqueue(msg);
  return true;
}</pre><p>The <code class="literal">QueueMessage()</code> method simply checks whether the given message type is present in our dictionary before adding it to the queue. This effectively tests whether or not an object actually cares to listen to the message before we queue it to be processed later. We have introduced a new <code class="literal">private</code> field, <code class="literal">_messageQueue</code>, for this purpose.</p><p>Next, we'll add a definition for <code class="literal">Update()</code>. This callback will be called regularly by the Unity Engine. Its purpose is to iterate through the current contents of the message queue, one message a time, verify whether or not too much time has passed since we began processing, and if not, pass them along to the next stage in the process:</p><pre class="programlisting">private const int _maxQueueProcessingTime = 16667;
private System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();

void Update() {
  timer.Start();
  while (_messageQueue.Count &gt; 0) {
    if (_maxQueueProcessingTime &gt; 0.0f) {
      if (timer.Elapsed.Milliseconds &gt; _maxQueueProcessingTime) {
         timer.Stop();
         return;
      }
    }

    Message msg = _messageQueue.Dequeue();
    if (!TriggerMessage(msg)) {
      Debug.Log("Error when processing message: " + msg.type);
    }
  }
}</pre><p>The time-based safeguard is in place to make sure that it does not exceed a processing time limit threshold. This prevents the Messaging System from freezing our game if too many messages get pushed through the system too quickly. If the total time limit is exceeded, then all message processing will stop, leaving any remaining messages to be processed during the next frame.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip34"></a>Note</h3><p>Note that we use the full namespace when creating the <code class="literal">Stopwatch</code> object. We could have added <code class="literal">using System.Diagnostics</code>, but this would lead to a namespace conflict between <code class="literal">System.Diagnostics.Debug</code> and <code class="literal">UnityEngine.Debug</code>. Omitting it allows us to continue to call Unity's debug logger with <code class="literal">Debug.Log()</code>, without having to explicitly call <code class="literal">UnityEngine.Debug.Log()</code> each time.</p></div><p>Lastly, we will need to define the <code class="literal">TriggerMessage()</code> method, which distributes messages to listeners:</p><pre class="programlisting">public bool TriggerMessage(Message msg) {
  string msgType = msg.type;
  if (!_listenerDict.ContainsKey(msgType)) {
    Debug.Log("MessagingSystem: Message \"" + msgType + "\" has no listeners!");
    return false; // no listeners for message so ignore it
  }

  List&lt;MessageHandlerDelegate&gt; listenerList = _listenerDict[msgType];

  for(int i = 0; i &lt; listenerList.Count; ++i) {
    if (listenerList[i](msg))
      return true; // message consumed by the delegate
    }
    return true;
  }  
}</pre><p>The preceding method is the main workhorse behind the Messaging System. The <code class="literal">TriggerEvent()</code> method's purpose is to obtain the list of listeners for the given message type and give each of them an opportunity to process it. If one of the delegates returns <code class="literal">true</code>, then processing of the current message ceases and the method exits, allowing the <code class="literal">Update()</code> method to process the next message.</p><p>Normally, we would want to use <code class="literal">QueueEvent()</code> to broadcast messages, but we also provide direct access to <code class="literal">TriggerEvent()</code> as an alternative. Using <code class="literal">TriggerEvent()</code> directly allows message senders to force their messages to be processed immediately without waiting for the next <code class="literal">Update()</code> event. This bypasses the throttling mechanism, which might be necessary for messages that need to be sent during critical moments of gameplay, where waiting an additional frame might result in a strange-looking behavior.</p><p>For example, if we intend for two objects to be destroyed and create a Particle Effect the moment they collide with one another, and this work is handled by another subsystem (hence an event needs to be sent for it), then we would want to send the message via <code class="literal">TriggerEvent()</code> to prevent the objects from continuing to exist for one frame before the event is handled. Conversely, if we wanted to do something less frame-critical, such as create a pop-up message when the player walks into a new area, we could safely use a <code class="literal">QueueEvent()</code> call to handle it.</p><p>Try to avoid habitually using <code class="literal">TriggerEvent()</code> for all events, as we could end up handling too many calls simultaneously in the same frame, causing a sudden drop in frame rate. Decide which events are frame-critical, and which are not, and use the <code class="literal">QueueEvent()</code> and <code class="literal">TriggerEvent()</code> methods appropriately.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec16"></a>Implementing custom messages</h4></div></div></div><p>We've created the Messaging System, but an example of how to use it would help us wrap our heads around the concept. Let's start by defining a pair of simple classes that derive from <code class="literal">Message</code>, which we can use to create a new enemy, as well as notify other parts of our codebase that an enemy was created:</p><pre class="programlisting">public class CreateEnemyMessage : Message {}

public class EnemyCreatedMessage : Message {

  public readonly GameObject enemyObject;
  public readonly string enemyName;

  public EnemyCreatedMessage(GameObject enemyObject, string enemyName) {
    this.enemyObject = enemyObject;
    this.enemyName = enemyName;
  }
}</pre><p><code class="literal">CreateEnemyMessage</code> is the simplest form of message that contains no special data, while <code class="literal">EnemyCreatedMessage</code> will contain a reference to the enemy's <code class="literal">GameObject</code> as well as its name. Good practice for message objects is to make their member variables not only <code class="literal">public</code>, but also <code class="literal">readonly</code>. This ensures that the data is easily accessible but cannot be changed after the object's construction. This safeguards the content of our messages against being altered, as they're passed between one listener and another.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec17"></a>Message sending</h4></div></div></div><p>To send one of these message objects, we simply need to call either <code class="literal">QueueEvent()</code> or <code class="literal">TriggerEvent()</code> and pass it an instance of the message we wish to send. The following code demonstrates how we would broadcast a <code class="literal">CreateEnemyMessage</code> object when the <span class="emphasis"><em>Space Bar</em></span> is pressed:</p><pre class="programlisting">public class EnemyCreatorComponent : MonoBehaviour {
  void Update() {
    if (Input.GetKeyDown(KeyCode.Space)) {
      MessagingSystem.Instance.QueueMessage(new CreateEnemyMessage()); 
    }
  }
}</pre><p>If we were to test this code right now, nothing would happen, because even though we are sending a message through the Messaging System, there are no listeners for this message type. Let's cover how to register listeners with the Messaging System.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec18"></a>Message registration</h4></div></div></div><p>The following code contains a pair of simple classes that register with the Messaging System, each requesting to have one of their methods called whenever certain types of messages have been broadcast from anywhere in our codebase:</p><pre class="programlisting">
public class EnemyManagerWithMessagesComponent : MonoBehaviour {
  private List&lt;GameObject&gt; _enemies = new List&lt;GameObject&gt;();
  [SerializeField] private GameObject _enemyPrefab;

  void Start() {
    MessagingSystem.Instance.AttachListener(typeof(CreateEnemyMessage), 
                                            this.HandleCreateEnemy);
  }

  bool HandleCreateEnemy(Message msg) {
    CreateEnemyMessage castMsg = msg as CreateEnemyMessage;
    string[] names = { "Tom", "Dick", "Harry" };
    GameObject enemy = GameObject.Instantiate(_enemyPrefab, 
                       5.0f * Random.insideUnitSphere, 
                       Quaternion.identity);
    string enemyName = names[Random.Range(0, names.Length)];
    enemy.gameObject.name = enemyName;
    _enemies.Add(enemy);
    MessagingSystem.Instance.QueueMessage(new EnemyCreatedMessage(enemy, 
                                                                  enemyName));
    return true;
  }
}

public class EnemyCreatedListenerComponent : MonoBehaviour {
  void Start () {
    MessagingSystem.Instance.AttachListener(typeof(EnemyCreatedMessage), 
                                            HandleEnemyCreated);
  }

  bool HandleEnemyCreated(Message msg) {
    EnemyCreatedMessage castMsg = msg as EnemyCreatedMessage;
    Debug.Log(string.Format("A new enemy was created! {0}", 
                            castMsg.enemyName));
    return true;
  }
}</pre><p>During initialization, the <code class="literal">EnemyManagerWithMessagesComponent</code> class registers to receive messages of the type <code class="literal">CreateEnemyMessage</code>, and will process the message through it's <code class="literal">HandleCreateEnemy()</code> delegate. During this method, it can typecast the message into the appropriate derived message type and resolves the message in its own unique way. Other classes can register for the same message and resolve it differently through its own custom delegate method (assuming that an earlier listener didn't return <code class="literal">true</code> from its own delegate).</p><p>We know what type of message will be provided by the <code class="literal">msg</code> argument of the <code class="literal">HandleCreateEnemy()</code> method, because we defined it during registration through the <code class="literal">AttachListener()</code> call. Due to this, we can be certain that our typecasting is safe, and we can save time by not having to do a <code class="literal">null</code> reference check, although, technically, there is nothing stopping us using the same delegate to handle multiple message types. In these cases, though, we will need to implement a way to determine which message object is being passed and treat it accordingly. However, the best approach is to define a unique method for each message type in order to keep things appropriately decoupled. There really is little benefit in trying to use one monolithic method to handle all message types.</p><p>Note how the <code class="literal">HandleEnemyCreated()</code> method definition matches the function signature of <code class="literal">MessageHandlerDelegate</code> (that is, it has the same return type and argument list), and that it is being referenced in the <code class="literal">AttachListener()</code> call. This is how we tell the Messaging System what method to call when the given message type is broadcast, and how delegates ensure type-safety. If the function signature had a different return value or a different list of arguments, then it would be an invalid delegate for the <code class="literal">AttachListener()</code> method, and we would get compiler errors. Also, note that <code class="literal">HandleEnemyCreated()</code> is also a <code class="literal">private</code> method, and yet our <code class="literal">MessagingSystem</code> class is able to call it. This is a useful feature of delegates in that we can allow only systems we give permission to call this message handler. Exposing the method publicly might lead to some confusion in our code’s API, and developers may think that they’re meant to call the method directly, which is not its intended use.</p><p>The beautiful part is that we're free to give the delegate method whatever name we want. The most sensible approach is to name the method after the message which it handles. This makes it clear to anyone reading our code what the method is used for and what message object type must be sent in order to call it. This makes future parsing and debugging of our code much more straight-forward since we can follow the chain of events by the matching names of the messages and their handler delegates.</p><p>During the <code class="literal">HandleCreateEnemy()</code> method, we also queue another event, which broadcasts an <code class="literal">EnemyCreatedMessage</code> instead. The second class, <code class="literal">EnemyCreatedListenerComponent</code> registers to receive these messages, and then prints out a message containing that information. This is how we would implement a way for subsystems to notify other subsystems of changes. In a real application, we might register a UI system to listen for these types of messages, and update a counter on the screen to show how many enemies are now active. In this case, the enemy management and UI systems are appropriately <span class="emphasis"><em>decoupled</em></span> such that neither needs to know any specific information about how the other operates in order to do their assigned tasks.</p><p>If we now add the <code class="literal">EnemyManagerWithMessagesComponent</code>, <code class="literal">EnemyCreatorComponent</code> and <code class="literal">EnemyCreatedListenerComponent</code> to our Scene, and press the <span class="emphasis"><em>Space Bar</em></span> several times, we should see log messages appear in the <strong class="userinput"><code>Console</code></strong> window, informing us of a successful test:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/30cd8098-01a7-4fe8-9509-dd32431064d5.png" /></div><p>Note that a <code class="literal">MessagingSystem</code> Singleton object will be created during Scene initialization, when either the <code class="literal">EnemyManagerWithMessagesComponent</code> object's or <code class="literal">EnemyCreatedListenerComponent</code> object's <code class="literal">Start()</code> methods are called (whichever happens first), since that is when they register their delegates with the Messaging System, which accesses the <code class="literal">Instance</code> property, and hence creates the necessary <code class="literal">GameObject</code> containing the Singleton Component. No additional effort is required on our part to create the <code class="literal">MessagingSystem</code> object.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec19"></a>Message cleanup</h4></div></div></div><p>Since message objects are classes, they will be created dynamically in memory and will be disposed of shortly afterward when the message has been processed and distributed among all listeners. However, as you will learn in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>, this will eventually result in a garbage collection, as memory accumulates over time. If our application runs for long enough, it will eventually result in the occasional garbage collection, which is the most common cause of unexpected and sudden CPU performance spikes in Unity applications. Therefore, it is wise to use the Messaging System sparingly and avoid spamming messages too frequently on every update.</p><p>The more important clean-up operation to consider is deregistration of delegates if an object needs to be destroyed. If we don't handle this properly, then the Messaging System will hang on to delegate references that prevent objects from being fully destroyed and freed from memory.</p><p>Essentially, we will need to pair every <code class="literal">AttachListener()</code> call with an appropriate <code class="literal">DetachListener()</code> call when the object is destroyed, disabled, or we otherwise decide that we no longer need it to be queried when messages are being sent.</p><p>The following method definition in the <code class="literal">MessagingSystem</code> class will detach a listener for a specific event:</p><pre class="programlisting">public bool DetachListener(System.Type type, MessageHandlerDelegate handler) {
  if (type == null) {
    Debug.Log("MessagingSystem: DetachListener failed due to having no " + 
              "message type specified");
    return false;
  }

  string msgType = type.Name;

  if (!_listenerDict.ContainsKey(type.Name)) {
    return false;
  }

  List&lt;MessageHandlerDelegate&gt; listenerList = _listenerDict[msgType];
  if (!listenerList.Contains (handler)) {
    return false;
  }
  listenerList.Remove(handler);
  return true;
}</pre><p>Here is an example usage of the <code class="literal">DetachListener()</code> method added to our <code class="literal">EnemyManagerWithMessagesComponent</code> class:</p><pre class="programlisting">void OnDestroy() {
  if (MessagingSystem.IsAlive) {
    MessagingSystem.Instance.DetachListener(typeof(EnemyCreatedMessage), 
                                            this.HandleCreateEnemy);
  }
}</pre><p>Note how this definition makes use of the <code class="literal">IsAlive</code> property declared in the <code class="literal">SingletonComponent</code> class. This safeguards us against the aforementioned problem of accidentally creating a new <code class="literal">MessagingSystem</code> during application shutdown, since we can never guarantee that the Singleton gets destroyed last.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec20"></a>Wrapping up the Messaging System</h4></div></div></div><p>Congratulations are in order, as we have finally built a fully functional global Messaging System that any and all objects can interface with, and use it to send messages between one another. A useful feature of this approach is that it is <code class="literal">Type</code>-agnostic, meaning that the message senders and listeners do not even need to derive from any particular class in order to interface with the Messaging System; it just needs to be a class that provides a message type and a delegate function of the matching function signature, which makes it accessible to both ordinary classes and <code class="literal">MonoBehaviours</code>.</p><p>As far as benchmarking the <code class="literal">MessagingSystem</code> class goes, we will find that it is capable of processing hundreds, if not thousands, of messages in a single frame with minimal CPU overhead (depending on the CPU, of course). The CPU usage is essentially the same, whether one message is being distributed to 100 different listeners or 100 messages are distributed to just one listener. Either way, it costs about the same.</p><p>Even if we're predominantly sending messages during UI or gameplay events, this probably has far more power than we need. So, if it does seem to be causing performance problems, then it's far more likely to be caused by what the listener delegates are doing with the message than the Messaging System's ability to process those messages.</p><p>There are many ways to enhance the Messaging System to provide more useful features we may need in the future, as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Allow message senders to suggest a delay (in time or frame count) before a message is delivered to its listeners</li><li style="list-style-type: disc">Allow message listeners to define a priority for how urgently it should receive messages compared to other listeners waiting for the same message type. This is a means for listeners to skip to the front of the queue if it was registered later than other listeners</li><li style="list-style-type: disc">Implement some safety checks to handle situations where a listener gets added to the list of message listeners for a particular message while a message of that type is still being processed. Currently, C# will throw an <code class="literal">EnumerationException</code> at us since the delegate list will be changed by <code class="literal">AttachListener()</code>, while it is still being iterated through in <code class="literal">TriggerEvent()</code></li></ul></div><p>At this point, we probably explored the Messaging System enough, so these tasks will be left as an academic exercise for you to undertake, if you become comfortable using this solution in your games. Let's continue to explore more ways to improve performance through script code.</p></div></div></div>