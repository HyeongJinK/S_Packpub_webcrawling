<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec47"></a>Profiling memory</h2></div></div><hr /></div><p>There are two issues we are concerned about when it comes to memory management: how much we're consuming, and how often we're allocating new blocks. Let's cover each of these topics separately.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec101"></a>Profiling memory consumption</h3></div></div></div><p>We do not have direct control over what is going on in the Native Domain since we don't have the Unity Engine source code and hence can't add any code that will interact with it directly. We can, however, control it indirectly by means of various script-level functions that serve as interaction points between Managed and Native Code. There are technically a variety of memory allocators available, which are used internally for things such as <code class="literal">GameObjects</code>, Graphics objects, and the Profiler, but these are hidden behind the Native-Managed Bridge.</p><p>However, we can observe how much memory has been allocated and reserved in this Memory Domain via the <strong class="userinput"><code>Memory Area</code></strong> of the <strong class="userinput"><code>Profiler</code></strong> window. Native memory allocations show up under the values labeled <strong class="userinput"><code>Unity</code></strong>, and we can even get more information using <strong class="userinput"><code><strong class="userinput"><code>Detailed</code></strong> Mode</code></strong> and sampling the current frame:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/8451f213-7fde-4c77-b866-0a3e0d26e1e4.png" /></div><p>Under the <strong class="userinput"><code>Scene Memory</code></strong> section of <strong class="userinput"><code>Breakdown View</code></strong>, we can observe that <code class="literal">MonoBehaviour</code> objects always consume a constant amount of memory, regardless of their member data. This is the memory consumed by the Native representation of the object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip115"></a>Note</h3><p>Note that memory consumption in <strong class="userinput"><code>Edit Mode</code></strong> is always wildly different to that of a stand-alone version due to various debugging and editor hook data being applied. This adds a further incentive to avoid using <strong class="userinput"><code>Edit Mode</code></strong> for benchmarking and instrumentation purposes.</p></div><p>We can also use the <code class="literal">Profiler.GetRuntimeMemorySize()</code> method to get the Native memory allocation size of a particular object.</p><p>Managed object representations are intrinsically linked to their Native representations. The best way to minimize our Native memory allocations is to simply optimize our Managed memory usage.</p><p>We can verify how much memory has been allocated and reserved for the Managed Heap using the <strong class="userinput"><code>Memory Area</code></strong> of the <strong class="userinput"><code>Profiler</code></strong> window, under the values labeled <strong class="userinput"><code>Mono</code></strong>, as follows:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/2a6b9a12-8066-4129-8c81-82f8732773c1.png" /></div><p>We can also determine the current used and reserved heap space at runtime using the <code class="literal">Profiler.GetMonoUsedSize()</code> and  <code class="literal">Profiler.GetMonoHeapSize()</code> methods, respectively.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec102"></a>Profiling memory efficiency</h3></div></div></div><p>The best metric we can use to measure the health of our memory management is simply watching the behavior of the GC. The more work it's doing, the more waste we're generating and the worse our application's performance is likely to become.</p><p>We can use both the <strong class="userinput"><code>CPU Usage Area</code></strong> (the <strong class="userinput"><code>GarbageCollector</code></strong> checkbox) and <strong class="userinput"><code>Memory Area</code></strong> (the <strong class="userinput"><code>GC Allocated</code></strong> checkbox) of the <strong class="userinput"><code>Profiler</code></strong> window to observe the amount of work the GC is doing and the time it is doing it. This can be relatively straightforward for some situations, where we only allocated a temporary small block of memory or we just destroyed a <code class="literal">GameObject</code>.</p><p>However, root-cause analysis for memory efficiency problems can be challenging and time-consuming. When we observe a spike in the GC's behavior, it could be a symptom of allocating too much memory in a previous frame and merely allocating a little more in the current frame, requiring the GC to scan a lot of fragmented memory, determine whether there is enough space, and decide whether to allocate a new block. The memory it cleaned up could have been allocated a long time ago, and we may only be able to observe these effects when our application runs over long periods of time and could even happen when our Scene is sitting relatively idle, giving no obvious cause for the GC to suddenly trigger. Even worse, the Profiler can only tell us what happened in the last few seconds or so, and it won't be immediately obvious what data was being cleaned up.</p><p>We must be vigilant and test our application rigorously, observing its memory behavior while simulating a typical play session if we want to be certain we are not generating memory leaks or creating a situation where the GC has too much work to complete in a single frame.</p></div></div>