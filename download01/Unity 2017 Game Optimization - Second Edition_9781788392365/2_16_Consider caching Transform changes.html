<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec16"></a>Consider caching Transform changes</h2></div></div><hr /></div><p>The <code class="literal">Transform</code> Component stores data only relative to its own parent. This means that accessing and modifying a <code class="literal">Transform</code> Component's <code class="literal">position</code>, <code class="literal">rotation</code>, and/or <code class="literal">scale</code> properties can potentially result in a lot of unanticipated matrix multiplication calculations to generate the correct <code class="literal">Transform</code> representation for the object through its parent <code class="literal">Transforms</code>. The deeper the object is in the <strong class="userinput"><code>Hierarchy</code></strong> window, the more calculations are needed to determine the final result. </p><p>However, this also means that using <code class="literal">localPosition</code>, <code class="literal">localRotation</code>, and <code class="literal">localScale</code> have a relatively trivial cost associated with them, since these are the values stored directly in the given <code class="literal">Transform</code> and can be retrieved without any additional matrix multiplication. Therefore, these local property values should be used whenever possible.</p><p>Unfortunately, changing our mathematical calculations from world-space to local-space can over-complicate what were originally simple (and solved) problems, so making such changes risks breaking our implementation and introducing a lot of unexpected bugs. Sometimes, it's worth absorbing a minor performance hit in order to solve a complex 3D mathematical problem more easily.</p><p>Another problem with constantly changing a <code class="literal">Transform</code> Component's properties is that is also sends internal notifications to Components like <code class="literal">Collider</code>, <code class="literal">Rigidbody</code>, <code class="literal">Light</code>, and <code class="literal">Camera</code> which must also be processed since the Physics and Rendering Systems both need to know the new value of the <code class="literal">Transform</code> and update accordingly.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip27"></a>Note</h3><p>The speed of these internal notifications were improved dramatically in Unity 5.4 due to the reorganization of <code class="literal">Transforms</code> in memory in Unity 5.4, as mentioned previously, but we still need to be aware of their costs.</p></div><p>It is not uncommon, during a complex event chain, that we replace a <code class="literal">Transform</code> Component's properties multiple times in the same frame (although this is probably a warning sign of over-engineered design). This would cause the internal messages to fire each and every time this happens, even if they occur during the same frame, or even the same function call. Ergo, we should consider minimizing the number of times we modify <code class="literal">Transform</code> properties by caching them in a member variable and committing them only at the end of the frame, as follows:</p><pre class="programlisting">private bool _positionChanged;
private Vector3 _newPosition;

public void SetPosition(Vector3 position) {
  _newPosition = position;
  _positionChanged = true;
}

void FixedUpdate() {
  if (_positionChanged) {
    transform.position = _newPosition;
    _positionChanged = false;
  }
}</pre><p>This code will only commit changes to <code class="literal">position</code> in the next <code class="literal">FixedUpdate()</code> method.</p><p>Note that changing the <code class="literal">Transform</code> in this manner does not result in strange-looking behavior or teleporting objects during gameplay. The whole purpose of those internal events are to make sure the Physics and Rendering Systems are always synchronized with the current <code class="literal">Transform</code> state. Hence, Unity doesn't skip a beat and fires the internal events every time changes come through the <code class="literal">Transform</code> Component just to be sure nothing gets missed.</p></div>