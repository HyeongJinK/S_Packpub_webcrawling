<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec25"></a>Materials and Shaders</h2></div></div><hr /></div><p>Render State in Unity is essentially exposed to us via Materials. Materials are a container around Shaders, short programs that define how the GPU should render incoming vertex and texture data. A Shader on its own does not have the necessary knowledge of state to accomplish anything of value. A Shader requires inputs such as diffuse textures, Normal maps, and lighting information and effectively dictates what Render State variables need to be set in order to render the incoming data.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"></a>Note</h3><p><span class="emphasis"><em>Shaders</em></span> are named this way because their original implementation many years ago was to only handle lighting and <span class="emphasis"><em>shading</em></span> of an object (applying shadows, where originally there were none). Their purpose has grown enormously since then, and now they have a much more generic purpose of being a programmable access point to many different kinds of parallel tasks, but the old name still remains.</p></div><p>Every Shader needs a Material, and every Material must have a Shader. Even newly imported meshes introduced into the Scene without an assigned Material are automatically assigned a default (hidden) Material, which gives them a basic diffuse Shader and a white coloration. So, there is no way of getting around this relationship.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip40"></a>Note</h3><p>Note that a single Material can only support a single Shader. The use of multiple Shaders on the same mesh requires separate Materials to be assigned to different parts of the same mesh.</p></div><p>Therefore, if we want to minimize how often the Render State changes, then we can do so by reducing the number of Materials we use during a Scene. This would result in two performance improvements simultaneously; the CPU will spend less time generating and transmitting instructions to the GPU each frame and the GPU won't need to stop and re-synchronize state changes as often.</p><p>Let's begin with a simple Scene in order to visualize the behavior of Materials and Batching. However, before we start, we should disable a few rendering options as they will contribute some extra Draw Calls, which might be distracting:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Navigate to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Quality</code></strong> and set <strong class="userinput"><code>Shadows</code></strong> to <strong class="userinput"><code>Disable Shadow</code></strong><strong class="userinput"><code>s</code></strong> (or select the default <strong class="userinput"><code>Fastest</code></strong> quality level)</li><li>Navigate to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Player</code></strong>, open the <strong class="userinput"><code>Other Settings</code></strong> tab, and disable <strong class="userinput"><code>Static Batching</code></strong> and <strong class="userinput"><code>Dynamic Batching</code></strong> if they are enabled</li></ol></div><p>Next, we'll create a Scene that contains a single Directional Light with four cubes and four spheres, where each object has its own unique Material, position, rotation, and scale:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/13aafe04-aae4-4357-a5b8-87337923b7c8.png" /></div><p>In the preceding screenshot, in the <strong class="userinput"><code>Batching</code></strong> value in the <strong class="userinput"><code>Game</code></strong> window's <strong class="userinput"><code>Stats</code></strong> popup, we can see 9 total batches. This value closely represents the number of Draw Calls used to render the Scene. The current view will consume one of these batches rendering the background of the Scene, which could be set to <strong class="userinput"><code>Skybox</code></strong> or <strong class="userinput"><code>Solid Color</code></strong>. This is determined by the Camera object's <strong class="userinput"><code>Clear Flags</code></strong> settings.</p><p>The remaining 8 batches are used to draw our 8 objects. In each case, the Draw Call involves preparing the Rendering Pipeline using the Material's properties and asking the GPU to render the given mesh at its current transform. We have ensured that each Material is unique by giving them each a unique texture file to render. Ergo, each mesh requires a different Render State, and, therefore, each of our 8 meshes requires a unique Draw Call.</p><p>As previously mentioned, we can theoretically minimize the number of Draw Calls by reducing how often we cause the system to change Render State information. So, part of the goal is to reduce the amount of Materials we use. However, if we set all objects to use the same Material, we still won't see any benefit and the number of batches remains at 9:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/10b69e1a-8506-4aa7-b663-fca0a7d6aff3.png" /></div><p>This is because we're not actually reducing the number of Render State changes nor efficiently grouping mesh information. Unfortunately, the Rendering Pipeline is not smart enough to realize we're overwriting the exact same Render State values, and then asking it to render the same meshes, over and over again.</p></div>