<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec24"></a>Draw Calls</h2></div></div><hr /></div><p>Before we discuss Dynamic Batching and Static Batching independently, let's first understand the problems that they are both trying to solve within the Rendering Pipeline. We will try to keep fairly light on the technicalities as we will explore this topic in greater detail in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Dynamic Graphics</em></span>.</p><p>The primary goal of these batching methods is to reduce the number of Draw Calls required to render all objects in the current view. At its most basic form, a Draw Call is a request sent from the CPU to the GPU asking it to draw an object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p><span class="emphasis"><em>Draw Call</em></span> is the common industry vernacular for this process, although they are sometimes referred to as <span class="emphasis"><em>SetPass Calls</em></span> in Unity, since some low-level methods are named as such. Think of it as <span class="emphasis"><em>configuring options before initiating the current rendering pass</em></span>. We will refer to them as <span class="emphasis"><em>Draw Calls</em></span> throughout the remainder of this book.</p></div><p>Before a Draw Call can be requested, several tasks need to be completed. Firstly, mesh and texture data must be pushed from the CPU memory (RAM) into GPU memory (VRAM), which typically takes place during initialization of the Scene, but only for textures and meshes the Scene file knows about. If we dynamically instantiate objects at runtime using texture and mesh data that hasn't appeared in the Scene yet, then they must be loaded at the time they are instantiated. The Scene cannot know ahead of time which Prefabs we're planning to instantiate at runtime, as many of them are hidden behind conditional statements and much of our application's behavior depends upon user input. Next, the CPU must prepare the GPU by configuring the options and rendering features that are needed to process the object that is the target of the Draw Call.</p><p>These communication tasks between the CPU and GPU take place through the underlying Graphics API, which could be DirectX, OpenGL, OpenGLES, Metal, WebGL, or Vulkan, depending on the platform we're targeting and certain graphical settings. These API calls go through a library, called a <span class="emphasis"><em>driver</em></span>, which maintains a long series of complex and interrelated settings, state variables, and datasets that can be configured and executed from our application (although drivers are designed to service multiple applications simultaneously, as well as render calls coming from multiple threads). The available features change enormously based on the graphics card we're using and the version of the Graphics API we're targeting; more advanced graphics cards support more advanced features, which would need to be supported by newer versions of the API, so updated drivers would be needed to enable them. The sheer number of settings, supported features, and compatibility levels between one version and another that have been created over the years (particularly for the older APIs such as DirectX and OpenGL) can be nothing short of mind-boggling. Thankfully, at a certain level of abstraction, all of these APIs tend to operate in a similar fashion; hence Unity is able to support many different Graphics APIs through a common interface.</p><p>This utterly massive array of settings that must be configured to prepare the Rendering Pipeline just prior to rendering an object is often condensed into a single term known as the <span class="emphasis"><em>Render State</em></span>. Until these Render State options are changed, the GPU will maintain the same Render State for all incoming objects and render them in a similar fashion.</p><p>Changing the Render State can be a time-consuming process. So, for example, if we were to set the Render State to use a blue texture file and then ask it to render one gigantic mesh, then it would be rendered very rapidly with the whole mesh appearing blue. We could then render 9 more, completely different meshes, and they would all be rendered blue, since we haven't changed which texture is being used. If, however, we wanted to render 10 meshes using 10 different textures, then this will take longer. This is because we will need to prepare the Render State with the new texture just prior to sending the Draw Call instruction for each mesh.</p><p>The texture being used to render the current object is effectively a global variable in the Graphics API, and changing a global variable within a parallel system is much easier said than done. In a massively parallel system such as a GPU, we must effectively wait until all of the current jobs have reached the same synchronization point (in other words, the fastest cores need to stop and wait for the slowest ones to catch up, wasting processing time that they could be using on other tasks) before we can make a Render State change, at which point we will need to spin up all of the parallel jobs again. This can waste a lot of time, so the less we need to ask the Render State to change, the faster the Graphics API will be able to process our requests.</p><p>Things that can trigger Render State synchronization include--but are not limited to--an immediate push of a new texture to the GPU and changing a Shader, lighting information, shadows, transparency, and pretty much any graphical setting we can think of.</p><p>Once the Render State is configured, the CPU must decide what mesh to draw, what textures and Shader it should use, and where to draw the object based on its position, rotation, and scale (all represented within a 4x4 matrix known as a <span class="emphasis"><em>transform</em></span>, which is where the <code class="literal">Transform</code> Component gets its name from) and then send an instruction to the GPU to draw it. In order to keep the communication between CPU and GPU very dynamic, new instructions are pushed into a queue known as the <span class="emphasis"><em>Command Buffer</em></span>. This queue contains instructions that the CPU has created and that the GPU pulls from each time it finishes the preceding command.</p><p>The trick to how batching improves the performance of this process is that a new Draw Call does not necessarily mean that a new Render State must be configured. If two objects share the exact same Render State information, then the GPU can immediately begin rendering the new object since the same Render State is maintained after the last object is finished. This eliminates the time wasted due to a Render State synchronization. It also serves to reduce the number of instructions that need to be pushed into the Command Buffer, reducing the workload on both the CPU and GPU.</p></div>