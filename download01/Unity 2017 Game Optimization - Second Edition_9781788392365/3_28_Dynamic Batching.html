<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec27"></a>Dynamic Batching</h2></div></div><hr /></div><p>Dynamic Batching has the following three important qualities:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Batches are generated at runtime (batches are dynamically generated)</li><li style="list-style-type: disc">The objects that are contained within a batch can vary from one frame to the next, depending on what meshes are currently visible to the <strong class="userinput"><code>Main Camera</code></strong> view (batch contents are dynamic)
</li><li style="list-style-type: disc">Even objects that can move around the Scene can be batched (it works on dynamic objects)</li></ul></div><p>Hence, these attributes lead us to the name <span class="emphasis"><em>Dynamic</em></span> Batching.</p><p>If we return to the <strong class="userinput"><code>Player Settings</code></strong> page and enable <strong class="userinput"><code>Dynamic Batching</code></strong>, we should see that the number of batches drops from 9 down to 6. Dynamic Batching automatically recognizes that our objects share Material and mesh information and is, therefore, combining some of them into a larger batch for processing.  We should also see a different list of items in the Frame Debugger, demonstrating that meshes are now being dynamically batched.</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/104d8df5-41f4-4313-8872-29553fb527d7.png" /></div><p>As we can see from the Frame Debugger, our four boxes have been combined into a single Draw Call named <strong class="userinput"><code>Dynamic Batch</code></strong>, but our four spheres are still being rendered with four separate Draw Calls. This is because the four spheres do not fit the requirements of Dynamic Batching. Despite the fact that they all use the same Material, there are many more requirements we must fulfill.</p><p>The list of the requirements needed to successfully dynamically batch a mesh can be found in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/DrawCallBatching.html" target="_blank">http://docs.unity3d.com/Manual/DrawCallBatching.html</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip43"></a>Note</h3><p>At the time of publication of this book, the previous page is a little out of date, and a better breakdown can be found in this blog post: <a class="ulink" href="https://blogs.unity3d.com/2017/04/03/how-to-see-why-your-draw-calls-are-not-batched-in-5-6/" target="_blank">https://blogs.unity3d.com/2017/04/03/how-to-see-why-your-draw-calls-are-not-batched-in-5-6/</a>.</p></div><p>The following list covers the requirements to enable Dynamic Batching for a given mesh:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">All mesh instances must use the same Material reference</li><li style="list-style-type: disc">Only <code class="literal">ParticleSystem</code> and <code class="literal">MeshRenderer</code> Components are dynamically batched. <code class="literal">SkinnedMeshRenderer</code> Components (for animated characters) and all other renderable Component types cannot be batched</li><li style="list-style-type: disc">There is a limit of 300 vertices per mesh</li><li style="list-style-type: disc">The total number of vertex attributes used by the Shader must be no greater than 900</li><li style="list-style-type: disc">Either all mesh instances should use a uniform scale or all meshes should use a nonuniform scale, but not a mixture of the two</li><li style="list-style-type: disc">Mesh instances should refer to the same Lightmap file</li><li style="list-style-type: disc">The Material's Shader should not depend on multiple passes</li><li style="list-style-type: disc">Mesh instances must not receive real-time shadows</li><li style="list-style-type: disc">There is an upper limit on the total number of mesh indices in the entire batch, which varies per-Graphics API and platform used, which is around 32k-64k indices (check out the documentation/aforementioned blog post for specifics)</li></ul></div><p>It is important to note the term <span class="emphasis"><em>Material references</em></span>, because if we happen to use two different Materials with identical settings, the Rendering Pipeline is not smart enough to realize that, and they will be treated as different Materials and, therefore, will be disqualified from Dynamic Batching. Most of the rest of these requirements have either already been explained; however, a couple of these requirements are not completely intuitive or clear from the description, which merits some additional explanation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>Vertex attributes</h3></div></div></div><p>A vertex attribute is simply a piece of information contained within a mesh file on a per-vertex basis, and each is normally represented as a group of multiple floating-point values. This includes, but is not limited to, a vertex's position (relative to the root of the mesh), a normal vector (a vector pointing away from the object's surface, most often used in lighting calculations), one or more sets of texture UV coordinates (used to define how one or more textures wrap around the mesh), and possibly even color information per-vertex (normally used in custom lighting or for a flat-shaded, low-poly style object). Only meshes with less than 900 total vertex attributes used by the Shader can be included in Dynamic Batching.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>Note that looking into a mesh's raw data file may contain less vertex attribute information than what Unity loads into memory because of how the engine converts mesh data from one of several raw data formats into an internal format. So, don't assume that the number of attributes our 3D modeling tool tells us the mesh uses will be the final count. The best way to verify the attribute count is to either drill down into the mesh object in the <strong class="userinput"><code>Project</code></strong> window until you find the <code class="literal">MeshFilter</code> Component and look at the <strong class="userinput"><code>verts</code></strong> value that appears in the <strong class="userinput"><code>Preview</code></strong> subsection of the <strong class="userinput"><code>Inspector</code></strong> window.</p></div><p>Using more attribute data per vertex within the accompanying Shader will consume more from our 900-attribute budget and hence reduce the number of vertices the mesh is allowed to have before it can no longer be used in Dynamic Batching. For example, a simple diffuse Shader might only use 3 attributes per-vertex: position, normal, and a single set of UV coordinates. Dynamic Batching would therefore be able to support meshes using this Shader, which have a combined total of 300 vertices. However, a more complex Shader, requiring 5 attributes per-vertex, would only be able support Dynamic Batching with meshes using no more than 180 vertices. Also, note that even if we are using less than 3 vertex attributes per vertex in our Shader, Dynamic Batching still only supports meshes with a maximum of 300 vertices, so only relatively simple objects are candidates for Dynamic Batching.</p><p>These restrictions are why our Scene saves only 3 Draw Calls with Dynamic Batching enabled, despite having all objects share the same Material reference. The cube mesh that is autogenerated by Unity contains a mere 8 vertices, each with position, normal, and UV data, for 24 attributes in total. This is far less than the 300-vertex limit and 900-vertex attribute limit. However, an autogenerated sphere mesh contains 515 vertices and hence 1,545 total vertex attributes. These meshes clearly exceed both the 300-vertex and 900-vertex attribute limits and, therefore, cannot be dynamically batched.</p><p>If we click on one of the Draw Call items in the Frame Debugger, there will be a section labeled "<strong class="userinput"><code>Why this draw call can't be batched with the previous one</code></strong>". Most of the time, the explanation text beneath tells us which requirement we failed and (or at least the first one it detected) which can be useful for debugging batching behavior.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip45"></a>Note</h3><p>Be warned that the explanation text that appears is currently a little buggy in an early build of Unity 2017 and sometimes the actual reason appears when you click on the <strong class="userinput"><code>DynamicBatch</code></strong> item instead. For instance, in the preceding Scene example, the explanation given for <strong class="userinput"><code>Draw Mesh Sphere (3)</code></strong> was "<strong class="userinput"><code>The material doesn't have GPU instancing enabled</code></strong>", which is a bit confusing. However, looking at the <strong class="userinput"><code>DynamicBatch</code></strong> item gave the real reason, that is, "<strong class="userinput"><code>a submesh we are trying to dynamic-batch has more than 300 vertices</code></strong>".</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>Mesh scaling</h3></div></div></div><p>The documentation suggests that objects should either share a uniform scale or each should have a unique nonuniform scale in order to be included in dynamic batching. A uniform scale means that all three components of the scale vector (<code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code>) are identical to each other (but not necessarily across meshes), and a nonuniform scale means that at least one of these values is different from the others, and meshes that fall within these two groups will be placed in two different batches.</p><p>Let's explain this via an example. Consider that we have the following four objects: A scaled at <code class="literal">(1, 1, 1)</code>, B scaled at <code class="literal">(2, 1, 1)</code>, C scaled at <code class="literal">(2, 2, 1)</code>, and D scaled at <code class="literal">(2, 2, 2)</code>. Objects A and D have uniform scales, because all three components have the same value. Even though both meshes don't have exactly the same scale, their scales still count as uniform, and so they will be placed together in one dynamic batch. Meanwhile, B and C both have nonuniform scales, because at least one component is different than the rest. They're both scaled very differently (C being scaled on the <span class="emphasis"><em>y-axis</em></span> twice as much as B), but they both still count as nonuniform, so they will be combined together in a separate batch.</p><p>However, be warned that using negative scaling has a strange effect on Dynamic Batching. Negative scaling is often a quick way to mirror a mesh in our Scene, which can save us from having to create and import a completely different mesh for something that's only flipped on one axis. This trick is commonly used for pairs of doors, or just to make a Scene look more varied. However, if we only negatively scale the mesh on one or three axes, then it will be placed into a different Dynamic Batch than meshes negatively scaled on zero or two axes. It does not matter which of the three values (<code class="literal">x</code>, <code class="literal">y</code>, or <code class="literal">z</code>) are negative, only whether the total number of negative values is odd or even.</p><p>Another strange by-product of this batch-splitting behavior is how the rendering order of the objects can determine what gets batched together. If the previous object would have appeared in a different batch group than the current one, then it cannot be batched. Again, this is best explained by the following example. Consider that we have four objects again: V scaled at <code class="literal">(1, 1, 1)</code>, W scaled at <code class="literal">(-1, 1, 1)</code>, X scaled at <code class="literal">(-1, -1, 1)</code>, Y scaled at <code class="literal">(-1, -1, -1)</code>, and finally Z scaled similarly to V at <code class="literal">(1, 1, 1)</code>. Objects V and Z share a common uniform scale, so we might expect them to be batched together. However, if all of these objects were rendered to the Scene in the above order, then object V will be rendered, and Unity will test to check whether objects W and V could share a batch. They cannot do so, because of object W's odd negative scaling, so no batching takes place. Unity will then compare object X with object W to check whether they can be batched, which they cannot because W has an odd negative scaling and X has even negative scaling. The next comparisons between objects W-Y and Y-Z fail for the same reason. The end result is that all five objects will be rendered with five separate Draw Calls, and there was no opportunity given to combine objects V and Z. Note that this weird effect only comes into play when negative scaling is used. If all scaling differences are uniform versus nonuniform, then Unity should be capable of batching the objects appropriately.</p><p>Presumably, this is all a by-product of the algorithm used to detect valid batchable groups, since mirroring a mesh in two dimensions is mathematically equivalent to rotating the mesh about both of the same axes 180 degrees, while there is no rotational equivalent to mirroring a mesh on one or three axes. Thus, the behavior we observe is perhaps just the Dynamic Batching system automatically transforming the object for us, although this isn't completely clear. Regardless, hopefully this prepares us for many of the weird situations we might run in to when it comes to generating dynamic batches.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"></a>Dynamic Batching summary</h3></div></div></div><p>Dynamic Batching is a very useful tool when we want to render very large groups of simple meshes. The design of the system makes it ideal to use when we're making use of large numbers of simple meshes, which are nearly identical in appearance. Possible situations to apply Dynamic Batching could be as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">A large forest filled with rocks, trees, and bushes</li><li style="list-style-type: disc">A building, factory, or space station with many simple, common elements (computers, corridor pieces, pipes, and so on)</li><li style="list-style-type: disc">A game featuring many dynamic, non-animated objects with simple geometry and particle effects (a game such as Geometry Wars springs to mind)</li></ul></div><p>If the only requirement preventing two objects from being Dynamically Batched together is the fact that they use different texture files, be aware that it only takes a bit of development time and effort to combine textures, and regenerate mesh UVs so that they can be Dynamically Batched together (commonly known as <span class="emphasis"><em>Atlasing</em></span>). This may cost us in texture quality or the overall size of a texture file (which can have drawbacks we will understand once we dive into the topic of GPU Memory Bandwidth in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Dynamic Graphics</em></span>), but it is worth considering.</p><p>Perhaps the only situation where Dynamic Batching may be a detriment on performance is if we were to set up a Scene with hundreds of simple objects, where only a few objects are put into each batch. In these cases, the overhead cost of detecting and generating so many small batches might cost more time than we'd save by just making a separate Draw Call for each mesh. Even still, this is unlikely.</p><p>If anything, we're far more likely to inflict performance losses on our application by simply assuming that Dynamic Batching is taking place, when we've actually forgotten one of the essential requirements. We can accidentally break the vertex limit by pushing a new version of a mesh, and in the process of Unity converting a raw Object (with the <span class="emphasis"><em>.obj</em></span> extension) file into its own internal format, it generates more vertex attributes than we expected. We could also exceed it by tweaking some Shader code or adding additional passes without realizing it would disqualify it from Dynamic Batching. We might even set up the object to enable shadows or Light Probes, which breaks another requirement.</p><p>There will be no warning when these accidents occur, save for the number of Draw Calls increasing after changes are made and causing performance to degrade further and further. Maintaining a healthy amount of Dynamic Batching in our Scenes requires constant vigilance in checking our Draw Call count and looking at Frame Debugger data to make sure that we didn't accidentally disqualify objects from Dynamic Batching during our latest changes. However, as always, we only need to worry about our Draw Call performance if we've already proven that it's causing a performance bottleneck.</p><p>Ultimately, every situation is unique, so it is worth experimenting with our mesh data, Materials, and Shaders to determine what can and cannot be dynamically batched, and performing some testing in our Scene from time to time to ensure that the number of Draw Calls we're using remains reasonable.</p></div></div>