<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>Consider using distance-squared over distance</h2></div></div><hr /></div><p>It is safe to say that CPUs are relatively good at multiplying floating-point numbers together, but relatively dreadful at calculating square-roots from them. Every time we ask a <code class="literal">Vector3</code> to calculate a distance with the <code class="literal">magnitude</code> property or with the <code class="literal">Distance()</code> method, we're asking it to perform a square-root calculation (as per Pythagorean theorem), which can cost a lot of CPU overhead compared to many other types of vector math calculations.</p><p>However, the <code class="literal">Vector3</code> class also offers a <code class="literal">sqrMagnitude</code> property, which provides the same result as distance, only the value is squared. This means that if we also square the value we wish to compare distance against, then we can perform essentially the same comparison without the cost of an expensive square-root calculation.</p><p>For example, consider the following code:</p><pre class="programlisting">float distance = (transform.position – other.transform.position).Distance();
if (distance &lt; targetDistance) {
  // do stuff
}</pre><p>This can be replaced with the following and achieve a nearly identical result:</p><pre class="programlisting">float distanceSqrd = (transform.position – other.transform.position).sqrMagnitude;
if (distanceSqrd &lt; (targetDistance * targetDistance)) {
  // do stuff
}</pre><p>The reason the result is nearly identical is because of the floating-point precision. We're likely to lose some of the precision that we would have had from using the square-root values, since the value will be adjusted to an area with a different density of representable numbers; it can land exactly on, or closer to, a more accurate representable number, or, more likely, it will land on a number with less accuracy. As a result, the comparison is not exactly the same, but, in most cases, it is close enough to be unnoticeable, and the performance gain can be quite significant for each instruction we replace in this manner.</p><p>If this minor precision loss is not important, then this performance trick should be considered. However, if precision is very important (such as running an accurate large-scale galactic space simulation), then you may want to give this tip a pass.</p><p>Note that this technique can be used for any square-root calculations, not just for distance. This is simply the most common example you might run across, and it brings to light the important <code class="literal">sqrMagnitude</code> property of the <code class="literal">Vector3</code> class. This is a property which Unity Technologies intentionally exposed for us to make use of in this manner.</p></div>