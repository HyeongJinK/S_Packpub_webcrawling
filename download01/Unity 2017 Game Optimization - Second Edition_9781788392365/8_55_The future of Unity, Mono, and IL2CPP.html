<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec49"></a>The future of Unity, Mono, and IL2CPP</h2></div></div><hr /></div><p>When the first edition of this book was written, IL2CPP was being teased in a variety of blog posts, and Unity was still running a very old version of Mono. Well, the good news is that IL2CPP has finally landed, but the bad news is Unity is <span class="emphasis"><em>still</em></span> running a very old version of Mono. This is <span>an unfortunate consequence of how various elements of the Mono Framework are licensed, meaning that Unity Technologies has only been able to update Mono on an infrequent basis.</span></p><p><span>After many years, Unity is still only able to make use of the .NET 3.5 library functionality, which is about a decade old at this point. This limits what kinds of .NET library classes we can use, restricts certain C# language features, and limits performance since many enhancements would have been made to the library during this time. </span>However, to the great relief of many Unity developers, an experimental upgrade to a more recent version of Mono has been in beta for a while and is now available in Unity 2017 by switching the <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Player</code></strong> | <strong class="userinput"><code>Configuration</code></strong> | <strong class="userinput"><code>Scripting Runtime Version</code></strong> option to <strong class="userinput"><code>Experimental (.NET 4.6 Equivalent)</code></strong>. This setting upgrades the Mono runtime and allows us to make use of the .NET 4.6 functionality, which is only a couple of years old at the time of writing.</p><p>This feature is still experimental, however. This could lead to obscure bugs and crashes until it's been deemed stable. At which point, the Mono upgrade will become permanent so that all users can enjoy it. For the time-being, we should only use this option if we need it for a vital bug fix or feature that we cannot work around. Also, there is never a guarantee that the version fixing your bug isn't going to introduce an even worse bug. However, at the very least, hope is on the horizon that Unity is serious about making the upgrade happen sooner rather than later, as there are regular bug fixes around this area each update.</p><p>Meanwhile, Unity's rollout of IL2CPP has been rapid and impressive. It currently supports a large set of modern platforms and offers some decent performance improvements. Of course, again, it is slightly unstable, and we are likely to find bugs if we use the latest and greatest beta versions of Unity.</p><p>Where things will go from here is pretty predictable; since Unity is reliant on IL2CPP for certain platforms, and others gain benefit from it, IL2CPP will continue to gain more support, more fixes, and offer more performance improvements with each passing release, and the Mono upgrade will finally land at some point in the future.</p><p>Due to the advancement of time and technology, some features of Unity have become deprecated. A few examples that have been mentioned during this book include Animators (at least when used with UI elements), the Sprite Packer tool, and the UnityScript and Boo languages (which aren't completely gone yet, but it would be wise to start learning C# scripting sooner rather than later). Other features are also planned to be dropped. The most imminent among which is dropping of all support for DirectX 9 for Windows in Unity 2017.3 (check out <a class="ulink" href="https://blogs.unity3d.com/2017/07/10/deprecating-directx-9/" target="_blank">https://blogs.unity3d.com/2017/07/10/deprecating-directx-9/</a> for more information). We can expect further deprecated features as development of Unity 2017 progresses.</p><p>Of course, there are a lot of new features as well. The bulk of the features new in Unity 2017 primarily focus on helper utilities such as Timeline, Cinemachine, the Post-Processing stack, Collaborate, and built-in Analytics. These tools are helpful to game developers, but also make Unity a little more approachable to creatives among nongaming industries, so it's a safe bet that Unity Technologies is trying to entice a broader audience, so we can expect more on that front. Of course, game developers are still reaping the benefits of Unity Technologies' hard work. Since the first edition of this book around 2 years ago, Unity Technologies have released a whole new User Interface system (including the acquisition of Text Mesh Pro); the Progressive Lightmapper along with Global Illumination, Vulkan, and Metal support; huge improvements to the WebGL platform, 2D games, Particle Systems, Physics (both 3D and 2D), and Video playback; and, of course, a massive amount of support for the XR platforms and the more popular HMDs and their controllers.</p><p>Naturally, there is even more to come in the form of feature improvements (Particles, Animation, and 2D), expanded APIs (Physics and Networking), performance enhancements, platform support (WebVR, 360 Video playback, and Apple Watch), so ensure that you check out the Unity Road Map for an idea of what Unity Technologies are working on and when we can expect them to become available at <a class="ulink" href="https://unity3d.com/unity/roadmap" target="_blank">https://unity3d.com/unity/roadmap</a>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec120"></a>The upcoming C# Job System</h3></div></div></div><p>A huge performance-enhancing feature that Unity Technologies have been teasing for a while is a feature dubbed as the <span class="emphasis"><em>C# Job System</em></span>. The feature is still in active development and has not yet made it to any release versions of Unity, but it would be wise to start becoming familiar with it sooner rather than later, as it will introduce huge changes to how Unity developers will be writing high-performance code. It is plausible that the difference in quality of a game that uses this system well, versus one that doesn't, might become very noticeable, which may cause some fragmentation of the Unity development community. It is in our best interests to understand and exploit the benefits of the new Job System so that our application will have the most potential for success.</p><p>The idea of the C# Job System is to be able to create simple tasks that run in background threads to offload work from the main thread. The C# Job System will be ideal for tasks that are <span class="emphasis"><em>embarassingly parallel</em></span> such as having hundreds of thousands of simple AI agents operating in a Scene simultaneously and really any problem that can be boiled down to thousands of small, independent operations. Of course, it can also be used for typical multithreading behavior as well, where we perform some calculations in the background that are not needed immediately. The Job System also introduces some compiler technology improvements to get an even greater performance boost than just moving the tasks to separate threads.</p><p>A big problem with writing multithreaded code is the risk of <span class="emphasis"><em>race conditions</em></span>, <span class="emphasis"><em>deadlock</em></span>, and bugs that are notoriously difficult to reproduce and debug. The C# Job System aims to make this task easier than usual (but by no means trivial). One of Unity's founders, Joachim Ante, gave a presentation on the upcoming C# Job System at Unite Europe 2017 which gives a preview of the C# Job System and takes us through the ways in which how we think about programming Unity code will need to change. Of course, this won't apply to all code we write, but it should be treated as a valuable tool where it can deployed for huge performance improvements if we understand how it works and are able to identify sensible situations in which it would help.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note129"></a>Note</h3><p><span class="emphasis"><em>Race conditions</em></span> are where two or more calculations are racing toward completion, but actual outcome depends on the order in which they finish. Imagine one thread trying to add 3 to a number, whereas another thread multiplies it by 4. The result will be different, depending on which operation happens first. <span class="emphasis"><em>Deadlock</em></span> is a problem where two or more threads are competing for shared resources, where each needs the full resource collection to complete its task, but each has reserved a separate small portion of resources and refuses to relinquish control of them to another thread, in which case, none of the threads can get any work done because neither has the complete set it needs.</p></div><p>The presentation can be found at <a class="ulink" href="https://www.youtube.com/watch?v=AXUvnk7Jws4" target="_blank">https://www.youtube.com/watch?v=AXUvnk7Jws4</a>.</p></div></div>