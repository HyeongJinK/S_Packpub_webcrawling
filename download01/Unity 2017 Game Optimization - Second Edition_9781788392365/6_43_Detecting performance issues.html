<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec39"></a>Detecting performance issues</h2></div></div><hr /></div><p>It should be obvious that due to the number of complex processes involved, there are a lot of different ways in which the GPU can become bottlenecked. Now that we have a thorough understanding of the Rendering Pipeline and how bottlenecks may occur, let's explore how to detect these problems.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec69"></a>Profiling rendering issues</h3></div></div></div><p>The Profiler can be used to quickly narrow down which of the two devices used in the Rendering Pipeline we are bottlenecked within--whether it is the CPU or GPU. We must examine the problem using both the <strong class="userinput"><code>CPU Usage</code></strong> and <strong class="userinput"><code>GPU Usage Areas</code></strong> of the <strong class="userinput"><code>Profiler</code></strong> window, as this can tell us which device is working the hardest.</p><p>The following screenshot shows <strong class="userinput"><code>Profiler</code></strong>data for a CPU-bound application. The test involved creating thousands of simple cube objects, with no batching or Shadowing techniques taking place. This resulted in an extremely large Draw Call count (around 32,000) for the CPU to generate commands for, but giving the GPU relatively little work to do due to the simplicity of the objects being rendered:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/815ccdcf-ce41-476d-94c4-cdbf92b49d68.png" /></div><p>This example shows that the CPU's <strong class="userinput"><code>Rendering</code></strong> task is consuming a large amount of cycles (around 25 ms per-frame), whereas the GPU is processing for less than 4 milliseconds, indicating that the bottleneck resides in the CPU. Note that this Profiling test was performed against a standalone app, not within the Editor. We now know that our rendering is CPU bound and can begin to apply some CPU-saving performance improvements (being careful not to introduce rendering bottlenecks elsewhere by doing so).</p><p>Meanwhile, Profiling a GPU-bound application via the Profiler is a little trickier. This time, the test involves creating a simple object requiring minimal Draw Calls, but using a very expensive Shader that samples a texture thousands of times to create an absurd amount of activity in the Back End.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip82"></a>Note</h3><p>To perform fair GPU-bound Profiling tests, you should ensure that you disable Vertical Sync through <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Quality</code></strong> | <strong class="userinput"><code>Other</code></strong> | <strong class="userinput"><code>V Sync Count</code></strong>, otherwise it is likely to pollute our data.</p></div><p>The following screenshot shows Profiler data for this test when it is run in a standalone application:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/0444479c-595e-4a83-909c-a16fd8ab6c84.png" /></div><p>As we can see in the preceding screenshot, the rendering task of the <strong class="userinput"><code>CPU Usage Area</code></strong> matches closely with the total rendering costs of the <strong class="userinput"><code>GPU Usage Area</code></strong>. We can also see that the CPU and GPU time costs at the bottom of the image are relatively similar (about 29 milliseconds each). This is somewhat confusing as we seem to be bottlenecked equally in both devices, where we would expect the GPU to be working much harder than the CPU.</p><p>In actuality, if we drill down into the <strong class="userinput"><code>Breakdown View</code></strong> of the <strong class="userinput"><code>CPU Usage Area</code></strong> using the <strong class="userinput"><code>Hierarchy Mode</code></strong>, we will note that most of the CPU time is spent on the task labeled <strong class="userinput"><code>Gfx.WaitForPresent</code></strong>. This is the amount of time that the CPU is wasting while it waits for the GPU to finish the current frame. Hence, we are in fact bottlenecked by the GPU despite appearing as though we are bound by both. Even if Multithreaded Rendering is enabled, the CPU must still wait for the Rendering Pipeline to finish before it can begin the next frame.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip83"></a>Note</h3><p><strong class="userinput"><code>Gfx.WaitForPresent</code></strong> is also used to signal that the CPU is waiting on Vertical Sync to complete, hence the need to disable it for this test.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec70"></a>Brute-force testing</h3></div></div></div><p>If we're pouring over our Profiling data and still not sure where the source of the problem resides, or we're GPU-bound and need to determine where we're bottlenecked in the Rendering Pipeline, we should try the brute-force method, that is, cull a specific activity from the Scene and check whether it results in greatly improved performance. If a small change results in a big speed improvement, then we have a strong clue about where the bottleneck lies. There's no harm in this approach if we eliminate enough unknown variables to ensure that the data is leading us in the right direction.</p><p>The obvious brute-force test for CPU bounding will be to reduce Draw Calls to check whether performance suddenly improves. However, this is often not possible since, presumably, we've already been reducing our Draw Calls to a minimum through techniques such as Static Batching, Dynamic Batching, and Atlasing. This would mean that we have very limited scope for reducing them further.</p><p>What we can do, however, is intentionally increase our Draw Call count by a small number, either by introducing more objects or disabling Draw Call-saving features such as Static and Dynamic Batching and observe whether the situation gets significantly worse than before. If so, then we have evidence that we're either very close to being CPU bound or have already become so. </p><p>There are two good brute-force tests we can apply to a GPU-bound application to determine whether we're bound by Fill Rate or by Memory Bandwidth: reducing screen resolution or reducing texture resolution, respectively.</p><p>By reducing screen resolution, we will ask the Rasterizer to generate significantly fewer fragments and transpose them over a smaller canvas of pixels for the Back End to process. This will reduce the Fill Rate consumption of the application, giving this key part of the Rendering Pipeline some additional breathing room. Ergo, if performance suddenly improves with a screen resolution reduction, then Fill Rate should be our primary concern.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note84"></a>Note</h3><p>A reduction from a resolution of 2560 x 1440 to 800 x 600 is an improvement factor of about eight, which is often more than enough to reduce Fill Rate costs enough to make the application perform well again.</p></div><p>Similarly, if we're bottlenecked on Memory Bandwidth, then reducing texture quality is likely to result in a significant performance improvement. By doing so, we have shrunk the size of our textures, greatly reducing the Memory Bandwidth costs of our Fragment Shaders, allowing the GPU to fetch the necessary textures much quicker. Globally reducing texture quality can be achieved by going to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Quality</code></strong> | <strong class="userinput"><code>Texture Quality and setting the value to <strong class="userinput"><code>Half Res</code></strong>, <strong class="userinput"><code>Quarter Res</code></strong>, or <strong class="userinput"><code>Eighth Res</code></strong>.</code></strong></p><p>An application bound by the CPU has ample opportunities for performance enhancements through practically every performance-enhancing tip in this book. If we free up CPU cycles from other activities, then we can afford to render more objects through more Draw Calls, keeping in mind, of course, that each will cost us more activity in the GPU. There are, however, additional opportunities to make some indirect improvements in Draw Call count while we try to improve other parts of the Rendering Pipeline. This includes Occlusion Culling, tweaking our Lighting and Shadowing behavior, and modifying our Shaders. These will be explained in the following sections as we investigate various performance enhancements.</p><p>Meanwhile, we will probably need to apply a little brute-force testing and guesswork to determine how a GPU-bound application is bottlenecked. Most applications are bottlenecked by Fill Rate or Memory Bandwidth, so we should start there. It is rare to find performance bottlenecks in the Front End, at least on desktop applications, so it is worth checking only after we've verified that the other sources are not the problem. Vertex Shaders are often trivial compared to Fragment Shaders, and so the only real opportunity to cause problems with Front End processing is either to push too much geometry or to have overly complex Geometry Shaders.</p><p>Ultimately, this investigation should help us determine whether we are CPU-bound or GPU-bound, and in the latter case, whether we are bound by the Front End or Back End, and again in the latter case, whether we are bound by Fill Rate or Memory Bandwidth. With this knowledge, there are a number of techniques we can apply to improve performance.</p></div></div>