<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec48"></a>Memory management performance enhancements</h2></div></div><hr /></div><p>In most Game Engines, we would have the luxury of being able to port inefficient Managed Code into faster Native Code if we were hitting performance issues. This is not an option unless we invest serious cash in obtaining the Unity source code, which is offered as a license separate from the Free/Personal/Pro licensing system, and on a per case, per title basis. We could also purchase a license of Unity Pro with the hope of using Native Plugins, but doing so rarely leads to a performance benefit since we must still cross the Native-Managed Bridge to invoke function calls inside of it. Native Plugins are normally used to interface with systems and libraries that are not built specifically for C#. This forces the overwhelming majority of us into a position of needing to make our C# script-level code as performant as possible ourselves.</p><p>With this in mind, we should now have enough understanding of Unity Engine internals and memory spaces to detect and analyze memory performance issues and understand and implement enhancements for them. So, let's cover some performance enhancements we can apply.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec103"></a>Garbage collection tactics</h3></div></div></div><p>One strategy to minimize garbage collection problems is concealment by manually invoking the GC at opportune moments, when we're certain the player would not notice. Garbage collection can be manually invoked by calling <code class="literal">System.GC.Collect()</code>.</p><p>Good opportunities to invoke a collection may be while loading between levels, when gameplay is paused, shortly after a menu interface has been opened, during cutscene transitions, or any break in Gameplay that the player would not witness, or care about, a sudden performance drop. We could even use the  <code class="literal">Profiler.GetMonoUsedSize()</code> and  <code class="literal">Profiler.GetMonoHeapSize()</code> methods at runtime to determine whether a garbage collection needs to be invoked in the near future.</p><p>We can also cause the deallocation of a handful of specific objects. If the object in question is one of the Unity object wrappers, such as a <code class="literal">GameObject</code> or <code class="literal">MonoBehaviour</code> Component, then the finalizer will first invoke the <code class="literal">Dispose()</code> method within the Native Domain. At this point, the memory consumed by both the Native and Managed Domains will then be freed. In some rare instances, if the Mono wrapper implements the <code class="literal">IDisposable</code> Interface Class (that is, it has a <code class="literal">Dispose()</code> method available from script code), then we can actually control this behavior and force the memory to be freed instantly.</p><p>There are a number of different object types in the Unity Engine (most of which are introduced in Unity 5 or later), which implement the <code class="literal">IDisposable Interface</code> Class, as follows: <code class="literal">NetworkConnection</code>, <code class="literal">WWW</code>, <code class="literal">UnityWebRequest</code>, <code class="literal">UploadHandler</code>, <code class="literal">DownloadHandler</code>, <code class="literal">VertexHelper</code>, <code class="literal">CullingGroup</code>, <code class="literal">PhotoCapture</code>, <code class="literal">VideoCapture</code>, <code class="literal">PhraseRecognizer</code>, <code class="literal">GestureRecognizer</code>, <code class="literal">DictationRecognizer</code>, <code class="literal">SurfaceObserver</code>, and more.</p><p>These are all utility classes for pulling in potentially large datasets where we might want to ensure immediate destruction of the data it has acquired, since they normally involve allocating several buffers and memory blocks in the Native Domain in order to accomplish their tasks. If we kept all of this memory for a long time, it would be a colossal waste of precious space. So, by calling their <code class="literal">Dispose()</code> method from script code, we can ensure that the memory buffers are freed promptly and precisely when they need to be.</p><p>All other Asset objects offer some kind of unloading method to clean up any unused asset data, such as <code class="literal">Resources.UnloadUnusedAssets()</code>. Actual asset data is stored within the Native Domain, so the GC technically isn't involved here, but the idea is basically the same. It will iterate through all Assets of a particular type, check whether they're no longer being referenced, and, if so, deallocate them. However, again, this is an asynchronous process, and we cannot guarantee exactly when the deallocation will occur. This method is automatically called internally after a Scene is loaded, but this still doesn't guarantee instant deallocation. The preferred approach is to use <code class="literal">Resources.UnloadAsset()</code> instead, which will unload one specific asset at a time. This method is generally faster since time will not be spent iterating through an entire collection of asset data, in order to figure out what is unused. </p><p>However, the best strategy for garbage collection will always be avoidance; if we allocate as little heap memory and control its usage as much as possible, then we won't have to worry about the GC inflicting frequent, expensive performance costs. We will cover many tactics for this throughout the remainder of this chapter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec104"></a>Manual JIT compilation</h3></div></div></div><p>In the event that JIT compilation is causing a runtime performance loss, be aware that it is actually possible to force JIT compilation of a method at any time via <span class="strong"><strong>Reflection</strong></span>. Reflection is a useful feature of the C# language that allows our code base to explore itself introspectively for type information, methods, values, and metadata. Using Reflection is often a very costly process. It should be avoided at runtime or, at the very least, only used during initialization or other loading times. Not doing so can easily cause significant CPU spikes and Gameplay freezing.</p><p>We can manually force JIT compilation of a method using Reflection to obtain a function pointer to it:</p><pre class="programlisting">var method = typeof(MyComponent).GetMethod("MethodName");
if (method != null) {
  method.MethodHandle.GetFunctionPointer();
  Debug.Log("JIT compilation complete!");
}</pre><p>The preceding code only works on <code class="literal">public</code> methods. Obtaining <code class="literal">private</code> or <code class="literal">protected</code> methods can be accomplished through the use of <code class="literal">BindingFlags</code>:</p><pre class="programlisting">using System.Reflection;
// ...
var method = typeof(MyComponent).GetMethod("MethodName",  
BindingFlags.NonPublic | BindingFlags.Instance);</pre><p>This kind of code should only be run for very targeted methods where we are certain that JIT compilation is causing CPU spikes. This can be verified by restarting the application and profiling a method's first invocation versus all subsequent invocations. The difference will tell us the JIT compilation overhead.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note116"></a>Note</h3><p>Note that the official method for forcing JIT compilation in the .NET library is <code class="literal">RuntimeHelpers.PrepareMethod()</code>, but this is not properly implemented in the current version of Mono that comes with Unity (Mono Version 2.6.5). The aforementioned workaround should be used until Unity has pulled in a more recent version of the Mono project.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec105"></a>Value types and Reference types</h3></div></div></div><p>Not all memory allocations we make within Mono will go through the heap. The .NET Framework (and, by extension, the C# language, which merely implements the .NET specification) has the concept of Value types and Reference types, and only the latter needs to be marked by the GC while it is performing its Mark-and-Sweep algorithm. Reference types are expected to (or need to) last a long time in memory due to their complexity, their size, or how they're used. Large datasets, and any kind of object instantiated from a <code class="literal">class</code>, is a Reference type. This also includes arrays (regardless of whether it is an array of Value types or Reference types), delegates, all classes, such as <code class="literal">MonoBehaviour</code>, <code class="literal">GameObject</code>, and any custom classes we define.</p><p>Reference types are always allocated on the heap, whereas Value types can be allocated either on the stack or the heap. Primitive data types such as <code class="literal">bool</code>, <code class="literal">int</code>, and <code class="literal">float</code> are examples of Value types. These values are typically allocated on the stack, but as soon as a Value type is contained within a Reference type, such as a <code class="literal">class</code> or an array, then it is implied that it is either too large for the stack or will need to survive longer than the current scope and must be allocated on the heap, bundled with the Reference type it is contained within.</p><p>All of this can be best explained through examples. The following code will create an integer as a Value type that exists on the stack only temporarily:</p><pre class="programlisting">public class TestComponent {
  void TestFunction() {
    int data = 5; // allocated on the stack
    DoSomething(data);
  } // integer is deallocated from the stack here
}</pre><p>As soon as the <code class="literal">Start()</code> method ends, the integer is deallocated from the stack. This is essentially a free operation since, as mentioned previously, it doesn't bother doing any cleanup; it just moves the stack pointer back to the previous memory location in the call stack (back to whichever function called <code class="literal">TestFunction()</code> on the <code class="literal">TestComponent</code> object). Any future stack allocations simply overwrite the old data. More importantly, no heap allocation took place to create the data, so the GC has no need to track its existence.</p><p>However, if we created an integer as a member variable of the <code class="literal">MonoBehaviour</code> class definition, then it is now contained within a Reference type (a <code class="literal">class</code>) and must be allocated on the heap along with its container:</p><pre class="programlisting">public class TestComponent : MonoBehaviour {
  private int _data = 5;
  void TestFunction() {
    DoSomething(_data);
  }
}</pre><p>The <code class="literal">_data</code> integer is now an additional piece of data that consumes space in the heap alongside the <code class="literal">TestComponent</code> object it is contained within. If the <code class="literal">TestComponent</code> is destroyed, then the integer is deallocated along with it, but not before then.</p><p>Similarly, if we put the integer into a normal C# <code class="literal">class</code>, then the rules for Reference types still apply and the object is allocated on the heap:</p><pre class="programlisting">public class TestData {
  public int data = 5;
}

public class TestComponent {
  void TestFunction() {
    TestData dataObj = new TestData(); // allocated on the heap
    DoSomething(dataObj.data);
  } // dataObj is not immediately deallocated here, but it will 
    // become a candidate during the next GC sweep
}</pre><p>So, there is a big difference between creating a temporary Value type within a <code class="literal">class</code> method versus storing long-term Value type as a member field of a <code class="literal">class</code>. In the former case, we're storing it in the stack, but in the latter case, we're storing it within a Reference type, which means it can be referenced elsewhere. For example, imagine that <code class="literal">DoSomething()</code> has stored the reference to <code class="literal">dataObj</code> within a member variable:</p><pre class="programlisting">public class TestComponent {
  private TestData _testDataObj;

  void TestFunction() {
    TestData dataObj = new TestData(); // allocated on the heap
    DoSomething(dataObj.data);
  }

  void DoSomething (TestData dataObj) {
    _testDataObj = dataObj; // a new reference created! The referenced 
    // object will now be marked during Mark-and-Sweep
  }
}</pre><p>In this case, we would not be able to deallocate the object pointed to <code class="literal">dataObj</code> as soon as the <code class="literal">TestFunction()</code> method ends because the total number of things referencing the object would go from <code class="literal">2</code> to <code class="literal">1</code>. This is not <code class="literal">0</code>, and hence the GC would still mark it during Mark-and-Sweep. We would need to set the value of <code class="literal">_testDataObj</code> to <code class="literal">null</code> or make it reference something else, before the object is no longer reachable.</p><p>Note that a Value type must have a value and can never be <code class="literal">null</code>. If a stack-allocated Value type is assigned to a Reference type, then the data is simply copied. This is true even for arrays of Value types:</p><pre class="programlisting">public class TestClass {
  private int[] _intArray = new int[1000]; // Reference type 
                                           // full of Value types
  void StoreANumber(int num) {
    _intArray[0] = num; // store a Value within the array
  }
}</pre><p>When the initial array is created (during object initialization), 1,000 integers will be allocated on the heap set to a value of <code class="literal">0</code>. When the <code class="literal">StoreANumber()</code> method is called, the value of <code class="literal">num</code> is merely copied into the <span class="emphasis"><em>zeroth</em></span> element of the array rather than storing a reference to it.</p><p>The subtle change in the referencing capability is what ultimately decides whether something is a Reference type or a Value type, and we should try to use Value types whenever we have the opportunity so that they generate stack allocations instead of heap allocations. Any situation where we're just sending around a piece of data that doesn't need to live longer than the current scope is a good opportunity to use a Value type instead of a Reference type. Ostensibly, it does not matter if we pass the data into another method of the same class or a method of another class--it still remains a Value type that will exist on the stack until the method that created it goes out of the scope.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec98"></a>Pass by value and by reference</h4></div></div></div><p>Technically, something is duplicated every time a data value is passed as an argument from one method to another, and this is true whether it is a Value type or a Reference type. When we're passing the object's data, this is known as <span class="emphasis"><em>passing by value</em></span>. When we're simply copying a reference to something else, it is called <span class="emphasis"><em>passing by reference</em></span>.</p><p>An important difference between Value types and Reference types is that a Reference type is merely a pointer to another location in memory that consumes only 4 or 8 bytes in memory (32 bit or 64 bit, depending on the architecture), regardless of what it is actually pointing to. When a Reference type is passed as an argument, it is only the value of this pointer that gets copied into the function. Even if the Reference type points to a humongous array of data, this operation will be very quick since the data being copied is very small.</p><p>Meanwhile, a Value type contains the full and complete bits of data stored within a concrete object. Hence, all of the data of a Value type will be copied whenever they are passed between methods or stored in other Value types. In some cases, it can mean that passing a large Value type as arguments around too much can be more costly than just using a Reference type and letting the GC take care of it. For most Value types, this is not a problem since they are comparable in size to a pointer, but this becomes important when we begin to talk about the <code class="literal">struct</code> type in the next section.</p><p>Data can also be passed around by reference using the <code class="literal">ref</code> keyword, but this is very different from the concept of Value and Reference types, and it is very important to keep them distinct in our mind when we try to understand what is going on under the hood. We can pass a Value type by value, or by reference, and we can pass a Reference type by value, or by reference. This means that there are four distinct data passing situations that can occur, depending on which type is being passed and whether the <code class="literal">ref</code> keyword is being used or not.</p><p>When data is passed by reference (even if it is a Value type), then making any changes to the data will change the original. For example, the following code would print the value as <code class="literal">10</code>:</p><pre class="programlisting">void Start() {
  int myInt = 5;
  DoSomething(ref myInt);
  Debug.Log(String.Format("Value = {0}", myInt));
}

void DoSomething(ref int val) {
  val = 10;
}</pre><p>Removing the <code class="literal">ref</code> keyword from both places would make it print the value <code class="literal">5</code> instead (and removing it from only one of them would lead to a compiler error since the <code class="literal">ref</code> keyword needs to be present in both locations or neither). This understanding will come in handy when we start to think about some of the more interesting data types we have access to, namely, structs, arrays, and strings.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec99"></a>Structs are Value types</h4></div></div></div><p>The <code class="literal">struct</code> type is an interesting special case in C#. A <code class="literal">struct</code> object can contain <code class="literal">private</code>, <code class="literal">protected</code>, and <code class="literal">public</code> fields, have methods, and can be instantiated at runtime, just like a <code class="literal">class</code> type. However, there is a fundamental difference between the two: a <code class="literal">struct</code> type is a Value type, and a <code class="literal">class</code> type is a Reference type. Consequently, this leads to some important differences between the two, namely, that a <code class="literal">struct</code> type cannot support inheritance, their properties cannot be given custom default values (member data always defaults to values such as <code class="literal">0</code> or <code class="literal">null</code> since it is a Value type), and their default constructors cannot be overridden. This greatly restricts their usage compared to classes, so simply replacing all classes with structs (under the assumption that it will just allocate everything on the stack) is not as easy as it sounds.</p><p>However, if we're using a class in a situation whose only purpose is to send a blob of data to somewhere else in our application, and it does not need to last beyond the current scope, then we might be able to use a <code class="literal">struct</code> type instead, since a <code class="literal">class</code> type would result in a heap allocation for no particularly good reason:</p><pre class="programlisting">public class DamageResult {
  public Character attacker;
  public Character defender;
  public int totalDamageDealt;
  public DamageType damageType;
  public int damageBlocked;
  // etc.
}

public void DealDamage(Character _target) {
  DamageResult result = CombatSystem.Instance.CalculateDamage(this, _target);
  CreateFloatingDamageText(result);
}</pre><p>In this example, we're using a <code class="literal">class</code> type to pass a bunch of data from one subsystem (the combat system) to another (the UI system). The only purpose of this data is to be calculated and read by various subsystems, so this is a good candidate to convert into a <code class="literal">struct</code> type.</p><p>Merely changing the <code class="literal">DamageResult</code> definition from a <code class="literal">class</code> type to a <code class="literal">struct</code> type could save us quite a few unnecessary garbage collections since it would be allocated on the stack as a Value type instead of the heap as a Reference type:</p><pre class="programlisting">public <span class="strong"><strong>struct</strong></span> DamageResult {
  // ...
}</pre><p>This is not a catch-all solution. Since structs are Value types, the entire blob of data will be duplicated and provided to the next method in the call stack, regardless of how large or small it is. So, if a <code class="literal">struct</code> object is passed by a value between five different methods in a long chain, then five different stack copies will occur at the same time. Recall that stack deallocations are effectively free, but stack allocations (which involves copying of data) is not. This data copying is pretty much negligible for small values, such as a handful of integers or floating-point values, but passing around ridiculously large datasets through structs over and over again is obviously not a trivial task and should be avoided.</p><p>We can work around this problem by passing the <code class="literal">struct</code> object by reference using the <code class="literal">ref</code> keyword to minimize the amount of data being copied each time (just a single pointer). However, this can be dangerous since passing by reference allows any subsequent methods to make changes to the <code class="literal">struct</code> object in which case it would be prudent to make its data values <code class="literal">readonly</code>. This means that the values can only be initialized in the constructor, and never again, even by its own member functions, which prevents accidental changes as it's passed through the chain.</p><p>All of the above is also true when structs are contained within Reference types, as follows:</p><pre class="programlisting">public struct DataStruct {
  public int val;
}

public class StructHolder {
  public DataStruct _memberStruct;
  public void StoreStruct(DataStruct ds) {
      _memberStruct = ds;
  }
}</pre><p>To the untrained eye, the preceding code appears to be attempting to store a stack-allocated struct (<code class="literal">ds</code>) within a Reference type (<code class="literal">StructHolder</code>). Does this mean that a <code class="literal">StructHolder</code> object on the heap can now reference an object on the stack? If so, what will happen when the <code class="literal">StoreStruct()</code> method goes out of scope and the <code class="literal">struct</code> object is (effectively) erased? It turns out that these are the wrong questions.</p><p>What's actually happening is that while a <code class="literal">DataStruct</code> object (<code class="literal">_memberStruct</code>) has been allocated on the heap within the <code class="literal">StructHolder</code> object, it is still a Value type and does not magically transform into a Reference type when it is a member variable of a Reference type. So, all of the usual rules for Value types apply. The <code class="literal">_memberStruct</code> variable cannot have a value of <code class="literal">null</code>, and all of its fields will be initialized to <code class="literal">0</code> or <code class="literal">null</code> values. When <code class="literal">StoreStruct()</code> is called, the data from <code class="literal">ds</code> will be copied into <code class="literal">_memberStruct</code> in its entirety. There are no references to stack objects taking place, and there is no concern about lost data.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec100"></a>Arrays are Reference types</h4></div></div></div><p>The purpose of arrays is to contain large datasets, which make them difficult to be treated as a Value type since there's probably not enough room on the stack to support them. Therefore, they are treated as a Reference type so that the entire dataset can be passed around via a single reference (if it were a Value type, we would need to duplicate the entire array every time it is passed around). This is true irrespective of whether the array contains Value types or Reference types.</p><p>This means that the following code will result in a heap allocation:</p><pre class="programlisting">TestStruct[] dataObj = new TestStruct[1000];

for(int i = 0; i &lt; 1000; ++i) {
  dataObj[i].data = i;
  DoSomething(dataObj[i]);
}</pre><p>However, the following, functionally equivalent, code would not result in any heap allocations since the <code class="literal">struct</code> objects being used are Value types, and hence, it would be created on the stack:</p><pre class="programlisting">for(int i = 0; i &lt; 1000; ++i) {
  TestStruct dataObj = new TestStruct();
  dataObj.data = i;
  DoSomething(dataObj);
}</pre><p>The subtle difference in the second example is that only one <code class="literal">TestStruct</code> exists on the stack at a time, whereas the first example needs to allocate 1,000 of them via an array. Obviously, these methods are kind of ridiculous as they're written, but they illustrate an important point to consider. The compiler isn't smart enough to automatically find these situations for us and make the appropriate changes. Opportunities to optimize our memory usage through Value type replacements will be entirely down to our ability to detect them, and understand why conversions from Reference types to Value types will result in stack allocations, rather than heap allocations.</p><p>Note that when we allocate an array of Reference types, we're creating an array of references, which can each reference other locations on the heap. However, when we allocate an array of Value types, we're creating a packed list of Value types on the heap. Each of these Value types will be initialized with a value of <code class="literal">0</code> (or equivalent) since they cannot be <code class="literal">null</code>, while each reference within an array of Reference types will always initialize to <code class="literal">null</code> since no references have been assigned, yet.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec101"></a>Strings are immutable Reference types</h4></div></div></div><p>We briefly touched upon the subject of strings in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>, but now it's time to go into more detail about why proper string usage is extremely important.</p><p>Strings are essentially arrays of characters, and so they are considered Reference types, and follow all of the same rules as other Reference types; they will be allocated on the heap, and a pointer is all that is copied from one method to the next. Since a string is effectively an array, this implies that the characters it contains must be contiguous in memory. However, we often find ourselves expanding, contracting, or combining strings to create other strings. This can lead us to making some faulty assumptions about how strings work. We might assume that because strings are such common, ubiquitous objects, performing operations on them is fast and cheap. Unfortunately, this is incorrect. Strings are not made to be fast. They are only made to be convenient. </p><p>The <code class="literal">string</code> object class is immutable, which means they cannot be changed after they've been allocated. Therefore, when we change a string, we are actually allocating a whole new string on the heap to replace it, where the contents of the original will be copied and modified as needed into a whole new character array, and the original <code class="literal">string</code> object reference now points to a completely new <code class="literal">string</code> object. In which case, the old <code class="literal">string</code> object might no longer be referenced anywhere, will not be marked during Mark-and-Sweep, and will eventually be purged by the GC. As a result, lazy string programming can result in a lot of unnecessary heap allocations and garbage collection.</p><p>A good example to illustrate how strings are different than normal Reference types is the following code:</p><pre class="programlisting">void TestFunction() {
  string testString = "Hello";
  DoSomething(testString);
  Debug.Log(testString);
}

void DoSomething(string localString) {
  localString = "World!";
}</pre><p>If we were under the mistaken assumption that strings worked just like other Reference types, then we might be forgiven for assuming that the log output of the following to be <code class="literal">World!</code>. It appears as though <code class="literal">testString</code>, a Reference type, is being passed into <code class="literal">DoSomething()</code>, which would change what <code class="literal">testString</code> is referencing to, in which case, the log statement will print out the new value of the string.</p><p>However, this is not the case, and it will simply print out <code class="literal">Hello</code>. What is actually happening is that the <code class="literal">localString</code> variable, within the scope of <code class="literal">DoSomething()</code>, starts off referencing the same place in memory as <code class="literal">testString</code> due to the reference being passed by value. This gives us two references pointing to the same location in memory as we would expect if we were dealing with any other Reference type. So far, so good.</p><p>However, as soon as we change the value of <code class="literal">localString</code>, we run into a little bit of a conflict. Strings are immutable, and we cannot change them, so, therefore, we must allocate a new string containing the value <code class="literal">World!</code> and assign its reference to the value of <code class="literal">localString</code>; now, the number of references to the <code class="literal">Hello</code> string returns back to one. The value of <code class="literal">testString</code>, therefore, has not been changed, and that is still the value that will be printed by <code class="literal">Debug.Log()</code>. All we've succeeded in doing by calling <code class="literal">DoSomething()</code> is creating a new string on the heap that gets garbage-collected and doesn't change anything. This is the textbook definition of wasteful.</p><p>If we change the method definition of <code class="literal">DoSomething()</code> to pass the string by reference via the <code class="literal">ref</code> keyword, the output would indeed change to <code class="literal">World!</code>. Of course, this is also what we would expect to happen with a Value type, which leads a lot of developers to incorrectly assume that strings are Value types. However, this is an example of the fourth and final data-passing case, where a Reference type is being passed by reference, which allows us to change what the original reference is referencing.</p><p>So, let's recap:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">If we pass a Value type by value, we can only change the value of a copy of its data</li><li style="list-style-type: disc">If we pass a Value type by reference, we can change the value of the original data passed in</li><li style="list-style-type: disc">If we pass a Reference type by value, we can make changes to the object that the original reference is referencing</li><li style="list-style-type: disc">If we pass a Reference type by reference, we can change the object or dataset the original reference is referencing</li></ul></div><p>If we find functions that seem to generate a lot of GC allocations the moment they are called, then we might be causing undue heap allocations due to a misunderstanding of the preceding rules.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec106"></a>String concatenation</h3></div></div></div><p>Concatenation is the act of appending strings to one another to form a larger string. As you've learned, any such cases are likely to result in excess heap allocations. The biggest offender in a string-based memory waste is concatenating strings using the <code class="literal">+</code> operator and <code class="literal">+=</code> operators, because of the allocation chaining effect they cause.</p><p>For example, the following code tries to combine a group of <code class="literal">string</code> objects together to print some information about a combat result:</p><pre class="programlisting">void CreateFloatingDamageText(DamageResult result) {
  string outputText = result.attacker.GetCharacterName() + " 
             dealt " + result.totalDamageDealt.ToString() + " " + 
             result.damageType.ToString() + " damage to " + 
             result.defender.GetCharacterName() + " (" + 
             result.damageBlocked.ToString() + " blocked)";
  // ...
}</pre><p>An example output of this function might be a string that reads as follows:</p><pre class="programlisting">Dwarf dealt 15 Slashing damage to Orc (3 blocked)</pre><p>This function features a handful of string literals (hardcoded strings that are allocated during application initialization) such as <code class="literal">" dealt "</code>, <code class="literal">" damage to "</code>, and <code class="literal">" blocked)"</code>, which are simple constructs for the compiler to pre-allocate for us. However, because we are using other local variables within this combined string, it cannot be compiled away at build time, and, therefore, the complete string be regenerated dynamically at runtime each time the function is called.</p><p>A new heap allocation will be generated each time a <code class="literal">+</code>, or <code class="literal">+=</code>, operator is executed; only a single pair of strings will be merged at a time, and it allocates a new <code class="literal">string</code> object each time. Then, the result of one merger will be fed into the next and merged with the next <code class="literal">string</code> and so on until the final <code class="literal">string</code> object has been built.</p><p>So, the previous example will result in nine different strings being allocated all in one statement. All of the following strings would be allocated to satisfy this instruction, and all would eventually need to be garbage collected (note that the operators are resolved from right to left):</p><pre class="programlisting">"3 blocked)"
" (3 blocked)"
"Orc (3 blocked)"
" damage to Orc (3 blocked)"
"Slashing damage to Orc (3 blocked)"
" Slashing damage to Orc (3 blocked)"
"15 Slashing damage to Orc (3 blocked)"
" dealt 15 Slashing damage to Orc (3 blocked)"
"Dwarf dealt 15 Slashing damage to Orc (3 blocked)"</pre><p>That's 262 characters being used, instead of 49. In addition, because a character is a 2-byte data type (for Unicode strings), that's 524-bytes of data being allocated when we only need 98-bytes. Chances are that if this code exists in the code base once, it exists all over the place; so, for an application that's doing a lot of lazy string concatenation like this, that is a ton of memory being wasted on generating unnecessary strings.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note117"></a>Note</h3><p>Note that big, constant string literals can be safely combined using the <code class="literal">+</code> and <code class="literal">+=</code> operators. The compiler knows that you will eventually need the full string and pregenerates the string automatically. This helps us to make huge block of text more readable within the code base, but only if they will result in a constant string.</p></div><p>Better approaches for generating strings are to use either the <code class="literal">StringBuilder</code> class or one of several string class methods for string formatting.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec102"></a>StringBuilder</h4></div></div></div><p>Conventional wisdom says that if we roughly know the final size of the resultant string, then we can allocate an appropriate buffer ahead of time and save ourselves undue allocations. This is the purpose of the <code class="literal">StringBuilder</code> class. It is effectively a mutable (changeable) string-based object that works like a dynamic array. It allocates a block of space, which we can copy future <code class="literal">string</code> objects into, and allocates additional space whenever the current size is exceeded. Of course, expanding the buffer should be avoided as much as possible by predicting the maximum size we will need and allocating a sufficiently sized buffer ahead of time.</p><p>When we use a <code class="literal">StringBuilder</code>, we can retrieve the resultant <code class="literal">string</code> object by calling the <code class="literal">ToString()</code> method. This still results in a memory allocation for the completed <code class="literal">string</code>, but, at the very least, we only allocated one large string as opposed to dozens of smaller strings, had we used the <code class="literal">+</code> or <code class="literal">+=</code> operators.</p><p>For the previous example, we might allocate a <code class="literal">StringBuilder</code> buffer of 100 characters to make room for long character names and damage values:</p><pre class="programlisting">using System.Text;
// ...
StringBuilder sb = new StringBuilder(100);
sb.Append(result.attacker.GetCharacterName());
sb.Append(" dealt " );
sb.Append(result.totalDamageDealt.ToString());
// etc.
string result = sb.ToString();</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec103"></a>String formatting</h4></div></div></div><p>If we don't know the final size of the resultant string, then using a <code class="literal">StringBuilder</code> class is unlikely to generate a buffer that fits the result size exactly. We will either end up with a buffer that's too large (wasted space), or, worse, a buffer that's too small, which must keep expanding as we generate the complete string. In this scenario, it might be best to use one of the various string class formatting methods.</p><p>There are three string class methods available for generating strings: <code class="literal">string.Format()</code>, <code class="literal">string.Join()</code>, and <code class="literal">string.Concat()</code>. Each operates slightly differently, but the overall output is the same. A new <code class="literal">string</code> object is allocated, containing the contents of the <code class="literal">string</code> objects we pass into them, and it is all done in a single action, which reduces excess string allocations.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note118"></a>Note</h3><p>Unfortunately, regardless of the approach we use, if we're converting other objects into additional <code class="literal">string</code> objects (such as the calls to generate the strings for <code class="literal">"Orc"</code>, <code class="literal">"Dwarf"</code>, or <code class="literal">"Slashing"</code> in the preceding example), then this will allocate an additional <code class="literal">string</code> object on the heap. There is nothing we can do about this allocation, except perhaps cache the result so that we don't need to recalculate it each time its needed.</p></div><p>It can be surprisingly hard to say which one of these string generation approaches would be more beneficial in a given situation, as there are a lot of silly little nuances involved that tends to explode into religious debate (just do a Google search for <span class="emphasis"><em>c sharp string concatenation performance,</em></span> and you'll see what I mean), so the simplest approach is to implement one or the other using the conventional wisdom described previously. Whenever we run into bad performance with one of the string-manipulation methods, we should also try the other to check whether it results in a performance improvement. The best way to be certain is to profile them both for comparison, and then pick the best option of the two.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec107"></a>Boxing</h3></div></div></div><p>Everything in C# is an object (caveats apply), meaning that they derive from the <code class="literal">System.Object</code> class. Even primitive data types such as <code class="literal">int</code>, <code class="literal">float</code>, and <code class="literal">bool</code> are implicitly derived from <code class="literal">System.Object</code>, which is itself a Reference type. This is a special case, which allows them access to helper methods such as <code class="literal">ToString()</code> so that they can customize their string representation, but without actually turning them into Reference types. Whenever one of these Value types is implicitly treated in such a way that it must act like an object, the CLR automatically creates a temporary object to store, or <span class="emphasis"><em>box</em></span>, the value inside so that it can be treated as a typical Reference type object. As we should expect, this results in a heap allocation to create the containing vessel.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note119"></a>Note</h3><p>Note that boxing is not the same thing as using Value types as member variables of Reference types. Boxing only takes place when Value types are treated as Reference types via conversion or casting.</p></div><p>For example, the following code will cause the integer variable <code class="literal">i</code> to be boxed inside object <code class="literal">obj</code>:</p><pre class="programlisting">int i = 128;
object obj = i;</pre><p>The following code will use the object representation <code class="literal">obj</code> to replace the value stored within the integer, and <span class="emphasis"><em>unbox</em></span> it back into an integer, storing it in <code class="literal">i</code>. The final value of <code class="literal">i</code> would be 256:</p><pre class="programlisting">int i = 128;
object obj = i;
obj = 256;
i = (int)obj; // i = 256</pre><p>These types can be changed dynamically. The following is perfectly legal C# code, where we override the type of  <code class="literal">obj</code>, converting it into a <code class="literal">float</code>:</p><pre class="programlisting">int i = 128;
object obj = i;
obj = 512f;
float f = (float)obj; // f = 512f</pre><p>The following is also legal--conversion into a <code class="literal">bool</code>:</p><pre class="programlisting">int i = 128;
object obj = i;
obj = false;
bool b = (bool)obj; // b = false</pre><p>Note that attempting to unbox <code class="literal">obj</code> into a type that isn't the most recently assigned type would result in an <code class="literal">InvalidCastException</code>:</p><pre class="programlisting">int i = 128;
object obj = i;
obj = 512f;
i = (int)obj; // InvalidCastException thrown here since most recent conversion was to a float</pre><p>All of this can be a little tricky to wrap our head around until we remember that, at the end of the day, everything is just bits in memory and that we are free to interpret them any way we like. After all, data types like <code class="literal">int</code>, <code class="literal">float</code>, and so on are just an abstraction over binary lists of  <code class="literal">0</code> and <code class="literal">1</code>. What's important is knowing that we can treat our primitive types as objects by boxing them, converting their types, and then unboxing them into a different type at a later time, but each time we do this results in a heap memory allocation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note120"></a>Note</h3><p>Note that it's possible to convert a boxed object's type using one of the many <code class="literal">System.Convert.To…()</code> methods.</p></div><p>Boxing can be either implicit, as shown in the preceding examples, or explicit, by typecasting to <code class="literal">System.Object</code>. Unboxing must always be explicit by typecasting back to its original type. Whenever we pass a Value type into a method that uses <code class="literal">System.Object</code> as arguments, boxing will be applied implicitly.</p><p>Methods such as <code class="literal">String.Format()</code>, which take <code class="literal">System.Object</code> as arguments, are one such example. We typically use them by passing in Value types, such as <code class="literal">int</code>, <code class="literal">float</code>, and <code class="literal">bool</code>, to generate a string with. Boxing is automatically taking place in these situations, causing additional heap allocations that we should be aware of. <code class="literal">Collections.Generic.ArrayList</code> is another such example since <code class="literal">ArrayList</code> always contains converts its inputs into <code class="literal">System.Object</code> references, regardless of what types are stored within.</p><p>Any time we use a function definition that takes <code class="literal">System.Object</code> as arguments, and we're passing in Value types, we should be aware that we're implicitly causing heap allocations due to boxing.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec108"></a>The importance of data layout</h3></div></div></div><p>The importance of how our data is organized in memory can be surprisingly easy to forget about, but can result in a fairly big performance boost if it is handled properly. Cache misses should be avoided whenever possible, which means that in most cases, arrays of data that are contiguous in memory should be iterated over sequentially as opposed to any other iteration style.</p><p>This means that data layout is also important for garbage collection since it is done in an iterative fashion, and if we can find ways to have the GC skip over problematic areas, then we can potentially save a lot of iteration time.</p><p>In essence, we want to keep large groups of Reference types separated from large groups of Value types. If there is even one Reference type within a Value type, such as a <code class="literal">struct</code>, then the GC considers the entire object, and all of its data members, indirectly referenceable objects. When it comes time to Mark-and-Sweep, it must verify all fields of the object before moving on. However, if we separate the various types into different arrays, then we can make the GC skip the majority of the data.</p><p>For instance, if we have an array of <code class="literal">struct</code> objects that looks like the following code, then the GC will need to iterate over every member of every <code class="literal">struct</code>, which could be fairly time-consuming:</p><pre class="programlisting">public struct MyStruct {
    int myInt;
    float myFloat;
    bool myBool;
    string myString;
}

MyStruct[] arrayOfStructs = new MyStruct[1000];</pre><p>However, if we reorganize all pieces of this data into multiple arrays of each time, then the GC will ignore all of the primitive data types and only check the <code class="literal">string</code> objects. The following code will result in much a faster garbage collection sweep:</p><pre class="programlisting">int[] myInts = new int[1000];
float[] myFloats = new float[1000];
bool[] myBools = new bool[1000];
string[] myStrings = new string[1000];</pre><p>The reason this works is because we're giving the GC fewer indirect references to check. When the data is split into separate arrays (Reference types), it finds three arrays of Value types, marks the arrays, and then immediately moves on because there's no reason to mark the contents of an array of Value types. It must still iterate through all of the <code class="literal">string</code> objects within <code class="literal">myStrings</code> since each is a Reference type and it needs to verify that there are no indirect references within it. Technically, the <code class="literal">string</code> objects cannot contain indirect references, but the GC works at a level where it only knows whether the object is a Reference type or Value type and, therefore, can't tell the difference between a <code class="literal">string</code> and <code class="literal">class</code>. However, we have still spared the GC from needing to iterate over an extra 3,000 pieces of data (the 3,000 values in <code class="literal">myInts</code>, <code class="literal">myFloats</code>, and <code class="literal">myBools</code>).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec109"></a>Arrays from the Unity API</h3></div></div></div><p>There are several instructions within the Unity API that result in heap memory allocations, which we should be aware of. This essentially includes everything that returns an array of data. For example, the following methods allocate memory on the heap:</p><pre class="programlisting">GetComponents&lt;T&gt;(); // (T[])
Mesh.vertices; // (Vector3[])
Camera.allCameras; // (Camera[])</pre><p>Each and every time we call a Unity API method that returns an array, will cause a whole new version of that data to be allocated. Such methods should be avoided whenever possible or at the very least called once and cached so that we don't cause memory allocations more often than necessary.</p><p>There are other Unity API calls where we provide an array of elements to a method, and it writes the necessary data into the array for us. One such example is providing a <code class="literal">Particle[]</code> array to a <code class="literal">ParticleSystem</code> to get its <code class="literal">Particle</code> data. The benefit of these types of API calls is that we can avoid reallocating large arrays, whereas the downside is that the array needs to be large enough to fit all of the objects. If the number of objects we need to acquire keeps increasing, then we may find ourselves reallocating larger arrays. In the case of a <code class="literal">ParticleSystem</code>, we need to be certain we create an array large enough to contain the maximum number of <code class="literal">Particle</code> objects it generates at any given time.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip121"></a>Note</h3><p>Unity Technologies have hinted in the past that they may eventually change some of the API calls that return arrays into the form that requires an array to be provided. The API of the latter form can be confusing for new programmers on first glance; however, unlike the first form, it allows responsible programmers to use memory much more efficiently.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec110"></a>Using InstanceIDs for dictionary keys</h3></div></div></div><p>As mentioned in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>, dictionaries are used to map associations between two different objects, which are very quick at telling us whether a mapping exists, and if so, what that mapping is. It's common practice to map a <code class="literal">MonoBehaviour</code> or Scriptable Object reference as the key of a dictionary, but this causes some problems. When the dictionary element is accessed, it will need to call into several derived methods of <code class="literal">UnityEngine.Object</code>, which both of these object types derive from. This makes element comparison and mapping acquisition relatively slow.</p><p>This can be improved by making use of <code class="literal">Object.GetInstanceID()</code>, which returns an integer representing a unique identification value for that object that never changes and is never reused between two objects during the entire lifecycle of the application. If we cache this value in the object somehow and use it as the key in our dictionary, then the element comparison will be around two to three times faster than if we used the object reference directly.</p><p>However, there are caveats to this approach. If the instance ID value is not cached (we keep calling <code class="literal">Object.GetInstanceID()</code> each time we need to index into our dictionary) and we are compiling with Mono (and not IL2CPP), then element acquisition could end up being slow. This is because it will call some thread-unsafe code in order to acquire the instance ID, in which case, the Mono compiler cannot optimize the loop, and, therefore, causes some additional overhead by comparison to caching the instance ID value. If we are compiling with IL2CPP, which doesn't have this problem, then the benefits are still not as great (only around 50 percent faster) than if we had simply cached the value beforehand. Therefore, we should aim to cache the integer value in some way so that we avoid having to call <code class="literal">Object.GetInstanceID()</code> too often.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec111"></a>foreach loops</h3></div></div></div><p>The <code class="literal">foreach</code> loop keyword is a bit of a controversial issue in Unity development circles. It turns out that a lot of <code class="literal">foreach</code> loops implemented in Unity C# code will incur unnecessary heap memory allocations during these calls, as they allocate an <code class="literal">Enumerator</code> object as a <code class="literal">class</code> on the heap, instead of a <code class="literal">struct</code> on the stack. It all depends on the given collection's implementation of the <code class="literal">GetEnumerator()</code> method.</p><p>It turns out that every single collection that has been implemented in the version of Mono that comes with Unity (Mono version 2.6.5) will create classes instead of structs, which results in heap allocations. This includes, but is not limited to, <code class="literal">List&lt;T&gt;</code>, <code class="literal">LinkedList&lt;T&gt;</code>, <code class="literal">Dictionary&lt;K,V&gt;</code>, and <code class="literal">ArrayList</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip122"></a>Note</h3><p>Note that it is safe to use <code class="literal">foreach</code> loops on typical arrays. The Mono compiler secretly converts <code class="literal">foreach</code> over arrays into simple for loops.</p></div><p>The cost is fairly negligible, as the heap allocation cost does not scale with the number of iterations. Only one <code class="literal">Enumerator</code> object is allocated, and reused over and over again, which only costs a handful of bytes of memory overall. So, unless our <code class="literal">foreach</code> loops are being invoked for every update (which is typically dangerous in, and of, itself), the costs will be mostly negligible on small projects. The time taken to convert everything to a <code class="literal">for</code> loop may not be worth the time. However, it's definitely something to keep in mind for the next project we begin to write.</p><p>If we're particularly savvy with C#, Visual Studio, and manual compilation of the Mono assembly, then we can have Visual Studio perform code compilation for us and copy the resulting assembly DLL into the <code class="literal">Assets</code> folder, which will fix this mistake for the generic collections.</p><p>Note that performing <code class="literal">foreach</code> over a <code class="literal">Transform</code> Component is a typical shortcut to iterating over a <code class="literal">Transform</code> Component's children. Let's consider the following example:</p><pre class="programlisting">foreach (Transform child in transform) {
    // do stuff with 'child'
}</pre><p>However, this results in the same heap allocations mentioned above. As a result, that coding style should be avoided in favor of the following code:</p><pre class="programlisting">for (int i = 0; i &lt; transform.childCount; ++i) {
  Transform child = transform.GetChild(i);
  // do stuff with 'child'
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec112"></a>Coroutines</h3></div></div></div><p>As mentioned before, starting a Coroutine costs a small amount of memory to begin with, but note that no further costs are incurred when the method calls <code class="literal">yield</code>. If memory consumption and garbage collection are significant concerns, we should try to avoid having too many short-lived Coroutines and avoid calling <code class="literal">StartCoroutine()</code> too much during runtime.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec113"></a>Closures</h3></div></div></div><p>Closures are useful, but dangerous tools. Anonymous methods and lambda expressions are not always Closures, but they can be. It all depends on whether the method uses data outside of its own scope and parameter list or not.</p><p>For example, the following anonymous function would not be a Closure, since it is self-contained and functionally equivalent to any other locally defined function:</p><pre class="programlisting">System.Func&lt;int,int&gt; anon = (x) =&gt; { return x; };

int result = anon(5); // result = 5</pre><p>However, if the anonymous function pulled in data from outside itself, it becomes a Closure, as it <span class="emphasis"><em>closes the environment</em></span> around the required data. The following would result in a Closure:</p><pre class="programlisting">int i = 1024;
System.Func&lt;int,int&gt; anon = (x) =&gt; { return x + i; };
int result = anon(5);</pre><p>In order to complete this transaction, the compiler must define a new custom class that can reference the <span class="emphasis"><em>environment</em></span> where the data value <code class="literal">i</code> would be accessible. At runtime, it creates the corresponding object on the heap and provides it to the anonymous function. Note that this includes Value types (as per the above example), which were originally on the stack, possibly defeating the purpose of them being allocated on the stack in the first place. So, we should expect each invocation of the second method to result in heap allocations and inevitable garbage collection.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec114"></a>The .NET library functions</h3></div></div></div><p>The .NET library offers a huge amount of common functionalities that help solve numerous problems that programmers may come across during day-to-day implementation. Most of these classes and functions are optimized for general use cases, which may not be optimal for a specific situation. It may be possible to replace a particular .NET library class with a custom implementation that is more suited to our specific use case.</p><p>There are also two big features in the .NET library that often become big performance hogs whenever they're used. This tends to be because they are only included as a quick-and-dirty solution to a given problem without much effort put into optimization. These features are <span class="strong"><strong>LINQ</strong></span> and <span class="strong"><strong>Regular Expressions</strong></span>.</p><p>LINQ provides a way to treat arrays of data as miniature databases and perform queries against them using a SQL-like syntax. The simplicity of its coding style and complexity of the underlying system (through its usage of Closures) implies that it has a fairly large overhead cost. LINQ is a handy tool, but is not really intended for high-performance, real-time applications, such as games, and does not even function on platforms that do not support JIT compilation, such as iOS.</p><p>Meanwhile, Regular Expressions through the <code class="literal">Regex</code> class allow us to perform complex string parsing to find substrings that match a particular format, replace pieces of a string, or construct strings from various inputs. Regular Expression is another very useful tool, but tends to be overused in places where it is largely unnecessary or in so-called <span class="emphasis"><em>clever</em></span> ways to implement a feature such as text localization, when straightforward string replacement would be far more efficient.</p><p>Specific optimizations for both of these features go far beyond the scope of this book, as they could fill an entire book by themselves. We should either try to minimize their usage as much as possible, replace their usage with something less costly, bring in a LINQ or Regex expert to solve the problem for us, or do some Googling on the subject to optimize how we're using them.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip123"></a>Note</h3><p>One of the best ways to find the correct answer online is to simply post the wrong answer. People will either help us out of kindness or will take such a great offense to our implementation that they will consider it their civic duty to correct us. Just be sure to do some kind of research on the subject first. Even the busiest of people are generally happy to help if they can see that we've put in our fair share of effort beforehand.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec115"></a>Temporary work buffers</h3></div></div></div><p>If we get into the habit of using large, temporary work buffers for one task or another, then it just makes sense that we should look for opportunities to reuse them, instead of reallocating them over and over again, as this lowers the overhead involved in allocation and garbage collection (often called <span class="emphasis"><em>memory pressure</em></span>). It might be worthwhile to extract such functionality from case-specific classes into a generic God Class that contains a big work area for multiple classes to reuse.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec116"></a>Object Pooling</h3></div></div></div><p>Speaking of temporary work buffers, Object Pooling is an excellent way of both minimizing and establishing control over our memory usage by avoiding deallocation and reallocation. The idea is to formulate our own system for object creation, which hides away whether the object we're getting has been freshly allocated or has been recycled from an earlier allocation. The typical terms to describe this process are to <span class="emphasis"><em>spawn</em></span> and <span class="emphasis"><em>despawn</em></span> the object rather than creating and deleting them in memory. When an object is despawned, we're simply hiding it, making it lay dormant until we need it again, at which point it is <span class="emphasis"><em>respawned</em></span> from one of the previously despawned objects and used in place of an object we might have otherwise newly allocated.</p><p>Let's cover a quick implementation of an Object Pooling System.</p><p>An important feature of this system is to allow the pooled object to decide how to recycle itself when the time comes. The following Interface Class called <code class="literal">IPoolableObject</code> will satisfy this requirement nicely:</p><pre class="programlisting">public interface IPoolableObject{
  void New();
  void Respawn();
}</pre><p>This Interface Class defines two methods: <code class="literal">New()</code> and <code class="literal">Respawn()</code>. These should be called when the object is first created and when it has been respawned, respectively.</p><p>The following <code class="literal">ObjectPool</code> class definition is a fairly simple implementation of the Object Pooling concept:</p><pre class="programlisting">using System.Collections.Generic;

public class ObjectPool&lt;T&gt; where T : IPoolableObject, new() {
  private Stack&lt;T&gt; _pool;
  private int _currentIndex = 0;

  public ObjectPool(int initialCapacity) {
    _pool = new Stack&lt;T&gt;(initialCapacity);
    for(int i = 0; i &lt; initialCapacity; ++i) {
      Spawn (); // instantiate a pool of N objects
    }
    Reset ();
  }

  public int Count {
    get { return _pool.Count; }
  }

  public void Reset() {
    _currentIndex = 0;
  }

  public T Spawn() {
    if (_currentIndex &lt; Count) {
      T obj = _pool.Peek ();
      _currentIndex++;
      IPoolableObject po = obj as IPoolableObject;
      po.Respawn();
      return obj;
    } else {
      T obj = new T();
      _pool.Push(obj);
      _currentIndex++;
      IPoolableObject po = obj as IPoolableObject;
      po.New();
      return obj;
    }
  }
}</pre><p>This class allows the ObjectPool to be used with any object type so long as it fits the following two criteria: it must implement the <code class="literal">IPoolableObject</code> Interface Class, and the derived class must allow for a parameter-less constructor (specified by the <code class="literal">new()</code> keyword in the class declaration).</p><p>An example poolable object would look like so: it must implement two <code class="literal">public</code> methods, <code class="literal">New()</code> and <code class="literal">Respawn()</code>, which are invoked by the <code class="literal">ObjectPool</code> class at the appropriate times:</p><pre class="programlisting">public class TestObject : IPoolableObject {
  public void New() {
    // very first initialization here
  }
  public void Respawn() {
    // reset data which allows the object to be recycled here
  }
}</pre><p>Finally, consider an example usage to create a pool of 100 <code class="literal">TestObject</code> objects:</p><pre class="programlisting">private ObjectPool&lt;TestObject&gt; _objectPool = new ObjectPool&lt;TestObject&gt;(100);</pre><p>The first 100 calls to <code class="literal">Spawn()</code> on the <code class="literal">ObjectPool</code> will cause the objects to be respawned, providing the caller with a unique instance of the object each time. If there are no more objects to provide (we have called <code class="literal">Spawn()</code> more than 100 times), then we will allocate a new <code class="literal">TestObject</code> object and push it onto the Stack. Finally, if <code class="literal">Reset()</code> is called on the <code class="literal">ObjectPool</code>, it will begin again from the start, recycling objects and providing them to the caller.</p><p>Note that we are using the <code class="literal">Peek()</code> method on the <code class="literal">Stack</code> object so that we don't remove the old instance from the Stack. We want the <code class="literal">ObjectPool</code> to maintain references to all of the objects we create.</p><p>Also, note that this Pooling solution will not work for classes we haven't defined and cannot derive from <code class="literal">IPoolableObject</code>, such as <code class="literal">Vector3</code> and <code class="literal">Quaternion</code>. This is normally dictated by the <code class="literal">sealed</code> keyword in the class definition. In these cases, we would need to define a containing class:</p><pre class="programlisting">public class PoolableVector3 : IPoolableObject {
  public Vector3 vector = new Vector3();
  public void New() {
    Reset();
  }
  public void Respawn() {
    Reset();
  }
  public void Reset() {
    vector.x = vector.y = vector.z = 0f;
  }
}</pre><p>We could extend this system in a number of ways, such as defining a <code class="literal">Despawn()</code> method to handle destruction of the object, making use of the <code class="literal">IDisposable</code> Interface Class and <code class="literal">using</code> blocks when we wish to automatically spawn and despawn objects within a small scope, and/or allowing objects instantiated outside the pool to be added to it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec117"></a>Prefab Pooling</h3></div></div></div><p>The previous Pooling solution is useful for typical C# objects, but it won't work for specialized Unity objects, such as <code class="literal">GameObject</code> and <code class="literal">MonoBehaviour</code>. These objects tend to consume a large chunk of our runtime memory, can cost us a great deal of CPU usage when they're created and destroyed, and tend to risk a large amount of garbage collection at runtime. For instance, during the lifecycle of a small RPG game, we might spawn a thousand Orc creatures, but at any given moment, we may only need at a maximum, 10 of them. It would be nice if we could perform similar Pooling as before, but, for Unity Prefabs, to save on a lot of unnecessary overhead creating and destroying 990 Orcs we don't need.</p><p>Our goal is to push the overwhelming majority of object instantiation to Scene initialization rather than letting them get created at runtime. This can provide some big runtime CPU savings and avoids a lot of spikes caused by object creation/destruction and garbage collection at the expense of Scene loading times and runtime memory consumption. As a result, there are quite a few Pooling solutions available on the Asset Store for handling this task, with varying degrees of simplicity, quality, and feature sets.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip124"></a>Note</h3><p>It is often recommended that Pooling should be implemented in any game that intends to be deployed on mobile devices, due to the greater overhead costs involved in the allocation and deallocation of memory compared to desktop applications.</p></div><p>However, creating a Pooling solution is an interesting topic, and building one from scratch is a great way of getting to grips with a lot of important internal Unity Engine behavior. Also, knowing how such a system is built makes it easier to extend if we wish it to meet the needs of our particular game, rather than relying on a prebuilt solution.</p><p>The general idea of Prefab Pooling is to create a system that contains lists of active and inactive <code class="literal">GameObjects</code> that were all instantiated from the same Prefab reference. The following diagram shows how the system might look after several spawns, despawns, and respawns of various objects derived from four different Prefabs (<span class="strong"><strong>Orc</strong></span>, <span class="strong"><strong>Troll</strong></span>, <span class="strong"><strong>Ogre</strong></span>, and <span class="strong"><strong>Dragon</strong></span>):</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/b9aef900-2e1b-4ae4-ad4c-44dacebb2904.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note125"></a>Note</h3><p>Note that the <span class="emphasis"><em>Heap Memory</em></span> area in the previous screenshot represents the objects as they exist in memory, while the <span class="emphasis"><em>Pooling System</em></span> area represents the Pooling System's references to those objects.</p></div><p>In this example, several instances of each Prefab were instantiated (11 Orcs, 8 Trolls, 5 Ogres, and 1 Dragon). Currently, only 11 of these objects are active, while the other 14 have been previously despawned and are inactive. Note that the despawned objects still exist in memory, although they are not visible and cannot interact with the game world until they have been respawned. Naturally, this costs us a constant amount of heap memory at runtime in order to maintain the inactive objects, but when a new object is instantiated, we can reuse one of the existing inactive objects rather than allocating more memory in order to satisfy the request. This saves significant runtime CPU costs during object creation and destruction and avoids garbage collection.</p><p>The following diagram shows the chain of events that needs to occur when a new Orc is spawned:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/ad22590f-7d80-4c82-bd12-1fe1d266aa24.png" /></div><p>The first object in the <span class="strong"><strong>Inactive</strong></span> Orc pool (<span class="strong"><strong>Orc7</strong></span>) is reactivated and moved into the <span class="strong"><strong>Active</strong></span> pool. We now have six active Orcs and five inactive Orcs.</p><p>The following figure shows the order of events when an <span class="strong"><strong>Ogre</strong></span> object is despawned:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/80b80498-c2e9-41ab-b69d-7bf81837e2be.png" /></div><p>This time, the object is deactivated and moved from the Active pool into the Inactive pool, leaving us with one active Ogre and four inactive Ogres.</p><p>Finally, the following diagram shows what happens when a new object is spawned, but there are no inactive objects to satisfy the request:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/32feb664-47bb-446a-9fc9-0c5b98ee39c6.png" /></div><p>In this scenario, more memory must be allocated to instantiate the new Dragon object since there are no Dragon objects in its Inactive pool to reuse. Therefore, in order to avoid runtime memory allocations for our <code class="literal">GameObjects</code>, it is critical that we know beforehand how many we will need and that there is sufficient memory space available to contain them all at once. This will vary depending on the type of object in question and requires occasional testing and sanity-checking to ensure that we have a sensible number of each Prefab instantiated at runtime.</p><p>With all of this in mind, let's create a Pooling System for Prefabs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec104"></a>Poolable Components</h4></div></div></div><p>Let's first define an <code class="literal">interface</code> class for a Component that can be used in the Pooling System:</p><pre class="programlisting">public interface IPoolableComponent {
  void Spawned();
  void Despawned();
}</pre><p>The approach for <code class="literal">IPoolableComponent</code> will be very different from the approach taken for <code class="literal">IPoolableObject</code>. The objects being created this time are <code class="literal">GameObjects</code>, which are a lot trickier to work with than standard objects because of how much of their runtime behavior is already handled through the Unity Engine and how little low-level access we have to it.</p><p><code class="literal">GameObjects</code> do not give us access to an equivalent <code class="literal">New()</code> method that we can invoke any time the object is created, and we cannot derive from the <code class="literal">GameObject</code> class in order to implement one. <code class="literal">GameObjects</code> are created either by placing them in a Scene or by instantiating them at runtime through <code class="literal">GameObject.Instantiate()</code>, and the only inputs we can apply are an initial position and rotation. Of course, their Components have an <code class="literal">Awake()</code> callback that we can define, which is invoked the first time the Component is brought to life, but this is merely a compositional object--it's not the actual parent object we're spawning and despawning.</p><p>So, because we have control on only a <code class="literal">GameObject</code> class's Components, it is assumed that the <code class="literal">IPoolableComponent</code> Interface Class is implemented by at least one of the Components that is attached to the <code class="literal">GameObject</code> we wish to pool.</p><p>The <code class="literal">Spawned()</code> method should be invoked on every implementing Component each time the pooled <code class="literal">GameObject</code> is respawned, while the <code class="literal">Despawned()</code> method gets invoked whenever it is despawned. This gives us entry points to control the data variables and behavior during the creation and destruction of the parent <code class="literal">GameObject</code>.</p><p>The act of despawning a <code class="literal">GameObject</code> is trivial: turn its <code class="literal">active</code> flag to <code class="literal">false</code> through <code class="literal">SetActive()</code>. This disables the <code class="literal">Collider</code> and <code class="literal">Rigidbody</code> for physics calculations, removes it from the list of renderable objects, and essentially takes care of disabling all interactions with all built-in Unity Engine subsystems in a single stroke. The only exception is any Coroutines that are currently invoking on the object, since as you learned in <a class="ulink" href="https://cdp.packtpub.com/unity_2017_game_optimization__second_edition/wp-admin/post.php?post=123&amp;action=edit#post_44" target="_blank">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>, Coroutines are invoked independently of any <code class="literal">Update()</code> and <code class="literal">GameObject</code> activity. We will, therefore, need to call <code class="literal">StopCoroutine()</code> or <code class="literal">StopAllCoroutines()</code> during the despawning of such objects.</p><p>In addition, Components typically hook into our own custom gameplay subsystems as well, so the <code class="literal">Despawn()</code> method gives our Components the opportunity to take care of any custom cleanup before shutting down. For example, we would probably want to use <code class="literal">Despawn()</code> to deregister the Component from the Messaging System we defined in <a class="ulink" href="https://cdp.packtpub.com/unity_2017_game_optimization__second_edition/wp-admin/post.php?post=123&amp;action=edit#post_44" target="_blank">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>.</p><p>Unfortunately, successfully respawning the <code class="literal">GameObject</code> is a lot more complicated. When we respawn an object, there will be many settings that were left behind when the object was previously active, and these must be reset in order to avoid conflicting behaviors. A common problem with this is the Rigidbody's <code class="literal">linearVelocity</code> and <code class="literal">angularVelocity</code> properties. If these values are not explicitly reset before the object is reactivated, then the newly respawned object will continue moving with the same velocity the old version had when it was despawned.</p><p>This problem becomes further complicated by the fact that built-in Components are <code class="literal">sealed</code>, which means that they cannot be derived from. So, to avoid these issues, we can create a custom Component that resets the attached Rigidbody whenever the object is despawned:</p><pre class="programlisting">public class ResetPooledRigidbodyComponent : MonoBehaviour, IPoolableComponent {
  [SerializeField] Rigidbody _body;
  public void Spawned() {  }
  public void Despawned() {
    if (_body == null) {
      _body = GetComponent&lt;Rigidbody&gt;();
      if (_body == null) {
        // no Rigidbody!
        return;
      }
    }
    _body.velocity = Vector3.zero;
    _body.angularVelocity = Vector3.zero;
  }
}</pre><p>Note that the best place to perform the cleanup task is during despawning, because we cannot be certain in what order the <code class="literal">GameObject</code> class's <code class="literal">IPoolableComponent</code> Interface Classes will have their <code class="literal">Spawned()</code> methods invoked. It is unlikely that another <code class="literal">IPoolableComponent</code> will change the object's velocity during despawning, but it is possible that a different <code class="literal">IPoolableComponent</code> attached to the same object might want to set the Rigidbody's initial velocity to some important value during its own <code class="literal">Spawned()</code> method. Ergo, performing the velocity reset during the <code class="literal">ResetPooledRigidbodyComponent</code> class's <code class="literal">Spawned()</code> method could potentially conflict with other Components and cause some very confusing bugs.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip126"></a>Note</h3><p>In fact, creating Poolable Components that are not self-contained and tend to tinker with other Components like this, is one of the biggest dangers of implementing a Pooling System. We should minimize such design and routinely verify them when we're trying to debug strange issues in our game.</p></div><p>For the sake of illustration, here is the definition of a simple poolable Component making use of the <code class="literal">MessagingSystem</code> class we defined in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>. This Component automatically handles some basic tasks every time the object is spawned and despawned:</p><pre class="programlisting">public class PoolableTestMessageListener : MonoBehaviour, IPoolableComponent {
  public void Spawned() {
    MessagingSystem.Instance.AttachListener(typeof(MyCustomMessage), 
                                            this.HandleMyCustomMessage);
  }

  bool HandleMyCustomMessage(BaseMessage msg) {
    MyCustomMessage castMsg = msg as MyCustomMessage;
    Debug.Log (string.Format("Got the message! {0}, {1}", 
                             castMsg._intValue, 
                             castMsg._floatValue));
    return true;
  }

  public void Despawned() {
    if (MessagingSystem.IsAlive) {
      MessagingSystem.Instance.DetachListener(typeof(MyCustomMessage), 
                                              this.HandleMyCustomMessage);
    }
  }
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec105"></a>The Prefab Pooling System</h4></div></div></div><p>Hopefully, we now have an understanding of what we need from our Pooling System, so all that's left is to implement it. The requirements are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">It must accept requests to spawn a <code class="literal">GameObject</code> from a Prefab, an initial position, and an initial rotation:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">If a despawned version already exists, it should respawn the first available one</li><li style="list-style-type: disc">If it does not exist, then it should instantiate a new <code class="literal">GameObject</code> from the Prefab</li><li style="list-style-type: disc">In either case, the <code class="literal">Spawned()</code> method should be invoked on all <code class="literal">IPoolableComponent</code> Interface Classes attached to the <code class="literal">GameObject</code></li></ul></div></li><li style="list-style-type: disc">It must accept requests to despawn a specific <code class="literal">GameObject</code>:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">If the object is managed by the Pooling System, it should deactivate it and call the <code class="literal">Despawned()</code> method on all <code class="literal">IPoolableComponent</code> Interface Classes attached to the <code class="literal">GameObject</code></li><li style="list-style-type: disc">If the object is not managed by the Pooling System, it should send an error</li></ul></div></li></ul></div><p>The requirements are fairly  straightforward, but the implementation requires some investigation if we wish to make the solution performance-friendly. Firstly, a typical Singleton would be a good choice for the main entry point since we want this system to be globally accessible from anywhere:</p><pre class="programlisting">public static class PrefabPoolingSystem {}</pre><p>The main task for object spawning involves accepting a Prefab reference and figuring whether we have any despawned <code class="literal">GameObjects</code> that were originally instantiated from the same reference. To do this, we will essentially want our Pooling System to keep track of two different lists for any given Prefab reference: a list of active (spawned) <code class="literal">GameObjects</code>, and a list of inactive (despawned) objects that were instantiated from it. This information would be best abstracted into a separate class, which we will name <code class="literal">PrefabPool</code>.</p><p>In order to maximize the performance of this system (and hence make the largest gains possible, relative to just allocating and deallocating objects from memory all of the time), we will want to use some fast data structures in order to acquire the corresponding <code class="literal">PrefabPool</code> objects whenever a spawn or despawn request comes in.</p><p>Since spawning involves being given a Prefab, we will want a data structure that can quickly map Prefabs to the <code class="literal">PrefabPool</code> that manages them. Also, since despawning involves being given a <code class="literal">GameObject</code>, we will want another data structure that can quickly map spawned <code class="literal">GameObjects</code> to the <code class="literal">PrefabPool</code> that originally spawned them. A pair of dictionaries would be a good choice for both of these needs.</p><p>Let's define these dictionaries in our <code class="literal">PrefabPoolingSystem</code> class:</p><pre class="programlisting">public static class PrefabPoolingSystem {
  static Dictionary&lt;GameObject,PrefabPool&gt; _prefabToPoolMap = new Dictionary&lt;GameObject,PrefabPool&gt;();
  static Dictionary&lt;GameObject,PrefabPool&gt; _goToPoolMap = new Dictionary&lt;GameObject,PrefabPool&gt;();
}</pre><p>Next, we'll define what happens when we spawn an object:</p><pre class="programlisting">public static GameObject Spawn(GameObject prefab, Vector3 position, Quaternion rotation) {
  if (!_prefabToPoolMap.ContainsKey (prefab)) {
    _prefabToPoolMap.Add (prefab, new PrefabPool());
  }
  PrefabPool pool = _prefabToPoolMap[prefab];
  GameObject go = pool.Spawn(prefab, position, rotation);
  _goToPoolMap.Add (go, pool);
  return go;
}</pre><p>The <code class="literal">Spawn()</code> method will be given a Prefab reference, an initial position, and an initial rotation. We need to figure out which <code class="literal">PrefabPool</code> the Prefab belongs to (if any), ask it to spawn a new <code class="literal">GameObject</code> using the data provided, and then return the spawned object to the requestor. We will first check our <span class="emphasis"><em>Prefab-to-Pool</em></span> map to check whether a pool already exists for this Prefab. If not, we immediately create one. In either case, we then ask the <code class="literal">PrefabPool</code> to spawn us a new object. The <code class="literal">PrefabPool</code> will either end up respawning an object that was despawned earlier or instantiate a new one (if there aren't any inactive instances left).</p><p>This class doesn't particularly care how the <code class="literal">PrefabPool</code> creates the object. It just wants the instance generated by the <code class="literal">PrefabPool</code> class so that it can be entered into the <span class="emphasis"><em>GameObject-to-Pool</em></span> map and returned to the requestor.</p><p>For convenience, we can also define an overload that places the object at the world's center. This is useful for <code class="literal">GameObjects</code> that aren't visible and just need to exist in the Scene:</p><pre class="programlisting">public static GameObject Spawn(GameObject prefab) {
  return Spawn (prefab, Vector3.zero, Quaternion.identity);
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note127"></a>Note</h3><p>Note that no actual spawning and despawning are taking place, yet. This task will eventually be implemented within the <code class="literal">PrefabPool</code> class.</p></div><p>Despawning involves being given a <code class="literal">GameObject</code> and then figuring out which <code class="literal">PrefabPool</code> is managing it. This could be achieved by iterating through our <code class="literal">PrefabPool</code> objects and checking whether they contain the given <code class="literal">GameObject</code>. However, if we end up generating a lot of Prefab Pools, then this iterative process can take a while. We will always end up with as many <code class="literal">PrefabPool</code> objects as we have Prefabs (at least, so long as we manage all of them through the Pooling System). Most projects tend to have dozens, hundreds, if not thousands, of different Prefabs.</p><p>So, the <span class="emphasis"><em>GameObject-to-Pool</em></span> map is maintained to ensure that we always have rapid access to the <code class="literal">PrefabPool</code> that originally spawned the object. It can also be used to quickly check whether the given <code class="literal">GameObject</code> is even managed by the Pooling System to begin with. Here is the method definition for the despawning method, which takes care of these tasks:</p><pre class="programlisting">public static bool Despawn(GameObject obj) {
  if (!_goToPoolMap.ContainsKey(obj)) {
    Debug.LogError (string.Format ("Object {0} not managed by pool system!", obj.name));
    return false;
  }

  PrefabPool pool = _goToPoolMap[obj];
  if (pool.Despawn (obj)) {
    _goToPoolMap.Remove (obj);
    return true;
  }
  return false;
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note128"></a>Note</h3><p>Note that the <code class="literal">Despawn()</code> method of both <code class="literal">PrefabPoolingSystem</code> and <code class="literal">PrefabPool</code> returns a Boolean that can be used to check whether the object was successfully despawned.</p></div><p>As a result, thanks to the two maps we're maintaining, we can quickly access the <code class="literal">PrefabPool</code> that manages the given reference, and this solution will scale for any number of Prefab that the system manages.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec106"></a>Prefab pools</h4></div></div></div><p>Now that we have a system that can handle multiple Prefab pools automatically, the only thing left is to define the behavior of the pools. As mentioned previously, we will want the <code class="literal">PrefabPool</code> class to maintain two data structures: one for active (spawned) objects that have been instantiated from the given Prefab and another for inactive (despawned) objects.</p><p>Technically, the <code class="literal">PrefabPoolingSystem</code> class already maintains a map of which Prefab is governed by which <code class="literal">PrefabPool</code>, so we can actually save a little memory by making the <code class="literal">PrefabPool</code> dependent upon the <code class="literal">PrefabPoolingSystem</code> class to give it the reference to the Prefab it is managing. Consequently, the two data structures would be the only member variables the <code class="literal">PrefabPool</code> needs to keep track of.</p><p>However, for each spawned <code class="literal">GameObject</code>, it must also maintain a list of all of its <code class="literal">IPoolableComponent</code> references in order to invoke the <code class="literal">Spawned()</code> and <code class="literal">Despawned()</code> methods on them. Acquiring these references can be a costly operation to perform at runtime, so it would be best to cache the data in a simple struct:</p><pre class="programlisting">public struct PoolablePrefabData {
  public GameObject go;
  public IPoolableComponent[] poolableComponents;
}</pre><p>This <code class="literal">struct</code> will contain a reference to the <code class="literal">GameObject</code> and the precached list of all of its <code class="literal">IPoolableComponent</code> Components.</p><p>Now, we can define the member data of our <code class="literal">PrefabPool</code> class:</p><pre class="programlisting">public class PrefabPool {
  Dictionary&lt;GameObject,PoolablePrefabData&gt; _activeList = new Dictionary&lt;GameObject,PoolablePrefabData&gt;();
  Queue&lt;PoolablePrefabData&gt; _inactiveList = new Queue&lt;PoolablePrefabData&gt;();
}</pre><p>The data structure for the active list should be a dictionary in order to do a quick lookup for the corresponding <code class="literal">PoolablePrefabData</code> from any given <code class="literal">GameObject</code> reference. This will be useful during object despawning.</p><p>Meanwhile, the inactive data structure is defined as a <code class="literal">Queue</code>, but it will work equally well as a <code class="literal">List</code>, <code class="literal">Stack</code>, or really any data structure that needs to regularly expand or contract, where we only need to pop items from one end of the group, since it does not matter which object it is. It only matters that we retrieve one of them. A <code class="literal">Queue</code> is useful in this case because we can both retrieve and remove the object from the data structure in a single call to <code class="literal">Dequeue()</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec107"></a>Object spawning</h4></div></div></div><p>Let's define what it means to spawn a <code class="literal">GameObject</code> in the context of our Pooling System: at some point, <code class="literal">PrefabPool</code> will get a request to spawn a <code class="literal">GameObject</code> from a given Prefab, at a particular position and rotation. The first thing we should check is whether or not we have any inactive instances of the Prefab. If so, then we can dequeue the next available one from the <code class="literal">Queue</code> and respawn it. If not, then we need to instantiate a new <code class="literal">GameObject</code> from the Prefab using <code class="literal">GameObject.Instantiate()</code>. At this moment, we should also create a <code class="literal">PoolablePrefabData</code> object to store the <code class="literal">GameObject</code> reference and acquire the list of all <code class="literal">MonoBehaviours</code> that implement <code class="literal">IPoolableComponent</code> that are attached to it.</p><p>Either way, we can now activate the <code class="literal">GameObject</code>, set its position and rotation, and call the <code class="literal">Spawned()</code> method on all of its <code class="literal">IPoolableComponent</code> references. Once the object has been respawned, we can add it to the list of active objects and return it to the requestor.</p><p>The following is the definition of the <code class="literal">Spawn()</code> method that defines this behavior:</p><pre class="programlisting">public GameObject Spawn(GameObject prefab, Vector3 position, Quaternion rotation) {    
  PoolablePrefabData data;

  if (_inactiveList.Count &gt; 0) {
    data = _inactiveList.Dequeue();
  } else {
    // instantiate a new object
    GameObject newGO = GameObject.Instantiate(prefab, position, rotation) as GameObject;
    data = new PoolablePrefabData();
    data.go = newGO;
    data.poolableComponents = newGO.GetComponents&lt;IPoolableComponent&gt;();
  }

  data.go.SetActive (true);
  data.go.transform.position = position;
  data.go.transform.rotation = rotation;

  for(int i = 0; i &lt; data.poolableComponents.Length; ++i) {
    data.poolableComponents[i].Spawned ();
  }
  _activeList.Add (data.go, data);

  return data.go;
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec108"></a>Instance prespawning</h4></div></div></div><p>Since we are using <code class="literal">GameObject.Instantiate()</code> whenever the <code class="literal">PrefabPool</code> has run out of despawned instances, this system does not completely rid us of runtime object instantiation, hence heap memory allocation. It's important to prespawn the expected number of instances that we will need during the lifetime of the current Scene so that we minimize or remove the need to instantiate more during runtime.</p><p>Note that we shouldn't prespawn too many objects. It would be wasteful to prespawn 100 explosion Particle Effects, if the most we will ever expect to see in the Scene at any given time is three or four. Conversely, spawning too few instances will cause excessive runtime memory allocations, and the goal of this system is to push the majority of allocation to the start of a Scene's lifetime. We need to be careful about how many instances we maintain in memory so that we don't waste more memory space than necessary.</p><p>Let's define a method in our <code class="literal">PrefabPoolingSystem</code> class that we can use to quickly prespawn a given number of objects from a Prefab. This essentially involves spawning <code class="literal">N</code> objects and then immediately despawning them all:</p><pre class="programlisting">public static void Prespawn(GameObject prefab, int numToSpawn) {
  List&lt;GameObject&gt; spawnedObjects = new List&lt;GameObject&gt;();

  for(int i = 0; i &lt; numToSpawn; i++) {
    spawnedObjects.Add (Spawn (prefab));
  }

  for(int i = 0; i &lt; numToSpawn; i++) {
    Despawn(spawnedObjects[i]);
  }

  spawnedObjects.Clear ();
}</pre><p>We would use this method during Scene initialization to prespawn a collection of objects to use in the level. Take for example the following code:</p><pre class="programlisting">public class OrcPreSpawner : MonoBehaviour
  [SerializeField] GameObject _orcPrefab;
  [SerializeField] int _numToSpawn = 20;

  void Start() {
    PrefabPoolingSystem.Prespawn(_orcPrefab, _numToSpawn);
  }
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec109"></a>Object despawning</h4></div></div></div><p>Finally, there is the act of despawning the objects. As mentioned previously, this primarily involves deactivating the object, but we also need to take care of various bookkeeping tasks and invoking <code class="literal">Despawned()</code> on all of its <code class="literal">IPoolableComponent</code> references.</p><p>Here is the method definition for <code class="literal">PrefabPool.Despawn()</code>:</p><pre class="programlisting">public bool Despawn(GameObject objToDespawn) {
  if (!_activeList.ContainsKey(objToDespawn)) {
    Debug.LogError ("This Object is not managed by this object pool!");
    return false;
  }

  PoolablePrefabData data = _activeList[objToDespawn];

  for(int i = 0; i &lt; data.poolableComponents.Length; ++i) {
    data.poolableComponents[i].Despawned ();
  }

  data.go.SetActive (false);
  _activeList.Remove (objToDespawn);
  _inactiveList.Enqueue(data);
  return true;
}</pre><p>First, we verify that the object is being managed by the pool and then we grab the corresponding <code class="literal">PoolablePrefabData</code> in order to access the list of <code class="literal">IPoolableComponent</code> references. Once <code class="literal">Despawned()</code> is invoked on all of them, we deactivate the object, remove it from the active list, and push it into the inactive queue so that it can be respawned later.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec110"></a>Prefab pool testing</h4></div></div></div><p>The following class definition allows us to perform a simple hands-on test with the <code class="literal">PrefabPoolingSystem</code> class; it will support three Prefabs, and prespawn five instances of each during application initialization. We can press the <span class="emphasis"><em>1</em></span>, <span class="emphasis"><em>2</em></span>, <span class="emphasis"><em>3</em></span>, or <span class="emphasis"><em>4</em></span> keys to spawn an instance of each type, and then press <span class="emphasis"><em>Q</em></span>, <span class="emphasis"><em>W</em></span>, <span class="emphasis"><em>E</em></span> and <span class="emphasis"><em>R</em></span> to despawn a random instance of each type, respectively:</p><pre class="programlisting">public class PrefabPoolingTestInput : MonoBehaviour {
  [SerializeField] GameObject _orcPrefab;
  [SerializeField] GameObject _trollPrefab;
  [SerializeField] GameObject _ogrePrefab;
  [SerializeField] GameObject _dragonPrefab;

  List&lt;GameObject&gt; _orcs = new List&lt;GameObject&gt;();
  List&lt;GameObject&gt; _trolls = new List&lt;GameObject&gt;();
  List&lt;GameObject&gt; _ogres = new List&lt;GameObject&gt;();
  List&lt;GameObject&gt; _dragons = new List&lt;GameObject&gt;();

   void Start() {
     PrefabPoolingSystem.Prespawn(_orcPrefab, 11);
     PrefabPoolingSystem.Prespawn(_trollPrefab, 8);
     PrefabPoolingSystem.Prespawn(_ogrePrefab, 5);
     PrefabPoolingSystem.Prespawn(_dragonPrefab, 1);
   }

  void Update () {
    if (Input.GetKeyDown(KeyCode.Alpha1)) {SpawnObject(_orcPrefab, _orcs);}
    if (Input.GetKeyDown(KeyCode.Alpha2)) {SpawnObject(_trollPrefab, _trolls);}
    if (Input.GetKeyDown(KeyCode.Alpha3)) {SpawnObject(_ogrePrefab, _ogres);}
    if (Input.GetKeyDown(KeyCode.Alpha4)) {SpawnObject(_dragonPrefab, _dragons);}
    if (Input.GetKeyDown(KeyCode.Q)) { DespawnRandomObject(_orcs); }
    if (Input.GetKeyDown(KeyCode.W)) { DespawnRandomObject(_trolls); }
    if (Input.GetKeyDown(KeyCode.E)) { DespawnRandomObject(_ogres); }
    if (Input.GetKeyDown(KeyCode.R)) { DespawnRandomObject(_dragons); }
  }

  void SpawnObject(GameObject prefab, List&lt;GameObject&gt; list) {
    GameObject obj = PrefabPoolingSystem.Spawn (prefab, 
                                                5.0f * Random.insideUnitSphere, 
                                                Quaternion.identity);
    list.Add (obj);
  }

  void DespawnRandomObject(List&lt;GameObject&gt; list) {
    if (list.Count == 0) {
       // Nothing to despawn
       return;
    }

    int i = Random.Range (0, list.Count);
    PrefabPoolingSystem.Despawn(list[i]);
    list.RemoveAt(i);
  }
}</pre><p>Once we spawn more than five instances of any of the Prefabs, it will need to instantiate a new one in memory, costing us some memory allocation. However, if we observe the <strong class="userinput"><code>Memory Area</code></strong> in the <strong class="userinput"><code>Profiler</code></strong> window, while we only spawn and despawn instances that already exist, then we will notice that absolutely no new allocations take place.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec111"></a>Prefab Pooling and Scene loading</h4></div></div></div><p>There is one important caveat to this system that has not yet been mentioned: the <code class="literal">PrefabPoolingSystem</code> class will outlast Scene lifetime since it is a Static Class. This means that when a new Scene is loaded, the Pooling System's dictionaries will attempt to maintain references to any pooled instances from the previous Scene, but Unity forcibly destroys these objects regardless of the fact that we are still keeping references to them (unless they were set to <code class="literal">DontDestroyOnLoad()</code>), and so the dictionaries will be full of <code class="literal">null</code> references. This would cause some serious problems for the next Scene.</p><p>We should, therefore, create a method in <code class="literal">PrefabPoolingSystem</code> that resets the Pooling System in preparation for this likely event. The following method should be called before a new Scene is loaded so that it is ready for any early calls to <code class="literal">Prespawn()</code> in the next Scene:</p><pre class="programlisting">public static void Reset() {
  _prefabToPoolMap.Clear ();
  _goToPoolMap.Clear ();
}</pre><p>Note that if we also invoke a garbage collection during Scene transitions, there's no need to explicitly destroy the <code class="literal">PrefabPool</code> objects these dictionaries were referencing. Since these were the only references to the <code class="literal">PrefabPool</code> objects, they will be deallocated during the next garbage collection. If we aren't invoking garbage collection between Scenes, then the <code class="literal">PrefabPool</code> and <code class="literal">PooledPrefabData</code> objects will remain in memory until that time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec112"></a>Prefab Pooling summary</h4></div></div></div><p>This Pooling System provides a decent solution to the problem of runtime memory allocations for <code class="literal">GameObjects</code> and Prefabs, but, as a quick reminder, we need to be aware of the following caveats:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">We need to be careful about properly resetting important data in respawned objects (such as <code class="literal">Rigidbody</code> velocity)</li><li style="list-style-type: disc">We must ensure that we don't prespawn too few, or too many, instances of a Prefab</li><li style="list-style-type: disc">We should be careful of the order of execution of <code class="literal">Spawned()</code> and <code class="literal">Despawned()</code> methods on <code class="literal">IPoolableComponent</code> and not assume that they will be called in a particular order</li><li style="list-style-type: disc">We must call <code class="literal">Reset()</code> on <code class="literal">PrefabPoolingSystem</code> when loading a new Scene in order to clear any <code class="literal">null</code> references to objects, which may no longer exist</li></ul></div><p>There are several other features that we could implement. These will be left as academic exercises if we wish to extend this system in the future:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Any <code class="literal">IPoolableComponent</code> added to the <code class="literal">GameObject</code> after initialization will not have their <code class="literal">Spawned()</code> or <code class="literal">Despawned()</code> methods invoked since we only collect this list when the <code class="literal">GameObject</code> is first instantiated. We could fix this by changing <code class="literal">PrefabPool</code> to keep acquiring <code class="literal">IPoolableComponent</code> references every time <code class="literal">Spawned()</code> and <code class="literal">Despawned()</code> are invoked at the cost of additional overhead during spawning/despawning.</li><li style="list-style-type: disc">Any <code class="literal">IPoolableComponent</code> attached to children of the Prefab's root will also not be counted. This could be fixed by changing <code class="literal">PrefabPool</code> to use <code class="literal">GetComponentsInChildren&lt;T&gt;</code> at the cost of additional overhead if we're using Prefabs with deep hierarchies.
</li><li style="list-style-type: disc">Prefab instances that already exist in the Scene will not be managed by the Pooling System. We could create a Component that needs to be attached to such objects and that notifies the <code class="literal">PrefabPoolingSystem</code> class of its existence in its <code class="literal">Awake()</code> callback, which passes the reference along to the corresponding <code class="literal">PrefabPool</code>.</li><li style="list-style-type: disc">We could implement a way for <code class="literal">IPoolableComponent</code> to set a priority during acquisition and directly control the order of execution for their <code class="literal">Spawned()</code> and <code class="literal">Despawned()</code> methods.</li><li style="list-style-type: disc">We could add counters that keep track of how long objects have been sitting in the Inactive list relative to total Scene lifetime and print out the data during shutdown. This could tell us whether or not we're prespawning too many instances of a given Prefab.</li><li style="list-style-type: disc">This system will not interact kindly with Prefab instances that set themselves to <code class="literal">DontDestroyOnLoad()</code>. It might be wise to add a Boolean to every <code class="literal">Spawn()</code> call to say whether the object should persist or not and keep them in a separate data structure that is not cleared out during <code class="literal">Reset()</code>.</li><li style="list-style-type: disc">We could change <code class="literal">Spawn()</code> to accept an argument that allows the requestor to pass custom data to the <code class="literal">Spawned()</code> function of <code class="literal">IPoolableObject</code> for initialization purposes. This could use a system similar to how custom message objects were derived from the <code class="literal">Message</code> class for our Messaging System in <a class="ulink" href="https://cdp.packtpub.com/unity_2017_game_optimization__second_edition/wp-admin/post.php?post=123&amp;action=edit#post_44" target="_blank">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>.</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec118"></a>IL2CPP optimizations</h3></div></div></div><p>Unity Technologies have released a few blog posts on interesting ways to improve the performance of IL2CPP in some circumstances, but they can be difficult to manage. If you're using IL2CPP and need to eke out the last little bit of performance from our application that we can, then check out the blog series at the following links:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><a class="ulink" href="https://blogs.unity3d.com/2016/07/26/il2cpp-optimizations-devirtualization/" target="_blank">https://blogs.unity3d.com/2016/07/26/il2cpp-optimizations-devirtualization/</a></li><li style="list-style-type: disc"><a class="ulink" href="https://blogs.unity3d.com/2016/08/04/il2cpp-optimizations-faster-virtual-method-calls/" target="_blank">https://blogs.unity3d.com/2016/08/04/il2cpp-optimizations-faster-virtual-method-calls/</a></li><li style="list-style-type: disc"><a class="ulink" href="https://blogs.unity3d.com/2016/08/11/il2cpp-optimizations-avoid-boxing/" target="_blank">https://blogs.unity3d.com/2016/08/11/il2cpp-optimizations-avoid-boxing/</a></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec119"></a>WebGL optimizations</h3></div></div></div><p>Unity Technologies have also released a number of blog posts covering WebGL applications, which includes some crucial information about memory management that all WebGL developers should know. These can be found at the following links:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><a class="ulink" href="https://blogs.unity3d.com/2016/09/20/understanding-memory-in-unity-webgl/" target="_blank">https://blogs.unity3d.com/2016/09/20/understanding-memory-in-unity-webgl/</a></li><li style="list-style-type: disc"><a class="ulink" href="https://blogs.unity3d.com/2016/12/05/unity-webgl-memory-the-unity-heap/" target="_blank">https://blogs.unity3d.com/2016/12/05/unity-webgl-memory-the-unity-heap/</a></li></ul></div></div></div>