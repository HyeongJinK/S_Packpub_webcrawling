<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec11"></a>Update, Coroutines, and InvokeRepeating</h2></div></div><hr /></div><p>Another habit that's easy to fall into is to call something repeatedly in an <code class="literal">Update()</code> callback way more often than is needed. For example, we may start with a situation like this:</p><pre class="programlisting">void Update() {
  ProcessAI();
}</pre><p>In this case, we're calling some custom <code class="literal">ProcessAI()</code> subroutine every single frame. This may be a complex task, requiring the AI system to check some grid system to figure out where it's meant to move or determine some fleet maneuvers for a group of spaceships or whatever our game needs for its AI.</p><p>If this activity is eating into our frame rate budget too much, and the task can be completed less frequently than every frame with no significant drawbacks, then a good trick to improve performance is to simply reduce the frequency that <code class="literal">ProcessAI()</code> gets called:</p><pre class="programlisting">private float _aiProcessDelay = 0.2f;
private float _timer = 0.0f;

void Update() {
  _timer += Time.deltaTime;
  if (_timer &gt; _aiProcessDelay) {
    ProcessAI();
    _timer -= _aiProcessDelay;
  }
}</pre><p>In this case, we've reduced the <code class="literal">Update()</code> callback's overall cost by only invoking <code class="literal">ProcessAI()</code> about five times every second, which is an improvement over the previous situation, at the expense of code that can take a bit of time to understand at first glance, and a little extra memory to store some floating-point data. Although, at the end of the day we're still having Unity call an empty callback function more often than not.</p><p>This function is a perfect example of a function we could convert into a Coroutine to make use of their delayed invocation properties. As mentioned previously, Coroutines are typically used to script a short sequence of events, either as a one-time, or repeated, action. They should not be confused with threads, which would run on a completely different CPU core in a concurrent manner, and multiple threads can be running simultaneously. Instead, Coroutines run on the main thread in a sequential manner such that only one Coroutine is handled at any given moment, and each Coroutine decides when to pause and resume via <code class="literal">yield</code> statements. The following code is an example of how we might rewrite the above <code class="literal">Update()</code> callback in the form of a Coroutine:</p><pre class="programlisting">void Start() {
  StartCoroutine(ProcessAICoroutine ());
}

</pre><pre class="programlisting">IEnumerator ProcessAICoroutine () {
  while (true) {
    ProcessAI();
    yield return new WaitForSeconds(_aiProcessDelay);
  }
}</pre><p>The preceding code demonstrates a Coroutine that calls <code class="literal">ProcessAI()</code>, then pause at the <code class="literal">yield</code> statement for the given number of seconds (the value of  <code class="literal">_aiProcessDelay</code>) before the main thread resumes the Coroutine again. At which point, it will return to the start of the loop, call <code class="literal">ProcessAI()</code>, pause on the <code class="literal">yield</code> statement again, and repeat forever (via the <code class="literal">while(true)</code> statement) until asked to stop.</p><p>The main benefit of this approach is that this function will only be called as often as dictated by the value of <code class="literal">_aiProcessDelay</code>, and it will sit idle until that time, reducing the performance hit inflicted in most of our frames. However, this approach has its drawbacks.</p><p>For one, starting a Coroutine comes with an additional overhead cost relative to a standard function call (around three times as slow), as well as some memory allocations to store the current state in memory until it is invoked the next time. This additional overhead is also not a one-time cost because Coroutines often constantly call <code class="literal">yield</code>, which inflicts the same overhead cost again and again, so we need to ensure that the benefits of a reduced frequency outweighs this cost.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"></a>Note</h3><p>In a test of 1,000 objects with empty <code class="literal">Update()</code> callbacks, it took 1.1 milliseconds to process, whereas 1,000 Coroutines yielding on <code class="literal">WaitForEndOfFrame</code> (which has identical frequency to <code class="literal">Update()</code> callbacks) took 2.9 milliseconds. So, the relative cost is almost three times as much.</p></div><p>Secondly, once initialized, Coroutines run independent of the triggering <code class="literal">MonoBehaviour</code> Component’s <code class="literal">Update()</code> callback and will continue to be invoked regardless of whether the Component is disabled or not, which can make them unwieldy if we’re performing a lot of <code class="literal">GameObject</code> construction and destruction.</p><p>Thirdly, the Coroutine will automatically stop the moment the containing <code class="literal">GameObject</code> is made inactive for whatever reason (whether it was set inactive or one of its parents was) and will not automatically restart if the <code class="literal">GameObject</code> is set active again.</p><p>Finally, by converting a method into a Coroutine, we may have reduced the performance hit inflicted during most of our frames, but if a single invocation of the method body causes us to break our frame rate budget, then it will still be exceeded no matter how rarely we call the method. Therefore, this approach is best used for situations where we are only breaking our frame rate budget because of the sheer number of times the method is called in a given frame, not because the method is too expensive on its own. In those cases, we have no option but to either dig into and improve the performance of the method itself or reduce the cost of other tasks to free up the time it needs to complete its work.</p><p>There are several <code class="literal">yield</code> types available to us when generating Coroutines. <code class="literal">WaitForSeconds</code> is fairly self-explanatory; the Coroutine will pause at the <code class="literal">yield</code> statement for a given number of seconds. It is not exact an exact timer, however, so expect a small amount of variation when this <code class="literal">yield</code> type actually resumes.</p><p><code class="literal">WaitForSecondsRealTime</code> is another option and is different to <code class="literal">WaitForSeconds</code> only in that it uses unscaled time. <code class="literal">WaitForSeconds</code> compares against scaled time, which is affected by the global <code class="literal">Time.timeScale</code> property while <code class="literal">WaitForSecondsRealTime</code> is not, so be careful about which <code class="literal">yield</code> type you use if you’re tweaking the time scale value (for example, for slow motion effects).</p><p>There is also <code class="literal">WaitForEndOfFrame</code>, which would continue at the end of the next <code class="literal">Update()</code>, and then there’s <code class="literal">WaitForFixedUpdate</code>, which would continue at the end of the next <code class="literal">FixedUpdate()</code>. Lastly, Unity 5.3 introduced <code class="literal">WaitUntil</code> and <code class="literal">WaitWhile</code>, where we provide a delegate function, and the Coroutine will pause until the given delegate returns <code class="literal">true</code> or <code class="literal">false</code>, respectively. Note that the delegates provided to these <code class="literal">yield</code> types will be executed for each <code class="literal">Update()</code> until they return the Boolean value needed to stop them, which makes them very similar to a Coroutine using <code class="literal">WaitForEndOfFrame</code> in a <code class="literal">while</code>-loop that ends on a certain condition. Of course, it is also important that the delegate function we provide is not too expensive to execute.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Note</h3><p>Delegate functions are incredibly useful constructs in C# that allows us to pass local methods around as arguments to other methods and are typically used for callbacks. Check out the MSDN C# Programming Guide for more information on delegates at <a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/" target="_blank">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/</a>.</p></div><p>The way that some <code class="literal">Update()</code> callbacks are written could probably be condensed down into simple Coroutines that always call <code class="literal">yield</code> on one of these types, but we should be aware of the drawbacks mentioned previously. Coroutines can be tricky to debug since they don’t follow normal execution flow; there's no caller in the callstack we can directly blame as to why a Coroutine triggered at a given time, and if Coroutines perform complex tasks and interact with other subsystems, then they can result in some impossibly difficult bugs because they happened to be triggered at a moment that some other code didn't expect, which also tend to be the kinds of bugs that are painstakingly difficult to reproduce. If you do wish to make use of Coroutines, the best advice is to keep them simple and independent of other complex subsystems.</p><p>Indeed, if our Coroutine is simple enough that it can be boiled down to a <code class="literal">while</code>-loop that always calls <code class="literal">yield</code> on <code class="literal">WaitForSeconds</code>, or <code class="literal">WaitForSecondsRealtime</code> as in the above example, then we can usually replace it with an <code class="literal">InvokeRepeating()</code> call, which is even simpler to set up and has a slightly smaller overhead cost. The following code is functionally equivalent to the previous implementation that used a Coroutine to regularly invoke a <code class="literal">ProcessAI()</code> method:</p><pre class="programlisting">void Start() {
  InvokeRepeating("ProcessAI", 0f, _aiProcessDelay);
}</pre><p><span>An im</span>portant difference between <code class="literal">InvokeRepeating()</code> and Coroutines is that <code class="literal">InvokeRepeating()</code> is completely independent of both the <code class="literal">MonoBehaviour</code> and <code class="literal">GameObject's</code> state. The only two ways to stop an <code class="literal">InvokeRepeating()</code> call is to either call <code class="literal">CancelInvoke()</code> which stops all <code class="literal">InvokeRepeating()</code> callbacks initiated by the given <code class="literal">MonoBehaviour</code> (note that they cannot be canceled individually) or to destroy the associated <code class="literal">MonoBehaviour</code> or its parent <code class="literal">GameObject</code>. Disabling either the <code class="literal">MonoBehaviour</code> or <code class="literal">GameObject</code> does not stop <code class="literal">InvokeRepeating()</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"></a>Note</h3><p>A test of 1,000 <code class="literal">InvokeRepeating()</code> calls was processed in about 2.6 milliseconds; slightly faster than 1,000 equivalent Coroutine <code class="literal">yield</code> calls, which took 2.9 milliseconds.</p></div><p>That covers most of the useful information related to the <code class="literal">Update()</code> callback. Let’s look into some other useful scripting tips.</p></div>