<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch06"></a>Chapter 6. Dynamic Graphics</h2></div></div></div><p>There is no question that the Rendering Pipeline of a modern graphics device is complicated. Even rendering a single triangle to the screen requires a multitude of Graphics API calls, covering tasks such as creating a buffer for the Camera view that hooks into the Operating System (usually via some kind of windowing system), allocating buffers for vertex data, setting up data channels to transfer vertex and texture data from RAM to VRAM, configuring each of these memory spaces to use a specific set of data formats, determining the objects that are visible to the Camera, setting up and initiating a Draw Call for the triangle, waiting for the Rendering Pipeline to complete its task(s), and finally presenting the rendered image to the screen. However, there's a simple reason for this seemingly convoluted and over engineered way of drawing such a simple object--rendering often involves repeating the same tasks over and over again, and all of this initial setup makes future rendering tasks very fast.</p><p>CPUs are designed to handle virtually any computational scenario, but can't handle too many tasks simultaneously, whereas GPUs are designed for incredibly large amounts of parallelism, but they are limited in the complexity they can handle without breaking that parallelism. Their parallel nature requires immense amounts of data to be copied around very rapidly. During the setup of the Rendering Pipeline, we configure memory data channels for our graphics data to flow through. So, if these channels are properly configured for the types of data we will be passing, then they will operate more efficiently. However, setting them up poorly will result in the opposite.</p><p>Both the CPU and GPU are used during all graphics rendering, making it a high-speed dance of processing and memory management that spans software; hardware; multiple memory spaces, programming languages (each suited to different optimizations), processors, and processor types; and a large number of special-case features that can be thrown into the mix.</p><p>To make matters even more complicated, every rendering situation we will come across is different in its own way. Running the same application against two different GPUs often results in an apples-versus-oranges comparison due to the different capabilities and APIs they support. It can be difficult to determine where a bottleneck resides within such a complex web of hardware and software systems, and it can take a lifetime of industry work in 3D graphics if we want to have a strong, immediate intuition about the source of performance issues in modern Rendering Pipelines.</p><p>Thankfully, Profiling comes to the rescue once again, which makes becoming a <span class="emphasis"><em>Rendering Pipeline wizard</em></span> less of a necessity. If we can gather data about each device, use multiple performance metrics for comparison, and tweak our Scenes to observe how different rendering features affect their behavior, then we should have sufficient evidence to find the root cause of an issue and make appropriate changes. So, in this chapter, you will learn how to gather the right data, dig just deep enough into the Rendering Pipeline to find the true source of the problem, and explore various solutions and workarounds for a multitude of potential problems.</p><p>There are many topics to be covered when it comes to improving rendering performance. So, in this chapter, we will explore the following topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">A brief exploration of the Rendering Pipeline, focusing on the parts where the CPU and GPU come into play</li><li style="list-style-type: disc">General techniques on how to determine whether our rendering is limited by the CPU or by GPU</li><li style="list-style-type: disc">A series of performance optimization techniques and features, as follows:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">GPU Instancing</li><li style="list-style-type: disc">Level Of Detail (LOD) and other Culling Groups</li><li style="list-style-type: disc">Occlusion Culling</li><li style="list-style-type: disc">Particle Systems</li><li style="list-style-type: disc">Unity UI</li><li style="list-style-type: disc">Shader optimization</li><li style="list-style-type: disc">Lighting and Shadow optimization</li><li style="list-style-type: disc">Mobile-specific rendering enhancements</li></ul></div></li></ul></div></div>