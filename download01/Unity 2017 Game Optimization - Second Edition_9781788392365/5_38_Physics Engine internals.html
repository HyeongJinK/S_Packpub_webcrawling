<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec35"></a>Physics Engine internals</h2></div></div><hr /></div><p>Unity technically features two different Physics Engines: Nvidia's PhysX for 3D physics, and the Open Source project Box2D for 2D physics. However, their implementations are highly abstracted, and from the perspective of the higher-level Unity API that we configure through the main Unity Engine, both Physics Engine solutions operate in a functionally identical fashion.</p><p>In either case, the more we understand about Unity's Physics Engines, the more sense we can make of possible performance enhancements. So, first we'll cover some theory about how Unity implements these systems.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec42"></a>Physics and time</h3></div></div></div><p>Physics Engines generally operate under the assumption that time advances by fixed values, and both of Unity's Physics Engines operate in this manner. Each of these iterations is known as the <span class="strong"><strong>Timestep</strong></span>. The Physics Engine will only resolve each Timestep using very specific values of time, which is independent of how much time it took to render the previous frame. This is known in Unity as the Fixed Update Timestep, and it is set to a value of 20 milliseconds by default (50 updates per second).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note57"></a>Note</h3><p>It can be very difficult to generate consistent results for collisions and forces between two different computers if a Physics Engine uses a variable timestep due to differences in architecture (in how floating-point values are represented) as well as latency between clients. Such Physics Engines tend to generate very inconsistent results between multiplayer clients or during recorded replays.</p></div><p>The following diagram shows an important snippet of the Unity Order of Execution diagram:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/d29b80cd-e91f-427f-984e-f6e3da9baf40.png" /></div><p>The full Order of Execution diagram can be found at <a class="ulink" href="http://docs.unity3d.com/Manual/ExecutionOrder.html" target="_blank">http://docs.unity3d.com/Manual/ExecutionOrder.html</a>.</p><p>As we can see in the preceding diagram, Fixed Updates are processed just before the Physics Engine performs its own update and the two are inextricably linked. The process begins with determining whether enough time has passed to begin the next Fixed Update. Once this is determined, the outcome of resolving it will vary, depending on how much time has passed since the last Fixed Update.</p><p>If enough time has passed, then the Fixed Update processes will invoke all <code class="literal">FixedUpdate()</code> callbacks defined across all active MonoBehaviours in the Scene, followed by any Coroutines tied to Fixed Updates (specifically those that <code class="literal">yield</code> to <code class="literal">WaitForFixedUpdate</code>). Note that there is no guarantee of execution order for methods invoked during either of these processes, so we should never write code under this assumption. Once these tasks are done, the Physics Engine can begin to process the current timestep and invoke any necessary Trigger and Collider callbacks.</p><p>Conversely, if too little time has passed since the last Fixed Update (that is, less than 20 milliseconds), then the current Fixed Update is skipped, and all of the tasks listed previously don't happen during the current iteration. At this point, input, gameplay logic, and rendering will be allowed to happen as normal. Once this activity is complete, Unity checks whether the next Fixed Update is required.</p><p>At high frame rates, rendering updates are likely to complete multiple times before the Physics Engine gets a chance to update itself. This process repeats itself during runtime and effectively gives Fixed Updates and the Physics Engine a higher priority over rendering while also forcing the physics simulation into a fixed frame rate.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip58"></a>Note</h3><p>In order to ensure that objects move smoothly between Fixed Updates, Physics Engines (including Unity's) interpolate the visible location of each object between where it was during the previous state and where it should be after resolving the current state based on how much time remains until the next Fixed Update. This interpolation ensures that objects appear to move smoothly despite the fact that their physical positions, velocities, and so on are being updated less frequently than the render frame rate.</p></div><p>The <code class="literal">FixedUpdate()</code> callback is a useful place to define any gameplay behavior that we want to be frame-rate independent. AI calculations are commonly resolved in Fixed Updates since they tend to be easier to work with if we assume a fixed update frequency.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec40"></a>Maximum Allowed Timestep</h4></div></div></div><p>It is important to note that if a lot of time has passed since the last Fixed Update (for example, the game froze momentarily), then Fixed Updates will continue to be calculated within the same Fixed Update loop until the Physics Engine has <span class="emphasis"><em>caught up</em></span> with the current time. For example, if the previous frame took 100 ms to render (for example, a sudden CPU spike caused the main thread to block for a long time), then the Physics Engine will need to be updated five times. The <code class="literal">FixedUpdate()</code> method will, therefore, be called five times before <code class="literal">Update()</code> can be called again due to the default Fixed Update Timestep of 20 milliseconds. Of course, if there is a lot of physics activity to process during these five Fixed Updates, such that it takes more than 20 milliseconds to resolve them all, then the Physics Engine will need to invoke a sixth update.</p><p>Consequently, it's possible during moments of heavy physics activity that the Physics Engine takes more time to process a Fixed Update than the amount of time it is simulating. For example, if it took 30 ms to process a Fixed Update simulating 20 ms of Gameplay, then it has fallen behind, requiring it to process more Timesteps to try and keep up, but this could cause it to fall behind even further, requiring it to process even more Timesteps, and so on. In these situations the Physics Engine is never able to escape the Fixed Update loop and allow another frame to render. This problem is often known as the <span class="strong"><strong>spiral of death</strong></span>. However, to prevent the Physics Engine from locking up our game during these moments, there is a maximum amount of time that the Physics Engine is allowed to process each Fixed Update loop. This threshold is called the <span class="strong"><strong>Maximum Allowed Timestep</strong></span>, and if the current batch of Fixed Updates takes too long to process, then it will simply stop and forgo further processing until the next render update completes. This design allows the Rendering Pipeline to at least render the current state and allow for user input and gameplay logic to make some decisions during rare moments where the Physics Engine has gone ballistic (pun intended).</p><p>This setting can be accessed through <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Time</code></strong> | <strong class="userinput"><code>Maximum Allowed Timestep</code></strong>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec41"></a>Physics updates and runtime changes</h4></div></div></div><p>When the Physics Engine processes a given timestep, it must move any active Rigidbody objects (<code class="literal">GameObjects</code> with a <code class="literal">Rigidbody</code> Component), detect any new collisions, and invoke the collision callbacks on the corresponding objects. The Unity documentation makes an explicit note that changes to Rigidbody objects should be handled within <code class="literal">FixedUpdate()</code> and other physics callbacks for exactly this reason. These methods are tightly coupled with the update frequency of the Physics Engine as opposed to other parts of the Game Loop, such as <code class="literal">Update()</code>.</p><p>This means that callbacks such as <code class="literal">FixedUpdate()</code> and <code class="literal">OnTriggerEnter()</code> are safe places to make Rigidbody changes, whereas methods such as <code class="literal">Update()</code> and Coroutines yielding on <code class="literal">WaitForSeconds</code> or <code class="literal">WaitForEndOfFrame</code> are not. Ignoring this advice could cause unexpected physics behavior, as multiple changes may be made to the same object before the Physics Engine is given a chance to catch and process all of them.</p><p>It's particularly dangerous to apply forces or impulses to objects in <code class="literal">Update()</code> callbacks without taking into account the frequency of those calls. For instance, applying a 10-Newton force each Update while the player holds down a key would result in completely different resultant velocity between two different devices than if we did the same thing in Fixed Update since we can't rely on the number of <code class="literal">Update()</code> calls being consistent. However, doing so in a <code class="literal">FixedUpdate()</code> callback will be much more consistent. Therefore, we must ensure that all physics-related behavior is handled in the appropriate callbacks or we will risk introducing some especially confusing gameplay bugs that are very hard to reproduce.</p><p>It logically follows that the more time we spend in any given Fixed Update iteration, the less time we have for the next gameplay and rendering pass. Most of the time this results in minor, unnoticeable background processing tasks, since the Physics Engine barely has any work to do, and the <code class="literal">FixedUpdate()</code> callbacks have a lot of time to complete their work. However, in some games, the Physics Engine could be performing a lot of calculations during each and every Fixed Update. This kind of bottlenecking in physics processing time will affect our frame rate, causing it to plummet as the Physics Engine is tasked with greater and greater workloads. Essentially, the Rendering Pipeline will try to proceed as normal, but whenever it's time for a Fixed Update, in which the Physics Engine takes a long time to process, the Rendering Pipeline would have very little time to generate the current display before the frame is due, causing a sudden stutter. This is in addition to the visual effect of the Physics Engine stopping early because it hit the Maximum Allowed Timestep. All of this together would generate a very poor user experience.</p><p>Hence, in order to keep a smooth and consistent frame rate, we will need to free up as much time as we can for rendering by minimizing the amount of time the Physics Engine takes to process any given timestep. This applies in both the best-case scenario (nothing moving) and worst-case scenario (everything smashing into everything else at once). There are a number of time-related features and values we can tweak within the Physics Engine to avoid performance pitfalls such as these.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec43"></a>Static Colliders and Dynamic Colliders</h3></div></div></div><p>There is a rather extreme namespace conflict with the terms <span class="emphasis"><em>static</em></span> and <span class="emphasis"><em>dynamic</em></span> in Unity. When <span class="emphasis"><em>static</em></span> is used, it normally means that the object or process under discussion is not moving, remains unchanged, or exists in only one location, whereas <span class="emphasis"><em>dynamic</em></span> simply means the opposite--objects or processes that tend to move or change. However, it's important to remember that each of these are separate topics and usage of the terms <span class="emphasis"><em>static</em></span> and <span class="emphasis"><em>dynamic</em></span> mean something different in each case. We have already introduced the <strong class="userinput"><code>Static</code></strong> subflags for <code class="literal">GameObjects</code>, the Dynamic Batching and Static Batching systems, and the concepts of Static classes, <code class="literal">static</code> variables, and <code class="literal">static</code> functions in the C# language. So, just to be extra-confusing, Unity also has the concept of Static and Dynamic Colliders.</p><p>Dynamic Colliders simply mean <code class="literal">GameObjects</code> that contain both a <code class="literal">Collider</code> Component (which could be one of several types) and a <code class="literal">Rigidbody</code> Component. By attaching a Rigidbody to the same object as a Collider, the Physics engine will treat that Collider as the bounding volume of a physical object that must react to outside forces (such as gravity) and collisions with other Rigidbodies. If we collide one Dynamic Collider into another, they will both react based on Newton's Laws of Motion (or at least as best as a computer using floating-point arithmetic is capable of).</p><p>We can also have Colliders that do not have a <code class="literal">Rigidbody</code> Component attached, and these are called Static Colliders. These effectively work as invisible barriers that Dynamic Colliders can collide into, but the Static Collider will not react in response. To think of it another way, imagine objects without a <code class="literal">Rigidbody</code> Component as having infinite mass. No matter how hard you throw a rock into an object of infinite mass, it will never move, but you can still expect the rock to react like it just hit a solid wall. This makes Static Colliders ideal for world barriers and other obstacles that must not move.</p><p>The Physics Engine automatically separates Dynamic Colliders and Static Colliders into two different data structures, each optimized to handle the types of Collider present. This helps to simplify future processing tasks since, for example, there's no point resolving collisions and impulses between two Static Colliders.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec44"></a>Collision detection</h3></div></div></div><p>There are three settings for collision detection in Unity, which can be configured in a <code class="literal">RigidBody</code> Component's <strong class="userinput"><code>Collision Detection</code></strong> property: <strong class="userinput"><code>Discrete</code></strong>, <strong class="userinput"><code>Continuous</code></strong>, and <strong class="userinput"><code>ContinuousDynamic</code></strong>. The <strong class="userinput"><code>Discrete</code></strong> setting enables Discrete collision detection, which effectively teleports objects a small distance every timestep based on their velocity and how much time has passed. Once all the objects have been moved, it then performs a bounding volume check for any overlaps, treats them as collisions, and resolves them based on their physical properties and how they overlap. This method risks collisions being missed if small objects move too quickly.</p><p>The following image shows how Discrete collision detection works to catch two objects as they teleport from one location to the next:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/d2b5c32c-08c6-4561-8851-22207d8bde12.png" /></div><p>Either of the remaining settings will enable Continuous collision detection, which works by interpolating Colliders from their starting and ending positions for the current timestep and checking for any collisions along the way. This reduces the risk of missed collisions and generates a more accurate simulation at the expense of a significantly greater CPU overhead compared to Discrete collision detection.</p><p>The <strong class="userinput"><code>Continuous</code></strong> setting enables Continuous collision detection only between the given Collider and Static Colliders. Collisions between the same Collider and Dynamic Colliders will still make use of Discrete collision detection. Meanwhile, the <strong class="userinput"><code>ContinuousDynamic</code></strong> setting enables Continuous collision detection between the Collider and all Static and Dynamic Colliders, making it the most expensive in terms of resources.</p><p>The following diagram shows how the Discrete and Continuous collision detection methods work for a pair of small, fast-moving objects:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/5c4eddb0-5575-4587-a887-7b2562019d50.png" /></div><p>This is an extreme example for the sake of illustration. In the case of Discrete collision detection, we can observe that the objects are teleporting a distance around four times their own size in a single timestep, which would typically only happen with very small objects with very high velocities, and is, hence, very rare if our game is running optimally. In the overwhelming majority of cases, the distances the objects travel in a single 20-milliseconds timestep are much smaller relative to the size of the object, and so the collision is easily caught by Discrete collision detection methods.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec45"></a>Collider types</h3></div></div></div><p>There are four different types of 3D Colliders in Unity. In order of the lowest performance cost to the greatest, they are Sphere, Capsule, Box, and Mesh Colliders. The first three Collider types are often called <span class="emphasis"><em>primitives</em></span> and maintain very specific shapes, although they can generally be scaled in different directions to meet certain needs. Mesh Colliders can, however, be customized to a particular shape depending on the assigned mesh. There are also three types of 2D Colliders--Circle, Box, and Polygon--that are functionally similar to Sphere, Box, and Mesh Colliders, respectively. All of the following information is essentially transferable to the equivalent 2D shape.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip59"></a>Note</h3><p>Note that we can also generate cylindrical 3D objects in Unity, but this is only for its graphical representation. Autogenerated Cylinder shapes use Capsule Colliders to represent their physical bounding volume, which may not create the expected physics behavior.</p></div><p>In addition, there are two varieties of Mesh Collider: <span class="strong"><strong>Convex</strong></span> and <span class="strong"><strong>Concave</strong></span>. The difference is that a Concave shape features at least one internal angle (an angle between two inside edges of the shape) of greater-than 180 degrees. To illustrate this, the following diagram shows the difference between Convex and Concave shapes:</p><div class="mediaobject"><img src="/graphics/9781788392365/graphics/f41a865e-e413-4b47-b197-3b43bb743dd2.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip60"></a>Note</h3><p>An easy way to remember the difference between a Convex and Concave shape is that a Concave shape has at least one <span class="emphasis"><em>cave</em></span> within it.</p></div><p>Both Mesh Collider types use the same Component (a <code class="literal">MeshCollider</code> Component). The type of Mesh Collider that gets generated is toggled using the <strong class="userinput"><code>Convex</code></strong> checkbox. Enabling this option will allow the object to collide with all primitive shapes (Spheres, Boxes, and so on) as well as other Mesh Colliders with <strong class="userinput"><code>Convex</code></strong> enabled. In addition, if the <strong class="userinput"><code>Convex</code></strong> checkbox is enabled for a Mesh Collider with a Concave shape, then the Physics Engine will automatically simplify it, generating a Collider with the nearest Convex shape it can. In the preceding example, if we imported the Concave mesh on the right and enable the <strong class="userinput"><code>Convex</code></strong> checkbox, it would generate a Collider shape closer to the Convex shape on the left. In either case, the Physics Engine will attempt to generate a Collider that matches the shape of the attached mesh with an upper limit of 255 vertices. If the target mesh has more vertices than this, it will throw an error during mesh generation.</p><p>Collider Components also contain the <code class="literal">IsTrigger</code> property, allowing them to be treated as nonphysical objects, but still invoke physics events when other Colliders enter or leave them. These are called Trigger Volumes. Normally, a Collider's <code class="literal">OnCollisionEnter()</code>, <code class="literal">OnCollisionStay()</code>, and <code class="literal">OnCollisionExit()</code> callbacks are called when another Collider touches, keeps touching (each timestep), or stops touching it, respectively. However, when the Collider is used as a Trigger Volume, the <code class="literal">OnTriggerEnter()</code>, <code class="literal">OnTriggerStay()</code>, and <code class="literal">OnTriggerExit()</code> callbacks will be used instead.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note61"></a>Note</h3><p>Note that due to the complexity of resolving inter-object collisions, Concave Mesh Colliders cannot also be Dynamic Colliders. Concave shapes can only be used as Static Colliders or Trigger Volumes. If we attempt to add a <code class="literal">Rigidbody</code> Component to a Concave Mesh Collider, Unity will simply ignore it.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec46"></a>The Collision Matrix</h3></div></div></div><p>The Physics Engine features a Collision Matrix that defines which objects are allowed to collide with which other objects. Objects that do not fit this matrix are automatically ignored by the Physics Engine when the time comes to resolve bounding volume overlaps and collisions. This saves on physics processing during collision detection stages and also allows the objects to move through one another without any collisions taking place.</p><p>The Collision Matrix can be accessed through <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>(Physics / Physics2D) | Layer Collision Matrix</code></strong>.</p><p>The Collision Matrix system works through Unity's Layer system. The matrix represents every possible Layer-to-Layer combination that might be possible, and enabling a checkbox means that Colliders in both of those Layers will be checked during the collision detection phase. Note that there's no way to allow only one of the two objects to respond to the collision. If one Layer can collide with another, then they must both respond to the collision. However, Static Colliders are an exception since they aren't allowed to respond physically to collisions (although they still receive the <code class="literal">OnCollision...()</code> callbacks).</p><p>Note that we are limited to only 32 total Layers for our entire project (since the Physics Engine uses a 32-bit bitmask to determine inter-Layer collision opportunities), so we must organize our objects into sensible Layers that will extend throughout the entire lifetime of the project. If, for whatever reason, 32 Layers are not enough for our project, then we might need to find cunning ways to reuse Layers or remove Layers that aren't necessary.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec47"></a>Rigidbody active and sleeping states</h3></div></div></div><p>Every modern Physics Engine shares a common optimization technique, whereby objects that have come to rest have their internal state changed from an active state to a sleeping state. While a Rigidbody is in the sleeping state, little-to-no processor time will be spent during Fixed Updates to update the object until it has been awoken by an external force or collision event.</p><p>The value of measurement that is used to determine what <span class="emphasis"><em>at rest</em></span> means tends to vary among different Physics Engines; it could be calculated using linear and rotational speed, kinetic energy, momentum, or some other physical properties of the Rigidbody. Both of Unity's Physics Engines work by evaluating the object's <span class="emphasis"><em>mass-normalized-kinetic-energy</em></span>, which essentially boils down to <span class="emphasis"><em>the magnitude of its velocity-squared</em></span>.</p><p>If the object's velocity has not exceeded some threshold value after a short time, then the Physics Engine will assume that the object will no longer need to move again until it has undergone a new collision, or a new force has been applied to it. Until then, the sleeping object will maintain its current position. Setting the threshold value too low would mean objects are much less likely to go to sleep, so we will keep paying a small processing cost within the Physics Engine every Fixed Update, even though it is not doing anything important. Meanwhile, setting the threshold value too high would mean slow-moving objects will appear to jerk to a sudden stop once the Physics Engine decides that they need to go to sleep. The threshold value that controls the sleeping state can be modified under <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Physics</code></strong> | <strong class="userinput"><code>Sleep Threshold</code></strong>. We can also get a count of the total number of active Rigidbody objects from the <strong class="userinput"><code>Physics Area of the <strong class="userinput"><code>Profiler</code></strong> window.</code></strong></p><p>Note that sleeping objects are not removed entirely from the simulation. If a moving Rigidbody approaches the sleeping object, then it must still perform checks to see whether nearby objects have collided with it, which would reawaken the sleeping object, reintroducing it to the simulation for processing.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec48"></a>Ray and object casting</h3></div></div></div><p>Another common feature of Physics Engines is the ability to <span class="emphasis"><em>cast a ray</em></span> from one point to another and generate collision information with one or more of the objects in its path. This is known as <span class="strong"><strong>Raycasting</strong></span>. It is pretty common to implement several gameplay mechanics through Raycasting, such as firing a gun. This is typically implemented by performing Raycasts from the player to the target location and finding any viable targets in its path (even if it's just a wall).</p><p>We can also obtain a list of targets within a finite distance of a fixed point in space using a <code class="literal">Physics.OverlapSphere()</code> check. This is typically used to implement area-of-effect gameplay features, such as grenade or fireball explosions. We can even cast entire objects forward in space using <code class="literal">Physics.SphereCast()</code> and <code class="literal">Physics.CapsuleCast()</code>. These methods are often used to simulate wide laser beams, or if we simply want to see what would be in the path of a moving character.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec49"></a>Debugging Physics</h3></div></div></div><p><span>Physics bugs usually fall into two categories: an object pair collided/didn't collide when it shouldn't have/should have or the objects collided but something unexpected happened after the fact. The former case is generally easier to debug; it is often either due to mistakes in the Collision Matrix, incorrect Layers used in Raycasting, or object Colliders being the wrong size or shape. The latter case is often much more difficult to resolve because of three big problems:</span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Determining which collided objects caused the issue</li><li style="list-style-type: disc">Determining the conditions of the collision just prior to resolution</li><li style="list-style-type: disc">Reproducing the collision</li></ul></div><p>Any of these three pieces of information would make resolution much easier, but they can all be difficult to obtain in some circumstances.</p><p>The Profiler provides some measure of information in the <strong class="userinput"><code>Physics and <strong class="userinput"><code>Physics (</code></strong><strong class="userinput"><code><strong class="userinput"><code>2D)</code></strong> Areas</code></strong> (for 3D and 2D physics, respectively), which can be moderately useful. We can get a measure of how much CPU activity is being spent on all Rigidbodies and groups of Rigidbodies isolated to different types such as Dynamic Colliders, Static Colliders, Kinematic objects, Trigger Volumes, Constraints (used to simulate hinges and other connected physics objects), and Contacts. The <strong class="userinput"><code>Physics 2</code></strong><strong class="userinput"><code><strong class="userinput"><code>D</code></strong> Area</code></strong> contains a little more information such as the number of sleeping and active Rigidbodies and how long processing the Timestep took. The <strong class="userinput"><code>Detailed Breakdown View</code></strong> provides even more information in both cases. This information helps us keep an eye on Physics performance, but it doesn't tell us much about what went wrong in the event we find a bug in our physics behavior.</code></strong></p><p>A tool that is better suited to the task of helping us debug physics issues is the <strong class="userinput"><code>Physics Debugger</code></strong>, which can be opened via <strong class="userinput"><code>Window</code></strong> | <strong class="userinput"><code>Physics Debugger</code></strong>. This tool can help us filter out different types of Colliders from the <strong class="userinput"><code>Scene</code></strong> window to give us a better idea of which objects collided with one another. Of course, this does not help too much in determining the conditions of the problem and reproducing issues.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip62"></a>Note</h3><p>Note that settings in the Physics Debugger do not affect object visibility in the <strong class="userinput"><code>Game</code></strong> window.</p></div><p>Unfortunately, there isn't much secret advice to be given for the remaining problems. Catching information about collisions before or when they happen normally involves a lot of targeted breakpoints in an <code class="literal">OnCollisionEnter()</code> or <code class="literal">OnTriggerEnter()</code> callback to catch the problem in the act and using step-through debugging until the source of the issue becomes clear. As a last resort, we can add <code class="literal">Debug.Log()</code> statements to log important information just before the problem occurs, although this can be a frustrating exercise because we sometimes don't know what information we need to log, or which objects to log from, and so we end up adding logs to everything.</p><p>Another frequent source of headaches is trying to reproduce physics problems. Reproducing collisions is always a challenge due to the nondeterministic nature between user input (normally handled in <code class="literal">Update()</code>) and physics behavior (handled in <code class="literal">FixedUpdate()</code>). Even though physics timesteps occur with relative regularity, the simulation will have different timings on each <code class="literal">Update()</code> between one session and the next, so even if we recorded user input timings and automatically replayed the Scene, trying to apply the recorded inputs at the moments they were applied isn't going to be exactly the same every time, and so we may not get the exact same result.</p><p>Moving user input handling to <code class="literal">FixedUpdate()</code> is possible, and helpful, if user input controls Rigidbody behavior such as applying forces in different directions while the player holds down certain keys. However, this will tend to lead to input latency or <span class="emphasis"><em>lag</em></span>, since it will be anywhere from 0 to 20 milliseconds (based on the Fixed Update timestep frequency) before the Physics Engine can respond to the key being pressed. Instantaneous inputs, such as jumping or activating an ability, are always best handled in <code class="literal">Update()</code> in order to avoid missing keystrokes. Helper functions such as <code class="literal">Input.GetKeyDown()</code> would only return <code class="literal">true</code> for the frame the player presses the given key and will return <code class="literal">false</code> during the next <code class="literal">Update()</code>. If we tried to read a <span class="emphasis"><em>key-down</em></span> event during a <code class="literal">FixedUpdate()</code>, we would never know that the user pressed the key, unless a physics timestep just happens to occur between these two frames. This can be worked around with an input buffering/tracking system, but this is certainly more trouble than its worth if we're implementing it merely to replicate a physics bug.</p><p>Ultimately, experience and persistence are the only good ways to debug most physics problems. The more experience we have with the Physics Engine, the more intuition we will have to find the source of the problem, but unfortunately they almost always take a lot of time to resolve due to their limited reproducibility and sometimes nebulous behavior, and so we should expect physics issues to take longer than most logic bugs to resolve and plan extra time before it can be resolved.</p></div></div>