<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec32"></a>Mesh and animation files</h2></div></div><hr /></div><p>Finally, let's cover mesh and animation files. These file types are essentially large arrays of vertex and skinned bone data, and there are a variety of techniques we can apply to minimize file size, while keeping a similar, if not identical, appearance. There are also ways to lower the cost of rendering large groups of these objects through batching techniques. Let's take a look at a series of performance-enhancing techniques we can apply to such files.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec37"></a>Reduce polygon count</h3></div></div></div><p><span>This</span> is the most obvious way to gain performance and should always be considered. In fact, since we cannot batch objects using Skinned Mesh Renderers, it's one of the good ways of reducing CPU and GPU runtime overhead for animated objects.</p><p>Reducing the polygon count is simple, straightforward, and provides both CPU and memory cost savings for the time required for artists to clean up the mesh. Much of an object's detail is provided almost entirely by detailed texturing and complex shading in this day and age, so we can often get away with stripping away a lot of vertices on modern meshes and most users would be unable to tell the difference.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec38"></a>Tweak Mesh Compression</h3></div></div></div><p>Unity offers four different <strong class="userinput"><code>Mesh Compression</code></strong> settings for imported mesh files: <strong class="userinput"><code>Off</code></strong>, <strong class="userinput"><code>Low</code></strong>, <strong class="userinput"><code>Medium</code></strong>, and <strong class="userinput"><code>High</code></strong>. Increasing this setting will convert floating-point data into fixed values, reducing the accuracy in vertex position/Normal direction, simplifying vertex color information, and so on. This can have a noticeable effect on meshes that contain lots of small parts near one another, such as a fence or grate. If we're generating meshes procedurally, we can achieve the same type of compression by calling the <code class="literal">Optimize()</code> method of a <code class="literal">MeshRenderer</code> Component (of course, this will take some time to complete).</p><p>There are also two global settings found in <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Player</code></strong> | <strong class="userinput"><code>Other Settings</code></strong>, which can affect how mesh data is imported. These are named <strong class="userinput"><code>Vertex Compression</code></strong> and <strong class="userinput"><code>Optimize Mesh Data</code></strong>.</p><p>We can use the <strong class="userinput"><code>Vertex Compression</code></strong> option to configure the type of data that will be optimized when we import a mesh file with <strong class="userinput"><code>Mesh Compression</code></strong> enabled, so if we want accurate Normal data (for lighting), but have less worry over positional data, then we can configure it here. Unfortunately, this is a global setting and will affect all imported meshes (although it can be configured on a per-platform basis since it is a <strong class="userinput"><code>Player</code></strong> setting).</p><p>Enabling <strong class="userinput"><code>Optimize Mesh Data</code></strong> will strip away any data from the mesh that isn't required by the Material(s) assigned to it. So, if the mesh contains tangent information, but the Shader never requires it, then Unity will ignore it during build time.</p><p>In each case, the benefits are reducing the application's disk footprint at the cost of extra time loading the mesh since extra time must be spent decompressing the data before it's needed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip55"></a>Note</h3><p>3D mesh building/animation tools often provide their own built-in ways of automated mesh optimization in the form of estimating the overall shape and stripping the mesh down to fewer total polygons. This can cause significant loss of quality and should be tested vigorously if used.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec39"></a>Use Read-Write Enabled appropriately</h3></div></div></div><p>The <strong class="userinput"><code>Read-Write Enabled</code></strong> flag allows changes to be made to the mesh at runtime either via Scripting or automatically by Unity during runtime, similar to how it is used for texture files. Internally, this means that it will keep the original mesh data in memory until we want to duplicate it and make changes dynamically. Disabling this option will allow Unity to discard the original mesh data from memory once it has determined the final mesh to use, since it knows it will never change.</p><p>If we use only a uniformly scaled version of a mesh throughout the entire game, then disabling this option will save runtime memory since we will no longer need the original mesh data to make further rescaled duplicates of the mesh (incidentally, this is how Unity organizes objects by scale factor when it comes to Dynamic Batching). Unity can, therefore, discard this unwanted data early since we will never need it again until the next time the application is launched.</p><p>However, if the mesh often reappears at runtime with different scales, then Unity needs to keep this data in memory so that it can recalculate a new mesh more quickly, hence it would be wise to enable the <strong class="userinput"><code>Read-Write Enabled</code></strong> flag. Disabling it will require Unity to not only reload the mesh data each time the mesh is reintroduced, but also make the rescaled duplicate at the same time, causing a potential performance hiccup.</p><p>Unity tries to detect the correct behavior for this setting at initialization time, but when meshes are instantiated and scaled in a dynamic fashion at runtime, we must force the issue by enabling this setting. This will improve instantiation speed of the objects, but cost some memory overhead since the original mesh data is kept around until it's needed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip56"></a>Note</h3><p>Note that this potential overhead cost also applies when using the <strong class="userinput"><code>Generate Colliders</code></strong> option.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec40"></a>Consider baked animations</h3></div></div></div><p>This tip will require changes in the asset through the 3D rigging and animation tool that we are using since Unity does not provide such tools itself. Animations are normally stored as key frame information where it keeps track of specific mesh positions and interpolates between them at runtime using skinning data (bone shapes, assignments, animation curves, and so on). Meanwhile, baking animations means effectively sampling and hardcoding each position of each vertex per-frame into the mesh/animation file without the need for interpolation and skinning data.</p><p>Using baked animations can, sometimes, result in much smaller file sizes and memory overhead than blended/skinned animations for some objects since skinning data can take up a surprisingly large amount of space to store. This is most likely to be the case for relatively simple objects, or objects with short animations, since we would effectively be replacing procedural data with a hardcoded series of vertex positions. So, if the mesh's polygon count is low enough where storing lots of vertex information is cheaper than skinning data, then we may see some significant savings through this simple change. </p><p>In addition, how often the baked sample is taken can usually be customized by the exporting application. Different sample rates should be tested to find a good value where the key moments of the animation still shine-through what is essentially a simplified estimate.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec41"></a>Combine meshes</h3></div></div></div><p>Forcefully combining meshes into a large, single mesh can be convenient to reduce Draw Calls, particularly if the meshes are too large for Dynamic Batching and don't play well with other statically batched groups. This is essentially the equivalent of Static Batching, but performed manually, so sometimes it's wasted effort if Static Batching could take care of the process for us.</p><p>Beware that if any single vertex of the mesh is visible in the Scene, then the entire object will be rendered together as one whole. This can lead to a lot of wasted processing if the mesh is only partially visible most of the time. This technique also comes with the drawback that it generates a whole new mesh asset file that we must deposit into our Scene, which means any changes we make to the original meshes will not be reflected in the combined one. This results in a lot of tedious workflow effort every time changes need to be made, so if Static Batching is an option, it should be used instead.</p><p>There are several tools available online, which can combine mesh files together for us in Unity. They are only an Asset Store or Google search away.</p></div></div>