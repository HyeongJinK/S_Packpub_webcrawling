<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>The huge world problem</h2></div></div><hr /></div><p>Huge <a id="id12" class="indexterm"></a>landscapes may require a lot of memory, potentially more than a 3D card can handle. In game consoles memory is a scarce resource, on mobile devices transferring the app and storing is a factor. Even on a cutting edge PC large datasets will eat into that onboard memory especially when we get down to designing and building them using high-resolution data. Requesting actions that eat up your system memory may cause the application to fail. We can use GROME to create vast worlds without worrying too much about memory. This is done by taking advantage of how GROME manages data through a process of splitting terrain into "zones" and swapping it out to disk. This swapping is similar to how operating systems move memory to disk and reload it on demand. By default whenever you import large DTED files GROME will break the region into multiple zones and hide them. Someone new to GROME <a id="id13" class="indexterm"></a>might be confused by a lengthy file import operation only to be presented with a seemingly empty project space.</p><p>When creating terrain for engines such as Unity, UDK, Ogre3D, and others you should keep in mind their own technical limitations of what they can reasonably import.</p><p>Most of these engines are built for small scale scenes. While GROME doesn't impose any specific unit of measure on your designs, one unit equals one meter is a good rule of thumb. Many third-party models are made to this scale. However it's up to the artist to pick a unit of scale and importantly, be consistent.</p><p>Keep in mind many 3D engines are limited by two factors:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Floating point math precision</p></li><li style="list-style-type: disc"><p>Z-buffer (depth buffer) precision</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec08"></a>Floating point precision</h3></div></div></div><p>As a general rule anything larger than 20,000 units away from the world origin in any direction is going to exhibit precision errors. <a id="id14" class="indexterm"></a>This manifests as vertex jitter whenever vertices are rotated and transformed by large values. The effects are not something you can easily work around. Changing the scale of the object shifts the error to another decimal point. Normally in engines that specialize in rendering large worlds they either use a camera-relative rendering or some kind of paging system. Unity and UDK are not inherently capable of camera-relative rendering but a method of paging is possible to employ. There are techniques available such as a treadmill style terrain system but these are beyond the <a id="id15" class="indexterm"></a>scope of this book to demonstrate.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec09"></a>Depth buffer precision</h3></div></div></div><p>The other issue associated with large scene rendering is z-fighting. The <a id="id16" class="indexterm"></a>depth buffer is a normally invisible part of a scene used to determine what part is hidden by another, <a id="id17" class="indexterm"></a>depth-testing. Whenever a pixel is written to a scene buffer the z component is saved in the depth buffer. Typically this buffer has 16 bits of precision, meaning you have a linear depth of 0 to 65,536. This depth value is based on the 3D camera's view range (the difference between the camera near and far distance). <a id="id18" class="indexterm"></a>Z-fighting occurs when objects appear to be co-planer polygons written into the z-buffer with similar depth values causing them to "fight" for visibility. This flickering is an indicator that the scene and camera settings need to be rethought. Often the easy fix is to increase the z-buffer precision by increasing the camera's near distance. The downside is that this can clip very near objects.</p><p>GROME will <a id="id19" class="indexterm"></a>let you create such large worlds. Its own Graphite engine handles them well. Most 3D engines are designed for smaller first and third-person games which will have a practical limit of around 10 to 25 square kilometers (1 meter = 1 unit). GROME can mix levels of detail quite easily, different regions of the terrain have their own mesh density. If for example you have a map on an island, you will want lots of detail for the land and less in the sea region. However, game engines such as Unity, UDK, and Ogre3 Dare are not easily adapted to deal with such variability in the terrain mesh since they are optimized to render a large triangular grid of uniform size. Instead, we use techniques to fake extra detail and bake it into our terrain textures, dramatically reducing the triangle count in the process. Using a combination of Normal Maps and Mesh Layers in GROME we can create the illusion of more detail than there is at a distance.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip03"></a>Tip</h3><p>
<span class="strong"><strong>Normal map</strong></span>
</p><p>A Normal <a id="id20" class="indexterm"></a>is a unit vector (a vector with a total length of one) perpendicular to a surface. When a texture is used as a Normal map, the red, green, and blue channels represent the vector (x,y,z). These are used to generate the illusion of more detail by creating a bumpy looking surface. Also known as <a id="id21" class="indexterm"></a>bump-maps. Normal map generation is covered in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Textures and Lighting</em></span>.</p></div></div></div>