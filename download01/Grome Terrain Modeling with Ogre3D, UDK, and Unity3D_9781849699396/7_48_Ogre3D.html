<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec48"></a>Ogre3D</h2></div></div><hr /></div><p>At this point I will assume you have some programming experience of the Ogre open source 3D graphics engine. A crash course in <a id="id421" class="indexterm"></a>Ogre3D programming is a little beyond the scope of this book but there are plenty of great books and tutorials to be had.</p><p>Before we get started compiling a simple scene and viewer, we will need to install the OgreGrome SDK which <a id="id422" class="indexterm"></a>at time of writing can be downloaded from:</p><p>
<a class="ulink" href="http://www.quadsoftware.com/download.php?file=grome2ogre/OgreGrome_1.00.27.exe" target="_blank">http://www.quadsoftware.com/download.php?file=grome2ogre/OgreGrome_1.00.27.exe</a>
</p><p>Alternatively, visit Quad Software's website and navigate to "GROME – Support for Engines and External Formats". There you will find links to any updated SDKs and plugins.</p><p>Another requirement is the OgreCOLLADA <a id="id423" class="indexterm"></a>application <a id="id424" class="indexterm"></a>(or some other tool) that converts COLLADA models used by GROME into the <code class="literal">.mesh</code> format required by Ogre3D.</p><p>
<a class="ulink" href="http://sourceforge.net/projects/ogrecollada/" target="_blank">http://sourceforge.net/projects/ogrecollada/</a>
</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec52"></a>OgreGraphite engine</h3></div></div></div><p>The OgreGrome sample viewer makes use of the <a id="id425" class="indexterm"></a>Graphite engine and is fully compatible with scenes produced by GROME. As such, it is the simplest and most direct of the pipelines allowing the use of an <a id="id426" class="indexterm"></a>unlimited number of terrain layers. Detail layers, materials, shadow maps, and object placement are directly supported as illustrated in the following screenshot: </p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_23.jpg" /></div><p>The scenery shown is the demo scene bundled with the viewer. Ogre3D is a rendering engine, not a game engine, it works well with <a id="id427" class="indexterm"></a>
<span class="strong"><strong>Open Dynamics Engine</strong></span> (<span class="strong"><strong>ODE</strong></span>) for physics although the sample viewer application doesn't constrain the camera at all. Everything is left to the developer to add from other libraries. Ogre3D does what it does well (but some assembly is required).</p><p>Graphite is considered an outdoor "middleware" library and free for commercial and noncommercial applications—providing you possess a GROME license. Licensed users of GROME have access to the Graphite library which is needed to compile viewer application.</p><p>The OgreGrome viewer comes with full source and programming guide which will guide you through the process of integrating the Graphite engine with Ogre. If you already have a game library framework you will find Graphite easy to integrate as it's added to the Ogre rendering system like any other Listener class.</p><p>Exporting GROME scenes for OgreGraphite is the <a id="id428" class="indexterm"></a>most straightforward export process, we will step through the process highlighting some of the main points.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec53"></a>Exporting with GraphiTE </h3></div></div></div><p>The dedicated plugin we need for Ogre3D has a nice <a id="id429" class="indexterm"></a>variety of configurable options. The good news is <a id="id430" class="indexterm"></a>that these settings are saved, so we only have to set these once.</p><p>Starting with the <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Export</strong></span> menu option, select the <span class="strong"><strong>Graphite Exporter plug-in</strong></span>, enter a name and file location and then click on <span class="strong"><strong>Save</strong></span>. This will start the plugin UI, the first page is shown as follows:</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_24.jpg" /></div><p>We need the "Right Hand" coordinate system (Ogre uses a right-handed coordinate system). Click on the <span class="strong"><strong>Change Options</strong></span> button at any stage to adjust any of the settings shown in the panel.</p><p>If you need images for a mini-map in your game, <span class="strong"><strong>Global</strong></span> has a dedicated setting for exporting an overhead map for each zone. This includes lighting effects and ground detail objects. There are dozens of options available and too many to <a id="id431" class="indexterm"></a>look at, most are self-explanatory. However, details of all the options are available in the plugin by clicking on its <span class="strong"><strong>Help</strong></span> button. Most <a id="id432" class="indexterm"></a>of the options are cosmetic in some way with the odd exception.</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_25.jpg" /></div><p>If we have a specular layer then we must ensure the <span class="strong"><strong>Export per vertex normals</strong></span> checkbox is checked. The pixel shader requires normals from the terrain for lighting calculations, this also applies if you have any custom shaders that require vertex normals with your terrain. It makes the dataset larger and hence should be avoided unless you really need it.</p><p>Once we're happy with all our settings we can go ahead and click on the <span class="strong"><strong>OK</strong></span> button to begin the export. This will take some time depending on your map size.</p><p>Once the export dump is complete, our destination <a id="id433" class="indexterm"></a>
<a id="id434" class="indexterm"></a>directory should contain, for each zone:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A <code class="literal">.tzone</code> file</p></li><li style="list-style-type: disc"><p>Image files for masks and any color layers</p></li><li style="list-style-type: disc"><p>Image files for detail objects (such as grass)</p></li><li style="list-style-type: disc"><p>Image files for roads and mini-map (if selected)</p></li><li style="list-style-type: disc"><p>An XML file containing model instances</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note05"></a>Note</h3><p>All the files related to each zone are prefixed with the name of the zone.</p></div><p>Use the OgreCOLLADA (or other tool) to convert any 3D models used into the native Ogre3D .mesh format. This will also generate the necessary material files.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec54"></a>Compiling the code</h3></div></div></div><p>The sample viewer code can only be compiled if you have Graphite SDK library that is available to all licensed users of GROME 2.0. Preview versions of Graphite 3.0 can be applied for, through the Quad Software website at <a class="ulink" href="http://www.quadsoftware.com" target="_blank">www.quadsoftware.com</a>.</p><p>The source code for OgreGrome <code class="literal">Viewer.exe</code> is <a id="id435" class="indexterm"></a>included in the <code class="literal">src</code> folder just below the <code class="literal">bin</code> folder. To compile, it's recommended you use the <code class="literal">OgreGraphite.sln</code> VisualStudio solution. Once <a id="id436" class="indexterm"></a>loaded there will be some additional work needed for a successful compile.</p><p>You will need to set up the paths for:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Ogre3D SDK</p></li><li style="list-style-type: disc"><p>Graphite source (available to licensed GROME users only)</p></li></ul></div><p>The main source files in the viewer application are <code class="literal">Viewer.cpp</code> and <code class="literal">Viewer.h</code>. These contain all relevant code sections and cover:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Initializing the Graphite engine</p></li><li style="list-style-type: disc"><p>Creating and loading individual TerrainZones</p></li><li style="list-style-type: disc"><p>The Graphite renderer Listener class</p></li><li style="list-style-type: disc"><p>Graphite shutdown</p></li></ul></div><p>It's similar in structure to the standard Ogre3D example application so it's easy to follow if you're experienced at compiling Ogre3D applications. If not, there are several good textbooks on getting started with Ogre3D that cover compiling the basic example code.</p><p>Given next is the <code class="literal">createScene()</code> class <a id="id437" class="indexterm"></a>member from the Viewer source code. This uses the <a id="id438" class="indexterm"></a>
<code class="literal">loadTerrainZone()</code>class member to load named zones.</p><p>In this example, <code class="literal">TerrainZone25.tzone</code> and <code class="literal">TerrainZone26.tzone</code> are files we assume have been correctly exported by the <a id="id439" class="indexterm"></a>Graphite Exporter plugin:</p><div class="informalexample"><pre class="programlisting">void ViewerApp::createScene(void)
{
  // Init Graphite library.
  if(M_FAILED(initGraphiteLib(mSceneMgr, mCamera, mWindow)))
  {
    MessageBox(NULL, M_SZ("Error initiating the Graphite library!"), M_SZ("Error"), 0);
    return;
  }
  // Load some terrain zones.
  _graphite-&gt;loadTerrainZone(M_SZ("../Media/Scenes/IndustrialBuilding"), M_SZ("TerrainZone25.tzone"));
  _graphite-&gt;loadTerrainZone(M_SZ("../Media/Scenes/IndustrialBuilding"), M_SZ("TerrainZone26.tzone"));// …
// Load terrain zones associated object instance files.
  _graphite-&gt;loadObjectInstances(M_SZ("../Media/Scenes/IndustrialBuilding"), M_SZ("TerrainZone26_instances.xml"), M_SZ("TerrainZone26"));
  createGraphiteListener();
}</pre></div><p>If a zone contains 3D models, a called is needed to <code class="literal">loadObjectInstances(…)</code> passing the exported instance XML document and name of the Terrain Zone.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec55"></a>Deleting zones</h3></div></div></div><p>When we want to remove a zone including all <a id="id440" class="indexterm"></a>model <a id="id441" class="indexterm"></a>instances:</p><div class="informalexample"><pre class="programlisting">_graphite-&gt;deleteTerrainZone(zoneIndex);
_graphite-&gt;operateObjectInstances(gte::C_INST_OP_DELETE, NULL, M_SZ("TerrainZone25"));</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec56"></a>Going further – the edge of forever</h3></div></div></div><p>The OgreGrome examples available from the website contain several tutorials in the following location: <code class="literal">Source/Samples/Terrain/DynamicLoad</code>.</p><p>I highly encourage readers interested in GROME to play with the "Dynamic Loading" sample, this is a solid example of efficient scenery paging in a large open world game. And building on that example is the "Dynamic Loading Origin Change" example. This demonstrates how to manipulate the matrix to always keep the camera and terrain tile close to the origin of the world. This is the basis of creating truly massive worlds not bound by floating point errors or similar or any of the constraints we discussed at the beginning of this book. Once these techniques are mastered there is no limit to the virtual worlds you can create.</p></div></div>