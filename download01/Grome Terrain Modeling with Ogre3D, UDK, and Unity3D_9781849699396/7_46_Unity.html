<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec46"></a>Unity</h2></div></div><hr /></div><p>By far the easiest of the three engines to use and can build games for PC, Mac, and mobile platforms. Unity comes with its own terrain system however this isn't available in the Unity iPhone/Android editor. This is simply <a id="id355" class="indexterm"></a>because mobile platforms can't (yet) render the hundreds of thousands of polygons that typically constitute landscapes on their larger desktop counterparts.</p><p>In spite of this limitation, Unity iPhone/Android has been partly addressed by including a simple terrain system for mobiles, <a id="id356" class="indexterm"></a>GROME still has this well in hand through its use of Mesh layers.</p><p>Mesh layers are 3D models based on the terrain heightmap exported in Collada (<code class="literal">.dae</code>) format. We can export our terrain with enough detail for a target mobile device or for PlayStation, XBOX, and PC. We can do this for multiple <a id="id357" class="indexterm"></a>
<span class="strong"><strong>levels of detail</strong></span> (<span class="strong"><strong>LOD</strong></span>). For desktops we can simply use the heightmap from GROME and load it into the Unity editor so we can use all of the native Unity terrain tools for painting and vegetation. This presents us with two different export/import processes, one for desktops and one for mobile.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec46"></a>Desktop PC/Mac</h3></div></div></div><p>The following method is the best means to get terrain into Unity for desktop applications, however we can't import vegetation or water features. With the <a id="id358" class="indexterm"></a>help of a small script we can import four GROME material layers as Unity splat textures, directly. This also allows us to continue the edit process using Unity's native terrain tools. We can also create multiple terrain objects and import terrains into each one.</p><p>To use the native terrain tools in Unity we take advantage of the "RAW" data format. RAW is a 16 bit (PC endian), minimally processed file format that contains only data, there's no information about structure. When using RAW files we must know how many rows, columns, and channels of data were saved.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec47"></a>Export RAW terrain</h3></div></div></div><p>The advantage of "going native" with Unity's terrain is that <a id="id359" class="indexterm"></a>it comes with all the benefits of advanced LOD, texture painting, and vegetation details. Large terrains can get unwieldy to manage and a limited toolset means third-party tools are a must. For now, let's focus on getting a basic <a id="id360" class="indexterm"></a>terrain into Unity. </p><p>First we export our data as RAW and make some notes on dimensions and cell size. We're going to export one GROME zone for each Unity terrain object to keep things simple. We can get information on the zone and cell size from the <a id="id361" class="indexterm"></a>
<span class="strong"><strong>Heightmap</strong></span> layer stack (as shown in the following screenshot), click on the <span class="strong"><strong>Select</strong></span> <a id="id362" class="indexterm"></a>button and expand the tree view to see a thumbnail of the heightmap. The dimensions we need are shown as follows:</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_01.jpg" /></div><p>Subtracting 1 unit from the x and y value (because this number is the number of texels which is always plus 1) is 1,024 x 1,024. We multiply this value by the <span class="strong"><strong>Tile size</strong></span> of <span class="strong"><strong>25.00</strong></span> which equals 25,600. </p><p>This will be the dimensions (in world units) of the map we'll <a id="id363" class="indexterm"></a>enter into the Unity editor for the terrain <a id="id364" class="indexterm"></a>object. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec48"></a>Exporting from GROME</h3></div></div></div><p>From the <span class="strong"><strong>File</strong></span> menu in GROME select <span class="strong"><strong>Export</strong></span>, change the <span class="strong"><strong>Save as type</strong></span> to <span class="strong"><strong>General Large Data Export</strong></span> and enter a filename (as <a id="id365" class="indexterm"></a>shown in the <a id="id366" class="indexterm"></a>following screenshot):</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_02.jpg" /></div><p>This triggers the appropriate plugin with a lot of options that are pretty self-explanatory. I will say that the heightmap should be set to RAW and the resolution should match the zone tile resolution. In our example, it is 25 units per pixel. </p><p>We will also check the <a id="id367" class="indexterm"></a>
<span class="strong"><strong>Vertically flipped</strong></span> checkbox in <span class="strong"><strong>Terrain baked texture</strong></span>. For <span class="strong"><strong>Terrain layer masks</strong></span> if we check the <span class="strong"><strong>Export as multiple image channels</strong></span> it will create a splatmap mask that we can import into Unity with a little magic, we'll get to it later in this chapter.</p><p>The <span class="strong"><strong>General Exporter for Large Data Sets</strong></span> with suggested options for Unity is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_03.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec39"></a>Importing into Unity</h4></div></div></div><p>The following steps will allow you to import <a id="id368" class="indexterm"></a>
<a id="id369" class="indexterm"></a>RAW files into Unity:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First create a Terrain object in Unity from the menu.</p></li><li><p>Set the position as required (the origin is usually fine unless we're planning to patch several terrains together).</p></li><li><p>From the <span class="strong"><strong>Terrain</strong></span> menu, select the <span class="strong"><strong>Set Resolution</strong></span> option. For our example, I've set the values to match our Island zone (as shown in the following screenshot). Our zone is 25,600 units square so to keep the scale we set the same values here. The next image shows this Unity dialog in action:</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_04.jpg" /></div></li><li><p>The <span class="strong"><strong>Terrain Height</strong></span> value should match the one in GROME, you can get this value in GROME from the <span class="strong"><strong>Utilities</strong></span> menu (Scene Statistics). When GROME saves a RAW file, height data is normalized against the height range in the scene. The full 16-bit range is used irrespective of whether your exporting gentle fields or towering <a id="id370" class="indexterm"></a>
<a id="id371" class="indexterm"></a>mountain ranges. Also, Unity will not support heightmaps higher than 4096 resolution, if this is required, use multiple terrain zones.</p></li><li><p>Select the <a id="id372" class="indexterm"></a>
<span class="strong"><strong>Import Heightmap â€“ RAW</strong></span> option from the <span class="strong"><strong>Terrain</strong></span> menu. Select the RAW file exported from GROME. A second dialog box will appear (as shown in the following screenshot), this is where we need to know how our RAW image files were saved, if we get these wrong things will look very strange indeed:</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_05.jpg" /></div></li><li><p>Make sure the <span class="strong"><strong>Depth</strong></span> is 16 bit and <span class="strong"><strong>Byte Order</strong></span> is set to <span class="strong"><strong>Windows</strong></span>.</p></li><li><p>Click on the <span class="strong"><strong>Import</strong></span> button and (fingers crossed, the Gods of graphic design are with you) the terrain will appear in the scene view. If it looks all spikey then you forgot to change the byte order (grin).</p></li></ol></div><p>You might observe that the terrain is horizontally flipped, <a id="id373" class="indexterm"></a>this is just the way Unity imports RAW data (if you load the RAW file into Photoshop you can see it's the correct orientation). While GROME will flip the baked texture for you, it won't flip the RAW file. If you have GIMP or Photoshop this is a quick edit.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec49"></a>Importing Unity Splatmaps</h3></div></div></div><p>The GROME Raw exporter can create a <code class="literal">&lt;export_name&gt;_masks.png</code> file which has an option to normalize the output (this means pixels from all RGBA layers add up to a maximum of 1.0). This feature prevents over brightening of splat <a id="id374" class="indexterm"></a>
<a id="id375" class="indexterm"></a>textures in Unity.</p><p>We can drag this mask file into our Unity project but we have to do two things before we can use it. First, we must convert it to <a id="id376" class="indexterm"></a>
<span class="strong"><strong>ARGB32</strong></span> format in the Unity Inspector. Second, we have to add an undocumented function to the Unity <span class="strong"><strong>Terrain</strong></span> menu <a id="id377" class="indexterm"></a>to replace the terrain splatmaps with our new splatmap.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec40"></a>Convert texture to ARGBA32 format</h4></div></div></div><p>Before we start, make sure we have selected the mask texture in the <a id="id378" class="indexterm"></a>
<a id="id379" class="indexterm"></a>Unity Project explorer panel so that we can see it in the <span class="strong"><strong>Inspector</strong></span> panel (shown in the following screenshot):</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_06.jpg" /></div><p>In the <span class="strong"><strong>Inspector</strong></span> panel set <span class="strong"><strong>Texture Type</strong></span> to <span class="strong"><strong>Advanced</strong></span>, this will display all the options we need in the Inspector.</p><p>In the lower part of the <span class="strong"><strong>Inspector</strong></span> panel, check <span class="strong"><strong>Override for Standalone</strong></span> and set the size to the source size of the mask. Then set the format to <span class="strong"><strong>ARGB 32 bit</strong></span>.</p><p>Click on the <span class="strong"><strong>Apply</strong></span> button to finish the operation. <a id="id380" class="indexterm"></a>Everything is now ready and we can apply the splatmaps.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec41"></a>Unity editor script to replace splatmaps</h4></div></div></div><p>To add a new command to apply our splatmaps to the Unity <a id="id381" class="indexterm"></a>
<a id="id382" class="indexterm"></a>editor saves this script as a JavaScript file (for example, <code class="literal">splat_tool.js</code>) in the currently active project's <code class="literal">Assets\Editor</code> folder. </p><div class="informalexample"><pre class="programlisting">@MenuItem ("Terrain/Apply Splatmap")
static function ApplySplatmap () {
  var splatmap : Texture2D = Selection.activeObject as Texture2D;
  if (splatmap == null) { 
    EditorUtility.DisplayDialog("No texture selected", "Please select a texture", "Cancel"); 
    return; 
  }
  if (splatmap.format != TextureFormat.ARGB32) {
    EditorUtility.DisplayDialog("Wrong format", "Splatmap must be in RGBA 32 bit format", "Cancel"); 
    return;
  }

  var w = splatmap.width;
  if (splatmap.height != w) {
    EditorUtility.DisplayDialog("Wrong size", "Splatmap width and height must be the same", "Cancel"); 
    return;
  }
  if (Mathf.ClosestPowerOfTwo(w) != w) {
    EditorUtility.DisplayDialog("Wrong size", "Splatmap width and height must be a power of two", "Cancel"); 
    return;
  }

  var terrain = Terrain.activeTerrain.terrainData;
  terrain.alphamapResolution = w;
  var splatmapData = terrain.GetAlphamaps(0, 0, w, w);
  var mapColors = splatmap.GetPixels();
  if (splatmapData.Length &lt; mapColors.Length*4) {
    EditorUtility.DisplayDialog("Add textures", "The terrain must have at least four textures", "Cancel"); 
    return;	
  }

  for (z = 0; z &lt; 4; z++) {
    for (y = 0; y &lt; w; y++) {
      for (x = 0; x &lt; w; x++) {
        splatmapData[x,y,z] = mapColors[((w-1)-x)*w + y][z];
      }
    }
  }
  terrain.SetAlphamaps(0, 0, splatmapData);
} </pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip13"></a>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you. </p></div><p>Once this is added to the right place (and assuming there are no script errors), a new menu option, <span class="strong"><strong>Apply Splatmap</strong></span>, should appear in the <a id="id383" class="indexterm"></a>
<a id="id384" class="indexterm"></a>
<span class="strong"><strong>Terrain</strong></span> menu .</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_07.jpg" /></div><p>To use the function we first add four splat textures to our terrain object (as shown in the following screenshot), then we select an ARGB32 format texture in the project panel which will contain all of the splat information. Then we select our new <span class="strong"><strong>Apply Splatmap</strong></span> menu option.</p><p>The terrain splat textures should then be distributed as per the information contained within our new splatmap. Our GROME island example is <a id="id385" class="indexterm"></a>
<a id="id386" class="indexterm"></a>shown in the following screenshot after export in this manner:</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_08.jpg" /></div><p>We could improve this by applying our baked texture exported from GROME as the first splat texture, giving it the same x and y size as the terrain (25,600 in our example).</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Tip</h3><p>If the imported splats appear overly bright or contain odd color artifacts then the splatmap was probably not normalized.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec50"></a>Mesh terrain export</h3></div></div></div><p>We can export GROME terrain as a 3D model (we <a id="id387" class="indexterm"></a>might do this for devices that don't support terrain entities or a treadmill terrain system). Unity's native terrain tools don't work on such objects <a id="id388" class="indexterm"></a>however navmeshes and colliders work fine. If we were making a flying game for tablets then this kind of export is ideal. </p><p>Getting the exported model into Unity is relatively easy since we can simply drag-and-drop exported DAE Collada files directly into the Unity project. From there we can assign any baked zone textures to it if required (the base texture is usually exported as a TGA and mapped automatically). </p><p>If you remember, we create terrain meshes in GROME using the heightmap's Simplify tool. This creates a representation of the terrain as an optimized irregular triangle mesh. However, if we don't manually create any meshes then GROME will export the heightmap as a regular triangle mesh. </p><p>Unity's <span class="strong"><strong>Inspector</strong></span> panel has an <span class="strong"><strong>Optimize Mesh</strong></span> which changes how triangles are ordered in the mesh. If you need collision detection on the terrain don't forget to check the <span class="strong"><strong>Generate Collider</strong></span> <a id="id389" class="indexterm"></a>option and click on the <span class="strong"><strong>Apply</strong></span> button. (I've failed to do that once before and spent half an hour trying to debug a raycast *sigh*.)</p><p>The following screenshot shows an example of terrain <a id="id390" class="indexterm"></a>exported as an irregular triangle mesh:</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_09.jpg" /></div><p>COLLADA is an industry standard format managed by the non-profit Khronos Group for the purpose of exchanging files between 3D applications. DAE is an acronym for digital asset exchange which is what we're going to do with <a id="id391" class="indexterm"></a>GROME and Unity.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec42"></a>Mesh export from GROME</h4></div></div></div><p>In GROME, go to the <span class="strong"><strong>File</strong></span> menu and select the <span class="strong"><strong>Export</strong></span> option to <a id="id392" class="indexterm"></a>
<a id="id393" class="indexterm"></a>bring up the export location dialog. Here we set the <span class="strong"><strong>Save as type</strong></span> to <span class="strong"><strong>COLLADA Export (*.dae)</strong></span>. This setting determines which export plugin is fired when we click on the <span class="strong"><strong>Save</strong></span> button.</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_10.jpg" /></div><p>Set the filename for the exported DAE model file (something like <code class="literal">grome_terrain_island</code>). The export plugin will then display the dialog box shown as follows:</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_11.jpg" /></div><p>It's important we set the <span class="strong"><strong>Coordinate system</strong></span> to <span class="strong"><strong>Unity 3D</strong></span>. For our example, we'll be exporting multiple Mesh layers for use in our own LOD Unity script so the <span class="strong"><strong>Mesh layers</strong></span> option should be checked, this will include each mesh layer as a child object.</p><p>GROME will only export textures and meshes if the "visible" icon of the item is active. We can use this behavior to control the output. If we want the normalmap saved into our export directory then we must flag it as visible on the layer stack. And the same for any of the mesh layers.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip15"></a>Tip</h3><p>
<span class="strong"><strong>Road Meshes</strong></span>
</p><p>Models exported using the Collada export plugin will contain meshes for any road (spline) objects if we check the <span class="strong"><strong>Save road geometry</strong></span> box<a id="id394" class="indexterm"></a>. This saves the road network in the scene as a set of triangle strips suitable for navmesh use.</p></div><p>It can take a few minutes to complete the save operation depending on size but once complete, we should have a DAE file and a series of .TGA <a id="id395" class="indexterm"></a>
<a id="id396" class="indexterm"></a>format textures that we simply drag into our Unity Project window. Unity will crunch through the mesh and turn it into an object suitable for use in the engine.</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_12.jpg" /></div><p>The texture of the terrain will lack definition as the resolution won't be high enough for the terrain size (in the previous screenshot, the texture near the camera is quite blurry). The base texture will typically be good enough as a base if we're flying above it at high altitude but closer to the ground it doesn't look so great. <a id="id397" class="indexterm"></a>
<a id="id398" class="indexterm"></a>We can improve things quickly by adding a detail texture. Select the terrain object Unity and change the shader to <span class="strong"><strong>Diffuse Detail</strong></span> (this is shown in the following image).</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_13.jpg" /></div><p>We see the baked texture of the zone assigned to the base, now we add a detail texture; here I've used the same "mexico" texture from GROME and set the <span class="strong"><strong>Tiling</strong></span> to <span class="strong"><strong>100</strong></span>.</p><p>This adds some nice low level detail on top of the base <a id="id399" class="indexterm"></a>
<a id="id400" class="indexterm"></a>texture and transforms the scene. Not all mobile platforms support multi-texturing so this isn't always available. The following is an image of the terrain model with just two texture layers applied:</p><div class="mediaobject"><img src="/graphics/9781849699396/graphics/9182_07_14.jpg" /></div><p>If the terrain was exported with the mesh layers they will be present as child objects. Don't be alarmed if there's a lot of flickering caused by them being drawn on top of each other. These can be disabled in the inspector or deleted if we don't want them.</p><p>It's possible to have multiple mesh layers as LOD models, the GROME website has an excellent tutorial and example Unity script which swaps out terrain meshes based on camera distance.</p><p>If road meshes are present, create an empty game object and move them into it to create a prefab that's easier to manipulate. They are easy to identify as <a id="id401" class="indexterm"></a>each road section is named "Road entity", the name of the zone and finally the instance number of the section. (for example, Road entity-IslandSE-inst 1").</p><p>When importing a DAE model into Unity it's possible (depending on the size and detail of the terrain) that it may have more than 65,536 vertices. This is the maximum most 3D engines will allow in a single object. Unity will split the model up into a prefab containing as many submeshes as are required for the entire model.</p></div></div></div>