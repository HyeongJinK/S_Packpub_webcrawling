<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec20"></a>Using mouse input</h2></div></div><hr /></div><p>Now, before we dive into mobile-only solutions, I do want to point out that it is possible to write inputs that work on both mobile and PC, namely using mouse controls. Mobile devices support using mouse clicks as taps on the screen, and we can use the mouse position as being where the screen was touched. This doesn't give you all of the features that the mobile-only options do; we will be discussing that later on in this chapter, but I think it's important to note, since I use this often for ease of testing on both the PC and on my device, making it so I don't have to <span>deploy to a mobile device to test every single change made in the project</span>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><span>Inside</span> Unity, open up your <code class="literal">PlayerBehaviour</code> script and add the following highlighted code to the <code class="literal">Update</code> function:</li></ol></div><pre class="programlisting">void Update()
    {
        // Check if we're moving to the side
        var horizontalSpeed = Input.GetAxis("Horizontal") *
                              dodgeSpeed;

<span class="strong"><strong>// If the mouse is held down (or the screen is tapped</strong></span>
<span class="strong"><strong>        // on Mobile)</strong></span>
<span class="strong"><strong>        if (Input.GetMouseButton(0))</strong></span>
<span class="strong"><strong>        {</strong></span>
<span class="strong"><strong>            // Converts to a 0 to 1 scale</strong></span>
<span class="strong"><strong>            var worldPos = 
            Camera.main.ScreenToViewportPoint(Input.mousePosition);</strong></span>
<span class="strong"><strong>            float xMove = 0;</strong></span>

<span class="strong"><strong>            // If we press the right side of the screen</strong></span>
<span class="strong"><strong>            if (worldPos.x &lt; 0.5f)</strong></span>
<span class="strong"><strong>            {</strong></span>
<span class="strong"><strong>                xMove = -1;</strong></span>
<span class="strong"><strong>            }</strong></span>
<span class="strong"><strong>            else</strong></span>
<span class="strong"><strong>            {</strong></span>
<span class="strong"><strong>                // Otherwise we're on the left</strong></span>
<span class="strong"><strong>                xMove = 1;</strong></span>
<span class="strong"><strong>            }</strong></span>

<span class="strong"><strong>            // replace horizontalSpeed with our own value</strong></span>
<span class="strong"><strong>            horizontalSpeed = xMove * dodgeSpeed;</strong></span>
<span class="strong"><strong>        }</strong></span>

        // Apply our auto-moving and movement forces
        rb.AddForce(horizontalSpeed, 0, rollSpeed);
    }

</pre><p>We have added a number of things to the preceding script. Firstly, we check whether the mouse button had been held down or not through the use of the <code class="literal">Input.GetMouseButton</code> function. The function will return <code class="literal">true</code> if the mouse is held down, and <code class="literal">false</code> if it is not. The function takes in a parameter, which is for what mouse button we'd like to check, providing <code class="literal">0</code> for the left button, <code class="literal">1</code> for the right, and <code class="literal">2</code> for the middle button. For mobile, however, only <code class="literal">0</code> will be picked up as a click.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"></a>Note</h3><p>For more info on the <code class="literal">Input.GetMouseButton</code> function, check out <span><a class="ulink" href="https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html" target="_blank">https://docs.unity3d.com/ScriptReference/Input.GetMouseButton.html</a>.</span></p></div><p>To start off, we can get the position that the mouse is at using the <code class="literal">Input.mousePosition</code> property. However, this value is given to us in screen space. What is screen space? Well, let's first talk about how we traditionally deal with positions in Unity making use of world space.</p><p>When dealing with positions in Unity through the <strong class="userinput"><code>Inspector</code></strong> window, we have the point <span class="strong"><strong>(0,0,0)</strong></span> in the middle of our world, which we call the origin, and then we refer to everything else based on an offset from there. We typically refer to this method of positioning as <span class="strong"><strong>World Space</strong></span>. Assuming that we have our camera pointing toward the origin, <span class="strong"><strong>World Space</strong></span> looks like this:</p><div class="mediaobject"><img src="/graphics/9781787288713/graphics/edede8dd-be58-4cda-baf3-1436e6458d54.png" /></div><p>The lines are the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> axes of our world. If I were to move an object to the right or left, it would move along the X-axis positively or negatively, respectively. When in school, you may have learned about using graphs and points, and world space works very much like that.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note27"></a>Note</h3><p>It's not important for the current conversation, but I should note that children of parented objects use a different system in the <strong class="userinput"><code>Inspector</code></strong>, which is that they are given positions relative to their parent instead. This system is called <span class="strong"><strong>local space</strong></span>.</p></div><p>When using mouse input, Unity gives us this information in another space, <span class="strong"><strong>Screen Space</strong></span>. In this space, the position is based on where the camera is and isn't involved with the actual game world. This space is also just in 2-D, so there's only an <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> position with <span class="emphasis"><em>z</em></span> always being stuck at <code class="literal">0</code>:</p><div class="mediaobject"><img src="/graphics/9781787288713/graphics/9371aca2-1f4f-4c85-9f16-7648674268de.png" /></div><p>In this case, the bottom left of the screen would be <span class="strong"><strong>(0,0)</strong></span> and the top right would be <span class="strong"><strong>(Screen.width, Screen.height)</strong></span>. <code class="literal">Screen.width</code> and <code class="literal">Screen.height</code> are values in Unity that will give us the screen size of the screen window in pixels.</p><p>We could use these values as provided and then compare what side of the screen the player pressed, but, in my case, I think it'd be better to convert the position into an easier space to work with. One such space is the <span class="strong"><strong>Viewport space</strong></span>, which goes from <strong class="userinput"><code>(0,0)</code></strong> to <strong class="userinput"><code>(1,1)</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781787288713/graphics/40480b6c-e8fa-44eb-aa0f-9e96bab7b439.png" /></div><p></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note28"></a>Note</h3><p>Note that some of Unity's functions will use a <code class="literal">Vector3</code> instead of a <code class="literal">Vector2</code> in order to work with 3D spaces as well.</p></div><p>Instead of searching whether our <span class="emphasis"><em>x</em></span> position is less than half of the screen width, I can instead just check whether it's less than <code class="literal">0.5</code>, which is what we are doing here. If the value is less than <code class="literal">0.5</code>, it's on the left side of the screen so we return <code class="literal">-1</code>; otherwise, it's on the right side, so we give <code class="literal">1</code>.</p><p>Once we know that, we can then set the horizontal speed variable to move to the left or right based on our movement.</p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Save the script and dive back into Unity; you will see the following:</li></ol></div><div class="mediaobject"><img src="/graphics/9781787288713/graphics/8fc63b7d-db59-436d-bef6-e2d1b2ff02d7.png" /></div><p>As you can see in the preceding screenshot, we can now use either the mouse (<code class="literal">Input.mousePosition</code>) or our keyboard (<code class="literal">Input.GetAxis</code>) to move our player.</p></div>