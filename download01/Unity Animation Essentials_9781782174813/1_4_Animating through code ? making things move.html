<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>Animating through code – making things move</h2></div></div><hr /></div><p>Animating through code is a<a id="id35" class="indexterm"></a> great way to start animating generally, as it demonstrates all the core concepts we've seen so far, so let's try it. For this section, and the remaining sections, we'll use C# for scripting wherever applicable. However, since this book focuses on animation, I won't be explaining basic coding concepts here (such as variables, loops, and functions). Instead, I'll assume you already have basic to intermediate coding knowledge. If you want to learn coding, I recommend my <a id="id36" class="indexterm"></a>3dmotive video course <span class="emphasis"><em>C# For Unity Developers</em></span> (available at <a class="ulink" href="http://3dmotive.com/" target="_blank">http://3dmotive.com/</a>) and <span class="emphasis"><em>Learning C# by Developing Games with Unity 3D Beginner's Guide</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>.</p><p>By the end of the next few sections, we'll have created a game object (for example, a spaceship) that can travel at a constant speed in a single direction across the level. To get started, create a new <a id="id37" class="indexterm"></a>script file by right-clicking inside the Project panel. Go to <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>C# Script</strong></span> from the context menu. Alternatively, go to <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>C# Script</strong></span> from the application menu, as shown in the following screenshot. Name the file <code class="literal">Mover.cs</code>. This script will be attached to any object that will move.</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_12.jpg" /></div><p>Now open the script file in MonoDevelop by double-clicking on it from the Project panel. By default, all new scripts are created with two functions: <code class="literal">Start</code> and <code class="literal">Update</code>. The <code class="literal">Update</code> function is of special significance for animation because it's related to frames and the frame rate. Specifically, it's called on every frame at runtime. This means that for a game with an FPS of 70, the <code class="literal">Update</code> function is called 70 times per second for each object with the script attached, provided the object is active. This makes <code class="literal">Update</code> important for animation because it gives us an opportunity to adjust an object's properties continually over time.</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_13.jpg" /><div class="caption"><p>The Update function is called once per frame</p></div></div><p>To start <a id="id38" class="indexterm"></a>moving an object, let's code the <code class="literal">Update</code> function, as shown in the following snippet. It accesses the object's <a id="id39" class="indexterm"></a>
<span class="strong"><strong>transform</strong></span> component and increments its current position in the <span class="emphasis"><em>x</em></span> axis by 1 unit (meter) on each frame.</p><p>Code sample 1-1: moving an object:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Mover : MonoBehaviour 
{
  // Use this for initialization
  void Start () {
  
  }
  
  // Update is called once per frame
  void Update () 
  {
    //Transform component on this object
    <span class="strong"><strong>Transform ThisTransform = GetComponent&lt;Transform&gt;();</strong></span>

    //Add 1 to x axis position
    <span class="strong"><strong>ThisTransform.position += new Vector3(1f,0f,0f);</strong></span>
  }
}</pre></div><p>If you haven't already tested the code, drag and drop the script file onto an object in the scene. Then press the <span class="strong"><strong>Play</strong></span> button. Depending on your view, the object may move too fast to be visible. Be<a id="id40" class="indexterm"></a> sure to position your camera for a good view, and you should see your object spring to life by moving continually on the <span class="emphasis"><em>x</em></span> axis.</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_14.jpg" /><div class="caption"><p>Adding the Mover script to an object in the scene</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec18"></a>Consistent animation – speed, time, and deltaTime</h3></div></div></div><p>The code<a id="id41" class="indexterm"></a> in sample 1-1 works, but there's an important animation problem, and we should address it directly. As we've seen, the object travels along the <span class="emphasis"><em>x</em></span> axis by 1 unit on every call to <code class="literal">Update</code>, that is, on each frame. This is <a id="id42" class="indexterm"></a>potentially a problem because frame rates differ across computers, and even over time on the same computer. This means that different users will get different experiences while using our code because the object will move at varying speeds. Specifically, on a system with an FPS of 70, the object will be updated by 70 units every second. But on a different system running at 90 FPS, the object will move 90 units in the same time. This is bad, because we want all users to get a consistent in-game experience, experiencing time at the same speed and in the same way. This issue is especially important for multiplayer games, where it's critical that all users are in sync. To solve this issue, we need to approach the task differently, thinking in terms of speed and time.</p><p>To calculate <a id="id43" class="indexterm"></a>how far an object should travel over time, we can use the speed-distance-time formula, where <span class="emphasis"><em>distance traveled = speed x time</em></span>. This means that an object traveling at 10 meters per second for 5 seconds will travel a total of 50 meters. This way of thinking about <a id="id44" class="indexterm"></a>movement doesn't rely on frame rates and frames. Also, it doesn't link motion to the <code class="literal">Update</code> function and its frequency specifically. Instead it maps motion to time directly, and time is consistent across all computers; that is, 1 second is the same everywhere. To code this in Unity, we can use the <code class="literal">deltaTime</code> variable. Consider code sample 1-2, which updates and improves on code sample 1-1.</p><p>Code sample 1-2: setting an object's speed:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Mover : MonoBehaviour 
{
  //Amount to travel (in metres) per second
  <span class="strong"><strong>public float Speed = 1f;</strong></span>
  
  // Update is called once per frame
  void Update () 
  {
    //Transform component on this object
    Transform ThisTransform = GetComponent&lt;Transform&gt;();

    //Update X Axis position by 1 metre per second
<span class="strong"><strong>    ThisTransform.position += new Vector3(Speed * Time.deltaTime,0f,0f);</strong></span>
  }
}</pre></div><p>The <code class="literal">deltaTime</code> variable<a id="id45" class="indexterm"></a> is a native Unity variable updated every frame, and is part of the <code class="literal">Time</code> class. On each frame, it expresses (in seconds) how much time has elapsed since the previous frame. Therefore, if <code class="literal">deltaTime</code> is 0.5, then it means 1/2 of a second has elapsed since the previous frame, that is, since the <code class="literal">Update</code> function was last called. This is highly important information because, when multiplied by speed values, we always scale the speed value to be consistent with the frame rate for the current computer, ensuring a consistent speed across computers. By doing this, we make all speed values work the same for everybody. Now try this code in the editor and see the difference. Our objects will now move at the same speed on all computers.</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_15.jpg" /><div class="caption"><p>Press Play and test the new code</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec19"></a>Movement in a direction</h3></div></div></div><p>Based on code <a id="id46" class="indexterm"></a>sample 1-2, we now have an object that moves in the <span class="emphasis"><em>x</em></span> axis at a consistent speed. But how can the code be adapted to move in a different direction? If we wanted to move in only the <span class="emphasis"><em>y</em></span> or <span class="emphasis"><em>z</em></span> direction, we could've adapted the code easily. But what about movement in any arbitrary direction, including diagonals? For this, we need vectors. A vector is a three-component number in the form of (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, <span class="emphasis"><em>z</em></span>), representing a direction. For example, (<span class="emphasis"><em>0</em></span>, <span class="emphasis"><em>1</em></span>, <span class="emphasis"><em>0</em></span>) means up (since the up-down axis is <span class="emphasis"><em>y</em></span>) and (<span class="emphasis"><em>0</em></span>, <span class="emphasis"><em>0</em></span>, <span class="emphasis"><em>1</em></span>) means forward (since the <span class="emphasis"><em>z</em></span> axis represents the forward-backward axis).</p><p>Code sample 1-3: controlling the direction:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Mover : MonoBehaviour 
{
  //Amount to travel (in metres) per second
  public float Speed = 1f;

  //Direction to travel
  <span class="strong"><strong>public Vector3 Direction = Vector3.zero;</strong></span>
  
  // Update is called once per frame
  void Update () 
  {
    //Transform component on this object
    Transform ThisTransform = GetComponent&lt;Transform&gt;();

    //Update position in specified direction by speed
<span class="strong"><strong>    ThisTransform.position += Direction.normalized * Speed * Time.deltaTime;</strong></span>
  }
}</pre></div><p>Now <a id="id47" class="indexterm"></a>return to your object in the scene. The object inspector shows a <code class="literal">Direction</code> variable that can be edited to specify the direction in which the object should move. Movement along the <span class="emphasis"><em>x</em></span> axis is due to (<span class="emphasis"><em>1</em></span>, <span class="emphasis"><em>0</em></span>, <span class="emphasis"><em>0</em></span>) or (<span class="emphasis"><em>-1</em></span>, <span class="emphasis"><em>0</em></span>, <span class="emphasis"><em>0</em></span>), and the numbers are similar for the other axes. You can also travel in diagonals using (<span class="emphasis"><em>1</em></span>, <span class="emphasis"><em>1</em></span>, <span class="emphasis"><em>1</em></span>), which means moving in all three axes simultaneously.</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_16.jpg" /><div class="caption"><p>Specifying a direction for the Mover script</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>The Unity project for this assignment can be found in this book's companion files in the <code class="literal">Chapter01/Moving Object</code> folder.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec20"></a>Coding tweens with animation curves</h3></div></div></div><p>For objects that move <a id="id48" class="indexterm"></a>continually at a constant speed and in a straight line, the code created in sample 1-3 works exactly as <a id="id49" class="indexterm"></a>expected. But when<a id="id50" class="indexterm"></a> animating, you'll typically want objects to move along curved paths, not just straight paths. Or you'd want objects to travel at variable speeds as opposed to constant speeds. To solve this, we can use <a id="id51" class="indexterm"></a>
<span class="strong"><strong>animation curves</strong></span>, which are special objects (available only in Unity Pro) that allow us to build curves that define tweens for the animation, controlling how an object changes across key frames. Consider code sample 1-4, which allows us to vary an object's speed over time with an animation curve.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note03"></a>Note</h3><p>More information<a id="id52" class="indexterm"></a> on animation curves can be found online at <a class="ulink" href="http://docs.unity3d.com/Manual/animeditor-AnimationCurves.html" target="_blank">http://docs.unity3d.com/Manual/animeditor-AnimationCurves.html</a>.</p></div><p>Code sample 1-4: ramping the speed:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Mover : MonoBehaviour 
{
  //Maximum Speed to travel (in metres) per second
  public float Speed = 1f;
  
  //Direction to travel
  public Vector3 Direction = Vector3.zero;

  //Curve to adjust speed
  <span class="strong"><strong>public AnimationCurve AnimCurve;</strong></span>

  // Update is called once per frame
  void Update () 
  {
    //Transform component on this object
    Transform ThisTransform = GetComponent&lt;Transform&gt;();

    //Update position in specified direction by speed
ThisTransform.position += Direction.normalized * Speed * <span class="strong"><strong>AnimCurve.Evaluate(Time.time)</strong></span> * Time.deltaTime;
  }
}</pre></div><p>With the code<a id="id53" class="indexterm"></a> in sample 1-4, select the animated <a id="id54" class="indexterm"></a>object in the scene and <a id="id55" class="indexterm"></a>examine the object inspector. The public <code class="literal">AnimCurve</code> variable is now visible as a graph.</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_17.jpg" /><div class="caption"><p>Accessing the animation curve editor</p></div></div><p>Click on the graph in the inspector to show the graph editor as a separate dialog. This graph allows you to control the tweens applied to the speed value. The horizontal axis represents time (in seconds), and the vertical axis represents the value (speed).</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_18.jpg" /><div class="caption"><p>Building an animation curve</p></div></div><p>You can <a id="id56" class="indexterm"></a>click any of <a id="id57" class="indexterm"></a>the bottom-left curve presets to generate an initial curve, controlling interpolation for object speed. You can also double-click anywhere along the curve to insert new control <a id="id58" class="indexterm"></a>points, allowing greater control of the curve's shape. Let's go ahead and create a famous type of curve in animation—an ease-in-ease-out curve. It will gradually increase the object's speed at the start of the animation (acceleration), and then eventually reduce the object's speed towards a complete stop (deceleration). To start, use the mouse's scrolling wheel to zoom out from the curve view, to show a horizontal view of 5 seconds in all from 0 seconds at animation start to 5 seconds at animation end. Make sure that the first and last key frame points rest at the start and end times respectively on the horizontal axis. Also make sure that both the points are at 0 for the vertical axis, which means that the object's speed should be 0 at both the start and the end.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip03"></a>Tip</h3><p>As you click and drag the points, hold down the <span class="emphasis"><em>Ctrl</em></span> key to snap to grid.</p></div><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_19.jpg" /><div class="caption"><p>Starting an animation curve</p></div></div><p>To build an <a id="id59" class="indexterm"></a>ease-in-ease-out curve, insert a new control point at the curve's center (at time equal to 2.5 seconds), and <a id="id60" class="indexterm"></a>drag it upward on the vertical axis to a <a id="id61" class="indexterm"></a>value of 1, representing the maximum speed for the object at that time. If the new control point forms a hard-edged angle in the curve, preventing it from being smooth, then right-click on the control point and select the <span class="strong"><strong>Free Smooth</strong></span> option from the context menu to smooth out the curve.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip04"></a>Tip</h3><p>You can press <span class="emphasis"><em>F</em></span> to resize the graph view to get the curve fully in view.</p></div><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_20.jpg" /><div class="caption"><p>Creating an ease-in-ease-out curve for speed</p></div></div><p>Once the curve is constructed, give the code a test run by playing the Unity project, and see the<a id="id62" class="indexterm"></a> effect it has<a id="id63" class="indexterm"></a> in the <span class="strong"><strong>Game</strong></span> tab. Based on code sample 1-4, the speed of the object will necessarily animate according to the curve over time. The <code class="literal">AnimationCurve.Evaluate</code> method accepts a time<a id="id64" class="indexterm"></a> value as the input (on the horizontal axis) and returns an associated value from the <span class="emphasis"><em>y</em></span> axis as a multiplier for speed. Using this function, we can evaluate any curve for programmatic animation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note04"></a>Note</h3><p>More information <a id="id65" class="indexterm"></a>on the <code class="literal">Evaluate</code> method can be found at the official Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/AnimationCurve.html" target="_blank">http://docs.unity3d.com/ScriptReference/AnimationCurve.html</a>.</p><p>The Unity project for this assignment can be found in this book's companion files in the <code class="literal">Chapter01/animation_curves</code> folder.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec21"></a>Rotating towards objects – animation with coroutines</h3></div></div></div><p>Now let's try a different <a id="id66" class="indexterm"></a>programmatic animation scenario using <a id="id67" class="indexterm"></a>
<span class="strong"><strong>coroutines</strong></span>, a special kind of function that are very useful for creating types of behavior that unfold over time. Specifically, we'll create a script that slowly and <a id="id68" class="indexterm"></a>smoothly rotates an object to always face its target. This is useful for building enemies that always turn to look at you, rotating gun turrets, or other objects that must track a target. It should be emphasized here that the intended behavior isn't simply the <code class="literal">LookAt</code> behavior, which causes objects to immediately be oriented towards a target using the <code class="literal">Transform.LookAt</code> function. Instead, we're coding a kind of behavior in which an object always rotates at a specified angular speed to face a target, as shown in the following screenshot. The object may or may not be looking at its target at a particular moment, but it'll always be trying to look at it. This involves rotation and turning over time to look at its target, wherever the latter moves. Consider the code file (<code class="literal">LookAt.cs</code>) in sample 1-5.</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_21.jpg" /><div class="caption"><p>A cubical object rotating to face a sphere</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note05"></a>Note</h3><p>More information <a id="id69" class="indexterm"></a>on coroutines can be found in the Unity official documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html" target="_blank">http://docs.unity3d.com/Manual/Coroutines.html</a>.</p></div><p>Code sample 1-5: rotating to face a target:</p><div class="informalexample"><pre class="programlisting">//--------------------------------------------
using UnityEngine;
using System.Collections;
[ExecuteInEditMode]
//--------------------------------------------
public class LookAt : MonoBehaviour
{
  //Cached transform
  private Transform ThisTransform = null;

  //Target to look at
  <span class="strong"><strong>public Transform Target = null;</strong></span>

  //Rotate speed
  public float RotateSpeed = 100f;

  //--------------------------------------------
  // Use this for initialization
  void Awake () {
    //Get transform for this object
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //--------------------------------------------
  void Start()
  {
    //Start tracking target
    StartCoroutine(TrackRotation(Target));
  }
  //--------------------------------------------
  //Coroutine for turning to face target
  <span class="strong"><strong>IEnumerator TrackRotation(Transform Target)</strong></span>
  {
    //Loop forever and track target
    while(true)
    {
      if(ThisTransform != null &amp;&amp; Target != null)
      {
        //Get direction to target
        Vector3 relativePos = Target.position - ThisTransform.position;

        //Calculate rotation to target
        Quaternion NewRotation = <span class="strong"><strong>Quaternion.LookRotation(relativePos)</strong></span>;

        //Rotate to target by speed
        ThisTransform.rotation = <span class="strong"><strong>Quaternion.RotateTowards</strong></span>(ThisTransform.rotation, NewRotation, RotateSpeed * Time.deltaTime);
      }

      //wait for next frame
      yield return null;
    }
  }
  //--------------------------------------------
  //Function to draw look direction in viewport
  void OnDrawGizmos()
  {
    Gizmos.DrawLine(ThisTransform.position, ThisTransform.forward.normalized * 5f);
  }
  //--------------------------------------------
}
//--------------------------------------------</pre></div><p>Coroutines work differently from regular functions. They always feature an <code class="literal">IEnumerator</code> return type and contain at least one <code class="literal">yield</code> statement. Unlike regular functions, which <a id="id70" class="indexterm"></a>perform their work line by line and then terminate, after which program execution resumes, coroutines seem to run in parallel with the process that invoked them. They feel and work much like a thread or <a id="id71" class="indexterm"></a>background process—though without truly being so—multitasking and running alongside other processes. This makes them useful for animation, allowing us to animate and change properties for objects while other processes are running.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note06"></a>Note</h3><p>The Unity project for this assignment can be found in this book's companion files in the <code class="literal">Chapter01/RotatingObjects</code> folder.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec22"></a>Material and mapping animation</h3></div></div></div><p>Another really useful <a id="id72" class="indexterm"></a>animation technique is UV or mapping animation, as shown in the following screenshot. This involves programmatically <a id="id73" class="indexterm"></a>tweaking or changing the UV coordinates across a mesh's vertices over time to slide or move around the texture on its surface. This doesn't change or alter the pixels inside the texture itself, but rather animates where the pixels are mapped on the surface. Using UV animation, various effects can be created, such as animated water, flowing lava, moving clouds, warp tunnel effects, and lots more. Consider code sample 1-6 (<code class="literal">MatScroller.cs</code>).</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_22.jpg" /><div class="caption"><p>Animating texture mapping for a surface to create moving clouds, water, or lava</p></div></div><p>Code sample 1-6: material scroller:</p><div class="informalexample"><pre class="programlisting">//CLASS TO SCROLL TEXTURE ON PLANE. CAN BE USED FOR MOVING SKY
//------------------------------------------------
using UnityEngine;
using System.Collections;
//------------------------------------------------
[RequireComponent (typeof (MeshRenderer))] //Requires Renderer Filter Component
public class MatScroller : MonoBehaviour
{
  //Public variables
  //------------------------------------------------
  //Reference to Horizontal Scroll Speed
  public float HorizSpeed = 1.0f;
  
  //Reference to Vertical Scroll Speed
  public float VertSpeed = 1.0f;
  
  //Reference to Min and Max Horiz and Vertical UVs to scroll between
  public float HorizUVMin = 1.0f;
  public float HorizUVMax = 2.0f;
  
  public float VertUVMin = 1.0f;
  public float VertUVMax = 2.0f;
  
  //Private variables
  //------------------------------------------------
  //Reference to Mesh Renderer Component
  private MeshRenderer MeshR = null;

  //Methods
  //------------------------------------------------
  // Use this for initialization
  void Awake ()
  {
    //Get Mesh Renderer Component
    MeshR = GetComponent&lt;MeshRenderer&gt;();
  }
  //------------------------------------------------
  // Update is called once per frame
  void Update () 
  {
    //Scrolls texture between min and max
    Vector2 Offset = new Vector2((MeshR.material.mainTextureOffset.x &gt; HorizUVMax) ? HorizUVMin : MeshR.material.mainTextureOffset.x + Time.deltaTime * HorizSpeed,
                   (MeshR.material.mainTextureOffset.y &gt; VertUVMax) ? VertUVMin : MeshR.material.mainTextureOffset.y + Time.deltaTime * VertSpeed);
    
    //Update UV coordinates
    MeshR.material.mainTextureOffset = Offset;
  }
  //------------------------------------------------
}
//------------------------------------------------</pre></div><p>This<a id="id74" class="indexterm"></a> code <a id="id75" class="indexterm"></a>can be attached to a mesh object to animate its material. Simply set the <code class="literal">HorizSpeed</code> and <code class="literal">VertSpeed</code> variables from the object inspector to control the horizontal and vertical scroll speeds of the material.</p><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_23.jpg" /><div class="caption"><p>Controlling a material's scroll speed</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note07"></a>Note</h3><p>The Unity project for this assignment can be found in this book's companion files in the <code class="literal">Chapter01/texture_animator</code> folder.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec23"></a>Camera shaking – animation effects</h3></div></div></div><div class="mediaobject"><img src="/graphics/9781782174813/graphics/B04103_01_24.jpg" /><div class="caption"><p>The camera shake effect</p></div></div><p>If you've played <a id="id76" class="indexterm"></a>hard-hitting action games, such as beat 'em ups or shooters, you'll often see a camera shake effect when the characters get hurt. The shake effect adds a dramatic impact and dynamism to the action. It's also a really easy animation effect to achieve, based only on the principles and ideas we've already seen in this chapter. Consider code sample 1-7, which may be added to any scene camera to create a shake effect:</p><p>Code sample 1-7: camera shake:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//---------------------
public class CameraShake : MonoBehaviour 
{
  private Transform ThisTransform = null;

  //Total time for shaking in seconds
  public float ShakeTime = 2.0f;

  //Shake amount - distance to offset in any direction
  public float ShakeAmount = 3.0f;

  //Speed of camera moving to shake points
  public float ShakeSpeed = 2.0f;

  //---------------------
  // Use this for initialization
  void Start () 
  {
    //Get transform component
    ThisTransform = GetComponent&lt;Transform&gt;();

    //Start shaking
    StartCoroutine(Shake());
  }
  //---------------------
  //Shake camera
  public IEnumerator Shake()
  {
    //Store original camera position
    Vector3 OrigPosition = ThisTransform.localPosition;

    //Count elapsed time (in seconds)
    float ElapsedTime = 0.0f;

    //Repeat for total shake time
    while(ElapsedTime &lt; ShakeTime)
    {
      //Pick random point on unit sphere
      Vector3 RandomPoint = OrigPosition + Random.insideUnitSphere * ShakeAmount;

      //Update Position
      ThisTransform.localPosition = Vector3.Lerp(ThisTransform.localPosition, RandomPoint, Time.deltaTime * ShakeSpeed);

      //Break for next frame
      yield return null;

      //Update time
      ElapsedTime += Time.deltaTime;
    }

    //Restore camera position
    ThisTransform.localPosition = OrigPosition;
  }
  //---------------------
}
//---------------------</pre></div><p>This code <a id="id77" class="indexterm"></a>sample uses coroutines to fluctuate the position of the camera randomly over time within an imaginary spherical volume using the <code class="literal">Random.insideUnitSphere</code> variable. To use this code, just drag and drop the script onto a camera, and go!</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"></a>Note</h3><p>The Unity project for this assignment can be found in this book's companion files in the <code class="literal">Chapter01/camera_shake</code> folder.</p></div></div></div>