<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec108"></a>Level editor â€“ saving/loading levels to file</h2></div></div><hr /></div><p>Now that we have the groundwork all placed and ready, let's get to the real meat of the <a id="id682" class="indexterm"></a>level editor: saving <a id="id683" class="indexterm"></a>and loading! Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open our <code class="literal">LevelEditor</code> class in your IDE. The first step will be to include some additional functionality at the beginning of our file:</p><div class="informalexample"><pre class="programlisting">//You must include these namespaces
//to use BinaryFormatter
using System;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;</pre></div></li><li><p>The first thing we'll want to add is a variable, as follows:</p><div class="informalexample"><pre class="programlisting">private string levelName = "Level1";</pre></div></li><li><p>Now, we'll need to add the following code to the <code class="literal">OnGUI</code> function:</p><div class="informalexample"><pre class="programlisting">GUILayout.BeginArea(new Rect(10, 20, 100, 100));
levelName = GUILayout.TextField(levelName);
if (GUILayout.Button ("Save"))
{
  SaveLevel();
}
if (GUILayout.Button ("Load"))
{
  //If we have a file with the name typed in, load it!
  if(File.Exists(Application.persistentDataPath + "/" + levelName + ".lvl"))
  {
    LoadLevelFile(levelName);
    PlayerStart.spawned = false;

    // We need to wait one frame before UpdateOrbTotals 
    // will work (Orbs need to have Tag assigned)
    StartCoroutine(LoadedUpdate());
  }
  else
  {
    levelName = "Error";
  }
}
if (GUILayout.Button ("Quit"))
{
  enabled = false;
}
GUILayout.EndArea();</pre></div></li><li><p>We are missing<a id="id684" class="indexterm"></a> some of these <a id="id685" class="indexterm"></a>functions, so let's start with <code class="literal">SaveLevel</code>, as follows:</p><div class="informalexample"><pre class="programlisting">void SaveLevel()
{
  List&lt;string&gt; newLevel = new List&lt;string&gt;();
  
  for(int i = yMin; i &lt;= yMax; i++)
  {
    string newRow = "";
    for(int j = xMin; j &lt;= xMax; j++)
    {
      Vector3 pos = new Vector3(j, i, 0);
      Ray ray = Camera.main.ScreenPointToRay(pos);
      RaycastHit hit = new RaycastHit();
      
      Physics.Raycast(ray, out hit, 100);
      
      // Will check if there is something hitting us within 
      // a distance of .1
      Collider[] hitColliders = Physics.OverlapSphere(pos, 0.1f);
      
      if(hitColliders.Length &gt; 0)
      {
        // Do we have a tile with the same name as this 
        // object?
        for(int k = 0; k &lt; tiles.Count; k++)
        {
          // If so, let's save that to the string
          if(tiles[k].name == hitColliders[0].gameObject.name)
          {
            newRow += (k+1).ToString() + ",";
          }
        }
      }
      else
      {
        newRow += "0,";
      }
    }
    newRow += "\n";
    newLevel.Add(newRow);
  }
  // Reverse the rows to make the final version rightside 
  // up
  newLevel.Reverse();
  
  string levelComplete = "";
  
  foreach(string level in newLevel)
  {
    levelComplete += level;
  }
  // This is the data we're going to be saving
  print(levelComplete);

  //Save to a file
  BinaryFormatter bFormatter = new BinaryFormatter();
  FileStream file = File.Create(Application.persistentDataPath + "/"+ levelName + ".lvl");
  bFormatter.Serialize (file, levelComplete);
  file.Close ();
  
}</pre></div></li></ol></div><p>To do this, we will go <a id="id686" class="indexterm"></a>through <a id="id687" class="indexterm"></a>the map, see what tiles are at a certain place, and add them to a string for each column using a list to store each of the rows. Then, we put them all together into a single string, which we could just store in <code class="literal">PlayerPrefs</code>.</p><p>However, instead of using the <code class="literal">PlayerPrefs</code> class as we did before, we will store our data in an actual file using the <code class="literal">FileStream</code> class.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec60"></a>FileStreams</h3></div></div></div><p>To determine <a id="id688" class="indexterm"></a>where to save our file, we will use the <code class="literal">Application.persistentDataPath</code> variable. This value will point to something differently, depending on what platform you're working with. For instance, on a Windows 8 computer, it will save to <code class="literal">C:\Users\YOUR_USER_NAME\AppData\LocalLow\COMPANY_NAME\PROJECT_NAME</code>. For more information, check out <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html" target="_blank">http://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html</a>.</p><p>For more information on <code class="literal">FileStreams</code>, check out the Microsoft Developers Network's page on it at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.io.filestream(v=vs.110).aspx" target="_blank">http://msdn.microsoft.com/en-us/library/system.io.filestream(v=vs.110).aspx</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec61"></a>BinaryFormatter</h3></div></div></div><p>We don't want the<a id="id689" class="indexterm"></a> file to be easy to read, so we'll use the <code class="literal">BinaryFormatter</code> class, which will convert our object into a byte array and be a stream of bytes, which will be much harder for potential hackers to read.</p><p>For more information on the <code class="literal">BinaryFormatter</code> class, check out the Microsoft Developers Network's page on it at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v=vs.110).aspx" target="_blank">http://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v=vs.110).aspx</a>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Now we need<a id="id690" class="indexterm"></a> to add in the following functions to load the file that we'll be creating from the save functionality:</p><div class="informalexample"><pre class="programlisting">void LoadLevelFile(string level)
{
  // Destroy everything inside our currently level that's
  // created dynamically
  foreach(Transform child in dynamicParent.transform) {
    Destroy(child.gameObject);
  }
  
  BinaryFormatter bFormatter = new BinaryFormatter();
  FileStream file = File.OpenRead(Application.persistentDataPath + "/"+ level + ".lvl");

  // Convert the file from a byte array into a string
  string levelData = bFormatter.Deserialize(file) as string;

  // We're done working with the file so we can close it
  file.Close ();
  
  LoadLevelFromString(levelData);
  
  // Set our text object to the current level.
  levelName = level;
}
  
  public void LoadLevelFromString(string content)
  {
    // Split our string by the new lines (enter)
    List &lt;string&gt; lines = new List &lt;string&gt; (content.Split ('\n'));
    // Place each block in order in the correct x and y 
    // position
    for(int i = 0; i &lt; lines.Count; i++)
    {
      string[] blockIDs = lines[i].Split (',');
      for(int j = 0; j &lt; blockIDs.Length - 1; j++)
      {
        CreateBlock(int.Parse(blockIDs[j]), j, lines.Count - i);
      }
    }
  }</pre></div></li><li><p>Finally, we <a id="id691" class="indexterm"></a>need to add in <code class="literal">LoadedUpdate</code> so that <code class="literal">Orbs</code> will be updated after they've been created, as follows:</p><div class="informalexample"><pre class="programlisting">IEnumerator LoadedUpdate()
{
  //returning 0 will make it wait 1 frame
  yield return 0;
  
  GameController._instance.UpdateOrbTotals(true);
}</pre></div></li><li><p>
<span class="strong"><strong>Save</strong></span> the file and exit the editor. Save the project and play the game! Take a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785883118/graphics/B05212_10_09.jpg" /></div></li></ol></div><p>As you can see, when we play the game you'll see a new menu appear on the left-hand side? We can now give a name to all of our files that we want, type in their name, hit <span class="strong"><strong>Save</strong></span> to save it to a file, and <span class="strong"><strong>Load</strong></span> to load the data for the level if it exists! Finally, we can click on <span class="strong"><strong>Quit</strong></span> to exit out of the editor whenever we want. </p><p>Take a look at the<a id="id692" class="indexterm"></a> following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785883118/graphics/B05212_10_10.jpg" /></div><p>As you can see here, the files are saved in our <code class="literal">Application.persistentDataPath</code> location (print it out to know exactly where it is)!</p></div></div>