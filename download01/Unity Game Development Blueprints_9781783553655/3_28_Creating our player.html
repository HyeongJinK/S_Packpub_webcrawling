<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec32"></a>Creating our player</h2></div></div><hr /></div><p>Having the basis of our <a id="id182" class="indexterm"></a>world is great, but if we don't have a player, it <a id="id183" class="indexterm"></a>doesn't matter how nice the level looks. In this section, we will create the actual player that will walk around and move in the world:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's first create a capsule by selecting <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Other</strong></span> | <span class="strong"><strong>Capsule</strong></span>. Have a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_03_4.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip04"></a>Tip</h3><p>If you are using Unity 4.6 or above, use the <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Capsule</strong></span>
</p></div></li><li><p>Right now, the capsule is too big to fit in our world because it is larger than our blocks. To easily fix this, we will set <span class="strong"><strong>Scale</strong></span> of our capsule to (<code class="literal">.4</code>, <code class="literal">.4</code>, <code class="literal">.4</code>). Also, set <span class="strong"><strong>Position</strong></span> to (<code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">0</code>).</p></li><li><p>Now, we want our player to use gravity and forces, so we will need to add a rigid body component by going to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Rigid</strong></span> <span class="strong"><strong>Body</strong></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>The 2D and 3D Physics systems are not interchangeable. You'll need to choose one or the other when working on a project. We're using 3D right now, so you can have a good idea of what to look out for, and the differences between 2D and 3D.</p></div></li><li><p>Next, since we are creating 2D gameplay, we don't want our player to move in the <span class="strong"><strong>Z</strong></span> axis, so under <span class="strong"><strong>Rigid Body</strong></span>, open the <span class="strong"><strong>Constraints</strong></span> box, and check <span class="strong"><strong>Z</strong></span> in the <span class="strong"><strong>Freeze Position</strong></span> variable. After that, check each axis for <span class="strong"><strong>Freeze Rotation</strong></span>, as we do not want our character to change its rotation via <span class="strong"><strong>Rigid Body</strong></span> (we'll rotate it via code). Have a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_03_5.jpg" /></div></li><li><p>After this, all that's left is to create some custom functionality, which means another script. Create a new script file in the <code class="literal">Scripts</code> folder called <code class="literal">PlayerBehaviour</code>, and open it in <code class="literal">MonoDevelop</code>.</p></li><li><p>With the <code class="literal">PlayerBehaviour</code> script opened, let's first write down each of the issues we need to <a id="id184" class="indexterm"></a>solve and make them <a id="id185" class="indexterm"></a>functions. As programmers, it's our job to solve problems, and separating problems into smaller pieces will make it easier to solve, rather than trying to solve the entire thing all at once. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">  void FixedUpdate () 
  {
    // Move the player left and right
    Movement();

    // Sets the camera to center on the player's position.
    // Keeping the camera's original depth
    Camera.main.transform.position = new Vector3(transform.position.x, 
  transform.position.y, 
  Camera.main.transform.position.z);
  }</pre></div></li><li><p>Next, we write the following code in the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">void Update()
{
// Have the player jump if they press the jump button
  Jumping();
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note37"></a>Note</h3><p>
<code class="literal">Update()</code> is great<a id="id186" class="indexterm"></a> and is called in every frame, but it's called at random times leading to more instant, but less constant, things, such as input. Instead of that, <code class="literal">FixedUpdate()</code> is a great<a id="id187" class="indexterm"></a> function to use for things that need to happen consistently and for things like Physics (due to its fixed delta time). However, in a platformer, the player needs to feel a jump instantly, so that's why I put the <code class="literal">Jumping</code> function inside <code class="literal">Update</code>.</p></div><p>So, at this point, we have broken apart the player's behavior into two sections: their movement and their jumping.</p></li><li><p>Next, we need<a id="id188" class="indexterm"></a> to declare some variables <a id="id189" class="indexterm"></a>for us to use as follows:</p><div class="informalexample"><pre class="programlisting">// Force to apply when player jumps
public Vector2 jumpForce = new Vector2(0, 450);

// How fast we'll let the player move in the x axis
public float maxSpeed = 3.0f;

// A modifier to the force applied
public float speed = 50.0f;

// The force to apply that we will get for the player's movement
private float xMove;

// Set to true when the player can jump
private bool shouldJump;</pre></div></li><li><p>I initialized the public data here, but the user can modify the numbers in <span class="strong"><strong>Inspector</strong></span>. However, we still need to initialize the <code class="literal">private</code> variables in the <code class="literal">Start</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">void Start ()
{
  shouldJump = false;
  xMove = 0.0f;
}</pre></div></li><li><p>Now that we have the variables, we think we need to fill in the implementation for the <code class="literal">Movement</code> function now, as follows:</p><div class="informalexample"><pre class="programlisting">void Movement()
{
  //Get the player's movement (-1 for left, 1 for right, 0 for // none)
  xMove = Input.GetAxis("Horizontal");

  if(xMove != 0)
  {
    // Setting player horizontal movement
    float xSpeed = Mathf.Abs(xMove * rigidbody.velocity.x);
    
    if (xSpeed &lt; maxSpeed) 
    {
      Vector3 movementForce = new Vector3(1,0,0);
      movementForce *= xMove * speed;
      rigidbody.AddForce(movementForce);        
    }
    
    // Check speed limit
    if (Mathf.Abs(rigidbody.velocity.x) &gt; maxSpeed) 
    {
      Vector2 newVelocity;
      
      newVelocity.x = Mathf.Sign(rigidbody.velocity.x) * maxSpeed;
      newVelocity.y = rigidbody.velocity.y;
      
      rigidbody.velocity = newVelocity;
    }
  }
  else
  {
    // If we're not moving, get slightly slower
    Vector2 newVelocity = rigidbody.velocity;
    
    // Reduce the current speed by 10%
    newVelocity.x *= 0.9f;
    rigidbody.velocity = newVelocity;
  }
}</pre></div><p>In this <a id="id190" class="indexterm"></a>section of code, we <a id="id191" class="indexterm"></a>use a different way to get input from the player, the <code class="literal">GetAxis</code> function. <code class="literal">GetAxis</code> will return a value for directional movement. The value will be in the range <code class="literal">-1</code> to 1 for keyboard and joystick input, so it can work on controllers or on various places on your keyboard. Unity already provides a few preset axes for us, which you can look at. We will go to these preset axes now.</p></li><li><p>Back in the Unity Editor, Access the <span class="strong"><strong>Input</strong></span> properties by going to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Input</strong></span>. Once there, extend the <span class="strong"><strong>Jump</strong></span> tab. In <span class="strong"><strong>Alt Positive Button</strong></span>, put in <code class="literal">up</code>. Have a look at the <span class="strong"><strong>Axes</strong></span> and <span class="strong"><strong>Jump</strong></span> tabs in the following screenshot:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p>It's okay if there is an error shown in the console right now, as we haven't created the <code class="literal">Jumping</code> function yet.</p></div><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_03_6.jpg" /></div></li><li><p>Next, let's <a id="id192" class="indexterm"></a>implement the <code class="literal">Jumping</code> function, as<a id="id193" class="indexterm"></a> follows:</p><div class="informalexample"><pre class="programlisting">void Jumping()
{
  if(Input.GetButtonDown("Jump")) 
  {
    shouldJump = true;
  }
  
  // If the player should jump
  if(shouldJump) 
  {
    rigidbody.AddForce(jumpForce);  
    shouldJump = false;
  }
}</pre></div><p>Now, if we press space bar or the up arrow key, we will turn the <code class="literal">shouldJump</code> Boolean value to <code class="literal">true</code>. If it's <code class="literal">true</code>, then we'll apply <code class="literal">jumpForce</code> to our character.</p></li><li><p>With that<a id="id194" class="indexterm"></a> completed, let's save our script<a id="id195" class="indexterm"></a> and jump back into the Unity editor. Attach the newly created behavior to our player if you haven't done so already. Have a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_03_7.jpg" /></div></li></ol></div><p>Great start! We now have a player in our world, and we're able to move around and jump. However, if you keep playing with it, you'll notice some of the issues this has: namely, the fact that you can always jump up as many times as you want, and if you hold a direction key hitting a wall, you'll stay stuck in the air. This could make for interesting game mechanics, but I'm going to assume this is not what you're looking for. In addition, all we see at this time is dark grey. </p><p>Let's solve those issues now. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Make sure <a id="id196" class="indexterm"></a>you have exited the game<a id="id197" class="indexterm"></a> by clicking on the play button again, and then create a directional light by going to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Other</strong></span> | <span class="strong"><strong>Directional Light</strong></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p>Make sure you exit the game before making changes, otherwise you will lose everything that you've done.</p></div><p>If you go to the <span class="strong"><strong>Game</strong></span> tab and play the game, you'll see immediately that the game changes for the better, graphics-wise. Have a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_03_8.jpg" /></div><p>This is due to our inclusion of the directional light. You can think of a directional light like the sun in that no matter where you place it, it will affect objects. You may notice in <span class="strong"><strong>Inspector</strong></span> that there are a number of properties that you can use to change the rotation of the light, the color, and how strong it is. Depending on the game, you may want to modify these properties accordingly. We'll be looking at it, and other light types, more closely in our next project.</p></li><li><p>Next, before<a id="id198" class="indexterm"></a> we solve our movement<a id="id199" class="indexterm"></a> issues, I wanted to show you a tool that you can use as a developer to help you when working on your own projects. Add the following function to your script:</p><div class="informalexample"><pre class="programlisting">void OnDrawGizmos() 
{
  Debug.DrawLine(transform.position, transform.position + 
  rigidbody.velocity, Color.red);
}</pre></div><p>
<code class="literal">OnDrawGizmos</code> is a function inherited by the <code class="literal">MonoBehaviour</code> class that will allow us to draw things appearing in the Scene view, and sure enough, you will not see anything in the Game view, but if you look at the <span class="strong"><strong>Scene</strong></span> tab while the game is being played, you'll be able to see the velocity that our object is traveling at. Have a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_03_9.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"></a>Note</h3><p>Note that the <span class="strong"><strong>Game</strong></span> tab needs to be active before Input registers any keys pressed, which is why I have both tabs open. You can also click on the <span class="strong"><strong>Gizmos</strong></span> button on the right hand side of the <span class="strong"><strong>Game</strong></span> tab in order to see the <span class="strong"><strong>Gizmos</strong></span> during the game as well.</p></div><p>In this <a id="id200" class="indexterm"></a>example, the red line<a id="id201" class="indexterm"></a> shows that I'm jumping up and moving to the left-hand side. If you look at the <span class="strong"><strong>Scene</strong></span> view when the player is walking, you'll see little bumps occurring. This isn't something we like to see, as we expect the collision to flow together. These bumps occur, because the moment we hit the edges of two separate boxes, the collision engine will try to push the player in different directions to prevent the collision from happening. After the collisions occur, the Physics engine will try to combine both of those forces into one, which causes these hiccups. We can fix this by telling Unity to spend some extra time doing the calculations.</p></li><li><p>Go into Unity's Physics properties by going to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Physics</strong></span>. Change the <span class="strong"><strong>Min Penetration for Penalty</strong></span> property to <code class="literal">0.0001</code>.</p><p>The <span class="strong"><strong>Min Penetration for Penalty</strong></span> property tells us how deep two objects are allowed to be penetrated by another before the collision solver pushes them apart.</p></li><li><p>Now there's the matter of being able to jump anytime we want. What we want to happen is if the player is on the ground, they can jump, but they cannot jump again until they are on the ground. This is to prevent the case of being able to jump while falling. So, to do this, we will need to introduce some new variables inside of our <code class="literal">PlayerBehaviour</code> script, as follows:</p><div class="informalexample"><pre class="programlisting">private bool onGround;
private float yPrevious;</pre></div></li><li><p>Just like <a id="id202" class="indexterm"></a>any <code class="literal">private</code> variables, we<a id="id203" class="indexterm"></a> will need to initialize them in our <code class="literal">Start</code> function. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">onGround = false;
yPrevious = Mathf.Floor(transform.position.y);</pre></div></li><li><p>Now, in our <code class="literal">Jumping</code> function, we just need to add the highlighted part of the following code:</p><div class="informalexample"><pre class="programlisting">void Jumping()
{
  if(Input.GetButtonDown("Jump")) 
  {
    shouldJump = true;
  }
  
  // If the player should jump
  if(shouldJump <span class="strong"><strong>&amp;&amp; onGround</strong></span>) 
  {
    rigidbody.AddForce(jumpForce);
    shouldJump = false;
  }
}</pre></div></li><li><p>In our <code class="literal">Update</code> function, we will add in a new function for us to check if we are grounded, as follows:</p><div class="informalexample"><pre class="programlisting">// Update is called once per frame
void Update () 
{
<span class="strong"><strong>  // Check if we are on the ground</strong></span>
<span class="strong"><strong>  CheckGrounded();</strong></span>
  
  // Have the player jump if they press the jump button
  Jumping();
}</pre></div></li><li><p>Now, we <a id="id204" class="indexterm"></a>just need to add in the code<a id="id205" class="indexterm"></a> for <code class="literal">CheckGrounded</code>. Sadly, this isn't exactly a simple issue to solve without math, so we will actually need to use some linear algebra to solve the issue for us, as follows:</p><div class="informalexample"><pre class="programlisting">void CheckGrounded()
{
// Check if the player is hitting something from 
// the center of the object (origin) to slightly below the 
// bottom of it (distance)
  float distance = (GetComponent&lt;CapsuleCollider&gt;().height/2 * 
  this.transform.localScale.y) + .01f;
  Vector3 floorDirection = transform.TransformDirection(-Vector3.up);
  Vector3 origin = transform.position;

  if(!onGround)
  {
    // Check if there is something directly below us
    if (Physics.Raycast (origin, floorDirection, distance)) 
    {
      onGround = true;
    }
  }
  // If we are currently grounded, are we falling down or jumping?
  else if((Mathf.Floor(transform.position.y) != yPrevious)) 
  {
    onGround = false;
  }

  // Our current position will be our previous next frame
  yPrevious = Mathf.Floor(transform.position.y);
}</pre></div></li></ol></div><p>This function uses a <code class="literal">Raycast</code> function to cast an invisible line (ray) from origin in the direction of the floor for a certain distance, which is just slightly further than our player. If it finds an object colliding with this, it will return <code class="literal">true</code>, which will tell us that we are indeed on the ground.</p><p>In the game, we can leave the ground in two ways, by jumping or by falling down a platform; either way, we will change our <code class="literal">y</code> position. If that's the case, we are no longer on the ground, so <code class="literal">onGround</code> will be set to <code class="literal">false</code>. The <code class="literal">Floor</code> function will remove the decimal from a number to allow for some leeway for floating point error.</p><p>Now, our only <a id="id206" class="indexterm"></a>issue resides in the fact that the player sticks<a id="id207" class="indexterm"></a> to walls if they press into it. To solve this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We will simply not allow the player to move into a wall, by not adding a force if we're right next to a wall. Add the following bolded code to this section of code in the <code class="literal">Movement</code> function:</p><div class="informalexample"><pre class="programlisting">// Movement()
// if xMove != 0...
if (xSpeed &lt; maxSpeed)
{
  Vector3 movementForce = new Vector3(1,0,0);
  movementForce *= xMove * speed;

<span class="strong"><strong>  RaycastHit hit;</strong></span>
<span class="strong"><strong>  if(!rigidbody.SweepTest(movementForce, out hit, 0.05f))</strong></span>
<span class="strong"><strong>  {</strong></span>
    rigidbody.AddForce(movementForce);
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
// Etc.</pre></div><p>The <code class="literal">SweepTest</code> function<a id="id208" class="indexterm"></a> will check in the direction the rigid body is traveling, and if it sees something within a certain direction, it will get hit with the object that it has touched and return <code class="literal">true</code>. We want to stop the player from being able to move into the wall, so we will not add the force if that's the case.</p></li><li><p>Now, this works for the most part, except for when we are already along the wall, jumping up, and other fringe cases. To fix these issues when we touch a wall, we will do just as we solved the last problem. We will have a variable that will keep track if we touch a wall, as follows:</p><div class="informalexample"><pre class="programlisting">private bool collidingWall;</pre></div></li><li><p>After that, we need to initialize it in <code class="literal">Start</code>, as follows:</p><div class="informalexample"><pre class="programlisting">collidingWall = false;</pre></div></li><li><p>After this, we <a id="id209" class="indexterm"></a>will use the 3D collision detection functions to determine whether we're touching a wall, as follows:</p><div class="informalexample"><pre class="programlisting">// If we hit something and we're not grounded, it must be a wall or // a ceiling. 
  void OnCollisionEnter(Collision collision)
  { 
    if (!onGround)
    { 
      collidingWall = true;  
    }
  }
  
  void OnCollisionExit(Collision collision)
  {
    collidingWall = false;
  }</pre></div><p>You'll notice <a id="id210" class="indexterm"></a>that the functions look quite similar to the 2D functions apart from… well, the word 2D.</p></li><li><p>Next, inside of your <code class="literal">Movement</code> function, add the following bolded code:</p><div class="informalexample"><pre class="programlisting">void Movement()
{
  //Get the player's movement (-1 for left, 1 for right, 0 for // none)
  xMove = Input.GetAxis("Horizontal");
  
<span class="strong"><strong>  if(collidingWall &amp;&amp; !onGround)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    xMove = 0;</strong></span>
<span class="strong"><strong>  }</strong></span>

  // Etc.</pre></div><p>Now, if we collide against a wall, we will stop the player from applying a force.</p></li><li><p>Save the script, and go back to Unity. Refresh the scripts if needed, and hit the play button. Have a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_03_10.jpg" /></div></li></ol></div><p>Now, our <a id="id211" class="indexterm"></a>player can jump along walls, fall normally, and<a id="id212" class="indexterm"></a> can only jump when he is on the ground! We now have the basis to complete a platformer game!</p></div>