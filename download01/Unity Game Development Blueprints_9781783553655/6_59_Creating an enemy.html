<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec60"></a>Creating an enemy</h2></div></div><hr /></div><p>Now that we can take <a id="id462" class="indexterm"></a>pictures, let's create an enemy to take pictures of! We <a id="id463" class="indexterm"></a>will perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The first step to adding in an enemy is to import the assets required to use it. Inside our <code class="literal">Chapter 6\Assets\Ghost Model</code> location, you'll find a series of files.</p></li><li><p>First, let's create the material for our new mesh. To do this, go into either the <code class="literal">1024 Textures</code> or <code class="literal">2048 Textures</code> folder, and move the files into the <code class="literal">Materials</code> folder. Afterwards, navigate to <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Material</strong></span>, and give it the name <code class="literal">GhostMaterial</code>. Change the <span class="strong"><strong>Shader</strong></span> value to <span class="strong"><strong>Bumped Diffuse</strong></span>, and move the <code class="literal">Ghost_Tex</code> file into the <code class="literal">Base</code> and <code class="literal">Ghost_TEX_NRM</code> file in the <span class="strong"><strong>Normalmap</strong></span> selection. You'll get a warning indicating the texture isn't marked as a normal map; feel free to click on <span class="strong"><strong>Fix Now</strong></span>, or go back into the file, and change its <span class="strong"><strong>Texture Type</strong></span> value to <code class="literal">Normal map</code>. The following screenshot shows the Unity screen with these changes:</p><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_06_7.jpg" /></div></li><li><p>Now, move to <a id="id464" class="indexterm"></a>the <span class="strong"><strong>Models</strong></span> folder on the<a id="id465" class="indexterm"></a> <span class="strong"><strong>Project</strong></span> tab, and drag-and-drop the <span class="strong"><strong>Ghost_mesh.obj</strong></span> file in there. Now, select the object to bring up its properties in the <span class="strong"><strong>Inspector</strong></span> tab. Under <span class="strong"><strong>Scale Factor</strong></span> in the <span class="strong"><strong>Model</strong></span> tab, change the value to <code class="literal">.10</code> to scale the object to 1/10th of its starting size. Then, check <span class="strong"><strong>Generate Colliders</strong></span>, and uncheck the <span class="strong"><strong>Import Materials</strong></span> option, making sure to hit <span class="strong"><strong>Apply</strong></span>.</p></li><li><p>Under the <span class="strong"><strong>Rig</strong></span> tab, change the <span class="strong"><strong>Animation Type</strong></span> value to <span class="strong"><strong>None</strong></span>, as this model doesn't have any animations, and then click on <span class="strong"><strong>Apply</strong></span>.</p></li><li><p>Now, go somewhere in your world in the <span class="strong"><strong>Scene</strong></span> view, and drag-and-drop the character onto the screen near your player and terrain. have a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_06_8.jpg" /></div></li><li><p>Right now, the <a id="id466" class="indexterm"></a>mesh is just using the default <a id="id467" class="indexterm"></a>material, so let's fix that. Expand the <span class="strong"><strong>Ghost_mesh</strong></span> object, and select its child. In the <span class="strong"><strong>Inspector</strong></span> tab, extend the <span class="strong"><strong>Mesh Renderer</strong></span> tab, and change the material's <span class="strong"><strong>Element 0</strong></span> property to our <code class="literal">Ghost</code> material, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553655/graphics/3655OT_06_9.jpg" /></div></li></ol></div><p>And now, the <a id="id468" class="indexterm"></a>character has a material that makes it<a id="id469" class="indexterm"></a> appear as an enemy much nicer. Spooky!</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec28"></a>State machines 101</h3></div></div></div><p>We oftentimes write code to <a id="id470" class="indexterm"></a>provide the <a id="id471" class="indexterm"></a>reactive or interactive parts within our simulation (or game world)â€”things such as when you're pressing a button or if you're walking or jumping. If you look at real life, you should notice that a lot of things are reactive systems in that same way, such as your mobile phone and toaster. Depending on the stimuli provided to these objects, the state of these objects may change. We describe something that can be in one of multiple states at a time as a state machine.</p><p>Almost every program that we write is or can be a state machine of some sort, because technically, the moment you write <a id="id472" class="indexterm"></a>an <code class="literal">if</code> statement, you've created code that can be in one of at least two states. However, having a number of <code class="literal">switch</code> <a id="id473" class="indexterm"></a>and <code class="literal">if</code> statements can quickly get out of hand, making it very hard for people to understand what your code is actually doing. As a programmer, we want to isolate problems and break them down into their simplest parts before jumping in to solve them.</p><p>There are different kinds of state machines, but for this first example, we are going to create a simple <span class="strong"><strong>Finite State Machine</strong></span> (<span class="strong"><strong>FSM</strong></span>). When I say finite, it means that each of the states is <a id="id474" class="indexterm"></a>already <a id="id475" class="indexterm"></a>defined ahead of time. With a<a id="id476" class="indexterm"></a> finite state machine, we can have different states in which we can process input differently depending on the state.</p><p>For example, if you are on a ladder, you can only move up and down and not to the sides.</p></div></div>