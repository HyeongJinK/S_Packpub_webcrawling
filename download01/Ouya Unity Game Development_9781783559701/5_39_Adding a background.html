<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec41"></a>Adding a background</h2></div></div><hr /></div><p>There is still a lot of black in the background and as the game has a space theme, let's add some stars <a id="id219" class="indexterm"></a>in there. The way we'll do this is to add a sphere that we<a id="id220" class="indexterm"></a> can map the stars texture to, so click on <span class="strong"><strong>Game Object</strong></span> | <span class="strong"><strong>Create Other</strong></span> | <span class="strong"><strong>Sphere</strong></span>, and position it at <code class="literal">X: 0</code>, <code class="literal">Y: 0</code>, <code class="literal">Z: 0</code>. We also need to set the size to <code class="literal">X: 100</code>, <code class="literal">Y: 100</code>, <code class="literal">Z: 100</code>. Drag the <code class="literal">stars</code> texture, located at <code class="literal">Textures/stars</code>, on to the new sphere that we created in our scene. That was simple, wasn't that? Unity has added the texture to a material that appears on the outside of our sphere while we need it to show on the inside. To fix it, we are going to reverse the triangle order, flip the normal map, and flip the UV map with C# code. Right-click on the <code class="literal">Scripts</code> folder and then click on <span class="strong"><strong>Create</strong></span> and select <span class="strong"><strong>C# Script</strong></span>. Once you click on it, a script will appear in the <code class="literal">Scripts</code> folder; it should already have focus and be asking you to type a name for the script, call it <code class="literal">SkyDome</code>. Double-click on the script in Unity and it will open in MonoDevelop. Edit the <code class="literal">Start</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">void Start () {
  
  // Get a reference to the mesh
  MeshFilterBase MeshFilter = transform.GetComponent("MeshFilter") as MeshFilter;
  Mesh mesh = BaseMeshFilter.mesh;
  
  // Reverse triangle winding
  int[] triangles = mesh.triangles; 
  int numpolies = triangles.Length / 3;
  for(int t = 0;t &lt;numpolies; t++)
  {
    Int tribuffer = triangles[t * 3];
    triangles[t * 3] = triangles[(t * 3) + 2];
    triangles[(t * 3) + 2] = tribuffer;
  }
  
  // Read just uv map for inner sphere projection
  Vector2[] uvs = mesh.uv;
  for(int uvnum = 0; uvnum &lt; uvs.Length; uvnum++)
  {
    uvs[uvnum] = new Vector2(1 - uvs[uvnum].x, uvs[uvnum].y);
  }
  
  // Read just normals for inner sphere projection 
  Vector3[] norms = mesh.normals;       
  for(int normalsnum = 0; normalsnum &lt; norms.Length; normalsnum++)
  {
    norms[normalsnum] = -norms[normalsnum];
  }
  
  // Copy local built in arrays back to the mesh
  mesh.uv = uvs;
  mesh.triangles = triangles;
  mesh.normals = norms;    
}  </pre></div><p>The <a id="id221" class="indexterm"></a>breakdown of the code as is follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Get <a id="id222" class="indexterm"></a>the mesh of the sphere.</p></li><li><p>Reverse the way the triangles are drawn. Each triangle has three indexes in the array; this script just swaps the first and last index of each triangle in the array.</p></li><li><p>Adjust the <code class="literal">X</code> position for the UV map coordinates.</p></li><li><p>Flip the normals of the sphere.</p></li><li><p>Apply the new values of the reversed triangles, adjusted UV coordinates, and flipped normals to the sphere.</p></li></ol></div><p>Click and drag this <a id="id223" class="indexterm"></a>script onto your sphere GameObject and<a id="id224" class="indexterm"></a> test your scene. You should now see something like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783559701/graphics/9701OS_05_02.jpg" /></div></div>