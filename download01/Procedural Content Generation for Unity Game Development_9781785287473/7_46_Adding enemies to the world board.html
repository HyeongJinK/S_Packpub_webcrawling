<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec46"></a>Adding enemies to the world board</h2></div></div><hr /></div><p>As usual, we will<a id="id287" class="indexterm"></a> need to generate the enemies at random to keep the player on their toes. We then need to address the issue of enemies being able to move through black space. We will also have to handle the event that an enemy moves <a id="id288" class="indexterm"></a>off screen.</p><p>Let's start by adding the enemies to the world board. Open up the <code class="literal">BoardManager.cs</code> script for editing. You can start by adding the line <code class="literal">public GameObject enemy;</code> under all the other public variables. This will be our Enemy prefab reference. Then, take a look at <span class="emphasis"><em>Code Snip 7.2</em></span> for the rest of the update:</p><div class="informalexample"><pre class="programlisting">1 private void addTiles(Vector2 tileToAdd) {
2   if (!gridPositions.ContainsKey (tileToAdd)) {
3    gridPositions.Add (tileToAdd, tileToAdd);
4    GameObject toInstantiate = floorTiles [Random.Range (0, floorTiles.Length)];
5    GameObject instance = Instantiate (toInstantiate, new Vector3 (tileToAdd.x, tileToAdd.y, 0f), Quaternion.identity) as GameObject;
6    instance.transform.SetParent (boardHolder);
7
8    if (Random.Range (0, 3) == 1) {
9      toInstantiate = wallTiles[Random.Range (0,wallTiles.Length)];
10     instance = Instantiate (toInstantiate, new Vector3 (tileToAdd.x, tileToAdd.y, 0f), Quaternion.identity) as GameObject;
11     instance.transform.SetParent (boardHolder);
12    } else if (Random.Range (0, 50) == 1) {
13      toInstantiate = exit;
14      instance = Instantiate (toInstantiate, new Vector3 (tileToAdd.x, tileToAdd.y, 0f), Quaternion.identity) as GameObject;
15      instance.transform.SetParent (boardHolder);
16    }
17    else if (Random.Range (0, 20) == 1) {
18      toInstantiate = enemy;
19      instance = Instantiate (toInstantiate, new Vector3 (tileToAdd.x, tileToAdd.y, 0f), Quaternion.identity) as GameObject;
20      instance.transform.SetParent (boardHolder);
21    }
22  }
23 }</pre></div><p><span class="emphasis"><em>Code Snip 7.2</em></span> shows<a id="id289" class="indexterm"></a> the full <code class="literal">addTiles</code> function from the <code class="literal">BoardManager</code> class <a id="id290" class="indexterm"></a>with the addition of spawning enemies. <code class="literal">Lines 17-21</code> show the additional check needed to randomly generate an enemy. So the player will walk and discover new areas of the world board, but just as random wall tiles appear, so too will enemies now.</p><p>We still need to handle when and where enemies can move. The simplest and probably the easiest solution to enemies moving over black space is to destroy them if they move into that area. We can piggyback on that idea and also destroy enemies if they move outside of the camera view. This way enemies that are not rendered will not have a turn to move and slow down the overall game.</p><p>To implement this<a id="id291" class="indexterm"></a> functionality open up the <code class="literal">GameManager.cs</code> script for editing. We will be adding several small functions and updating others. Take a look at <span class="emphasis"><em>Code Snip 7.3</em></span> for the updates:</p><div class="informalexample"><pre class="programlisting">1 public void AddEnemyToList(Enemy script) {
2   enemies.Add(script);
3 }
4
5 public void RemoveEnemyFromList(Enemy script) {
6   enemies.Remove(script);
7 }
8
9 public bool checkValidTile (Vector2 pos) {
10  if (gridPositions.ContainsKey(pos)) {
11    return true;
12  }
13  return false;
14 }
15 
16 IEnumerator MoveEnemies() {
17   enemiesMoving = true;
18    
19   yield return new WaitForSeconds(turnDelay);
20    
21   if (enemies.Count == 0)  {
22     yield return new WaitForSeconds(turnDelay);
23   }
24 
25   List&lt;Enemy&gt; enemiesToDestroy = new List&lt;Enemy&gt;();
26   for (int i = 0; i &lt; enemies.Count; i++) {
27     if ((!enemies[i].getSpriteRenderer().isVisible) || (!boardScript.checkValidTile (enemies[i].transform.position))) {
28       enemiesToDestroy.Add(enemies[i]);
29       continue;
30     }
31
32     enemies[i].MoveEnemy ();
33 
34     yield return new WaitForSeconds(enemies[i].moveTime);
35   }
36   playersTurn = true;
37   enemiesMoving = false;
38 
39   for (int i = 0; i &lt; enemiesToDestroy.Count; i++) {
40     enemies.Remove(enemiesToDestroy[i]);
41     Destroy(enemiesToDestroy[i].gameObject);
42   }
43   enemiesToDestroy.Clear ();
44 }</pre></div><p>The enemies list will be <a id="id292" class="indexterm"></a>coming into play now. We add enemies to this list<a id="id293" class="indexterm"></a> as they are generated, and then, on every move cycle, the <code class="literal">GameManager</code> class will loop through the list and move each enemy. Let's take a look at how this is done in the code:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Lines 1-3</code>: First, we need to define an <code class="literal">AddEnemyToList</code> function. This will be called by the <code class="literal">Enemy</code> class when an enemy is spawned.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 5-7</code>: Next, we need to define a <code class="literal">RemoveEnemyFromList</code> function. We will call this whenever an enemy is destroyed by the player defeating it.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 9-14</code>: The newly added <code class="literal">checkValidTile</code> function will take the position of an enemy and check to see whether that position is in the dictionary of visible floor tiles.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 16-43</code>: Here, we have our definition for the <code class="literal">MoveEnemies</code> function. This function is a <a id="id294" class="indexterm"></a>coroutine and is therefore declared to have the <code class="literal">IEnumerator</code> return type.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 17</code>: We want to prevent the player from moving while the enemies are moving, so we set the flag <code class="literal">enemiesMoving</code>. We will deactivate said flag after all the enemies are done with their movement.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 18</code>: We'll wait one increment of <code class="literal">turnDelay</code> with yield return regardless of how many enemies need to move.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 21-23</code>: Next, we will run a check to make sure we have enemies in our list to move. If not, then we make the player wait one more increment of <code class="literal">turnDelay</code>. This second turn delay is to make the player wait the amount of time it would take <a id="id295" class="indexterm"></a>a single onscreen enemy to move. If you add it up, the minimum move time is 0.2 seconds, which is just an arbitrary value that looks and feels adequate during game play.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 25</code>: <code class="literal">enemiesToDestroy</code> will be a secondary list that will track the enemies that we need to remove from the game after their move is completed. Directly removing enemies from the enemies list while in a loop might result in our loop trying to access items that are no longer there. So instead, we will use a separate list to help us keep track of our destroyed enemies.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 26-35</code>: The <code class="literal">for</code> loop will cycle through all our onscreen enemies and begin by checking whether they are visible to the camera and that they are standing on a valid tile. If either of those are false, then that enemy is placed in the <code class="literal">enemiesToDestroy</code> list and the loop starts with the next iteration. Otherwise, the enemy moves a single space and waits for the normal turn delay.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 36-37</code>: After the enemy movement is complete, we reset the <code class="literal">playerTurn</code> and <code class="literal">enemiesMoving</code> flags so the player has control again.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 39-43</code>: Lastly, we loop through the <code class="literal">enemiesToDestroy</code> list and remove enemies from the enemies list. We also destroy those GameObjects. Then, we clear the <code class="literal">enemiesToDestroy</code> list just to make sure it takes up no more memory.</p></li></ul></div><p>And that should do it for our enemy and world board spawning implementation. We can give this a test simply<a id="id296" class="indexterm"></a> by playing the game. Enemies should randomly spawn in new revealed areas and attempt to move towards the player. They should also<a id="id297" class="indexterm"></a> permanently vanish if they move completely off screen or into the black outer area.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_07_04.jpg" /><div class="caption"><p>Enemies on world board</p></div></div><p>Still, no place is safe for the player. We want to also spawn enemies on the Dungeon Board that we generated in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Generating Random Dungeons</em></span>. This will pose a different challenge as the dungeon is a fixed, enclosed area. There will be no black space accessible to the enemies and it wouldn't make as much sense to delete them when they move off screen.</p></div>