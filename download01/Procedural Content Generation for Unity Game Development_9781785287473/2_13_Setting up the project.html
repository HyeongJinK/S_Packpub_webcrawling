<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>Setting up the project</h2></div></div><hr /></div><p>Let's set up our<a id="id45" class="indexterm"></a> base project. There will be two methods we will <a id="id46" class="indexterm"></a>cover in setting up this project. You can either import the provided Unity package or you can follow through the code explanations in the <span class="emphasis"><em>File Overview</em></span> section and write the code by hand. Either way, it is highly advised that you read through the code explanations to understand the structure of how the project operates.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec09"></a>Importing the base project</h3></div></div></div><p>We will import a package that will contain more assets and use them right away. However, keep in mind that we<a id="id47" class="indexterm"></a> will use all the assets eventually. All of the files are explained in the <span class="emphasis"><em>File Overview</em></span> section of this chapter:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start by opening up Unity and creating a new project. Select <span class="strong"><strong>2D</strong></span> and then <span class="strong"><strong>Create Project</strong></span>. We won't need to import any Standard Asset packages for this project.</p></li><li><p>Once in <span class="strong"><strong>Unity Editor</strong></span>, navigate to <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Import Packages</strong></span> | <span class="strong"><strong>Custom Package...</strong></span> from the top menu bar. Navigate to the directory where you saved the code files that accompany this book. In the <code class="literal">Chapter 2</code> folder, select the <code class="literal">Chapter2Assets.unitypackage</code> and open it. You will get a pop-up displaying all the assets in the package. You can click on <span class="strong"><strong>OK</strong></span> and Unity will import the package.</p></li><li><p>After the package has been imported, there might be a warning message that you can disregard for now. You now have several more folders in your <code class="literal">Assets</code> folder. Navigate to the <code class="literal">Scenes</code> folder and open the <span class="strong"><strong>Main</strong></span> scene.</p></li><li><p>You will see some game objects in your <span class="strong"><strong>Hierarchy</strong></span> panel and some text on the screen of your <span class="strong"><strong>Game</strong></span> view panel. You can now click on the play button to see a small animated character. You can move the character using the <span class="emphasis"><em>W</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>S</em></span>, and <span class="emphasis"><em>D</em></span> keys or the arrow keys.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip03"></a>Tip</h3><p>Take notice of the character's movement. The character moves the width of a tile and is on a turn-based timing system. When a key is hit, the player character will move in that direction and into the adjacent tile; they will then wait for the enemies to take a turn. There are no enemies, so the player can move the character again immediately.</p></div><div class="mediaobject"><img src="/graphics/9781785287473/graphics/4808_02_04.jpg" /><div class="caption"><p>Results of importing the package and clicking on play</p></div></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec10"></a>File overview</h3></div></div></div><p>Let's go over the files <a id="id48" class="indexterm"></a>so that we understand how the project is structured. First, your folder structure should follow this format:</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/4808_02_05.jpg" /><div class="caption"><p>Folder structure for the Roguelike project</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec11"></a>Animation</h3></div></div></div><p>In the <code class="literal">Animation</code> folder, there are<a id="id49" class="indexterm"></a> two subfolders, <code class="literal">Animations</code> and <code class="literal">AnimatorControllers</code>. The <code class="literal">Animations</code> folder contains three sprite animations that the player character <a id="id50" class="indexterm"></a>uses. The <code class="literal">AnimatorControllers</code> folder contains the animator controller that the player character uses to run its animations. These files are already integrated into the <span class="strong"><strong>Player</strong></span> prefab from the <code class="literal">Chapter 2</code> import package.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec04"></a>Fonts</h4></div></div></div><p>The <code class="literal">Fonts</code> folder <a id="id51" class="indexterm"></a>contains the font file <code class="literal">PressStart2P-Regular.ttf</code> and the Open Font License. You can disregard the license. The font is already applied to the text that is visible in our game preview.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec05"></a>Prefabs</h4></div></div></div><p>The <code class="literal">Prefabs</code> folder holds<a id="id52" class="indexterm"></a> the tile set we will use to create our game board in the next chapter. This also holds <code class="literal">GameManager</code> and <code class="literal">Player</code>, which are being used to run our base project. <span class="strong"><strong>Player</strong></span> is referenced directly on the <span class="strong"><strong>Hierarchy</strong></span> panel and the <code class="literal">GameManager</code> is referenced via a script in the Main Camera.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="strong"><strong>Player</strong></span> prefab requires the <span class="strong"><strong>BoxCollider2D</strong></span>, <span class="strong"><strong>RigidBody2D</strong></span>, and <span class="strong"><strong>SpriteRenderer</strong></span> components and the <code class="literal">Player.cs</code> script</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>GameManager</strong></span> prefab requires the <code class="literal">GameManager.cs</code> script</p></li><li style="list-style-type: disc"><p><code class="literal">Wall</code> prefabs require a <span class="strong"><strong>BoxCollider2D</strong></span> and <span class="strong"><strong>SpriteRenderer</strong></span> component and the <code class="literal">Wall.cs</code> script</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>OuterWall</strong></span> prefabs require a <span class="strong"><strong>BoxCollider2D</strong></span> and <span class="strong"><strong>SpriteRenderer</strong></span> component</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Floor</strong></span> prefabs requires a <span class="strong"><strong>SpriteRenderer</strong></span> component</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec06"></a>Scenes</h4></div></div></div><p>The <code class="literal">Scenes</code> folder holds <a id="id53" class="indexterm"></a>our main scene. This is where our base game is set up and it is where we will add all our features. The <span class="strong"><strong>Hierarchy</strong></span> panel shows what the scene holds.</p><p>The Main Camera is included in every Unity scene; this holds our <span class="strong"><strong>GameManager</strong></span> prefab. The <span class="strong"><strong>Player</strong></span> prefab holds the player character animations and functionality. The Canvas object contains a text object called <span class="strong"><strong>HealthText</strong></span>, which is the source of the in-game text currently showing. The <span class="strong"><strong>EventSystem</strong></span> object accompanies the <span class="strong"><strong>Canvas</strong></span> object by default.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec07"></a>Scripts</h4></div></div></div><p>The <code class="literal">Scripts</code> folder contains<a id="id54" class="indexterm"></a> all the scripts needed to run our base game. Some of the scripts are meant as hooks for future features. We will go over all the script files that came in the Unity package and discuss the relevant parts.</p><p>The first script is <code class="literal">BoardManager.cs</code>, as seen in <span class="emphasis"><em>Code Snip 2.1</em></span>:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System;
3 using System.Collections.Generic;
4 using Random = UnityEngine.Random;
5
6 public class BoardManager : MonoBehaviour
7 {
  [Serializable]
8  public class Count
9  {
10    public int minimum;
11    public int maximum;
12    
13    public Count (int min, int max)
14    {
15      minimum = min;
16      maximum = max;
17    }
18  }
19 }</pre></div><p>The <code class="literal">BoardManager</code> script, so far, only holds a <code class="literal">Serializable</code> public class called <code class="literal">Count</code>, which we will use to aid us in randomizing our game board tiling. We can also use this class for any type<a id="id55" class="indexterm"></a> of list randomization, such as placing items and enemies on the game board. The <code class="literal">BoardManager</code> script will be called by the <code class="literal">GameManager</code> script at the start of the game to set up the level.</p><p>Let's take a look at the code itself:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 3</code>: <code class="literal">System.Collections.Generic</code> allows us to use C# lists, which will come in handy later.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 4</code>: There are actually two random classes within Unity. One is the Unity class and the other is the .NET class. This line says that we want to use the Unity-specific <code class="literal">Random</code> method. The reason for this is the Unity <code class="literal">Random</code> method is optimized for game development.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 8</code>: The class, <code class="literal">Count</code>, is declared <code class="literal">Serializable</code> so that we can see the class's properties while in the Unity Editor.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 11-12</code>: These are the properties <code class="literal">Count</code> will keep a track of. We will use minimum and maximum as a random range.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 14-18</code>: This is the class constructor.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"></a>Note</h3><p>For more information on script <a id="id56" class="indexterm"></a>serialization <a id="id57" class="indexterm"></a>and the serializable key word, visit the Unity Documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Serializable.html" target="_blank">http://docs.unity3d.com/ScriptReference/Serializable.html</a> and <a class="ulink" href="http://docs.unity3d.com/Manual/script-Serialization.html" target="_blank">http://docs.unity3d.com/Manual/script-Serialization.html</a>.</p></div></li></ul></div><p>The <code class="literal">Loader.cs</code> script is responsible for instantiating the <code class="literal">GameManager</code> class, which runs the essential parts of our game. You can see the script in the following <span class="emphasis"><em>Code Snip 2.2</em></span>:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System.Collections;
3 
4 public class Loader : MonoBehaviour 
5 {
6   public GameObject gameManager;
7   
8   void Awake ()
9   {
10    if (GameManager.instance == null)
11      Instantiate(gameManager);
12  }
13 }</pre></div><p>Lines 8-12 are an<a id="id58" class="indexterm"></a> important part of this script. The <code class="literal">Awake</code> function simply creates a new <code class="literal">GameManager</code> if one doesn't exist already. So let's discuss the <code class="literal">GameManager.cs</code> script, which is the connection point for all the other scripts.</p><p>The <code class="literal">GameManager.cs</code> script is too large to print in the middle of the chapter, so it can be found in the <span class="emphasis"><em>Appendix</em></span> section under <span class="emphasis"><em>Code Snip 2.3</em></span>. Instead, we will overview the functions that comprise the script.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Awake()</code>: The <code class="literal">Awake</code><a id="id59" class="indexterm"></a> function establishes the <code class="literal">GameManager</code> as a singleton, it sets up an enemy list (which we will use later), and initializes the game.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note09"></a>Note</h3><p>Singletons are<a id="id60" class="indexterm"></a> programming paradigms in which only one singleton can exist during the program's runtime. This means that there is only ever one <code class="literal">GameManager</code> for every scene/level in our game.</p><p>For more<a id="id61" class="indexterm"></a> information on singletons in Unity, visit <a class="ulink" href="http://wiki.unity3d.com/index.php/Singleton" target="_blank">http://wiki.unity3d.com/index.php/Singleton</a>.</p></div></li><li style="list-style-type: disc"><p><code class="literal">OnLevelWasLoaded (int index)</code>: This<a id="id62" class="indexterm"></a> function will track our dungeons when we create them.</p></li><li style="list-style-type: disc"><p><code class="literal">InitGame()</code>: <code class="literal">InitGame</code> only clears the enemy list, which will be more useful when we <a id="id63" class="indexterm"></a>actually have enemies. This will be the function we call to initialize our main level.</p></li><li style="list-style-type: disc"><p><code class="literal">Update()</code>: The <code class="literal">Update</code> function <a id="id64" class="indexterm"></a>checks whether it is the player's turn or the enemy's turn. Since there are no enemies yet, it is always the player's turn.</p></li><li style="list-style-type: disc"><p><code class="literal">GameOver()</code>: When called, this<a id="id65" class="indexterm"></a> function will disable the <code class="literal">GameManager</code> class.</p></li><li style="list-style-type: disc"><p><code class="literal">MoveEnemies()</code>: This is <a id="id66" class="indexterm"></a>called when it is the enemy's turn to move. There are currently no enemies, so this function just creates a pause letting the player character complete its move before another one can be taken. Having this structure predefined <a id="id67" class="indexterm"></a>will make it easier to add in enemies later.</p></li></ul></div><p>Next, we will take a look at the <code class="literal">Wall.cs</code> script, which gives properties to certain tiles that can block the player's movement. You see the <code class="literal">Wall.cs</code> script in <span class="emphasis"><em>Code Snip 2.4</em></span>:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System.Collections;
3 
4 public class Wall : MonoBehaviour
5 {
6   public Sprite dmgSprite;
7   public int hp = 3;
8
9   private SpriteRenderer spriteRenderer;
10
11  void Awake ()
12  {
13    spriteRenderer = GetComponent&lt;SpriteRenderer&gt; ();
14  }
15  
16  public void DamageWall (int loss)
17  {
18    spriteRenderer.sprite = dmgSprite;
19
20    hp -= loss;
21    
22    if(hp &lt;= 0)
23      gameObject.SetActive (false);
24  }
25 }</pre></div><p>This script won't be visibly useful until we write the code that will lay out our game board. For now, the script dictates that if there is a wall, it will block the player and some walls are destructible. Let's go through <span class="emphasis"><em>Code Snip 2.4</em></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 6</code>: We will store a reference to the sprite that will show a wall has taken damage.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 7</code>: Here, we will store the number of times a wall is hit before it is destroyed.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 9-14</code>: The <code class="literal">Awake</code> function will store a reference to the <span class="strong"><strong>SpriteRenderer</strong></span> component of our <span class="strong"><strong>Wall</strong></span> prefab.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 16-24</code>: The <code class="literal">DamageWall</code> function will track the times a wall is hit, switch out sprites to show wall damage, and eventually destroy a wall that has been hit enough.</p></li></ul></div><p>The last few scripts are<a id="id68" class="indexterm"></a> related in a sense. The <code class="literal">MovingObject.cs</code> script is an abstract class, meaning it can't be applied directly to our game. Instead, the <code class="literal">Player.cs</code> and <code class="literal">Enemy.cs</code> script inherit from the <code class="literal">MovingObject</code> class. The reason for this is the <span class="strong"><strong>Player</strong></span> and <span class="strong"><strong>Enemy</strong></span> prefabs will move in a similar way, so instead of writing the movement logic twice, we write it once and have both prefabs use it.</p><p>Because the <code class="literal">MovingObject</code>.cs script holds most of the movement logic, it is a larger file. So instead of printing it here, you can view it in the <span class="emphasis"><em>Appendix</em></span> under <span class="emphasis"><em>Code Snip 2.5</em></span>. As an alternative, we will overview the code as we did with the <code class="literal">GameManager.cs</code> script:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Start()</code>: The <code class="literal">Start</code> function stores the <code class="literal">BoxCollider2D</code> and <code class="literal">RigidBody2D</code> components attached to the Wall prefab. It also stores the reciprocal of a variable called<a id="id69" class="indexterm"></a> <code class="literal">moveTime</code>, which is used to time the character's movement. We store the reciprocal here so that we can multiply the move time instead of dividing it later. Multiplication is computationally more efficient than division in most cases.</p></li><li style="list-style-type: disc"><p><code class="literal">Move(int xDir, int yDir, out RaycastHit2D hit)</code>: <code class="literal">Move</code> checks whether the player<a id="id70" class="indexterm"></a> can move in the direction they have input. The function casts a ray out from the player character in the direction input and if it hits anything, it returns <code class="literal">false</code>. The <code class="literal">RaycastHit2D</code> parameter hit, has a key word out so that it can be modified in the function and the effect is carried to outside the scope of the function.</p></li><li style="list-style-type: disc"><p><code class="literal">SmoothMovement (Vector3 end)</code>: This is a coroutine for moving units from one tile space to the next. It takes a <code class="literal">Vector3</code> parameter, <code class="literal">end</code>, to specify where to the<a id="id71" class="indexterm"></a> movement destination.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>For more information on coroutines, visit <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html" target="_blank">http://docs.unity3d.com/Manual/Coroutines.html</a>.</p></div></li><li style="list-style-type: disc"><p><code class="literal">AttemptMove&lt;T&gt;(int xDir, int yDir)</code>: <code class="literal">AttemptMove</code> is called by <code class="literal">Move</code> to check whether the<a id="id72" class="indexterm"></a> player/enemy is being blocked from moving. It takes a generic parameter <code class="literal">T</code> to specify the type of component we expect our unit to interact with if blocked. This makes the function usable for any case of blocking action. Walls block a player's movement, but so will enemies. The virtual keyword means <code class="literal">AttemptMove</code> can be overridden by inheriting classes using the override keyword.</p></li><li style="list-style-type: disc"><p><code class="literal">OnCantMove&lt;T&gt;(T component)</code>: <code class="literal">OnCantMove</code> will be called when a player/enemy <a id="id73" class="indexterm"></a>character is blocked from moving. There will be some logic here on how to handle certain blocking events. This function is abstract, which means it has no meaning in <code class="literal">MovingObjects</code>. However, any child classes will have a unique<a id="id74" class="indexterm"></a> implementation of this function.</p></li></ul></div><p>Now that we've seen the base class for our characters, let's take a look at the most important character class, the <code class="literal">Player</code> class. This script is another one that is too large to print here, so you can find it in the <span class="emphasis"><em>Appendix</em></span> section under <span class="emphasis"><em>Code Snip 2.6</em></span>. Here is an overview of the <code class="literal">Player.cs</code> script:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>First off, this class<a id="id75" class="indexterm"></a> inherits from the <code class="literal">MovingObject</code> class, not <code class="literal">MonoBehaviour</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Start()</code>: Here, we store the animator, get a reference to health points, set up the health point text, and call the <code class="literal">MovingObeject</code> base <code class="literal">Start</code> function.</p></li><li style="list-style-type: disc"><p><code class="literal">Update()</code>: The <code class="literal">Update</code> function listens for player input and calls for movement.</p></li><li style="list-style-type: disc"><p><code class="literal">AttemptMove&lt;T&gt;(int xDir, int  yDir)</code>: This is an override function whose base is in the <code class="literal">MovingObject</code> class. For now, it just calls the base <code class="literal">AttemptMove</code> function and updates the player's turn. Later, we will add into this function.</p></li><li style="list-style-type: disc"><p><code class="literal">OnCantMove&lt;T&gt;(T component)</code>: This is another override function. We check whether we hit a wall here. If we hit a destructible wall, we will attack it.</p></li><li style="list-style-type: disc"><p><code class="literal">LoseHealth(int loss)</code>: Here, we will manage our player character losing health when we add enemies.</p></li><li style="list-style-type: disc"><p><code class="literal">CheckIfGameOver()</code>: Finally, this is just a check for ending the game when our player runs out<a id="id76" class="indexterm"></a> of health. Again, this is going to be relevant when we add enemies.</p></li></ul></div><p>Last is our <code class="literal">Enemy</code> script. Like the <code class="literal">Player</code> class, this also inherits from the <code class="literal">MovingObject</code> class. It can be viewed in <span class="emphasis"><em>Code Snip 2.7</em></span>:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System.Collections;
3
4 public class Enemy : MovingObject
5 {
6   protected override bool AttemptMove &lt;T&gt; (int xDir, int yDir)
7  {
8     return true;
9  }
10
11  protected override void OnCantMove &lt;T&gt; (T component)
12  {
13  }
14 }</pre></div><p>This class holds no logic at the moment. It has the two override functions that are required for the class to exist, but they are empty. We are using this script currently to add a delay in the player's movement. We are implementing a turn-based system so we check for enemy movement and because there is none, it's the player's turn again. Having this script predefined <a id="id77" class="indexterm"></a>will save us some time later. However, since the script inherits from the <code class="literal">MoveingObject</code> class, the system requires the placeholder override function at a minimum.</p><p>So that's all there is to the base project. You can use your own art assets if you like. In fact, at the very least, you should try replacing the current art assets with your own at some point during your reading. This is good practice for learning Unity in general. Just be sure they meet the setup requirements, as explained in the <span class="emphasis"><em>Prefabs</em></span> section.</p></div></div></div>