<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec57"></a>Models</h2></div></div><hr /></div><p>3D models, as you saw in <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Generating a 3D Planet</em></span>, can be extraordinarily complicated. It is natural we created programs that allow designers to sculpt in a digital 3D space as opposed to trying to create an algorithm that would generate these 3D models. A simple sphere can take thousands of lines of code to create alone.</p><p>Allowing a person to <a id="id421" class="indexterm"></a>sculpt and see the creation of the model as it is being created allows for an unparalleled level of detail. It would simply take too long to try and procedurally generate every 3D model in a game. So, we generally stick to procedurally manipulating models.</p><p>The trade-off then is to make small pieces of a model that can be widely used and then having those procedurally constructed into a whole model at runtime. The effect is that we create a game world that is unique to that playthrough. It could be possible that the game world morphs every time the player starts a new game or just that this game world is unique to another player's game world.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_10_01.jpg" /><div class="caption"><p>Left: simple model made from modules; Right: more complex model with same modules</p></div></div><p>The method of modularizing game models has its pros and cons. Designers will design smaller pieces but might have to do just as much work, if not more, to create enough modules to fill a game. The developer also has the extra task of placing these modules correctly in the game so that they make sense to the player. The outcome of this is that we can have unique<a id="id422" class="indexterm"></a> environments for each player and we don't have to program the exact geometry of every single model. If we generate a level layout, we can then swap in the model modules at random fairly easily.</p><p>We can also apply the method of modularization to all of our 3D models including items and characters. Character generation is even simpler as most characters in a game will have a similar form. If you put the character together with modules, then you can swap them out as well. If we choose, we can take this to smaller layers of detail.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_10_02.jpg" /><div class="caption"><p>Character building modules with modules</p></div></div><p>The final piece here is that modules can have parameters of differentiation to easily make small adjustments and increase uniqueness. These parameters can be anything from color to minor model module additions to the current module or vertex movements. These parameters can further the differentiation in models and drastically increase the number of unique models in a game.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_10_03.jpg" /><div class="caption"><p>Two characters with the same modules but different parameters</p></div></div><p>Modulating models in video games opens the doors to generating unique models in every game playthrough if we wanted. We can apply it to levels, items, characters, or any 3D modeled construct. But the power is really in finding new ways to make smaller modules so that the modules<a id="id423" class="indexterm"></a> compound to make seemingly infinite possibilities. This method has the drawback of needing a lot of processing power and it might use more memory when it fully expands as compared to traditional methods.</p><p>You can pursue areas of further learning such as the field of graphics programming to gain more knowledge on PCG with 3D models. You will need a strong understanding of 3D space mathematics, which it includes but is not limited to calculus, linear algebra, and geometry. The study of computer science can usually include most of what you need to know.</p></div>