<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec38"></a>PCG with modules</h2></div></div><hr /></div><p>In software <a id="id237" class="indexterm"></a>development, we strive to make our code modular. This means that we break our code down into smaller, simpler pieces, which are sometimes called modules. The point is to create larger systems out of pieces that can be reused in as many ways as possible. If we write code in this way, we can efficiently create similar systems and also increase our flexibility.</p><p>We could apply this concept to art, as well. If we separate a piece of art into its components, we can redraw each component in many different ways. Each component is a module, and we can swap modules to make a whole new piece of art.</p><p>An example of this would be a sword. A sword is made up of three basic components of modules, such as a blade, a hilt, and a handle. We can combine any blade with any hilt and handle, if we choose to. We will put this example into practice, as this will show exactly how we implement our modular weapons.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_06_02.jpg" /><div class="caption"><p>Weapon module sprites</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec38"></a>Statistics of modular PCG</h3></div></div></div><p>Besides the fact that this <a id="id238" class="indexterm"></a>system gives us randomly unique items in our game, there is another reason that this system is desirable. We can produce a small number of modular art assets and, in return, generate a large number of whole art assets. This, in turn, can save a lot of time and resources in our asset creation process.</p><p>We can give ourselves an idea of just how many items we can generate with a few modular pieces by doing a little math. Say, for example, we have four possible modules per component of the sword. This means that there are four blades, four hilts, and four handles, which comes up to 12 modules in total. The possible number of combinations of all these modules is as follows:</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_06_03.jpg" /></div><p>Comparing 12 modules to 64 whole art assets, we can see that we have just over five times the generated art assets than we do the modules. This is a pretty good return, but it doesn't end there. If we add just one more module to each type of component, with five blades, five hilts, and five handles, we now have this combination:</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_06_04.jpg" /></div><p>By adding only three<a id="id239" class="indexterm"></a> more modules, we get over eight times the return in generated art assets. This is because we have created an exponential relation. Adding more modules will exponentially increase the number of ways in which they can be combined to generate whole art assets. This is extremely powerful as we can deliver our game with less baked-in information, making it smaller in size. Instead of creating 125 distinct art assets, we will have to only create 15 art assets. The variety that is a result of this method will keep our player interested for a longer period of time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec39"></a>Creating and configuring new sprites</h3></div></div></div><p>It is beneficial <a id="id240" class="indexterm"></a>to know exactly how the module sprite alignment works so that we <a id="id241" class="indexterm"></a>can go a little more in-depth into the subject of sprite creation than in previous chapters. As stated in the preceding examples, we are going to create a sword as our modular weapon model. We will first need to add a new sprite sheet with our weapon modules. This particular sprite sheet will need some special considerations, though.</p><p>We will be overlaying the 2D sprites on top of one another. Each module will align in such a way that does not obstruct the view of the other modules. In order to do this with no mathematical calculation, we will create each module with a bounding box of the same size. This way, each sprite will occupy the same bounding space, but we will move the actual image to align with the other modules.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>Note that this method of using identical bounding boxes is a simplification due to the animation that we will be adding. In a production grade video game, you would want to make the bounding boxes as small as possible, and use a mathematical calculation to offset the images from one another.</p></div><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_06_05.jpg" /><div class="caption"><p>Weapon modules in their respective bounding boxes</p></div></div><p>Setting the bounding <a id="id242" class="indexterm"></a>box to an appropriate size will be done in Unity, but we need to make sure that there is adequate room in the sprite sheet to do this. We have been using the metric to indicate that each of our tiles is 32 x 32 pixels. We will want to place our <a id="id243" class="indexterm"></a>modules within a tile of this size so that each module occupies the same amount of space.</p><p>We will be making four modules for each sword component, which means four blades, four hilts, and four handles. This is a total of 12 modules. We can space them out to make four 32 pixel columns by three 32 pixel rows. The exact size of this sprite sheet is 128 pixels (width) by 96 pixels (height). Even though we are using a low-resolution art form, we can still match pixels in this same way for any 2D resolution art modulation.</p><p>The sprite sheet, which is provided to you in the accompanying files of <code class="literal">Chapter 6</code>, uses a blade height of 21 pixels. In each 32 pixel block, you can align the top of the blade with the top of the canvas. Then, you will align the top of the hilt to be just under 22 pixels from the top of a different block.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_06_06.jpg" /><div class="caption"><p>Measurements of a module</p></div></div><p>Once our<a id="id244" class="indexterm"></a> sprite sheet is prepared and ready for use, we will import it into our Unity <a id="id245" class="indexterm"></a>project under the <span class="strong"><strong>Sprites</strong></span> folder, as we did earlier. Here are the steps as a reminder:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Inside the Unity Editor, navigate to the <span class="strong"><strong>Project</strong></span> tab.</p></li><li><p>Open the <span class="strong"><strong>Sprites</strong></span> folder, right-click and select <span class="strong"><strong>Import New Assetâ€¦</strong></span>.</p></li><li><p>Navigate to your modular weapon sprite sheet; the one provided is named <code class="literal">WeaponSpriteSheet.png</code>.</p></li></ol></div><p>We will now have to do some Unity-specific editing. We will be setting the sprite settings to what we were using in the previous chapters. The sprite import settings are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Set <span class="strong"><strong>Sprite Mode</strong></span> to <span class="strong"><strong>Multiple</strong></span>.</p></li><li><p>Set <span class="strong"><strong>Pixels Per Unit</strong></span> to <code class="literal">32</code>.</p></li><li><p>Set <span class="strong"><strong>Filter Mode</strong></span> to <span class="strong"><strong>Point</strong></span>.</p></li><li><p>Set <span class="strong"><strong>Max Size</strong></span> to <span class="strong"><strong>1024</strong></span>.</p></li><li><p>Set <span class="strong"><strong>Format</strong></span> to <span class="strong"><strong>Truecolor</strong></span>.</p></li><li><p>Click on the <span class="strong"><strong>Apply</strong></span> button.</p></li></ol></div><p>After you are done with the settings, we are going to slice the sprites so that they will overlap correctly. Each sprite will contain the image of its respective module and some transparent space for the other component to show through. Also, we have to consider an animation to swing the weapon. It will be beneficial to set a common pivot point for each module.</p><p>With <code class="literal">WeaponSpriteSheet.png</code> selected, click on the <span class="strong"><strong>Sprite Editor</strong></span> button in the <span class="strong"><strong>Inspector</strong></span> tab. You can try the <span class="strong"><strong>Slice</strong></span> button in the upper-left corner of the <span class="strong"><strong>Sprite Editor</strong></span> window, but some of these modules are too small for it to easily detect. Either way, you will have to make some adjustments to the bounding box.</p><p>You can click and drag a bounding box anywhere in the <span class="strong"><strong>Sprite Editor</strong></span> window. Once a bounding box is made, you can click and drag one of its corners to change its size. You will see the size of the currently selected bounding box in the lower-right corner.</p><p>You can make each<a id="id246" class="indexterm"></a> bounding box only the width of the module, but the height must be 32 <a id="id247" class="indexterm"></a>pixels. If you start with the top row, you can drag the boxes that are 32 pixels in height and are aligned with the top of the <span class="strong"><strong>Sprite Editor</strong></span> window. Then, you can move on to the second row and draw similar boxes that align with the bottom of the top row. You can do the same for the third row.</p><p>We will also set the pivot point to be the same for each module so that it can rotate for our animation at the same point. The pivot point is the center circle of each box and can be dragged and dropped anywhere. We want it at the very bottom of every bounding box.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_06_07.jpg" /><div class="caption"><p>Pivot points for each type of module</p></div></div><p>When you are done, you<a id="id248" class="indexterm"></a> can click on <span class="strong"><strong>Accept</strong></span> in the upper-right corner of the Sprite Editor. The<a id="id249" class="indexterm"></a> <code class="literal">WeaponSpriteSheet.png</code> file should now have an arrow on it, showing that you can expand it to see the separated modules. We are now ready to make our Weapon prefab.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec40"></a>Creating a multiple image prefab</h3></div></div></div><p>Unity GameObjects can<a id="id250" class="indexterm"></a> only hold one Sprite Renderer component at a time. This Sprite Renderer can only render one sprite at a time. So, the easiest way to achieve our goal is to make multiple GameObjects, each with their own Sprite Renderer. We can then place all the module GameObjects under a parent GameObject for easy reference.</p><p>A more optimal solution would be to have the module sprites redrawn as a single sprite and then passed to a single Sprite Renderer in a single GameObject. GameObjects are rather large structures, and too many of them can impact performance. For now, our solution will work fine, but perhaps, you can return to this issue later and find a way to compress everything into a single GameObject.</p><p>We will start making our Weapon prefab with an empty GameObject with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new empty GameObject.</p></li><li><p>Name the GameObject <code class="literal">Weapon</code>.</p></li><li><p>Add a tag to the GameObject called <code class="literal">Weapon</code> as well.</p></li><li><p>Put the <span class="strong"><strong>Weapon</strong></span> object in the <span class="strong"><strong>Units</strong></span> layer.</p></li><li><p>Add a <span class="strong"><strong>Box Collider 2D</strong></span> component.</p></li><li><p>In <span class="strong"><strong>Box Collider 2D</strong></span>, check <span class="strong"><strong>Is Trigger</strong></span>.</p></li><li><p>Create another empty GameObject.</p></li><li><p>Name the new empty GameObject <code class="literal">WeaponComponents1</code>.</p></li><li><p>Put the <span class="strong"><strong>WeaponComponents1</strong></span> object in the <span class="strong"><strong>Units</strong></span> layer.</p></li><li><p>Add a <span class="strong"><strong>Sprite Renderer</strong></span> component.</p></li><li><p>Put <span class="strong"><strong>Sorting Layer</strong></span> of the <span class="strong"><strong>Sprite Renderer</strong></span> component to the <span class="strong"><strong>Units</strong></span> layer.</p></li><li><p>Drag and drop<a id="id251" class="indexterm"></a> the <span class="strong"><strong>WeaponComponents1</strong></span> object into the <span class="strong"><strong>Weapon</strong></span> object to make it a child of the <span class="strong"><strong>Weapon</strong></span> object.</p></li><li><p>You can then duplicate the <span class="strong"><strong>WeaponComponents1</strong></span> object twice, and name them <code class="literal">WeaponComponents2</code> and <code class="literal">WeaponComponents3</code>.</p></li></ol></div><p>At this point, we have done all that we can for the creation of the prefab. We need to add some scripts now that will configure the modular weapon behind the scenes, much like we did with the random items in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Randomized Items</em></span>. So, let's take a look at the weapon and weapon component scripts.</p></div></div>