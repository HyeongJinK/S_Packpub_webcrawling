<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec48"></a>Fighting the enemy</h2></div></div><hr /></div><p>For this feature, we will need to modify the way the player interacts with his environment one last time. We initially implemented the player <code class="literal">Update</code> function to interact with only wall tiles. We then needed the player to interact with chest tiles so we forced our <code class="literal">AttemptMove</code> function<a id="id310" class="indexterm"></a> to take a wall type on the world board and a chest type on the Dungeon Board. We have yet another tile type that the player can interact with.</p><p>We will need to devise a new system that will extract the type of tile the player is interacting with and call <code class="literal">AttemptMove</code> correctly. This won't be too difficult though. The changes we need to make will take place in the <code class="literal">Player.cs</code> script, so open that up for editing. Then, take a<a id="id311" class="indexterm"></a> look at <span class="emphasis"><em>Code Snip 7.8</em></span> to see what has changed:</p><div class="informalexample"><pre class="programlisting">1 private void Update () {
2   if(!GameManager.instance.playersTurn) return;
3   int horizontal = 0;
4   int vertical = 0;
5   bool canMove = false;
6   horizontal = (int) (Input.GetAxisRaw ("Horizontal"));
7   vertical = (int) (Input.GetAxisRaw ("Vertical"));
8    
9   if(horizontal != 0) {
10    vertical = 0;
11  }
12    
13  if(horizontal != 0 || vertical != 0) {
14    if (!dungeonTransition) {
15      Vector2 start = transform.position;
16      Vector2 end = start + new Vector2 (horizontal, vertical);
17      base.boxCollider.enabled = false;
18      RaycastHit2D hit = Physics2D.Linecast (start, end, base.blockingLayer);
19      base.boxCollider.enabled = true;
20      if (hit.transform != null) {
21        switch(hit.transform.gameObject.tag) {
22        case "Wall":
23          canMove = AttemptMove&lt;Wall&gt; (horizontal, vertical);
24          break;
25        case "Chest":
26          canMove = AttemptMove&lt;Chest&gt; (horizontal, vertical);
27          break;
28        case "Enemy":
29          canMove = AttemptMove&lt;Enemy&gt; (horizontal, vertical);
30          break;
31        }
32      } else {
33        canMove = AttemptMove&lt;Wall&gt; (horizontal, vertical);
34      }
...
35
36 protected override void OnCantMove &lt;T&gt; (T component) {
37   if (typeof(T) == typeof(Wall)) {
38     Wall blockingObj = component as Wall;
39     blockingObj.DamageWall (wallDamage);
40   }
41   else if (typeof(T) == typeof(Chest)) {
42    Chest blockingObj = component as Chest;
43    blockingObj.Open ();
44   }
45   else if (typeof(T) == typeof(Enemy)) {
46     Enemy blockingObj = component as Enemy;
47     blockingObj.DamageEnemy (wallDamage);
48   }
49    
50  animator.SetTrigger ("playerChop");
51    
52  if (weapon) {
53    weapon.useWeapon ();
54  }
55 }</pre></div><p>We first handle when we call <code class="literal">AttemptMove</code> in the <code class="literal">Update</code> function. We need to be able to figure out which tile is<a id="id312" class="indexterm"></a> blocking us and whether we can attack it. Then, we update the <code class="literal">OnCantMove</code> function and add what happens when we hit an enemy. Let's take a look at the details:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Lines 1-34</code>: This is our <code class="literal">update</code> function though it is only partial.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 15-31</code>: Here is the new functionality we need to call <code class="literal">AttemptMove</code> correctly.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 15-19</code>: This is a redundant implementation that mimics what happens in the <code class="literal">MovingObject</code> class. We need to know what is in front of the player at this point so that we can give <code class="literal">AttempMove</code> the correct tile type. If there is an object in front of the player, <code class="literal">RaycastHit2D</code> will return it into hit.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 20-31</code>: If there is an object in hit, we want to enter a switch that will look at the tag of the object and make the corresponding <code class="literal">AttemptMove</code> call.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 45-48</code>: Lastly, inside the <code class="literal">OnCantMove</code> function, we add a condition that when the player hits an enemy, we cause damage to that enemy.</p></li></ul></div><p>Finally, we have added the enemy component to the game. In PCG fashion, the enemies randomly spawn and the player can flee or fight them. Now is a good time for you to take a play test. Try getting as far as you can and remember that if your health drops to 0, the game will end.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_07_06.jpg" /><div class="caption"><p>Attacking an enemy</p></div></div><p>We are not done yet. We want to use PCG to shift the difficulty of the game. We can easily make the enemies that are generated hit harder and take more damage, but that won't change how the <a id="id313" class="indexterm"></a>player plays the game. It would be more interesting for the player if we were able to create a new environment to adapt to.</p></div>