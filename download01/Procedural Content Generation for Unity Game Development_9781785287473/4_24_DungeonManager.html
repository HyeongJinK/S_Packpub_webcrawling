<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec27"></a>DungeonManager</h2></div></div><hr /></div><p>Our dungeon generator class will be called <code class="literal">DungeonManager</code>. The class will create the data the dungeon is<a id="id180" class="indexterm"></a> made of and pass it to the <code class="literal">BoardManager</code> class to be built on screen. First, we need to create the C# script. Go to the <code class="literal">Scripts</code> folder and create a new C# script called <code class="literal">DungeonManager.cs</code>.</p><p><code class="literal">DungeonManager</code> is a fairly large class, so we will view it in sections. Open up the <code class="literal">DungeonManager</code> for editing. You can see the first section of <code class="literal">DungeonManager</code> in <span class="emphasis"><em>Code Snip 4.1</em></span>:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System;
3 using System.Collections.Generic;
4 using Random = UnityEngine.Random;
5
6 public enum TileType {
7   essential, random, empty
8 }
9
10 public class DungeonManager : MonoBehaviour {</pre></div><p>We are going to need a list, a dictionary, and some PRNs for our <code class="literal">Dungeon</code> class. <code class="literal">Lines 2-4</code> will enable these things for our use. <code class="literal">Lines 6-8</code> introduces a global enumeration that we will use to keep track of our path types. Then, <code class="literal">Line 10</code> leads us into the <code class="literal">DungeonManager</code> definition, starting with a helper class called <code class="literal">PathTile</code> that can be seen in <span class="emphasis"><em>Code Snip 4.2</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"></a>Note</h3><p>Enumerations are a great way to keep track of states. Our<a id="id181" class="indexterm"></a> <code class="literal">PathTile</code> class can take on a few different states (essential and random) and can possibly take on more states in the future. Given the nature that a <code class="literal">PathTile</code> class can only be one state at a time, enumerations work like a state ID. The enumeration is really just a number relation, such as <code class="literal">essential = 1</code> and <code class="literal">random = 2</code>. The enumeration is more descriptive though, so if we had 100 states we could assign names to the states rather than having to look up each state's ID number. For more information on<a id="id182" class="indexterm"></a> enumerations, check out <a class="ulink" href="https://unity3d.com/learn/tutorials/modules/beginner/scripting/enumerations" target="_blank">https://unity3d.com/learn/tutorials/modules/beginner/scripting/enumerations</a>.</p></div><div class="informalexample"><pre class="programlisting">11 [Serializable]
12 public class PathTile {
13   public TileType type;
14   public Vector2 position;
15   public List&lt;Vector2&gt; adjacentPathTiles;
16
17   public PathTile (TileType t, Vector2 p, int min, int max, Dictionary&lt;Vector2, TileType&gt; currentTiles) {
18     type = t;
19     position = p;
20    adjacentPathTiles = getAdjacentPath(min, max, currentTiles);
21  }
22
23  public List&lt;Vector2&gt; getAdjacentPath(int minBound, int maxBound, Dictionary&lt;Vector2, TileType&gt; currentTiles) {
24    List&lt;Vector2&gt; pathTiles = new List&lt;Vector2&gt; ();
25    if (position.y + 1 &lt; maxBound &amp;&amp; !currentTiles.ContainsKey(new Vector2(position.x, position.y + 1))) {
26      pathTiles.Add(new Vector2(position.x, position.y + 1));
27    }
28    if (position.x + 1 &lt; maxBound &amp;&amp; !currentTiles.ContainsKey(new Vector2(position.x + 1, position.y))) {
29      pathTiles.Add(new Vector2(position.x + 1, position.y));
30    }
31    if (position.y - 1 &gt; minBound &amp;&amp; !currentTiles.ContainsKey(new Vector2(position.x, position.y - 1))) {
32      pathTiles.Add(new Vector2(position.x, position.y - 1));
33    }
34    if (position.x - 1 &gt;= minBound &amp;&amp; !currentTiles.ContainsKey(new Vector2(position.x - 1, position.y)) &amp;&amp; type != TileType.essential) {
35      pathTiles.Add(new Vector2(position.x - 1, position.y));
36    }
37    return pathTiles;
38  }
39 }</pre></div><p>The <code class="literal">PathTile</code> class is going to make the rest of the <code class="literal">DungeonManager</code> implementation much easier. Each <code class="literal">PathTile</code> will calculate and keep track of the tiles that are adjacent to that tile. They will <a id="id183" class="indexterm"></a>also hold their own position and their type, which could be <code class="literal">E</code> for essential or <code class="literal">R</code> for random. Let's take a closer look at the <code class="literal">PathTile</code> class in <span class="emphasis"><em>Code Snip 4.2</em></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 13</code>: <code class="literal">type</code> will hold a <code class="literal">TileType</code> enum value, which will refer to the type of tile as <code class="literal">TileType.essential</code>, <code class="literal">TileType.random</code>, or <code class="literal">TileType.empty</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 14</code>: This is the position of the tile as <code class="literal">Vector2</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 15</code>: <code class="literal">adjacentPathTiles</code> is the list that we will use to store the tiles next to the current <code class="literal">PathTile</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 17-21</code>: This is the <code class="literal">PathTile</code> constructor. We will call this to make a new <code class="literal">PathTile</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 23</code>: <code class="literal">getAdjacentPath</code> is the function that will calculate which tiles are adjacent to this tile based on the Dungeon Board dimensions and current tiles that have been laid out. We call <code class="literal">getAdjacentPath</code> in the constructor of the <code class="literal">PathTile</code> class and it requires the minimum and maximum bound of the grid, as well as the<a id="id184" class="indexterm"></a> current tile list of all the tiles current laid.</p></li></ul></div><p><code class="literal">GetAdjacentPath</code> uses four <code class="literal">if</code> statements to check adjacent tiles to the top, right, bottom, and left of the current <code class="literal">PathTile</code>. The conditional statements are based on whether the adjacent tile is within the grid dimensions and if the tile is already part of the dungeon tile list. The last <code class="literal">if</code> condition on <code class="literal">Line 31</code> checks the type for <code class="literal">TileType.essential</code> because we don't want essential <code class="literal">PathTiles</code> to move left (backwards), we want to force them right (forwards).</p><p>So, that is our helper class that is going to make the rest of the <code class="literal">DungeonManager</code> class simpler to implement. We are ready to develop the rest of the <code class="literal">DungeonManager</code> definition. <span class="emphasis"><em>Code Snip 4.3</em></span> continues the <code class="literal">DungeonManager</code> class:</p><div class="informalexample"><pre class="programlisting">40 public Dictionary&lt;Vector2, TileType&gt; gridPositions = new Dictionary&lt;Vector2, TileType&gt; ();
41
42  public int minBound = 0, maxBound;
43
44  public static Vector2 startPos;
45
46  public Vector2 endPos;
47
48  public void StartDungeon () {
49    gridPositions.Clear ();
50    maxBound = Random.Range (50, 101);
51
52    BuildEssentialPath ();
53
54    BuildRandomPath ();
55  }</pre></div><p><span class="emphasis"><em>Code Snip 4.3</em></span> shows the setup of the dungeon in the <code class="literal">DungeonManager</code> class. We declare all our variables in the first few lines, then use a driver function to generate separate parts of the dungeon. Let's take a look at the specifics from <span class="emphasis"><em>Code Snip 4.3</em></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 40</code>: <code class="literal">gridPositions</code> is the dictionary we are using to store the structure of the generated dungeon. This dictionary is similar to the one we used in the <code class="literal">BoardManager</code> class except our value is now <code class="literal">TileType</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 42</code>: <code class="literal">minBound</code> and <code class="literal">maxBound</code> are the dimensions of our board grid. <code class="literal">minBound</code> is always <code class="literal">0</code>, but we set it up as a variable just in case we decide to change it later. <code class="literal">maxBound</code> is not initialized here because it will be randomly initialized later.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 44</code>: <code class="literal">startPos</code> is the entrance position of our dungeon. We are making it public static because<a id="id185" class="indexterm"></a> it needs to be accessed by the <code class="literal">Player</code> class. The <code class="literal">Player</code> class will use the position data to move the player character to <code class="literal">startPos</code>, while the world board is being changed out for the dungeon board.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 48-55</code>: <code class="literal">StartDungeon</code> is our driver function for our dungeon generator. In the function, we clear our dictionary because we will use the generator multiple times in a game. We then randomly choose the dimensions of the board grid. Our grid is a square so we only need to choose one number and it will represent the length of all four sides. A dungeon larger than 200 by 200 starts to add a significant amount of load time mostly due to the fact that we are generating so many outer wall tiles. Lastly, we call the functions that will build the dungeon's essential and random paths.</p></li></ul></div><p>Now, we need to develop the logic behind building the actual dungeon. The first function involved is <code class="literal">BuildEssentialPath</code>. Within this function, we are going to use a little bit of randomness and a little bit of direction to create a path that spans our grid from left to right. The left-most point will be our entrance and the right most point will be our exit. <span class="emphasis"><em>Code Snip 4.4</em></span> shows the function:</p><div class="informalexample"><pre class="programlisting">56 private void BuildEssentialPath () {
57  int randomY = Random.Range (0, maxBound + 1);
58  PathTile ePath = new PathTile (TileType.essential, new Vector2 (0, randomY), minBound, maxBound, gridPositions);
59  startPos = ePath.position;
60
61  int boundTracker = 0;
62
63  while (boundTracker &lt; maxBound) {
64    gridPositions.Add (ePath.position, TileType.empty);
65    int adjacentTileCount = ePath.adjacentPathTiles.Count;
66    int randomIndex = Random.Range (0, adjacentTileCount);
67    Vector2 nextEPathPos;
68    if (adjacentTileCount &gt; 0) {
69      nextEPathPos = ePath.adjacentPathTiles[randomIndex];
70    } else {
71      break;
72    }
73  PathTile nextEPath = new PathTile (TileType.essential, nextEPathPos, minBound, maxBound, gridPositions);
74    if (nextEPath.position.x &gt; ePath.position.x || (nextEPath.position.x == maxBound - 1 &amp;&amp; Random.Range (0,2) == 1)) { 
75      ++boundTracker;
76    }
77    ePath = nextEPath;
78  }
79
80  if (!gridPositions.ContainsKey (ePath.position))
81    gridPositions.Add (ePath.position, TileType.empty);
82
83  endPos = new Vector2 (ePath.position.x, ePath.position.y);
84 }</pre></div><p><code class="literal">BuildEssentialPath</code> is going to run a loop that can potentially loop through every space in our grid. It is unlikely this will happen but we need to be aware of it. This means that in a worst-case scenario, a 100 x 100 dungeon can cause a loop to process 10,000 spaces, which is why any dungeon over 200 x 200 begins to load significantly more slowly. An important part of algorithm design is understanding what can happen in the worst case to gauge<a id="id186" class="indexterm"></a> an average speed of execution.</p><p>It is very unlikely that we will see this worst case because our dungeon can take so many other forms. So let's take a look at the first step of our dungeon generator. We will go through <span class="emphasis"><em>Code Snip 4.4</em></span> to see how we generate an essential path:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 57</code>: Here, we choose a random <span class="emphasis"><em>y</em></span> coordinate for our entrance. We will always start our entrance on the extreme left, which is <code class="literal">minBound</code>. In this case, <code class="literal">minBound</code> is always <code class="literal">0</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 58</code>: <code class="literal">ePath</code> is a container for our current <code class="literal">PathTile</code>. We will store the current essential <code class="literal">PathTile</code> here and add it to our Dungeon Board after we decide which adjacent tile to follow. Initially, we will set it to our entrance location.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 59</code>: We need to set <code class="literal">startPos</code> to the entrance position so we can inform the <code class="literal">Player</code> class where to move the player character.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 61</code>: We will use a local integer variable to track how far along the grid length we are. Every time the essential path moves right, we will add <code class="literal">1</code> to <code class="literal">boundTracker</code> till <code class="literal">boundTracker</code> equals <code class="literal">maxBound</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 63-84</code>: This <code class="literal">while</code> loop will loop through tile spaces in our grid. It will end when our essential path has reached the right side of our grid.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 64</code>: The first thing we do is add the current <code class="literal">PathTile</code> to our dictionary. Remember, the first <code class="literal">PathTile</code> is the entrance.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 65</code>: Here, we find out how many tiles are adjacent to the current tile.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 66</code>: From the adjacent tile, we randomly choose one to follow.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 68-72</code>: This is our first check. We need to make sure that there are adjacent tiles before we continue. If there are no adjacent tiles and we reference an empty index, we will cause an error. However, we can assume that if there are no adjacent tiles, then we have hit the end of the grid and can break the loop early.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 73</code>: If there are adjacent tiles, we store them as the next essential <code class="literal">PathTile</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 74-76</code>: This check will determine whether or not the essential path has moved right. If it has, then we need to update the <code class="literal">boundTracker</code> to reflect that.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 77</code>: At this point, we <a id="id187" class="indexterm"></a>have made all the checks we need to use the current essential <code class="literal">PathTile</code> and the adjacent essential <code class="literal">PathTile</code>. We can set the adjacent tile to the current so that in the next iteration of the loop, it will be added to the list the process repeats.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 78-83</code>: Finally, once the loop has completed all its iterations, we add a check to see if the final essential <code class="literal">PathTile</code> was added to the dungeon dictionary. Remember that the loop could have broken early so we may have not added that last tile. Then, we set the last tile to the exit position, <code class="literal">endPos</code>.</p></li></ul></div><p>So, just like in our algorithm design, our essential path builds out one tile at a time as it follows a random path that can only move in the directions up, down, and right. The essential path should be fairly winding, but it will be narrow as well. What's more, the path only moves in one direction, which is not very interesting. So we will introduce some random branches from the essential path.</p><p>The <code class="literal">BuildRandomPath</code> function, which is called just after the <code class="literal">BuildEssentialPath</code> function, will add onto the essential path in two ways. First, it will go through the essential <code class="literal">PathTiles</code> and see if there is an open adjacent tile that can branch off into an alternate path. Then, it might choose to build an opening called a chamber at the end of that path. <span class="emphasis"><em>Code Snip 4.5</em></span> shows the implementation of <code class="literal">BuildRandomPath</code>:</p><div class="informalexample"><pre class="programlisting">85 private void BuildRandomPath () {
86  List&lt;PathTile&gt; pathQueue = new List&lt;PathTile&gt; ();
87  foreach (KeyValuePair&lt;Vector2,TileType&gt; tile in gridPositions) {
88    Vector2 tilePos = new Vector2(tile.Key.x, tile.Key.y);
89    pathQueue.Add(new PathTile(TileType.random, tilePos, minBound, maxBound, gridPositions));
90  }
91
92  pathQueue.ForEach (delegate (PathTile tile) {
93
94    int adjacentTileCount = tile.adjacentPathTiles.Count;
95    if (adjacentTileCount != 0) {
96      if (Random.Range(0, 5) == 1) {
97        BuildRandomChamber (tile);
98      }
99      else if (Random.Range (0, 5) == 1 || (tile.type == TileType.random &amp;&amp; adjacentTileCount &gt; 1)) {
100        int randomIndex = Random.Range (0, adjacentTileCount);
101
102        Vector2 newRPathPos = tile.adjacentPathTiles[randomIndex];
103
104        if (!gridPositions.ContainsKey(newRPathPos)) {
105          gridPositions.Add (newRPathPos, TileType.empty);
106
107          PathTile newRPath = new PathTile (TileType.random, newRPathPos, minBound, maxBound, gridPositions);
108          pathQueue.Add (newRPath);
109        }
110      }
111    }
112  });
113 }</pre></div><p><code class="literal">BuildRandomPath</code> will introduce<a id="id188" class="indexterm"></a> the use of the queue we discussed in our algorithm design earlier in this chapter. This queue will be used to take a copy of the essential path so that we can iterate over it. As we iterate over the queue and process the items, we will add new random <code class="literal">PathTiles</code> to the end of the queue. Once the queue is empty, our dungeon is complete. So let's take a look at how <code class="literal">BuildRandomPath</code> works:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 86</code>: We are going to use a list as our queue because it is easy to add to the end and remove from the front of the list.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 87-89</code>: Using a <code class="literal">foreach</code> loop, we copy the essential path to the <code class="literal">pathQueue</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 92-113</code>: Now, we use a <code class="literal">foreach</code> loop on our queue and start processing <code class="literal">PathTiles</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 94-95</code>: We need to check if the current tile has any adjacent tiles.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 96-98</code>: This check creates a 1 in 5 chance that the tile will become a chamber. We have a separate function that will build chambers.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 99</code>: Random paths generate randomly, meaning, there is a chance they won't generate at all. This check creates another 1 in 5 chance that a path will generate from an essential <code class="literal">PathTile</code>. However, if the current tile is a random <code class="literal">PathTile</code> and it has more than one direction to move, it will continue to develop. This just makes the random paths a little more wild.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 102-108</code>: If a random <code class="literal">PathTile</code> is to be placed, we check to make sure it isn't already part of the dungeon. We then add the new random <code class="literal">PathTile</code> to <code class="literal">gridPositions</code> and to the end of the queue. Eventually, the queue will come to this newly added <code class="literal">PathTile</code> and process it as well.</p></li></ul></div><p>Eventually, probability or the size restriction of our grid will make it so that no new random <code class="literal">PathTiles</code> are added to the queue. Once the queue runs out of tiles to process the function terminates. We are left with a dictionary full of tile positions. But before that, we have to see how the <a id="id189" class="indexterm"></a>
<code class="literal">BuildRandomChamber</code> function works in <span class="emphasis"><em>Code Snip 4.6</em></span>:</p><div class="informalexample"><pre class="programlisting">114 private void BuildRandomChamber (PathTile tile) {
115  int chamberSize = 3,
116    adjacentTileCount = tile.adjacentPathTiles.Count,
117    randomIndex = Random.Range (0, adjacentTileCount);
118  Vector2 chamberOrigin = tile.adjacentPathTiles[randomIndex];
119
120  for (int x = (int) chamberOrigin.x; x &lt; chamberOrigin.x + chamberSize; x++) {
121    for (int y = (int) chamberOrigin.y; y &lt; chamberOrigin.y + chamberSize; y++) {
122      Vector2 chamberTilePos = new Vector2 (x, y);
123      if (!gridPositions.ContainsKey(chamberTilePos) &amp;&amp; chamberTilePos.x &lt; maxBound &amp;&amp; chamberTilePos.x &gt; 0 &amp;&amp; chamberTilePos.y &lt; maxBound &amp;&amp; chamberTilePos.y &gt; 0)
124
125        gridPositions.Add (chamberTilePos, TileType.empty);
126    }
127  }
127 }</pre></div><p>The <code class="literal">BuildRandomChamber</code> function is called in the <code class="literal">BuildRandomPath</code> function. This function is much like the type of PCG dungeon generation in which you connect some number of predefined level assets. In this case, we add a 3 x 3 chamber to the end of a random path. We could have made that 3 x 3 chamber a prefab, which would have been less code but more storage the game would need more storage. Instead, we generate it at runtime. Let's see how in <span class="emphasis"><em>Code Snip 4.6</em></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 114-118</code>: We pass in the current <code class="literal">PathTile</code> that we are processing from the queue. We set the size of the chamber to <code class="literal">3</code> but this can easily be randomized. Next, we randomly choose an adjacent tile and set that as the origin of the chamber.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 120-130</code>: Knowing the origin point and size of the chamber, we can loop through the tiles we need to add. This is very similar to the line of sight algorithm we used to reveal the world board in the previous chapter. At the end, we add the new tiles to the dictionary.</p></li></ul></div><p>At this point, all of our<a id="id190" class="indexterm"></a> dungeon coordinates have been generated and stored. We need to actually lay the floor and wall tiles now so that the player can see the dungeon onscreen and interact with it. We are going to use the <code class="literal">BoardManager</code> class for this.</p></div>