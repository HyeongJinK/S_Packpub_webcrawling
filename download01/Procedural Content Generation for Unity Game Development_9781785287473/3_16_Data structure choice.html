<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec20"></a>Data structure choice</h2></div></div><hr /></div><p>The first PCG algorithm we will develop will create the game environment that our player will explore. We <a id="id78" class="indexterm"></a>are going to build a game world that never ends; that is, as long as you have enough memory. As the player explores the world, our algorithm will create and place more pieces of the Game Board.</p><p>Remember, the Game Board is what we are calling the ground area in which the player will walk on. The Game Board is made up of small, rectangular, 2D sprites that we refer to as <span class="strong"><strong>tiles</strong></span>. In<a id="id79" class="indexterm"></a> this chapter, we will start with floor tiles, which the player will walk on. We will then randomly add wall tiles to a new layer as an obstacle to the player.</p><p>The concept of the 2D Game Board can be visualized as a grid. A grid can be easily implemented as an array or list data structure to track the tiles we layout for the Game Board. As the player explores, we will add to our list references to our newly created tiles. We can then use this list to look up any tile on our Game Board. The most important role of the tile list is<a id="id80" class="indexterm"></a> such that we don't recreate a tile that is already on the Game Board. This process is usually<a id="id81" class="indexterm"></a> referred to as <span class="strong"><strong>object pooling</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808-03-02.jpg" /><div class="caption"><p>Imagine the Game Board within a grid</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec12"></a>Array</h3></div></div></div><p>Because we are creating a large part of the Game Board while the player is playing the game, we need a data <a id="id82" class="indexterm"></a>structure in which we can add tiles too dynamically. A <a id="id83" class="indexterm"></a>two-dimensional array is visualized as a grid, which makes adding tile coordinates more natural. We name an index of a two-dimensional array like this: <code class="literal">myArray[X][Y]</code>. <code class="literal">X</code> and <code class="literal">Y</code> will be the 2D <span class="emphasis"><em>x</em></span> axis and <span class="emphasis"><em>y</em></span> axis coordinates.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p><span class="emphasis"><em>Dynamic</em></span> is another <a id="id84" class="indexterm"></a>computer science term. We refer to things as <span class="emphasis"><em>static</em></span> or <span class="emphasis"><em>dynamic</em></span>. Static refers to <a id="id85" class="indexterm"></a>something that has a hard-coded value such as: <code class="literal">const int num = 2;</code>. Dynamic refers to a value that is determined at runtime and might change over the life of the program such as: <code class="literal">int num = someFunction();</code>.</p></div><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808-03-03.jpg" /><div class="caption"><p>Visualization of a 2D array</p></div></div><p>Arrays are <a id="id86" class="indexterm"></a>great for fast lookup, which will be important as our Game Board expands. Arrays reserve a portion of memory and assign a call number called<a id="id87" class="indexterm"></a> an index to every block of memory in the array. This gives the array a fixed size guaranteeing that we won't run into memory problems when generating the world. Also, looking up any index in an array is nearly instant.</p><p>The main issue with using a two-dimensional array is that we have to predefine the size. This means that as soon as the game starts, we will reserve a large chunk of memory for our game that we might not use. It is even worse if we end up filling the array before the game is over, as then we have to make a new larger array, transfer all the information to the new array, and deallocate all the memory of the old array.</p><p>The larger array<a id="id88" class="indexterm"></a> then faces the same two problems as described previously. This method also means having to spend extra development time to write the logic<a id="id89" class="indexterm"></a> that would perform the array rewrite task. Our game might then start to slow down as our memory expands and contracts to make new arrays and delete old ones. This will still be a viable option, but perhaps with a little more careful development work.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec13"></a>Linked list</h3></div></div></div><p>The 2D array has the<a id="id90" class="indexterm"></a> important feature of fast look up but the implementation <a id="id91" class="indexterm"></a>would be inefficient and it also runs the risk of creating too much overhead. So another option would be a list, which is a form of linked list. The list doesn't need to reserve a chunk of memory because each entry in the list holds a link reference to the entry before it and after it in the list. This means that list entries can be stored anywhere in the memory, which eliminates the need to reserve any memory on startup.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808-03-04.jpg" /><div class="caption"><p>Visualization of a linked list</p></div></div><p>The list solves the<a id="id92" class="indexterm"></a> problem of having to create a new array when you run out of space. We can easily and continuously add to a list dynamically, as well. However, the fast look up will suffer slightly with lists and therefore cause the performance of the game to suffer. When an array is created, the structure of it is like a chart where each entry is adjacent to the next and the system can scan very quickly to a specified index. Lists, on the other hand, have entries littered throughout the memory so the system has to<a id="id93" class="indexterm"></a> start at the first entry and follow each entry to the specified index.</p><p>One more caveat of a list is that we wouldn't be able to reference an index that we hadn't already filled with a tile. In our 2D array example, all of the indices of the array are predefined and can be referenced, even though they are empty. List entries don't have place holders like this. If we reference a list entry that doesn't exist, the system will throw an exception and most likely freeze the game if we aren't prepared for it. We would have to predefine all the entries in the list to circumvent this issue, which means a list is little better than an array at this point.</p><p>So now we are at the crossroads of choosing the lesser of two evils. In one hand, we have the array that needs some overhead maintenance to add tiles dynamically. On the other hand, we have a list that can be dynamically added to, but we are forced into a similar overhead to<a id="id94" class="indexterm"></a> maintain our free flowing grid structure. Our ideal data <a id="id95" class="indexterm"></a>structure can have dynamic entry additions with a fast lookup, but with none of the costs associated with arrays and lists. Again, this is a perfectly viable option, but perhaps there's another that will suit our needs better.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec14"></a>Dictionary</h3></div></div></div><p>The compromise<a id="id96" class="indexterm"></a> is something called a <span class="strong"><strong>Dictionary</strong></span> in C#, which is a form of an associative array. An associative array is just a modified array to use some other data type like a string as the index instead of a non-negative number. The <a id="id97" class="indexterm"></a>dictionary uses a key-value pair to store data and it can be dynamically added to and removed from. However, keep in mind that the dictionary will continue to take up as much memory as its maximum size. The dictionary key-value pair would look something like this:</p><div class="informalexample"><pre class="programlisting">Dictionary myInventory (string key, int value);
myInventory.Add("Gold", 10);
myInventory["Gold"];</pre></div><p>The C# dictionary is a class that wraps an array. This class will notice when the internal array is about to become full and will perform the task of rewriting our data into a larger array automatically. The dictionary also has a fast lookup speed. Having an associative array as our data structure also benefits us by only needing to create a one-dimensional array instead of a two-dimensional array as in the previous examples.</p><p>Because the dictionary takes a key-value pair, we can make our key a Vector2 with our X and Y coordinates of each placed tile. This way, when we want to know whether a specific tile has been placed already, we can look up the X and Y coordinates directly. The <code class="literal">Dictionary</code> class has a method called <code class="literal">Contains()</code> making lookups as easy as <code class="literal">myInventory.Contains("Gold");</code>. This will give us a <code class="literal">true</code>/<code class="literal">false</code> value that we can check in an <code class="literal">ifâ€¦else</code> or a <code class="literal">switch</code> statement.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808-03-05.jpg" /><div class="caption"><p>Visualization of a dictionary/map</p></div></div><p>Here is a summary <a id="id98" class="indexterm"></a>of our data structure choice:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Array</strong></span>: This is a <a id="id99" class="indexterm"></a>simple data structure with fast lookup but it is difficult to add tiles dynamically.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>List</strong></span>: This is <a id="id100" class="indexterm"></a>a linked list, which can have tiles added dynamically, but will have slower lookup as  the list gets bigger.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Dictionary</strong></span>: This is an<a id="id101" class="indexterm"></a> associative array class with built-in array resizing and a fast lookup.</p><p>Even though the dictionary has a little more overhead with it's extra class methods, it will be the most efficient data structure for our use. It is also really easy to use.</p></li></ul></div></div></div>