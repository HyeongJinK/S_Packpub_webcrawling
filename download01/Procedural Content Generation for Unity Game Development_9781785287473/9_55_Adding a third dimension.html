<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec53"></a>Adding a third dimension</h2></div></div><hr /></div><p>Unity makes 2D<a id="id377" class="indexterm"></a> game development very easy. Don't forget that underneath Unity's user interface, there are a lot of calculations being done for us. In many other graphics rendering engines, we would have to write the code that creates the 2D square that we can then draw our sprite on. With Unity, we simply add a component or two. In the following figure, we can see a 2D sprite from a 3D perspective. A sprite is after all just a quad that is rendered facing the camera.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_09_02.jpg" /><div class="caption"><p>The 2D quad a sprite is drawn onto</p></div></div><p>Unity also makes 3D game <a id="id378" class="indexterm"></a>development much easier. Instead of using quads for sprite rendering, in 3D, we will work from 3D models. A 3D model is a collection of vertices, or points, in 3D space. We then connect those dots and make faces or triangles. This comprises the wireframe structure and surface of our model.</p><p>For most games, a 3D model is created by a 3D modeling program or software and then imported into Unity. We will then assign appropriate components to the imported model. We can then easily manipulate the 3D models with physics and animation. This is convenient because it can be very difficult and time consuming trying to program an algorithm to create a complex 3D model.</p><p>This is exactly what we are going to do though. We are going to bypass the modeling phase and write a script that creates a model for us. We want to do this to introduce that random factor. However, as stated before, this can get very time consuming and complex. There are a few things that change drastically when applying PCG to 3D as opposed to 2D.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec48"></a>3D versus 2D</h3></div></div></div><p>Because 3D objects can become very complex very quickly, we need to keep two things in mind when we <a id="id379" class="indexterm"></a>write our algorithms: time and space. We need to be aware that certain tasks can take a long time because there is a lot for the computer to process and some tasks can take a lot of space in terms of memory. In computer science, this is the <a id="id380" class="indexterm"></a>study of <span class="strong"><strong>time complexity</strong></span> and <span class="strong"><strong>space complexity</strong></span>.</p><p>We need to<a id="id381" class="indexterm"></a> understand that creating and managing 3D objects can take a long time because there are a lot of pieces to a 3D object. We need to calculate the position of every point and draw every triangle between those points. This ultimately means longer load times and/or some slowing during gameplay.</p><p>Space management also becomes a concern when generating 3D objects. The more complex an object is, the more memory it will need to use in its calculations. Information on every point, triangle, and more needs to be stored somewhere when generating 3D objects. The more 3D objects that are being drawn onscreen, the more memory will be consumed and possibly slow down the gameplay.</p><p>Fortunately, graphics programming is a field that is widely researched and developed. There are plenty of references online alone that can aid in generating a wide range of 3D objects. The 3D primitives (cubes, cylinders, spheres, polygons, and so on) all have an equation that has been made into an efficient algorithm already. We just need to keep in mind that there are usually several ways to make a shape and some might suit our needs better than others.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec49"></a>Know your geometry</h3></div></div></div><p>In this chapter, we will be <a id="id382" class="indexterm"></a>working with spheres. Spheres in particular can be represented by quite a few 3D primitives and other polygons. The Unity primitive sphere is actually a cube that has had its vertices interpolated and edges slightly moved to make more of a curve. You can see the corners of the cube in the sphere wireframe:</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_09_03.jpg" /><div class="caption"><p>3D cube made into a sphere</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec50"></a>Working with the Unity primitive sphere</h3></div></div></div><p>There aren't too many uses for the Unity 3D primitive shapes. Their primary use will be in prototypes as a<a id="id383" class="indexterm"></a> placeholder. Usually, anything that is used in a game has been designed and modeled to a specification. With that said, we are going to start with a Unity primitive just to see how it works and why we might want to use something else instead.</p><p>The Unity primitive<a id="id384" class="indexterm"></a> sphere has a certain property that makes it a little difficult to manipulate. The triangles that make up the sphere are all distinct and separate. Each triangle has its own vertices and where triangles meet, there is a cluster of separate vertices. When we start moving theses vertices, we will split the seams of the model and open it up. Usually, meshes only render on one side of a 3D model. So meshes that open up will appear transparent at the back of the triangles. The effect can be seen in the following figure:</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_09_04.jpg" /><div class="caption"><p>Sphere triangles splitting when moved</p></div></div><p>To solve this, we will have to add some extra functionality to group the vertices. So, when one vertex moves, all of the vertices in the same position will move to the same new location. Let's try out writing a script to randomize the vertices while not distorting the mesh so much<a id="id385" class="indexterm"></a> that it renders improperly.</p><p>Be sure to set <a id="id386" class="indexterm"></a>up a new project with a fresh scene in 3D mode. Create a new C# script called <code class="literal">MoveVertices</code> and open it up for editing. <span class="emphasis"><em>Code Snip 9.1</em></span> shows the script:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System;
3 using System.Collections.Generic;
4 using Random = UnityEngine.Random;
5
6 public class MoveVertices : MonoBehaviour {
7 
8    Mesh mesh;
9    Vector3[] vertices;
10
11    void Start () {
12        mesh = GetComponent&lt;MeshFilter&gt;().mesh;
13        vertices = mesh.vertices;
14
15        mesh.vertices = Randomize(vertices);
16    }
17
18    Vector3[] Randomize(Vector3[] verts) {
19        Dictionary&lt;Vector3, List&lt;int&gt;&gt; dictionary = new Dictionary&lt;Vector3, List&lt;int&gt;&gt;();
20
21        for (int x = 0; x &lt; verts.Length; x++) {
22            if (!dictionary.ContainsKey(verts[x])) {
23                dictionary.Add(verts[x], new List&lt;int&gt;());
24            }
25
26            dictionary[verts[x]].Add(x);
27        }
28
29        foreach (KeyValuePair&lt;Vector3, List&lt;int&gt;&gt; pair in dictionary) {
30          Vector3 newPos = pair.Key * Random.Range(0.9f, 1.1f);
31            foreach (int i in pair.Value) {
32                verts[i] = newPos;
33            }
34        }
35
36        return verts;
37    }
38 }</pre></div><p>After writing the script, you <a id="id387" class="indexterm"></a>can make a sphere primitive in the editor by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Sphere</strong></span> from the menu. You can then attach this script to the object and run it to see its effects. The randomization of the vertices makes a sort of bumpiness or terrain on the sphere. Now, let's see<a id="id388" class="indexterm"></a> what is happening in the code:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Lines 1-4</code>: These are our general using statements. We use <code class="literal">Generic</code> for the dictionary class and set <code class="literal">Random</code> to <code class="literal">Unity.Random</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 8-9</code>: We will be working with two members, the sphere's Mesh component and the set of vertices that make up that mesh.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 11-16</code>: In the <code class="literal">Start</code> function, we will set a reference to the <code class="literal">Mesh</code> component, grab the array of vertices from that mesh, and call the <code class="literal">Randomize</code> function.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 18-19</code>: The <code class="literal">Randomize</code> function takes an array of <code class="literal">Vector3</code> objects. We are going to set up a dictionary to store the location of a vertex as a key and map that to a list of vertices that share the same location.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 21-27</code>: We want to loop through all the vertices and add their location to our dictionary. If the vertex location hasn't been added yet, then we add it; if it has, then we add that vertex to the list of vertices at that location.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 29-34</code>: Once <a id="id389" class="indexterm"></a>we have our dictionary of grouped vertices, we will loop through each vertex position. For each vertex position, we want to choose a new random location, loop through every vertex in the current location, and change it to the new location.</p></li></ul></div><p>Now, our sphere has a<a id="id390" class="indexterm"></a> bumpy structure to it. You can vary the size of the sphere and the randomization range for different results. Try experimenting with this script and see what you come up with.</p><p>The main issue with using the Unity primitive is that you don't get to choose the natural size and how many vertices you want in the mesh. So the better option is to generate our own sphere. However, we have to be aware that this might slow down our system. As with our <code class="literal">MoveVertices</code> script, we looped through a large set of vertices several times. The number of vertices and loop passes all add up against performance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec51"></a>Generating a sphere</h3></div></div></div><p>As stated before, generating<a id="id391" class="indexterm"></a> a sphere entails plotting points based on an equation. The equation is geometry-based and made into an algorithm to plot the vertices. Teaching the bases of graphics programming would be a book in itself. Thus, the explanation of the math will be brief.</p><p>There happens to be<a id="id392" class="indexterm"></a> quite a few ways to make a sphere. We can take a simple 3D shape and interpolate or multiply the vertices in a structured fashion, smoothing as we go. There are a lot of algorithms available online and each might make slightly different kinds of spheres.</p><p>The algorithm we are going to use can be<a id="id393" class="indexterm"></a> found at the Unity Wiki page, <a class="ulink" href="http://wiki.unity3d.com/index.php/ProceduralPrimitives" target="_blank">http://wiki.unity3d.com/index.php/ProceduralPrimitives</a>. There are also other 3D primitives on this page that you can generate. The sphere we are going to generate is a polar sphere, which is the common sphere that is generated. So, now create a new C# script called <code class="literal">ProceduralSphere.cs</code> and open it up for editing. <span class="emphasis"><em>Code Snip 9.2</em></span> shows the script:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System.Collections;
3 using System.Collections.Generic;
4 using Random = UnityEngine.Random;
5 
6 public class ProceduralSphere : MonoBehaviour {
7 
8    private Mesh mesh;
9    private MeshFilter filter;
10
11    void Start () {
12        GenerateSphere(0.5f, 16, 16);
13    }
14
15    private void GenerateSphere (float radius, int nbLong, int nbLat) {
16        filter = gameObject.AddComponent&lt;MeshFilter&gt;();
17        mesh = filter.mesh;
18        mesh.Clear();
19
20        #region Vertices
21        Vector3[] vertices = new Vector3[(nbLong + 1) * nbLat + 2];
22        float _pi = Mathf.PI;
23        float _2pi = _pi * 2f;
24
25        vertices[0] = Vector3.up * radius;
26        for (int lat = 0; lat &lt; nbLat; lat++)
27        {
28            float a1 = _pi * (float)(lat + 1) / (nbLat + 1);
29            float sin1 = Mathf.Sin(a1);
30            float cos1 = Mathf.Cos(a1);
31
32            for (int lon = 0; lon &lt;= nbLong; lon++)
33            {
34                float a2 = _2pi * (float)(lon == nbLong ? 0 : lon) / nbLong;
35                float sin2 = Mathf.Sin(a2);
36                float cos2 = Mathf.Cos(a2);
37
38                vertices[lon + lat * (nbLong + 1) + 1] = new Vector3(sin1 * cos2, cos1, sin1 * sin2) * radius;
39            }
40        }
41        vertices[vertices.Length - 1] = Vector3.up * -radius;
42        #endregion
43
44        #region Normals
45        Vector3[] normales = new Vector3[vertices.Length];
46        for (int n = 0; n &lt; vertices.Length; n++)
47            normales[n] = vertices[n].normalized;
48        #endregion
49
50        #region UVs
51        Vector2[] uvs = new Vector2[vertices.Length];
52        uvs[0] = Vector2.up;
53        uvs[uvs.Length - 1] = Vector2.zero;
54        for (int lat = 0; lat &lt; nbLat; lat++)
55            for (int lon = 0; lon &lt;= nbLong; lon++)
56                uvs[lon + lat * (nbLong + 1) + 1] = new Vector2((float)lon / nbLong, 1f - (float)(lat + 1) / (nbLat + 1));
57        #endregion
58
59        #region Triangles
60        int nbFaces = vertices.Length;
61        int nbTriangles = nbFaces * 2;
62        int nbIndexes = nbTriangles * 3;
63        int[] triangles = new int[nbIndexes];
64
65        //Top Cap
66        int i = 0;
67        for (int lon = 0; lon &lt; nbLong; lon++)
68        {
69            triangles[i++] = lon + 2;
70            triangles[i++] = lon + 1;
71            triangles[i++] = 0;
72        }
73
74        //Middle
75        for (int lat = 0; lat &lt; nbLat - 1; lat++)
76        {
77            for (int lon = 0; lon &lt; nbLong; lon++)
78            {
79                int current = lon + lat * (nbLong + 1) + 1;
80                int next = current + nbLong + 1;
81
82                triangles[i++] = current;
83                triangles[i++] = current + 1;
84                triangles[i++] = next + 1;
85
86                triangles[i++] = current;
87                triangles[i++] = next + 1;
88                triangles[i++] = next;
89            }
90        }
91
92        //Bottom Cap
93        for (int lon = 0; lon &lt; nbLong; lon++)
94        {
95            triangles[i++] = vertices.Length - 1;
96            triangles[i++] = vertices.Length - (lon + 2) - 1;
97            triangles[i++] = vertices.Length - (lon + 1) - 1;
98        }
99        #endregion
100
101        mesh.vertices = vertices;
102        mesh.normals = normales;
103        mesh.uv = uvs;
104        mesh.triangles = triangles;
105
106        mesh.RecalculateBounds();
107        mesh.Optimize();
108    }
109 }</pre></div><p>As you can see, there is a lot that goes into generating a seemingly simple sphere. Luckily, we didn't have to write this algorithm from scratch. Primitive shapes are pretty well defined and can <a id="id394" class="indexterm"></a>usually be found documented somewhere else. For more complex meshes, though, you will need to engineer them yourself.</p><p>In the beginning of <span class="emphasis"><em>Code Snip 9.2</em></span>, we set <code class="literal">Mesh</code> and <code class="literal">Mesh Filter</code>. The <code class="literal">Mesh</code> object is what gets rendered, but we use <code class="literal">Mesh Filter</code> for general mesh manipulation. In the <code class="literal">Start</code> function, we make a<a id="id395" class="indexterm"></a> call to our <code class="literal">GenerateSphere</code> function passing in a radius and latitude and longitude lines:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Lines 15-18</code>: In the <code class="literal">GenerateSphere</code> function, we add the <code class="literal">MeshFilter</code> component and clear the new <code class="literal">MeshFilter</code> to make sure it is ready to go.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 20-42</code>: This script is broken up into regions so that it is a little more readable. In the <code class="literal">Vertices</code> region, we plot the points that we will then create triangles out of. The algorithm creates an array of <code class="literal">Vector3</code> positions that represent the vertices. The vertices are calculated on a curved grid using the longitude and latitude lines. The curvature is calculated using sine and cosine, which are trigonometric functions for calculating angles.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 44-48</code>: In the <code class="literal">Normals</code> region, we calculate the normal of each vertex. There is a Unity built-in function for this, called <code class="literal">normalized</code>. The normal of a vertex is the direction the vertex is facing.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 50-57</code>: The <code class="literal">UVs</code> region sets the mapping for texture wrapping. Textures use a set of coordinates to wrap the texture around a 3D object.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 59-99</code>: The <code class="literal">Triangles</code> region creates the list of triangles that the object will render. The triangles will be the face of our object. Each triangle is rendered with the given material using its set of three vertex positions. This algorithm creates a triangle in three parts: top, middle, and bottom.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 101-104</code>: At the end of the calculations, we assign the pieces from <code class="literal">Mesh Filter</code> to <code class="literal">Mesh</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 106-107</code>: Lastly, we <a id="id396" class="indexterm"></a>call two <code class="literal">Mesh</code> methods to finish our generated sphere. <code class="literal">RecalculateBounds</code> will make sure the volume of the new mesh is correctly calculated and optimize will attempt to<a id="id397" class="indexterm"></a> make the object render faster to the screen. You'll need to add a <code class="literal">Mesh Renderer</code> and a component to the <code class="literal">Material</code> on the object. Also, be sure the object is in view of the camera if you don't see anything appear. You can also inspect the sphere in the <span class="strong"><strong>Scene</strong></span> view while in the play mode. Now, if you create an empty GameObject, add this script and play the scene. You should see a sphere:</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_09_05.jpg" /><div class="caption"><p>Procedurally generated sphere</p></div></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec52"></a>Adding randomization</h3></div></div></div><p>Now we are going to<a id="id398" class="indexterm"></a> add the same randomization to this sphere as we did the Unity primitive sphere. We just need to add our <code class="literal">Randomize</code> function <a id="id399" class="indexterm"></a>at the end of the <code class="literal">ProceduralSphere.cs</code> script. <span class="emphasis"><em>Code Snip 9.3</em></span> shows what that looks like:</p><div class="informalexample"><pre class="programlisting">1  private void GenerateSphere (float radius, int nbLong, int nbLat) {
2        
...
3 
4        mesh.vertices = vertices;
5        mesh.normals = normales;
6        mesh.uv = uvs;
7        mesh.triangles = triangles;
8
9        mesh.RecalculateBounds();
10       mesh.Optimize();
11
12       mesh.vertices = Randomize(vertices);
13    }
14
15    private Vector3[] Randomize(Vector3[] verts) {
16        Dictionary&lt;Vector3, List&lt;int&gt;&gt; dictionary = new Dictionary&lt;Vector3, List&lt;int&gt;&gt;();
17
18        for (int x = 0; x &lt; verts.Length; x++) {
19
20            if (!dictionary.ContainsKey(verts[x])) {
21                dictionary.Add(verts[x], new List&lt;int&gt;());
22            }
23            dictionary[verts[x]].Add(x);
24        }
25
26        foreach (KeyValuePair&lt;Vector3, List&lt;int&gt;&gt; pair in dictionary) {
27            Vector3 newPos = pair.Key * Random.Range(0.9f, 1.1f);
28            foreach (int i in pair.Value) {
29
30                verts[i] = newPos;
31            }
32        }
33        
34        return verts;
35    }</pre></div><p>The update to the <code class="literal">ProceduralSphere</code> script simply adds the <code class="literal">Randomize</code> function to the end of the file and calls it at the end of the <code class="literal">GenerateSphere</code> function. This will have a very similar effect on its looks<a id="id400" class="indexterm"></a> as the Unity primitive sphere. However, since we are procedurally generating<a id="id401" class="indexterm"></a> the sphere, we are always one bad function call away from straining our system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec53"></a>Bad time and space complexities</h3></div></div></div><p>Imagine if we needed to<a id="id402" class="indexterm"></a> perform a task on each vertex after we moved only one. This would cause us to loop over the whole set of vertices multiple times. This would be more costly in time than<a id="id403" class="indexterm"></a> even just generating a more complex sphere. The performance of our game is ultimately hurt with scripts like this.</p><p>As a demonstration of a bad time complexity, we will update our code slightly to simulate having to perform extra tasks on each vertex move.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip04"></a>Tip</h3><p>Save your scene and <a id="id404" class="indexterm"></a>project before running this<a id="id405" class="indexterm"></a> script, as it might crash Unity!</p></div><p><span class="emphasis"><em>Code Snip 9.4</em></span> shows the update for the demo:</p><div class="informalexample"><pre class="programlisting">1    void Start () {
2        GenerateSphere(1f, 10, 10);
3    }
4
...
5    
6     private Vector3[] Randomize(Vector3[] verts) {
7        Dictionary&lt;Vector3, List&lt;int&gt;&gt; dictionary = new Dictionary&lt;Vector3, List&lt;int&gt;&gt;();
8
9        for (int x = 0; x &lt; verts.Length; x++) {
10
11            if (!dictionary.ContainsKey(verts[x])) {
12                dictionary.Add(verts[x], new List&lt;int&gt;());
13            }
14            dictionary[verts[x]].Add(x);
15        }
16
17        foreach (KeyValuePair&lt;Vector3, List&lt;int&gt;&gt; pair in dictionary) {
18            Vector3 newPos = pair.Key * Random.Range(0.9f, 1.1f);
19            foreach (int i in pair.Value) {
20
21                verts[i] = newPos;
22                for (int j = 0; j &lt; mesh.vertexCount; j++) {
23                    Debug.Log("loading...");
24                }
25            }
26        }
27        
28        return verts;
29    }</pre></div><p>We are going to lessen the number of longitude and latitude sections in the sphere as this script is very heavy in processing. Then, we will add <code class="literal">lines 22-24</code>. This is a loop through the set of vertices that make up the sphere. We make a <code class="literal">Debug.Log</code> call as some work to perform.</p><p>If you run this, you <a id="id406" class="indexterm"></a>should notice your computer take 30 seconds to 1 minute processing before rendering the sphere to your screen. If you don't notice any time delay, then you have a very good computer. You can increase the longitude and latitude lines but do this in increments of 1.</p><p>The <code class="literal">Debug.Log</code> call actually<a id="id407" class="indexterm"></a> takes quite a bit of time to complete as there is more work involved than you might think. This example is thus an exaggeration but should still be considered. We have exponentially increased the amount of time it will take to render the sphere because of our extra loop. Be aware of this time complexity moving forward.</p><p>This sort of thing can happen with <span class="emphasis"><em>space</em></span> as well. When we say <span class="emphasis"><em>space</em></span>, we mean the memory your computer can store at a time. To see an example of bad space complexity, we simply need to increase the sphere complexity to an unmanageable level.</p><p>Start by removing the loop from <span class="emphasis"><em>Code Snip 9.4</em></span> on lines <code class="literal">22-24</code>. Then, increase the longitude and latitude arguments in the <code class="literal">GenerateSphere</code> call on <code class="literal">line 2</code> to over 300. If you run this updated code, you will get an error saying you have exceeded the maximum number of vertices.</p><p>These are good things to be aware of when working with 3D. As you can see, you can easily add some code that will either slow your system tremendously or break it outright. Good programmers always consider time and space complexities to keep performance as high as possible.</p></div></div>