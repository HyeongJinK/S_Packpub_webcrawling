<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec41"></a>Adding a weapon pick up</h2></div></div><hr /></div><p>Now, we can<a id="id259" class="indexterm"></a> move on to adding the logic that will run the player pickup of the weapon object. This will be very similar to the other player pickups except that the weapon will need a few special considerations. For one, the weapon will need to be in the same screen location as the player at all times so that it can animate appropriately.</p><p>Let's begin by opening up the <code class="literal">Player.cs</code> script where the current player pickup logic exists. We are going to add a few new variables that will hold references to our weapon and some of the images that we will use to make the display icon. As stated earlier, we will create a display icon on the screen that will show the weapon that the player has in their inventory. Add the following lines to the beginning of the <code class="literal">Player</code> class definition:</p><div class="informalexample"><pre class="programlisting">1 private Weapon weapon;
2 public Image weaponComp1, weaponComp2, weaponComp3;</pre></div><p>We will then edit the <code class="literal">OnTriggerEnter2D</code> function. We need to add a condition that will allow us to handle against colliding with a weapon object. The updated function can be seen in <span class="emphasis"><em>Code Snip 6.5</em></span>:</p><div class="informalexample"><pre class="programlisting">1 private void OnTriggerEnter2D (Collider2D other) {
2  if (other.tag == "Exit") {
3    dungeonTransition = true;
4    Invoke ("GoDungeonPortal", 0.5f);
5    Destroy (other.gameObject);
6  } else if (other.tag == "Food" || other.tag == "Soda") {
7    UpdateHealth(other);
8    Destroy (other.gameObject);
9  } else if (other.tag == "Item") {
10   UpdateInventory(other);
11    Destroy (other.gameObject);
12  } else if (other.tag == "Weapon") {
13    if (weapon) {
14      Destroy(transform.GetChild(0).gameObject);
15    }
16    other.enabled = false;
17    other.transform.parent = transform;
18    weapon = other.GetComponent&lt;Weapon&gt;();
19    weapon.AcquireWeapon();
20    weapon.inPlayerInventory = true;
21    weapon.enableSpriteRender(false);
22    wallDamage = attackMod + 3;
23    weaponComp1.sprite = weapon.getComponentImage(0);
24    weaponComp2.sprite = weapon.getComponentImage(1);
25    weaponComp3.sprite = weapon.getComponentImage(2);
26      
27  }
28 }</pre></div><p>We aren't adding the<a id="id260" class="indexterm"></a> weapon object to our inventory map so that we can manipulate it more easily. We can simply change the colors of an existing object, like we did with the items of the previous chapter. Instead, we need to keep track of whether we have a weapon or not before we add another to our player. Let's take a look at what we have developed in <span class="emphasis"><em>Code Snip 6.5</em></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 12</code>: This line starts the conditional statement that checks whether we have collided with a weapon.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 13-15</code>: We need to check whether we already have a weapon and destroy it if we do. The weapon will get added to the player as a child. The new weapon only overwrites the weapon reference, not the entire GameObject. If we don't remove it, we will end up adding a bunch of objects to the scene that are not used and will potentially slow our game.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 16</code>: We want to disable BoxCollider2D of the spawned weapon so that we don't trigger it again. Remember that the weapon will share the same coordinates as the player.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 17</code>: Here, we make the player the parent of the weapon that we just collided with.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 18</code>: We <a id="id261" class="indexterm"></a>need to store a reference to the <code class="literal">Weapon</code> script.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 19-21</code>: We will also call all of the functions that initialize the weapon as part of the player inventory. The <code class="literal">AcquireWeapon</code> and <code class="literal">enableSpriteRender</code> functions haven't been implemented yet, but we will be getting to them shortly.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 22</code>: Adding in <code class="literal">attackMod</code> that's brought in by items, we finally get to update the damage done by the player.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 23-25</code>: Lastly, we are going to update the <code class="literal">Image</code> variables so that we can use them for the display icon.</p></li></ul></div><p>Before we leave the <code class="literal">Player</code> class, we should also update the <code class="literal">UpdateInventory</code> function. Add the following conditional statement at the end of the function definition:</p><div class="informalexample"><pre class="programlisting">1 if (weapon)
2   wallDamage = attackMod + 3;</pre></div><p>This additional code will make it so the damage done by the player is recalculated to reflect the newly acquired items and/or weapon.</p><p>We can return to the Unity Editor now and check that things are working as we expect them to. Play the game and find a sword spawned from a chest. We couldn't interact with the weapon before, but now we can. Unfortunately, the weapon never hides from view and the display icon is a blank white.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_06_11.jpg" /><div class="caption"><p>The weapon is unhidden and follows the player, while there is a blank image to the right</p></div></div><p>We will have to <a id="id262" class="indexterm"></a>head back to our <code class="literal">Weapon</code> class definition and start filling out the hook functions that we created. The first of these will be the <code class="literal">AcquireWeapon</code> function, which is used to initialize the connection between the <code class="literal">Player</code>, <code class="literal">Weapon</code>, and <code class="literal">WeaponComponents</code> classes. We can see the function implementation in <span class="emphasis"><em>Code Snip 6.6</em></span>:</p><div class="informalexample"><pre class="programlisting">1 public void AquireWeapon () {
2   player = GetComponentInParent&lt;Player&gt; ();
3   weaponsComps = GetComponentsInChildren&lt;WeaponComponents&gt; ();
4 }</pre></div><p><code class="literal">Line 2</code> grabs a reference to the <code class="literal">Player</code> script that the <code class="literal">Weapon</code> class is attached to. <code class="literal">Line 3</code> grabs an array of the <code class="literal">WeaponComponents</code> scripts that are attached to the <code class="literal">Weapon</code> class. And now the three classes can communicate with each other.</p><p>Next is the <code class="literal">enableSpriteRender</code> function. This function will enable or disable the Sprite Renderers of the <code class="literal">WeaponComponents</code> class. We can see the function implementation in <span class="emphasis"><em>Code Snip 6.7</em></span>:</p><div class="informalexample"><pre class="programlisting">1 public void enableSpriteRender (bool isEnabled) {
2   foreach (WeaponComponents comp in weaponsComps) {
3     comp.getSpriteRenderer ().enabled = isEnabled;
4   }
5 }</pre></div><p>We pass a <code class="literal">bool</code> argument that will represent whether we want to enable or disable the Sprite Renderer. <code class="literal">isEnabled</code> should be <code class="literal">true</code> to enable the Sprite Renderer and <code class="literal">false</code> otherwise. The function uses a loop to call the <code class="literal">getSpriteRenderer</code> function from each weapon component and sets the returned Sprite Renderer to the value of <code class="literal">isEnabled</code>.</p><p>Lastly, we will use the <code class="literal">getComponentImage</code> function to return a reference to the weapon component's module sprite. This sprite will then be used by the <code class="literal">Player</code> class to construct the display icon that will tell us which weapon we are using. The function just needs the <code class="literal">return null;</code> line to be replaced with the following:</p><div class="informalexample"><pre class="programlisting">return weaponsComps[index].getSpriteRenderer().sprite;</pre></div><p>With this piece<a id="id263" class="indexterm"></a> of code, you can save your changes and head back to the Unity Editor. We have completed the spawn and pick up phase of the weapon implementation. You can test it by finding a sword in a chest and walking over it. The sword should disappear from the chest and reappear in the lower-right corner of the screen as part of the UI:</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_06_12.jpg" /><div class="caption"><p>The sword is hidden and the icon to the right appears</p></div></div><p>After you've checked to see that the weapon pick up is successful, you can find a wall to hit. The wall will sustain more damage and be destroyed quicker, but it is only implied that the sword is causing this effect. It would be more immersive if we could see the sword swing as the<a id="id264" class="indexterm"></a> player character swipes at the wall.</p></div>