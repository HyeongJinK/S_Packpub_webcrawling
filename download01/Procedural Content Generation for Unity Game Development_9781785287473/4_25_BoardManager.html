<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec28"></a>BoardManager</h2></div></div><hr /></div><p>The <code class="literal">BoardManager</code> class already keeps references to the floor and wall tiles. Rather than having our <code class="literal">DungeonManager</code> class<a id="id191" class="indexterm"></a> keep the same references, we will send our dungeon dictionary to the <code class="literal">BoardManager</code> class and have it build the Dungeon Board. We will need to update our <code class="literal">BoardManager</code> class for this. Open up <code class="literal">BoardManager.cs</code> for editing and make the changes seen in <span class="emphasis"><em>Code Snip 4.7</em></span>:</p><div class="informalexample"><pre class="programlisting">29 <span class="strong"><strong>public GameObject exit;</strong></span>
…
33 <span class="strong"><strong>public GameObject[] outerWallTiles;</strong></span>
… 
40 <span class="strong"><strong>private Transform dungeonBoardHolder;</strong></span>
<span class="strong"><strong>41 private Dictionary&lt;Vector2, Vector2&gt; dungeonGridPositions;</strong></span>
…
69 private void addTiles(Vector2 tileToAdd) {
70    if (!gridPositions.ContainsKey (tileToAdd)) {
71      gridPositions.Add (tileToAdd, tileToAdd);
72      GameObject toInstantiate = floorTiles [Random.Range (0, floorTiles.Length)];
73      GameObject instance = Instantiate (toInstantiate, new Vector3 (tileToAdd.x, tileToAdd.y, 0f), Quaternion.identity) as GameObject;
74      instance.transform.SetParent (boardHolder);
75      
76      if (Random.Range (0, 3) == 1) {
77        toInstantiate = wallTiles[Random.Range (0,wallTiles.Length)];
78        instance = Instantiate (toInstantiate, new Vector3 (tileToAdd.x, tileToAdd.y, 0f), Quaternion.identity) as GameObject;
79        instance.transform.SetParent (boardHolder);
80      }
81
82      if (Random.Range (0, 100) == 1) {
83        toInstantiate = exit;
84        instance = Instantiate (toInstantiate, new Vector3 (tileToAdd.x, tileToAdd.y, 0f), Quaternion.identity) as GameObject;
85        instance.transform.SetParent (boardHolder);
86      }
87    }
88  }
…
141 public void SetDungeonBoard (Dictionary&lt;Vector2,TileType&gt; dungeonTiles, int bound, Vector2 endPos) {
142    boardHolder.gameObject.SetActive (false);
143    dungeonBoardHolder = new GameObject ("Dungeon").transform;
144    GameObject toInstantiate, instance;
145 
146    foreach(KeyValuePair&lt;Vector2,TileType&gt; tile in dungeonTiles) {
147      toInstantiate = floorTiles [Random.Range (0, floorTiles.Length)];
148      instance = Instantiate (toInstantiate, new Vector3 (tile.Key.x, tile.Key.y, 0f), Quaternion.identity) as GameObject;
149      instance.transform.SetParent (dungeonBoardHolder);
150    }
151
152    for (int x = -1; x &lt; bound + 1; x++) {
153      for (int y = -1; y &lt; bound + 1; y++) {
154        if (!dungeonTiles.ContainsKey(new Vector2(x, y))) {
155          toInstantiate = outerWallTiels [Random.Range (0, outerWallTiles.Length)];
156          instance = Instantiate (toInstantiate, new Vector3 (x, y, 0f), Quaternion.identity) as GameObject;
157          instance.transform.SetParent (dungeonBoardHolder);
158        }
159      }
160    }
161
162    toInstantiate = exit;
163    instance = Instantiate (toInstantiate, new Vector3 (endPos.x, endPos.y, 0f), Quaternion.identity) as GameObject;
164    instance.transform.SetParent (dungeonBoardHolder);
165  }
166
167  public void SetWorldBoard () {
168    Destroy (dungeonBoardHolder.gameObject);
169    boardHolder.gameObject.SetActive (true);
170  }</pre></div><p>Keep in mind that the printed line number of <span class="emphasis"><em>Code Snip 4.7</em></span> might not match perfectly with the code in your <code class="literal">BoardManager.cs</code> file. They should be close though. We will go over the relative position<a id="id192" class="indexterm"></a> of the code in <span class="emphasis"><em>Code Snip 4.7</em></span> as part of the following explanation:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 29</code>: <code class="literal">exit</code> is the the exit tile sprite that we are using as our dungeon entrance and exit marker. This should be placed near the other tile references.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 33</code>: <code class="literal">outerWallTiles</code> are the impassable wall tiles we will use to enclose our dungeon. This line should be placed somewhere near the other tile references.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 40-41</code>: We are going to use a separate transform and dictionary for the dungeon. This will prevent any cross over between the world board and the Dungeon Board as they will exist in the same scene. These lines should be placed near the world board transform and dictionary.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 69-88</code>: The <code class="literal">addTiles</code> function was already declared, but we will be adding <code class="literal">Lines 82-86</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 82-86</code>: This small addition creates a probability that for every 1 in 100 tiles that are revealed on the world board, there will be an exit tile spawned. This exit tile would then act as an entrance to a randomly generated dungeon. You can change how frequently the exit tiles spawn by changing the <code class="literal">Random.Range</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 141-165</code>: The function <code class="literal">SetDungeonBoard</code> is a new addition to our <code class="literal">BoardManager</code> class. This function will take the dungeon data and apply the on screen graphics.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 142</code>: Instead of changing the scene, we will set the world board as inactive so that it is removed from the screen. Then, our Dungeon Board will be active and shown instead.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 143-149</code>: The dungeon coordinates are passed in as an argument. We can use a <code class="literal">foreach</code> loop to iterate over them and place the corresponding sprites.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 152-160</code>: This nested <code class="literal">for</code> loop will traverse the perimeter of the dungeon and place a layer of outer wall tiles to enclose the dungeon. We will also fill in the empty space of the grid in this nested <code class="literal">for</code> loop with more outer wall tiles.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 162-164</code>: Lastly, for the <code class="literal">SetDungeonBoard</code> function, we place the exit tiles on the <code class="literal">endPos</code> of our dungeon data.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 167-170</code>: After exiting a dungeon, we want to reactivate the world board. We do that in these lines while destroying the old Dungeon Board so that it doesn't continue to take up space on our system.</p></li></ul></div><p>So with these few updates to the <code class="literal">BoardManager</code> class, we were able to build and show an entered dungeon, set an <a id="id193" class="indexterm"></a>entrance to the dungeon from the world board, and reactivate the world board by exiting the Dungeon Board. The <code class="literal">Player</code> class is going to need some updates as well. We are now placing an exit tile that will have a specific interaction with the player.</p></div>