<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec51"></a>Concept of music</h2></div></div><hr /></div><p>Music has existed for many<a id="id329" class="indexterm"></a> years. It's prehistoric to be precise, and has evolved into a very complicated construct. Even though it is complicated and could take you many years of education to master, music can be very formulaic. The fact that we can abstract the idea of music as a formula is what will allow us to make an algorithm to generate it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec43"></a>Tempo</h3></div></div></div><p>The first thing we need to understand is<a id="id330" class="indexterm"></a> that a song will follow a tempo. The tempo of a song is the speed at which<a id="id331" class="indexterm"></a> the song progresses. Every sound within the song falls within some range of the tempo by an equal measure. That measure is usually at pace with the tempo, at 1/4th, at 1/8th, or at 1/16th. The tempo as seen in the following figure:</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_08_01.jpg" /><div class="caption"><p>Visualization of tempo</p></div></div><p>This might sound strange<a id="id332" class="indexterm"></a> if you have never heard it before. We can visualize each sound following a tempo as dots on a line or in a graph. The tempo can be seen as a vertical line that moves in the positive direction on the <span class="emphasis"><em>x</em></span> axis. Each time the tempo line intersects a sound dot, the sound will play.</p><p>The tempo line moves at a constant rate, but the sound dots can be placed farther apart or closer together. The sound dots are usually placed within the tempo time frame in a uniform distribution. Having your sounds play uniformly with a tempo creates a harmony to your song.</p><p>We can think of the<a id="id333" class="indexterm"></a> tempo as a simple timer. Timers are widely used in game development, so if you haven't been exposed to them, you will learn about them in this chapter. We can set a<a id="id334" class="indexterm"></a> timer to count down from a set interval and at the end of the timer's life, we play a sound. This will be the basis of our tempo.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec44"></a>Melody</h3></div></div></div><p>In a song, the<a id="id335" class="indexterm"></a> melody is the placement of sounds usually following a tempo that creates an interesting melodic sound as a whole. We will use our tempo timer to play sounds at<a id="id336" class="indexterm"></a> certain times to create our melody. However, it won't be enough to simply play a sound on a timer.</p><p>We will need to vary exactly when and for how long the sound is played within the tempo to make a more interesting melody. Playing sounds at random within the tempo won't work well, as we'll find out later in the chapter with our first attempt at generating music. In order to create a melody that isn't so dissonant that it disturbs the player, we need to play our sounds at equal measures of the tempo.</p><p>In the following figure, we see a coordinate plane where the x-axis is time. Our tempo moves along the <span class="emphasis"><em>x</em></span> axis as time increases. When the tempo intersects with a plotted sound dot, that sound will play. All of the dots are plotted on the <span class="emphasis"><em>x</em></span> axis, but we vary the <span class="emphasis"><em>y</em></span> coordinate so that it is easier to read as sounds will sometimes overlap.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_08_02.jpg" /><div class="caption"><p>Visualization of tempo divisions</p></div></div><p>This is where the idea of playing sounds at 1/4th, 1/8th, and 1/16th of the tempo comes in. We will equally space out<a id="id337" class="indexterm"></a> our sounds at some division of the tempo timer to keep our melody harmonious. But then, we need to consider the sounds that we are playing as well.</p><p>We will need a variety <a id="id338" class="indexterm"></a>of sounds to make our song, as we need a variety of art assets to make a game. Also, in PCG we want to reuse as much as we can, like we did with art, so that we can make the most out of a small amount of sounds. Luckily, there are some simple ways to get the most out of a few sounds.</p><p>First, we can vary the length of time for which the sound is played, as shown in the following figure. We will be using some sounds that can be sustained for long periods or played at short intervals. Second, we will be varying the pitch that will change the note at which the sound is played. This will raise <a id="id339" class="indexterm"></a>and lower the tone of the sound, which is generally<a id="id340" class="indexterm"></a> used in music to make interesting melodies.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_08_03.jpg" /><div class="caption"><p>Visualization of sound length variations</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec45"></a>Repetition</h3></div></div></div><p>Most music follows some<a id="id341" class="indexterm"></a> sort of repetition. Usually, the song will repeat sections of the song in a pattern, such as VCVC. The V represents a verse where the music will vary in <a id="id342" class="indexterm"></a>structure and the C represents a chorus where the music structure is consistent. We will simply use the idea of repetition as an excuse to repeat our simple melody.</p><p>We will construct a single section of music, such as a verse, and loop it. This will make the song, as a whole, less interesting but this is the desired effect. With the single verse of the song repeating, the tone of the song will become more atmospheric and blend into the background. This way, the player isn't overly distracted by the music in the game.</p><p>So now that we<a id="id343" class="indexterm"></a> know the basics of tempo, melody, and repetition, we are ready to put together a simple song. Since we are generating our song procedurally, we will need to plan out an algorithm, as we<a id="id344" class="indexterm"></a> have done before. Keep in mind that this will be a small subset of what it can be.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note19"></a>Note</h3><p>A great<a id="id345" class="indexterm"></a> example of a more complex procedural music generator can be experienced at <a class="ulink" href="http://abundant-music.com/" target="_blank">http://abundant-music.com/</a>. You can play around with this tool and get inspired to make some procedurally generated music.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec09"></a>Procedurally generated music algorithm</h4></div></div></div><p>The design of our algorithm<a id="id346" class="indexterm"></a> will start with the tempo. As stated before, we can abstract a simple timer into our tempo concept. So we will set a timer at a random interval. When the timer hits 0, then we will play our sound and reset the timer.</p><p>This seems simple enough but there is something to consider, the play length of the sound. We are going to vary the play lengths of our sounds, so we need to keep a track of when and for how long the sound will play. We can easily throw off our timer, and as a result, have some sounds playing at different times when the song loops.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec10"></a>Measure</h4></div></div></div><p>We can imagine the whole song fitting in a single structure that we will call a <span class="strong"><strong>measure</strong></span>. The measure is the entire time<a id="id347" class="indexterm"></a> frame of the song before it loops. In order to keep<a id="id348" class="indexterm"></a> the tempo, we will divide the measure time frame into subsections where our sounds will play.</p><p>The following image is a visualization of our measure. There are three horizontal sections that represent the separate sounds that will play in their own time frame. The tempo will move from left to right as the time increases from zero to <span class="strong"><strong>t</strong></span> (how ever long we like).</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_08_04.jpg" /><div class="caption"><p>Visualization of the measure with sounds</p></div></div><p>By confining our <a id="id349" class="indexterm"></a>sounds to a constant time frame, we will increase the harmony of the overall song. We don't need the song to be too harmonious as it is meant to be <a id="id350" class="indexterm"></a>atmospheric and a little creepy. However, the measure will ensure our song doesn't lose timing and transform itself overtime, which may be a little jarring for the player.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec11"></a>Dividing the measure</h4></div></div></div><p>For simplicity's sake, our song will consist of three<a id="id351" class="indexterm"></a> distinct sounds. Feel free<a id="id352" class="indexterm"></a> to add more sounds, if you like. The measure will be divided uniquely for each sound. We will do a little math to divide the measure so that the sound frequency and play time fits correctly.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_08_05.jpg" /><div class="caption"><p>Measure with sound division</p></div></div><p>We can choose at<a id="id353" class="indexterm"></a> random how many times the sound is played in<a id="id354" class="indexterm"></a> the measure. Then, we will need to determine the play length of the sound instances. We can let the sounds play at random lengths within a subdivision of the measure. If we divide the measure by the number of times the sound is played, then we can allow the sound to play no longer than that division.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_08_06.jpg" /><div class="caption"><p>Measure with random sound lengths</p></div></div><p>The space in between (the white space in the preceding figure) the sound play length is then added together<a id="id355" class="indexterm"></a> and divided equally. This division will create uniform <a id="id356" class="indexterm"></a>periods in which the sound is not being played. All of this will ensure that the sound line fits well within the measure and utilizes the space appropriately.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_08_07.jpg" /><div class="caption"><p>The interval in which sound is not played</p></div></div><p>Within a single measure, we can add multiple lines of sound that are divided individually to fit the measure. The<a id="id357" class="indexterm"></a> layering of different sounds following our timer tempo and playing within the same measure will create our song. We can then easily<a id="id358" class="indexterm"></a> manipulate the pitch each time the sound is played to create a variation in the sound.</p><p>So, at this point, our algorithm is pretty well defined. We now need to translate it to code. We can start with a single sound and work our way through it from there.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec46"></a>The base line</h3></div></div></div><p>The base line<a id="id359" class="indexterm"></a> will be our naturally low-pitched sound. We will create this line of bass sounds within a measure <a id="id360" class="indexterm"></a>division using a single bass sound. But first, we need to set up our script, which will be our <code class="literal">SoundManager</code> script.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec12"></a>Setting up the script</h4></div></div></div><p>Let's first set up the <a id="id361" class="indexterm"></a>GameObject that will manage the sounds that will make up our game music. We are going to make a <code class="literal">SoundManager</code> class that is a lot like our <code class="literal">GameManager</code> class. You can make the Sound Manager using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new empty GameObject.</p></li><li><p>Name the new GameObject <code class="literal">Sound Manager</code>.</p></li><li><p>Add three audio source components to the <code class="literal">Sound Manager</code> GameObject.</p></li></ol></div><p>After you have the <code class="literal">Sound Manager</code> GameObject, we will need to import some sounds. You can find the three main sounds we will use for this chapter in the accompanying files under <code class="literal">Chapter 8</code>. Create a new folder called <code class="literal">Sounds</code> and import <code class="literal">sound1.wav</code>, <code class="literal">sound2.wav</code>, and <code class="literal">sound3.wav</code> into the <code class="literal">Sounds</code> folder.</p><p>Then, return to the <code class="literal">Sound Manager</code> GameObject and add each sound to the <span class="strong"><strong>Audio Clip</strong></span> section of the three audio sources. That is all we need to do right now for the <code class="literal">Sound Manager</code> setup. It is important to note that two of the three sounds that we are using have a particular quality to them.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note20"></a>Note</h3><p>All three sounds were<a id="id362" class="indexterm"></a> created using an online synthesizer called <span class="strong"><strong>AudioSauna</strong></span>, which can be found at <a class="ulink" href="http://www.audiosauna.com/studio/" target="_blank">http://www.audiosauna.com/studio/</a>.</p></div><p>Both <code class="literal">sound1.wav</code> and <code class="literal">sound2.wav</code> were recorded for a longer time frame (about 7 seconds) because the<a id="id363" class="indexterm"></a> sounds' wave form can be infinite. That means, we can play these sounds at a constant rate for some time as opposed to <code class="literal">sound3.wav</code>, which will dampen on its own after some time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec13"></a>The Sound Manager script</h4></div></div></div><p>Now that we are all set up, we are<a id="id364" class="indexterm"></a> ready to write the script. Create a <code class="literal">SoundManager.cs</code> script in the <span class="strong"><strong>Scripts</strong></span> folder. Then, open the script for editing. <span class="emphasis"><em>Code Snip 8.1</em></span> shows our new <code class="literal">SoundManager</code> class. As a warning, the following code snippet is not our final product and we will be improving it throughout the chapter:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System;
3 using System.Collections;
4 using Random = UnityEngine.Random;
5
6 public class SoundManager : MonoBehaviour {
7
8   public static SoundManager instance = null;
9
10  public AudioSource highSource;
11  public AudioSource midSource;
12  public AudioSource lowSource;
13
14  public float lowPitchRange = 0.0f;
15  public float highPitchRange = 0.0f;
16
17  public float measure = 0.0f;
18
19  public float[] basePlayTime;
20  public float basePlayTimer = 0.0f;
21  public float baseInterval = 0.0f;
22  public float baseIntervalTimer = 0.0f;
23  public int baseCords;
24  private float[] basePitchRanges;
25  public int basePitchRangeCount = 0;
26
27  void Awake() {
28    if (instance == null)
29      instance = this;
30    else if (instance != this)
31      Destroy(gameObject);
32
33    DontDestroyOnLoad(gameObject);
34
35    lowPitchRange = 0.25f;
36    highPitchRange = 1.75f;
37
38    Init();
39  }
40
41  void Update() {
42
43    PlaySoundLine(lowSource,
44      basePlayTime,
45      ref basePlayTimer,
46      baseInterval,
47      ref baseIntervalTimer,
48      baseCords,
49      basePitchRanges,
50      ref basePitchRangeCount);
51  }
52
53  private void Init() {
54
55    measure = Random.Range(3.0f, 20.0f);
56    float playTotal = 0.0f;
57
58    baseCords = Random.Range(3, 7);
59    basePlayTime = new float[baseCords];
60    basePitchRanges = new float[baseCords];
61    for (int i = 0; i &lt; baseCords; i++)
62    {
63      basePlayTime[i] = Random.Range(3.0f / baseCords, measure / baseCords);
64      playTotal += basePlayTime[i];
65      basePitchRanges[i] = Random.Range(lowPitchRange, highPitchRange);
66    }
67    basePlayTimer = basePlayTime[0];
68
69    baseInterval = (measure - playTotal) / baseCords;
70    baseIntervalTimer = baseInterval;
71  }
72
73  private void PlaySoundLine(AudioSource audio,
74    float[] playTime,
75    ref float playTimer,
76    float interval,
77    ref float intervalTimer,
78    int cords,
79    float[] pitchRanges,
80    ref int pitchRangeCount)
81    {
82      if (pitchRangeCount &gt;= cords)
83      {
84        pitchRangeCount = 0;
85      }
86
87      if (playTimer &gt; 0)
88      {
89        playTimer -= Time.deltaTime;
90        if (!audio.isPlaying)
91        {
92          audio.pitch = pitchRanges[pitchRangeCount];
93          audio.Play();
94          pitchRangeCount++;
95        }
96      }
97      else if (playTimer &lt;= 0)
98        {
99          audio.Stop();
100
101         if (intervalTimer &gt; 0)
102         {
103           intervalTimer -= Time.deltaTime;
104         }
105         else if (intervalTimer &lt;= 0)
106         {
107           playTimer = playTime[pitchRangeCount];
108           intervalTimer = interval;
109         }
110      }
111   }
112 }</pre></div><p>This is a rather large code block, so we will take a look at it in blocks. First, we will go over our declarations, then<a id="id365" class="indexterm"></a> the <code class="literal">Awake</code> function, then we'll jump to the <code class="literal">Init</code> and <code class="literal">PlaySoundLine</code>, and finally, return to the <code class="literal">Update</code> function. So, in that order, let's go over an explanation of the <code class="literal">SoundManager</code> code:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Lines 1-4</code>: These are our general using directives that you've seen throughout the book.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 8-25</code>: These lines are our variable declarations and there are quite a few of them. We'll give a brief explanation of each one. The <code class="literal">SoundManager</code> instance—the <code class="literal">SoundManager</code> class will be a singleton and is set up exactly like the <code class="literal">GameManager</code> class.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 10-12</code>: Here are our <code class="literal">AudioSource</code> references. Each sound will be called from an <code class="literal">AudioSource</code> that we attached to the Sound Manager prefab. We will only be working with the <code class="literal">lowSource</code> instance for right now.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 14-15</code>: These are the pitch ranges that our sounds can have. We will be dynamically changing these values, so initialize them at 0.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 17</code>: This is our measure variable, which will be a single float value representing the time frame in which all the sounds are played.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 19</code>: The play times for the <code class="literal">lowSource</code> instance. We will refer to this as the base line sounds because it will make up the tempo/rhythm for the other sounds to follow. The <code class="literal">basePlayTime</code> is an array because the sound will play multiple times in a measure and at differing lengths.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 20</code>: <code class="literal">basePlayTimer</code> is the play timer. We will need a variable dedicated to timing the play length of the current <code class="literal">lowSource</code> sound. We will have several variables like this.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 21</code>: <code class="literal">baseInterval</code> is the internal time frame. The interval is the amount of time between the sound playing. Remember from the algorithm design that we are going to<a id="id366" class="indexterm"></a> use this value to calculate the other values.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 22</code>: <code class="literal">baseIntervalTimer</code> is another dedicated timer. This one is for timing the interval or wait period between sound plays.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 23</code>: <code class="literal">baseCords</code> is the number of times the sound will play within a measure. This number will be the length of the <code class="literal">basePlayTimes</code> and <code class="literal">basePitchRanges</code> arrays.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 24</code>: <code class="literal">basePitchRanges</code> is the array that holds the pitch range values that correlate to the <code class="literal">basePlayTimes</code> array.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 25</code>: Finally, we'll use <code class="literal">pitchRangeCount</code> to keep track of which pitch value we need to attach to the sound.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 27-39</code>: After all those variable declarations, we are at the <code class="literal">Awake</code> function. Here, we will set up the <code class="literal">SoundManager</code> class to be a singleton, just like we do in the <code class="literal">GameManager</code> class. Then, we set our initial values for our pitch range and call the <code class="literal">Init</code> function, which will calculate our sounds within our measure.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 53-71</code>: The <code class="literal">Init</code> function is where we will decide the length of our measure and calculate how the sound will be played within that measure. First, we randomly decide the length of the measure, and then, we declare a helper variable that will track how much time in total of the measure is spent playing the sound.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 58-60</code>: We randomly decide the number of times we play the sound as <code class="literal">baseCords</code>. We then use that number to initialize our <code class="literal">basePlayTimes</code> and <code class="literal">basePitchRanges</code> arrays.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 61-66</code>: When calculating the <code class="literal">basePlayTimes</code>, we do a little math. We are going to let the <code class="literal">basePlayTimes</code> array be decided at random, but we can't let them be too long or it will mess up our measure timing. So the minimum of our range dictates that the sound can play for no less than the minimum length of a measure divided by the number of times we want to play the sound. Likewise, the sound can play for no longer than the full length of our measure divided by the number of sound plays. This will restrict the sound to play in intervals that are well contained within the measure. Then, we add this calculated play time to the total of <code class="literal">playTotal</code> and randomize the pitch for that sound to play.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 67</code>: We want to initialize the <code class="literal">basePlayTimer</code> array to hold the first play time.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 69-70</code>: Lastly, we will calculate the <code class="literal">baseInterval</code> array to be an even distribution of the leftover time that the sound is not playing. The way we do this is we subtract the total play time from the total measure time and divide it by the number of times the sound is played.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 73-112</code>: Moving on to the <code class="literal">PlaySoundLine</code> function, this is where the <code class="literal">AudioSource</code> method will be called and the play timers will be run. We pass into the function all the variables we track for the <code class="literal">lowSource</code> sound. Some of the variables, mainly the timers, are passed as <code class="literal">ref</code>, which means their values will be globally updated in the script.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 82-85</code>: This is a check that resets the <code class="literal">pitchRangeCount</code> variable. The <code class="literal">pitchRangeCount</code> variable will increase over time representing which pitch is being applied to the sound.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 87-96</code>: This first check is to see if our <code class="literal">playTimer</code> is running. If the timer hasn't hit zero yet, we <a id="id367" class="indexterm"></a>want to decrease the time. Then, we check if the sound is playing. If not, we play it with the selected pitch and adjust the <code class="literal">pitchRangeCount</code> for next time. We check to see if the sound is playing we can then skip playing the song so that we don't start it from the beginning.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 97-111</code>: If the <code class="literal">playTimer</code> variable hits 0, then we stop the sound. We will also start the interval wait period. After the <code class="literal">intervalTimer</code> variable hits 0, we set the <code class="literal">playTime</code> value to match the <code class="literal">pitchRangeCount</code> value, which was adjusted during the playing of the sound. We are using <code class="literal">pitchRangeCount</code> as the dynamic value and cords as the constant to reset.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 41-51</code>: Lastly, the <code class="literal">Update</code> function calls the <code class="literal">PlaySoundLine</code> function. The <code class="literal">Update</code> function is called once per frame, which happens many times within a second of the game and is ideal for use of timing.</p></li></ul></div><p>And after all that, you can add this script to the Sound Manager prefab. You will need to add the three Audio Sources in our Sound Manager component to their source locations in the <code class="literal">SoundManager</code> script. Then, go ahead and play the game. You should hear a low bass sound. Try stopping and starting the game several times to hear how it changes.</p><p>That was quite a bit to get through, but we're not done yet. It's not much of a song to only have one sound playing. So, next, we are going to add our two other sounds. But we need to be aware of good coding practices.</p><p>As of right now, we can easily add the sounds to our script, but it will make for some unappealing code. We are tracking a large number of variables for our base sound and we would have to add those same<a id="id368" class="indexterm"></a> variables per new sound. Take a look at <span class="emphasis"><em>Code Snip 8.2</em></span> to see an example:</p><div class="informalexample"><pre class="programlisting">1  public float basePlayTime = 0.0f;
2  public float basePlayTimer = 0.0f;
3 public float baseInterval = 0.0f;
4  public float baseIntervalTimer = 0.0f;
5  public int baseCords;
6  private float[] basePitchRanges;
7  public int basePitchRangeCount = 0;
8  
9  public float midPlayTime = 0.0f;
10 public float midPlayTimer = 0.0f;
11 public float midInterval = 0.0f;
12 public float midIntervalTimer = 0.0f;
13 public int midCords;
14 private float[] midPitchRanges;
15 public int midPitchRangeCount = 0;
16
17 public float highPlayTime = 0.0f;
18 public float highPlayTimer = 0.0f;
19 public float highInterval = 0.0f;
20 public float highIntervalTimer = 0.0f;
21 public int highCords;
22 private float[] highPitchRanges;
23 public int highPitchRangeCount = 0;
24
25 void Update () {
26   PlaySoundLine (lowSource,
27     basePlayTime,
28     ref basePlayTimer,
29     baseInterval,
30     ref baseIntervalTimer,
31     baseCords,
32     basePitchRanges,
33     ref basePitchRangeCount);
34
35   PlaySoundLine (midSource,
36     midPlayTime,
37     ref midPlayTimer,
38     midInterval,
39     ref midIntervalTimer,
40     midCords,
41     midPitchRanges,
42     ref midPitchRangeCount);
43
44  PlaySoundLine (highSource,
45    highPlayTime,
46    ref highPlayTimer,
47    highInterval,
48    ref highIntervalTimer,
49    highCords,
50    highPitchRanges,
51    ref highPitchRangeCount);
52
53 }</pre></div><p>As you can see, we would have to heavily repeat ourselves in the code and it would quickly become an unnecessarily large file. Instead, what we can do is make things a little more modular. By adding a class that would encapsulate the sound variables, the sound calculations, and the playing of the sound, we can make it so that adding a new sound would only require a few <a id="id369" class="indexterm"></a>new lines. This would make our script scale better as we could also devise a system to dynamically add sounds.</p><p>All that we need to do is declare a class within the Sound Manager, and then copy our functionality into that new class. Then, we can slightly rewrite our functions to call the class methods instead. Check out <span class="emphasis"><em>Code Snip 8.3</em></span> to see how this is done:</p><div class="informalexample"><pre class="programlisting">1 public class SoundManager : MonoBehaviour {
2 
3  [Serializable]
4  public class AudioCtrl
5  {
6    public float[] pitchRanges;
7    public float[] playTimes;
8    public float playTimer;
9    public float interval;
10   public float intervalTimer;
11   public int cordCount;
12   public int rangeCount;
13   
14   public AudioCtrl () {
15     playTimer = 0.0f;
16     interval = 0.0f;
17     intervalTimer = 0.0f;
18     cordCount = 0;
19     rangeCount = 0;
20   }
21
22   public void CalculateAudio (float measure, int minFreq, int maxFreq, float low, float high) {
23     float playTotal = 0.0f;
24
25     cordCount = Random.Range (minFreq, maxFreq);
26     playTimes = new float[cordCount];
27     pitchRanges = new float[cordCount];
28     for (int i = 0; i &lt; cordCount; i++) {
29       playTimes[i] = Random.Range (minFreq/cordCount, measure/cordCount);
30       playTotal += playTimes[i];
31       pitchRanges[i] = Random.Range(low, high);
32     }
33     playTimer = playTimes[0];
34     
35     interval = (measure - playTotal) / cordCount;
36     intervalTimer = interval;
37   }
38
39   public void PlaySoundLine (AudioSource source) {
40    
41     if (rangeCount &gt;= cordCount) {
42       rangeCount = 0;
43     }
44     
45     if (playTimer &gt; 0){
46       playTimer -= Time.deltaTime;
47       if (!source.isPlaying) {
48         source.pitch = pitchRanges[rangeCount];
49         source.Play();
50         rangeCount++;
51       }
52     }
53     else if (playTimer &lt;= 0){
54       source.Stop();
55       
56       if (intervalTimer &gt; 0){
57         intervalTimer -= Time.deltaTime;
58       }
59       else if (intervalTimer &lt;= 0){
60         playTimer = playTimes[rangeCount];
61         intervalTimer = interval;
62       }
63     }
64   }
65 }
66
67  public static SoundManager instance = null;
68
69  public AudioSource highSource;
70  public AudioSource midSource;
71  public AudioSource lowSource;
72           
73  public float lowPitchRange = 0.0f;
74  public float highPitchRange = 0.0f;
75
76  public float measure = 0.0f;
77
78  public AudioCtrl baseAudio;
79  public AudioCtrl midAudio;
80  public AudioCtrl highAudio;
81
82  void Awake () {
83    if (instance == null)
84      instance = this;
85    else if (instance != this)
86      Destroy (gameObject);
87
88    DontDestroyOnLoad (gameObject);
89
90    lowPitchRange = 0.25f;
91    highPitchRange = 1.75f;
92
93    baseAudio = new AudioCtrl();
94    midAudio = new AudioCtrl();
95    highAudio = new AudioCtrl();
96
97    FormAudio();
98  }
99
100 void Update () {
101   baseAudio.PlaySoundLine (lowSource);
102   midAudio.PlaySoundLine (midSource);
103   highAudio.PlaySoundLine (highSource);
104 }
105
106 public void FormAudio () {
107   measure = Random.Range (1.0f, 20.0f);
108
109   baseAudio.CalculateAudio(measure, 3, 7, lowPitchRange, highPitchRange);
110   midAudio.CalculateAudio(measure, 2, 6, lowPitchRange, highPitchRange);
111   highAudio.CalculateAudio(measure, 5, 10, lowPitchRange, highPitchRange);
112
113 }
114 }</pre></div><p>This is another large code block, but keep in mind that this is more of a code rearrangement than an addition of functionality. The main task of this is to modularize our sound effects so that we can easily add more sounds. So let's take a look at what we've done:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Lines 3-4</code>: Here is the declaration of our new <code class="literal">AudioCtrl</code> helper class. We are also going to serialize the class so that we can see its properties in the Unity Editor.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 6-12</code>: These lines <a id="id370" class="indexterm"></a>of the <code class="literal">AudioCtrl</code> class are the variables we used to manage our base sound. We have renamed them slightly because these properties are now universal to any <code class="literal">AudioCtrl</code> sound.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 14-20</code>: This is the <code class="literal">AudioCtrl</code> constructor. It simply initializes all single values to 0. The arrays will be initialized later in the class.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 22-36</code>: The <code class="literal">CalculateAudio</code> method of the <code class="literal">AudioCtrl</code> class will use the sound variables and calculate the play times of the sound based on the measure. This is the <code class="literal">Init</code> function from the last version of code.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 38-63</code>: The <code class="literal">PlaySoundLine</code> function is the <code class="literal">PlaySoundLine</code> from the last version of code as well. We have made some variable name adjustments to use the <code class="literal">AudioCtrl</code> internal properties.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 67-80</code>: After the <code class="literal">AudioCtrl</code> class declaration, we have the regular variable declarations for the <code class="literal">SoundManager</code> class. The only difference here is that instead of declaring a group of variables for each sound source, we declare a new <code class="literal">AudioCtrl</code> instance.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 81-97</code>: In the <code class="literal">Awake</code> function, we initialize the <code class="literal">AudioCtrl</code> instances and call a new function called <code class="literal">FormAudio</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 99-103</code>: Our <code class="literal">Update</code> function is still only three function calls, but they are much more compact than the variables have been compartmentalized more efficiently, adding other sounds.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 105-111</code>: Lastly, our <code class="literal">FormAudio</code> function just acts as a driver to call <code class="literal">CalculateAudio</code> on each of the <code class="literal">AudioCtrl</code> instances. The measure length is also decided here. The numbers in the function calls represent the min and max range of how many times within the measure a sound is played. Feel free to change these numbers to create a sound combination that you enjoy.</p></li></ul></div><p>So, we cleaned up our code and simultaneously added two more sounds to our song. Now, you can head back to the Unity Editor and give the new setup a test. You might need to reset your Audio Sources in the <code class="literal">SoundManager</code> script on the Game Object.</p><p>Try stopping and starting the game to generate new songs. You might notice that sometimes the song has a fast pace or a slow pace. The pace or tempo of the song is controlled with the measure<a id="id371" class="indexterm"></a> range that was set in the <code class="literal">FormAudio</code> function.</p><p>It would be a fun adjustment to our script if we could manipulate the measure during game play and thus change the tempo of the music as we play. Usually, you have atmospheric music as you explore in a game and then the music gets tenser and the tempo increases when you are in a battle or in a similar situation. We are going to add the functionality to change the tempo on our song, depending on what we are doing in the game. We can also make an adjustment to increase the melodic nature of our song.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec47"></a>Adding tension</h3></div></div></div><p>This addition will <a id="id372" class="indexterm"></a>need to take place in the <code class="literal">GameManager</code> class as well, but we will start in the <code class="literal">SoundManager</code> class. First, we will try to add some more melody to our song. There is a rise and fall nature to music. The sound will rise in pitch and then lower creating a rhythm.</p><p>We will add in some pitch control to attempt a similar effect. This change will take place in the <code class="literal">CalculateAudio</code> function of the <code class="literal">SoundManager</code> class. Take a look at <span class="emphasis"><em>Code Snip 8.4</em></span> to see the changes:</p><div class="informalexample"><pre class="programlisting">1 public void CalculateAudio (float measure, int minFreq, int maxFreq, float low, float high) {
2   float playTotal = 0.0f;
3   float lastPitch = Random.Range(low, high);
4   int switchPitchCount = Random.Range(3, maxFreq);
5   int switchPitch = 0;
6   int pitchDir = Random.Range(0, 2);
7
8   cordCount = Random.Range (minFreq, maxFreq);
9   playTimes = new float[cordCount];
10  pitchRanges = new float[cordCount];
11  for (int i = 0; i &lt; cordCount; i++) {
12    playTimes[i] = Random.Range (minFreq/cordCount, measure/cordCount);
13    playTotal += playTimes[i];
14    if (pitchDir == 0) {
15      lastPitch = pitchRanges[i] = Random.Range(low, lastPitch);
16    }
17    else if (pitchDir == 1) {
18      lastPitch = pitchRanges[i] = Random.Range(lastPitch, high);
19    }
20    switchPitch++;
21    if (switchPitch == switchPitchCount) {
22      if (pitchDir == 0)
23        pitchDir = 1;
24      else
25        pitchDir = 0;
26    }
27  }
28  playTimer = playTimes[0];
29  
30  interval = (measure - playTotal) / cordCount;
31  intervalTimer = interval;
32 }</pre></div><p>We added some new local variables that will keep track of the pitch. Then, we added some checks that will dictate whether we want to adjust the pitch lower or higher. Let's go through the code:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 3</code>: <code class="literal">lastPitch</code> will be the current pitch value.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 4</code>: <code class="literal">switchPitchCount</code> will be the number of times the pitch value changes.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 5</code>: <code class="literal">switchPitch</code> will be a flag to indicate that we are switching whether a pitch should increase<a id="id373" class="indexterm"></a> or decrease.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 6</code>: <code class="literal">pitchDir</code> is the indicator that the pitch is increasing or decreasing. 1 for increasing and 0 for decreasing.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 14-19</code>: We will calculate the pitch of the sound with the play time calculation. First, we check to see in which direction the pitch needs to go. If 0, we want the pitch to stay the same or to go lower. If 1, we want the pitch to stay the same or to go higher.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 19-26</code>: After we choose a pitch or a sound play, we add to the countdown of the pitch's direction change. If it's time to change the pitch's direction, then we adjust <code class="literal">pitchDir</code> accordingly.</p></li></ul></div><p>So that quick change should give our music a bit more melody. Use this and adjust the frequency values in the <code class="literal">PlaySoundLine</code> calls to create a general sound that you like. Now, we will move on to adjusting the measure during game play.</p><p>Still in the <code class="literal">SoundManager</code> class , you'll make a small change. In the <code class="literal">FormAudio</code> function, you'll add a check for a flag. We can then call <code class="literal">FormAudio</code> from the <code class="literal">GameManager</code> with the flag active or not to change the tempo.</p><p>The flag, which we will call tension, will be set when you encounter enemies. In <code class="literal">FormAudio</code>, we'll simply adjust the range in which the measure can choose from. You can see this in <span class="emphasis"><em>Code Snip 8.5</em></span>:</p><div class="informalexample"><pre class="programlisting">1 public void FormAudio (bool tension) {
2 
3   if (tension) {
4     measure = Random.Range (1.0f, 3.0f);
5   } else {
6     measure = Random.Range (10.0f, 20.0f);
7   }
8
9   baseAudio.CalculateAudio(measure, 3, 7, lowPitchRange, highPitchRange);
10  midAudio.CalculateAudio(measure, 2, 6, lowPitchRange, highPitchRange);
11  highAudio.CalculateAudio(measure, 5, 10, lowPitchRange, highPitchRange);
12
13 }</pre></div><p><code class="literal">Lines 3-7</code> show the check that is needed. If the <code class="literal">tension</code> flag is set, <code class="literal">measure</code> will choose from a lower range of measure time frames, which will increase the frequency of sound plays. This, thus, increases the tempo and the anxiety of the song.</p><p>We need to also change<a id="id374" class="indexterm"></a> how we call the function and where. Starting in the <code class="literal">Awake</code> function of the <code class="literal">SoundManager</code> class, change the <code class="literal">FormAudio</code> call to <code class="literal">FormAudio(false)</code>. Then, we'll need to open up the <code class="literal">GameManager</code> script to add some <code class="literal">FormAudio</code> calls. The changes to the <code class="literal">GameManager</code> class can be seen in <span class="emphasis"><em>Code Snip 8.6</em></span>:</p><div class="informalexample"><pre class="programlisting">14 public void AddEnemyToList(Enemy script)
15 {
16   enemies.Add(script);
17   SoundManager.instance.FormAudio (true);
18 }
19 public void RemoveEnemyFromList(Enemy script)
20 {
21   enemies.Remove(script);
22   if (enemies.Count == 0) {
23    SoundManager.instance.FormAudio (false);
24  }
25 }
...
26 public void exitDungeon () {
27   boardScript.SetWorldBoard ();
28   playerScript.dungeonTransition = false;
29   playerInDungeon = false;
30   enemies.Clear ();
31 
32   SoundManager.instance.FormAudio (false);
33 }</pre></div><p>The adjustment is minor but will make a good impact on game play. Simply add the <code class="literal">SoundManager.instance.FormAudio</code> call to the <code class="literal">AddEnemyToList</code>, <code class="literal">RemoveEnemyFromList</code>, and <code class="literal">exitDungeon</code> functions. You will need to add a check to the <code class="literal">RemoveEnemyFromList</code> function that checks whether all enemies have been removed.</p><p>Now, when you play the <a id="id375" class="indexterm"></a>game, the tempo of our song will play slower and more melodic. Find an enemy and the tempo of the song will increase, which will make it feel as though there is some tension. This all adds to the overall fun of the game.</p></div></div>