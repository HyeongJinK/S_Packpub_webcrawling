<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec45"></a>Setting up sprites</h2></div></div><hr /></div><p>We will now add enemy scripts and set up sprites.</p><p>First on our agenda is <a id="id278" class="indexterm"></a>setting up the Enemy prefab and script. Let's take a look at the Enemy prefab. The prefab was imported with all of the starting materials in <code class="literal">Chapter 2</code>. Just in case you need an extra copy of the Enemy prefab though, there will be an import file in the accompanying <code class="literal">Chapter 7</code> files.</p><p>The Enemy prefab looks a lot like the<a id="id279" class="indexterm"></a> Player prefab. Both the <code class="literal">Enemy</code> and <code class="literal">Player</code> classes inherit from the<a id="id280" class="indexterm"></a> <code class="literal">Moving Object</code> class. This means the enemy movement and animations<a id="id281" class="indexterm"></a> are going to be processed in a similar way to the <code class="literal">Player</code> class. This generally means the prefab structure will have to be similar.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_07_02.jpg" /><div class="caption"><p>Enemy Sprite</p></div></div><p>Requirements for <a id="id282" class="indexterm"></a>our Enemy prefab include:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A Sprite Renderer</p></li><li style="list-style-type: disc"><p>An Animator</p></li><li style="list-style-type: disc"><p>A Box Collider 2D</p></li><li style="list-style-type: disc"><p>A Rigid Body 2D</p></li><li style="list-style-type: disc"><p>The Enemy Script</p></li></ul></div><p>Also, be sure that these options are selected in your Enemy prefab:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Set the tag to <span class="strong"><strong>Enemy</strong></span></p></li><li style="list-style-type: disc"><p>Set the layer to <span class="strong"><strong>BlockingLayer</strong></span></p></li><li style="list-style-type: disc"><p>In the <span class="strong"><strong>Sprite Renderer</strong></span> component, set the <span class="strong"><strong>Sorting Layer</strong></span> field to <span class="strong"><strong>Units</strong></span></p></li><li style="list-style-type: disc"><p>In the <span class="strong"><strong>Animator</strong></span> component, set the <span class="strong"><strong>Controller</strong></span> field to use the <span class="strong"><strong>Enemy Animator Controller</strong></span></p></li></ul></div><p>That's it for the Enemy prefab. All the magic is going to happen in the <code class="literal">Enemy</code> script. Go ahead and open the <code class="literal">Enemy</code> script for editing. You will see the following lines:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System.Collections;
3
4 public class Enemy : MovingObject
5 {
6   protected override bool AttemptMove &lt;T&gt; (int xDir, int yDir)
7   {
8     return true;
9   }
10
11  protected override void OnCantMove &lt;T&gt; (T component)
12  {
13  }
14 }</pre></div><p>The <code class="literal">Enemy</code> script is currently a placeholder. The movement cycle in the game is turn based. The player needs to play a turn by moving and only then is it the enemy's turn, and back to the player in a cycle. We added the <code class="literal">enemy</code> class at the beginning of our <span class="emphasis"><em>Roguelike</em></span> game so that this turn-based system would be functional from the get go, hence the <code class="literal">Enemy</code> class placeholder. So, now, all we have to do is add the enemy functionality to the placeholder and the<a id="id283" class="indexterm"></a> turn-based movement system will work as is.</p><p>We can now go ahead and add the enemy base functionality. <span class="emphasis"><em>Code Snip 7-1</em></span> shows what we need to add to get started with enemies in our game. The code snippet includes the movement functionality and what the enemy does when it is blocked from moving. This will be similar to the player's movement. Following the code snippet, we will take a look at the details of the code:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System.Collections;
3 
4 public class Enemy : MovingObject {
5
6   public int playerDamage;
7  
8   private Animator animator;
9   private Transform target;
10  private bool skipMove;
11
12  protected override void Start () {
13    GameManager.instance.AddEnemyToList (this);
14
15    animator = GetComponent&lt;Animator&gt; ();
16
17    target = GameObject.FindGameObjectWithTag ("Player").transform;
18
19    base.Start ();
20  }
21
22  protected override void AttemptMove &lt;T&gt; (int xDir, int yDir) {
23    if(skipMove) {
24      skipMove = false;
25      return;
26    }
27
28    base.AttemptMove &lt;T&gt; (xDir, yDir);
29
30    skipMove = true;
31  }
32
33  public void MoveEnemy () {
34    int xDir = 0;
35    int yDir = 0;
36
37    if(Mathf.Abs (target.position.x - transform.position.x) &lt; float.Epsilon)
38      yDir = target.position.y &gt; transform.position.y ? 1 : -1;
39    else
40      xDir = target.position.x &gt; transform.position.x ? 1 : -1;
41
42    AttemptMove &lt;Player&gt; (xDir, yDir);
43  }
44
45  protected override void OnCantMove &lt;T&gt; (T component) {
46    Player hitPlayer = component as Player;
47
48    hitPlayer.LoseHealth (playerDamage);
49
50    animator.SetTrigger ("enemyAttack");
51  }
52 }</pre></div><p>The enemy will try to move towards the player and when the player is adjacent to the enemy the enemy will <a id="id284" class="indexterm"></a>attack the player. The enemy movement AI is handled in the new <code class="literal">MoveEnemy</code> function. We will see how the enemy moves on its own as we go over the code in <span class="emphasis"><em>Code Snip 7.1</em></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Lines 1-2</code>: The <code class="literal">Enemy</code> class only requires UnityEngine and <code class="literal">System.Collections</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 4</code>: Be sure to inherit from the <code class="literal">MovingObject</code> class.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 8-10</code>: The starting variable we need to get this class working is an <code class="literal">Animator</code> to control the animations, a Transform called <code class="literal">target</code> to be the player, and a bool called <code class="literal">skipMove</code> to slow the enemy down.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 12</code>: We will add a <code class="literal">Start</code> function to initialize everything.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 13</code>: We need to add the enemies to a list so we can keep track of them because there will likely be more than one on screen. The <code class="literal">AddEnemyToList</code> function has been in the <code class="literal">GameManager</code> class since <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Roguelike Games</em></span> but we haven't used it until now. The <code class="literal">GameManager</code> class will be in charge of the enemies and run their movement.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 17</code>: Here, we set the target to the player. We want the enemies to know the position of the player at all times so that the enemies can chase the player.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 22-31</code>: We are going to expand the <code class="literal">AttemptMove</code> function and make it so that the enemies aren't as fast as the player to start with. First, we check to see whether the <code class="literal">skipMove</code> variable is set to <code class="literal">true</code>, and if it is, we set it back to <code class="literal">false</code> and exit the<a id="id285" class="indexterm"></a> function, effectively ending the enemies' turn without movement. If <code class="literal">skipMove</code> is <code class="literal">false</code>, then we call the base class <code class="literal">AttemptMove</code> function.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 33-43</code>: This is a new function that the <code class="literal">GameManager</code> class will call when it is time to move the enemies. This function contains the AI logic of the <code class="literal">Enemy</code> class.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 34-35</code>: The goal of the function is to record the direction of the player into <code class="literal">xDir</code> and <code class="literal">yDir</code>. We can only move one space at a time, though, so either <code class="literal">xDir</code> or <code class="literal">yDir</code> will get the 1/-1 value.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 37-40</code>: The AI is basic. We want the enemy to move in the <span class="emphasis"><em>x</em></span> direction towards the player. If the player and enemy are on the same <span class="emphasis"><em>x</em></span> coordinate, then we want the enemy to move toward the enemy in the <span class="emphasis"><em>y</em></span> direction. We do not take into account that the enemy can easily get stuck on a wall and get blocked from reaching the player. In fact, this is a desired effect as we want the player to be able to escape the enemy at the beginning when the player does very little damage.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 42</code>: Once the enemy has a direction, it will call its <code class="literal">AttemptMove</code> function.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 45-51</code>: Last is our <code class="literal">OnCantMove</code> function. Our component is going to be the player and if we hit him, then we will call the <code class="literal">Player.LoseHealth</code> function to reflect the damage. We will also call an enemy attack animation.</p></li></ul></div><p>Our enemy base functionality is all set up. Of course, that isn't enough. The <code class="literal">Enemy</code> class won't just move on its own, it needs some other structure to guide it. This structure would be the <code class="literal">GameManager</code> class. We should also be thinking about what will happen to the enemy once they are on the world board.</p><p>It is impossible for our player to walk on the black space surrounding our floor tiles because every step of the player generates new floor tiles. The same isn't true for enemies though. They will be able to walk anywhere unless we write the conditions to constrain them to the board. We will need to keep this under consideration as we spawn enemies on the world <a id="id286" class="indexterm"></a>board.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_07_03.jpg" /><div class="caption"><p>Enemy walking on black space</p></div></div></div>