<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec54"></a>Multi mesh planet</h2></div></div><hr /></div><p>Now that we are able to<a id="id408" class="indexterm"></a> generate a sphere and understand some of the pitfalls of 3D rendering, we are ready to generate our planet. Normally, the approach for generating a planet would be to generate a sphere and then generate a random texture called a height map. This is well covered and documented in free online resources. This would require quite a bit of work and extra plugins so it will be left to you to research on your own. We will take another approach that can be scripted easily.</p><p>We will generate<a id="id409" class="indexterm"></a> multiple spheres and perform some manipulations on their geometry to give them each a unique character. We are also going to use a different type of sphere for this task. This sphere will be generated from a polygon called an Icosahedron. The algorithm for this <a id="id410" class="indexterm"></a>primitive can be found at the Unity Wiki page, <a class="ulink" href="http://wiki.unity3d.com/index.php/ProceduralPrimitives" target="_blank">http://wiki.unity3d.com/index.php/ProceduralPrimitives</a>.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_09_06.jpg" /><div class="caption"><p>Icosahedron sphere on the left and polar sphere on the right</p></div></div><p>The <span class="strong"><strong>icosahedron sphere </strong></span>is seamlessly<a id="id411" class="indexterm"></a> created, meaning that there are fewer vertices and we can get rid of the vertex grouping functionality. This helps improve performance overall. We can do this with the polar sphere but the icosphere has a more uniform shape that will work better for the following example. The code to generate the icosahedron sphere is found at the same Unity Wiki page as the polar sphere.</p><p>We are going to write a single script that we can use and manipulate properties to create the terrain, water, and sky of our generated planet. Before we begin writing the script, we need to create some materials so that we can tell our spheres apart. Create a <code class="literal">Materials</code> folder in your <code class="literal">Assets</code> folder.</p><p>In the <code class="literal">Materials</code> folder, create a new <code class="literal">Material</code>. You can name this material <code class="literal">Land</code>. Then, you can follow the given steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Set <span class="strong"><strong>Shader</strong></span> to <span class="strong"><strong>Standard</strong></span>.</p></li><li><p>Set <span class="strong"><strong>Rendering Mode</strong></span> to <span class="strong"><strong>Opaque</strong></span>.</p></li><li><p>Set <span class="strong"><strong>Smoothness</strong></span> to <code class="literal">0</code>.</p></li></ol></div><p>This will give us a nice<a id="id412" class="indexterm"></a> flat land material. Next, we can make the water. Create a new material with the color blue and these properties:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Set <span class="strong"><strong>Shader</strong></span> to <span class="strong"><strong>Standard</strong></span>.</p></li><li><p>Set <span class="strong"><strong>Rendering Mode</strong></span> to <span class="strong"><strong>Transparent</strong></span>.</p></li><li><p>Set <span class="strong"><strong>Smoothness</strong></span> to <code class="literal">0.7</code>.</p></li></ol></div><p>Lastly, we will make a sky material with a light blue color and the following properties:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Set <span class="strong"><strong>Shader</strong></span> to <span class="strong"><strong>Standard</strong></span>.</p></li><li><p>Set <span class="strong"><strong>Rendering Mode</strong></span> to <span class="strong"><strong>Transparent</strong></span>.</p></li><li><p>Set <span class="strong"><strong>Smoothness</strong></span> to <code class="literal">0.2</code>.</p></li></ol></div><p>Now, in the editor, create four new empty GameObjects and call them <code class="literal">Land1</code>, <code class="literal">Land2</code>, <code class="literal">Water</code>, and <code class="literal">Sky</code> respectively. Make sure that they share the exact same XYZ position. Add a <span class="strong"><strong>Mesh Renderer</strong></span> component to each object. Add a <span class="strong"><strong>Mesh Collider</strong></span> component to <code class="literal">Land1</code> and <code class="literal">Land2</code>. And add the materials to the appropriate GameObjects.</p><p>Now we are ready to write<a id="id413" class="indexterm"></a> the new script. Create a new script called <code class="literal">ProceduralPlanet.cs</code>. Then, open up the script for editing. <span class="emphasis"><em>Code Snip 9.5</em></span> shows the new script in its entirety:</p><div class="informalexample"><pre class="programlisting">1 using UnityEngine;
2 using System.Collections;
3 using System.Collections.Generic;
4 using Random = UnityEngine.Random;
5 
6 public class ProceduralPlanet : MonoBehaviour {
7 
8     private struct TriangleIndices {
9         public int v1;
10        public int v2;
11        public int v3;
12
13        public TriangleIndices(int v1, int v2, int v3) {
14            this.v1 = v1;
15            this.v2 = v2;
16            this.v3 = v3;
17        }
18    }
19
20    private Mesh mesh;
21
22    public bool randomize;
23    public bool offset;
24    public bool invert;
25    public float rad;
26    public int detail;
27    public MeshCollider meshCollider;
28
29    // Use this for initialization
30    void Start () {
31        Create(rad, detail);
32
33        if (offset) {
34            Offset();
35        }
36
37        if (meshCollider) {
38            meshCollider.sharedMesh = mesh;
39        }
40        
41 }
42
43 private void Offset () {
44        int offset = Random.Range(1, 7);
45
46        int offsetMod = Random.Range(0, 2);
47        if (offsetMod == 0) {
48            offsetMod = -1;
49        }
50
51        Vector3 offsetVec = new Vector3();
52        switch (offset) {
53            case 1:
54                offsetVec = new Vector3(Random.Range(0.01f, 0.05f), 0, 0) * offsetMod;
55                break;
56            case 2:
57                offsetVec = new Vector3(0, Random.Range(0.01f, 0.05f), 0) * offsetMod;
58                break;
59            case 3:
60                offsetVec = new Vector3(0, 0, Random.Range(0.01f, 0.05f)) * offsetMod;
61                break;
62        }
63        transform.position = transform.position += offsetVec;
64    }
65
66    // return index of point in the middle of p1 and p2
67    private int getMiddlePoint(int p1, int p2, ref List&lt;Vector3&gt; vertices, ref Dictionary&lt;long, int&gt; cache, float radius) {
68        // first check if we have it already
69        bool firstIsSmaller = p1 &lt; p2;
70        long smallerIndex = firstIsSmaller ? p1 : p2;
71        long greaterIndex = firstIsSmaller ? p2 : p1;
72        long key = (smallerIndex &lt;&lt; 32) + greaterIndex;
73
74        int ret;
75        if (cache.TryGetValue(key, out ret)) {
76            return ret;
77        }
78
79        // not in cache, calculate it
80        Vector3 point1 = vertices[p1];
81        Vector3 point2 = vertices[p2];
82        Vector3 middle = new Vector3
83        (
84            (point1.x + point2.x) / 2f,
85            (point1.y + point2.y) / 2f,
86            (point1.z + point2.z) / 2f
87        );
88
89        // add vertex makes sure point is on unit sphere
90        int i = vertices.Count;
91        vertices.Add(middle.normalized * radius);
92
93        // store it, return index
94        cache.Add(key, i);
95
96        return i;
97    }
98
99    public void Create(float radius, int recursionLevel) {
100        MeshFilter filter = gameObject.AddComponent&lt;MeshFilter&gt;();
101        mesh = filter.mesh;
102        mesh.Clear();
103
104        List&lt;Vector3&gt; vertList = new List&lt;Vector3&gt;();
105        Dictionary&lt;long, int&gt; middlePointIndexCache = new Dictionary&lt;long, int&gt;();
106
107        // create 12 vertices of a icosahedron
108        float t = (1f + Mathf.Sqrt(5f)) / 2f;
109
110        vertList.Add(new Vector3(-1f, t, 0f).normalized * radius);
111        vertList.Add(new Vector3(1f, t, 0f).normalized * radius);
112        vertList.Add(new Vector3(-1f, -t, 0f).normalized * radius);
113        vertList.Add(new Vector3(1f, -t, 0f).normalized * radius);
114
115        vertList.Add(new Vector3(0f, -1f, t).normalized * radius);
116        vertList.Add(new Vector3(0f, 1f, t).normalized * radius);
117        vertList.Add(new Vector3(0f, -1f, -t).normalized * radius);
118        vertList.Add(new Vector3(0f, 1f, -t).normalized * radius);
119
120        vertList.Add(new Vector3(t, 0f, -1f).normalized * radius);
121        vertList.Add(new Vector3(t, 0f, 1f).normalized * radius);
122        vertList.Add(new Vector3(-t, 0f, -1f).normalized * radius);
123        vertList.Add(new Vector3(-t, 0f, 1f).normalized * radius);
124
125
126        // create 20 triangles of the icosahedron
127        List&lt;TriangleIndices&gt; faces = new List&lt;TriangleIndices&gt;();
128
129        // 5 faces around point 0
130        faces.Add(new TriangleIndices(0, 11, 5));
131        faces.Add(new TriangleIndices(0, 5, 1));
132        faces.Add(new TriangleIndices(0, 1, 7));
133        faces.Add(new TriangleIndices(0, 7, 10));
134        faces.Add(new TriangleIndices(0, 10, 11));
135
136        // 5 adjacent faces 
137        faces.Add(new TriangleIndices(1, 5, 9));
138        faces.Add(new TriangleIndices(5, 11, 4));
139        faces.Add(new TriangleIndices(11, 10, 2));
140        faces.Add(new TriangleIndices(10, 7, 6));
141        faces.Add(new TriangleIndices(7, 1, 8));
142
143        // 5 faces around point 3
144        faces.Add(new TriangleIndices(3, 9, 4));
145        faces.Add(new TriangleIndices(3, 4, 2));
146        faces.Add(new TriangleIndices(3, 2, 6));
147        faces.Add(new TriangleIndices(3, 6, 8));
148        faces.Add(new TriangleIndices(3, 8, 9));
149
150        // 5 adjacent faces 
151        faces.Add(new TriangleIndices(4, 9, 5));
152        faces.Add(new TriangleIndices(2, 4, 11));
153        faces.Add(new TriangleIndices(6, 2, 10));
154        faces.Add(new TriangleIndices(8, 6, 7));
155        faces.Add(new TriangleIndices(9, 8, 1));
156
157
158        // refine triangles
159        for (int i = 0; i &lt; recursionLevel; i++) {
160            List&lt;TriangleIndices&gt; faces2 = new List&lt;TriangleIndices&gt;();
161            foreach (var tri in faces) {
162                // replace triangle by 4 triangles
163                int a = getMiddlePoint(tri.v1, tri.v2, ref vertList, ref middlePointIndexCache, radius);
164                int b = getMiddlePoint(tri.v2, tri.v3, ref vertList, ref middlePointIndexCache, radius);
165                int c = getMiddlePoint(tri.v3, tri.v1, ref vertList, ref middlePointIndexCache, radius);
166
167                faces2.Add(new TriangleIndices(tri.v1, a, c));
168                faces2.Add(new TriangleIndices(tri.v2, b, a));
169                faces2.Add(new TriangleIndices(tri.v3, c, b));
170                faces2.Add(new TriangleIndices(a, b, c));
171            }
172            faces = faces2;
173        }
174
175        mesh.vertices = vertList.ToArray();
176
177        List&lt;int&gt; triList = new List&lt;int&gt;();
178        for (int i = 0; i &lt; faces.Count; i++) {
179            triList.Add(faces[i].v1);
180            triList.Add(faces[i].v2);
181            triList.Add(faces[i].v3);
182        }
183
184        mesh.triangles = triList.ToArray();
185        mesh.uv = new Vector2[mesh.vertices.Length];
186
187        Vector3[] normales = new Vector3[vertList.Count];
188        for (int i = 0; i &lt; normales.Length; i++)
189            normales[i] = vertList[i].normalized;
190
191
192        mesh.normals = normales;
193
194        if (invert) {
195            // Reverse the triangles
196            int[] triangles = mesh.triangles;
197            for (int i = 0; i &lt; triangles.Length; i += 3) {
198                int j = triangles[i];
199                triangles[i] = triangles[i + 2];
200                triangles[i + 2] = j;
201            }
202            mesh.triangles = triangles;
203
204            // Reverse the normals;
205            Vector3[] normals = mesh.normals;
206            for (int i = 0; i &lt; normals.Length; i++)
207                normals[i] = -normals[i];
208            mesh.normals = normals;
209        }
210
211        mesh.RecalculateBounds();
212        mesh.Optimize();
213
214        if (randomize)
215            mesh.vertices = Randomize(mesh.vertices);
216    }
217
218    Vector3[] Randomize(Vector3[] verts) {
219
220        for (int x = 0; x &lt; verts.Length; x++) {
221            Vector3 newPos = verts[x] * Random.Range(0.95f, 1.03f);
222            verts[x] = newPos;
223        }
224
225            return verts;
226    }
227 }</pre></div><p>Most of this script is the algorithm for generating the icosahedron sphere. Then, at the end is our <code class="literal">Randomize</code> function but without the vertex grouping functionality. Despite the size of the script, it only requires a brief explanation of its components. It is left to you to research and understand the mathematics behind geometrically constructing an icosahedron. Let's take a quick look at <span class="emphasis"><em>Code snip 9.5</em></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Lines 8-18</code>: The struct <code class="literal">TriangleIndices</code> is used as a helper class to store information on the triangles of the icosahedron.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 20-27</code>: Here, we <a id="id414" class="indexterm"></a>set a reference to the Mesh and set some public variables that will be used to determine the properties of the spheres:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">bool randomize</code> will be set if we wish to randomize the location of the vertices to create a terrain.</p></li><li style="list-style-type: disc"><p><code class="literal">bool offset</code> will be set if we want to offset the sphere slightly so that they aren't perfectly aligned. We will do this with the land to make one or more sides of the planet terrain heavy.</p></li><li style="list-style-type: disc"><p><code class="literal">bool invert</code> will invert the triangles so the material is drawn on the inside of the sphere. This will be used for the sky.</p></li><li style="list-style-type: disc"><p><code class="literal">float rad</code> is the radius of the sphere.</p></li><li style="list-style-type: disc"><p><code class="literal">int detail</code> is how many triangles we want to generate in the sphere. This is a multiplier, not a value.</p></li><li style="list-style-type: disc"><p><code class="literal">MeshCollider</code> <code class="literal">meshCollider</code> will determine if characters can walk on the mesh or not.</p></li></ul></div></li><li style="list-style-type: disc"><p><code class="literal">Lines 43-64</code>: The <code class="literal">Offset</code> function will run if offset is set to <code class="literal">true</code>. This function will randomly choose a number that corresponds to a direction in which the sphere will be offset, either <code class="literal">-X</code>, <code class="literal">X</code>, <code class="literal">-Y</code>, <code class="literal">Y</code>, <code class="literal">-Z</code>, or <code class="literal">Z</code>. Then, the sphere is offset in that direction by a small random amount. This will make the land appear through the water more on one side than the other.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 67-97</code>: <code class="literal">GetMiddlePoint</code> is a helper function to the <code class="literal">Create</code> function. It is used as an interpolation method. This function will return the point at which an edge can be split into two separate edges.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 99-216</code>: The <code class="literal">Create</code> method runs the icosahedron generation and interpolation into a sphere.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 218-226</code>: Last is our <code class="literal">Randomize</code> function without the vertex grouping, which is a much faster solution given the appropriate amount of memory</p></li></ul></div><p>Now, we can add this script to each of our empty GameObjects, <code class="literal">Land1</code>, <code class="literal">Land2</code>, <code class="literal">Water</code>, and <code class="literal">Sky</code>. Each one will have a different use of the public properties. So, after you add the script to each object, set these property values.</p><p>For <code class="literal">Land1</code> and <code class="literal">Land2</code>, set the following values:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Check <span class="strong"><strong>Randomize</strong></span></p></li><li style="list-style-type: disc"><p>Check <span class="strong"><strong>Offset</strong></span></p></li><li style="list-style-type: disc"><p>Set <span class="strong"><strong>Rad</strong></span> to <code class="literal">5</code></p></li><li style="list-style-type: disc"><p>Set <span class="strong"><strong>Detail</strong></span> to <code class="literal">2</code></p></li><li style="list-style-type: disc"><p>Add the <code class="literal">Mesh Collider</code> component to the <code class="literal">Mesh Collider</code> field</p></li></ul></div><p>For <code class="literal">Water</code>, set the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Set <span class="strong"><strong>Rad</strong></span> to <code class="literal">4.92</code></p></li><li style="list-style-type: disc"><p>Set <span class="strong"><strong>Detail</strong></span> to <code class="literal">5</code></p></li></ul></div><p>For Sky, set the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Check <span class="strong"><strong>Invert</strong></span></p></li><li style="list-style-type: disc"><p>Set <span class="strong"><strong>Rad</strong></span> to <code class="literal">6.5</code></p></li><li style="list-style-type: disc"><p>Set <span class="strong"><strong>Detail</strong></span> to <code class="literal">5</code></p></li></ul></div><p>Make sure that the empty objects are in view of the camera and give it a play. You should see your very own procedurally <a id="id415" class="indexterm"></a>generated planet. You can experiment with the properties or add more objects to see what happens.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_09_07.jpg" /><div class="caption"><p>Procedurally generated planet</p></div></div></div>