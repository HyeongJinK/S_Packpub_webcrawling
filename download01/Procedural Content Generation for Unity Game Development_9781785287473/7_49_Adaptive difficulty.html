<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec49"></a>Adaptive difficulty</h2></div></div><hr /></div><p>Adaptive difficulty can be a content generation solution by having enemies carry improved equipment or <a id="id314" class="indexterm"></a>changing enemy properties such as color and textures. It can also be an Artificial Intelligence question. This is similar to choosing the hard mode at the beginning of a game except, you, the game creator, determine when to engage the hard mode based on some gameplay aspect.</p><p>We have already done things such as swapping sprites and changing colors based on strength, so we will be exploring the AI route. We will determine what it takes to adapt the difficulty to the player by changing the AI of the enemy. Eventually, the player will become so strong that one hit from the player will destroy an enemy. So, we want the enemies to be capable of overwhelming the player by getting to the player faster, more efficiently, and in greater numbers.</p><p>In order to do this, we will need to adjust the AI capabilities in the <code class="literal">Enemy</code> class. But first, we will set-up the flags that will determine when and how the difficulty advances. We will start in the <code class="literal">GameManager.cs</code> script. Add the following variables in <span class="emphasis"><em>Code Snip 7.9</em></span>:</p><div class="informalexample"><pre class="programlisting">1 public bool enemiesFaster = false;
2 public bool enemiesSmarter = false;
3 public int enemySpawnRatio = 20;</pre></div><p>The variables in <span class="emphasis"><em>Code Snip 7.9</em></span> signify the various advances in difficulty. <code class="literal">enemiesFaster</code> will trigger enemies to no longer skip a turn. <code class="literal">enemiesSmarter</code> will trigger the use of a more efficient enemy pathfinding algorithm. <code class="literal">enemySpawnRatio</code> will make it so enemies appear at a higher frequency.</p><p>We need to implement the <a id="id315" class="indexterm"></a>actual trigger events for these flags now. Every difficulty advancement event is triggered by the player getting stronger. So, we will be placing the event handlers in the <code class="literal">Player.cs</code> script. <span class="emphasis"><em>Code Snip 7.10</em></span> shows the changes needed to run the adaptive difficulty events:</p><div class="informalexample"><pre class="programlisting">1 private void AdaptDifficulty () {
2   if (wallDamage &gt;= 10)
3     GameManager.instance.enemiesSmarter = true;
4   if (wallDamage &gt;= 15)
5     GameManager.instance.enemiesFaster = true;
6   if (wallDamage &gt;= 20)
7     GameManager.instance.enemySpawnRatio = 10;
8 }
9   
10 private void OnTriggerEnter2D (Collider2D other) {
11   if (other.tag == "Exit") {
12     dungeonTransition = true;
13     Invoke ("GoDungeonPortal", 0.5f);
14     Destroy (other.gameObject);
15   } else if (other.tag == "Food" || other.tag == "Soda") {
16    UpdateHealth(other);
17    Destroy (other.gameObject);
18  } else if (other.tag == "Item") {
19    UpdateInventory(other);
20    Destroy (other.gameObject);
21    AdaptDifficulty ();
22  } else if (other.tag == "Weapon") {
23    if (weapon) {
24      Destroy(transform.GetChild(0).gameObject);
25    }
26    other.enabled = false;
27    other.transform.parent = transform;
28    weapon = other.GetComponent&lt;Weapon&gt;();
29    weapon.AquireWeapon();
30    weapon.inPlayerInventory = true;
31    weapon.enableSpriteRender(false);
32    wallDamage = attackMod + 3;
33    weaponComp1.sprite = weapon.getComponentImage(0);
34    weaponComp2.sprite = weapon.getComponentImage(1);
35    weaponComp3.sprite = weapon.getComponentImage(2);
36    AdaptDifficulty ();
37  }
38 }</pre></div><p>The event handling for adapting the difficulty to the player's strength is pretty straightforward. First, we add a function called <code class="literal">AdaptDifficulty</code>, which will hold the cases for each difficulty <a id="id316" class="indexterm"></a>advancement. Then, we add that function call to whenever the player powers up, which for our game is when the player picks up an item or weapon. Let's see how this is done in the code:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Lines 1-8</code>: This is the <code class="literal">AdaptDifficulty</code> event handler function. We are watching to see the amount of damage the player can deal out. At a damage of 10, the enemies are shifted to a better AI; at 15, the enemies no longer skip a turn; and at 20, the enemies spawn more frequently.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 10-38</code>: The <code class="literal">OnTriggerEnter2D</code> function is used to handle item and weapon pickups.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 21</code>: We add the <code class="literal">AdaptDifficulty</code> function call on an item pickup because we will be calculating a new player damage here.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 36</code>: We also add the <code class="literal">AdaptDifficulty</code> function call on a weapon pickup because we will be calculating a new player damage here as well.</p></li></ul></div><p>Finally, we need to implement the actual events including the better AI functionality. To start off, we should discuss how we plan to implement the said better AI. Luckily, the current AI isn't very complex and improving it won't be difficult.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec41"></a>Enemy AI</h3></div></div></div><p>The current AI can be viewed in the <a id="id317" class="indexterm"></a>
<code class="literal">Enemy.cs</code> script under the <code class="literal">MoveEnemy</code> function. The AI performs a check on the player position. If the enemy is on the same <span class="emphasis"><em>x</em></span> coordinate <a id="id318" class="indexterm"></a>as the player, then the enemy will move towards the player in the <span class="emphasis"><em>y</em></span> direction. Otherwise, the enemy will move towards the player in the <span class="emphasis"><em>x</em></span> direction.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_07_07.jpg" /><div class="caption"><p>Diagram of simple enemy movement</p></div></div><p>This means that the enemy doesn't try to get around walls. The enemy is easily stuck making it fairly easy<a id="id319" class="indexterm"></a> for the player to flee. This is perfect in the beginning of the game when the player does very little damage. So our objective is to make it<a id="id320" class="indexterm"></a> harder for the player to flee when the player becomes strong enough to take on enemy encounters.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_07_08.jpg" /><div class="caption"><p>Enemy stuck on wall</p></div></div><p>We have an event that will make the enemy move every turn the player moves. This will decrease the opportunity the player has to get an enemy stuck behind a wall. Then, all our improved AI has to do is add some checks that will allow our enemy to navigate around walls. We can also perform some simple pathfinding that will have our enemy seek to close the distance between it and the player.</p><p>Let's begin by <a id="id321" class="indexterm"></a>selecting a more effective move an enemy can make. The player will be some distance away from the enemy on both the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes. Neither the player nor the enemy can move diagonally, so we can calculate the distance between<a id="id322" class="indexterm"></a> them on the <span class="emphasis"><em>x</em></span> axis separate from the <span class="emphasis"><em>y</em></span> axis. Once we know how many spaces we need to move horizontally and vertically to get to the player, we can make an informed decision on which direction we should take.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_07_09.jpg" /><div class="caption"><p>Player is 1 space away horizontally and 2 away vertically so enemy moves vertically</p></div></div><p>The path with the greater distance will be the preferred path because we want the enemy to reach the player as fast as he can. After we have chosen a direction, we need to check that the enemy isn't going to hit anything in that direction. So, we'll check the neighbor cell and see what's in the enemy's way. If there's an obstacle, then we will switch to the next best direction.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_07_10.jpg" /><div class="caption"><p>Enemy going around wall</p></div></div><p>For simplicity, we'll <a id="id323" class="indexterm"></a>only go as far as giving the enemy two attempts to pick the best path. As discussed earlier in the book, pathfinding can be a very complex<a id="id324" class="indexterm"></a> topic on its own. This algorithm alone will make for a much more challenging game already.</p><div class="mediaobject"><img src="/graphics/9781785287473/graphics/B04808_07_11.jpg" /><div class="caption"><p>Smarter enemy getting stuck on a wall after two attempts of picking the best path</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec42"></a>Finishing up</h3></div></div></div><p>So, now that we know what we<a id="id325" class="indexterm"></a> want to accomplish, let's begin the implementation. Open the <code class="literal">Enemy.cs</code> script for editing. <span class="emphasis"><em>Code Snip 7-10</em></span> shows the changes needed for our adaptive difficulty:</p><div class="informalexample"><pre class="programlisting">1 protected override bool AttemptMove &lt;T&gt; (int xDir, int yDir) {
2   if(skipMove &amp;&amp; !GameManager.instance.enemiesFaster){
3     skipMove = false;
4     return false;
5   }
6   base.AttemptMove &lt;T&gt; (xDir, yDir);
7    
8   skipMove = true;
9   return true;
10 }
11  
12 public void MoveEnemy () {
13  int xDir = 0;
14  int yDir = 0;
15
16  if (GameManager.instance.enemiesSmarter) {
17    int xHeading = (int)target.position.x - (int)transform.position.x;
18    int yHeading = (int)target.position.y - (int)transform.position.y;
19    bool moveOnX = false;
20
21    if (Mathf.Abs(xHeading) &gt;= Mathf.Abs(yHeading)) {
22      moveOnX = true;
23    }
24    for (int attempt = 0; attempt &lt; 2; attempt++) {
25      if (moveOnX == true &amp;&amp; xHeading &lt; 0) {
26        xDir = -1; yDir = 0;
27      }
28      else if (moveOnX == true &amp;&amp; xHeading &gt; 0) {
29        xDir = 1; yDir = 0;
30      }
31      else if (moveOnX == false &amp;&amp; yHeading &lt; 0) {
32        yDir = -1; xDir = 0;
33      }
34      else if (moveOnX == false &amp;&amp; yHeading &gt; 0) {
35        yDir = 1; xDir = 0;
36      }
37
38      Vector2 start = transform.position;
39      Vector2 end = start + new Vector2 (xDir, yDir);
40      base.boxCollider.enabled = false;
41      RaycastHit2D hit = Physics2D.Linecast (start, end, base.blockingLayer);
42      base.boxCollider.enabled = true;
43
44      if (hit.transform != null) {
45        if (hit.transform.gameObject.tag == "Wall" || hit.transform.gameObject.tag == "Chest") {
46          if (moveOnX == true)
47            moveOnX = false;
48          else 
49            moveOnX = true;
50        } else {
51          break;
52        }
53      }
54    }
55
56  } else {
57    if (Mathf.Abs (target.position.x - transform.position.x) &lt; float.Epsilon)
58      yDir = target.position.y &gt; transform.position.y ? 1 : -1;
59    else
60.      xDir = target.position.x &gt; transform.position.x ? 1 : -1;
61  }
62  AttemptMove &lt;Player&gt; (xDir, yDir);
63
64 }</pre></div><p>We'll start by handling the enemy speed-up event. Then, we'll move on to discuss the improved AI event. Let's take a look at the details of the implementation in <span class="emphasis"><em>Code Snip 7.10</em></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Line 2</code>: We are <a id="id326" class="indexterm"></a>adding a second condition to the move skip of the enemy. We will also be checking whether the <code class="literal">enemyFaster</code> flag has been set and if so, we do not skip a move.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 16</code>: We are going to start things off in the <code class="literal">MoveEnemy</code> function by checking whether the <code class="literal">enemySmarter</code> flag has been set. If so, we will move into our better pathfinding algorithm for our <code class="literal">Enemy</code> class.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 17-18</code>: We'll calculate the distance from the player to the enemy on the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axis . This can be a negative value, which will tell us if we need to move left (negative x) or down (negative y). A positive value is right (positive x) or up (positive y).</p></li><li style="list-style-type: disc"><p><code class="literal">Line 19</code>: The <code class="literal">moveOnX</code> bool variable will tell us if we need to move horizontal (true) or vertical (false).</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 21-23</code>: Here, we will check the magnitude of the x and y distances. Remember, we want the enemy to try to take the longer of the two distances to close the gap between the enemy and player.</p></li><li style="list-style-type: disc"><p><code class="literal">Line 24</code>: We want to only make two attempts at picking an optimal path, so we set a <code class="literal">for</code> loop to run the decision-making process a second time, if need be.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 25-36</code>: This block will determine which direction the enemy will move in. The <code class="literal">moveOnX</code> variable will tell the enemy to move horizontally or not. The <code class="literal">xHeading</code> and <code class="literal">yHeading</code> will tell the enemy to move in the positive or negative direction.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 38-42</code>: We then check whether there is a wall in the way of the direction we have chosen to move in. We do this with <code class="literal">RayCastHit2D</code> in the same manner we have done in the <code class="literal">Player</code> and <code class="literal">MovingObject</code> classes.</p></li><li style="list-style-type: disc"><p><code class="literal">Lines 44-53</code>: Lastly, we are going to check whether we hit anything by checking the transform of the hit variable. If we did hit something, we need to determine whether it is a wall or chest because otherwise, we hit the player. If we did hit a wall or chest, we are going to switch the <code class="literal">moveOnX</code> variable to try a different direction of movement. If we didn't hit anything or we hit the player, we break our <code class="literal">for</code> loop and continue with the rest of the game execution.</p></li></ul></div><p>We have just a few more changes to make. In order for this algorithm to work properly in the dungeon, we need to set the OuterWall prefabs' tag to <span class="strong"><strong>Wall</strong></span>. We also need to handle the increased frequency of spawning enemy events. This will be done in the <code class="literal">BoardManager.cs</code> script.</p><p>We only need to change one line in the <code class="literal">BoardManager.cs</code> script. Inside the <code class="literal">addTiles</code> function, change the line <code class="literal">else if (Random.Range (0,20) == 1)</code> to <code class="literal">else if (Random.Range (0, GameManager.instance.enemySpawnRatio) == 1)</code>. This makes the enemy spawn<a id="id327" class="indexterm"></a> ratio based on the <code class="literal">GameManager</code> variable that will change as the player gains strength.</p><p>With all of that complete, you can test the full adaptive difficulty functionality. You first need to survive long enough to get a weapon and high-level items to trigger the adaptive difficulty. You can use the <span class="strong"><strong>Inspector</strong></span> tab to verify that all the flags have been set and you can visually verify that the algorithms have taken effect.</p></div></div>