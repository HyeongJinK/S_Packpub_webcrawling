<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec42"></a>Pathfinding and obstacle detection with navMesh</h2></div></div><hr /></div><p>NavMesh is Unity's pathfinding<a id="id590" class="indexterm"></a> system. It works by defining the<a id="id591" class="indexterm"></a> navigable areas of the game level, storing this as a simple mesh. Once areas that can be accessed are defined, the navMesh is baked like a lightmap.</p><p>This system offers numerous advantages over waypoint systems. Firstly, it allows an AI character to roam freely within a level.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the scene <code class="literal">Chapter9_nav_Start</code>.</p><p>The scene contains the office environment with a navMesh already baked. The steps taken to set this up are well documented on the Unity website.</p><p>We can view the generated navMesh by activating the <span class="strong"><strong>Navigation</strong></span> panel.</p></li><li><p>From the menu bar, choose <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Navigation</strong></span>.</p></li></ol></div><p>The <span class="strong"><strong>Navmesh Display</strong></span> box will appear in the lower right of the <span class="strong"><strong>Scene</strong></span> view.</p><p>By default, the<a id="id592" class="indexterm"></a> <span class="strong"><strong>Show NavMesh</strong></span> checkbox should be checked and the <a id="id593" class="indexterm"></a>walkable areas of the game level will be displayed in blue:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_09.jpg" /></div><p>In the scene, the patrol points have been placed to make a more complex route for the zombie. If you press the <span class="strong"><strong>Play</strong></span> button at this point, you will see the zombie walk toward the first point as before.</p><p>When she walks toward the second point, she will get stuck as it is not directly in view. We can solve this using Unity's navigation.</p><p>Next, we will add the component that will allow the zombie to use the navMesh:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, select the <code class="literal">zombie_f_nav</code> game object.</p></li><li><p>Add a navMesh agent component from the menu bar by navigating to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Navigation</strong></span> | <span class="strong"><strong>Nav Mesh Agent</strong></span>.</p><p>The navMesh agent defines how the character moves around the space. It has a <code class="literal">radius</code> variable, which controls how close the zombie will get to scenery. It also has <code class="literal">speed</code> and <code class="literal">turning</code> variables that we will need to set in our script.</p><p>If we test the game at this point, there will be no apparent change, as the navMesh <a id="id594" class="indexterm"></a>agent requires a goal (or destination) to be set in a script so that a route can be calculated.</p></li><li><p>In the<a id="id595" class="indexterm"></a> <span class="strong"><strong>Project</strong></span> panel, locate the <code class="literal">PACKT_Scripts</code> folder and click on it once to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Open the <code class="literal">zombie_nav_Start</code> script in MonoDevelop by double-clicking on it in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Add the following variables to the others, near the top of the script:</p><div class="informalexample"><pre class="programlisting">var zAgent : NavMeshAgent;
var navSpeed : float = 1.0;</pre></div><p>In the <code class="literal">zAgent</code> variable, we will be storing the navMesh agent so that we can send it other variables. We will use <code class="literal">navSpeed</code> to keep the speed of the navigation updated.</p><p>In the <code class="literal">Start</code> function, we will initialize <code class="literal">NavMeshAgent</code> the same way that we have done with the character controller and animator.</p></li><li><p>Add the following lines of code inside the <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">zAgent = GetComponent(NavMeshAgent);</pre></div><p>The navMesh agent needs an initial target position to be able to run.</p></li><li><p>Add the following code to the bottom of the function:</p><div class="informalexample"><pre class="programlisting">targetedPt = patrolPts[currPt];
zAgent.destination = targetedPt.position;</pre></div><p>Here, we designate the <code class="literal">targetedPt</code> as the current patrol point. We then define the navMesh agent's destination variable as the <code class="literal">targetedPt</code> variable's position.</p><p>We also need to make sure that the destination changes when the zombie reaches the patrol point.</p></li><li><p>Add the following<a id="id596" class="indexterm"></a> line to the top of the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">zAgent.destination = targetedPt.position;</pre></div><p>This will be sufficient for the zombie to use the navigation. If you press <span class="strong"><strong>Play</strong></span> at this point, you will see the zombie move rapidly between the two points.</p><p>The navMesh agent has its own internal speed variable. We can keep this the same as the zombie's adjusted walk speed.</p></li><li><p>Add the <a id="id597" class="indexterm"></a>following code to the <code class="literal">Start</code> function, directly after the last line that we added:</p><div class="informalexample"><pre class="programlisting">zAgent.speed = navSpeed;</pre></div><p>We initialize the navMesh agent's <code class="literal">speed</code> variable, setting it to the value of <code class="literal">navSpeed</code>. Next, we need to keep this the same as the zombie's adjusted speed value, which changes with the animation.</p></li><li><p>Add the following code to the <code class="literal">Update</code> function, directly after the last line that we added:</p><div class="informalexample"><pre class="programlisting">navSpeed = speed;</pre></div></li></ol></div><p>The zombie will now walk between the patrol points with the corrected speed, but it is not currently being adjusted when she is idling or turning.</p><p>The solution is to temporarily suspend the navigation while the zombie is turning.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec78"></a>Suspending navigation during the turn</h3></div></div></div><p>At this point, we<a id="id598" class="indexterm"></a> need to slow the zombie down so that she can turn. The best way to do this is to temporarily switch off the navigation.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <code class="literal">Update</code> function, locate the <code class="literal">if(ptDistance &lt;= changeDistance)</code> statement.</p><p>The code contained within this statement will run whenever the zombie comes within the defined range of the patrol point.</p></li><li><p>Add the following <a id="id599" class="indexterm"></a>code inside the statement's curly brackets:</p><div class="informalexample"><pre class="programlisting">zAgent.Stop();</pre></div><p>The navMesh agent's <code class="literal">Stop</code> function will suspend the navigation. We need to resume navigation once the zombie has turned toward the next point.</p></li><li><p>Scroll down to the <code class="literal">WalkTowards</code> function and add the following code at the start:</p><div class="informalexample"><pre class="programlisting">zAgent.Resume();</pre></div></li><li><p>Save the script.</p></li></ol></div><p>If we test the game at this point, we should see the zombie's speed slow long enough for her to execute the turn. If the player comes within range, her attack is relentless and she will pursue the player until she is dead.</p><p>In the next step, we will temporarily suspend the navigation while the attack takes place and give the player a chance to escape.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec79"></a>Adjusting navigation during the attack</h3></div></div></div><p>Currently, when the<a id="id600" class="indexterm"></a> zombie's attack is initiated, she continues to move toward the player. We can suspend this in the same way that we did for the turn:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <code class="literal">Update</code> function, locate the <code class="literal">if(attacking)</code> statement.</p></li><li><p>Add the following code inside the statement's curly brackets and before the other code:</p><div class="informalexample"><pre class="programlisting">zAgent.Stop();</pre></div></li></ol></div><p>The <code class="literal">WalkTowards</code> function, which runs following the attack, is already setup to resume navigation. If we test the game at this point, the zombie will stop chasing the player when she starts the attack.</p><p>The code is currently set up to damage the player whether he is close to the zombie or far away, so we need to add another condition to make sure that the player is close enough to be hurt.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec80"></a>Modifying the Attack function</h4></div></div></div><p>Here, we will <a id="id601" class="indexterm"></a>modify the attack to ensure the player is only hurt when he is close enough for the zombie to reach him:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Near the top of the script, add the following variable:</p><div class="informalexample"><pre class="programlisting">var playerDamaged : boolean = false;</pre></div><p>The boolean variable <code class="literal">playerDamaged</code> will be used as a flag to see if the player is currently being hurt in the attack.</p><p>We only want the player to lose 2 points of health per attack, not to be hurt continuously during the time the attack takes place.</p></li><li><p>In the <code class="literal">Update</code> function, locate the following <code class="literal">if</code> statement:</p><div class="informalexample"><pre class="programlisting">if(attackTimer &lt;= 0.0)</pre></div></li><li><p>Add the following code inside the curly brackets of the statement:</p><div class="informalexample"><pre class="programlisting">playerDamaged = false;</pre></div></li><li><p>Directly after the <code class="literal">if</code> statement, add the following code:</p><div class="informalexample"><pre class="programlisting">if(attackTimer &gt; 0.7 &amp;&amp; playerDistance &lt;= attackRange &amp;&amp; !playerDamaged)
{
    DamagePlayer();
}</pre></div><p>Here we check that the attack has been going for <code class="literal">0.7</code> seconds, the <code class="literal">playerDistance</code> object is within <code class="literal">attackRange</code>, and the player is not already being damaged.</p><p>These are the conditions that need to be met before we damage the player. We move the actual damaging into its own function, <code class="literal">DamagePlayer</code>.</p></li><li><p>Scroll down to the <code class="literal">Attack</code> function and locate the last two lines of code: </p><div class="informalexample"><pre class="programlisting">var playerStatus = target.Find("FirstPersonCharacter/player_m");
playerStatus.SendMessage("AddDamage", damage);</pre></div></li><li><p>Select the lines and delete them from the function.</p></li><li><p>After the closing curly bracket of the function, add the following code: </p><div class="informalexample"><pre class="programlisting">function DamagePlayer()
{
    playerDamaged = true;
    var playerStatus = target.Find("FirstPersonCharacter/player_m");
    playerStatus.SendMessage("AddDamage", damage);
}</pre></div><p>Here, we set the boolean <code class="literal">playerDamaged</code> to <code class="literal">true</code>.</p><p>Next, we add the lines that we deleted from the <code class="literal">Attack</code> function, connecting to the player status script and applying the damage.</p></li><li><p>Save the script.</p></li></ol></div><p>If we test the game<a id="id602" class="indexterm"></a> at this point, we should be able to slip away from the zombie without being damaged after she starts the attack:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_10.jpg" /></div><p>Zombies are forgetful creatures; it would be good to allow a zombie to forget about the player after he has been out of range for long enough. We can add this feature to the AI script next.</p></div></div></div>