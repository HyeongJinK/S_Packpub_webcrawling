<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec20"></a>Adding and implementing collectable objects</h2></div></div><hr /></div><p>Typically, in a game, the player will be able to collect power-ups to increase their effectiveness, or to<a id="id237" class="indexterm"></a> replace depleted life or energy.</p><p>In this game, our player<a id="id238" class="indexterm"></a> will collect food to boost his health. This stage will involve adding a collectable and making the player react with a suitable animation sequence.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec32"></a>Instantiating the lunchBox collectable in the game level</h3></div></div></div><p>Our first collectable is<a id="id239" class="indexterm"></a> already set up as a prefab in the project files, making it easy to drag and drop into our game level without having to add components and set variables:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, locate the <code class="literal">PACKT_Prefabs</code> folder.</p></li><li><p>Click to expand the <code class="literal">Pickups</code> subfolder and locate the <code class="literal">lunchBox</code> prefab.</p></li><li><p>Drag <code class="literal">lunchBox</code> into the <span class="strong"><strong>Hierarchy</strong></span> panel to instantiate it.</p></li><li><p>Position the prefab and navigate within the <span class="strong"><strong>Scene</strong></span> view until it is clearly visible:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_03_10.jpg" /></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec37"></a>Inspecting the lunchBox collectable's components</h4></div></div></div><p>The <code class="literal">lunchBox</code> prefab is a game object with a few components attached. We will take a look and see how it<a id="id240" class="indexterm"></a> has been assembled. For doing so click the instantiated <code class="literal">lunchBox</code> in the <span class="strong"><strong>Hierarchy</strong></span> panel to examine it a little more closely.</p><p>The prefab consists<a id="id241" class="indexterm"></a> of the actual geometry, along with a point light to make it more visible within the game level. It also has a simple script which will allow us to add some functionality when it is collected.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec09"></a>Looking at the collectable script</h5></div></div></div><p>We already made a start on the player animation script. The code that we need for the collectable is also <a id="id242" class="indexterm"></a>quite simple. The basic script has already been set up, but we will need to add to it, to get the <code class="literal">lunchBox</code> game object to function properly in the level:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click the <code class="literal">PACKT_Scripts</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Double-click <code class="literal">Collectable</code> to open it in MonoDevelop. The script will appear as follows:</p><div class="informalexample"><pre class="programlisting">var sound : AudioClip;

function OnTriggerEnter (other : Collider)
{

    if (sound)
    {
    AudioSource.PlayClipAtPoint(sound, transform.position);
    }
}</pre></div></li></ol></div><p>This script is a typical definition of a power-up or a booby trap, which affects the player's status or score in some way.</p><p>It uses the <code class="literal">OnTriggerEnter</code> built-in function to set trigger code to run when the player enters its collider. The script is currently set up to play a sound effect.</p><p>Next we will <a id="id243" class="indexterm"></a>add more code to ensure that the collectable game object destroys itself, preventing the player from triggering it (and receiving its benefits) again.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec10"></a>Implementing self destruction in the collectable script</h5></div></div></div><p>Code placed<a id="id244" class="indexterm"></a> in the <code class="literal">Update</code> function runs every frame, so ideally we want to set up new functions for code that is to run only once:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following lines of code to the bottom of the script:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>function Remove()</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>        Destroy(gameObject);</strong></span>
<span class="strong"><strong>    }</strong></span>
</pre></div><p>
<code class="literal">Remove</code> is a new custom function. It removes the instanced prefab from the game. It happens instantly, so any particle or sound effects should be added to the preceding function.</p><p>We still need to run this function at the end of <code class="literal">OnTriggerEnter</code>.</p></li><li><p>Before the last curly bracket in the <code class="literal">OnTriggerEnter</code> function, add the following line:</p><div class="informalexample"><pre class="programlisting">Remove();</pre></div></li><li><p>Save the script and add it to the <code class="literal">lunchBox</code> prefab by dragging it onto the instance in the <span class="strong"><strong>Hierarchy</strong></span> panel or the <span class="strong"><strong>Inspector</strong></span> panel<span class="strong"><strong>.</strong></span>
</p></li><li><p>Test the script by positioning the instantiated <code class="literal">lunchBox</code> a few meters from the player character game object.</p></li><li><p>Click the <span class="strong"><strong>Game</strong></span> view tab in the top center of the Unity interface and deselect the <span class="strong"><strong>Maximize on Play</strong></span> button by clicking it.</p></li><li><p>Press the <span class="strong"><strong>Play</strong></span> button.</p></li><li><p>Move the <a id="id245" class="indexterm"></a>player character towards the <code class="literal">lunchBox</code> collectable.</p><p>The lunchbox will disappear (from the <span class="strong"><strong>Scene</strong></span> view and the <span class="strong"><strong>Hierarchy</strong></span> panel) when contact is made:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_03_11.jpg" /></div></li></ol></div><p>In the next section we will be setting up the player character's response when the <code class="literal">lunchBox</code> is collected.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec33"></a>Setting up the player character's response</h3></div></div></div><p>We will start by <a id="id246" class="indexterm"></a>adding an<a id="id247" class="indexterm"></a> additional state to the player character's animator controller.</p><p>Unlike with the shoot animation, the pickup animation will only run when the character is in collision with the <code class="literal">lunchBox</code>. We will need to stop other animations playing to enable the pickup animation to play through.</p><p>In order to view this animation, we will create an additional camera and set it up to become active for the duration of the animation sequence. Lastly, we will implement a very simple <a id="id248" class="indexterm"></a>player status script so<a id="id249" class="indexterm"></a> that we can see the character's health value increase when he collects the <code class="literal">lunchBox</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec38"></a>Adding the Pickup state to the animator controller</h4></div></div></div><p>As we are <a id="id250" class="indexterm"></a>adding a new<a id="id251" class="indexterm"></a> animation sequence, we need to add a new state to contain this:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, click to select <code class="literal">player_m</code>.</p></li><li><p>Click the <span class="strong"><strong>Animator</strong></span> tab in the top center of the Unity interface to view the selected object's animator controller.</p></li><li><p>Right-click somewhere in the empty space to create a new state by navigating to <span class="strong"><strong>Create State</strong></span> | <span class="strong"><strong>Empty</strong></span>.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, rename this state <code class="literal">Pickup</code>.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click the <code class="literal">PACKT_Animations</code> folder to expose its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate the <code class="literal">pickup</code> subfolder and click it to view its contents.</p></li><li><p>Drag the <code class="literal">pickup</code> animation (identified by the gray play button icon) into the <span class="strong"><strong>Pickup</strong></span> state's <span class="strong"><strong>motion</strong></span> field in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li></ol></div><p>Having specified the animation sequence used in the state, we need to set the transitions and parameter that will activate this state.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec11"></a>Setting the Pickup state's transitions and parameter</h5></div></div></div><p>Importantly, the new <span class="strong"><strong>Pickup</strong></span> state will only be connected by transitions to the <span class="strong"><strong>ShootIdle</strong></span> state, otherwise <a id="id252" class="indexterm"></a>we risk overriding the player's attack.</p><p>Imagine that the player character is backing away from a horde of zombies rushing towards him, when he stumbles over <code class="literal">lunchBox</code> and has to stop shooting to pick it up!</p><p>Prioritizing player states is an important factor when considering game play. Mecanim makes this really easy because it shows us exactly how the character's states connect.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch03lvl5sec04"></a>Transitioning between the ShootIdle and Pickup states</h6></div></div></div><p>States can have multiple transitions connecting them to other states. For the moment, our <span class="strong"><strong>Pickup</strong></span> state only needs to<a id="id253" class="indexterm"></a> be connected to the <span class="strong"><strong>ShootIdle</strong></span> state:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Animator</strong></span> window, right-click the <span class="strong"><strong>ShootIdle</strong></span> state and choose <span class="strong"><strong>Make Transition</strong></span>.</p></li><li><p>Drag the transition line to the <span class="strong"><strong>Pickup</strong></span> state and click on it to complete the transition.</p></li><li><p>Create the return transition in the same way from the <span class="strong"><strong>Pickup</strong></span> state to the <span class="strong"><strong>ShootIdle</strong></span> state.</p></li></ol></div><p>The new transitions are connecting the states, but currently have default settings. Next we need to add an appropriate parameter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="ch03lvl5sec05"></a>Creating and adding the parameter</h6></div></div></div><p>Like variables in a <a id="id254" class="indexterm"></a>script, parameters created in the animator controller can be used multiple times. Here we will create another <span class="strong"><strong>Trigger</strong></span> parameter that will <a id="id255" class="indexterm"></a>switch the <span class="strong"><strong>Pickup</strong></span> state on:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Parameters</strong></span> box, click the <span class="strong"><strong>+</strong></span> symbol to create a new parameter.</p></li><li><p>Choose <span class="strong"><strong>Trigger</strong></span>.</p></li><li><p>Name the new parameter <code class="literal">Picking</code> and leave its radio button deactivated.</p></li><li><p>Click the <span class="strong"><strong>Idle</strong></span> to <span class="strong"><strong>Pickup</strong></span> transition.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, scroll down until you see the <span class="strong"><strong>Conditions</strong></span> box.</p></li><li><p>Set the condition to <code class="literal">Picking</code>, and make sure that the Boolean marker is set to <span class="strong"><strong>True</strong></span>.</p></li></ol></div><p>This will ensure that the <span class="strong"><strong>Pickup</strong></span> state is only activated when the <code class="literal">Picking</code> is triggered:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_03_12.jpg" /></div><p>The next step<a id="id256" class="indexterm"></a> will involve creating the new camera that we will <a id="id257" class="indexterm"></a>use during the pickup animation.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec39"></a>Creating the pickup camera</h4></div></div></div><p>We will add a new <a id="id258" class="indexterm"></a>camera to view the player character's pickup animation sequence more clearly. Briefly switching cameras will make it unnecessary for us to alter the main camera script, which is used throughout the majority of the game level. It will also make it obvious to the player that the character is picking up an item:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a <code class="literal">Camera</code> game object by navigating to <span class="strong"><strong>Game Object</strong></span> | <span class="strong"><strong>Create Other</strong></span> | <span class="strong"><strong>Camera</strong></span>.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, rename the game object <code class="literal">pickupCamera</code>.</p></li><li><p>Delete all of the game object's components except <span class="strong"><strong>Camera</strong></span>.</p><p>When we setup the first-person camera, we reduced the near clipping planes so that the player geometry would not be clipped out. We need to do the same thing for the <code class="literal">pickupCamera</code>.</p></li><li><p>In the <span class="strong"><strong>Camera</strong></span> component's settings in the <span class="strong"><strong>Inspector</strong></span> panel, set the <span class="strong"><strong>Near</strong></span> clipping plane value to <code class="literal">0.05</code>.</p><p>As we want this camera to render on top of the first-person camera we need to give it a higher priority.</p></li><li><p>Further down in the <span class="strong"><strong>Inspector</strong></span> panel, set the <span class="strong"><strong>Camera</strong></span> component's <span class="strong"><strong>Depth</strong></span> value to <code class="literal">1</code>.</p><p>This makes it unnecessary to deactivate the first-person camera when we temporarily switch to the pickup camera. This also means that we do not need an additional audio listener component to hear any sounds which are played.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, locate the <code class="literal">PACKT_Scripts</code> folder and click it, to view its contents<a id="id259" class="indexterm"></a> in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Drag the <code class="literal">pickupCamera</code> script onto the <code class="literal">pickupCamera</code> game object that we just created.</p></li></ol></div><p>There are a few more steps to take to complete the pickup camera.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec40"></a>Finalizing the pickup camera prefab</h4></div></div></div><p>We will be changing<a id="id260" class="indexterm"></a> the position and rotation of the camera in our script, but we need a default target that the camera can point at:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a sphere game object in the scene by navigating to <span class="strong"><strong>Game Object</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Sphere</strong></span>.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel rename it <code class="literal">defaultTarget</code>.</p></li><li><p>Set the game object's scale <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> values to <code class="literal">0.1</code>.</p></li><li><p>Delete the <span class="strong"><strong>Sphere Collider</strong></span> component by right-clicking on the settings icon in the top-right corner of the component's parameter list and choosing <span class="strong"><strong>Remove Component</strong></span>.</p><p>We will keep the <span class="strong"><strong>Mesh Renderer</strong></span> component for now so we can make sure the target is lined up correctly.</p><p>We need to group the <code class="literal">pickupCamera</code> and <code class="literal">defaultTarget</code> together so they can be instantiated in the game.</p></li><li><p>Create a new empty game object by navigating to <span class="strong"><strong>Game Object</strong></span> | <span class="strong"><strong>Create Empty</strong></span>.</p></li><li><p>Rename the empty object <code class="literal">camParent</code>.</p></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, drag <code class="literal">pickupCamera</code> and then <code class="literal">defaultTarget</code> onto <code class="literal">camParent</code> to make them children of this game object.</p></li><li><p>Select each of the game objects and zero out their position and rotation values in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>Select <code class="literal">defaultTarget</code> and set its <span class="strong"><strong>Position Z</strong></span> value to <code class="literal">2</code>.</p></li><li><p>Check that it is positioned directly in front of the camera by selecting the camera<a id="id261" class="indexterm"></a> in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p><p>The camera's view will be displayed as an inset in the corner of the main <span class="strong"><strong>Scene</strong></span> view.</p><p>The <code class="literal">defaultTarget</code> should appear as a small sphere in the center of the view.</p></li><li><p>When you have verified where it should be, select it in the <span class="strong"><strong>Hierarchy</strong></span> and deactivate its mesh renderer by checking the box next to the <span class="strong"><strong>Mesh Renderer</strong></span> component.</p><p>Finally, we will save the whole hierarchy as a prefab, allowing it to be instantiated in the game when we need it.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click to select the <code class="literal">PACKT_Prefabs</code> folder.</p></li><li><p>Select the <code class="literal">camParent</code> game object in the <span class="strong"><strong>Hierarchy</strong></span> panel and drag it into an empty area of the <span class="strong"><strong>Assets</strong></span> panel.</p><p>The game object name will turn blue in the <span class="strong"><strong>Hierarchy</strong></span> panel, indicating that it is now an instance of a prefab. Delete the instance from the scene by selecting it and hitting <span class="emphasis"><em>Delete</em></span> (or <span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Delete</em></span> on a Mac).</p></li></ol></div><p>Next we will create a simple player status script to enable the player to get something from the pickup.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec41"></a>Looking at the player status script</h4></div></div></div><p>The player status<a id="id262" class="indexterm"></a> script keeps track of the player's current condition in the game. This often includes health and other numerical values that change during gameplay:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click to expand the <code class="literal">PACKT_Scripts</code> folder in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate <code class="literal">PlayerStatus</code> and double-click to open it in MonoDevelop.</p></li></ol></div><p>This is what we currently have in the <code class="literal">PlayerStatus</code> script:</p><div class="informalexample"><pre class="programlisting">var health : int = 10;
var healthLimit : int = 10;

function AddHealth (increase : int)
{
    health += increase;

    if (health &gt; healthLimit)
{
        health = healthLimit; 
   }

}

function AddDamage (damage : int)
{
    health-=damage;

    if (health &lt;= 0)
    {
<span class="strong"><strong>        </strong></span>Die();
    }
}
function Die()
{
    Debug.Log("You Died");
}</pre></div><p>The first variable, <code class="literal">health</code> sets the starting health value as an integer or whole number. Next, <code class="literal">healthMax</code> sets the maximum value that health can reach.</p><p>The custom function <code class="literal">AddHealth</code> increases the health value by an amount specified by the value increase which will be sent to the script.</p><p>The <code class="literal">if</code> statement <a id="id263" class="indexterm"></a>contained within the function will capture health with the <code class="literal">maxHealth</code> value so that it does not exceed this number even if the player picks up lots of lunchBoxes when we do not need them.</p><p>The custom function <code class="literal">AddDamage</code> works in the same way, but decrements health rather than increasing it using an integer value called <code class="literal">damage</code>. When health reaches zero we run the custom function <code class="literal">Die</code>.</p><p>No fancy effects at this point, just a message appearing in the console informing the player that he or she is dead. We can test this later on, but for now we will get back to the pickup<a id="id264" class="indexterm"></a> interaction.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec12"></a>Adding the PlayerStatus script to the player character game object</h5></div></div></div><p>The <code class="literal">PlayerStatus</code> script is added directly to the player character, so that it can be accessed and <a id="id265" class="indexterm"></a>affected by other scripts:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, select the <code class="literal">player_m</code> game object.</p></li><li><p>Drag <code class="literal">PlayerStatus</code> onto <code class="literal">player_m</code> to add it as a component.</p></li></ol></div><p>The player is now capable of losing and gaining health.</p><p>Next, we will make the necessary changes to the <code class="literal">Collectable</code> and <code class="literal">FPSAnimation</code> scripts.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec42"></a>Updating the Collectable script</h4></div></div></div><p>We need to<a id="id266" class="indexterm"></a> add some extra functions to our scripts in order to facilitate the picking up:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the <code class="literal">Collectable</code> script in MonoDevelop.</p></li><li><p>At the top of the script, add the following variables:</p><div class="informalexample"><pre class="programlisting">var increase : int;
var playerObj : GameObject;
var pickingCamera : GameObject;
var playerCamera : Transform;
var headBone : Transform;
var triggered : boolean = false;</pre></div><p>The value increase is the amount of health that the collectable will give the player when he picks it up. We are setting this to <code class="literal">1</code> by default.</p><p>The variable <code class="literal">playerObj</code> will store the player game object. We could also locate the player with its tag if we wanted to.</p><p>Next, <code class="literal">pickingCamera</code> will store the prefab containing the camera which we need to instantiate when the player picks the item up.</p><p>We also store a reference to the first-person camera with <code class="literal">playerCamera</code>, so we can access its transform data.</p><p>The Boolean variable <code class="literal">triggered</code> will be used to check whether the collectable is currently being picked up, so that it does not trigger multiple times.</p><p>Lastly, <code class="literal">headBone</code> will store the transform of the bone in the character's hierarchy that we will parent the pickup camera to.</p></li><li><p>Add the following code to the top of the <code class="literal">OnTriggerEnter</code> before the <code class="literal">if (sound)</code> statement that <a id="id267" class="indexterm"></a>we already added:</p><div class="informalexample"><pre class="programlisting">if(triggered == false)
{
    triggered = true;
    var playerState = playerObj.GetComponent(PlayerStatus);
    var playerAnim = playerObj.GetComponent(FPSAnimation);

    playerState.AddHealth(increase);
    playerAnim.Pick();

    RunCam();</pre></div><p>At the bottom of the function delete the <code class="literal">Remove();</code> line and add another closing curly bracket to complete our <code class="literal">if(triggered)</code> statement.</p><p>Here we check to make sure that the collectable is not already being triggered. If <code class="literal">triggered</code> is not true, we run the contained code by setting <code class="literal">triggered</code> to <code class="literal">true</code>.</p><p>We add two new local variables to access the <code class="literal">PlayerStatus</code> and <code class="literal">FPSAnimation</code> scripts and then run functions in each of these to add to the <code class="literal">health</code> value and run an animation respectively. Lastly we run the <code class="literal">RunCam</code> function. This will contain the code that operates the pickup camera.</p></li><li><p>Add the following code to the bottom of the script:</p><div class="informalexample"><pre class="programlisting">function RunCam()
{
    var pickTrans = transform;
    var addCamObj : GameObject = Instantiate(pickingCamera, headBone.position, playerCamera.rotation);
    addCamObj.transform.parent = headBone;
    addCamObj.transform.GetChild(0).SendMessage ("SentTarget", pickTrans);
    yield WaitForSeconds(0.5);
    Remove();
}</pre></div><p>We start by creating two local variables. The first, <code class="literal">pickTrans</code> is set as the transform that this script is attached to.</p><p>Secondly, <code class="literal">addCamObj</code> is defined as type <code class="literal">gameObject</code>, this will store the instantiated object so we can further modify its position and rotation. In the next line we instantiate the prefab, setting its position to match <code class="literal">headBone</code> and its rotation to match the existing player camera.</p><p>We make <code class="literal">addCamObj</code> the child of <code class="literal">headBone</code>. As a bone in the <code class="literal">player_m</code> hierarchy, <code class="literal">headBone</code> already animates when the pickup animation plays.</p><p>In the next line we locate the first child object within <code class="literal">AddCamObj</code>, which is the <code class="literal">pickupCamera</code>. This is sent the message <code class="literal">"SentTarget"</code>, with the variable <code class="literal">pickTrans</code> which we just defined. This effectively sends the collectable's transform as the camera's target.</p><p>We add<a id="id268" class="indexterm"></a> a short pause with the yield <a id="id269" class="indexterm"></a><code class="literal">WaitForSeconds</code> method, before running the <code class="literal">Remove</code> function which destroys the collectable game object, and which already exists at the bottom of our script.</p></li><li><p>Save the script.</p></li></ol></div><p>The pause is handled differently in C#. Take a look at the final commented code in the project files for details.</p><p>Our next step will involve hooking up variables, before we move on to updating the other scripts.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec13"></a>Hooking up variables in the collectable script</h5></div></div></div><p>The script now<a id="id270" class="indexterm"></a> accesses plenty of other game objects. We need to connect these in the main unity interface:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, <span class="emphasis"><em>Alt</em></span> + click the small arrow next to the <code class="literal">FPSController</code> game object to fully expand its hierarchy.</p></li><li><p>Select <code class="literal">lunchBox</code>.</p><p>Its components will become visible in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>Drag <code class="literal">player_m</code> from the <span class="strong"><strong>Hierarchy</strong></span> panel into the <span class="strong"><strong>Player Obj</strong></span> slot under the <span class="strong"><strong>Collectable (Script)</strong></span> component in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>Drag the <code class="literal">FirstPersonCharacter</code> game object onto the <span class="strong"><strong>Player Camera</strong></span> slot.</p></li><li><p>Scroll down in the <span class="strong"><strong>Hierarchy</strong></span> panel until you find <code class="literal">zombie_m_Head</code>.</p></li><li><p>Drag this onto the <code class="literal">headBone</code> slot in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click the <code class="literal">PACKT_Prefabs</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate <code class="literal">camParent</code> and drag this onto the <span class="strong"><strong>Picking Camera</strong></span> slot in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li></ol></div><p>In the next<a id="id271" class="indexterm"></a> section, we will make some changes to the <code class="literal">FPSAnimation</code> script.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec43"></a>Updating the FPSAnimation script</h4></div></div></div><p>We created the <code class="literal">FPSAnimation</code> script and attached it to the <code class="literal">player_m</code> game object earlier in this chapter.</p><p>Currently it is used to<a id="id272" class="indexterm"></a> set the trigger, transitioning to the <span class="strong"><strong>Shoot</strong></span> state in the player's animator controller. Here we will update it to trigger the <span class="strong"><strong>Pickup</strong></span> state:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Locate the <code class="literal">FPSAnimation</code> script in the <code class="literal">PACKT_Animations</code> folder.</p></li><li><p>Double-click on it, to open it in MonoDevelop.</p></li><li><p>At the bottom of the script, add the following functions:</p><div class="informalexample"><pre class="programlisting">function Pick()
{
    thisAnimator.SetTrigger("Picking"); 
}</pre></div><p>The <code class="literal">Pick</code> function<a id="id273" class="indexterm"></a> accesses animator controller and uses the same <code class="literal">SetTrigger</code> function to set the Mecanim trigger <code class="literal">Picking</code>.</p><p>Unlike <code class="literal">Fire</code>, <code class="literal">Pick</code> does not use input but is run from another script—the <code class="literal">Collectable</code> script that we just updated.</p></li><li><p>Save the script.</p></li></ol></div><p>The last script we need to update is <code class="literal">pickup</code>, the script attached to <code class="literal">pickupCamera</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec44"></a>Modifying the pickup script</h4></div></div></div><p>The bare<a id="id274" class="indexterm"></a> bones <code class="literal">pickup</code> script was already included in the project files. It was attached to <code class="literal">pickupCamera</code> when we setup the <code class="literal">camParent</code> prefab earlier in this chapter.</p><p>We can start by taking a look at the current code:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click the <code class="literal">PACKT_Scripts</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate the <code class="literal">pickup</code> script and double-click it to open it in MonoDevelop:</p><div class="informalexample"><pre class="programlisting">var life : float = 1.5;

function SentTarget(pickTrans : Transform)
{
    transform.LookAt(pickTrans);
    yield WaitForSeconds(life);
    ReturnTarget();
}

function ReturnTarget()
{
    Destroy(transform.parent.gameObject);
}</pre></div><p>The script contains single variable, <code class="literal">life</code>, which defines the duration that the prefab is created before it is destroyed. During this time the pickup camera is active.</p><p>The custom function <code class="literal">SentTarget</code> is run from the <code class="literal">Collectable</code> script when the player enters its trigger. It is sent the collectable object's <code class="literal">transform</code> to use as a target. This is currently set up using the <code class="literal">transform.LookAt</code> method.</p><p>When the life duration is up, the <code class="literal">ReturnTarget</code> function runs, destroying the parent game object—the object which <code class="literal">pickupCamera</code> is a child of.</p><p>If we test the game at this point, the camera switch will work, but the transition is a little jarring. We need to smooth the transition between the first-person camera and the pickup camera.</p><p>We will start by adding some more variables. Near the top of the script add the following code just below the existing variable:</p><div class="informalexample"><pre class="programlisting">var origTarget : Transform;
var pickTarget : Transform;
var damping : float = 5.0;
var camOffset : Vector3;</pre></div><p>The variable <code class="literal">origTarget</code> will be used to store the <code class="literal">pickupCamera</code> object's original rotation so we can transition back to it.</p><p>The next variable, <code class="literal">pickTarget</code> will store the new target sent to the script from the collectable.</p><p>Lastly, <code class="literal">damping</code> is used to delay the transition so the camera does not snap back quite so quickly.</p></li><li><p>Now replace<a id="id275" class="indexterm"></a> the code inside of the <code class="literal">SentTarget</code> function with the following code:</p><div class="informalexample"><pre class="programlisting">pickTarget = pickTrans;
var lookAtPosition : Vector3 = pickTarget.position;
    lookAtPosition.y = transform.position.y;
    lookAtPosition.z = transform.position.z;
    var rotation = Quaternion.LookRotation(lookAtPosition - transform.position);
    transform.rotation = Quaternion.Slerp(transform.rotation, rotation, Time.deltaTime * damping);    
    yield WaitForSeconds(life);
    ReturnTarget();</pre></div><p>We define <code class="literal">pickTarget</code> as equal to <code class="literal">pickTrans</code>, the <code class="literal">transform</code> variable is sent from collectable.</p><p>Next we replace the <code class="literal">transform.LookAt</code> method with some more specialized code that will allow us to transition between the camera targets smoothly. This starts with the definition of a new local <code class="literal">Vector3</code> variable, <code class="literal">lookAtPosition</code>.</p><p>In the next two lines we override the sent transform's <span class="strong"><strong>Y</strong></span> and <span class="strong"><strong>Z</strong></span> values with the <code class="literal">pickCamera</code> object's existing transform data, so we end up only using the <span class="strong"><strong>X</strong></span> value. This will allow the camera to dip rather than twisting towards the target.</p><p>Next we define another local variable, <code class="literal">rotation</code> using the <code class="literal">Quaternion.LookRotation</code> method. This allows us to measure the difference in rotation between the current target position and new target position.</p><p>The next line of code causes the camera to rotate from the current rotation to the new rotation value over time and with damping.</p><p>Next we put in our pause using the <code class="literal">yield WaitForSeconds</code> method and using our <code class="literal">life</code> float variable. This value needs to be sufficiently long to allow the pickup animation to play.</p><p>Finally <a id="id276" class="indexterm"></a>we run our <code class="literal">ReturnTarget</code> function to get the camera back to where it was.</p></li><li><p>Add the following code to the <code class="literal">Return Target</code> function before the existing line of code:</p><div class="informalexample"><pre class="programlisting">var origPosition : Vector3 = origTarget.position;
    origPosition.y = transform.position.y;
    origPosition.z = transform.position.z;
    var rotation = Quaternion.LookRotation(origPosition - transform.position);
    transform.rotation = Quaternion.Slerp(transform.rotation, rotation, Time.deltaTime * damping);</pre></div><p>Here we reverse the procedure, transitioning in the same way from the current rotation to a new rotation defined in the variable <code class="literal">origTarget</code>.</p></li><li><p>Now, save the script.</p></li></ol></div><p>Lastly, we need to hook up a single variable and adjust the transform values of the <code class="literal">pickCamera</code> object:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Minimize MonoDevelop.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click the <code class="literal">PACKT_Prefabs</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate the <code class="literal">camParent</code> prefab and click the small arrow to expand its hierarchy within the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Click the <code class="literal">pickupCamera</code> child object which appears beside it.</p><p>The <code class="literal">Pickup (Script)</code> components variables will become visible in the <span class="strong"><strong>Inspector</strong></span> panel.</p><p>We need to leave the <code class="literal">Pick Target</code> variable slot empty as this is sent from <code class="literal">collectable</code> at runtime.</p></li><li><p>Drag the <code class="literal">defaultTarget</code> child game object from the <span class="strong"><strong>Assets</strong></span> panel onto the <span class="strong"><strong>Orig Target</strong></span> slot to define it.</p></li><li><p>In the <code class="literal">pickupCamera</code> object's <span class="strong"><strong>Transform Position</strong></span> fields at the top of the Inspector, enter <code class="literal">-0.25</code> in the <span class="strong"><strong>Y</strong></span> field and <code class="literal">0.25</code> in the <span class="strong"><strong>Z</strong></span> field.</p></li></ol></div><p>These values will move the camera slightly closer to the collectable, minimizing the chance of seeing<a id="id277" class="indexterm"></a> the ends of the player arms. If you adjusted the <code class="literal">player_m</code> position differently you may want to experiment with the values.</p><p>Changes made directly to prefabs like this will be effected instantly. We can now test the <code class="literal">lunchBox</code> collectable.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec34"></a>Testing the lunchBox collectable</h3></div></div></div><p>We will test the <a id="id278" class="indexterm"></a>effects of the collectable and the pickup animation by adding a few more instances of the <code class="literal">lunchBox</code> game objects to our level:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, select the <code class="literal">lunchBox</code> game object.</p></li><li><p>Hit <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span> three times to duplicate the game object (use <span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>D</em></span> if you are working on a Mac).</p></li><li><p>Use the <span class="strong"><strong>Move</strong></span> tool to reposition the new instances of the <code class="literal">lunchBox</code> so they are spaced out within the environment.</p></li><li><p>Click to select the <code class="literal">player_m</code> game object.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, scroll down until you can clearly see the <code class="literal">health</code> variable in the <span class="strong"><strong>Player Status</strong></span> component.</p></li><li><p>Set the <code class="literal">health</code> value to <code class="literal">7</code>.</p></li><li><p>Click the <span class="strong"><strong>Game</strong></span> view tab.</p></li><li><p>If it is active, click to deactivate the <span class="strong"><strong>Maximize on Play</strong></span> button near the top of the interface.</p></li><li><p>Press the <span class="strong"><strong>Play</strong></span> button to preview the game.</p></li><li><p>Navigate the player towards the <code class="literal">lunchBox</code> collectables.</p></li></ol></div><p>We will get something like this:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_03_13.jpg" /></div><p>When the player collides with each of the collectables, the <code class="literal">Pickup</code> animation will play and the collectable will disappear.</p><p>The <code class="literal">health</code> value in the <span class="strong"><strong>Inspector</strong></span> panel will increase up to the maximum amount.</p><p>The last <code class="literal">lunchBox</code><a id="id279" class="indexterm"></a> collectible will still disappear, but the <code class="literal">health</code> value will not exceed the number defined in the <code class="literal">healthLimit</code>.</p></div></div>