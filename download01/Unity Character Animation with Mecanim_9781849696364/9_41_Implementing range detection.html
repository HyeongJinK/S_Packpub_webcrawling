<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec41"></a>Implementing range detection</h2></div></div><hr /></div><p>Our work in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Talking Heads</em></span>, left us with an enemy that becomes aware of the player on a button <a id="id522" class="indexterm"></a>click. Let's begin where we left off and improve this to make a smarter enemy that automatically attacks the player when he comes within a certain range.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec69"></a>Looking at the scene</h3></div></div></div><p>We will start by<a id="id523" class="indexterm"></a> opening our scene:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the Unity project, open <code class="literal">Chapter9_Start</code> by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Open Scene…</strong></span> | <span class="strong"><strong>Chapter9_Start</strong></span>.</p><p>The scene consists of the main office geometry and a single female zombie character. The <code class="literal">FPSController</code> prefab will allow us to navigate the scene.</p></li><li><p>Press the <span class="strong"><strong>Play</strong></span> button in the top center of the Unity interface.</p></li></ol></div><p>The female zombie is<a id="id524" class="indexterm"></a> currently set up to idle in place. We can approach and nothing happens at this point:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_01.jpg" /></div><p>In the next step, we will add the zombie's AI script and allow her to detect the player.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec70"></a>Adding the initial AI script</h3></div></div></div><p>We are starting with the<a id="id525" class="indexterm"></a> zombie's script that we completed in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Talking Heads</em></span>. The enemy is able to target the player, but we need to add some more code for anything exciting to happen:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, locate the <code class="literal">PACKT_Scripts</code> folder.</p></li><li><p>Click on it to view its contents it in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate <code class="literal">zombie_chapter9_Start</code>.</p></li><li><p>Drag the script onto the <code class="literal">zombie_f</code> game object in the <span class="strong"><strong>Inspector</strong></span> panel.</p><p>We now need to hook up some variables.</p></li><li><p>Drag the <code class="literal">FPSController</code> game object from the <span class="strong"><strong>Hierarchy</strong></span> panel onto the <span class="strong"><strong>Target</strong></span> slot under the <span class="strong"><strong>zombie_Chapter9 (script)</strong></span> component in the <span class="strong"><strong>Inspector</strong></span> panel.</p><p>This will allow the zombie to find the player.</p></li><li><p>In the <a id="id526" class="indexterm"></a><span class="strong"><strong>Project</strong></span> panel, locate <code class="literal">PACKT_Sounds</code> and click on it once to view its contents in the <span class="strong"><strong>Inspector </strong></span>panel.</p></li><li><p>Drag <code class="literal">zombie_growl</code> onto the <span class="strong"><strong>Snarl Sound</strong></span> slot in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li></ol></div><p>This will allow us to hear the zombie's growl when she is alerted.</p><p>If we preview the game at this point, we will have the same kind of setup as the end of <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Talking Heads</em></span>. The zombie will not notice the player until the fire button is pressed. In the next section, we will make the zombie respond to the player getting close.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec71"></a>Adding proximity detection to the enemy AI script</h3></div></div></div><p>The zombie currently becomes aware of the player only when the fire button is pressed. We need to add the <a id="id527" class="indexterm"></a>necessary code for the zombie to detect the player:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, locate the <code class="literal">PACKT_Scripts</code> folder and click on it to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate <code class="literal">zombie_chapter9_Start</code> in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Double-click on the script to open it in MonoDevelop.</p><p>We will start by adding some variables.</p></li><li><p>Add the following line of code to the end of the list of variables at the top of the script:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var distance : float;</strong></span>
<span class="strong"><strong>var awareRange : float = 4.0;</strong></span>
</pre></div><p>The first variable that we add is a <code class="literal">float</code> variable that will be used to store the current distance between the zombie and her target. The second, also a <code class="literal">float</code> variable that defines the range within which the zombie will become aware of the player.</p></li><li><p>In the <code class="literal">Update</code> function, locate the following code:</p><div class="informalexample"><pre class="programlisting">if(Input.GetButton("Fire1") &amp;&amp; alerted == false)
{
    alerted = true;
}</pre></div></li><li><p>Replace it with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>distance = Vector3.Distance(target.position, transform.position);</strong></span>
<span class="strong"><strong>if(distance &lt;= awareRange)</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>    alerted = true;</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>The <code class="literal">distance</code> variable keeps track of the actual distance between the zombie and<a id="id528" class="indexterm"></a> the target using the <a id="id529" class="indexterm"></a><code class="literal">Vector3.Distance</code> method.</p><p>In the <code class="literal">if</code> statement, we check to see if distance is less than the <code class="literal">awareRange</code> value, which we defined at the top of the script as a value of <code class="literal">4.0</code>. When this is the case we set the <code class="literal">alerted</code> boolean to true.</p></li><li><p>Save the behavior script and test the game by pressing the <span class="strong"><strong>Play</strong></span> button.</p></li></ol></div><p>The zombie will idle for a while before walking forward. Once she comes within 4 meters of the player, she will become alerted to the player's presence and walk toward him:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_02.jpg" /></div><p>This small addition to the script makes for a slightly more intelligent AI, but it has limited uses in the game.</p><p>The current animator <a id="id530" class="indexterm"></a>controller contains three states: <span class="strong"><strong>Idle</strong></span>, <span class="strong"><strong>Turn</strong></span>, and <span class="strong"><strong>Walk</strong></span>. The script switches between these states by setting triggers in the controller.</p><p>In the next section, we will set up a patrol behavior for the enemy, so the player can use good timing to avoid being detected.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec72"></a>Setting up the patrol behavior</h3></div></div></div><p>We already have a zombie<a id="id531" class="indexterm"></a> that will move toward the player when he comes within range, but a room full of zombies doing the same thing will not make the game particularly fun.</p><p>When our player<a id="id532" class="indexterm"></a> has run out of bullets, we still want to give them the opportunity to survive the game using stealth. We can do this by giving enemies fixed patrol patterns, which the player must identify in order to bide his time and sneak through the level.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec73"></a>Adding variables for the patrol</h4></div></div></div><p>We will prepare the<a id="id533" class="indexterm"></a> script by defining a few more variables to our current enemy script:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open or maximize MonoDevelop and make sure that the <code class="literal">zombie_Chapter9_Start</code> script is active in the editing window.</p></li><li><p>Add the following code to the bottom of the list of variables near the top of the script:</p><div class="informalexample"><pre class="programlisting">var patrolPts : Transform[];
var currPt : int;
var targetedPt : Transform;
var ptDistance : float;
var changeDistance : float = 0.5;
var turnTime : float = 5.0;
var moving : boolean = true;
var speed : float;
var alertDistance : float = 3.0;</pre></div></li></ol></div><p>Here, we are defining <code class="literal">patrolPts</code> as an array of transforms. This will store the positions of a number of patrol points (or waypoints) in the game level.</p><p>The next variable, <code class="literal">currPt</code> will keep track of which <code class="literal">patrolPt</code> the zombie is currently targeting. Next, <code class="literal">targetedPt</code> maintains a connection to the current point's transform.</p><p>The <code class="literal">ptDistance</code> float variable will keep track of how far the zombie is from the targeted point.</p><p>The next variable, <code class="literal">changeDistance</code> will define the distance which causes the zombie to target the next point, here we are defining it with the value <code class="literal">0.5</code>.</p><p>We added <code class="literal">turnTime</code> temporarily to determine how long it will take the zombie to turn to face the next point.</p><p>After this, we have a boolean named <code class="literal">moving</code> that will let us determine when the zombie should be moving forward.</p><p>We already have a float parameter to determine the zombie's <code class="literal">walkSpeed</code>, but we add a float named <code class="literal">speed</code> to keep track of the current value and help us decide which animation to play.</p><p>Finally, <code class="literal">alertDistance</code> will determine when the zombie can see the player.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec74"></a>Adding the initial patrol code to the Update function</h4></div></div></div><p>We will use the<a id="id534" class="indexterm"></a> variables that we just added in the next lines of code:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Near the top of the <code class="literal">Update</code> function, add the following code:</p><div class="informalexample"><pre class="programlisting">targetedPt = patrolPts[currPt];
var patrolPtDistance : float = Vector3.Distance(targetedPt.position, transform.position);
var playerDistance = Vector3.Distance(target.position, transform.position);

if(playerDistance &lt;= alertDistance)
{
    alerted = true;
}</pre></div><p>Here, we define the <code class="literal">targetedPt</code> variable as the transform current in the <code class="literal">patrolPt</code> array.</p><p>We define a new local float variable named <code class="literal">patrolPtDistance</code>, which keeps track of the distance between the <code class="literal">targetedPt</code> variable's position and the game object's position.</p><p>Variables that are only used within a single function can be kept as local variables like this to reduce clutter in the <span class="strong"><strong>Inspector</strong></span> panel.</p><p>Another local variable, <code class="literal">playerDistance</code>, uses the same method, <code class="literal">Vector3.Distance</code> to <a id="id535" class="indexterm"></a>keep track of the distance between the player and the enemy. This one will be used to tell the zombie when to leave her idling routine and go into attack mode.</p><p>Following this variable definition, we add an <code class="literal">if</code> statement to check whether <code class="literal">playerDistance</code> is less than or equal to <code class="literal">alertDistance</code>. When this is the case, we switch the <code class="literal">alerted</code> boolean to <code class="literal">true</code>.</p><p>We are prioritizing functionality here, the zombie's reaction to the player<a id="id536" class="indexterm"></a> is more important than the patrol.</p></li><li><p>Locate the <code class="literal">if(alerted)</code> statement and add the following line of code at the start:</p><div class="informalexample"><pre class="programlisting">targetedPt = target;</pre></div><p>This will override our patrol point targeting and allow the zombie to chase after the player rather than the point.</p><p>The next line of code in the script calls the function <code class="literal">TurnToPlayer</code>. We will repurpose this function to also turn the zombie toward the current patrol point.</p></li><li><p>Replace <code class="literal">TurnToPlayer()</code> with <code class="literal">TurnToPoint()</code>.</p></li><li><p>Right after the<a id="id537" class="indexterm"></a> closing bracket of the <code class="literal">if(alerted)</code> statement, further down in the <code class="literal">Update</code> function, enter the following code:</p><div class="informalexample"><pre class="programlisting">else
{
    if(patrolPtDistance &lt;= changeDistance)
    {
        ChangePt();
        turning = true;
    }
}</pre></div><p>Here, we check to see if the zombie has come within range of the patrol point. We want her to start her turn a little way before she gets to the actual point.</p><p>We run a new custom function called <code class="literal">ChangePt</code>, which will update the patrol point in the array so the zombie has something to turn toward.</p></li><li><p>Add the following code right after the last statement:</p><div class="informalexample"><pre class="programlisting">if(turning)
{
    TurnToPoint();
        
    if(angle &lt; 2 &amp;&amp; angle &gt; -2)
    {
        WalkTowards();
    }
}</pre></div><p>Here we check for the boolean <code class="literal">turning</code> to be true, which is also set up to run the <span class="strong"><strong>Turn</strong></span> state in our animator controller.</p><p>If the current angle that we need to turn to face toward the patrol point is less than 2 degrees difference in the positive or negative direction, we run the <code class="literal">WalkTowards</code> function which we have already defined.</p></li><li><p>After the <code class="literal">Update</code> function add the following code:</p><div class="informalexample"><pre class="programlisting">function ChangePt()
{
    currPt++;
}</pre></div><p>This is a <a id="id538" class="indexterm"></a>very short function. All we are doing here is increasing the <code class="literal">currPt</code> variable, which will move on to the next patrol point in the array. This code needs to be outside the <code class="literal">Update</code> function, otherwise the number will continuously increase when <code class="literal">turning</code> is <code class="literal">true</code>.</p><p>If we play the game at this point, we will very quickly get an <span class="emphasis"><em>index out of range </em></span>error. The <code class="literal">currPt</code> variable will increase way beyond the number of items we have in our array, so we need to limit it.</p></li><li><p>To fix this, we will add the following code to the very end of the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">if(currPt &gt; patrolPts.Length-1)
{
    currPt = 0;
}</pre></div><p>Here, we are ensuring that whenever <code class="literal">currPt</code> is greater than the length of the <code class="literal">patrolPts</code> array (<code class="literal">-1</code>, because we count from 0), <code class="literal">currPt</code> is equal to <code class="literal">0</code>.</p><p>The value of <code class="literal">CurrPt</code> will never be greater than the number of items we have in our array.</p><p>We now run the <code class="literal">TurnToPoint</code> function in two situations in our script, but the point that we turn to is <code class="literal">target</code>, which will be set up to use the player's transform. We need to edit this function to use our new variable.</p></li><li><p>Locate the <code class="literal">TurnToPlayer</code> function and rename it <code class="literal">TurnToPoint</code>.</p></li><li><p>Within the function, replace the second line of code with the following:</p><div class="informalexample"><pre class="programlisting">var localRotate = transform.InverseTransformPoint(targetedPt.position);</pre></div><p>All we need to do here is replace the variable <code class="literal">target</code> with the new <code class="literal">targetedPt</code> variable, which is set to the player or the current patrol point in the main part of our script.</p><p>We created the <code class="literal">WalkTowards</code> function back in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Talking Heads</em></span>. It basically allows the zombie to move forward on her local axis while running the walk animation.</p><p>We should ensure that the zombie is not turning when this happens.</p></li><li><p>Locate the<a id="id539" class="indexterm"></a> <code class="literal">WalkTowards</code> function and add the following code right at the top:</p><div class="informalexample"><pre class="programlisting">turning = false;</pre></div></li><li><p>Save the script.</p></li></ol></div><p>In order to see if this code works, we need to set up some patrol points for the zombie to use in the level. We will do this next.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec73"></a>Defining patrol points</h3></div></div></div><p>We will start by creating two patrol points (or waypoints) in the scene, though the script that we created will accept more than this.</p><p>The script <a id="id540" class="indexterm"></a>defines the patrol points as <span class="strong"><strong>Transforms</strong></span>. We could use empty game objects or pretty much anything we want.</p><p>We will use cubes here, because <a id="id541" class="indexterm"></a>you can see them clearly in the scene. We can delete the mesh renderers or just turn them off before we build the game so that we do not see them:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a <code class="literal">cube</code> game object using the menu bar by navigating to <span class="strong"><strong>Game Object</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Cube</strong></span>.</p></li><li><p>At the top of the <span class="strong"><strong>Inspector</strong></span> panel, change the name of the game object to <code class="literal">wayPoint01</code>.</p></li><li><p>Decrease the <span class="strong"><strong>Transform - Scale</strong></span> values for <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> to <code class="literal">0.5</code>.</p></li><li><p>Deactivate the <span class="strong"><strong>Box Collider</strong></span> component by unchecking the box next to this component's name.</p></li><li><p>Duplicate the waypoint by selecting it and using the <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span> shortcut (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>D</em></span> on a Mac).</p></li><li><p>In <span class="strong"><strong>Inspector </strong></span>panel, rename the second box <code class="literal">wayPoint02</code>.</p></li><li><p>In the scene, position <code class="literal">wayPoint01</code> so that it is between the first set of office cube partitions and <code class="literal">wayPoint02</code> so that it is between the third set.</p></li><li><p>Move both <a id="id542" class="indexterm"></a>waypoints so that they are resting on the ground.</p><p>You can set the <span class="strong"><strong>Position Y</strong></span> value to <code class="literal">0.25</code> in the <span class="strong"><strong>Transform</strong></span> settings at the top of the <span class="strong"><strong>Inspector</strong></span> panel if you want to be exact.</p></li><li><p>If necessary, reposition the <code class="literal">zombie_f</code> game object so that the zombie is facing toward <code class="literal">wayPoint01</code>, with her back to <code class="literal">wayPoint02</code> a short distance away:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_03.jpg" /></div><p>Now that we have all of our game objects repositioned, we can add the two waypoints to the array in the behavior script.</p></li><li><p>Select the <code class="literal">zombie_f</code> game object in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p><p>The script component should now be visible in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, click on the small arrow next to the <code class="literal">Patrol Pts</code> variable under the script component.</p><p>This will expose the <code class="literal">Size</code> variable, which sets the size of the array.</p></li><li><p>Set the <code class="literal">Size</code> value to <code class="literal">2</code>.</p><p>This will create two new <code class="literal">Element</code> fields, which will accept any transforms that are dragged onto them.</p></li><li><p>Drag <code class="literal">wayPoint01</code> from the <span class="strong"><strong>Hierarchy</strong></span> panel onto the <code class="literal">Element 0</code> field and <code class="literal">wayPoint02</code> onto the <code class="literal">Element 1</code> field.</p></li></ol></div><p>If you press the <span class="strong"><strong>Play</strong></span> button at this point, you should see the zombie move between the two points.</p><p>Next, we will make<a id="id543" class="indexterm"></a> the necessary changes to the animator controller and implement the zombie's animation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec74"></a>Modifying the animator</h3></div></div></div><p>The current animator controller is set up the same as we left it at the end of <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Talking Heads</em></span>. We need to make <a id="id544" class="indexterm"></a>a few changes to get the animation running a little more smoothly:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, select the <code class="literal">zombie_f</code> game object.</p></li><li><p>Click on the <span class="strong"><strong>Animator</strong></span> tab in the top center of the main Unity interface to open the <span class="strong"><strong>Animator</strong></span> window.</p><p>The currently selected game object's animator controller should be displayed in the window.</p></li><li><p>Drag the <span class="strong"><strong>Animator</strong></span> tab toward the top of the Unity interface to undock it.</p></li><li><p>Position it so that it can be viewed at the same time as the <span class="strong"><strong>Game</strong></span> view.</p></li><li><p>Press the <span class="strong"><strong>Play</strong></span> button to preview the game.</p><p>The zombie walks to the patrol point and idles briefly before beginning her turn animation:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_04.jpg" /></div><p>We can see in the <span class="strong"><strong>Animator</strong></span> window that the zombie is in her <span class="strong"><strong>Idle</strong></span> state even though she is turning toward the next patrol point in the <span class="strong"><strong>Game</strong></span> view.</p><p>This would<a id="id545" class="indexterm"></a> look better if we reduced the amount of <code class="literal">idle</code> and got straight to the turn.</p></li><li><p>Press the <span class="strong"><strong>Play</strong></span> button again to exit play mode.</p></li><li><p>In the <span class="strong"><strong>Animator</strong></span> window, click on the <span class="strong"><strong>Idle</strong></span> | <span class="strong"><strong>Turn</strong></span> transition to view its settings in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>Uncheck the <span class="strong"><strong>Has Exit Time</strong></span> checkbox.</p><p>This will interrupt the <span class="strong"><strong>Idle</strong></span> animation and transition straight to <span class="strong"><strong>Turn</strong></span> before the <span class="strong"><strong>Idle</strong></span> cycle has finished playing.</p></li><li><p>Press the <span class="strong"><strong>Play</strong></span> button again to view the result.</p></li></ol></div><p>At the moment when the zombie walks forward, she does so at a constant rate. In the next step, we will integrate this forward movement better with the animation using an animation curve.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec75"></a>Adding and accessing an animation curve</h3></div></div></div><p>When the zombie<a id="id546" class="indexterm"></a> walks forward, the forward <a id="id547" class="indexterm"></a>movement is defined by a fixed value in the <code class="literal">walkSpeed</code> <a id="id548" class="indexterm"></a>variable.</p><p>We can also create a variable<a id="id549" class="indexterm"></a> tied to the animation frames in the animation's <span class="strong"><strong>Import</strong></span> settings.</p><p>Start by locating the walk animation clip in the project:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Animation</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate the <code class="literal">zombie_walk</code> asset and click on it once to view its properties in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, click on the <span class="strong"><strong>Animation</strong></span> tab, if it is not already active.</p></li><li><p>In the list of clips, select <code class="literal">zwalk01f</code>.</p><p>The <a id="id550" class="indexterm"></a>selected animation can be viewed in the <span class="strong"><strong>Animation Preview</strong></span> panel at the bottom.</p></li><li><p>If this panel appears empty, drag the <code class="literal">zombie_f</code> game object from the <span class="strong"><strong>Hierarchy</strong></span> panel onto this panel to preview the animation with this character.</p></li><li><p>Scroll to the bottom of the <span class="strong"><strong>Inspector</strong></span> panel and click on the small arrow next to <span class="strong"><strong>Curves</strong></span>.</p><p>By default, there are no curves associated with the animation.</p></li><li><p>Click on the <span class="strong"><strong>+</strong></span> symbol to create a curve.</p><p>You should <a id="id551" class="indexterm"></a>see an empty timeline proportionately representing the selected motion clip.</p></li><li><p>Rename<a id="id552" class="indexterm"></a> the new curve <code class="literal">ForwardMovement</code>.</p></li><li><p>Click on the <a id="id553" class="indexterm"></a>curve graph.</p><p>This will open the new curve in the <span class="strong"><strong>Curve</strong></span> window so that it can be edited.</p><p>In the <span class="strong"><strong>Curve</strong></span> window, you can create keyframes by right-clicking on anywhere on the curve and selecting <span class="strong"><strong>Add Key</strong></span> from the pop-up menu.</p></li><li><p>Using the <span class="strong"><strong>Animation Preview</strong></span> panel as a guide, define positive values in the curve, where the zombie should be moving forward.</p><p>The value scale on the left will define the actual forward movement of the zombie per second, so keyframe your maximum value at 1.0.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip12"></a>Tip</h3><p>Remember that the curve<a id="id554" class="indexterm"></a> represents the <span class="strong"><strong>root movement</strong></span>—the whole body, not the feet.</p></div></li><li><p>When you are finished defining the curve, set the start and end tangents to <span class="strong"><strong>Loop</strong></span> by clicking on the tangent mode (set by default to <span class="strong"><strong>Clamp</strong></span>) in the <span class="strong"><strong>Curve</strong></span> window and defining <span class="strong"><strong>Loop</strong></span> from the drop-down list.</p><p>This <a id="id555" class="indexterm"></a>will ensure that the sequence blends together<a id="id556" class="indexterm"></a> smoothly as the walk cycles.</p></li><li><p>Save the <span class="strong"><strong>Import</strong></span> settings and store the new animation curve by clicking on the <span class="strong"><strong>Apply</strong></span> button at the bottom of the <span class="strong"><strong>Inspector</strong></span> panel:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_05.jpg" /></div></li></ol></div><p>In this curve, I <a id="id557" class="indexterm"></a>have defined the peaks, where the zombie is propelled<a id="id558" class="indexterm"></a> forward, and a slight dip at the mid, crossing point of the walk cycle.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec75"></a>Accessing the animation curve in Mecanim and using it in the script</h4></div></div></div><p>Now that we have added<a id="id559" class="indexterm"></a> the animation curve to the motion clip, we can make use of it in our Mecanim setup.</p><p>We will start by storing the curve's value in the animator controller:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In Unity, click on the <span class="strong"><strong>Animator</strong></span> tab to view the zombie's controller.</p></li><li><p>At the top right of the <span class="strong"><strong>Animator</strong></span> panel, click on the <span class="strong"><strong>Parameter</strong></span> tab to activate it.</p></li><li><p>At the moment, we have boolean parameters to trigger the <span class="strong"><strong>Walk</strong></span> and <span class="strong"><strong>Turn</strong></span> states.</p></li><li><p>Create a new parameter by clicking on the <span class="strong"><strong>+</strong></span> symbol.</p></li><li><p>Choose <span class="strong"><strong>Float</strong></span> from the drop-down selection list that appears.</p></li><li><p>Rename the new float parameter <code class="literal">ForwardMovement</code>.</p><p>It is important that we give it the same name as the animation curve we created in the <span class="strong"><strong>Import</strong></span> settings, for Mecanim to make a connection between them.</p><p>We can test this, by running the game at this point.</p></li><li><p>Press the <span class="strong"><strong>Play</strong></span> button.</p></li><li><p>Switch to the <span class="strong"><strong>Animator</strong></span> tab, while <span class="strong"><strong>Play</strong></span> mode is still running.</p><p>While the zombie is in her <span class="strong"><strong>Walk</strong></span> state, you should see the value of <code class="literal">ForwardMovement</code> change.</p><p>The value is grayed out, indicating that it is a read only parameter—it is being driven by the animation curve:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_06.jpg" /></div><p>At the<a id="id560" class="indexterm"></a> moment, this parameter is not affecting the zombie's movement. We need to make another change to the script to <a id="id561" class="indexterm"></a>effect this.</p></li><li><p>Maximize MonoDevelop and make sure that <code class="literal">zombie_chapter9_Start</code> is the active script.</p></li><li><p>Add the following code to the top of the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">var speedFactor = theAnimator.GetFloat("ForwardMovement");
speed = walkSpeed * speedFactor;</pre></div><p>Here, we create a new local variable to handle the animator parameter, which we are driving with the animation curve. We multiply <code class="literal">walkSpeed</code> by this value.</p><p>We put this in <code class="literal">Update</code> so that it stays current with the value in the controller.</p></li><li><p>Scroll down to the <code class="literal">WalkTowards</code> function.</p></li><li><p>Replace the definition of the <code class="literal">direction</code> variable with the following line of code:</p><div class="informalexample"><pre class="programlisting">var direction = transform.TransformDirection(Vector3.forward * speed);</pre></div><p>Here, we replace <code class="literal">walkSpeed</code> with our new adjusted speed value.</p></li><li><p>Save the script.</p></li><li><p>Press the <span class="strong"><strong>Play</strong></span> button to preview the game.</p></li></ol></div><p>Our zombie should now<a id="id562" class="indexterm"></a> lurch forward unevenly. Her forward movement is driven by the animation <a id="id563" class="indexterm"></a>curve and should appear to be in sync with her walk animation.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec76"></a>Adding the attack</h3></div></div></div><p>Back in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>The Zombie Attacks!</em></span>, we set up the male zombie character to attack the player on a key press. To allow<a id="id564" class="indexterm"></a> our current zombie to attack, we need to be able to target the player and create a new state to handle the attack <a id="id565" class="indexterm"></a>animation.</p><p>The zombie can already locate the player when he comes within a defined range and move toward him. We need to add some more variables to define when the zombie can attack and for how long:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Near the top of the script add the following variables:</p><div class="informalexample"><pre class="programlisting">var attackRange : float = 1.5;
var attacking : boolean = false;
var attackDuration : float = 2.0;
var attackTimer : float;</pre></div><p>The <code class="literal">attackRange</code> float is like the <code class="literal">changeDistance</code> variable we are already using for our patrol points. It defines a specific range that will be used to trigger the attack.</p><p>We add a boolean, <code class="literal">attacking</code> that will allow us to sync up the state change and other implications. The <code class="literal">attackDuration</code> and <code class="literal">attackTimer</code> floats will allow us to time out the attack and give the player a chance to respond.</p></li><li><p>Locate the <code class="literal">if(alerted)</code> statement near the top of the <code class="literal">Update</code> function.</p></li><li><p>Within this, add<a id="id566" class="indexterm"></a> the following line before the other <code class="literal">if</code> statements:</p><div class="informalexample"><pre class="programlisting">if(playerDistance &lt;= attackRange &amp;&amp; !attacking)
{
    Attack();
}</pre></div><p>This will run the <code class="literal">Attack</code> function. Importantly, we make this dependent on two conditions, the player must be within the range and the boolean <code class="literal">attacking</code> is currently <code class="literal">false</code>. This will make sure that we do not trigger an attack when we are already attacking.</p></li><li><p>Add the<a id="id567" class="indexterm"></a> following code next:</p><div class="informalexample"><pre class="programlisting">if(attacking)
{
        attackTimer -= Time.deltaTime;
        if(attackTimer &lt;= 0.0)
        {
            attacking = false;
        }
}</pre></div><p>Our condition here is that the <code class="literal">attacking</code> boolean should be <code class="literal">true</code>. When this is the case, we reduce <code class="literal">attackTimer</code> by real time. When this reaches zero or below, we set the <code class="literal">attacking</code> boolean to <code class="literal">false</code>, timing out the attack.</p></li><li><p>Scroll to the bottom of the script and add the following code:</p><div class="informalexample"><pre class="programlisting">function Attack()
{
    theAnimator.SetTrigger("IsAttacking");    
    attackTimer = attackDuration;
    attacking = true;
}</pre></div><p>Within the actual <code class="literal">Attack</code> function, we first set a <code class="literal">IsAttacking</code> trigger to transition into the <span class="strong"><strong>Attack</strong></span> state.</p><p>We reset <code class="literal">attackTimer</code> to the same value as <code class="literal">attackDuration</code>. If the <code class="literal">Attack</code> function <a id="id568" class="indexterm"></a>has already run, this value will be at zero.</p><p>We also set the boolean <code class="literal">attacking</code> to true, which will allow us to run some other code to damage the player.</p></li><li><p>Save the script<a id="id569" class="indexterm"></a> and return to the main Unity interface.</p></li></ol></div><p>At this point, we<a id="id570" class="indexterm"></a> need to add the state to handle the attack animation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec76"></a>Adding the Attack state</h4></div></div></div><p>We want the <span class="strong"><strong>Attack</strong></span> state to take priority over the others and to be triggered from any state. Rather than setting<a id="id571" class="indexterm"></a> up three different transitions, we can just use the <span class="strong"><strong>Any State</strong></span>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Locate <span class="strong"><strong>Any State</strong></span>, in the <span class="strong"><strong>Animator</strong></span> graph.</p></li><li><p>Right-click on an empty part of the graph close to this and choose <span class="strong"><strong>Create State</strong></span> | <span class="strong"><strong>Empty</strong></span>.</p></li><li><p>Click on the new state and rename it <code class="literal">Attack</code> in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Animations</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate the <code class="literal">zombie_attack</code> asset and click on the small arrow next to its icon to expand it.</p></li><li><p>Drag the <code class="literal">hit</code> animation clip into the motion field of the <span class="strong"><strong>Attack</strong></span> state.</p></li><li><p>Create a transition from the <span class="strong"><strong>Any State</strong></span> box to the new <span class="strong"><strong>Attack</strong></span> state.</p><p>We need to create the new parameter in order to complete this transition.</p></li><li><p>In the top left of the <span class="strong"><strong>Animator</strong></span> panel, click on the <span class="strong"><strong>Parameters</strong></span> tab if it is not already active.</p></li><li><p>Click on the <span class="strong"><strong>+</strong></span> symbol to create a new parameter and choose <span class="strong"><strong>Trigger</strong></span> from the drop-down list.</p></li><li><p>Rename the new parameter <code class="literal">IsAttacking</code>.</p></li><li><p>Select the transition between <span class="strong"><strong>Any State</strong></span> and <span class="strong"><strong>Attack</strong></span> and set its condition to <code class="literal">IsAttacking</code>.</p></li><li><p>Create a transition between <span class="strong"><strong>Attack</strong></span> and <span class="strong"><strong>Idle</strong></span>.</p></li><li><p>Leave its <span class="strong"><strong>Condition</strong></span> empty, it will default to <span class="strong"><strong>Exit Time</strong></span> so that the zombie will begin idling once it has attacked once.</p></li></ol></div><p>Refer to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_07.jpg" /></div><p>If we test the game at this point, we should see the zombie attack when it is approached. If the player moves<a id="id572" class="indexterm"></a> away, the zombie will follow the player and try to attack. Before we can allow the zombie to actually harm the player we will assign some tags.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec77"></a>Associating tags with the enemy and player game objects</h4></div></div></div><p>Now that we have our<a id="id573" class="indexterm"></a> state machine up and running, it seems like a <a id="id574" class="indexterm"></a>good time for some consequences.</p><p>We can start this using Unity's <span class="strong"><strong>tags</strong></span> to define the <code class="literal">zombie_f</code> game object as an enemy and <code class="literal">FPSController</code> as a player.</p><p>Tags allow us to define how specific objects or groups of objects are treated. In this case, we want the zombie to send a message to the player to deduct damage when he is hit. If the zombie hits another collider or misses the player, we do not want to send the same message:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, click on the <code class="literal">FPSController</code> game object to select it.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, click on the <span class="strong"><strong>Tag</strong></span> drop-down list in the upper left of the panel.</p></li><li><p>Select <span class="strong"><strong>Player</strong></span> from the list.</p></li><li><p>Back in the <span class="strong"><strong>Hierarchy</strong></span> panel, select the <code class="literal">zombie_f</code> game object.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, assign the <span class="strong"><strong>Enemy</strong></span> tag to this object.</p><p>We are assigning the player as the zombie's target by dragging the game object into the variable slot in the game scene.</p><p>It seems reasonable to do this for one or two enemies in a single level, but for more than this, it would be handy if the enemy could find the player automatically. We can do this with the tags.</p></li><li><p>Open the <code class="literal">zombie_chapter9_Start</code> script in MonoDevelop.</p></li><li><p>At the top of the <code class="literal">Start</code> function, add the following line of code:</p><div class="informalexample"><pre class="programlisting">target = GameObject.FindWithTag ("Player").transform;</pre></div><p>We use the<a id="id575" class="indexterm"></a> <code class="literal">GameObject.FindWithTag</code> method to locate a game object in the <a id="id576" class="indexterm"></a>scene with the tag<a id="id577" class="indexterm"></a> <span class="strong"><strong>Player</strong></span>. We then return its transform.</p></li><li><p>Save the script.</p></li><li><p>Back in the main Unity interface, select the <code class="literal">zombie_f</code> game object in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, click on the radio button next to the <span class="strong"><strong>Target</strong></span> variable slot under the script component.</p></li><li><p>When the <span class="strong"><strong>Select Transform</strong></span> window appears, scroll to the top and select <span class="strong"><strong>None</strong></span>.</p><p>The <code class="literal">target</code> variable will now be defined at runtime.</p></li><li><p>Press the <span class="strong"><strong>Play</strong></span> button to preview the game at this point and check that this works.</p></li></ol></div><p>The tags are now setup and the zombie targets the player in the scene automatically.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec78"></a>Allowing the zombie to hurt the player</h4></div></div></div><p>Now that we have<a id="id578" class="indexterm"></a> set up the tags, we will continue adding code to the script in MonoDevelop.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following variable to the <span class="strong"><strong>others</strong></span> near the top of the <code class="literal">zombie_chapter9_Start</code> script:</p><div class="informalexample"><pre class="programlisting">var damage: int = 2;</pre></div><p>This variable will be used to set the amount of damage caused to the player in each attack.</p></li><li><p>Scroll down to the <code class="literal">Attack</code> function and add the following lines of code:</p><div class="informalexample"><pre class="programlisting">var playerStatus = target.Find("FirstPersonCharacter/player_m");
    playerStatus.SendMessage("AddDamage", damage);</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>The <code class="literal">SendMessage</code> method is<a id="id579" class="indexterm"></a> a typical way to hurt a player or an enemy and relies on the game object containing a function named <code class="literal">AddDamage</code> in one of its scripts.</p></div><p>Back in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Interacting with the Environment</em></span>, we added a simple player status script that allowed our player to receive health power ups. We are accessing this script to damage the player.</p><p>Here, we send the <code class="literal">AddDamage</code> message with the integer variable <code class="literal">damage</code> to the game object <code class="literal">player_m</code>, which the <code class="literal">playerStatus</code> script is attached to. The <code class="literal">AddDamage</code> function is run in the script, decreasing the damage.</p></li><li><p>Save the <a id="id580" class="indexterm"></a>script.</p></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, select the <code class="literal">player_m</code> game object.</p></li><li><p>In the main unity interface, press the <span class="strong"><strong>Play</strong></span> button to preview the game.</p></li><li><p>Walk toward the zombie and allow her to attack the player.</p></li></ol></div><p>In the <span class="strong"><strong>Inspector</strong></span> panel, we should see the player's health reduced by 2 each time the zombie attacks.</p><p>When the player's health is reduced to <code class="literal">0</code>, a message will appear in the console to inform you that the player is dead.</p><p>Now that the zombie can attack and hurt the player, we will add the equivalent code to the zombie's script to allow her to be damaged and killed.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec77"></a>Damaging and killing the zombie</h3></div></div></div><p>In order for our zombie enemy to take damage and ultimately be killed, we need to add a variable that can<a id="id581" class="indexterm"></a> be decreased when they are struck by the<a id="id582" class="indexterm"></a> player's bullets:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In MonoDevelop, add the following variables to the others, near the top of the <code class="literal">zombie_chapter9_Start</code> script:</p><div class="informalexample"><pre class="programlisting">var zombieHealth : int = 5;
var deadPrefab : Transform;</pre></div><p>This first new variable stores the current health value. This will decrease when the zombie is hit. We will use <code class="literal">deadPrefab</code> to store the ragdoll prefab that we created previously in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Implementing Ragdoll Physics</em></span>.</p></li><li><p>At the<a id="id583" class="indexterm"></a> bottom of the script, add the following code:</p><div class="informalexample"><pre class="programlisting">function AddDamage(damage : int)
{
    zombieHealth -= damage;
    if(zombieHealth &lt;= 0)
    {
        zombieHealth = 0;
        Dead();
    }
}</pre></div><p>This function is almost identical to the function handling the player's health. When<a id="id584" class="indexterm"></a> the zombie's health value drops below zero, we call the <code class="literal">Dead</code> function, which we will write next.</p></li><li><p>Next, add the following code:</p><div class="informalexample"><pre class="programlisting">function Dead()
{
    Destroy(gameObject);
    if(deadPrefab)
    {
        var dead : Transform = Instantiate(deadPrefab, transform.position, transform.rotation);
        CopyTransformsRecurse(transform, dead);
    }
}
static function CopyTransformsRecurse (src : Transform, dst : Transform)
{
    dst.position = src.position;
    dst.rotation = src.rotation;

    for(var child : Transform in dst)
    {
        var curSrc = src.Find(child.name);
        if(curSrc)
            CopyTransformsRecurse(curSrc, child);
    }
}</pre></div></li></ol></div><p>In the <code class="literal">Dead</code> function, we destroy the game object—the zombie and all of her components.</p><p>We then instantiate the ragdoll, and store this as a local variable named <code class="literal">dead</code>. We then feed the <code class="literal">dead</code> <a id="id585" class="indexterm"></a>prefab and the original transform into a static function named <code class="literal">CopyTransformsRecurse</code>. This goes through all the child <code class="literal">Transforms</code> in our original game object and applies their rotation and position to those of the ragdoll, giving<a id="id586" class="indexterm"></a> us a seamless transition.</p><p>To see the result, we need to hook up the ragdoll prefab with the script:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Save the script.</p></li><li><p>Select the <code class="literal">zombie_f</code> game object by clicking on it in the <span class="strong"><strong>Hierarchy</strong></span> panel, if it is not already selected.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, scroll down until you can see the <code class="literal">Zombie chapter9_Start(script)</code> component.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Prefabs</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate the <code class="literal">zombie_f_ragdoll</code> prefab and drag it into the <span class="strong"><strong>Dead Prefab</strong></span> slot in the <code class="literal">Zombie_chapter9_Start(script).</code>
</p></li></ol></div><p>To damage the zombie, we need to fire some bullets, so we will make a small update to the player's script in the next step.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec79"></a>Allowing the player to fire</h4></div></div></div><p>When the fire button is pressed, a message appears in the console, but the player's weapon does not<a id="id587" class="indexterm"></a> actually fire any bullets. We will add the necessary code and connect variables to make this happen:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Assets</strong></span> panel, locate <code class="literal">FPSAnimation</code>.</p></li><li><p>Double-click on it to open it in MonoDevelop.</p></li><li><p>Add the following variables to the top of the script:</p><div class="informalexample"><pre class="programlisting">var bulletPrefab : GameObject;
var muzzle : Transform;</pre></div><p>Like the ragdoll, the bullet is a prefab that we are instantiating at runtime. This has already been setup.</p><p>The next variable, <code class="literal">muzzle</code>, defines the transform position where the bullet will be instantiated.</p></li><li><p>In MonoDevelop, scroll down until you find the <code class="literal">Shoot</code> function.</p></li><li><p>Add the following code within its opening and closing brackets:</p><div class="informalexample"><pre class="programlisting">var theBullet = Instantiate(bulletPrefab, muzzle.position, muzzle.rotation);
theBullet.GetComponent.&lt;Rigidbody&gt;().AddRelativeForce(0, 0, 3000);</pre></div><p>Here, we assign a new local variable named <code class="literal">theBullet</code>. We instantiate <code class="literal">bulletPrefab</code> with the position and rotation of the muzzle transform, within it.</p><p>We then add relative force to the object's <code class="literal">rigidbody</code> component so that it travels in the direction that we fire.</p></li><li><p>Save the script.</p></li><li><p>Minimize MonoDevelop.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Prefabs</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> <a id="id588" class="indexterm"></a>panel, select the <code class="literal">player_m</code> game object.</p></li><li><p>Locate <code class="literal">bulletCube</code> in the <span class="strong"><strong>Assets</strong></span> panel and drag it into the <code class="literal">bulletPrefab</code> slot under the <code class="literal">FPSAnimation (Script)</code> component in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, fully expand <code class="literal">player_m</code> game object's hierarchy by <span class="emphasis"><em>Alt</em></span> + clicking on the small arrow next to its name.</p></li><li><p>Locate the <code class="literal">muzzle</code> game object (a child of <code class="literal">Gun</code>) within the <code class="literal">player_m</code> hierarchy and drag it into the <span class="strong"><strong>Muzzle</strong></span> slot under the <code class="literal">FPSAnimation (Script)</code> component in the <span class="strong"><strong>Inspector</strong></span> panel.</p><p>The <code class="literal">bulletCube</code> prefab already has a small script attached to allow it to cause damage with the items it hits.</p><p>To decrease the clutter in our <span class="strong"><strong>Scene</strong></span> view, we can also make the waypoints invisible now that we do not need to see them anymore.</p></li><li><p>Select both waypoint objects in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, uncheck their <span class="strong"><strong>Mesh Renderer</strong></span> components.</p></li></ol></div><p>They should become invisible in the <span class="strong"><strong>Scene</strong></span> view, though they can still be selected in the hierarchy panel. If we test the game at this point, when we shoot the patrolling zombie, she will drop to the ground lifelessly.</p><p>With the values we have set up, it should take three shots to kill a zombie:</p><div class="mediaobject"><img src="/graphics/9781849696364/graphics/6364OT_09_08.jpg" /></div><p>In the next <a id="id589" class="indexterm"></a>section, we will demonstrate how we can use our Mecanim animation setup with navMesh.</p></div></div></div>