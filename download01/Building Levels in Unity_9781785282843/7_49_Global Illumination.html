<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec49"></a>Global Illumination</h2></div></div><hr /></div><p>There are two types of<a id="id399" class="indexterm"></a> lighting that you will need to take into account if you want to create well lit levels—direct and indirect.</p><p>Direct light is the one that is coming directly from the source. Indirect light is created by light bouncing off the affected area at a certain angle with variable intensity. In the real world, the number of bounces is infinite and that is the reason why we can see dark areas that don't have light shining directly at them. In computer software, we don't yet have the infinite computing power at our disposal to be able to use different tricks to simulate the realistic lighting at runtime. The process that simulates indirect lighting, light bouncing, reflections, and color bleeding is known as <span class="strong"><strong>Global Illumination</strong></span> (<span class="strong"><strong>GI</strong></span>).</p><p>Unity 5 is powered by<a id="id400" class="indexterm"></a> one of the industry's leading technologies for handling indirect lighting (radiosity) in the gaming industry, called Enlighten by Geomerics. Games such as <span class="emphasis"><em>Battlefield 3-4</em></span>, <span class="emphasis"><em>Medal of Honor: Warfighter</em></span>, <span class="emphasis"><em>Need for Speed the Run</em></span> and <span class="emphasis"><em>Dragon Age: Inquisition</em></span> are excellent examples of what this technology is capable of, and now all of that power is at your fingertips completely for free! Now, it's only appropriate to learn how to tame this new beast.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec75"></a>Preparing the environment</h3></div></div></div><p>As I've mentioned before, realtime<a id="id401" class="indexterm"></a> realistic lighting is just not feasible at our level of computing power, which forces us into inventing tricks to simulate it as close as possible, but just like with any trick, there are certain conditions that need to be met in order for it to work properly and keep viewer's eyes from exposing our clever deception. To demonstrate how to work with these limitations, we are going to construct a simple light set up for the small interior scene and talk about solutions to the problems as we go.</p><p>For the following example, we will use the <span class="strong"><strong>LightmappingInterior</strong></span> scene that can be found in the <span class="strong"><strong>Chapter 7</strong></span> folder in the <span class="strong"><strong>Project</strong></span> window. It's a very simple interior and should take us no time to set up.</p><p>The first step is to place the lights. In this example, we will be required to create two lights: a <span class="strong"><strong>Directional</strong></span> to imitate the moonlight coming from the crack in the dome and a <span class="strong"><strong>Point</strong></span> light for the fire burning in the goblet, on the ceiling.</p><div class="mediaobject"><img src="/graphics/9781785282843/graphics/B04214_07_12.jpg" /></div><p>Tune the <a id="id402" class="indexterm"></a>light's <span class="strong"><strong>Intensity</strong></span>, <span class="strong"><strong>Range</strong></span> (in <span class="strong"><strong>Point</strong></span> light's case), and <span class="strong"><strong>Color</strong></span> to your liking.</p><p>So far so good! We can see the direct lighting coming from the moonlight, but there is no trace of indirect lighting. Why is this happening? Should GI be enabled somehow for it to work? As a matter of fact, it does and here comes the first limitation of Global Illumination—it only works on GameObjects that are marked as <span class="strong"><strong>Static</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec76"></a>Static versus dynamic objects</h3></div></div></div><p>Unity objects can<a id="id403" class="indexterm"></a> be of one of the two<a id="id404" class="indexterm"></a> categories: static or dynamic. Differentiation is<a id="id405" class="indexterm"></a> very simple: static objects don't move, they stay still where they are at all times, they neither play any animations nor engage in any kind of interactions. The rest of the objects are dynamic.</p><p>By default, all objects in Unity are dynamic and can only be converted into static by checking the <span class="strong"><strong>Static</strong></span> checkbox in the <span class="strong"><strong>Inspector</strong></span> window.</p><div class="mediaobject"><img src="/graphics/9781785282843/graphics/B04214_07_13.jpg" /></div><p>See it for yourself. Try to mark an object as static in Unity and attempt to move it around in the <span class="strong"><strong>Play</strong></span> mode. Does it work?</p><p>Global Illumination will only work with static objects; this means, before we go into the "Play" - just like the Play mode right above it. mode, we need to be 100 percent sure that the objects that will cast and receive indirect lights will not stop doing that from their designated positions. However, why is that you may ask, isn't the whole purpose of <span class="strong"><strong>Realtime GI</strong></span>
<a id="id406" class="indexterm"></a> to calculate indirect lighting in runtime? The answer to that would be yes, but only to an extent. The technology behind this is called <a id="id407" class="indexterm"></a>
<span class="strong"><strong>Precomputed Realtime GI</strong></span>, according to Unity developers it precomputes all possible bounces that the light can make and encodes them to be used in realtime; so it essentially tells us that it's going to take a static object, a light and answer a question: "If this light is going to travel around, how is it going to bounce from the affected surface of the static object from every possible angle?"</p><div class="mediaobject"><img src="/graphics/9781785282843/graphics/B04214_07_14.jpg" /></div><p>During runtime, lights <a id="id408" class="indexterm"></a>are using <a id="id409" class="indexterm"></a>this encoded data as instructions on how<a id="id410" class="indexterm"></a> the light should bounce instead of calculating it every frame.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>Having static objects can be beneficial in many other ways, such as pathfinding, but that's a story for another time.</p></div><p>To test this theory, let's mark objects in the scene as <span class="strong"><strong>Static</strong></span>, meaning they will not move (and can't be forced to move) by physics, code or even transformation tools (the latter is only true during the <span class="strong"><strong>Play</strong></span> mode). To do that, simply select <span class="strong"><strong>Pillar</strong></span>, <span class="strong"><strong>Dome</strong></span>, <span class="strong"><strong>WaterProNighttime</strong></span>, and <span class="strong"><strong>Goblet</strong></span> GameObjects in the <span class="strong"><strong>Hierarchy</strong></span> window and check the <span class="strong"><strong>Static</strong></span> checkbox at the top-right corner of the <span class="strong"><strong>Inspector</strong></span> window.</p><p>Doing that will <a id="id411" class="indexterm"></a>cause Unity to <a id="id412" class="indexterm"></a>recalculate the light and encode bouncing<a id="id413" class="indexterm"></a> information. Once the process has finished (it should take no time at all), you can hit the <span class="strong"><strong>Play</strong></span> button and move the light around. Notice that bounce lighting is changing as well without any performance overhead.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec77"></a>Fixing the light coming from the crack</h3></div></div></div><p>Before we move on to the<a id="id414" class="indexterm"></a> next topic, there is one simple issue that could use a quick fix.</p><p>The moonlight inside the dome should be coming from the crack on its surface, however, if you rotate the directional light around, you'll notice that it simply ignores concrete walls and freely shines through. Naturally, that is incorrect behavior and we can't have that stay.</p><p>We can clearly see through the dome ourselves from the outside as a result of one-sided normals, something we've discussed in the previous chapters during the asset import. Earlier, the solution was to duplicate the faces and invert the normals; however, in this case, we actually don't mind seeing through the walls and only want to fix the lighting issue. To fix this, we need to go to the <span class="strong"><strong>Mesh Render</strong></span> component of the <span class="strong"><strong>Dome</strong></span> <span class="strong"><strong>GameObject</strong></span> and select the <span class="strong"><strong>Two Sided</strong></span> option from the drop-down menu of the <span class="strong"><strong>Cast Shadows</strong></span> parameter.</p><div class="mediaobject"><img src="/graphics/9781785282843/graphics/B04214_07_15.jpg" /></div><p>This will ignore backface culling and allow us to cast shadows from both sides of the mesh, thus fixing the problem. In order to cast shadows, make sure that your directional light has <span class="strong"><strong>Shadow Type</strong></span> parameter set to either <span class="strong"><strong>Hard Shadows</strong></span> or <span class="strong"><strong>Soft Shadows</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781785282843/graphics/B04214_07_16.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec78"></a>Emission materials</h3></div></div></div><p>Another way to <a id="id415" class="indexterm"></a>light up <a id="id416" class="indexterm"></a>the level is to utilize materials with <span class="strong"><strong>Emission</strong></span> maps. <span class="strong"><strong>Pillar_EmissionMaterial</strong></span> applied to the <span class="strong"><strong>Pillar</strong></span> GameObject already has an <span class="strong"><strong>Emission</strong></span> map assigned to it, all that is left is to crank up the parameter next to it, to a number which will give it a noticeable effect (let's say <code class="literal">3</code>).</p><div class="mediaobject"><img src="/graphics/9781785282843/graphics/B04214_07_17.jpg" /></div><p>Unfortunately, emissive <a id="id417" class="indexterm"></a>materials are not lights, and precomputed GI will not be able to update indirect light <a id="id418" class="indexterm"></a>bounce created by the emissive material. As a result, changing material in the <span class="strong"><strong>Play</strong></span> mode will not cause the update.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"></a>Note</h3><p>Changes done to materials in the <span class="strong"><strong>Play</strong></span> mode will be preserved in the Editor.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec79"></a>Shadows</h3></div></div></div><p>An important <a id="id419" class="indexterm"></a>byproduct of lighting is<a id="id420" class="indexterm"></a> shadows cast by affected objects. No surprises here! Unity allows us to cast shadows by both dynamic and static objects and have different results based on render settings.</p><p>By default, all lights in Unity have shadows disabled. In order to enable shadows for a particular light, we need to modify the <span class="strong"><strong>Shadow Type</strong></span> parameter to be either <span class="strong"><strong>Hard Shadows</strong></span> or <span class="strong"><strong>Soft Shadows</strong></span> in the <span class="strong"><strong>Inspector</strong></span> window.</p><div class="mediaobject"><img src="/graphics/9781785282843/graphics/B04214_07_18.jpg" /></div><p>Enabling shadows <a id="id421" class="indexterm"></a>will grant <a id="id422" class="indexterm"></a>you access to three parameters:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Strength</strong></span>: This is the darkness of shadows, from <code class="literal">0</code> to <code class="literal">1</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Resolution</strong></span>: This controls the resolution of the shadows. This parameter can utilize the value set in the <span class="strong"><strong>Use Quality Settings</strong></span> or be selected individually from the drop down menu.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Bias</strong></span> and <span class="strong"><strong>Normal Bias</strong></span> – this is the shadow offset. These parameters are used to prevent an artifact known as <span class="strong"><strong>Shadow Acne</strong></span> (pixelated shadows in lit areas); however, setting them too high can cause another artifact known as <span class="strong"><strong>Peter Panning</strong></span> (disconnected shadow). Default values usually help us to avoid both issues.</p></li></ul></div><p>Unity is using a technique known as <span class="strong"><strong>Shadow Mapping</strong></span>, which determines the objects that will be lit by assuming the light's perspective—every object that light sees directly, is lit; every object that isn't seen should be in the shadow. After rendering the light's perspective, Unity stores the depth of each surface into a shadow map. In the cases where the shadow map resolution is low, this can cause some pixels to appear shaded when they shouldn't be (Shadow Acne) or not have a shadow where it's supposed to be (Peter Panning), if the offset is too high.</p><div class="mediaobject"><img src="/graphics/9781785282843/graphics/B04214_07_19.jpg" /></div><p>Unity allows <a id="id423" class="indexterm"></a>you to control <a id="id424" class="indexterm"></a>the objects that should receive or cast shadows by changing the parameters <span class="strong"><strong>Cast Shadows </strong></span>and <span class="strong"><strong>Receive Shadows</strong></span> in the <span class="strong"><strong>Rendering Mesh</strong></span> component of a GameObject.</p><div class="mediaobject"><img src="/graphics/9781785282843/graphics/B04214_07_20.jpg" /></div></div></div>