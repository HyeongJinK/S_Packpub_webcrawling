<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec37"></a>Inventory system</h2></div></div><hr /></div><p>As with everything else we have discussed thus far, designing your Inventory System is also going to be heavily dependent on your game. There are many different types of Inventory System mechanics that you can study and choose based on the relevance of it to your game.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec39"></a>Weighted Inventory</h3></div></div></div><p>I am going to be leaning towards implementing what is called the Weighted Inventory. In this type of inventory system, each item or piece of equipment is assigned a numerical value that represents the weight of the item. This in turn is used to determine how much inventory the player can carry at any given time during game play. This makes sense for our RPG, if you think about it.</p><p>Consider the following as an example: assume you are a hiker who wants to climb Mount Ararat. The climb itself is going to require some time and during the journey you will need to carry with you the necessary equipment to be able to complete the journey. Realistically, there are several crucial items that you as the hiker will need to carry with you. Here is a simplified list:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Clothing</p></li><li style="list-style-type: disc"><p>Tents</p></li><li style="list-style-type: disc"><p>Sleeping bags</p></li><li style="list-style-type: disc"><p>Boots</p></li><li style="list-style-type: disc"><p>Icebreakers</p></li><li style="list-style-type: disc"><p>Food</p></li><li style="list-style-type: disc"><p>Light source</p></li><li style="list-style-type: disc"><p>Personal items</p></li></ul></div><p>Each one of the categories listed has a specific weight associated to it in real life. Therefore, when you are planning your hike, you will need to plan ahead and see how you can meet your climbing needs while in the meantime also reducing the number of items and the total weight of the items you will need to carry on your back during the journey. The actual logistics are a little more involved, but you get the picture.</p><p>It is no different in our RPG. The player character can only carry certain number of items and or equipment with them for their journey. For instance, the player character cannot be carrying 20 different types of weapons at any given time! It would be just impossible, realistically speaking. So it would be a nice touch to put in some realism in the gameplay.</p><p>Also, just like in real life, the heavier the equipment one has to carry, the more energy it will use. So we can also incorporate such a system for our game. For instance, carrying too many weapons will have a major effect on the player character over a long period of time. First of all, it will reduce its speed and movement drastically, and secondly, it can have a major impact on the health of the player. This is where your creativity and design skills will come into play. You are the master of the game, and you determine how you want to implement it!</p><p>I am going to keep it simple for demonstration's sake!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec40"></a>Determining item types</h3></div></div></div><p>For starters, we are going to concentrate on some of the basic item types that we would like to define in our game. These are going to be weapons, armour, and clothing. On top of this, we can also add the following: health packets, potions, and collectables.</p><p>We are going to create three new scripts named <code class="literal">BaseItem.cs, InventoryItem.c</code>
<span class="emphasis"><em>s</em></span> and <code class="literal">InventorySystem.cs</code>. The <code class="literal">BaseItem</code> class will hold the generic properties for all items, just like the <code class="literal">BaseCharacter</code> class we defined previously. The <code class="literal">InventoryItem</code> class will inherit the <code class="literal">BaseItem</code> class and define the item type.</p><p>Here is a listing of <code class="literal">BaseItem.cs</code>:</p><pre class="programlisting">using System; &#13;
using UnityEngine; &#13;
using System.Collections; &#13;
 &#13;
 &#13;
[Serializable] &#13;
public class BaseItem &#13;
{ &#13;
  public enum ItemCategory &#13;
  { &#13;
    WEAPON = 0, &#13;
    ARMOUR = 1, &#13;
    CLOTHING = 2, &#13;
    HEALTH = 3, &#13;
    POTION = 4 &#13;
  } &#13;
 &#13;
  [SerializeField] &#13;
  private string name; &#13;
  [SerializeField] &#13;
  private string description; &#13;
 &#13;
  public string NAME &#13;
  { &#13;
    get { return this.name; } &#13;
    set { this.name = value; } &#13;
  } &#13;
 &#13;
  public string DESCRIPTION &#13;
  { &#13;
    get { return this.description; } &#13;
    set { this.description = value; } &#13;
  } &#13;
 &#13;
} &#13;
</pre><p>The main idea in the preceding code is the <code class="literal">ItemCategory</code>. At the moment, I have kept it to only five different types of categories that the Inventory would keep track of.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p>A category could have multiple item types. For instance, there are different types of weapons, such as swords, hammers, and spears.</p></div><p>Here is the listing of <code class="literal">InventoryItem.cs</code>:</p><pre class="programlisting">using System; &#13;
using UnityEngine; &#13;
using System.Collections; &#13;
 &#13;
 &#13;
[Serializable] &#13;
public class InventoryItem : BaseItem &#13;
{ &#13;
  [SerializeField] &#13;
  private ItemCategory category; &#13;
  [SerializeField] &#13;
  private float strength; &#13;
  [SerializeField] &#13;
  private float weight; &#13;
 &#13;
  public ItemCategory CATEGORY &#13;
  { &#13;
    get { return this.category; } &#13;
    set { this.category = value; } &#13;
  } &#13;
 &#13;
  public float STRENGTH &#13;
  { &#13;
    get { return this.strength; } &#13;
    set { this.strength = value; } &#13;
  } &#13;
 &#13;
  public float WEIGHT &#13;
  { &#13;
    get { return this.weight; } &#13;
    set { this.weight = value; } &#13;
  } &#13;
} &#13;
</pre><p>The preceding code implements more properties or attributes for the items to be used in the inventory. For now, let's just keep it the way it is. We can always change it in the future.</p><p>The next important script is the actual script that will be used to manage the inventory. There are many ways to implement the logic for the inventory system. Again keeping things simple, the current script will have five <code class="literal">List</code> datatypes of type <code class="literal">InventoryItem</code>, one for each item category.</p><p>Here is the listing of <code class="literal">InventorySystem.cs</code>:</p><pre class="programlisting"> using System; &#13;
using UnityEngine; &#13;
using System.Collections.Generic; &#13;
 &#13;
[Serializable] &#13;
public class InventorySystem &#13;
{ &#13;
  [SerializeField] &#13;
  private List&lt;InventoryItem&gt; weapons = new List&lt;InventoryItem&gt;(); &#13;
  [SerializeField] &#13;
  private List&lt;InventoryItem&gt; armour = new List&lt;InventoryItem&gt;(); &#13;
  [SerializeField] &#13;
  private List&lt;InventoryItem&gt; clothing = new List&lt;InventoryItem&gt;(); &#13;
  [SerializeField] &#13;
  private List&lt;InventoryItem&gt; health = new List&lt;InventoryItem&gt;(); &#13;
  [SerializeField] &#13;
  private List&lt;InventoryItem&gt; potion = new List&lt;InventoryItem&gt;(); &#13;
 &#13;
  private InventoryItem selectedWeapon; &#13;
  private InventoryItem selectedArmour; &#13;
 &#13;
  public InventoryItem SELECTED_WEAPON &#13;
  { &#13;
    get { return this.selectedWeapon; } &#13;
    set { this.selectedWeapon = value; } &#13;
  } &#13;
  public InventoryItem SELECTED_ARMOUR &#13;
  { &#13;
    get { return this.selectedArmour; } &#13;
    set { this.selectedArmour = value; } &#13;
  } &#13;
 &#13;
  public InventorySystem() &#13;
  { &#13;
    this.ClearInventory(); &#13;
  } &#13;
 &#13;
  public void ClearInventory() &#13;
  { &#13;
    this.weapons.Clear(); &#13;
    this.armour.Clear(); &#13;
    this.clothing.Clear(); &#13;
    this.health.Clear(); &#13;
    this.potion.Clear(); &#13;
  } &#13;
 &#13;
  // this function will add an inventory item &#13;
  public void AddItem(InventoryItem item) &#13;
  { &#13;
    switch(item.CATEGORY) &#13;
    { &#13;
      case BaseItem.ItemCategory.ARMOUR: &#13;
        { &#13;
          this.armour.Add(item); &#13;
          break; &#13;
        } &#13;
      case BaseItem.ItemCategory.CLOTHING: &#13;
        { &#13;
          this.clothing.Add(item); &#13;
          break; &#13;
        } &#13;
      case BaseItem.ItemCategory.HEALTH: &#13;
        { &#13;
          this.health.Add(item); &#13;
          break; &#13;
        } &#13;
      case BaseItem.ItemCategory.POTION: &#13;
        { &#13;
          this.potion.Add(item); &#13;
          break; &#13;
        } &#13;
      case BaseItem.ItemCategory.WEAPON: &#13;
        { &#13;
          this.weapons.Add(item); &#13;
          break; &#13;
        } &#13;
    } &#13;
  } &#13;
 &#13;
  // this function will remove an inventory item &#13;
  public void DeleteItem(InventoryItem item) &#13;
  { &#13;
    switch (item.CATEGORY) &#13;
    { &#13;
      case BaseItem.ItemCategory.ARMOUR: &#13;
        { &#13;
          this.armour.Remove(item); &#13;
          break; &#13;
        } &#13;
      case BaseItem.ItemCategory.CLOTHING: &#13;
        { &#13;
          this.clothing.Remove(item); &#13;
          break; &#13;
        } &#13;
      case BaseItem.ItemCategory.HEALTH: &#13;
        { &#13;
          this.health.Remove(item); &#13;
          break; &#13;
        } &#13;
      case BaseItem.ItemCategory.POTION: &#13;
        { &#13;
          this.potion.Remove(item); &#13;
          break; &#13;
        } &#13;
      case BaseItem.ItemCategory.WEAPON: &#13;
        { &#13;
          this.weapons.Remove(item); &#13;
          break; &#13;
        } &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>We won't have direct access to the lists that will be used to contain the inventory items. For now, we have implemented two functions, <code class="literal">AddItem() </code>and <code class="literal">DeleteItem()</code>, which will handle the two basic features of the inventory, adding an item to it and removing an item from it. These two functions will take an <code class="literal">InventoryItem</code> object and, based on the <code class="literal">ItemCategory</code>, be added or removed from the appropriate list within the inventory.</p><p>The basics are in place. Now we will need to integrate this with the <code class="literal">GameMaster.cs </code>script. To do so, we will need to create a new variable of type <code class="literal">InventorySystem</code> named <code class="literal">INVENTORY </code>and initialized in the <code class="literal">Awake() </code>function of the <code class="literal">GameMaster.cs </code>script.</p><p>The following listing will illustrate just the new addition:</p><pre class="programlisting">  // reference to player Character Customization &#13;
  public PC PC_CC; &#13;
  public InventorySystem INVENTORY; &#13;
 &#13;
  public GameObject START_POSITION; &#13;
 &#13;
  public GameObject CHARACTER_CUSTOMIZATION; &#13;
 &#13;
  public LevelController LEVEL_CONTROLLER; &#13;
  public AudioController AUDIO_CONTROLLER; &#13;
 &#13;
  // Ref to UI Elements ... &#13;
  public bool DISPLAY_SETTINGS = false; &#13;
  public UIController UI; &#13;
 &#13;
  void Awake() &#13;
  { &#13;
    // simple singleton &#13;
    if (instance == null) &#13;
    { &#13;
      instance = this; &#13;
 &#13;
      // initialize Level Controller &#13;
      instance.LEVEL_CONTROLLER = new LevelController(); &#13;
 &#13;
      // initialize Audio Controller &#13;
      instance.AUDIO_CONTROLLER = new AudioController(); &#13;
      instance.AUDIO_CONTROLLER.AUDIO_SOURCE = GameMaster.instance.GetComponent&lt;AudioSource&gt;(); &#13;
      instance.AUDIO_CONTROLLER.SetDefaultVolume(); &#13;
 &#13;
      // initialize Inventory System &#13;
      instance.INVENTORY = new InventorySystem(); &#13;
      InventoryItem tmp = new InventoryItem(); &#13;
      tmp.CATEGORY = BaseItem.ItemCategory.CLOTHING; &#13;
      tmp.NAME = "Testing"; &#13;
      tmp.DESCRIPTION = "Testing the item type"; &#13;
      tmp.STRENGTH = 0.5f; &#13;
      tmp.WEIGHT = 0.2f; &#13;
      instance.INVENTORY.AddItem(tmp); &#13;
    } &#13;
    else if (instance != this) &#13;
    { &#13;
      Destroy(this); &#13;
    } &#13;
 &#13;
    // keep the game object when moving from &#13;
    // one scene to the next scene &#13;
    DontDestroyOnLoad(this); &#13;
  } &#13;
</pre><p>Notice that we are actually creating an <code class="literal">InventoryItem</code> and inserting it into the <code class="literal">InventorySystem</code> for testing purposes. Another great feature is the fact that you can see the <code class="literal">InventorySystem</code> within the designer, in the <span class="emphasis"><em>Inspector Window</em></span>, since we have serialized the classes and the fields:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_06_001.jpg" /></div><p>
</p><p>The preceding screenshot displays the Inventory System as seen in the <span class="strong"><strong>Inspector Window</strong></span> when you select the <span class="strong"><strong>GameMaster</strong></span> object. When you run the game to test it, you will see the following update:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_06_002.jpg" /></div><p>
</p><p>Notice in the preceding screenshot how the data reflects appropriately in the Inventory System as expected! The <span class="strong"><strong>Clothing</strong></span> list has now increased its size to 1, and the <code class="literal">InventoryItem</code> within the list is properly stored and displayed for testing and debugging. We have one Clothing item named <span class="strong"><strong>Testing</strong></span>, with the given description and a <span class="strong"><strong>Strength</strong></span>
<span class="emphasis"><em> of </em></span>
<span class="strong"><strong>0.5</strong></span> and a <span class="strong"><strong>Weight</strong></span>
<span class="emphasis"><em> of </em></span>
<span class="strong"><strong>0.2</strong></span>.</p><p>So far so good, now we need to actually create the items that will be used to visually represent our Inventory Items! This is discussed in the next section.</p></div></div>