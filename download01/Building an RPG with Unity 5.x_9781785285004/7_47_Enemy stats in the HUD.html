<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec46"></a>Enemy stats in the HUD</h2></div></div><hr /></div><p>We have not really discussed how to handle and manage the statistics and the visual representation of the NPC with the player. It is now time to do just that! So we need to decide what it is that we want to display as information to the player. For the moment, let's keep it simple and just display the basic health and strength of the enemy.</p><p>The question is, what is the best way to display this information? Should we display the information based on a distance threshold between the player character and the NPC, or should we display it when the player requests it at some time during gameplay?</p><p>Let's go ahead and take the first scenario. We will display the information for the NPC upon reaching a certain distance between the player character and the NPC. We can even make this distance the same as the line of sight we have set for the NPC! This is good because, if they can see us, then they are close enough for us to see their stats! Let's get to work!</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec57"></a>NPC stats user interface</h3></div></div></div><p>We are going to be using some of the existing textures that we have created for our player character. Like the textures for the health bar and strength bar, we just need to create a canvas that is going to be in the World Space and attached to the NPC character.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec58"></a>Creating the NPC canvas</h3></div></div></div><p>The main difference between the canvas we are going to create for the NPC and the one we have been creating for the player is some of the configurations.</p><p>One of the main differences is going to be the <span class="emphasis"><em>Render Mode</em></span> of the canvas. The NPC canvas is going to have a <span class="emphasis"><em>World Space Render Mode</em></span>. This will allow us to position the canvas as another GameObject within the scene. The next important difference will be the <span class="emphasis"><em>Rect Transform</em></span> attributes, and more importantly the <span class="emphasis"><em>Scale</em></span> and <span class="emphasis"><em>Rotation</em></span> attributes.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_07_020.jpg" /></div><p>
</p><p>To make life easier, all you need to do is create the canvas and change its properties as shown in the preceding screenshot. For the next step, you can copy the whole <span class="emphasis"><em>PanelCharacterInfo</em></span> we have developed in the previous sections, and paste it as a child of the new canvas.</p><p>This way, you will not have to re-create each UI element one by one and this will help save a lot of time. However, you will need to change the <span class="emphasis"><em>Scale</em></span> and the <span class="emphasis"><em>Transform</em></span> properties in the <span class="emphasis"><em>PanelCharacterInfo</em></span> panel, the new one, to arrange it so that it renders above the NPC's head!</p><p>The next step is for us to be able to control the values of the stat bars from the code. For this, we are going to create a new script called <span class="emphasis"><em>NPCStatUI.cs</em></span> and attach it to the canvas object we just created for the NPC stats.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note54"></a>Note</h3><p>I have renamed the canvas to <span class="emphasis"><em>CanvasNPCStats</em></span>.</p></div><p>Here is a listing of the script:</p><pre class="programlisting">using UnityEngine; &#13;
using UnityEngine.UI; &#13;
using System.Collections; &#13;
 &#13;
public class NPCStatUI : MonoBehaviour &#13;
{ &#13;
  public Image imgHealthBar; &#13;
  public Image imgManaBar; &#13;
} &#13;
</pre><p>The script we just created will only give us a reference to the image elements. We still need to be able to have a method to update the values.</p><p>We need to find a way to reference all of the NPC characters in a given scene. Once that is determined, we will need to set the initial values of the health and strength bar. Then, during gameplay, we will need to be able to update each NPC's stats according to the state of the game.</p><p>In order for us to identify the NPCs in a given scene, we are going to use the <span class="emphasis"><em>Tag</em></span> element defined in each GameObject. We need to create a new <span class="emphasis"><em>Tag</em></span> named <span class="emphasis"><em>ENEMY</em></span>, and every NPC that is of enemy type will need to be tagged as such. This is an easy way to do a quick search and get a list of GameObjects based on their <span class="emphasis"><em>Tag</em></span> value.</p><p>You should also start thinking about how are you going to dynamically attach the NPC stat canvas to the NPC on runtime. At the moment, for testing purposes, I am going to leave it attached to the model. But the question is, where do you actually attach it? Well, we have an empty GameObject named <span class="emphasis"><em>Follow</em></span> attached to our model prefab. Since this is driven from our player character model, we have embedded the <span class="emphasis"><em>Follow</em></span> as a placeholder for the main camera during gameplay. For the NPC, we are going to use it to attach the NPC canvas as a child GameObject to the <span class="emphasis"><em>Follow</em></span> GameObject in the model hierarchy. You can see these in the preceding screenshots.</p><p>We are going to use the <span class="emphasis"><em>NPC_Agent.cs</em></span> script to initialize the NPC Status canvas prefab and the appropriate values of the UI elements. This is the best place to place the initialization because it will be self-contained. Here is the new listing for the script:</p><pre class="programlisting">using UnityEngine; &#13;
using UnityEngine.UI; &#13;
 &#13;
using System; &#13;
using System.Collections; &#13;
 &#13;
[Serializable] &#13;
public class NPC_Agent : MonoBehaviour &#13;
{ &#13;
 &#13;
  [SerializeField] &#13;
  public NPC npcData; &#13;
 &#13;
  [SerializeField] &#13;
  public Transform canvasNPCStatsAttachment; &#13;
 &#13;
  [SerializeField] &#13;
  public Canvas canvasNPCStats; &#13;
 &#13;
  [SerializeField] &#13;
  public GameObject canvasNPCStatsPrefab; &#13;
 &#13;
  public void SetHealthValue(float value) &#13;
  { &#13;
    this.canvasNPCStats.GetComponent&lt;NPCStatUI&gt;().imgHealthBar.fillAmount -= value; &#13;
  } &#13;
 &#13;
  public void SetStrengthValue(float value) &#13;
  { &#13;
    this.canvasNPCStats.GetComponent&lt;NPCStatUI&gt;().imgManaBar.fillAmount -= value; &#13;
  } &#13;
 &#13;
  //// Use this for initialization &#13;
  void Start() &#13;
  { &#13;
    // let's go ahead and instantiate our stats &#13;
    GameObject tmpCanvasGO = GameObject.Instantiate( &#13;
      this.canvasNPCStatsPrefab, &#13;
      this.canvasNPCStatsAttachment.transform.position + this.canvasNPCStatsPrefab.transform.position, &#13;
      this.canvasNPCStatsPrefab.transform.rotation) as GameObject; &#13;
 &#13;
    tmpCanvasGO.transform.SetParent(this.canvasNPCStatsAttachment); &#13;
 &#13;
    this.canvasNPCStats = tmpCanvasGO.GetComponent&lt;Canvas&gt;(); &#13;
    this.canvasNPCStats.GetComponent&lt;NPCStatUI&gt;().imgHealthBar.fillAmount = 1f; &#13;
    this.canvasNPCStats.GetComponent&lt;NPCStatUI&gt;().imgManaBar.fillAmount = 1f; &#13;
 &#13;
  } &#13;
} &#13;
</pre><p>Note that you will need to assign <span class="emphasis"><em>canvasNPCStatsAttachment,</em></span> which will be used to store a reference to the GameObject we are going to attach to the NCP canvas, and <span class="emphasis"><em>canvasNPCStatsPrefab</em></span> will be used to assign the prefab representing the NPC status canvas at design time. If you run the game now, you will have the prefab instantiated dynamically and attached to the <span class="emphasis"><em>Follow</em></span> GameObject in the hierarchy, with the fill values set to 1f, that is, 100 percent.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec59"></a>NPC health</h3></div></div></div><p>We need to take a moment and go back to some of the initial scripts and configurations we created in the early chapters, where we defined the player character's <span class="emphasis"><em>Animator Controller</em></span> and <span class="emphasis"><em>CharacterController.cs</em></span> script.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note55"></a>Note</h3><p>Please refer to <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Character Design</em></span>, to refresh your memory about Animator Controller and Curves.</p></div><p>Open the Animator Controller we created in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Character Design</em></span>, named <span class="emphasis"><em>CH3_Animator_Controller</em></span>. Select the <span class="emphasis"><em>Parameters</em></span> tab and create a new parameter called <span class="emphasis"><em>Attack1C</em></span> of <span class="emphasis"><em>float</em></span> datatype.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_07_021.jpg" /></div><p>
</p><p>For a refresher, go back to the <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Player Character and Non-Player Character Design</em></span>, section, <span class="emphasis"><em>PC and NPC Interaction</em></span>, and you will recall how we defined and configured the Curve to assign the parameter based on the animation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note56"></a>Note</h3><p>We have defined the Curve only for one of the attack animations.</p></div><p>Once you have configured the parameter in the <span class="emphasis"><em>Animator Controller</em></span> for the player character, we have to update the <span class="emphasis"><em>CharacterController.cs</em></span> script to trigger an attack based on the parameter value.</p><p>The following listing is a partial listing of the script displaying just the modified portion:</p><pre class="programlisting">  void FixedUpdate() &#13;
  { &#13;
    // The Inputs are defined in the Input Manager &#13;
    h = Input.GetAxis("Horizontal"); // get value for horizontal axis &#13;
    v = Input.GetAxis("Vertical");   // get value for vertical axis &#13;
 &#13;
    speed = new Vector2(h, v).sqrMagnitude; &#13;
 &#13;
    animator.SetFloat("Speed", speed); &#13;
    animator.SetFloat("Horizontal", h); &#13;
    animator.SetFloat("Vertical", v); &#13;
 &#13;
    // We have three different attack modes, we have only implemented the curve parameter for attack1 &#13;
    // therefore, during game play if you use attack2/attack3 you will see the visual attack happening &#13;
    // but the data will not reflect &#13;
    if (this.attack1 || this.attack2 || this.attack3) &#13;
    { &#13;
      if (animator.GetFloat("Attack1C") == 1.0f) &#13;
      { &#13;
     &#13;
        GameMaster.instance.PlayerAttackEnemy(); &#13;
 &#13;
        // reset the timer &#13;
        this.attackTimer = Time.timeSinceLevelLoad + this.attackThreashold; &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>In the code, we check to see if any of the attack modes are active, and if so we check to see what the curve parameter <span class="emphasis"><em>Attack1C</em></span> is at the moment of the animation. If we are at <span class="emphasis"><em>1.0f</em></span>, then we call the <span class="emphasis"><em>GameMaster</em></span> object to perform the rest.</p><p>Now, we need to take a look at a few functions we have defined/modified in the <span class="emphasis"><em>GameMaster.cs</em></span> script:</p><pre class="programlisting">// for each level/scene that has been loaded&#13;
// do some of the preparation work&#13;
void OnLevelWasLoaded()&#13;
{&#13;
GameMaster.instance.LEVEL_CONTROLLER.OnLevelWasLoaded();&#13;
// find all NPC GameObjects of Enemy type&#13;
if(GameObject.FindGameObjectsWithTag("ENEMY").Length&gt;0)&#13;
{&#13;
var tmpGONPCEnemy = GameObject.FindGameObjectsWithTag("ENEMY");&#13;
GameMaster.instance.goListNPCEnemy.Clear();&#13;
foreach(GameObject goTmpNPCEnemy in tmpGONPCEnemy)&#13;
{&#13;
instance.goListNPCEnemy.Add(goTmpNPCEnemy);&#13;
instance.closestNPCEnemy = goTmpNPCEnemy;&#13;
}&#13;
}&#13;
}&#13;
public void PlayerAttackEnemy()&#13;
{&#13;
NPC npc = instance.closestNPCEnemy.GetComponent&lt;NPC_Agent&gt;().npcData;&#13;
npc.HEALTH -= 1;&#13;
}</pre><p>Some explanation is needed here. The function <span class="emphasis"><em>OnLevelWasLoaded()</em></span> is called each time a new scene is being loaded at runtime. This is where we query all GameObjects that are tagged <span class="emphasis"><em>ENEMY</em></span>. We then store them internally for further processing down the line.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note57"></a>Note</h3><p>For testing purposes and due to the simplicity of the scene, there is only one enemy present for testing, I am also setting the <span class="emphasis"><em>closestNPCEnemy</em></span> object to the last GameObject tagged <span class="emphasis"><em>ENEMY</em></span>. This variable is later used in the <span class="emphasis"><em>PlayerAttachEnemy()</em></span> function to set the NPCs <span class="emphasis"><em>HEALTH</em></span> property.</p></div><p>When the <span class="emphasis"><em>PlayerAttackEnemy()</em></span> function is called, we get a reference to the NPC component of the NPC character, and reduce the health based on the attack.</p><p>Now, this also forces us to update the <span class="emphasis"><em>BaseCharacter.cs</em></span> script; here is a listing of the modification:</p><pre class="programlisting">public float HEALTH&#13;
{&#13;
get { return this.health; }&#13;
set&#13;
{&#13;
this.health = value;&#13;
if(this.tag.Equals("Player"))&#13;
{&#13;
if (GameMaster.instance.UI.hudUI != null)&#13;
{&#13;
GameMaster.instance.UI.hudUI.imgHealthBar.fillAmount = this.health / 100.0f;&#13;
}&#13;
}&#13;
else&#13;
{&#13;
this.characterGO.GetComponent&lt;NPC_Agent&gt;().SetHealthValue(this.health / 100.0f);&#13;
}&#13;
}&#13;
}</pre><p>In the <span class="emphasis"><em>HEALTH</em></span> property, we check to see if we are the player or an NPC. If we are the player, we need to use the GameMaster to update our Stats UI, if we are going to update our own NPC Stats UI.</p><p>This mean that when you are creating your player character and/or NPC, you will need to make sure you are assigning the data elements properly, see here:</p><pre class="programlisting">void Awake()&#13;
{&#13;
PC tmp = new PC();&#13;
tmp.TAG = this.transform.gameObject.tag;&#13;
tmp.characterGO = this.transform.gameObject;&#13;
tmp.NAME = "Maximilian";&#13;
tmp.HEALTH = 100.0f;&#13;
tmp.DEFENSE = 50.0f;&#13;
tmp.DESCRIPTION = "Our Hero";&#13;
tmp.DEXTERITY = 33.0f;&#13;
tmp.INTELLIGENCE = 80.0f;&#13;
tmp.STRENGTH = 60.0f;&#13;
this.playerCharacterData = tmp;&#13;
}</pre><p>The preceding code snippet is the <span class="emphasis"><em>Awake()</em></span> from the <span class="emphasis"><em>PlayerAgent.cs</em></span> script. You will need to perform the same for the <span class="emphasis"><em>NPC_Agent.cs</em></span> script.</p><p>The code and scripts we have looked at have been used to test the ideas we have put forward. The results are positive. You might have noticed that when the player character is attacking, we are not taking into consideration its position relative to that of the enemy. We are also automatically assigning the closest NPC character in the GameMaster to eventually be the last element of the query we do each time a level loads.</p></div></div>