<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec50"></a>Initial Multiplayer Game</h2></div></div><hr /></div><p>The best way to learn about multiplayer games is by doing a simple example. The following project is based on the Unity networking tutorial but has been extended to have some other features implemented that will be helpful in the implementation of networking in our RPG.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec60"></a>Fundamental Networking Components</h3></div></div></div><p>We need to get familiar with some networking components that will be used for the creation of our network-enabled games. These components are:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Network Manager</strong></span>: The NetworkManager is a higher level class that allows you to control the state of a networked game. It provides an interface in the editor to control the configuration of the network, the prefabs used for spawning, and the scenes to use for different network game states.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Network Manager HUD</strong></span>: This provides a default user interface for controlling the network state of the game. It also shows information about the current state of the NetworkManager in the editor.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Network Identity</strong></span>: The NetworkIdentity component is at the heart of the new networking system. This component controls an object's network identity and it makes the networking system aware of it.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Network Transform</strong></span>: The NetworkTransform component synchronizes movement of game objects across the network. This component takes authority into account, so LocalPlayer objects synchronize their position from the client to server, then out to other clients. Other objects (with server authority) synchronize their position from the server to clients.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec61"></a>Networking Project</h3></div></div></div><p>The following project is used to demonstrate the concepts of a multiplayer game. The concepts can then be applied to more complex scenarios.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_001.jpg" /></div><p>
</p><p>We will start by creating a new Unity project. All multiplayer games need to have a NetworkManager implemented. To do this, we are going to create an Empty GameObject and rename it to Network Manager; now attach the NetworkManager component to the newly created object using the Inspector Window and navigating to <span class="strong"><strong>Add Component</strong></span>
<span class="emphasis"><em> | </em></span>
<span class="strong"><strong>Network</strong></span> | <span class="strong"><strong>NetworkManager</strong></span>. We are also going to add the <span class="strong"><strong>Network Manager HUD</strong></span> component to the selected GameObject. Again, from the InspectorWindow navigate to <span class="strong"><strong>Add Component | Network | NetworkManagerHUD.</strong></span>
</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec62"></a>Adding Player Character</h3></div></div></div><p>We are now going to be adding a simple character player. You can really use any primitive GameObject to represent your PC, I am going to create my player to take the shape of a simple tank. See the following figure:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_002.jpg" /></div><p>
</p><p>The following image will illustrate the hierarchy of the Tank GameObject:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_003.jpg" /></div><p>
</p><p>I am not going to cover how to create the GameObject, as you should be able to do that very easily by now. What I will cover, is how to enable the new Tank GameObject network enabled.</p><p>We are going to attach two network components to the Tank GameObject. The first one is going to be NetworkIdentity, which can be added by selecting the <span class="strong"><strong>Tank</strong></span> GameObject and from within the Inspector Window navigating to <span class="strong"><strong>Add Component | Network | Network Identity.</strong></span>
</p><p>When you are done adding the component, make sure to check the <span class="strong"><strong>Local Player Authority</strong></span> property checkbox.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_004.jpg" /></div><p>
</p><p>The Local Player Authority allows the object to be controlled by the client that owns it.</p><p>Next, we need to add the NetworkTransform component to the Tank GameObject. Again, selecting the <span class="strong"><strong>Tank</strong></span> GameObject, from the <span class="emphasis"><em>Inspector Window </em></span>and navigate to <span class="strong"><strong>Add Component | Network | NetworkTransform</strong></span> to add the component:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_005.jpg" /></div><p>
</p><p>We are going to keep the default values for the <span class="strong"><strong>NetworkTransform</strong></span> component. You can read more on the different properties on your own using the online documentation. The main attribute you may want to adjust is the <span class="strong"><strong>Network Send Rate</strong></span>.</p><p>Next, we want to create a script that will allow us to control the movement of the Tank. Go ahead and create a new C# script and name it PlayerController.cs.</p><p>Here is a listing of the script:</p><pre class="programlisting">using UnityEngine; &#13;
using UnityEngine.Networking; &#13;
using System.Collections; &#13;
 &#13;
public class PlayerController : NetworkBehaviour &#13;
{ &#13;
 &#13;
  public GameObject bulletPrefab; &#13;
  public Transform bulletSpawn; &#13;
 &#13;
  public override void OnStartLocalPlayer() &#13;
  { &#13;
    GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue; &#13;
  } &#13;
 &#13;
  void Update() &#13;
  { &#13;
    // only execute the following code if local player ... &#13;
    if (!isLocalPlayer) &#13;
      return; &#13;
 &#13;
    var x = Input.GetAxis("Horizontal") * Time.deltaTime * 150.0f; &#13;
    var z = Input.GetAxis("Vertical") * Time.deltaTime * 3.0f; &#13;
 &#13;
    transform.Rotate(0, x, 0); &#13;
    transform.Translate(0, 0, z); &#13;
 &#13;
    if (Input.GetKeyDown(KeyCode.Space)) &#13;
    { &#13;
      CmdFire(); &#13;
    } &#13;
  } &#13;
 &#13;
  [Command] &#13;
  void CmdFire() &#13;
  { &#13;
    // Create the Bullet from the Bullet Prefab &#13;
    var bullet = (GameObject)Instantiate( &#13;
        bulletPrefab, &#13;
        bulletSpawn.position, &#13;
        bulletSpawn.rotation); &#13;
 &#13;
    // Add velocity to the bullet &#13;
    bullet.GetComponent&lt;Rigidbody&gt;().velocity = bullet.transform.forward * 6; &#13;
 &#13;
    if(isLocalPlayer) &#13;
      bullet.GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue; &#13;
 &#13;
    // Spawn the bullet on the Clients &#13;
    NetworkServer.Spawn(bullet); &#13;
 &#13;
    // Destroy the bullet after 2 seconds &#13;
    Destroy(bullet, 2.0f); &#13;
  } &#13;
 &#13;
} &#13;
</pre><p>The code is straightforward, but there are some important concepts that we need to discuss. First and foremost, you will note that we are inheriting from <code class="literal">NetworkBehaviour</code>, instead of <code class="literal">MonoBehaviour</code>.</p><p>NetworkBehaviour is used to work with objects with the NetworkIdentiy component. This allows you to perform network-related functions such as Commands, ClientRPCs, SyncEvents, and SyncVars.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec18"></a>Variable Synchronization</h4></div></div></div><p>Synchronizing variables is one of the important aspects of a multiplayer game. If you recall, one of the challenges of multiplayer games was the ability to make sure all of the key data for the game is synchronized across the server and the clients. This is accomplished by the <code class="literal">SyncVar</code>attribute. You will see how this is applied in the next script we are going to create for the health of the unity.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec19"></a>Network Callbacks</h4></div></div></div><p>These are functions that are invoked on NetworkBehaviour script for various network events. Here is a list:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">OnStartServer()</code>: This is called when an object is spawned on the server or when the server is started for objects in the scene.</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnStartClient()</code>: This is called when the object is spawned on the client or when the client connects to a server for objects in the scene.</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnSerialize()</code>: This is called to gather state to send from the server to clients.</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnDeSerialize()</code>: This is called to apply a state to objects on clients.</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnNetworkDestroy()</code>: This is called on clients when server told the object to be destroyed.</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnStartLocalPlayer()</code>: This is called on clients for player objects for the local client only.</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnRebuildObservers()</code>: This is called on the server when the set of observers for an object is rebuild.</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnSetLocalVisibility()</code>: This is called on a host when the visibility of an object changed for the local client.</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnCheckObserver()</code>: This is called on the server to check visibility state for a new client.</p></li></ul></div><p>In the <code class="literal">PlayerController.cs</code> script, you will note that we are using the <code class="literal">OnStartClient()</code> to highlight the local player by changing its material color to blue.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec20"></a>Sending Commands</h4></div></div></div><p>Commands are the way for clients to request a function to be performed on the server. In a server authoritative system, clients can only do things through commands. Commands are run on the player object on the server that corresponds to the client that sent the command. This routing happens automatically, so it is impossible for a client to send a command for a different player.</p><p>A command must begin with the prefix "Cmd" and have the [Command] custom attribute on them.</p><p>In our <code class="literal">PlayerController.cs</code> script, when the player fires, it send a command to the server using the <code class="literal">CmdFire()</code> function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec21"></a>Client RPC Calls</h4></div></div></div><p>Client RPC calls are a way for server objects to cause things to happen on client objects. This is the reverse direction to how commands send messages, but the concepts are the same. Client RPC calls, however, are not only invoked on player objects, they can be invoked on any NetworkIdentity object. They must begin with the prefix "Rpc" and have the [ClientRPC] custom attribute.</p><p>You will see an example of this on the <code class="literal">Health.cs</code> script, which we will be creating next.</p><p>We would need a way to also keep track of our player character's health. This will be done using a new script called <code class="literal">Health.cs</code>.</p><p>Here is a listing of the script:</p><pre class="programlisting">using UnityEngine; &#13;
using UnityEngine.Networking; &#13;
 &#13;
public class Health : NetworkBehaviour { &#13;
  public const int maxHealth = 100; &#13;
 &#13;
  [SyncVar(hook = "OnChangeHealth")] &#13;
  public int currentHealth = maxHealth; &#13;
 &#13;
  public RectTransform healthBar; &#13;
 &#13;
  public bool destroyOnDeath; &#13;
 &#13;
  public override void OnStartClient() &#13;
  { &#13;
    healthBar.sizeDelta = new Vector2(currentHealth, healthBar.sizeDelta.y); &#13;
  } &#13;
 &#13;
  public void TakeDamage(int amount) &#13;
  { &#13;
    currentHealth -= amount; &#13;
    if (currentHealth &lt;= 0) &#13;
    { &#13;
      if (destroyOnDeath) &#13;
      { &#13;
        Destroy(gameObject); &#13;
      } &#13;
      else &#13;
      { &#13;
        currentHealth = maxHealth; &#13;
 &#13;
        // called on the Server, will be invoked on the Clients &#13;
        RpcRespawn(); &#13;
      } &#13;
    } &#13;
 &#13;
  } &#13;
 &#13;
  void OnChangeHealth(int health) &#13;
  { &#13;
    healthBar.sizeDelta = new Vector2(health, healthBar.sizeDelta.y); &#13;
  } &#13;
 &#13;
  [ClientRpc] &#13;
  void RpcRespawn() &#13;
  { &#13;
    if (isLocalPlayer) &#13;
    { &#13;
      // move back to zero location &#13;
      transform.position = Vector3.zero; &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>Notice, in this script we are also inheriting from <code class="literal">NetworkBehaviour</code>. The two main items I want to bring to your attention are the <code class="literal">SyncVar</code>, the <code class="literal">ClientRpc</code>, and the <code class="literal">OnStartClient()</code> functions.</p><p>We want to synchronize the player's health across the network, to do this, we use the <code class="literal">SyncVar NetworkBehaviour</code>. <code class="literal">SyncVar</code> can be any basic type, not, classes, lists, or other collections.</p><p>When the value of a <code class="literal">SyncVar</code> is changed on the server, it will be sent to all of the ready clients in the game. When objects are spawned, they are created on the client with the latest state of all SyncVars from the server.</p><p>The <code class="literal">OnStartClient()</code> function makes sure that each object with the <code class="literal">Health.cs</code> script attached to it, will have the most up-to-date value to display on the health bar UI.</p><p>I want to take a moment and make sure I give you a crucial pointer here. Assume, we are running a networked game session, and we have the Host, PlayerA, and Player B connected and going about their business. During the gameplay, Player A and Player B have their health value changed. Now, we have a third player connect to the game, Player <span class="emphasis"><em>C</em></span>. If the <code class="literal">OnStartClient() </code>is not implemented, the client for PlayerC will have the correct data synchronized for all of the GameObjects with the <code class="literal">Health.cs</code> script; however, the data will not reflect correctly on the UI because, we need to have a trigger for that to happen. This can be handled in the <code class="literal">OnStartClient() </code>function as shown in the code.</p><p>The next function is the <code class="literal">RpcRespawn()</code> function. In the <code class="literal">TakeDamage()</code> function, we check the health of the current GameObject; if the health drops below zero, we check to see if the <code class="literal">destroyOnDeath</code> Boolean variable is set. If it is not set, we go ahead and reset the <code class="literal">currentHealth</code> value to <code class="literal">maxHealth</code> value, and we use the <code class="literal">RpcRespawn()</code> method to respawn the player at the origin. Remember this function is executed on all clients!</p><p>Within the function, we check to see if the caller is the local player by checking the variable <code class="literal">isLocalPlayer</code>. Yes, creating a multiplayer game does get confusing! This will become apparent more, as you start experimenting with it more.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec22"></a>Creating the Canon Ball for the Tank</h4></div></div></div><p>Ok, so we need to create a prefab that will represent our Canon Balls! Very simple, create a sphere, and make it the same size as the nozzle of your Tank Gun.</p><p>We are going to need to attach the following components to the Canon Ball GameObject: <code class="literal">NetworkIdentity</code>, <code class="literal">NetworkTransform</code>, <code class="literal">Rigidbody</code>, and a <code class="literal">Bullet.cs</code> scripts.</p><p>Make sure that you set the <code class="literal">Use Gravity</code> property is <code class="literal">False</code> on the <code class="literal">Rigidbody</code> component. Also, make sure that both <code class="literal">Server Only</code> and <code class="literal">Local Player Authority</code> properties are <code class="literal">False</code> on the <code class="literal">NetworkIdentity</code> component. On the <code class="literal">NetworkTransform</code> component, change the <code class="literal">Network Send Rate</code> to <span class="emphasis"><em>0</em></span>. Once we generate the object on the server, the physics will take care of the motion on each client.</p><p>Create a new C# script called <code class="literal">Bullet.cs</code>.</p><p>Here is the listing for the script:</p><pre class="programlisting">using UnityEngine; &#13;
 &#13;
public class Bullet : MonoBehaviour { &#13;
 &#13;
  void OnCollisionEnter(Collision collision) &#13;
  { &#13;
    var hit = collision.gameObject; &#13;
    var health = hit.GetComponent&lt;Health&gt;(); &#13;
    if (health != null) &#13;
    { &#13;
      health.TakeDamage(10); &#13;
    } &#13;
 &#13;
    Destroy(gameObject); &#13;
  } &#13;
} &#13;
</pre><p>All we are doing here is detecting a collision. If there is a collision, we get the <code class="literal">Health</code> component. If the <code class="literal">Health</code> component is not null, we call the <code class="literal">TakeDamage()</code> function and pass is a value.</p><p>If you recall from the <code class="literal">Health.cs</code> script, <code class="literal">the TakeDamage()</code> function reduces the <code class="literal">currentHealth </code>of the player, which in return is a <code class="literal">SyncVar</code> that it gets updated on all active clients.</p><p>One item we did not discuss is the idea of a <code class="literal">hook</code>. A <code class="literal">SyncVar</code> can have a <code class="literal">hook</code>. Think of a hook as an event handler. The hook attribute can be used to specify a function to be called when the <code class="literal">SyncVar</code> changes value on the client.</p><pre class="programlisting">  [SyncVar(hook = "OnChangeHealth")] &#13;
  public int currentHealth = maxHealth; &#13;
</pre><p>The <code class="literal">OnChangeHealth()</code> function is responsible to update the UI canvas for displaying our health value.</p><pre class="programlisting">  void OnChangeHealth(int health) &#13;
  { &#13;
    healthBar.sizeDelta = new Vector2(health, healthBar.sizeDelta.y); &#13;
  } &#13;
</pre><p>Go ahead and also make a prefab of the Canon Ball and delete the instance from the scene.</p><p>Make sure you have assigned the proper prefab association that are required on each script. For instance, the Tank GameObject's <code class="literal">PlayerController.cs</code> script needs a reference to the Canon Ball prefab and also the Canon Spawn Location. The <code class="literal">Health.cs</code> script needs a reference to the HealthBar foreground image and so on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec23"></a>Creating Tank Prefab and Configuring NetworkManager</h4></div></div></div><p>Now that we created our Tank GameObject and attached all of the necessary components and scripts to it. We need to make a Prefab of it. This is because we are going to let the NetworkManger spawn our Player Character, and in order for it to be able to do so, it needs to refer to a prefab that is a representation of your player character.</p><p>The <span class="strong"><strong>NetworkManager</strong></span> has a Spawn Info section that you can assign the Player Prefab, determine if the <span class="strong"><strong>NetworkManager</strong></span> can <span class="strong"><strong>Auto Create Player</strong></span> and the <span class="strong"><strong>Player Spawn Method</strong></span>.</p><p>There is also a section for Registered Spawnable Prefabs. We need to register all of the GameObjects that will be spawned by the NetworkServer. For instance, the Canon Ball prefab will need to be registered here so that we can spawn it across the network on different clients.</p><p>Select the Network Manager GameObject in the scene, and in the Inspector Window assign the appropriate prefabs as needed.</p><p>Here is a screenshot of how the <span class="emphasis"><em>NetworkManager</em></span> should look like at this point:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_006.jpg" /></div><p>
</p><p>At this point, you are ready to test out what we have built so far. Go ahead and create a standalone version of your game using the <span class="strong"><strong>Build Settings</strong></span> window. Once you have your build ready, launch two instances of the application. We are going to use one instance to host the game and the other to connect as a client.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_007.jpg" /></div><p>
</p><p>The following figure illustrates how your game instance will look like when you run it.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_008.jpg" /></div><p>
</p><p>The following figure will illustrate how your screen will look after you click on the <span class="strong"><strong>LAN Host (H)</strong></span> button. I moved the Tank (player character around).</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_009.jpg" /></div><p>
</p><p>The following figure illustrates host/client with three clients:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_010.jpg" /></div><p>
</p><p>Notice in the preceding figure, each client has highlighted the player character it controls, that is, the Tank it controls. It is going to be difficult to capture the fire command, but you can go ahead and use the <span class="strong"><strong>Space Bar</strong></span> to fire the Canon and it will be triggered accordingly on all active clients.</p><p>You will also notice that the health of each Tank will be reflected accurately if they do get a hit. Now, we are ready to create an enemy to illustrate the non-player character in the game.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec63"></a>Adding the Enemy Tank</h3></div></div></div><p>Now it is time to add some of the non-player characters to our multiplayer demo. Adding the Enemy Tank is going to be simple as we are going to use our Tank prefab as a base. Go ahead and drop the Tank prefab into the scene and change the name to TankEnemy.</p><p>Remove the <code class="literal">PlayerCharacter.cs</code> script from the <code class="literal">GameObject</code>. We are going to create a separate script as the controller for the Enemy Tank. I have also gone ahead and applied different material to the Enemy Tank, so visually we can distinguish which tanks are going to be controlled by players and which ones are going to be non-player.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_011.jpg" /></div><p>
</p><p>The preceding figure illustrates how your Tank and TankEnemy prefabs should look like. The main difference between the two is the controller script. Tank has the <code class="literal">PlayerController.cs</code> script and TankEnemy has <code class="literal">EnemyController.cs</code> script.</p><p>Here is a listing of the <code class="literal">EnemyController.cs</code> script:</p><pre class="programlisting">using UnityEngine; &#13;
using UnityEngine.Networking; &#13;
 &#13;
public class EnemyController : NetworkBehaviour &#13;
{ &#13;
 &#13;
  public GameObject bulletPrefab; &#13;
  public Transform bulletSpawn; &#13;
  public float distance = 1000; &#13;
 &#13;
  public GameObject[] listOfPlayers; &#13;
 &#13;
  [SyncVar(hook = "OnChangePlayerToAttack")] &#13;
  public GameObject playerToAttack; &#13;
 &#13;
  float coolOffTime = 0.0f; &#13;
 &#13;
  void Update() &#13;
  { &#13;
    // only execute the following code if local player ... &#13;
    if (!isServer) &#13;
      return; &#13;
 &#13;
    listOfPlayers = GameObject.FindGameObjectsWithTag("Player"); &#13;
    if (listOfPlayers.Length &gt; 0) &#13;
    { &#13;
 &#13;
      float distance = 100f; &#13;
      foreach (var player in listOfPlayers) &#13;
      { &#13;
        float d = Vector3.Distance(transform.position, player.transform.position); &#13;
        if (d &lt; distance) &#13;
        { &#13;
          distance = d; &#13;
          this.playerToAttack = player; &#13;
        } &#13;
      } &#13;
 &#13;
 &#13;
      if (this.playerToAttack != null) &#13;
      { &#13;
        Vector3 direction = playerToAttack.transform.position - transform.position; &#13;
 &#13;
        this.transform.rotation = &#13;
          Quaternion.Slerp(this.transform.rotation, &#13;
          Quaternion.LookRotation(direction), 0.1f); &#13;
 &#13;
        float d = Vector3.Distance(transform.position, playerToAttack.transform.position); &#13;
        if (d &lt; 15.0f) &#13;
        { &#13;
          if(this.coolOffTime&lt;Time.time) &#13;
          { &#13;
            CmdFire(); &#13;
            this.coolOffTime = Time.time + 1.0f; &#13;
          } &#13;
        } &#13;
      } &#13;
    } &#13;
  } &#13;
 &#13;
  void OnChangePlayerToAttack(GameObject player) &#13;
  { &#13;
    this.playerToAttack = player; &#13;
  } &#13;
 &#13;
  [Command] &#13;
  void CmdFire() &#13;
  { &#13;
    // Create the Bullet from the Bullet Prefab &#13;
    var bullet = (GameObject)Instantiate( &#13;
        bulletPrefab, &#13;
        bulletSpawn.position, &#13;
        bulletSpawn.rotation); &#13;
 &#13;
    // Add velocity to the bullet &#13;
    bullet.GetComponent&lt;Rigidbody&gt;().velocity = bullet.transform.forward * 6; &#13;
 &#13;
    // Spawn the bullet on the Clients &#13;
    NetworkServer.Spawn(bullet); &#13;
 &#13;
    // Destroy the bullet after 2 seconds &#13;
    Destroy(bullet, 2.0f); &#13;
  } &#13;
 &#13;
} &#13;
</pre><p>The script does the following. It continuously searches for all players that are active in the scene and makes a list of them. Then, it finds the closest one to itself. Once it determines which player is closest, it rotates to face the player.</p><p>Then, it calculates the distance between itself and the selected player, if the distance is shorter than the acceptable threshold, then it starts firing at the player. Each time the Enemy Tank fires, it actually calls a <span class="emphasis"><em>[Command]</em></span> named <code class="literal">CmdFire()</code>.</p><p>This function is run on the server, it instantiates a Canon Ball prefab and spawns it on the network.</p><p>The <code class="literal">EnemyController.cs</code> script also has a <code class="literal">SyncVar</code> for the <code class="literal">playertoAttack</code> variable, with a <code class="literal">hook</code> attached as <code class="literal">OnChangePlayerToAttack()</code> function. This in turn makes sure that all clients get updated with the latest data on each Enemy Tank GameObject.</p><p>The <code class="literal">Health.cs</code> script works the same as it does on the Tank GameObject.</p><p>There is one more item we need to cover, the spawning of the Enemy Tanks by the server. We can do this easily by creating another Empty GameObject, and naming it <code class="literal">Enemy Spawner</code>. We need to attach a <span class="emphasis"><em>NetworkIdentity</em></span> component and make sure we set the <code class="literal">Server Only</code> property, to <code class="literal">True</code>. This will make sure that only the server can instantiate the enemy objects.</p><p>The next step is to create the <code class="literal">EnemySpawner.cs</code> scripts. Here is the listing:</p><pre class="programlisting">using UnityEngine; &#13;
using UnityEngine.Networking; &#13;
 &#13;
public class EnemySpawner : NetworkBehaviour { &#13;
 &#13;
  public GameObject enemyPrefab; &#13;
  public int numberOfEnemies; &#13;
 &#13;
  public override void OnStartServer() &#13;
  { &#13;
    for (int i = 0; i &lt; numberOfEnemies; i++) &#13;
    { &#13;
      var spawnPosition = new Vector3( &#13;
          Random.Range(-8.0f, 8.0f), &#13;
          0.0f, &#13;
          Random.Range(-8.0f, 8.0f)); &#13;
 &#13;
      var spawnRotation = Quaternion.Euler( &#13;
          0.0f, &#13;
          Random.Range(0, 180), &#13;
          0.0f); &#13;
 &#13;
      var enemy = (GameObject)Instantiate(enemyPrefab, spawnPosition, spawnRotation); &#13;
      NetworkServer.Spawn(enemy); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>This code technically takes the prefab provided as the Enemy Tank and randomly spawns each enemy tank within a range over the network.</p><p>Make sure all of your prefabs have been assigned in the Inspector Window for both the <code class="literal">Enemy Spawner</code> GameObject and the <code class="literal">TankEnemy </code>GameObject. Create a Prefab of your <code class="literal">TankEnemy </code>if you have not done so already and delete it from the scene. Do not delete the <code class="literal">Enemy Spawner</code>.</p><p>We need to register the <code class="literal">TankEnemy </code>prefab with the NetworkManager. Go ahead and select the <span class="strong"><strong>Network Manager</strong></span> GameObject and from the <span class="emphasis"><em>Inspector Window</em></span>, add a new Prefab to the <span class="strong"><strong>Registered Spawnable Prefabs option</strong></span>.</p><p>Your Network Manager should look like the following now:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_012.jpg" /></div><p>
</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec64"></a>Building and Testing</h3></div></div></div><p>We are ready to do our final test. Go ahead and build the standalone version of the project and launch a new instance of the game. Click on the <span class="strong"><strong>LAN Host (H)</strong></span> button to start hosting a game.</p><p>In the new implementation, you will note that not only the player character tank gets spawned, but also the non-player character enemy tanks.</p><p>You will also note that right after initialization, all of the enemy tanks are going to rotate toward the player character tank and if within range, they are going to start firing at it.</p><p>The following figure illustrates the initial scene:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_013.jpg" /></div><p>
</p><p>Note that while I was trying to capture the screen, the enemy tank were merciless and fired at my tank continuously. You can see that my health bar has reduced drastically. You can also note that one of the enemy tank has also received some damage.</p><p>I assure you that I had nothing to do with the damage taken by the enemy tank, it was actually caused by friendly fire. Yes, at the moment, the enemy tanks are not smart enough to hold fire if another team member is in the line of fire!</p><p>I will let you handle the implementation of that on your own. It shouldn't be too complex.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip59"></a>Tip</h3><p>Use Raycasting to make sure there is no object between the enemy tank and the player prior to firing.</p></div><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_014.jpg" /></div><p>
</p><p>Congratulations! You just created your first multiplayer game! As mentioned earlier, creating, maintaining, and hosting a multiplayer game is no small task, and covering every single aspect on how to do it is simply impossible in a few pages.</p><p>The idea here is to give you the foundation and the fundamentals that you can take and expand upon. I would encourage you to take some time and study what we have just covered and do some more reading on the material, even though, not much exists. The truth is that you will need to do a lot of experimentation and trial and error on your own.</p><p>Now that we know the basics, let's go ahead and apply what you learned to our RPG assets.</p></div></div>