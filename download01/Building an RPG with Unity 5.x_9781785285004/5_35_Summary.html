<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec36"></a>Summary</h2></div></div><hr /></div><p>
<span class="emphasis"><em>Chapter 5</em></span> was mostly code. We enhanced the <code class="literal">GameMaster</code> Class to handle the game settings and scene management. We began the chapter by making the <code class="literal">GameMaster </code>handle the user interface, the player character data, and the game settings, which currently is just the volume for the background music.</p><p>We added a new UI element that displays the settings panel for the game. At the moment, it only contains the main volume control. Next, we added the necessary code in the <code class="literal">UIController</code> class and the <code class="literal">GameMaster</code> class to handle the display of the settings window and also the slider value passed from the UI component to the <code class="literal">UIController</code> to the <code class="literal">GameMaster </code>class.</p><p>We also made the <code class="literal">GameMaster</code> class into a singleton. A singleton in software engineering is a design pattern that restricts the instantiation of a class to one object. This pattern fits perfectly for the <code class="literal">GameMaster </code>as we only need to have one instance of it active at any given time throughout the lifespan of the game.</p><p>We also looked how to perform scene management. We defined a static class named <code class="literal">SceneName</code> that contains constant string variables identifying the scene references in our game.</p><p>We then took the next step to improve our <code class="literal">GameMaster</code> and the internal structure for our code. We created a new class called <code class="literal">LevelController.cs</code> that handles the scene management who in turn is driven by the <code class="literal">GameMaster.</code> We practically took the logic for level handling from within the <code class="literal">GameMaster</code> class and reworked and improved it in the <code class="literal">LevelController </code>class.</p><p>Next, we developed an <code class="literal">AudioController</code> class that basically manages the audio for our game. This class also is driven by the <code class="literal">GameMaster</code>. By this time, our <code class="literal">GameMaster</code> is a lean script that manages all of the other components.</p><p>The next big challenge was how to handle the player character data. Specifically speaking, how to save the character customization data for the player character internally after the player had customized the character. In order to save the data, we had to modify the PC.cs class.</p><p>We created several enumerations representing each part of the character that could be customized, such as the shoulder pad, the body type, the weapon type, the helmet type and so on. We used enumeration to make it easier to reference them within the code.</p><p>This approached forced us to make some modifications to the existing character customization setup that we have had implemented previously. So we had to update the UI components, to reflect the enumeration defined for each customizable type and we also had to modify the <code class="literal">CharacterCustomization.cs</code> class to handle the new changes.</p><p>The <code class="literal">CharacterCustomization</code> class implemented a <span class="emphasis"><em>PC</em></span> type variable to keep track of the customizations and finally pass the data along to the <code class="literal">GameMaster</code>. During the process, we also improved the case handling of the <code class="literal">CharacterCustomization</code> class for default values and so on.</p><p>Finally, we had a test run of the game to double check that everything worked as designed and implemented.</p><p>We created a lot of code in this chapter. In the next chapter, we are going to start building our inventory system, and yes, that is going to involve more code!</p></div>