<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec29"></a>PC and NPC interaction</h2></div></div><hr /></div><p>Thus far we have created the basic movement for both our PC and NPC. The next item I would like to complete is the attack mechanism for the PC and the NPC characters. Let's start by implementing the hit for the NPC.</p><p>Our NPC detects the player character based on the code we just created in the previous section. When the player character is in sight, the NPC will find the shortest path to the player character, and at a given range, it will attack the player character. So we have the movement and animation mechanics completed. The next objective is to keep track of the hit points when the NPC is attacking.</p><p>There are a few adjustments we need to make in the <span class="strong"><strong>NPC_Animator_Controller</strong></span>. Open, the <span class="strong"><strong>Animator</strong></span>Window, and select the <span class="strong"><strong>NPC_Attack</strong></span> layer.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_022.jpg" /></div><p>
</p><p>Double-click on the <span class="strong"><strong>attack1</strong></span> state, or the attack state you have defined in your state machine. This will open the related animation in the <span class="strong"><strong>Inspector Window</strong></span>.</p><p>In the <span class="strong"><strong>Inspector Window</strong></span>, scroll down to the <span class="strong"><strong>Curves</strong></span> section. We are going to create a new curve by selecting the <span class="emphasis"><em>(+)</em></span> sign under the <span class="strong"><strong>Curves</strong></span> section. We are also going to create a new parameter called <span class="strong"><strong>Attack1C</strong></span> to represent the value of the curve, this parameter should be of type <code class="literal">float</code>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_023.jpg" /></div><p>
</p><p>The curve displayed in the preceding screenshot, will be based on your animation.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_024.jpg" /></div><p>
</p><p>In the preceding screenshot, I have marked the important parts of the interface you will need to work with to configure the curve of an animation. The first step would be to actual preview your animation and get a feeling for it. The next step for my particular animation sequence, was determining when the right arm of the model starts moving along and I set a marker in the curve. I make another marker a bit more into the animation where the right arm has crossed a good deal from the right side to the left side. These markers will indicate a hit point during the animation when the NPC is in attack mode.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_025.jpg" /></div><p>
</p><p>Ok, so why do we do this? Simple. This will help us only generate a hit based on the curve of the animation. This way we don't hit the player and reduce the health of the player while the weapon is away from the player's body.</p><p>Next, we need to update out <code class="literal">NPC_Movement.cs</code> code to program the NPC attack.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p>I have only listed the portions that have been updated.</p></div><p>Here is an updated listing of the code:</p><pre class="programlisting">using UnityEngine; &#13;
using System.Collections; &#13;
 &#13;
public class NPC_Movement : MonoBehaviour &#13;
{ &#13;
... &#13;
    void Update() &#13;
    { &#13;
        // if player is in sight let's slerp towards the player &#13;
        if (playerInSight) &#13;
        { &#13;
            this.transform.rotation = &#13;
                Quaternion.Slerp(this.transform.rotation, &#13;
                Quaternion.LookRotation(direction), 0.1f); &#13;
        } &#13;
 &#13;
        if(this.player.transform.GetComponent&lt;CharacterController&gt;().die) &#13;
        { &#13;
            animator.SetBool("Attack", false); &#13;
            animator.SetFloat("Speed", 0.0f); &#13;
            animator.SetFloat("AngularSpeed", 0.0f); &#13;
        } &#13;
    } &#13;
 &#13;
    // let's update our scene using fixed update &#13;
    void FixedUpdate() &#13;
    { &#13;
        h = angle;          // assign horizontal axis &#13;
        v = distance;       // assign vertical axis &#13;
 &#13;
        // calculate speed based on distance and delta time &#13;
        speed = distance / Time.deltaTime; &#13;
 &#13;
        if (DEBUG) &#13;
            Debug.Log(string.Format("H:{0} - V:{1} - Speed:{2}", h, v, speed)); &#13;
 &#13;
        // set the parameters defined in the animator controller &#13;
        animator.SetFloat("Speed", speed); &#13;
        animator.SetFloat("AngularSpeed", v); &#13;
        animator.SetBool("Attack", attack1); &#13;
        animator.SetBool("Attack1", attack1); &#13;
 &#13;
        if(playerInSight) &#13;
        { &#13;
            if (animator.GetFloat("Attack1C") == 1.0f) &#13;
            { &#13;
                this.player.GetComponent&lt;PlayerAgent&gt;().playerCharacterData.HEALTH -= 1.0f; &#13;
            } &#13;
        } &#13;
    } &#13;
... &#13;
} &#13;
</pre><p>The new addition to the code checks to see if the player is in sight, and if that is the case, we check to see if we are in range to be able to attack, if that is the case we enter the attack mode, if we are in the attack mode, the attack animation is played. In the code we check to get the value of the newly created parameter called <span class="strong"><strong>Attack1C</strong></span>, and if it happens to be of value 1.0f, then we go ahead and reduce the health of the player character.</p><p>If the player dies while the NPC is attacking it will stop attacking and go back into the idle state.</p><p>Ok, you might be wondering how we get the ability to get the information from the player character. This is because we need to make some more additional C# scripts. Let's go ahead and do so now. Create the following C# scripts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">PC.cs</code>, this is going to be our player character class which inherits from the BaseCharacter class we have defined previously</p></li><li style="list-style-type: disc"><p>
<code class="literal">PlayerAgent.cs</code>, this is going to be used to store the PC data and also inherit MonoBehaviour</p></li><li style="list-style-type: disc"><p>
<code class="literal">NPC.cs</code>, this is going to be our non-player character class which inherits from the BaseCharacter class as well</p></li><li style="list-style-type: disc"><p>
<code class="literal">NPC_Agent.cs</code>, is going to be used to store the NPC data and also inherit MonoBehaviour</p></li></ul></div><p>I have made some modifications to the <code class="literal">BaseCharacter.cs</code> script to make it more accessible through the editor. Here is the new listing:</p><pre class="programlisting">using UnityEngine; &#13;
using System; &#13;
using System.Collections; &#13;
 &#13;
[Serializable] &#13;
public class BaseCharacter &#13;
{ &#13;
    [SerializeField] &#13;
    private string name; &#13;
    [SerializeField] &#13;
    private string description; &#13;
 &#13;
    [SerializeField] &#13;
    private float strength; &#13;
    [SerializeField] &#13;
    private float defense; &#13;
    [SerializeField] &#13;
    private float dexterity; &#13;
    [SerializeField] &#13;
    private float intelligence; &#13;
    [SerializeField] &#13;
    private float health; &#13;
 &#13;
 &#13;
 &#13;
    public string NAME &#13;
    { &#13;
        get { return this.name; } &#13;
        set { this.name = value; } &#13;
    } &#13;
 &#13;
    public string DESCRIPTION &#13;
    { &#13;
        get { return this.description; } &#13;
        set { this.description = value; } &#13;
    } &#13;
 &#13;
    public float STRENGTH &#13;
    { &#13;
        get { return this.strength; } &#13;
        set { this.strength = value; } &#13;
    } &#13;
 &#13;
    public float DEFENSE &#13;
    { &#13;
        get { return this.defense; } &#13;
        set { this.defense = value; } &#13;
    } &#13;
 &#13;
    public float DEXTERITY &#13;
    { &#13;
        get { return this.dexterity; } &#13;
        set { this.dexterity = value; } &#13;
    } &#13;
 &#13;
    public float INTELLIGENCE &#13;
    { &#13;
        get { return this.intelligence; } &#13;
        set { this.intelligence = value; } &#13;
    } &#13;
 &#13;
    public float HEALTH &#13;
    { &#13;
        get { return this.health; } &#13;
        set { this.health = value; } &#13;
    } &#13;
} &#13;
</pre><p>I have gone ahead and made the class and the fields serializable.</p><p>Let's take a look at the listing for <code class="literal">PC.cs</code>:</p><pre class="programlisting">using UnityEngine; &#13;
using System; &#13;
using System.Collections; &#13;
 &#13;
[Serializable] &#13;
public class PC : BaseCharacter { &#13;
 &#13;
} &#13;
</pre><p>Nothing much going on there at this point. Now let's take a look at the <code class="literal">PlayerAgent.cs</code>:</p><pre class="programlisting">using UnityEngine; &#13;
using System; &#13;
using System.Collections; &#13;
 &#13;
[Serializable] &#13;
public class PlayerAgent : MonoBehaviour { &#13;
 &#13;
    //[SerializeField] &#13;
    public PC playerCharacterData; &#13;
 &#13;
    void Awake() &#13;
    { &#13;
        PC tmp = new PC(); &#13;
        tmp.NAME = "Maximilian"; &#13;
        tmp.HEALTH = 100.0f; &#13;
        tmp.DEFENSE = 50.0f; &#13;
        tmp.DESCRIPTION = "Our Hero"; &#13;
        tmp.DEXTERITY = 33.0f; &#13;
        tmp.INTELLIGENCE = 80.0f; &#13;
        tmp.STRENGTH = 60.0f; &#13;
 &#13;
        this.playerCharacterData = tmp; &#13;
    } &#13;
 &#13;
      // Use this for initialization &#13;
      void Start () { &#13;
       &#13;
      } &#13;
       &#13;
      // Update is called once per frame &#13;
      void Update () { &#13;
          if(this.playerCharacterData.HEALTH&lt;0.0f) &#13;
        { &#13;
            this.playerCharacterData.HEALTH = 0.0f; &#13;
 &#13;
            this.transform.GetComponent&lt;CharacterController&gt;().die = true; &#13;
        } &#13;
      } &#13;
} &#13;
</pre><p>In the player agent code, we are initializing some default values for our PC data in the <code class="literal">Awake() </code>function. Since the class has been serialized, we can actually see the data during runtime for debugging purposes!</p><p>In the <code class="literal">Update()</code> function, we check to see if the health of our PC is less than 0.0f, and if it is, then this indicates the player has died. Which we then use the <code class="literal">CharacterController </code>component we have created to set the <span class="emphasis"><em>die</em></span> property to true. The <code class="literal">CharacterController</code> then will use the new value and communicate with the animator controller for the player character to get into the die state.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>Notice that our <code class="literal">NPC_Movement.cs</code> script is accessing the exact same PC data through the reference we have created in the script.</p></div><p>You will need to attach the <code class="literal">PlayerAgent.cs</code> script to your player character in the scene.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_026.jpg" /></div><p>
</p><p>In the preceding screenshot you can see the additions we have done to the scripts and how they look during runtime. We will have a listing for the <code class="literal">NPC.cs</code> and <code class="literal">NPC_Agent.cs</code> in future chapters. At this point, they are not used.</p></div>