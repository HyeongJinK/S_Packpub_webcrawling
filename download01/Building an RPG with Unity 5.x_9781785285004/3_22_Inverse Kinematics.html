<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec25"></a>Inverse Kinematics</h2></div></div><hr /></div><p>
<span class="strong"><strong>Inverse Kinematics</strong></span> (<span class="strong"><strong>IK</strong></span>) are important in game programming. It is typically used to make the character's movement more realistic in the world. One of the main uses of IK is the calculation of the player's feet and how they relate to the ground they are standing on.</p><p>In short, IK, is used to determine the position and rotation of the joints in a character based on a given position in space. For instance, to make sure the foot of a player is landing properly on the terrain it is walking on.</p><p>Unity has a built in IK system that can be used to do some basic calculation in this regard. Let's go ahead and implement the foot IK for our character. There are a few things that you will need to set up before we can enable IK for our humanoid character. The first thing to do is check your layer in the Animator Controller and use the <span class="emphasis"><em>engine icon</em></span> to enter the settings window. Make sure that <span class="strong"><strong>IK Pass</strong></span> is checked as shown in the following screenshot. You will also need to provide a <span class="strong"><strong>Mask</strong></span> if you have not done so already. The mask is used to dictate which parts of the skeleton are affected by the IK.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_016.jpg" /></div><p>
</p><p>Once you have set up this, the fun begins. We need to create a C# script that will handle our IK. Create a C# script and call it <code class="literal">IKHandle.cs</code>. Type the following code into the script:</p><pre class="programlisting">using UnityEngine; &#13;
using System.Collections; &#13;
 &#13;
public class IKHandle : MonoBehaviour &#13;
{ &#13;
   Animator anim; &#13;
 &#13;
   public Transform leftIKTarget; &#13;
   public Transform rightIKTarget; &#13;
 &#13;
   public Transform hintLeft; &#13;
   public Transform hintRight; &#13;
 &#13;
   public float ikWeight = 1f; &#13;
 &#13;
   // to make it dynamic &#13;
   Vector3 leftFootPosition; &#13;
   Vector3 rightFootPosition; &#13;
 &#13;
   Quaternion leftFootRotation; &#13;
   Quaternion rightFootRotation; &#13;
 &#13;
   float leftFootWeight; &#13;
   float rightFootWeight; &#13;
 &#13;
   Transform leftFoot; &#13;
   Transform rightFoot; &#13;
 &#13;
   public float offsetY; &#13;
 &#13;
   // Use this for initialization &#13;
   void Start() &#13;
   { &#13;
      anim = GetComponent&lt;Animator&gt;(); &#13;
 &#13;
      leftFoot = anim.GetBoneTransform(HumanBodyBones.LeftFoot); &#13;
      rightFoot = anim.GetBoneTransform(HumanBodyBones.RightFoot); &#13;
 &#13;
      leftFootRotation = leftFoot.rotation; &#13;
      rightFootRotation = rightFoot.rotation; &#13;
 &#13;
   } &#13;
 &#13;
   // Update is called once per frame &#13;
   void Update() &#13;
   { &#13;
      RaycastHit leftHit; &#13;
      RaycastHit rightHit; &#13;
 &#13;
      Vector3 lpos = leftFoot.TransformPoint(Vector3.zero); &#13;
      Vector3 rpos = rightFoot.TransformPoint(Vector3.zero); &#13;
 &#13;
      if (Physics.Raycast(lpos, -Vector3.up, out leftHit, 1)) &#13;
      { &#13;
         leftFootPosition = leftHit.point; &#13;
         leftFootRotation = Quaternion.FromToRotation(transform.up, &#13;
         leftHit.normal) * transform.rotation; &#13;
      } &#13;
 &#13;
      if (Physics.Raycast(rpos, -Vector3.up, out rightHit, 1)) &#13;
      { &#13;
         rightFootPosition = rightHit.point; &#13;
         rightFootRotation = Quaternion.FromToRotation(transform.up, &#13;
         rightHit.normal) * transform.rotation; &#13;
      } &#13;
   } &#13;
 &#13;
   public bool Die = false; &#13;
   public void Died() &#13;
   { &#13;
 &#13;
      Debug.Log("I AM DEAD!"); &#13;
      this.Die = true; &#13;
   } &#13;
 &#13;
   void OnAnimatorIK() &#13;
   { &#13;
      leftFootWeight = anim.GetFloat("LeftFoot"); &#13;
      rightFootWeight = anim.GetFloat("RightFoot"); &#13;
 &#13;
      anim.SetIKPositionWeight(AvatarIKGoal.LeftFoot, leftFootWeight); &#13;
      anim.SetIKPositionWeight(AvatarIKGoal.RightFoot, rightFootWeight); &#13;
      anim.SetIKPosition(AvatarIKGoal.LeftFoot, leftFootPosition + &#13;
      new Vector3(0f, offsetY, 0f)); &#13;
      anim.SetIKPosition(AvatarIKGoal.RightFoot, rightFootPosition + &#13;
      new Vector3(0f, offsetY, 0f)); &#13;
 &#13;
      anim.SetIKRotationWeight(AvatarIKGoal.LeftFoot, leftFootWeight); &#13;
      anim.SetIKRotationWeight(AvatarIKGoal.RightFoot, rightFootWeight); &#13;
      anim.SetIKRotation(AvatarIKGoal.LeftFoot, leftFootRotation); &#13;
      anim.SetIKRotation(AvatarIKGoal.RightFoot, rightFootRotation); &#13;
 &#13;
   } &#13;
} &#13;
</pre><p>This script is a bit involved. In order for the IK to work properly, we need important points in space. One of these points is the position of the target in space that we want our foot to move to, and the second point in space is the hint. These two points in space are used to control the movement and translations of the skeleton for a particular joint to be made in order to successfully complete the IK for the target position.</p><p>The variables <code class="literal">leftFootPosition</code> and <code class="literal">rightFootPosition</code> are used to represent the target position for the left and right foot during runtime. <code class="literal">leftFootRotation</code> and <code class="literal">rightFootRotation</code> is used to store the rotation of the left and right foot.</p><p>We also need two variables to actually reference our left and right foot in the model. These are done by the <code class="literal">leftFoot</code> and <code class="literal">rightFoot</code> variables.</p><p>Some of these variables are initialized in the <code class="literal">Start()</code> function. Specifically speaking, we get a reference to the left and right foot from the Animator Controller bone structure defined for humanoids.</p><p>In the <code class="literal">Update()</code> function, we use <code class="literal">Physics.Raycast()</code> to perform some raycasting to determine the position of our left and right foot. This data is then used and stored in the variables <code class="literal">leftFootPosition</code> and <code class="literal">rightFootPosition</code> variables with their equivalent rotation data in the <code class="literal">leftFootRotation</code> and right <code class="literal">FootRotation</code> variables:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_017.jpg" /></div><p>
</p><p>The actual IK Animation is applied in the <code class="literal">OnAnimatorIK()</code> function. The <code class="literal">leftFootWight</code> and <code class="literal">rightFootWeight</code> variables are used to get the parameter values set for the <code class="literal">LeftFoot</code> and <code class="literal">RightFoot</code> in the Animator Controller through the animation clip <code class="literal">Curve</code> function.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note28"></a>Note</h3><p>The key here is to properly define the curve of the animation clip that will be used to drive the weight of the IK. The preceding screenshotÂ only shows the curve of the idle state, both feet are on the ground, therefore the value is set to <code class="literal">1</code>. For your walking and running clips, your curve will be different.</p></div><p>Finally, the <code class="literal">SetIKPositionWeight()</code> and <code class="literal">SetIKPosition()</code> functions are used to properly adjust the position and rotation of the feet relative to the ground! Notice that this is performed for each foot separately.</p><p>Attach the <code class="literal">IKHandle.cs</code> script to your character and do a test run. Notice the difference of your character and the way it is interacting with the floor or the terrain you have set up.</p></div>