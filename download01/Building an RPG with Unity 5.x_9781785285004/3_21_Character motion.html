<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec24"></a>Character motion</h2></div></div><hr /></div><p>Traditionally, the motion and movement of the characters were done separately through code. With the introduction of <span class="emphasis"><em>Mecanim</em></span>, you are now able to apply what is called <span class="strong"><strong>Root motion</strong></span>. This in return modifies the character's in-game transform based on the data in the root motion.</p><p>We are going to use root motion for our characters. Root motion works with the Animator Controller and the Animation State Machine. The Body Transform and Orientation are stored in the Animation Clip. This makes it easier for creating a state machine that plays the appropriate animation clip through the <span class="emphasis"><em>Animator Controller</em></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"></a>Animator Controller</h3></div></div></div><p>In this section we will use the new Animator Controller to create our character states and determine the criteria for a change of states. To create an Animator Controller, in the project window right-click and select <span class="strong"><strong>Create</strong></span>
<span class="emphasis"><em> | <span class="strong"><strong>Animator Controller</strong></span>
</em></span>. Give it a name. I have called mine <code class="literal">CH3_Animator_Controller</code>. Double-click the controller to open the Animator window.</p><p>The Animator Controller is a very complex tool and it will take you some time to study the different aspects and features that are available to you through it. The following diagram is a snapshot of an empty controller. I have marked the main sections of the Animator Window. There are two visible tabs, the <span class="strong"><strong>Layers</strong></span> tab and the <span class="strong"><strong>Parameters</strong></span> tab. In the <span class="strong"><strong>Layers</strong></span> tab you will be able to create different layers that hold your animation states and the relevant <span class="emphasis"><em>Transitions</em></span> from one state to the next. The <span class="strong"><strong>Parameters</strong></span> tab is where you define your parameters that will be accessed and modified by the <span class="emphasis"><em>Animator Controller</em></span> as well as through your code.</p><p>There are a wide range of topics that you will need to know to fully appreciate the Mecanim system. We won't be going through all of the aspects in this book, but we will touch on some of the key aspects that are needed for our game.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_007.jpg" /></div><p>
</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec7"></a>Animation states</h4></div></div></div><p>To create a new state, you can simply drag and drop an animation from your project window. This will name and assign the relevant animation to the state in the layer. You can also create an empty state by right-clicking in the layer and selecting <span class="strong"><strong>Create State</strong></span>
<span class="emphasis"><em> | </em></span>
<span class="strong"><strong>Empty</strong></span>. When a state is created, you can click on the state and observe its properties in the <span class="strong"><strong>Inspector</strong></span> window:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_008.jpg" /></div><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"></a>Note</h3><p>Your model may or may not have animations attached to it. The whole idea of the Mecanim system is to enable character modelers to work on their models while animators can use the skeleton of a humanoid Avatar to animate the character. This in turn makes it easier and better to have a set of animations applied to different types of character models!</p></div><p>To identify the state, it is best to provide it with a unique name that can be easily recognized in the state diagram. You will need to assign a Motion to it, this is the animation clip that will be playing when the state is active. The next important property would be the Transitions property. A transition will determine the condition of which state will be moving to another state, if there is such a requirement.</p><p>For instance, when the character is in an idle state, what the condition is for the character to change its state to a walking state, to a running state and so forth.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_009.jpg" /></div><p>
</p><p>In the preceding screenshot, you will see I have defined three different states: idle, Walking, and Running. You also notice in the <span class="strong"><strong>Parameters</strong></span> tab, I have defined some parameters. These parameters are used to determine when to move from idle to walking to running and back. The parameters are there to help you create the conditions for your state machine.</p><p>To create a Transition from one state to the next, right-click your state, and select <span class="strong"><strong>Make Transition</strong></span>, then select the state it will transition to. This will create the visual arrow from the start state to the end state. Select the <span class="strong"><strong>Transition</strong></span> arrow to get its properties and set the conditions in the <span class="strong"><strong>Inspector</strong></span> window.</p><p>The Walking and Running states are actually <span class="strong"><strong>Blend Tree</strong></span> in this instance. A Blend Tree is used to make the transition from one animation state to the next more natural. In order for the blended motion to make sense, the motions that are blended must be of a similar nature and timing.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"></a>Note</h3><p>Blend Trees are used for allowing multiple animations to be blended smoothly by incorporating parts of them all to varying degrees. The amount that each of the motions contribute to the final effect is controlled using a blending parameter, which is just one of the numeric animation parameters associated with the Animator Controller.</p></div><p>For instance, the walking state could look something like the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_010.jpg" /></div><p>
</p><p>In our first Blend Tree node, we have five outputs: WalkLeftMedium, WalkLeftShort, Walk, WalkRightMedium, WalkRightShort. These are the animation clips that will be playing based on the value of the parameter called <span class="strong"><strong>Horizontal</strong></span>. In the behavior region, you will notice a few thresholds that have been set up for the parameter, these thresholds are what determine which animation is to be played. The value of the <span class="strong"><strong>Horizontal</strong></span> parameter is set through our C# code by passing in the value of the <span class="strong"><strong>Horizontal Axis</strong></span> which is defined in the <span class="strong"><strong>Input Manager</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_011.jpg" /></div><p>
</p><p>When you select a Blend Tree node, your <span class="strong"><strong>Inspector</strong></span> window will give you the ability to add or remove the different animation states and also the parameter and the threshold of the parameter that will determine which animation will be rendered.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>The key to have a smooth looking blending in your animation, you will need to pay attention to your animation data.</p></div><p>Let's take a look at our final state diagram:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_012.jpg" /></div><p>
</p><p>At this stage, I have gone ahead and implemented the state diagram for <span class="strong"><strong>idle</strong></span>, <span class="strong"><strong>Walking</strong></span>, <span class="strong"><strong>Running</strong></span>, <span class="strong"><strong>Jump</strong></span>, <span class="emphasis"><em>
<span class="strong"><strong>Attack</strong></span>,</em></span> and <span class="emphasis"><em>
<span class="strong"><strong>Walking</strong></span>
</em></span> backwards. There is also a state for when the character dies.</p><p>The parameter that defines the transition from the Idle state to the Walking and Running States is the Speed parameter. If the speed value is greater than 0.1 it will transition from Idle to Walking, if it is greater than 0.6 it will transition from Walking to Running. The opposite is true for going from Running to Walking, and from Walking to Running.</p><p>Notice however, that the character can only enter the Jump state from the Running state. The parameter that controls this transition is the Jump parameter that is a Boolean value set by pressing the spacebar button on the keyboard.</p><p>There are also three unique attack states that can be entered from the Idle state. And a Die state that can be entered from any state. Well, because your character can die at any given time if you are not careful!</p><p>Let's take a look at how we can control these parameters.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec28"></a>Character controller</h3></div></div></div><p>It is time to enable our character to move around the scene. This is generally handled by the character controller. The character controller will be used to handle most of the interaction the player will have with the character in the game.</p><p>Create a new C# script and call it <code class="literal">CharacterController.cs</code>. Enter the following code in the <code class="literal">CharacterController</code> class. At the moment the code is very basic. Let's get a listing of the code and we can start discussing the different parts of the code after the listing:</p><pre class="programlisting">using UnityEngine; &#13;
using System.Collections; &#13;
 &#13;
public class CharacterController : MonoBehaviour &#13;
{ &#13;
 &#13;
   public Animator animator; &#13;
   public float directionDampTime; &#13;
 &#13;
   public float speed = 6.0f; &#13;
   public float h = 0.0f; &#13;
   public float v = 0.0f; &#13;
 &#13;
   public bool attack1 = false; &#13;
   public bool attack2 = false; &#13;
   public bool attack3 = false; &#13;
 &#13;
   public bool jump = false; &#13;
 &#13;
   public bool die = false; &#13;
 &#13;
   // Use this for initialization &#13;
   void Start() &#13;
   { &#13;
      this.animator = GetComponent&lt;Animator&gt;() as Animator; &#13;
   } &#13;
 &#13;
   // Update is called once per frame &#13;
   private Vector3 moveDirection = Vector3.zero; &#13;
 &#13;
   void Update() &#13;
   { &#13;
 &#13;
      if (Input.GetKeyDown(KeyCode.C)) &#13;
      { &#13;
         this.attack1 = true; &#13;
         this.GetComponent&lt;IKHandle&gt;().enabled = false; &#13;
      } &#13;
      if (Input.GetKeyUp(KeyCode.C)) &#13;
      { &#13;
         this.attack1 = false; &#13;
         this.GetComponent&lt;IKHandle&gt;().enabled = true; &#13;
      } &#13;
      animator.SetBool("Attack1", attack1); &#13;
 &#13;
      if (Input.GetKeyDown(KeyCode.Z)) &#13;
      { &#13;
         this.attack2 = true; &#13;
         this.GetComponent&lt;IKHandle&gt;().enabled = false; &#13;
      } &#13;
      if (Input.GetKeyUp(KeyCode.Z)) &#13;
      { &#13;
         this.attack2 = false; &#13;
         this.GetComponent&lt;IKHandle&gt;().enabled = true; &#13;
      } &#13;
      animator.SetBool("Attack2", attack2); &#13;
 &#13;
      if (Input.GetKeyDown(KeyCode.X)) &#13;
      { &#13;
         this.attack3 = true; &#13;
         this.GetComponent&lt;IKHandle&gt;().enabled = false; &#13;
      } &#13;
      if (Input.GetKeyUp(KeyCode.X)) &#13;
      { &#13;
         this.attack3 = false; &#13;
         this.GetComponent&lt;IKHandle&gt;().enabled = true; &#13;
      } &#13;
      animator.SetBool("Attack3", attack3); &#13;
 &#13;
      if (Input.GetKeyDown(KeyCode.Space)) &#13;
      { &#13;
         this.jump = true; &#13;
         this.GetComponent&lt;IKHandle&gt;().enabled = false; &#13;
      } &#13;
      if (Input.GetKeyUp(KeyCode.Space)) &#13;
      { &#13;
         this.jump = false; &#13;
         this.GetComponent&lt;IKHandle&gt;().enabled = true; &#13;
      } &#13;
      animator.SetBool("Jump", jump); &#13;
 &#13;
      if (Input.GetKeyDown(KeyCode.I)) &#13;
      { &#13;
         this.die = true; &#13;
         SendMessage("Died"); &#13;
      } &#13;
 &#13;
      animator.SetBool("Die", die); &#13;
   } &#13;
 &#13;
   void FixedUpdate() &#13;
   { &#13;
 &#13;
      // The Inputs are defined in the Input Manager &#13;
      // get value for horizontal axis       &#13;
      h = Input.GetAxis("Horizontal");       &#13;
      // get value for vertical axis &#13;
      v = Input.GetAxis("Vertical"); &#13;
 &#13;
      speed = new Vector2(h, v).sqrMagnitude; &#13;
 &#13;
      // Used to get values on console &#13;
      Debug.Log(string.Format("H:{0} - V:{1} - Speed:{2}", h, v, speed)); &#13;
 &#13;
      animator.SetFloat("Speed", speed); &#13;
      animator.SetFloat("Horizontal", h); &#13;
      animator.SetFloat("Vertical", v); &#13;
   } &#13;
} &#13;
</pre><p>In the <code class="literal">Start()</code> function we are going to get a reference to the Animator Controller. We will be using the <code class="literal">FixedUpdate()</code> function to perform our updates for the character movement.</p><p>What is the difference between the <code class="literal">Update()</code> function and the <code class="literal">FixedUpdate()</code>? The <code class="literal">Update() </code>function is called every frame and is used regularly to update the moving of non-physics object, simple timers, and input processing. The update interval time varies for the <span class="emphasis"><em>Update()</em></span> function. <code class="literal">FixedUpdate()</code> is called every physics step. The interval is consistent and used for adjusting physics on Rigidbody.</p><p>In the <code class="literal">FixedUpdate()</code> function, we get the inputs for our Horizontal and Vertical axis, we calculate the <code class="literal">speed</code> value, and set the parameters defined in the Animator Controller using the <code class="literal">animator.SetFloat()</code> function. These parameters are then used by the animator controller to decide which state the character is at.</p><p>For instance, to go from an idle state to the walking state, the <code class="literal">speed</code> parameter needs to be greater than 0.1, and from walking to running, the <code class="literal">speed</code> parameter will need to be greater than 0.6. The opposite is true when you want to go back from the running state to the walking state and from the walking state to the idle state. The Horizontal and Vertical parameters control the movement for turning left or turning right. All these three parameters combined control what state and what animation the character is rendering.</p><p>The next step is for us to enable the Jump, Die and Attack states. The Jump state can be only entered while the character is running and the <code class="literal">Jump</code> Boolean variable is set to true. The jump condition is set in the <code class="literal">Update()</code> function when the spacebar is pressed by the player. This sets the variable to <code class="literal">true</code> and passes the variable to the animator controller.</p><p>The same mechanism is used for the three attack states: <code class="literal">Attack1_Normal</code>, <code class="literal">Attack2_Lower</code>, and <code class="literal">Attack3_Destroy</code>. These are mapped to the following keys on the keyboard: <span class="emphasis"><em>C, Z, and X</em></span> respectively. Each one will set its Boolean value to true and pass it into the animator controller. However, the player can only enter these three states from the idle state. We will leave it as is for now.</p><p>Finally, the Die state is implemented and for now we are using the keyboard input I to test it out. The main difference between the die state and the other states so far is that the die state can be entered from any state.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"></a>Note</h3><p>We are not using Blend Trees for these states as there is only one type of animation for the state. You will also notice that the states can only be transitioned to from the idle state. This is due to how the animations and model was set up initially. Yours could be different.</p></div><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_013.jpg" /></div><p>
</p><p>The character can get into a die state from any state. That is, your character player can die at any time in the game during whatever state he or she is at. However, for the attack and jump states, we need to be at the idle state for us to be able to transition smoothly into the proper state. You can improve these transitions and state based on the level of your animation complexity, but for now, this should do.</p><p>These states are controlled through Boolean parameters defined in the animator. At this stage, you should be able to use your model to test the scene and also your character animations and states.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec8"></a>Modification to animations</h4></div></div></div><p>There might be times that you will need to make some changes and or modifications to the existing modification that will make it work properly with your game and the state machine.</p><p>The attack animations prepared for my character model need to be adjusted to make them loop while the character is still in that particular state. For instance, if I use the existing animation and the character state goes into attack mode, the animation will play only once. This is not what I intend to do, I am building the attack input to perform the attack while the attack key is pressed down. Changing the animation loop setting is easy, to do so, select the animation from your project window and select the <span class="strong"><strong>Edit...</strong></span> button from the <span class="strong"><strong>Inspector</strong></span> window as shown in the screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_014.jpg" /></div><p>
</p><p>You will now be in the <span class="strong"><strong>Edit</strong></span> mode of the animation as displayed in the next screenshot. I have placed the <span class="strong"><strong>Inspector</strong></span> window side by side to illustrate the <span class="strong"><strong>Animation</strong></span> tab, selecting each animation we want to modify, one at a time, and setting the <span class="strong"><strong>Loop Time</strong></span> property to true (checked).</p><p>In this particular screenshot you will also notice several other important properties for the animation such as: <span class="strong"><strong>Root Transform Rotation</strong></span>, <span class="strong"><strong>Mirror</strong></span>, <span class="strong"><strong>Curves</strong></span>, <span class="strong"><strong>Events</strong></span>, <span class="strong"><strong>Mask</strong></span>, and <span class="strong"><strong>Motion</strong></span>. We are going to use the Curves property when we set out Inverse Kinematics for some of our animations regarding our character. This basically sets the values of predefined parameters that can be used to set or get them through Mecanim:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_03_015.jpg" /></div><p>
</p><p>If your animations are attached to your model and your animations and models are older, you will most likely need to make some modifications to them. For instance, one of the main properties that you might have to set for a particular animation clip would be the <span class="strong"><strong>Loop Time</strong></span> property as shown in the preceding screenshot. This will make sure that the animation will loop as long as you are in the state which is running the animation. If looping is not enabled, the animation will run once and stop, even if you are still in the state representing the animation.</p><p>So make sure the <span class="strong"><strong>Loop Time</strong></span> property is set for the idle, walking, running, and attacking animations. At the same time, not all animation clips need to be looped, for instance, the jump and die animations just need to be played once. So you will need to be diligent and check all of these properties.</p><p>Other animation will need to be modified to enable baking the transform into the model. For instance, the die and jump animations have the following properties checked: <span class="strong"><strong>Root Transform Rotation</strong></span> and <span class="strong"><strong>Root Transform Position (Y)</strong></span>, make sure that the <span class="strong"><strong>Bake Into Pose</strong></span> property is checked. This is important to make sure the animation and the skeletal movement of the character are harmonized at the root transform position.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note27"></a>Note</h3><p>Your animation might seem funky if these properties are not set properly. So if there is something weird going on, make sure to double check these properties.</p></div><p>If you have not done so by now, you should attach your <code class="literal">CharacterController.cs</code> script to your player character.</p></div></div></div>