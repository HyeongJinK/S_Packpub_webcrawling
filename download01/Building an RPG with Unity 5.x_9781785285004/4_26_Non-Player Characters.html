<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec28"></a>Non-Player Characters</h2></div></div><hr /></div><p>So far we have concentrated on the player character, in this section we will start thinking about our non-player characters. Let's start with our Barbarians. We can use our Character Customization scene to quickly create a few prefabs that will represent our unique Barbarians.</p><p>Using the tools we have just developed, you can make your adjustments, and when satisfied with your model, drag and drop the GameObject representing your character-player into the <code class="literal">Prefabs</code> folder. This will create a copy of the instance of the GameObject as you see it and save it into a prefab. The following screenshot will demonstrate the two characters I have created and stored as a prefab:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_006.jpg" /></div><p>
</p><p>What I have shown you, if done properly, could save you hours of tedious work of manually going down the model structure and individually enabling and disabling the different meshes. In other words, we not only create a scene that allows us to customize our in-game player character, we have also created a tool that can help us customize our own character models quickly for use in the game!</p><p>Another point to emphasize here is the power of prefabs. Think of a prefab as a storage object that can be used to save the state of a given GameObject and used over and over again within your game environment. When you update your prefab, all instances of the prefab will automatically get updated!!! This is great, but at the same time you have to be careful not to break anything for the same reason. When you update code logic on a script that is attached to a prefab, all instances of the prefab will use the updated script, so a bit of planning on your part can save a lot of time and headache in the long run.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec31"></a>Non-Player Character basics</h3></div></div></div><p>We are going to be using the newly created prefabs to implement our non-player characters. Since there are some similarities in the character models, we can re-use some of the assets we have created so far.</p><p>For instance, all characters will be inheriting the <code class="literal">BaseCharacter</code> class defined in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Character Design</em></span>. They will also incorporate the same states we have already created for the player character and extend a few more states specifically for the NPC, for instance searching and seeking.</p><p>We have used our character customization tool to create and save our non-player character, hence we are OK with the modelling part. What we need to concentrate on is the motion of our non-player characters! We would need to create a new Animator Controller that will handle the states of our NPCs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec12"></a>Setting up the Non-Player Character</h4></div></div></div><p>One of the main difficulties for implementing a NPC is the ability to give it realistic intelligence. This can be achieved easily by identifying and implementing several key areas for our NPCs.</p><p>There are a few new components we would need to attach to our NPCs. Using the prefab we have saved, we will need to add the following components:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>New <code class="literal">Sphere Collider</code>, this will be used to implement the range of sight for our NPC.</p></li><li style="list-style-type: disc"><p>We already have an <code class="literal">Animator </code>component attached, but we will need to create a new <code class="literal">Animator Controller</code> to capture new states for the NPC.</p></li><li style="list-style-type: disc"><p>We would also need to add a <code class="literal">Nav Mesh Agent</code> component. We are going to use the built-in navigation and pathfinding system for our NPC.</p></li></ul></div><p>To add the <code class="literal">Sphere Collider</code>, you will need to select the prefab defined for the NCP, and in the <span class="strong"><strong>Inspector Window</strong></span>, select <span class="strong"><strong>Add Component | Physics | Sphere Collider</strong></span>. This will attach a <code class="literal">Sphere Collider</code> to our prefab.</p><p>Next we need to add the <span class="strong"><strong>Nav Mesh Agent</strong></span>, again from the <span class="strong"><strong>Inspector Window</strong></span>, select <span class="strong"><strong>Add Component | Navigation | Nav Mesh Agent</strong></span>. Ok so now we have set up our main built-in components that are going to be used for the NPC.</p><p>Since, our prefab is an instance of our player character, we will need to remove some of the script components that have been carried over. If your NPC prefab contains any scripts attached to it, go ahead and remove them now.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note32"></a>Note</h3><p>Make sure you also change the <code class="literal">Tag</code> property to <code class="literal">Untagged</code>, if you have not done so already.</p></div><p>The following screenshot will illustrate the components that we have so far on the NPC. This will include both the existing components, including the scripts we have brought over from the player character, and the newly added components that will be used for the NPC.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_007.jpg" /></div><p>
</p><p>The next step is to set up our Navmesh. To create a Navmesh, we need to get into the <span class="strong"><strong>Navigation Window</strong></span>, to do so, select <span class="strong"><strong>Window | Navigation</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_008.jpg" /></div><p>
</p><p>In order for the navmesh to work properly, we will need to mark all GameObjects in the scene as <span class="strong"><strong>Navigation Static</strong></span>. This will create a navmesh based on the static objects in the scene, that is, GameObjects that are not going to be moving throughout the lifespan of the scene.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_009.jpg" /></div><p>
</p><p>In your active scene, select the GameObjects that are going to be set as <span class="strong"><strong>Navigation Static</strong></span> as shown in the preceding screenshot (1) and use the Static drop-down menu as shown in (2) and select the <span class="strong"><strong>Navigation Static</strong></span> option as in (3). If your GameObject is a parent GameObject with children, Unity will ask if you want to apply the property change to all children.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note33"></a>Note</h3><p>Notice that I have placed all of my environment GameObjects under a GameObject called <code class="literal">Environment</code>. This way if I have many static objects, I can apply the property change to the parent and the children will automatically inherit the change as well. But make sure, everything in the group will be static!</p></div><p>Once this is complete, we need to go back to the Navigation Window and make some adjustments. In the <span class="strong"><strong>Navigation</strong></span> tab, select <span class="strong"><strong>Terrains</strong></span> and make sure it is set to <span class="strong"><strong>Navigation Static</strong></span>, and the <span class="strong"><strong>Navigation Area</strong></span> is set to <span class="strong"><strong>Walkable</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_010.jpg" /></div><p>
</p><p>In the <span class="strong"><strong>Bake</strong></span> tab, change the <span class="strong"><strong>Agent Radius</strong></span> to <span class="strong"><strong>0.3</strong></span> and <span class="strong"><strong>Agent Height</strong></span> to <span class="strong"><strong>1</strong></span>. This will give the NPC more freedom to pass through tight corners.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_011.jpg" /></div><p>
</p><p>When you are ready, you can select the <span class="strong"><strong>Bake</strong></span> button at the bottom of the <span class="strong"><strong>Navigation</strong></span>Window.</p><p>Unity will take some time to generate the Navmesh for your scene. This will depend on the complexity of your level. If all is done correctly, you will see something similar to the following screenshot displaying your Navmesh:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_012.jpg" /></div><p>
</p><p>The blue areas you see are all the regions that the NPC can actually navigate to.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_013.jpg" /></div><p>
</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec13"></a>NPC Animator Controller</h4></div></div></div><p>We now need to create the Animator Controller (AC) for our NPC. The Animator Controller will use input from the MeshAgent to control and change the state of our NPC. We also need to define a few parameters for our NPC AC. These are going to be:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>AngularSpeed: will be used for directional movement</p></li><li style="list-style-type: disc"><p>Speed: will be used to determine how fast the NPC will be moving</p></li><li style="list-style-type: disc"><p>Attack: will be used to determine if it needs to attack</p></li><li style="list-style-type: disc"><p>AttackWeight: used to determine damage of the attack</p></li><li style="list-style-type: disc"><p>PlayerInSight: will be used to determine if the PC is in sight</p></li></ul></div><p>Go ahead and create a new <code class="literal">Animator Controller</code> in your project and name it <code class="literal">NPC_Animator_Controller</code>. Open the <span class="strong"><strong>Animator</strong></span>Window. Create a new Blend Tree by right-clicking in the <span class="strong"><strong>Animator </strong></span>Window and selecting <span class="strong"><strong>Create State | From New Blend Tree</strong></span>. Change the name to <span class="strong"><strong>NPC_Locomotion</strong></span>. Double-click it so that you can edit the blend tree. Change the node name to <span class="strong"><strong>NPC_Locomotion</strong></span> as well. From the Inspector Window, change the <span class="strong"><strong>Blend Type</strong></span> to <span class="strong"><strong>2D Freeform Cartesian</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_014.jpg" /></div><p>
</p><p>The x-axis will be represented by the <span class="strong"><strong>AngularSpeed</strong></span>, and the y-axis will be represented by the <span class="strong"><strong>Speed</strong></span> parameters.</p><p>The Blend Tree is going to hold all of the different locomotion animation states. These are going to be the idle, walking and running states.</p><p>I have set up 11 different animation states for the locomotion of my NPC. The following screenshot will give you an overview of the Blend Tree.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_015.jpg" /></div><p>
</p><p>Once you include all of the animations states in the Blend Tree, you will need to compute the positions of your animations, an easy way to do this, is to select the <span class="strong"><strong>Compute Positions</strong></span> drop-down menu and select the <span class="strong"><strong>AngularSpeed </strong></span>and<span class="strong"><strong> Speed</strong></span>. This will place the animation position based on the root motion as illustrated in the following screenshot</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_016.jpg" /></div><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>You can use your mouse to drag the red point on the diagram to preview your animation states in action.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec14"></a>NPC attack</h4></div></div></div><p>In order to implement our attack mode, we will need to create a new layer in the Animator Controller. Go ahead and create a new layer and call it <span class="strong"><strong>NPC_Attack</strong></span>. This layer will be responsible for animating our character when we enter attack mode.</p><p>We need to create a new Mask for the layer. The mask will be used to determine which parts of the humanoid body will be affected by the layer animation. To create a <span class="strong"><strong>Mask</strong></span>, right-click in your <span class="strong"><strong>Project</strong></span> Window and select <span class="strong"><strong>Create | Avatar Mask</strong></span>. Name the new mask, <span class="strong"><strong>NPC_Attack</strong></span>. Use the Inspector Window to disable the body parts that we don't want to be affected by the layer animation. See following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_017.jpg" /></div><p>
</p><p>Your layer setup should look like the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_018.jpg" /></div><p>
</p><p>Make sure you change the <span class="strong"><strong>Weight</strong></span> property to <span class="strong"><strong>1</strong></span>, the <span class="strong"><strong>Mask </strong></span>property assigned to the Avatar Mask we created, and also that the <span class="strong"><strong>IK</strong></span> property is checked. Now we are ready to create our attack state machine.</p><p>Right-click in the <span class="strong"><strong>Animator Window</strong></span> and select <span class="strong"><strong>Create State | Empty</strong></span>. Drag and drop your attack animation(s). The empty state is used to have a nice transition between the main layer and back.</p><p>After you have dropped your attack animation(s) into the Animator, you will need to connect them using the transition conditions. I have added three more parameters to the parameter list named: <span class="strong"><strong>Attack1, Attack2 </strong></span>and <span class="strong"><strong>Attack3.</strong></span> These parameters in connection with the <span class="strong"><strong>Attack </strong></span>parameter will determine which attack state our NPC will transition to.</p><p>The following screenshot shows the <span class="strong"><strong>NPC_Attack</strong></span> layer as configured up-to this point.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_019.jpg" /></div><p>
</p><p>Finally, you want to assign the new NPC_Animator_Controller to the NPC prefab(s).</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec32"></a>NPC AI</h3></div></div></div><p>Now it is time to give some intelligence to our NPCs. One of the scripts we will need to create is the ability for the NPC to detect the player. This script will be called <code class="literal">NPC_Sight.cs</code>. The script will be used to detect if the player is in sight, calculate the field of view for the NPC, and calculate the path from the NPC to the player character.</p><p>Here is a listing of the source code:</p><pre class="programlisting">using UnityEngine; &#13;
using System.Collections; &#13;
 &#13;
public class NPC_Movement : MonoBehaviour &#13;
{ &#13;
    // reference to the animator &#13;
    public Animator animator; &#13;
 &#13;
    // these variables are used for the speed &#13;
    // horizontal and vertical movement of the NPC &#13;
    public float speed = 0.0f; &#13;
    public float h = 0.0f; &#13;
    public float v = 0.0f; &#13;
 &#13;
    public bool attack1 = false;  // used for attack mode 1 &#13;
    public bool attack2 = false;  // used for attack mode 2 &#13;
    public bool attack3 = false;  // used for attack mode 3 &#13;
 &#13;
    public bool jump = false;     // used for jumping &#13;
    public bool die = false;      // are we alive? &#13;
 &#13;
    // used for debugging &#13;
    public bool DEBUG = false; &#13;
    public bool DEBUG_DRAW = false; &#13;
 &#13;
    // Reference to the NavMeshAgent component. &#13;
    private NavMeshAgent nav; &#13;
     &#13;
    // Reference to the sphere collider trigger component. &#13;
    private SphereCollider col; &#13;
 &#13;
    // where is the player character in relation to NPC &#13;
    public Vector3 direction; &#13;
     &#13;
    // how far away is the player character from NPC &#13;
    public float distance = 0.0f; &#13;
     &#13;
    // what is the angle between the PC and NPC &#13;
    public float angle = 0.0f; &#13;
     &#13;
    // a reference to the player character &#13;
    public GameObject player; &#13;
     &#13;
    // is the PC in sight? &#13;
    public bool playerInSight; &#13;
 &#13;
    // what is the field of view for our NPC? &#13;
    // currently set to 110 degrees &#13;
    public float fieldOfViewAngle = 110.0f; &#13;
 &#13;
    // calculate the angle between PC and NPC &#13;
    public float calculatedAngle; &#13;
 &#13;
    void Awake() &#13;
    { &#13;
        // get reference to the animator component &#13;
        this.animator = GetComponent&lt;Animator&gt;() as Animator; &#13;
 &#13;
        // get reference to nav mesh agent  &#13;
        this.nav = GetComponent&lt;NavMeshAgent&gt;() as NavMeshAgent; &#13;
 &#13;
        // get reference to the sphere collider &#13;
        this.col = GetComponent&lt;SphereCollider&gt;() as SphereCollider; &#13;
 &#13;
        // get reference to the player  &#13;
        player = GameObject.FindGameObjectWithTag("Player") as GameObject; &#13;
 &#13;
        // we don't see the player by default &#13;
        this.playerInSight = false; &#13;
    } &#13;
 &#13;
    // Use this for initialization &#13;
    void Start() &#13;
    { &#13;
    } &#13;
 &#13;
    void Update() &#13;
    { &#13;
        // if player is in sight let's lerp towards the player &#13;
        if (playerInSight) &#13;
        { &#13;
            this.transform.rotation = &#13;
                Quaternion.Slerp(this.transform.rotation, &#13;
                Quaternion.LookRotation(direction), 0.1f); &#13;
        } &#13;
    } &#13;
 &#13;
    // let's update our scene using fixed update &#13;
    void FixedUpdate() &#13;
    { &#13;
        h = angle;          // assign horizontal axis &#13;
        v = distance;       // assign vertical axis &#13;
 &#13;
        // calculate speed based on distance and delta time &#13;
        speed = distance / Time.deltaTime; &#13;
 &#13;
        if (DEBUG) &#13;
            Debug.Log(string.Format("H:{0} - V:{1} - Speed:{2}", h, v, speed)); &#13;
 &#13;
        // set the parameters defined in the animator controller &#13;
        animator.SetFloat("Speed", speed); &#13;
        animator.SetFloat("AngularSpeed", v); &#13;
        animator.SetBool("Attack", attack1); &#13;
        animator.SetBool("Attack1", attack1); &#13;
    } &#13;
 &#13;
    // if the PC is in our collider, we want to examine the location of the player &#13;
    // calculate the direction based on our position and the player's position &#13;
    // use the DOT product to get the angle between the two vectors &#13;
    // calculate the angle between the NPC forward vector and the PC &#13;
    // if it falls within the field of view, we have the player in in sight &#13;
    // if the player is in sight, we will set the nav agent desitation &#13;
    // if we are within a certain distance from the PC, the NPC has the ability to attack &#13;
    void OnTriggerStay(Collider other) &#13;
    { &#13;
        if (other.transform.tag.Equals("Player")) &#13;
        { &#13;
            // Create a vector from the enemy to the player and store the angle between it and forward. &#13;
            direction = other.transform.position - transform.position; &#13;
 &#13;
            distance = Vector3.Distance(other.transform.position, transform.position) - 1.0f; &#13;
 &#13;
            float DotResult = Vector3.Dot(transform.forward, player.transform.position); &#13;
            angle = DotResult; &#13;
 &#13;
            if (DEBUG_DRAW) &#13;
            { &#13;
                Debug.DrawLine(transform.position + Vector3.up, direction * 50, Color.gray); &#13;
                Debug.DrawLine(other.transform.position, transform.position, Color.cyan); &#13;
            } &#13;
 &#13;
            this.playerInSight = false; &#13;
 &#13;
            this.calculatedAngle = Vector3.Angle(direction, transform.forward); &#13;
 &#13;
            if (calculatedAngle &lt; fieldOfViewAngle * 0.5f) &#13;
            { &#13;
                RaycastHit hit; &#13;
 &#13;
                if (DEBUG_DRAW) &#13;
                    Debug.DrawRay(transform.position + transform.up, direction.normalized, Color.magenta); &#13;
 &#13;
                // ... and if a raycast towards the player hits something... &#13;
                if (Physics.Raycast(transform.position + transform.up, direction.normalized, out hit, col.radius)) &#13;
                { &#13;
                    // ... and if the raycast hits the player... &#13;
                    if (hit.collider.gameObject == player) &#13;
                    { &#13;
                        // ... the player is in sight. &#13;
                        this.playerInSight = true; &#13;
 &#13;
                        if (DEBUG) &#13;
                            Debug.Log("PlayerInSight: " + playerInSight); &#13;
                    } &#13;
                } &#13;
            } &#13;
 &#13;
            if (this.playerInSight) &#13;
            { &#13;
                this.nav.SetDestination(other.transform.position); &#13;
                this.CalculatePathLength(other.transform.position); &#13;
 &#13;
                if (distance &lt; 1.1f) &#13;
                { &#13;
                    this.attack1 = true; &#13;
                } &#13;
                else &#13;
                { &#13;
                    this.attack1 = false; &#13;
                } &#13;
            } &#13;
        } &#13;
    } &#13;
 &#13;
    void OnTriggerExit(Collider other) &#13;
    { &#13;
        if (other.transform.tag.Equals("Player")) &#13;
        { &#13;
            distance = 0.0f; &#13;
            angle = 0.0f; &#13;
            this.attack1 = false; &#13;
            this.playerInSight = false; &#13;
        } &#13;
    } &#13;
 &#13;
    // this is a helper function at this point &#13;
    // in the future we will use it to calculate distance around the corners &#13;
    // it currently is also used to draw the path of the nav mesh agent in the  &#13;
    // editor &#13;
    float CalculatePathLength(Vector3 targetPosition) &#13;
    { &#13;
        // Create a path and set it based on a target position. &#13;
        NavMeshPath path = new NavMeshPath(); &#13;
        if (nav.enabled) &#13;
            nav.CalculatePath(targetPosition, path); &#13;
 &#13;
        // Create an array of points which is the length of the number of corners in the path + 2. &#13;
        Vector3[] allWayPoints = new Vector3[path.corners.Length + 2]; &#13;
 &#13;
        // The first point is the enemy's position. &#13;
        allWayPoints[0] = transform.position; &#13;
 &#13;
        // The last point is the target position. &#13;
        allWayPoints[allWayPoints.Length - 1] = targetPosition; &#13;
 &#13;
        // The points in between are the corners of the path. &#13;
        for (int i = 0; i &lt; path.corners.Length; i++) &#13;
        { &#13;
            allWayPoints[i + 1] = path.corners[i]; &#13;
        } &#13;
 &#13;
        // Create a float to store the path length that is by default 0. &#13;
        float pathLength = 0; &#13;
 &#13;
        // Increment the path length by an amount equal to the distance between each waypoint and the next. &#13;
        for (int i = 0; i &lt; allWayPoints.Length - 1; i++) &#13;
        { &#13;
            pathLength += Vector3.Distance(allWayPoints[i], allWayPoints[i + 1]); &#13;
 &#13;
            if (DEBUG_DRAW) &#13;
                Debug.DrawLine(allWayPoints[i], allWayPoints[i + 1], Color.red); &#13;
        } &#13;
 &#13;
        return pathLength; &#13;
    } &#13;
} &#13;
</pre><p>Ok, so let's actually take a look and see what this code is trying to do. In the <code class="literal">Awake()</code> function we are initializing our variables that will be used in the script. We have a reference to the <code class="literal">NavMeshAgent</code>, the <code class="literal">SphereCollider</code> and the <code class="literal">Animator</code> components attached to the NPC, these are stored in the <code class="literal">nav</code>, <code class="literal">col</code> and <code class="literal">anim</code> variables respectively.</p><p>We also need to get a reference to the player and the player animator component. This is done through the <code class="literal">player</code> variable. We are also setting the <code class="literal">playerInSight</code> variable to false by default.</p><p>The <code class="literal">Update()</code> function is not performing anything major at this point, it is just checking to see if the player character is in sight, and if so, it makes sure that the NPC is orienting itself to look at the player.</p><p>Most of the meat of our code is in the <code class="literal">OnTriggerStay()</code> function. The first thing we need to do is make sure the object that has entered our collider is the player object. This is done by checking the <code class="literal">tag</code> attribute on the other collider.</p><p>If the player is within our collider, then we go ahead and calculate the direction, the distance and the angle of the player relative to the NPC. This is done with the following lines:</p><pre class="programlisting">direction = other.transform.position - transform.position; &#13;
 &#13;
distance = Vector3.Distance(other.transform.position, transform.position) - 1.0f; &#13;
 &#13;
float DotResult = Vector3.Dot(transform.forward,player.transform.position); &#13;
 &#13;
angle = DotResult; &#13;
</pre><p>Then, if the angle is smaller than the <code class="literal">fieldOfViewAngle</code> variable we can use ray casting to determine if we can hit the player. If that is the case, the player is in NPC's sight.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_020.jpg" /></div><p>
</p><p>There is one more critical calculation the NPC needs to perform. That is how to get to the player once it is in range! Once we have established that the player is in range and that we are facing the player, we need to make the NPC find its way to the player. This is where the <code class="literal">NavMesh</code> and the <code class="literal">NavMeshAgent</code> come into play.</p><p>The <code class="literal">CalculatePathLength()</code> is a function that takes the position of the player and using the mesh data, calculates the best path to navigate from the NPC's location to the player's location.</p><p>However, there's one more additional calculation we are performing, and that is, we are calculating the length of the path between the two points. This length calculation will be used in the future to perform the following:</p><p>If the length of the path is larger than a threshold we have set, then we won't make the NPC attack, if it is, then we can make the NPC move towards the player to engage in battle.</p><p>In the last function <code class="literal">OnTriggerExit()</code>, we set the <code class="literal">playerInSight</code> variable to false. This will stop the NPC from pursuing the player.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_04_021.jpg" /></div><p>
</p><p>The preceding screenshot illustrates the path between the NPC and the Player based on real-time calculation.</p><p>Go ahead and attach the script to the NPC prefab if you have not done so already, and run the application to test it out. If all things are good, then you will be able to move the player character around the level, and once the player character enters the NPC's field of view, the NPC will start moving toward the player, and when close enough it will attack.</p><p>At this point your NPC should have the following components attached to its prefab:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Animator</p></li><li style="list-style-type: disc"><p>Rigidbody</p></li><li style="list-style-type: disc"><p>Capsule and Sphere Colliders</p></li><li style="list-style-type: disc"><p>Nav Mesh Agent</p></li><li style="list-style-type: disc"><p>NPC_Movement script</p></li></ul></div><p>We have covered a lot of information. I would encourage you to take the time to read through it one more time and understand the concepts before moving forward.</p></div></div>