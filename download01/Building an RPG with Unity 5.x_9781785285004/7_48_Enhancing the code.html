<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec47"></a>Enhancing the code</h2></div></div><hr /></div><p>One last code implementation I would like to make, before I close out the chapter, is to make sure that when we are in attack mode for the player character, the hit points are going to affect the NPC that it is intended for automatically. In other words, determine which NPC is closest to us based on distance and also our view angle toward the NPC.</p><p>We have already created the logic to determine these quantities for the NPC character, and we need to implement something similar for the player character. Let's take a look at a partial listing of the code changes we need to make for the <span class="emphasis"><em>CharacterMovement.cs</em></span> script:</p><pre class="programlisting">using UnityEngine; &#13;
using System.Collections; &#13;
 &#13;
public class CharacterController : MonoBehaviour &#13;
{ &#13;
 &#13;
  public Animator animator; &#13;
 &#13;
  public float speed = 6.0f; &#13;
  public float h = 0.0f; &#13;
  public float v = 0.0f; &#13;
 &#13;
  public bool attack1 = false; // used for attack mode 1 &#13;
  public bool attack2 = false; // used for attack mode 2 &#13;
  public bool attack3 = false; // used for attack mode 3 &#13;
 &#13;
  public bool jump = false;     // used for jumping &#13;
  public bool die = false;      // are we alive? &#13;
 &#13;
  public bool DEBUG = false; &#13;
 &#13;
  // Reference to the sphere collider trigger component. &#13;
  private SphereCollider col; &#13;
 &#13;
  // where is the player character in relation to NPC &#13;
  public Vector3 direction; &#13;
 &#13;
  // how far away is the player character from NPC &#13;
  public float distance = 0.0f; &#13;
 &#13;
  // what is the angle between the PC and NPC &#13;
  public float angle = 0.0f; &#13;
 &#13;
  // is the PC in sight? &#13;
  public bool enemyInSight; &#13;
 &#13;
  // what is the field of view for our NPC? &#13;
  // currently set to 110 degrees &#13;
  public float fieldOfViewAngle = 110.0f; &#13;
 &#13;
  // calculate the angle between PC and NPC &#13;
  public float calculatedAngle; &#13;
 &#13;
  // Use this for initialization &#13;
  void Start() &#13;
  { &#13;
    this.animator = GetComponent&lt;Animator&gt;() as Animator; &#13;
    //this.attackTimer = 0.0f; &#13;
 &#13;
    // we don't see the player by default &#13;
    this.enemyInSight = false; &#13;
  } &#13;
 &#13;
  // Update is called once per frame &#13;
  private Vector3 moveDirection = Vector3.zero; &#13;
 &#13;
  Quaternion startingAngle = Quaternion.AngleAxis(-60, Vector3.up); &#13;
  Quaternion stepAngle = Quaternion.AngleAxis(5, Vector3.up); &#13;
  Vector3 viewDistance = new Vector3(0, 0, 30); &#13;
 &#13;
  Quaternion startingAttackAngle = Quaternion.AngleAxis(-25, Vector3.up); &#13;
  Quaternion stepAttackAngle = Quaternion.AngleAxis(5, Vector3.up); &#13;
  Vector3 attackDistance = new Vector3(0, 0, 2); &#13;
 &#13;
  void Update() &#13;
  { &#13;
    ... &#13;
 &#13;
    if (Input.GetKeyDown(KeyCode.I)) &#13;
    { &#13;
      this.die = true; &#13;
      SendMessage("Died"); &#13;
    } &#13;
    animator.SetBool("Die", die); &#13;
 &#13;
  } &#13;
 &#13;
  void FixedUpdate() &#13;
  { &#13;
    // The Inputs are defined in the Input Manager &#13;
    // get value for horizontal axis &#13;
    h = Input.GetAxis("Horizontal");  &#13;
    // get value for vertical axis &#13;
    v = Input.GetAxis("Vertical");    &#13;
 &#13;
    speed = new Vector2(h, v).sqrMagnitude; &#13;
 &#13;
    if (DEBUG) &#13;
      Debug.Log(string.Format("H:{0} - V:{1} - Speed:{2}", h, v, speed)); &#13;
 &#13;
    animator.SetFloat("Speed", speed); &#13;
    animator.SetFloat("Horizontal", h); &#13;
    animator.SetFloat("Vertical", v); &#13;
 &#13;
    // We have three different attack modes, we have only implemented the curve parameter for attack1 &#13;
    // therefore, during game play if you use attack2/attack3 you will see the visual attack happening &#13;
    // but the data will not reflect &#13;
    if (this.attack1 || this.attack2 || this.attack3) &#13;
    { &#13;
      #region used for attack range &#13;
      RaycastHit hitAttack; &#13;
      var angleAttack = transform.rotation * startingAttackAngle; &#13;
      var directionAttack = angleAttack * attackDistance; &#13;
      var posAttack = transform.position + Vector3.up; &#13;
      for (var i = 0; i &lt; 10; i++) &#13;
      { &#13;
        Debug.DrawRay(posAttack, directionAttack, Color.yellow); &#13;
        if (Physics.Raycast(posAttack, directionAttack, out hitAttack, 1.0f)) &#13;
        { &#13;
          var enemy = hitAttack.collider.GetComponent&lt;NPC_Agent&gt;(); &#13;
          if (enemy) &#13;
          { &#13;
            //Enemy was seen &#13;
            if(DEBUG) &#13;
              Debug.Log(string.Format("Detected: {0}", enemy.npcData.NAME)); &#13;
            this.enemyInSight = true; &#13;
            GameMaster.instance.closestNPCEnemy = hitAttack.collider.gameObject; &#13;
          } &#13;
          else &#13;
          { &#13;
            this.enemyInSight = false; &#13;
          } &#13;
        } &#13;
        directionAttack = stepAngle * directionAttack; &#13;
      } &#13;
      #endregion &#13;
 &#13;
      if (enemyInSight) &#13;
      { &#13;
        if (animator.GetFloat("Attack1C") == 1.0f) &#13;
        { &#13;
          PC pc = this.gameObject.GetComponent&lt;PlayerAgent&gt;().playerCharacterData; &#13;
          float impact = (pc.STRENGTH + pc.HEALTH) / 100.0f; &#13;
          GameMaster.instance.PlayerAttackEnemy(impact); &#13;
        } &#13;
      } &#13;
 &#13;
    } &#13;
 &#13;
  } &#13;
</pre><p>The way we calculate the sighting and distance of the enemy NPCs is through raycasting. This is done only when we are in attack mode: we check to see if the NPC is in front of us, and if so, we set the <span class="emphasis"><em>closestNPCEnemy</em></span> object in the GameMaster and set the flag <span class="emphasis"><em>enemyInSight</em></span>, where we then perform the necessary subtraction from the health of the NPC.</p><p>Notice that I have also changed the way we are computing the impact of the hit based on a simple equation:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_07_022.jpg" /></div><p>
</p><p>Where pc is the object reference to our Player Character. The same equation is used on the NPC objects. This is just a simple demonstration that the impact of the hit point of the player or the NPC is based on the strength and the health of the actors in the scene.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_07_023.jpg" /></div><p>
</p><p>The preceding screenshotÂ illustrates how we detect if an NPC is in attack range or not.</p><p>In turn you can derive the strength value from the components that the play or the NPC has activated throughout the gameplay.</p><p>Here is partial listing of <span class="emphasis"><em>BaseCharacter.cs</em></span> illustrating the <span class="emphasis"><em>HEALTH</em></span> property:</p><pre class="programlisting">public float HEALTH&#13;
{&#13;
get { return this.health; }&#13;
set&#13;
{&#13;
this.health = value;&#13;
if(this.tag.Equals("Player"))&#13;
{&#13;
if (GameMaster.instance.UI.hudUI != null)&#13;
{&#13;
GameMaster.instance.UI.hudUI.imgHealthBar.fillAmount = this.health / 100.0f;&#13;
}&#13;
}&#13;
else&#13;
{&#13;
this.characterGO.GetComponent&lt;NPC_Agent&gt;().SetHealthValue(this.health / 100.0f);&#13;
}&#13;
}&#13;
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p>There are more code changes and updates, please refer to the associated files provided.</p></div><p>During the process of implementation I have modified a few other code locations that are not listed within the book due to physical limitations. Here are the scripts that have been modified: <span class="emphasis"><em>BaseCharacter.cs</em></span>, <span class="emphasis"><em>CharacterController.cs</em></span>, <span class="emphasis"><em>GameMaster.cs</em></span>, <span class="emphasis"><em>NPC_Agent.cs</em></span>, <span class="emphasis"><em>PlayerAgent.cs</em></span> and <span class="emphasis"><em>NPC_Movement.cs</em></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_07_024.jpg" /></div><p>
</p><p>You are encouraged to do some research and try different types of mechanics and implementation to enhance your skills.</p></div>