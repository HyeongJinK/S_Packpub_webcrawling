<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec51"></a>Network Enabling RPG Characters</h2></div></div><hr /></div><p>In order to make life easier, I decided to create a new scene that will be used to test and implement our network-enabled characters. This example will show you how to network enable the player character and also how to synchronize the player character data such as inventory item across the network and also the ability to network enable the non-player character and make it synchronize its data across the clients.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec65"></a>Creating a Scene for RPG</h3></div></div></div><p>Create a new scene and save it as <span class="emphasis"><em>CH8_Networking</em></span>. Place a <span class="emphasis"><em>Terrain</em></span> in the scene; modify it so that it has a TerrainWidth and Terrain Length of 30. Modify the Position Transform so that it is at &lt;-15,0,-15&gt;; this will make the center of the terrain at the origin.</p><p>Next, we are going to create an Empty GameObject and name it NetworkManager. We are also going to create another Empty GameObject and name is SpawnEnemy.</p><p>Select the <span class="strong"><strong>NetworkManager </strong></span>GameObject and attach the following components to it: <span class="strong"><strong>NetworkManager</strong></span> and <span class="strong"><strong>NetworkManager HUD</strong></span> using the <span class="emphasis"><em>Inspector Windows</em></span>, select <span class="strong"><strong>Add Component | Network | NetworkManager</strong></span> and <span class="strong"><strong>Add Component | Network | NetworkManagerHUD.</strong></span>
</p><p>We will come back to these GameObjects later. We need to make our Player Character network enabled.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec66"></a>Networked Player Character</h3></div></div></div><p>Go ahead and drag the player prefab you created into the scene. We are going to use it as a base to create a new prefab that will be used for the networked version of the game.</p><p>Go ahead and remove the existing <code class="literal">CharacterController.cs </code>and <span class="emphasis"><em>CharacterCustomization.cs</em></span> components from the instance. We are going to create new scripts that are networked enabled and use them. Rename the PC GameObject instance to <span class="emphasis"><em>PC-CC-Network</em></span>. Now, make a prefab of the instance. You should now have a new prefab named <span class="emphasis"><em>PC-CC-Network</em></span>.</p><p>Go ahead and attach the following components to the prefab: <span class="strong"><strong>NetworkIdentiy</strong></span>, <span class="strong"><strong>NetworkTransform</strong></span>, and <span class="strong"><strong>NetworkAnimator</strong></span>using the <span class="emphasis"><em>Inspector Window</em></span> and navigating to <span class="strong"><strong>Add Components | Network</strong></span>
<span class="emphasis"><em> | &lt;component name&gt;</em></span>.</p><p>On <span class="strong"><strong>NetworkIdentity</strong></span> component, set the <span class="strong"><strong>Local Player Authority</strong></span> to <span class="emphasis"><em>True</em></span>. On <span class="strong"><strong>NetworkTransform</strong></span> component change the <span class="emphasis"><em>Transform Sync Mode</em></span> to <span class="emphasis"><em>Sync Transform</em></span>. On the <span class="strong"><strong>NetworkAnimator</strong></span> component, you will need to drag the <span class="emphasis"><em>Animator</em></span> components attached to the GameObject into the <span class="emphasis"><em>Animator</em></span> slot.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip60"></a>Tip</h3><p>You will need to select the <span class="emphasis"><em>Animator</em></span> component and drag it right down into the <span class="emphasis"><em>Animator</em></span> slot on the <span class="emphasis"><em>NetworkAnimator</em></span> components.</p></div><p>Next, we need to create a new character controller so that it is network compatible.</p><p>Create a new C# script and call it <code class="literal">CharacterController_Network.cs</code>. Attach the script to the <span class="emphasis"><em>PC-CC-Network</em></span> prefab. The new character controller is a stripped down version of the original character controller.</p><p>Here is the listing for it:</p><pre class="programlisting">using System; &#13;
 &#13;
using UnityEngine; &#13;
using UnityEngine.Networking; &#13;
using System.Collections; &#13;
 &#13;
public class CharacterController_Network : NetworkBehaviour { &#13;
 &#13;
  public Animator animator; &#13;
 &#13;
  public float speed = 6.0f; &#13;
  public float h = 0.0f; &#13;
  public float v = 0.0f; &#13;
 &#13;
  public bool attack1 = false; // used for attack mode 1 &#13;
  public bool attack2 = false; // used for attack mode 2 &#13;
  public bool attack3 = false; // used for attack mode 3 &#13;
 &#13;
  public bool jump = false;     // used for jumping &#13;
  public bool die = false;      // are we alive? &#13;
 &#13;
  public bool DEBUG = false; &#13;
 &#13;
  // Reference to the sphere collider trigger component. &#13;
  private SphereCollider col; &#13;
 &#13;
  // where is the player character in relation to NPC &#13;
  public Vector3 direction; &#13;
 &#13;
  // how far away is the player character from NPC &#13;
  public float distance = 0.0f; &#13;
 &#13;
  // what is the angle between the PC and NPC &#13;
  public float angle = 0.0f; &#13;
 &#13;
  // is the PC in sight? &#13;
  public bool enemyInSight; &#13;
 &#13;
  // what is the field of view for our NPC? &#13;
  // currently set to 110 degrees &#13;
  public float fieldOfViewAngle = 110.0f; &#13;
 &#13;
  // calculate the angle between PC and NPC &#13;
  public float calculatedAngle; &#13;
 &#13;
  [SyncVar(hook ="OnChangeEnemyToAttack")] &#13;
  public GameObject enemyToAttack; &#13;
 &#13;
  [SyncVar(hook = "OnChangePlayerHealth")] &#13;
  public float Health = 100.0f; &#13;
 &#13;
  [SyncVar] &#13;
  public string Shield=""; &#13;
  [SyncVar] &#13;
  public string Helmet=""; &#13;
 &#13;
  public override void OnStartClient() &#13;
  { &#13;
    if(!String.IsNullOrEmpty(Shield)) &#13;
      PlayerSetShield(Shield); &#13;
 &#13;
    if(!String.IsNullOrEmpty(Helmet)) &#13;
      PlayerSetHelmet(Helmet); &#13;
  } &#13;
 &#13;
  // Use this for initialization &#13;
  void Start() &#13;
  { &#13;
    this.animator = GetComponent&lt;Animator&gt;() as Animator; &#13;
 &#13;
    // we don't see the player by default &#13;
    this.enemyInSight = false; &#13;
  } &#13;
 &#13;
  // Update is called once per frame &#13;
  private Vector3 moveDirection = Vector3.zero; &#13;
 &#13;
  Quaternion startingAttackAngle = Quaternion.AngleAxis(-25, Vector3.up); &#13;
  Quaternion stepAttackAngle = Quaternion.AngleAxis(5, Vector3.up); &#13;
  Vector3 attackDistance = new Vector3(0, 0, 2); &#13;
 &#13;
  void Update() &#13;
  { &#13;
    if (!isLocalPlayer) &#13;
      return; &#13;
 &#13;
    if (enemyInSight) &#13;
    { &#13;
      // Create a vector from the enemy to the player and store the angle between it and forward. &#13;
      direction = enemyToAttack.transform.position - transform.position; &#13;
 &#13;
      this.transform.rotation = &#13;
          Quaternion.Slerp(this.transform.rotation, &#13;
          Quaternion.LookRotation(direction), 0.1f); &#13;
    } &#13;
 &#13;
    if (this.attack1 || this.attack2 || this.attack3) &#13;
    { &#13;
      #region used for attack range &#13;
      RaycastHit hitAttack; &#13;
      var angleAttack = transform.rotation * startingAttackAngle; &#13;
      var directionAttack = angleAttack * attackDistance; &#13;
      var posAttack = transform.position + Vector3.up; &#13;
      for (var i = 0; i &lt; 10; i++) &#13;
      { &#13;
        Debug.DrawRay(posAttack, directionAttack, Color.yellow); &#13;
        if (Physics.Raycast(posAttack, directionAttack, out hitAttack, 1.0f)) &#13;
        { &#13;
          if (hitAttack.collider.gameObject.tag.Equals("ENEMY")) &#13;
          { &#13;
            enemyInSight = true; &#13;
            enemyToAttack = hitAttack.collider.gameObject; &#13;
 &#13;
            CmdEnemyToAttack(hitAttack.collider.gameObject); &#13;
          } &#13;
        } &#13;
        directionAttack = stepAttackAngle * directionAttack; &#13;
      } &#13;
      #endregion &#13;
 &#13;
      if (enemyInSight &amp;&amp; !die) &#13;
      { &#13;
        if (animator.GetFloat("Attack1C") == 1.0f) &#13;
        { &#13;
          CmdEnemyTakeDamage(1.0f); &#13;
        } &#13;
      } &#13;
 &#13;
      if(this.enemyToAttack!=null) &#13;
      { &#13;
        if (this.enemyToAttack.GetComponent&lt;NPC_Movement_Network&gt;().Health &lt;= 0.0f) &#13;
        { &#13;
          enemyInSight = false; &#13;
          enemyToAttack = null; &#13;
        } &#13;
      } &#13;
 &#13;
    } &#13;
 &#13;
    if (Input.GetKeyDown(KeyCode.C)) &#13;
    { &#13;
      attack1 = true; &#13;
      GetComponent&lt;IKHandle&gt;().enabled = false; &#13;
    } &#13;
    if (Input.GetKeyUp(KeyCode.C)) &#13;
    { &#13;
      attack1 = false; &#13;
      GetComponent&lt;IKHandle&gt;().enabled = true; &#13;
    } &#13;
    animator.SetBool("Attack1", attack1); &#13;
 &#13;
    if (Input.GetKeyDown(KeyCode.Z)) &#13;
    { &#13;
      attack2 = true; &#13;
      GetComponent&lt;IKHandle&gt;().enabled = false; &#13;
    } &#13;
    if (Input.GetKeyUp(KeyCode.Z)) &#13;
    { &#13;
      attack2 = false; &#13;
      GetComponent&lt;IKHandle&gt;().enabled = true; &#13;
    } &#13;
    animator.SetBool("Attack2", attack2); &#13;
 &#13;
    if (Input.GetKeyDown(KeyCode.X)) &#13;
    { &#13;
      attack3 = true; &#13;
      GetComponent&lt;IKHandle&gt;().enabled = false; &#13;
    } &#13;
    if (Input.GetKeyUp(KeyCode.X)) &#13;
    { &#13;
      attack3 = false; &#13;
      GetComponent&lt;IKHandle&gt;().enabled = true; &#13;
    } &#13;
    animator.SetBool("Attack3", attack3); &#13;
 &#13;
    if (Input.GetKeyDown(KeyCode.Space)) &#13;
    { &#13;
      jump = true; &#13;
      GetComponent&lt;IKHandle&gt;().enabled = false; &#13;
    } &#13;
    if (Input.GetKeyUp(KeyCode.Space)) &#13;
    { &#13;
      jump = false; &#13;
      GetComponent&lt;IKHandle&gt;().enabled = true; &#13;
    } &#13;
    animator.SetBool("Jump", jump); &#13;
 &#13;
    if (Input.GetKeyDown(KeyCode.I)) &#13;
    { &#13;
      die = true; &#13;
      SendMessage("Died"); &#13;
    } &#13;
    animator.SetBool("Die", die); &#13;
 &#13;
    if(this.Health&lt;=0) &#13;
    { &#13;
      die = true; &#13;
      CmdPlayerCharacterIsDead(); &#13;
    } &#13;
 &#13;
  } &#13;
 &#13;
  [Command] &#13;
  void CmdEnemyToAttack(GameObject go) &#13;
  { &#13;
    enemyInSight = true; &#13;
    enemyToAttack = go; &#13;
  } &#13;
 &#13;
  [Command] &#13;
  void CmdPlayerCharacterIsDead() &#13;
  { &#13;
    RpcPlayerCharacterIsDead(); &#13;
  } &#13;
 &#13;
  [ClientRpc] &#13;
  void RpcPlayerCharacterIsDead() &#13;
  { &#13;
    this.die = true; &#13;
    Destroy(this.gameObject, 2.0f); &#13;
  } &#13;
 &#13;
  [Command] &#13;
  void CmdEnemyTakeDamage(float value) &#13;
  { &#13;
    RpcEnemyTakeDamage(value); &#13;
  } &#13;
 &#13;
  [ClientRpc] &#13;
  void RpcEnemyTakeDamage(float value) &#13;
  { &#13;
    if(this.enemyToAttack != null) &#13;
      this.enemyToAttack.GetComponent&lt;NPC_Movement_Network&gt;().Damage(value); &#13;
  } &#13;
 &#13;
  void FixedUpdate() &#13;
  { &#13;
    if (!isLocalPlayer) &#13;
      return; &#13;
 &#13;
    // The Inputs are defined in the Input Manager &#13;
    h = Input.GetAxis("Horizontal"); &#13;
    v = Input.GetAxis("Vertical"); &#13;
 &#13;
    speed = new Vector2(h, v).sqrMagnitude; &#13;
 &#13;
    if (DEBUG) &#13;
      Debug.Log(string.Format("H:{0} - V:{1} - Speed:{2}", h, v, speed)); &#13;
 &#13;
    animator.SetFloat("Speed", speed); &#13;
    animator.SetFloat("Horizontal", h); &#13;
    animator.SetFloat("Vertical", v); &#13;
 &#13;
  } &#13;
 &#13;
  // Var Sync hook function ... &#13;
  void OnChangePlayerHealth(float health) &#13;
  { &#13;
    this.Health = health; &#13;
  } &#13;
 &#13;
  // Var Sync hook function &#13;
  void OnChangeEnemyToAttack(GameObject enemy) &#13;
  { &#13;
    this.enemyToAttack = enemy; &#13;
  } &#13;
 &#13;
  public void PlayerArmourChanged(InventoryItem item) &#13;
  { &#13;
    switch (item.TYPE.ToString()) &#13;
    { &#13;
      case "HELMET": &#13;
        { &#13;
          this.Helmet = item.NAME; &#13;
          this.GetComponent&lt;CharacterCustomization_Network&gt;().SetHelmetType((PC.HELMET_TYPE)Enum.Parse(typeof(PC.HELMET_TYPE), item.NAME)); &#13;
          break; &#13;
        } &#13;
      case "SHIELD": &#13;
        { &#13;
          this.Shield = item.NAME; &#13;
          this.GetComponent&lt;CharacterCustomization_Network&gt;().SetShieldType((PC.SHIELD_TYPE)Enum.Parse(typeof(PC.SHIELD_TYPE), item.NAME)); &#13;
          break; &#13;
        } &#13;
      case "SHOULDER_PAD": &#13;
        { &#13;
          this.GetComponent&lt;CharacterCustomization_Network&gt;().SetShoulderPad((PC.SHOULDER_PAD)Enum.Parse(typeof(PC.SHOULDER_PAD), item.NAME)); &#13;
          break; &#13;
        } &#13;
      case "KNEE_PAD": &#13;
        { &#13;
          break; &#13;
        } &#13;
      case "BOOTS": &#13;
        { &#13;
          break; &#13;
        } &#13;
    } &#13;
  } &#13;
 &#13;
  private void PlayerSetHelmet(string item) &#13;
  { &#13;
    Debug.Log("Helmet: " + item); &#13;
    this.GetComponent&lt;CharacterCustomization_Network&gt;().SetHelmetType((PC.HELMET_TYPE)Enum.Parse(typeof(PC.HELMET_TYPE), item)); &#13;
  } &#13;
 &#13;
  private void PlayerSetShield(string item) &#13;
  { &#13;
    this.GetComponent&lt;CharacterCustomization_Network&gt;().SetShieldType((PC.SHIELD_TYPE)Enum.Parse(typeof(PC.SHIELD_TYPE), item)); &#13;
  } &#13;
 &#13;
} &#13;
</pre><p>The first thing you should notice is that we are inheriting from <code class="literal">NetworkBehaviour</code> instead of <code class="literal">MonoBehaviour</code>. This is needed if we want to enable certain network behaviors on the GameObject.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_015.jpg" /></div><p>
</p><p>Next, let's look at some of the variables that need to be synchronized across the network for each player character that is connected. These variables are: <code class="literal">enemyToAttack</code> and <code class="literal">Health</code>. There are two more variables, <code class="literal">Shield</code> and <code class="literal">Helmet</code>, which we will discuss later.</p><p>In the <code class="literal">Update()</code> function, we need a way to check and make sure that it is the local player before giving the controller the chance to execute the player. This is done by having the following code check to see if the current client is the local player:</p><pre class="programlisting">    if (!isLocalPlayer) &#13;
      return; &#13;
</pre><p>This will make sure that the code runs only for the current client (player). The rest of the code in the <code class="literal">Update()</code> function check to see if the enemy is in sight and make sure the player charter is facing the enemy to attack.</p><p>If the player is in attack mode, and the enemy is in our view, we set the <code class="literal">enemyInSight</code> to <code class="literal">True</code> and <code class="literal">enemyToAttack</code> to the enemy GameObject which is stored in the <code class="literal">hitAttack</code> variable of type <code class="literal">RacastHit</code>. The important element here is the <code class="literal">CmdEnemyToAttack()</code> function. The client needs to send a command to the server telling the server who the target of attack is.</p><pre class="programlisting">  [Command] &#13;
  void CmdEnemyToAttack(GameObject go) &#13;
  { &#13;
    this.enemyInSight = true; &#13;
    this.enemyToAttack = go; &#13;
  } &#13;
</pre><p>This will make sure that the data is registered correctly on the server, and it is synchronized to other clients. We also have another function called <code class="literal">CmdEnemyTakeDamage()</code> that is used to reduce the health of the enemy character on the server. The server then calls the <code class="literal">RpcEnemyTakeDamage()</code> function to synchronize across all clients the health value of the enemy.</p><pre class="programlisting">  [Command] &#13;
  void CmdEnemyTakeDamage(float value) &#13;
  { &#13;
    RpcEnemyTakeDamage(value); &#13;
  } &#13;
 &#13;
  [ClientRpc] &#13;
  void RpcEnemyTakeDamage(float value) &#13;
  { &#13;
    if(this.enemyToAttack != null) &#13;
      this.enemyToAttack.GetComponent&lt;NPC_Movement_Network&gt;().Damage(value); &#13;
  } &#13;
</pre><p>This idea is a bit confusing at first, but it will be clearer as you start to study it more carefully.</p><p>We also have the following function to send commands to the server when the player dies:</p><pre class="programlisting">  [Command] &#13;
  void CmdPlayerCharacterIsDead() &#13;
  { &#13;
    RpcPlayerCharacterIsDead(); &#13;
  } &#13;
 &#13;
  [ClientRpc] &#13;
  void RpcPlayerCharacterIsDead() &#13;
  { &#13;
    this.die = true; &#13;
    Destroy(this.gameObject, 2.0f); &#13;
  } &#13;
</pre><p>The preceding functions make sure that the player character is dead and destroyed on all connected clients at the moment of the game.</p><p>And finally, the following hook functions that are used by the SyncVar on Health and enemyToAttack variables:</p><pre class="programlisting">  // Var Sync hook function ... &#13;
  void OnChangePlayerHealth(float health) &#13;
  { &#13;
    this.Health = health; &#13;
  } &#13;
 &#13;
  // Var Sync hook function &#13;
  void OnChangeEnemyToAttack(GameObject enemy) &#13;
  { &#13;
    this.enemyToAttack = enemy; &#13;
  } &#13;
</pre><p>This idea is a bit confusing at first, but it will be clearer as you start to study it more carefully.</p><p>If you have not done so already, apply and save all of your changes to your <span class="emphasis"><em>PC-CC-Network</em></span> prefab.</p><p>At this stage, your character is ready to be integrated with the <span class="emphasis"><em>NetworkManager</em></span>, you can drag and drop the prefab into the Player Prefab slot and build a standalone version to test out your character movement and synchronization.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec67"></a>Networked Non-Player Character</h3></div></div></div><p>Just like the player character network-enabled prefab, we will use the non-player character prefab as our base to get started. Go ahead and create an instance of your NPC in the scene.</p><p>Go ahead and remove the existing <span class="emphasis"><em>NPC_Movement.cs</em></span> component from the prefab. Rename the Prefab to <span class="emphasis"><em>B1-Network</em></span> and attach the following components to it: <span class="emphasis"><em>NetworkIdentity</em></span>, <span class="emphasis"><em>NetworkTransform</em></span>, and <span class="emphasis"><em>NetworkAnimator</em></span> by navigating to <span class="strong"><strong>Add Component | Network</strong></span>
<span class="emphasis"><em> | &lt;component name&gt;</em></span> from the <span class="strong"><strong>Inspector Window</strong></span>.</p><p>On the <span class="emphasis"><em>NetworkIdentity</em></span> component, set the <span class="emphasis"><em>Local Player Authority</em></span> to <span class="emphasis"><em>True</em></span>; in the <span class="emphasis"><em>NetworkTransform</em></span> component, set the <span class="emphasis"><em>Transform Sync Mode</em></span> to <span class="emphasis"><em>Sync Transform</em></span>; and for the <span class="emphasis"><em>NetworkAnimator</em></span> component, set the <span class="emphasis"><em>Animator</em></span> slot to the <span class="emphasis"><em>Animator</em></span> controller attached to the prefab, by dragging it and dropping into the slot.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_016.jpg" /></div><p>
</p><p>We not need to create a new script for out NPC movement that is network enabled. Go ahead and create a new C# script and name it <code class="literal">NPC_Movement_Network.cs</code>. Here is a listing of the scripts:</p><pre class="programlisting">using UnityEngine;&#13;
using UnityEngine.Networking;&#13;
using System.Collections;&#13;
public class NPC_Movement_Network : NetworkBehaviour {</pre><pre class="programlisting">  // reference to the animator&#13;
  public Animator animator;&#13;
  // these variables are used for the speed&#13;
  // horizontal and vertical movement of the NPC&#13;
  public float speed = 0.0f;&#13;
  public float h = 0.0f;&#13;
  public float v = 0.0f;</pre><pre class="programlisting">  public bool attack1 = false; // used for attack mode 1&#13;
  public bool attack2 = false; // used for attack mode 2&#13;
  public bool attack3 = false; // used for attack mode 3&#13;
  public bool jump = false;     // used for jumping&#13;
  [SyncVar(hook ="OnNPCIsDead")]&#13;
  public bool die = false;      // are we alive?&#13;
  // used for debugging&#13;
  public bool DEBUG = false;&#13;
  public bool DEBUG_DRAW = false;&#13;
  // Reference to the NavMeshAgent component.&#13;
  private NavMeshAgent nav;&#13;
  // Reference to the sphere collider trigger component.&#13;
  private SphereCollider col;&#13;
  // where is the player character in relation to NPC&#13;
  [SyncVar]&#13;
  public Vector3 direction;&#13;
  // how far away is the player character from NPC&#13;
  [SyncVar]&#13;
  public float distance = 0.0f;&#13;
  // what is the angle between the PC and NPC&#13;
  [SyncVar]&#13;
  public float angle = 0.0f;&#13;
&#13;
  // is the PC in sight?&#13;
  [SyncVar(hook = "OnChangePlayerPlayerInSight")]&#13;
  public bool playerInSight;&#13;
  // what is the field of view for our NPC?&#13;
  // currently set to 110 degrees&#13;
  [SyncVar]&#13;
  public float fieldOfViewAngle = 110.0f;&#13;
  // calculate the angle between PC and NPC&#13;
  [SyncVar]&#13;
  public float calculatedAngle;&#13;
  [SyncVar(hook = "OnChangePlayerToAttackInNPC")]&#13;
  public GameObject playerToAttack;&#13;
  [SyncVar(hook = "OnChangeNPCHealth")]&#13;
  public float Health = 100.0f;</pre><pre class="programlisting">  void Awake()&#13;
  {&#13;
    // get reference to the animator component&#13;
    this.animator = GetComponent&lt;Animator&gt;() as Animator;&#13;
    // get reference to nav mesh agent&#13;
    this.nav = GetComponent&lt;NavMeshAgent&gt;() as NavMeshAgent;&#13;
    // get reference to the sphere collider&#13;
    this.col = GetComponent&lt;SphereCollider&gt;() as SphereCollider;&#13;
    // we don't see the player by default&#13;
    this.playerInSight = false;&#13;
  }&#13;
&#13;
  void Update()&#13;
  {&#13;
    // only execute the following code if local player ...&#13;
    if (!isServer)&#13;
      return;&#13;
    this.CmdUpdateNetwork();&#13;
  }&#13;
  [Command]&#13;
  void CmdUpdateNetwork()&#13;
  {&#13;
    this.RpcUpdateNetwork();&#13;
  }&#13;
&#13;
  [ClientRpc]&#13;
  void RpcUpdateNetwork()&#13;
  {&#13;
    // if player is in sight let's slerp towards the player&#13;
    if(this.playerToAttack!=null)&#13;
    {&#13;
      if (playerInSight)&#13;
      {&#13;
        this.transform.rotation =&#13;
            Quaternion.Slerp(this.transform.rotation,&#13;
            Quaternion.LookRotation(direction), 0.1f);&#13;
        if (this.playerToAttack.transform.GetComponent&#13;
        &lt;CharacterController_Network&gt;().die)&#13;
        {&#13;
          animator.SetBool("Attack", false);&#13;
          animator.SetFloat("Speed", 0.0f);&#13;
          animator.SetFloat("AngularSpeed", 0.0f);&#13;
          this.playerInSight = false;&#13;
          this.playerToAttack = null;&#13;
        }&#13;
      }&#13;
    }&#13;
    if(this.Health&lt;=0.0f)&#13;
    {&#13;
      this.die = true;&#13;
      this.Health = 0.0f;&#13;
      animator.SetBool("Attack", false);&#13;
      animator.SetFloat("Speed", 0.0f);&#13;
      animator.SetFloat("AngularSpeed", 0.0f);&#13;
      this.playerInSight = false;&#13;
      this.playerToAttack = null;&#13;
    }&#13;
    animator.SetBool("Die", die);&#13;
  }&#13;
  // let's update our scene using fixed update&#13;
  void FixedUpdate()&#13;
  {&#13;
    // only execute the following code if local player ...&#13;
    if (!isServer)&#13;
      return;&#13;
    this.RpcFixedUpdateNetwork();&#13;
  }</pre><pre class="programlisting">  [ClientRpc]&#13;
  void RpcFixedUpdateNetwork()&#13;
  {&#13;
    if (playerInSight)&#13;
    {&#13;
      h = angle;          // assign horizontal axis&#13;
      v = distance;       // assign vertical axis&#13;
      // calculate speed based on distance and delta time&#13;
      speed = distance / Time.deltaTime;&#13;
      if (DEBUG)&#13;
        Debug.Log(string.Format("H:{0} - V:{1} - Speed:{2}",&#13;
        h, v, speed));&#13;
      // set the parameters defined in the animator controller&#13;
      animator.SetFloat("Speed", speed);&#13;
      animator.SetFloat("AngularSpeed", v);&#13;
      animator.SetBool("Attack", attack1);&#13;
      animator.SetBool("Attack1", attack1);&#13;
      if (animator.GetFloat("Attack1C") == 1.0f)&#13;
      {&#13;
        this.playerToAttack.GetComponent&#13;
        &lt;CharacterController_Network&gt;().Health -= 1.0f;&#13;
        if(this.playerToAttack.GetComponent&#13;
        &lt;CharacterController_Network&gt;().Health&lt;=0)&#13;
        {&#13;
          this.playerInSight = false;&#13;
          this.playerToAttack = null;&#13;
        }&#13;
      }&#13;
    }&#13;
    else&#13;
    {&#13;
      animator.SetBool("Attack", false);&#13;
      animator.SetFloat("Speed", 0.0f);&#13;
      animator.SetFloat("AngularSpeed", 0.0f);&#13;
    }&#13;
  }&#13;
&#13;
  public void OnChangePlayerPlayerInSight(bool value)&#13;
  {&#13;
    this.playerInSight = value;&#13;
  }&#13;
&#13;
  // Var Sync hook function ...&#13;
  void OnChangeNPCHealth(float health)&#13;
  {&#13;
    this.Health = health;&#13;
  }&#13;
  void OnNPCIsDead(bool value)&#13;
  {&#13;
    die = true;&#13;
  }&#13;
  public void Damage(float value)&#13;
  {&#13;
    this.Health -= value;&#13;
  }&#13;
  void OnTriggerStay(Collider other)&#13;
  {&#13;
    if (die)&#13;
      return;&#13;
    if (other.transform.tag.Equals("Player"))&#13;
    {&#13;
      // Create a vector from the enemy to the player &#13;
      //and store the angle between it and forward.&#13;
      direction = other.transform.position - transform.position;&#13;
      distance = Vector3.Distance(other.transform.position, &#13;
      transform.position) - 1.0f;&#13;
      float DotResult = Vector3.Dot(transform.forward, &#13;
      other.transform.position); //player.transform.position);&#13;
      angle = DotResult;&#13;
      if (DEBUG_DRAW)&#13;
      {&#13;
        Debug.DrawLine(transform.position + Vector3.up, &#13;
       direction * 50, Color.gray);&#13;
        Debug.DrawLine(other.transform.position, transform.position,&#13;
        Color.cyan);&#13;
      }&#13;
      this.playerInSight = false;&#13;
      this.calculatedAngle = Vector3.Angle(direction, &#13;
      transform.forward);&#13;
      if (calculatedAngle &lt; fieldOfViewAngle * 0.5f)&#13;
      {&#13;
        RaycastHit hit;&#13;
        if (DEBUG_DRAW)&#13;
          Debug.DrawRay(transform.position + transform.up, &#13;
          direction.normalized, Color.magenta);&#13;
        // ... and if a raycast towards the player hits something...&#13;
        if (Physics.Raycast(transform.position + transform.up, &#13;
        direction.normalized, out hit, col.radius))&#13;
        {&#13;
          // ... and if the raycast hits the player...&#13;
          if (hit.collider.gameObject == other.gameObject) //player)&#13;
          {&#13;
            if(other.gameObject.GetComponent&#13;
            &lt;CharacterController_Network&gt;().Health&gt;0)&#13;
            {&#13;
              // ... the player is in sight.&#13;
              this.playerInSight = true;&#13;
              this.playerToAttack = hit.collider.gameObject;&#13;
              if (DEBUG)&#13;
                Debug.Log("PlayerInSight: " + playerInSight);&#13;
            }&#13;
          }&#13;
        }&#13;
      }&#13;
      if (this.playerInSight)&#13;
      {&#13;
        this.nav.SetDestination(other.transform.position);&#13;
        this.CalculatePathLength(other.transform.position);&#13;
        if (distance &lt; 1.1f)&#13;
        {&#13;
          this.attack1 = true;&#13;
        }&#13;
        else&#13;
        {&#13;
          this.attack1 = false;&#13;
        }&#13;
      }&#13;
      else&#13;
      {&#13;
        this.nav.SetDestination(this.transform.position);&#13;
        if (distance &lt; 1.1f)&#13;
        {&#13;
          this.attack1 = true;&#13;
        }&#13;
        else&#13;
        {&#13;
          this.attack1 = false;&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
</pre><pre class="programlisting">  void OnChangePlayerToAttackInNPC(GameObject player)&#13;
  {&#13;
    this.playerToAttack = player;&#13;
  }&#13;
  void OnTriggerExit(Collider other)&#13;
  {&#13;
    if (other.transform.tag.Equals("Player"))&#13;
    {&#13;
      distance = 0.0f;&#13;
      angle = 0.0f;&#13;
      this.attack1 = false;&#13;
      this.playerInSight = false;&#13;
      this.playerToAttack = null;&#13;
    }&#13;
  }&#13;
  // this is a helper function at this point&#13;
  // in the future we will use it to calculate distance &#13;
  // around the corners&#13;
  // it currently is also used to draw the path of the &#13;
  //  nav mesh agent in the editor&#13;
  float CalculatePathLength(Vector3 targetPosition)&#13;
  {&#13;
    // Create a path and set it based on a target position.&#13;
    NavMeshPath path = new NavMeshPath();&#13;
    if (nav.enabled)&#13;
      nav.CalculatePath(targetPosition, path);&#13;
    // Create an array of points which is the length of the &#13;
    number of corners in the path + 2.&#13;
    Vector3[] allWayPoints = new Vector3[path.corners.Length + 2];&#13;
    // The first point is the enemy's position.&#13;
    allWayPoints[0] = transform.position;&#13;
    // The last point is the target position.&#13;
    allWayPoints[allWayPoints.Length - 1] = targetPosition;&#13;
    // The points inbetween are the corners of the path.&#13;
    for (int i = 0; i &lt; path.corners.Length; i++)&#13;
    {&#13;
      allWayPoints[i + 1] = path.corners[i];&#13;
    }&#13;
    // Create a float to store the path length that is &#13;
    // by default 0.&#13;
    float pathLength = 0;&#13;
    &#13;
    // Increment the path length by an amount equal to the &#13;
    // distance between each waypoint and the next.&#13;
    for (int i = 0; i &lt; allWayPoints.Length - 1; i++)&#13;
    {&#13;
      pathLength += Vector3.Distance(allWayPoints[i], &#13;
      allWayPoints[i + 1]);&#13;
      if (DEBUG_DRAW)&#13;
        Debug.DrawLine(allWayPoints[i], allWayPoints[i + 1], &#13;
        Color.red);&#13;
    }&#13;
    return pathLength;&#13;
  }&#13;
}</pre><p>There are a few variables that have been indicated as <code class="literal">SyncVars</code>, these are: <code class="literal">die</code>, <code class="literal">distance</code>, <code class="literal">direction</code>, <code class="literal">angle</code>, <code class="literal">playerInSight</code>, <code class="literal">fieldOfViewAngle</code>, <code class="literal">calculatedAngle</code>, <code class="literal">playerToAttack</code>, and <code class="literal">Health</code>.</p><p>Some of the <code class="literal">SyncVars</code> have a <code class="literal">hook</code>, these are <code class="literal">Health</code>, <code class="literal">playerToAttack</code>, <code class="literal">playerInSight</code>, and <code class="literal">die</code>.</p><p>In the <code class="literal">Update()</code>function, we check to make sure we are the server by the following line:</p><pre class="programlisting">    // only execute the following code if server ... &#13;
    if (!isServer) &#13;
      return; &#13;
</pre><p>If we are the server, we use <code class="literal">CmdUpdateNetwork()</code> and <code class="literal">RpcUpdateNetwork()</code> functions to perform our duties. These are just for the movement and action for the NPC. The key here are the <code class="literal">SyncVars</code> and <code class="literal">hook</code> functions that are used to synchronize the NPC data to all clients.</p><pre class="programlisting">  public void OnChangePlayerPlayerInSight(bool value) &#13;
  { &#13;
    this.playerInSight = value; &#13;
  } &#13;
 &#13;
  // Var Sync hook function ... &#13;
  void OnChangeNPCHealth(float health) &#13;
  { &#13;
    this.Health = health; &#13;
  }</pre><pre class="programlisting">  void OnNPCIsDead(bool value) &#13;
  { &#13;
    die = true; &#13;
  } &#13;
  void OnChangePlayerToAttackInNPC(GameObject player) &#13;
  { &#13;
    this.playerToAttack = player; &#13;
  } &#13;
</pre><p>That is all we need for the NPC. Go ahead and add the script to the prefab and apply the changes. Save it!</p><p>Your new NPC prefab should have the following components attached:</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec68"></a>Synchronizing Player Customization and Items</h3></div></div></div><p>In order for this to work, we need to perform several other configuration and creation of new inventory item prefabs. I am going to use two inventory items to demonstrate this particular point.</p><p>I am going to use one of the Helmet prefabs from my inventory items, duplicate it, and remove the <span class="emphasis"><em>InventoryItemAgent.cs</em></span> component. We are going to create a new script that is network enabled as we did for our PC and NPC.</p><p>Attach the following components to the instance: <span class="strong"><strong>NetworkIdentity</strong></span> and <span class="strong"><strong>NetworkTransform</strong></span> using <span class="strong"><strong>Add Component | Network</strong></span>
<span class="emphasis"><em> | &lt;component name&gt;</em></span> from the <span class="strong"><strong>Inspector Window</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785285004/graphics/image_08_017.jpg" /></div><p>
</p><p>Create a new script named <code class="literal">InventoryItemAgent_Network.cs</code>. Here is the listing:</p><pre class="programlisting">using UnityEngine; &#13;
using UnityEngine.Networking; &#13;
using System.Collections; &#13;
 &#13;
public class InventoryItemAgent_Network : NetworkBehaviour { &#13;
 &#13;
  public InventoryItem ItemDescription; &#13;
 &#13;
  public void OnTriggerEnter(Collider c) &#13;
  { &#13;
    // make sure we are colliding with the player &#13;
    if (c.gameObject.tag.Equals("Player")) &#13;
    { &#13;
      // Make a copy of the Inventory Item Object &#13;
      InventoryItem myItem = new InventoryItem(); &#13;
      myItem.CopyInventoryItem(this.ItemDescription); &#13;
 &#13;
      c.gameObject.GetComponent&lt;CharacterController_Network&gt;().PlayerArmourChanged(myItem); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>All this script is doing is assigning the inventory item to the player character using the <code class="literal">PlayerArmourChanged()</code> function in the <code class="literal">CharacterController_Network.cs</code> script.</p><p>The <code class="literal">PlayerArmourChanged()</code> function uses another script we need to create that is network enabled, and that is the <span class="emphasis"><em>CharacterCustomization_Network.cs</em></span> script. I will not list the script here as it is very long. You can look at the script in the code supplied by the book.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec69"></a>Spawning NPC and Other Items</h3></div></div></div><p>We need a way to spawn our NPC and also the inventory items we are going to be using for the next demonstration.</p><p>In the <span class="strong"><strong>Hierarchy Window</strong></span>, right-click on and select <span class="strong"><strong>Create Empty</strong></span>. This will create an Empty GameObject. Rename it to <span class="emphasis"><em>SpawnEnemy</em></span> and add a <span class="strong"><strong>NetworkIdentity</strong></span> component to it by navigating to <span class="strong"><strong>Add Component | Network | NetworkIdentity</strong></span> from the <span class="strong"><strong>Inspector Window</strong></span>.</p><p>We are going to create a new script called <code class="literal">EnemySpawn_Network.cs</code>. Here is the listing:</p><pre class="programlisting">using UnityEngine; &#13;
using UnityEngine.Networking; // used for chapter 8 &#13;
 &#13;
using System.Collections; &#13;
 &#13;
public class EnemySpawn_Network : NetworkBehaviour &#13;
{ &#13;
  public GameObject enemyPrefab; &#13;
  public Transform spawnLocation; &#13;
 &#13;
  public GameObject inventoryItemPrefab; &#13;
  public GameObject inventoryItemShield; &#13;
 &#13;
  public override void OnStartServer() &#13;
  { &#13;
    GameObject go = GameObject.Instantiate(enemyPrefab, spawnLocation.position, Quaternion.identity) as GameObject; &#13;
    NetworkServer.Spawn(go); &#13;
 &#13;
 &#13;
    GameObject goInventoryItem1 = GameObject.Instantiate(inventoryItemPrefab, new Vector3(2, 1, 2), Quaternion.identity) as GameObject; &#13;
    NetworkServer.Spawn(goInventoryItem1); &#13;
 &#13;
    GameObject goInventoryItem2 = GameObject.Instantiate(inventoryItemShield, new Vector3(3, 1, 2), Quaternion.identity) as GameObject; &#13;
    NetworkServer.Spawn(goInventoryItem2); &#13;
 &#13;
  } &#13;
} &#13;
</pre><p>The script is very simple as you can see. We are just referencing the GameObjects that are representing the prefabs for the NPC and also inventory items prefab.</p><p>Attach the new script to the <span class="strong"><strong>SpawnEnemy</strong></span> prefab in the <span class="strong"><strong>Hierarchy Window</strong></span>.</p></div></div>