<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec35"></a>Adjusting basic textured materials</h2></div></div><hr /></div><p>As we have <a id="id335" class="indexterm"></a>already seen in the previous chapters, Unity adds materials for all applied textures and colors in imported models. However, as the<a id="id336" class="indexterm"></a> materials defined in CAD or BIM exports tend to be fairly basic, Unity has little information to define a dull color and texture map, using the default <a id="id337" class="indexterm"></a>diffuse shader.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>Every material in Unity is <a id="id338" class="indexterm"></a>controlled by a "Shader". This is a series of instructions, written in an interpreted language that gets compiled into GPU instructions. Common shaders use textures, for example, color and/or bump mapping.</p></div><p>The first thing to do is to check the imported materials to ensure all textures are really defined and found. Ensure imported models have integrated UV coordinates to define how the texture is mapped onto the geometry. If you use different textures, you might need to adapt the scaling (tiling). Since materials are shared between objects, this affects all objects that reference the same material.</p><div class="mediaobject"><img src="/graphics/9781783559060/graphics/7500EN_06_01.jpg" /></div><p>The <span class="strong"><strong>Diffuse</strong></span> shader only has a <span class="strong"><strong>Main Color</strong></span> and <span class="strong"><strong>Base (RGB)</strong></span> map. The <span class="strong"><strong>Main Color</strong></span> mapping modulates the material, so you can increase brightness simply by setting this color to white.</p><p>When <a id="id339" class="indexterm"></a>switching to a <span class="strong"><strong>Diffuse Bump</strong></span> shader option, you <a id="id340" class="indexterm"></a>can additionally set <span class="strong"><strong>NormalMap</strong></span>. In regular bump maps, each pixel's brightness indicates high or low bumps. With normal maps, an RGB color represents a normal vector (R=X, G=Y, B=Z). This gives more detail about the direction of the bumps and is directly supported by the GPU. If you don't use a suitable normal map, Unity displays a warning, <span class="strong"><strong>This texture is not marked as a normal map</strong></span>. By clicking on <span class="strong"><strong>Fix Now</strong></span>, as shown in the following screenshot, Unity adapts the image import settings to generate a suitable normal map. However, please do this for a copy of the image file, as the same file cannot be a regular texture and normal map at the same time:</p><div class="mediaobject"><img src="/graphics/9781783559060/graphics/7500EN_06_02.jpg" /></div><p>In the example, we copied the original texture and inverted the image, as the mortar lines were bright, which indicates that they lie above the darker regions. When setting as <span class="strong"><strong>Normal map</strong></span>, we enabled <span class="strong"><strong>Create from Grayscale</strong></span>, indicating that only brightness values are taken into account. The <span class="strong"><strong>Filtering</strong></span> option was set to <span class="strong"><strong>Smooth</strong></span> instead of <span class="strong"><strong>Sharp</strong></span>. Click on <span class="strong"><strong>Apply</strong></span>.</p><p>This<a id="id341" class="indexterm"></a> approach can be followed for most building <a id="id342" class="indexterm"></a>materials that are not transparent or reflective, such as concrete, wood, bricks, and soil.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec34"></a>Creating convincing glass</h3></div></div></div><p>A very basic, elementary glass material<a id="id343" class="indexterm"></a> can be simulated using the <span class="strong"><strong>Transparent/Specular</strong></span> shader, available by default. It has support for both the <span class="strong"><strong>Main Color</strong></span> and a <span class="strong"><strong>Specular Color</strong></span> map. In the following screenshot, we set the <span class="strong"><strong>Main Color</strong></span> option to transparent, by adjusting the alpha component (A) to be below 255.</p><div class="mediaobject"><img src="/graphics/9781783559060/graphics/7500EN_06_03.jpg" /></div><p>Even though this provides a fast transparent material, it is not convincing. While full ray traced reflections will take some more years to become viable in real time systems, there are tricks to at<a id="id344" class="indexterm"></a> least give the illusion of reflectivity. The same way a Skybox was simulated using a CubeMap, this kind of map is also usable to fake reflection. There is a series of reflective shaders in Unity (for example, <span class="strong"><strong>Reflective/Specular</strong></span>), but they do not provide support for transparency. Luckily, others have provided a suitable shader that can be used without much effort. Two suitable glass shaders<a id="id345" class="indexterm"></a> are documented on the Unity wiki (<a class="ulink" href="http://wiki.unity3d.com/index.php/Glass_Shader" target="_blank">http://wiki.unity3d.com/index.php/Glass_Shader</a>). The basic <span class="strong"><strong>Glass</strong></span> shader is very simple and looks a bit similar to our first attempt done previously, so we will use only the second, more advanced example, called <span class="strong"><strong>Glass Reflective</strong></span>. This uses a CubeMap to fake reflections from the environment. While not really reflecting the scene, it provides a convincing effect in a real time environment when you use the same CubeMap as your Skybox material. We will now illustrate how to apply the example glass shader code in your Unity project:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start a new shader (by navigating to <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Shader</strong></span>) and double-click on it to open the default code editor (<span class="strong"><strong>Monodevelop</strong></span>, usually, if you allowed it to be installed with Unity initially).</p></li><li><p>Although this is not a complete overview of shading programming, we explain this example in detail to understand what is going on. Luckily, the first section is simple, as it only defines the basic name and sets properties to be available in the <span class="strong"><strong>Inspector</strong></span> tab and their default values:</p><div class="informalexample"><pre class="programlisting">Shader "Glass Reflective" {
Properties {
  _SpecColor ("Specular Color", Color) = (0.5, 0.5, 0.5, 1)
  _Shininess ("Shininess", Range (0.01, 1)) = 0.078125
  _ReflectColor ("Reflection Color", Color) = (1,1,1,0.5)
  _Cube("Reflection Cubemap",Cube) = "black"{TexGen CubeReflect}
}</pre></div></li><li><p>In the following code, we indicate that this is a transparent material. This is rendered <a id="id346" class="indexterm"></a>after the opaque objects are rendered to blend the colors.</p><div class="informalexample"><pre class="programlisting">SubShader {
  Tags {
    "Queue"="Transparent"
    "IgnoreProjector"="True"
    "RenderType"="Transparent"
  }
  LOD 300</pre></div></li><li><p>In the shader program (<code class="literal">CGPROGRAM</code>) the actual calculations are coded. The color sampled from the CubeMap (<code class="literal">reflcol</code>) is first modulated (multiplied) with the RGB channel of the reflection color (<code class="literal">_ReflectColor.rgb</code>) as set previously. This defines the output emission (<code class="literal">o.Emission</code>). The same reflection color is also multiplied with the alpha channel of the reflection color to set the output opacity (<code class="literal">o.Alpha</code>). The output (<code class="literal">o</code>) is what is returned back from the shader to the graphics system. The shader program is as follows:</p><div class="informalexample"><pre class="programlisting">  CGPROGRAM
    #pragma surface surf BlinnPhong decal:add nolightmap
    samplerCUBE _Cube;
    fixed4 _ReflectColor;
    half _Shininess;
    struct Input {
      float3 worldRefl;
    };
    void surf (Input IN, inout SurfaceOutput o) {
      o.Albedo = 0;
      o.Gloss = 1;
      o.Specular = _Shininess;
      fixed4 reflcol = texCUBE (_Cube, IN.worldRefl);
      o.Emission = reflcol.rgb * _ReflectColor.rgb;
      o.Alpha = reflcol.a * _ReflectColor.a;
    }
  ENDCG
}</pre></div></li><li><p>And finally, the <code class="literal">Fallback</code> section ensures that the shader will render at least something when the GPU cannot render the preceding instructions. You see this with most shaders. The Fallback section is as follows:</p><div class="informalexample"><pre class="programlisting">FallBack "Transparent/VertexLit"
}</pre></div></li><li><p>Ensure that your glass material uses this shader. Assign the material to geometry or adjust the existing (imported) material from your CAD or BIM model to use this shader, so that it is applied throughout the scene at once.</p></li></ol></div><p>In the following screenshot, the example on the left uses the basic <span class="strong"><strong>Glass</strong></span> shader (for which we did not show the code), whereas the <span class="strong"><strong>Glass Reflective</strong></span> example to the right adds <span class="strong"><strong>Reflection CubeMap</strong></span> (for example, one <a id="id347" class="indexterm"></a>of the Sky maps from the Skybox package).</p><div class="mediaobject"><img src="/graphics/9781783559060/graphics/7500EN_06_04.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p>Beware that the example uses a single plane object, which can only be seen from the front side. If you need the effect from both directions, add back-faces.</p></div><p>The preceding example works fine, but for more complex reflective glass, you need a pro-license, which performs a separate rendering pass from the camera and projects the mirrored scene onto the material at the cost of longer rendering times.</p></div></div>