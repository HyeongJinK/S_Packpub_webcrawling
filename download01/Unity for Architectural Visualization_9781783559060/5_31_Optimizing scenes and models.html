<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec33"></a>Optimizing scenes and models</h2></div></div><hr /></div><p>While the performance of Unity running on current generation computers and handheld devices is still increasing, there are <a id="id294" class="indexterm"></a>limitations to the amount of geometry you can place in an interactive scene. Especially trees, cars, curved models, and other objects with many polygons slow down Unity, sometimes dramatically. The following screenshot shows how to activate the <span class="strong"><strong>Stats</strong></span> button on the <span class="strong"><strong>Game</strong></span> view, which gives some insight in how much work Unity has to do.</p><div class="mediaobject"><img src="/graphics/9781783559060/graphics/7500EN_05_06.jpg" /></div><p>We try to reach at least 30 <span class="strong"><strong>frames per second</strong></span> (<span class="strong"><strong>FPS</strong></span>)<a id="id295" class="indexterm"></a> for smooth display. In practice, we hope to attain 60 or more and drop down to 30 as a worst-case scenario. However, don't be too fixated on this number, as it is not an exact prediction of how the application itself will run, for example, on a tablet or in the Web Player. The Unity Wiki provides a utility script for that purpose. For more information on FPS visit: <a class="ulink" href="http://wiki.unity3d.com/index.php?title=FramesPerSecond" target="_blank">http://wiki.unity3d.com/index.php?title=FramesPerSecond</a>.</p><p>Luckily, Unity itself does some optimization automatically. The Unity documentation provides some pointers to optimize performance. This documentation can be found at <a class="ulink" href="http://docs.unity3d.com/Documentation/Manual/OptimizingGraphicsPerformance.html" target="_blank">http://docs.unity3d.com/Documentation/Manual/OptimizingGraphicsPerformance.html</a>, and you can go through some of the techniques, which help you getting Unity running smoothly (or less jaggy, at least). If you have a pro-license, the <span class="strong"><strong>Profiler</strong></span> module gives a very detailed insight into <a id="id296" class="indexterm"></a>the performance and possible bottlenecks.</p><p>While many of these optimizations are optional, whenever you target mobile users, or not this can mean the difference between success and failure.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec26"></a>Showing only what is needed</h3></div></div></div><p>If you look directly to a forest, Unity needs to display all the trees, branches, and leaves. If you turn your head, there is no need to draw anything. Unity automatically applies so called <span class="strong"><strong>Frustum Culling</strong></span>
<a id="id297" class="indexterm"></a>, which omits any object that falls outside the viewing <a id="id298" class="indexterm"></a>frustum (a truncated pyramidal cone) of the camera. However, even if you see only a small fragment of a large object, it will be calculated as long as it is on screen. Frustum Culling happens for the whole object at once. It is therefore best to split and re-organize your model so any geometry that falls off screen can be omitted.</p><p>That said, the effort of preparing the display of several smaller objects could be significant. So avoiding geometry is a two-fold effort. Split your scene in multiple objects that can be culled automatically, but group nearby objects that are to be visible together.</p><p>Avoid loading model geometry that is never shown. If you run through a building, but only the lobby and a meeting room is open for visitors, there is no need to include other rooms, furniture, and installation systems. There is a reason why old games have loading screens and you often switch levels when you enter a building. It is possible to have one scene with only the exterior and the main building as merely a shell. When you enter the building, a script could unload the exterior and load the interior of that particular building. Clever use of fake geometry, such as pictures behind open windows, could be enough to get the feeling you are still in a larger environment.</p><p>The same technique can also be used to display design alternatives. There are a few approaches you can follow. You can decide to make each alternative a separate level. This is easy to set up, requires only minimal scripting (basically a one-liner call to <code class="literal">Application.LoadLevel(string levelName)</code>) and is by default optimized per scene. If you want to load alternatives on and off, you can decide on toggling visibilities, again using a simple script, or use an asynchronous loading of scenes, for example, load the content of one scene, while retaining the basics from your current scene, such as player and terrain.</p><p>The <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Full Control with Scripting</em></span>, will show you how to handle such tasks more easily.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec27"></a>Grouping objects by material</h3></div></div></div><p>Whenever an object has to be drawn on the screen, it needs to be processed and translated into pixels. In any <a id="id299" class="indexterm"></a>graphics engine, the system is switching all the<a id="id300" class="indexterm"></a> time between different states. First you load a <a id="id301" class="indexterm"></a>particular material and then you display geometry that gets this material applied. The more you need to switch, the more time it takes. Each separate material requires an additional draw call. So, combining objects that have the same material will speed up the display.</p><p>However, this might counter the effect we tried to get by splitting up the model into smaller pieces to be culled. Having many materials and using large objects will increase the amount of required Draw Calls, sometimes dramatically.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec28"></a>Using Prefabs (instancing)</h3></div></div></div><p>If objects are <a id="id302" class="indexterm"></a>repeated, instancing increases productivity and ease of scene<a id="id303" class="indexterm"></a> organization. For example, if a model inside SketchUp is created using <span class="strong"><strong>Components</strong></span> instead of <span class="strong"><strong>Groups</strong></span>, they arrive as real instances, sharing meshes between instances, which can decrease the demand on the system. Having multiple copies of the geometry in a single file is more demanding than having multiple instances of the same, shared geometry.</p><p>In Unity, instances <a id="id304" class="indexterm"></a>are called <span class="strong"><strong>Prefabs</strong></span> and they can be created from any group of <span class="strong"><strong>GameObjects</strong></span> that are placed in the scene. You create a new <span class="strong"><strong>Prefab</strong></span> in the <span class="strong"><strong>Project</strong></span> tab and drag a single <span class="strong"><strong>GameObject</strong></span> onto it. If you need more objects, place them underneath an empty <span class="strong"><strong>GameObject</strong></span> first. Prefabs are indicated by a blue name, instead of the<a id="id305" class="indexterm"></a> default black one. They retain their scripts and other components as well.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>One behavior of Prefabs that might not be that obvious is that even though they share their definition, they can have their attributes set individually.</p></li><li style="list-style-type: disc"><p>A second characteristic is that Prefabs are stored as assets in the <code class="literal">Project</code> folder, which makes them easily re-usable across scenes. Should you want to transfer them to other projects, copy the assets or export them as a Package.</p></li></ul></div><p>Luckily, every external model that is loaded is already a Prefab.</p><p>That said, the use of Prefabs will not reduce the effort of displaying them on screen: the same amount of geometry and materials takes the same amount of graphics processing, Prefabs or not. But do <a id="id306" class="indexterm"></a>use the technique, as it will improve <a id="id307" class="indexterm"></a>project organization and handling changes.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec29"></a>Using Levels of Detail (LOD)</h3></div></div></div><p>This is a Pro Only feature, which allows automatic switching<a id="id308" class="indexterm"></a> between<a id="id309" class="indexterm"></a> different versions of a mesh, depending on the <a id="id310" class="indexterm"></a>distance from the camera. While convenient, most CAD or BIM models are not created several times. However, with BIM software, you can create Views for different scale levels and switch between them in your project. You can get more<a id="id311" class="indexterm"></a> information on LOD at: <a class="ulink" href="http://docs.unity3d.com/Documentation/Manual/LevelOfDetail.html" target="_blank">http://docs.unity3d.com/Documentation/Manual/LevelOfDetail.html</a>.</p><p>If you don't have a pro-license, you could write a small script that calculates the distance from the Main Camera and accordingly hides or displays different versions of a model.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec30"></a>Culling and Batching</h3></div></div></div><p>The objects that fall outside of the camera's viewing frustum are automatically skipped (Culling), as <a id="id312" class="indexterm"></a>they are not visible for the user. Unity Pro provides the <span class="strong"><strong>Occlusion Culling</strong></span> module, which is an additional step to indicate which objects are seen and which can be <a id="id313" class="indexterm"></a>safely hidden. This requires an additional <span class="strong"><strong>Occlusion Culling</strong></span> bake<a id="id314" class="indexterm"></a> step.</p><p>So what is Batching? As an <a id="id315" class="indexterm"></a>automatic aid to increase and optimize performance, Unity shifts your scene around at runtime, trying to call more objects in a single draw call, without any user interference. This occurs at runtime, after the visibility or culling <a id="id316" class="indexterm"></a>calculations. There are two types of batching:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Dynamic batching</strong></span>: It is <a id="id317" class="indexterm"></a>used for moving objects<a id="id318" class="indexterm"></a> that use the same material and are not affected by real-time shadows. This is automatic.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Static batching</strong></span>: It is <a id="id319" class="indexterm"></a>only available in Unity Pro and <a id="id320" class="indexterm"></a>increases the efficiency of mesh rendering, by grouping meshes by material and other properties, to minimize draw calls. This is steered by indicating objects with the static attribute, just like we did when <span class="strong"><strong>Lightmapping</strong></span> in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Let There be Light</em></span>. No further intervention is required, but the effect is ignored in Unity Free.</p></li></ul></div><p>You can get<a id="id321" class="indexterm"></a> more information on Draw Call Batching at: <a class="ulink" href="http://docs.unity3d.com/Documentation/Manual/DrawCallBatching.html" target="_blank">http://docs.unity3d.com/Documentation/Manual/DrawCallBatching.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec31"></a>Combining Meshes/Children</h3></div></div></div><p>Remember the discussion in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Quick Walk Around Your Design</em></span>, about a feature inside CINEMA 4D to reorganize the scene? Something similar is available inside Unity, called <code class="literal">CombineMeshes</code>, which groups geometry according to the used material. However, while<a id="id322" class="indexterm"></a> this can indeed reduce draw calls, it can cause new <a id="id323" class="indexterm"></a>problems, when approaching the limit of about 65.000 vertices per object and also because frustum calling is not as effective anymore with such large objects.</p><p>The <code class="literal">CombineMeshes</code> tool is available from a script that can be installed from the <span class="strong"><strong>Scripts</strong></span> Package (<span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Import Package</strong></span> | <span class="strong"><strong>Scripts</strong></span>). Ensure that you load both <span class="strong"><strong>Combine Children</strong></span> and <span class="strong"><strong>Mesh CombineUtility</strong></span> from the <code class="literal">Utility Scripts</code> folder. These scripts are an alternative to the static batching optimization technique and work without a pro-license!</p><p>Select the object in the scene you want to optimize and call the script from the menu (<span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Mesh</strong></span> | <span class="strong"><strong>Combine Children</strong></span>), which adds the script to the selected object. Nothing appears to happen, until the moment you click on play. The effect is only available at runtime! If you check the <span class="strong"><strong>Hierarchy</strong></span> tab, shown in the following screenshot, your original model is reorganized by merging all geometry that was assigned the same material. You see a combined mesh per material with the original mesh renderers toggled off. When you stop execution of the game, everything turns back to normal.</p><div class="mediaobject"><img src="/graphics/9781783559060/graphics/7500EN_05_07.jpg" /></div><p>An improved version of this script, called <code class="literal">CombineChildren_962.cs</code> can be downloaded from the Unity forum: <a class="ulink" href="http://forum.unity3d.com/threads/37721-Combine-Children-Extented-(sources-to-share)" target="_blank">http://forum.unity3d.com/threads/37721-Combine-Children-Extented-(sources-to-share)</a>. Rename it as <code class="literal">CombineChildren.cs</code> and remove the original one, before you can use it. This script exposes additional parameters and is more optimized.</p><p>There are some limitations with this approach, however. It takes additional computation at the start of your game and if you try to combine this script with <span class="strong"><strong>Lightmapping</strong></span>, it fails. When the meshes <a id="id324" class="indexterm"></a>are reorganized at runtime, the second layer of UV2 maps<a id="id325" class="indexterm"></a> is not correctly recalculated. So while you might assume that the light maps were baked correctly inside the editor, they are removed again at runtime. In a discussion with one of our former students, <span class="emphasis"><em>Thomas Van Bouwel</em></span> (<a class="ulink" href="http://tvb-design.com" target="_blank">http://tvb-design.com</a>), he showed us a slightly adapted version of this script (available with this book), which recalculates the UV2 coordinates using <code class="literal">Unwrapping.GenerateSecondaryUVSet(...)</code>.</p><p>How does it work? Add the script to your parent object. By default, the script acts at runtime. This is fine as long as you don't need Lightmapping. Otherwise, right-click on the component and call the <span class="strong"><strong>Combine Now</strong></span> context menu. This performs the combining directly inside the editor. This is also useful to inspect what the script would do at runtime. You can always revert back to the original model, as loaded models are prefabs. Remember to remove the script or at least disable it, so the UV2 generation is not called again in your final build. Otherwise, the lightmaps will not fit the model anymore.</p><p>We performed a few tests on the ArchiCAD model in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Quick Walk Around Your Design</em></span>. It has 55.000 triangles and 71.200 vertices, which is not that much. FPS seems to fluctuate considerably in the Unity editor and the only real performance is what you get in an application running on a particular device. In general, we can see the following effects:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The original model required 72 draw calls and 1070 additional ones that were saved by automatic batching. We reached a comfortable 130 FPS.</p></li><li style="list-style-type: disc"><p>Static batching lowered the amount of calls to 41 at 220 FPS. Use it if you have Unity Pro, as the effect is imminent.</p></li><li style="list-style-type: disc"><p>The <code class="literal">CombineChildren</code> scripts (original and adapted) reduce this to 37 calls (no batching), at about 94 FPS.</p></li><li style="list-style-type: disc"><p>After using the script in the editor (<code class="literal">Combine Now</code>), <span class="strong"><strong>Lightmapping</strong></span> on the generated meshes results in the same amount of draw calls, but increased FPS (back to about 130) and made the shadows visible.</p></li><li style="list-style-type: disc"><p>In comparison, adding real-time hard shadows has a huge impact. When added to the original model, we need more than 3500 calls without batching and 2500 calls with batching enabled. The amount of geometry that is getting calculated as a result of adding shadows increased as well, to 174.000 triangles and 228.000 vertices. We hardly reached 40 FPS.</p></li></ul></div><p>Your mileage may vary, as such optimization is highly dependent on the scene, but we have at least a few <a id="id326" class="indexterm"></a>operations that we can apply on the model to increase <a id="id327" class="indexterm"></a>performance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec32"></a>Combining materials (texture atlas)</h3></div></div></div><p>An additional optimization, which can further increase performance and one which is used widely in game<a id="id328" class="indexterm"></a> authoring, is creating a texture atlas. Instead of using many <a id="id329" class="indexterm"></a>different texture maps, they are combined in one or more assembly maps. This requires setting up the geometry with suitable texture coordinates. While it looks similar to Lightmapping at first sight, there is a huge difference: each part of the combined texture can be used repeatedly on different objects.</p><p>While most architectural models do not apply this technique, it can be partly automated. Read about it in the discussion of the <span class="emphasis"><em>Bob script</em></span>, which is slightly dated but freely available from <a class="ulink" href="http://forum.unity3d.com/threads/88604-One-draw-call-for-each-shader-with-dynamic-meshes-The-Bob-script" target="_blank">http://forum.unity3d.com/threads/88604-One-draw-call-for-each-shader-with-dynamic-meshes-The-Bob-script</a>. The author improved this afterwards and it is now available from the <span class="strong"><strong>Asset Store</strong></span> as the <span class="strong"><strong>Batching Tools</strong></span>: <a class="ulink" href="http://ippomed.com/unity/batching-tools-draw-call-batching-for-unity-3d/" target="_blank">http://ippomed.com/unity/batching-tools-draw-call-batching-for-unity-3d/</a> and <a class="ulink" href="http://forum.unity3d.com/threads/113508-Batching-Tools" target="_blank">http://forum.unity3d.com/threads/113508-Batching-Tools</a>.</p><p>An alternative system, also on the <span class="strong"><strong>Asset Store</strong></span>, is the <span class="strong"><strong>Mesh Baker</strong></span> package that helps to combine meshes and material. The creation of texture atlases is included as well in this package (<a class="ulink" href="https://www.assetstore.unity3d.com/#/content/5017" target="_blank">https://www.assetstore.unity3d.com/#/content/5017</a>).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec33"></a>Avoiding excessive collision geometry</h3></div></div></div><p>You might remember <a id="id330" class="indexterm"></a>when we imported FBX models in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Quick Walk Around Your Design</em></span>, that we activated the <span class="strong"><strong>Generate Colliders</strong></span> option in the FBXImporter Settings. A <span class="strong"><strong>Mesh Collider</strong></span>
<a id="id331" class="indexterm"></a> is actually a copy of the geometry to be used for collision detection. This is fine and <a id="id332" class="indexterm"></a>really handy, but it introduces some additional processing at runtime. Whenever the character is walking around or objects are being moved with the physics system, collisions are being calculated. This comes at a performance cost.</p><p>The first and obvious solution is disabling the <span class="strong"><strong>Mesh Collider</strong></span> objects that you will not access, for example, the walls on the third floor for a closed building, the rooftops, and the surrounding buildings on other sites.</p><p>However, you need them on all objects on which you allow the character to walk. To increase performance, you could replace the <span class="strong"><strong>Mesh Collider</strong></span> with a more simple shape. The <span class="strong"><strong>Box</strong></span>, <span class="strong"><strong>Sphere</strong></span>, and <span class="strong"><strong>Capsule Colliders</strong></span> are much easier, as they are convex, rather than concave objects, and have fewer triangles to calculate.</p><p>Other examples are replacing a set of chairs and table with a single box, or replacing trees, plants, traffic signs, lamp posts, and other small objects with <span class="strong"><strong>Capsules</strong></span>.</p><p>There are no <a id="id333" class="indexterm"></a>real shortcuts here, but <a id="id334" class="indexterm"></a>to dive in and painstakingly replace whatever geometry that can be simplified with these colliders. Remember that the meshes themselves stay visible, but the simplified colliders are used for physics and collision calculations.</p></div></div>