<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec15"></a>Custom Character Controller</h2></div></div><hr /></div><a id="id139" class="indexterm"></a><p>In this section, we will write a script that will take control of basic character manipulations. It will register a player's input and translate it into movement. We will talk about <span class="strong"><strong>vectors</strong></span> and <span class="strong"><strong>vector</strong></span> <span class="strong"><strong>arithmetic</strong></span>, try out <span class="strong"><strong>raycasting</strong></span>, make a character obey our controls and see different ways to register input, describe the purpose of the <code class="literal">FixedUpdate</code> function<a id="id140" class="indexterm"></a>, and learn to control <span class="strong"><strong>Rigidbody</strong></span>.</p><p>We shall start with teaching our character to walk in all directions, but before we start coding, there is a bit of theory that we need to know behind character movement.</p><p>Most game engines, if not all, use vectors to control the movement of objects. Vectors simply represent direction and magnitude, and they are usually used to define an object's position (specifically its <span class="strong"><strong>pivot</strong></span> <span class="strong"><strong>point</strong></span><a id="id141" class="indexterm"></a>) in a 3D space. Vector is a structure that consists of three variables—X, Y, and Z. In Unity, this structure is called <span class="strong"><strong>Vector3</strong></span><a id="id142" class="indexterm"></a>, but we have encountered <a id="id143" class="indexterm"></a>this variable type before in a previous chapter:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_02.jpg" /></div><p>To make the object move, knowing its vector is not enough.</p><p>Length of vectors is known as <span class="strong"><strong>magnitude</strong></span><a id="id144" class="indexterm"></a>. In physics, speed is a pure scalar, or something with a magnitude but no direction. To give an object a direction, we use vectors. Greater magnitude means greater speed. By controlling vectors and magnitude, we can easily change our direction or increase speed at any time we want.</p><p>Vectors are very important to understand if we want to create any movement in a game. Through the examples in this chapter, we will explain some basic vector manipulations and describe their influence on the character. It is recommended that you learn extra material about vectors to be able to perfect a Character Controller based on game needs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec14"></a>Setting up the project</h3></div></div></div><a id="id145" class="indexterm"></a><p>To start this section, we need an example scene. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select <span class="strong"><strong>Chapter</strong></span> <span class="strong"><strong>2</strong></span> folder from book assets, and click on on the <span class="strong"><strong>Unity_chapter2</strong></span> scene inside the <span class="strong"><strong>custom_scene</strong></span> folder.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_03.jpg" /></div></li><li><p>In the  <span class="strong"><strong>Custom</strong></span> <span class="strong"><strong>scripts</strong></span> folder<a id="id146" class="indexterm"></a>, create a new JavaScript file. Call it <span class="strong"><strong>CH_Controller</strong></span> (we will reference this script in the future, so try to remember <a id="id147" class="indexterm"></a>its name, if you choose a different one):</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_04.jpg" /></div></li><li><p>In a <span class="strong"><strong>Hierarchy</strong></span> view<a id="id148" class="indexterm"></a>, click on the object called <span class="strong"><strong>robot</strong></span>. Translate the mouse to a <span class="strong"><strong>Scene</strong></span> view and press <span class="emphasis"><em>F</em></span>; the camera will focus on a funny looking <a id="id149" class="indexterm"></a>character that we will teach to walk, run, jump, and behave as a character from a video game.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Creating movement</h3></div></div></div><a id="id150" class="indexterm"></a><p>The following is the theory of what needs to be done to make a character move:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Register a player's input.</p></li><li><p>Store information into a vector variable.</p></li><li><p>Use it to move a character.</p></li></ol></div><p>Sounds like a simple task, doesn't it? However, when it comes to moving a player-controlled character, there are a lot of things that we need to keep in mind, such as vector manipulation, registering input from the user, raycasting, Character Controller component manipulation, and so on. All these things are simple on their own, but when it comes to putting them all together, they might bring a few problems. To make sure that none of these problems will catch us by surprise, we will go through each of them step by step.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec07"></a>Manipulating character vector</h4></div></div></div><a id="id151" class="indexterm"></a><a id="id152" class="indexterm"></a><a id="id153" class="indexterm"></a><p>By receiving input from the player, we will be able to manipulate character movement. The following is the list of actions that we need to perform in Unity:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the <span class="strong"><strong>CH_Character</strong></span> script.</p></li><li><p>Declare <code class="literal">public</code> variables <code class="literal">Speed</code> and <code class="literal">MoveDirection</code> of types <code class="literal">float</code> and <code class="literal">Vector3</code> respectively. <code class="literal">Speed</code> is self-explanatory, it will determine at which speed our character will be moving. <code class="literal">MoveDirection</code> is a vector that will contain information about the direction in which our character will be moving.</p></li><li><p>Declare a new function called <code class="literal">Movement</code>. It will be checking horizontal and vertical inputs from the player.</p></li><li><p>Finally, we will use this information and apply movement to the character.</p><p>An example of the code is as follows:</p><div class="informalexample"><pre class="programlisting">public var Speed : float = 5.0;
public var MoveDirection : Vector3 = Vector3.zero;
function Movement (){
if (Input.GetAxis("Horizontal") || Input.GetAxis("Vertical"))
MoveDirection = Vector3(Input.GetAxisRaw("Horizontal"),MoveDirection.y, Input.GetAxisRaw("Vertical"));
this.transform.Translate(MoveDirection);
}</pre></div><a id="id154" class="indexterm"></a><a id="id155" class="indexterm"></a><a id="id156" class="indexterm"></a></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec08"></a>Register input from the user</h4></div></div></div><a id="id157" class="indexterm"></a><a id="id158" class="indexterm"></a><p>In order to move the character, we need to register an input from the user. To do that, we will use the <code class="literal">Input.GetAxis</code> function. It registers input and returns values from -1 to 1 from the keyboard and joystick. <code class="literal">Input.GetAxis</code><a id="id159" class="indexterm"></a> can only register input that had been defined by passing a string parameter to it. To find out which options are available, we will go to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Projectsettings</strong></span> | <span class="strong"><strong>Input</strong></span>. In the <span class="strong"><strong>Inspector</strong></span> view, we will see <span class="strong"><strong>Input</strong></span> <span class="strong"><strong>Manager</strong></span>.</p><p>Click on the <span class="strong"><strong>Axes</strong></span> drop-down menu and you will be able to see all available input information that can be passed to the <code class="literal">Input.GetAxis</code> function. Alternatively, we can use <code class="literal">Input.GetAxisRaw</code>. The only difference is that we aren't using Unity's built-in smoothing and processing data as it is, which allows us to have greater control over character movement.</p><p>To create your own input axes, simply increase the size of the array by 1 and specify your preferences (later we will look into a better way of doing and registering input for different buttons).</p><a id="id160" class="indexterm"></a><p><code class="literal">this.transform</code> is an access to transformation of this particular object. <span class="strong"><strong>transform</strong></span> contains all the information about translation, rotation, scale, and children of this object (object parenting will be covered in later chapters of this book). <code class="literal">Translate</code> is a function inside Unity that translates <span class="strong"><strong>GameObject</strong></span> to a specific direction based on a given vector.</p><p>If we simply leave it as it is, our character will move with the speed of light. That happens because translation is being applied on character every frame. Relying on frame rate when dealing with translation is very risky, and as each computer has different processing power, execution of our function will vary based on performance. To solve this problem, we will tell it to apply movement based on a common factor—time:</p><div class="informalexample"><pre class="programlisting">this.transform.Translate(MoveDirection * Time.deltaTime);</pre></div><p>This will make our character move one Unity unit every second, which is still a bit too slow. Therefore, we will multiply our movement speed by the <code class="literal">Speed</code> variable:</p><div class="informalexample"><pre class="programlisting">this.transform.Translate((MoveDirection * Speed) * Time.deltaTime);</pre></div><p>Now, when the <code class="literal">Movement</code> function is written, we need to call it from <code class="literal">Update</code>. A word of warning though—controlling <span class="strong"><strong>GameObject</strong></span> or <span class="strong"><strong>Rigidbody</strong></span> from the usual <code class="literal">Update</code> function is not recommended since, as mentioned previously, that frame rate is unreliable. Thankfully, there is a <code class="literal">FixedUpdate</code> function<a id="id161" class="indexterm"></a> that will help us by applying movement at every fixed frame. Simply change the <code class="literal">Update</code> function<a id="id162" class="indexterm"></a> to <code class="literal">FixedUpdate</code> and call the <code class="literal">Movement</code> function<a id="id163" class="indexterm"></a> from there:</p><div class="informalexample"><pre class="programlisting">function FixedUpdate (){
Movement();
}<a id="id164" class="indexterm"></a><a id="id165" class="indexterm"></a>
</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec09"></a>The Rigidbody component</h4></div></div></div><a id="id166" class="indexterm"></a><a id="id167" class="indexterm"></a><p>Now, when our character is moving, take a closer look at the <span class="strong"><strong>Rigidbody</strong></span> component that we have attached to it. Under the <span class="strong"><strong>Constraints</strong></span> drop-down menu, we will notice that <span class="strong"><strong>Freeze</strong></span> <span class="strong"><strong>Rotation</strong></span> for <span class="strong"><strong>X</strong></span> and <span class="strong"><strong>Z</strong></span> axes is checked, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_05.jpg" /></div><p>If we uncheck those boxes and try to move our character, we will notice that it starts to fall in the direction of the movement. Why is this happening? Well, remember, we talked about <span class="strong"><strong>Rigidbody</strong></span> being affected by physics laws in the engine? That applies to friction as well. To avoid force of friction affecting our character, we forced it to avoid rotation along all axes but <span class="strong"><strong>Y</strong></span>. We will use the <span class="strong"><strong>Y</strong></span> axis to rotate our character from left to right in the future.</p><p>Another problem that we will see when moving our character around is a significant increase in speed when walking in a diagonal direction. This is not an unusual bug, but an expected behavior of the <code class="literal">MoveDirection</code> vector. That happens because for directional movement we use vertical and horizontal vectors. As a result, we have a vector that inherits magnitude from both, in other words, its magnitude is equal to the sum of vertical and horizontal vectors.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_06.jpg" /></div><p>To prevent that from happening, we need to set the magnitude of the new vector to 1. This operation is called <span class="strong"><strong>vector</strong></span> <span class="strong"><strong>normalization</strong></span><a id="id168" class="indexterm"></a>. With normalization and speed multiplier, we <a id="id169" class="indexterm"></a><a id="id170" class="indexterm"></a>can always make sure to control our magnitude:</p><div class="informalexample"><pre class="programlisting">this.transform.Translate((MoveDirection.normalized * Speed) * Time.deltaTime);</pre></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>Jumping</h3></div></div></div><a id="id171" class="indexterm"></a><a id="id172" class="indexterm"></a><p>Jumping is not as hard as it seems. Thanks to <span class="strong"><strong>Rigidbody</strong></span>, our character is already affected by gravity, so the only thing we need to do is to send it up in the air. Jump force is different from the speed that we applied to movement. To make a decent jump, we need to set it to 500.0). For this specific example, we don't want our character to be controllable in the air (as in real life, that is physically impossible). Instead, we will make sure that he preserves transition velocity when jumping, to be able to jump in different directions. But, for now, let's limit our movement in air by declaring a separate vector for jumping.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec10"></a>User input verification</h4></div></div></div><a id="id173" class="indexterm"></a><a id="id174" class="indexterm"></a><p>In order to make a jump, we need to be sure that we are on the ground and not floating in the air. To check that, we will declare three variables—<code class="literal">IsGrounded</code>, <code class="literal">Jumping</code>, and <code class="literal">inAir</code>—of a type <code class="literal">boolean</code>. <code class="literal">IsGrounded</code> will check if we are grounded. <code class="literal">Jumping</code> will determine if we pressed the jump button to perform a jump. <code class="literal">inAir</code> will help us to deal with a jump if we jumped off the platform without pressing the jump button. In this case, we don't want our character to fly with the same speed as he walks; we need to add an <code class="literal">airControl</code> variable<a id="id175" class="indexterm"></a> that will smooth our fall.</p><p>Just as we did with movement, we need to register if the player pressed a jump button. To achieve this, we will perform a check right after registering <code class="literal">Vertical</code> and <code class="literal">Horizontal</code> inputs:</p><div class="informalexample"><pre class="programlisting">public var jumpSpeed : float = 500.0;
public var jumpDirection : Vector3 = Vector3.zero;
public var IsGrounded : boolean = false;
public var Jumping : boolean = false;
public var inAir : boolean = false;
public var airControl : float = 0.5;
function Movement(){
if (Input.GetAxis("Horizontal") || Input.GetAxis("Vertical")) {
MoveDirection = Vector3(Input.GetAxisRaw("Horizontal"),MoveDirection.y,Input.GetAxisRaw("Vertical"));
}
if (Input.GetButtonDown("Jump") &amp;&amp; isGrounded) {}
}</pre></div><p><code class="literal">GetButtonDown</code>
<a id="id176" class="indexterm"></a> determines if we pressed a specific button (in this case, <span class="emphasis"><em>Space bar</em></span>), as specified in <span class="strong"><strong>Input</strong></span> <span class="strong"><strong>Manager</strong></span>. We also need to check if our character is grounded to make a jump.</p><a id="id177" class="indexterm"></a><p>We will apply vertical force to a <code class="literal">rigidbody</code> by using the <code class="literal">AddForce</code> function<a id="id178" class="indexterm"></a> that takes the vector as a parameter and pushes a <code class="literal">rigidbody</code> in the specified direction. We will also toggle <code class="literal">Jumping</code> <code class="literal">boolean</code> to <code class="literal">true</code>, as we pressed the jump button and preserve velocity with <code class="literal">JumpDirection</code>:</p><div class="informalexample"><pre class="programlisting">if (Input.GetButtonDown("Jump") &amp;&amp;isGrounded){
Jumping = true;    
jumpDirection = MoveDirection;
rigidbody.AddForce((transform.up) * jumpSpeed);
}
if (isGrounded)
this.transform.Translate((MoveDirection.normalized * Speed) * Time.deltaTime);
else if (Jumping || inAir)
this.transform.Translate((jumpDirection * Speed * airControl) * Time.deltaTime);</pre></div><p>To make sure that our character doesn't float in space, we need to restrict its movement and apply translation with <code class="literal">MoveDirection</code> only, when our character is on the ground, or else we will use <code class="literal">jumpDirection</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec11"></a>Raycasting</h4></div></div></div><a id="id179" class="indexterm"></a><a id="id180" class="indexterm"></a><p>The jumping functionality is almost written; we now need to determine whether our character is grounded. The easiest way to check that is to apply <span class="strong"><strong>raycasting</strong></span>. Raycasting simply casts a ray in a specified direction and length, and returns if it hits any collider on its way (a collider of the object that the ray had been cast from is ignored):</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_07.jpg" /></div><p>To perform a raycast, we will need to specify a starting position, direction (vector), and length of the ray. In return, we will receive <code class="literal">true</code>, if the ray hits something, or <code class="literal">false</code>, if it doesn't:</p><div class="informalexample"><pre class="programlisting">function FixedUpdate ()
{
if (Physics.Raycast(transform.position, -transform.up, collider.height/2 + 2)){
    isGrounded = true;
    Jumping = false;
    inAir = false;
}
else if (!inAir){
    inAir = true;
    JumpDirection = MoveDirection;
}
Movement();
}</pre></div><p>As we have already mentioned, we used <code class="literal">transform.position</code> to specify the starting position of the ray as a center of our collider. <code class="literal">-transform.up</code> is a vector that is pointing downwards and <code class="literal">collider.height</code> is the height of the attached collider. We are using half of the height, as the starting position is located in the middle of the collider and extended ray for two units, to make sure that our ray will hit the ground. The rest of the code is simply toggling state <a id="id181" class="indexterm"></a><a id="id182" class="indexterm"></a>booleans.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch02lvl4sec03"></a>Improving efficiency in raycasting</h5></div></div></div><a id="id183" class="indexterm"></a><a id="id184" class="indexterm"></a><p>But what if the ray didn't hit anything? That can happen in two cases—if we walk off the cliff or are performing a jump. In any case, we have to check for it.</p><p>If the ray didn't hit a collider, then obviously we are in the air and need to specify that. As this is our first check, we need to preserve our current velocity to ensure that our character doesn't drop down instantly.</p><p>Raycasting is a very handy thing and being used in many games. However, you should not rely on it too often. It is very expensive and can dramatically drop down your frame rate.</p><p>Right now, we are casting rays every frame, which is extremely inefficient. To improve our performance, we only need to cast rays when performing a jump, but never when grounded. To ensure this, we will put all our raycasting section in <code class="literal">FixedUpdate</code> to fire when the character is not grounded.</p><div class="informalexample"><pre class="programlisting">function FixedUpdate (){
    if (!isGrounded){
        if (Physics.Raycast(transform.position, -transform.up, collider.height/2 + 0.2)){
            isGrounded = true;
            Jumping = false;
            inAir = false;
         }
        else if (!inAir){
            inAir = true;
            jumpDirection = MoveDirection;
         } 
     }  
Movement();
}
function OnCollisionExit(collisionInfo : Collision){
    isGrounded = false;
}</pre></div><p>To determine if our character is not on the ground, we will use a default function—<code class="literal">OnCollisionExit()</code>
<a id="id185" class="indexterm"></a>. Unlike <code class="literal">OnControllerColliderHit()</code>
<a id="id186" class="indexterm"></a>, which had been used with <a id="id187" class="indexterm"></a><a id="id188" class="indexterm"></a>Character Controller, this function is only for colliders and rigidbodies. So, whenever our character is not touching any collider or rigidbody, we will expect to be in the air, therefore, not grounded.</p><p>Let's hit <span class="strong"><strong>Play</strong></span> and see our character jumping on our command.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec12"></a>Additional jump functionality</h4></div></div></div><a id="id189" class="indexterm"></a><p>Now that we have our character jumping, there are a few issues that should be resolved. First of all, if we decide to jump on the sharp edge of the platform, we will see that our collider penetrates other colliders. Thus, our collider ends up being stuck in the wall without a chance of getting out:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_08.jpg" /></div><p>A quick patch to this problem will be pushing the character away from the contact point while jumping. We will use the <code class="literal">OnCollisionStay()</code> function<a id="id190" class="indexterm"></a> that's called at every frame <a id="id191" class="indexterm"></a>when we are colliding with an object. This function receives collision contact information that can help us determine who we are colliding with, its velocity, name, if it has <span class="strong"><strong>Rigidbody</strong></span>, and so on. In our case we are interested in contact points. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Declare a new <code class="literal">private</code> variable <code class="literal">contact</code> of a <code class="literal">ContactPoint</code> type that describes the collision point of colliding objects.</p></li><li><p>Declare the <code class="literal">OnCollisonStay</code> function.</p></li><li><p>Inside this function, we will take the first point of contact with the collider and assign it to our <code class="literal">private</code> variable.</p></li><li><p>Add force to the contact position to reverse the character's velocity, but only if the character is not on the ground.</p></li><li><p>Declare a new variable and call it <code class="literal">jumpClimax</code> of <code class="literal">boolean</code> type.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note04"></a>Note</h3><p><span class="strong"><strong>Contacts</strong></span> is an array of all contact points.</p></div></li></ol></div><p>Finally, we need to move away from that contact point by reversing our velocity. The <code class="literal">AddForceAtPosition</code> functio<a id="id192" class="indexterm"></a>n will help us here. It is similar to the one that we used for jumping, however, this one applies force at a specified position (contact point):</p><div class="informalexample"><pre class="programlisting">public var jumpClimax :boolean = false;
...
function OnCollisionStay(collisionInfo : Collision){
contact = collisionInfo.contacts[0];
if (inAir || Jumping)
rigidbody.AddForceAtPosition(-rigidbody.velocity, contact.point);
}</pre></div><p>The next patch will aid us in the future, when we will be adding animation to our character later in this chapter. To make sure that our jumping animation runs smoothly, we need to know when our character reaches jumping climax, in other words, when it stops going up and start a falling.</p><a id="id193" class="indexterm"></a><p>In the <code class="literal">FixedUpdate</code> function<a id="id194" class="indexterm"></a>, right after the last <code class="literal">else</code> <code class="literal">if</code> statement, put the following code snippet:</p><div class="informalexample"><pre class="programlisting">else if (inAir&amp;&amp;rigidbody.velocity.y == 0.0) {
            jumpClimax = true;
         }</pre></div><p>Nothing complex here. In theory, the moment we stop going up is a climax of our jump, that's why we check if we are in the air (obviously we can't reach jump climax when on the ground), and if vertical velocity of <code class="literal">rigidbody</code> is 0. The last part is to set our jumping climax to <code class="literal">false</code>. We'll do that at the moment when we touch the ground:</p><div class="informalexample"><pre class="programlisting">if (Physics.Raycast(transform.position, -transform.up, collider.height/2 + 2)){
    isGrounded = true;
    Jumping = false;
    inAir = false;
    jumpClimax = false;
}</pre></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Running</h3></div></div></div><a id="id195" class="indexterm"></a><a id="id196" class="indexterm"></a><p>We taught our character to walk, jump, and stand aimlessly on the same spot. The next logical step will be to teach him running. From a technical point of view, there is nothing too hard. Running is simply the same thing as walking, but with a greater speed. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Declare a new variable <code class="literal">IsRunning</code> of a type <code class="literal">boolean</code>, which will be used to determine whether our character has been told to run or not.</p></li><li><p>Inside the <code class="literal">Movement</code> function<a id="id197" class="indexterm"></a>, at the very top, we will check if the player is pressing left or right, and shift and assign an appropriate value to <code class="literal">isRunning</code>:</p><div class="informalexample"><pre class="programlisting">public var isRunning : boolean = false; 
...
function Movement()
{
if (Input.GetKey (KeyCode.LeftShift) || Input.GetKey (KeyCode.RightShift))
    isRunning = true;
else
    isRunning = false;
...
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note05"></a>Note</h3><p>Another way to get input from the user is to use <code class="literal">KeyCode</code>. It is an enumeration for all physical keys on the keyboard. Look at the <code class="literal">KeyCode</code> script reference for a complete list of available keys, on the official website: <a class="ulink" href="http://unity3d.com/support/documentation/ScriptReference/KeyCode" target="_blank">http://unity3d.com/support/documentation/ScriptReference/KeyCode</a>.</p></div></li></ol></div><a id="id198" class="indexterm"></a><a id="id199" class="indexterm"></a><p>We will return to running later, in the animation section.</p></div></div>