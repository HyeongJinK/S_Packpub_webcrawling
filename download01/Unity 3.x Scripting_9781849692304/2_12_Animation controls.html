<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Animation controls</h2></div></div><hr /></div><a id="id263" class="indexterm"></a><p>In the last part of this chapter, we will talk about what makes games look awesome—<span class="strong"><strong>animations</strong></span>. We will learn how to control animations through code, learn the truth about the <code class="literal">Start</code> and <code class="literal">Awake</code> functions, and figure out how to make smooth transactions in between animations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"></a>Playing simple animations</h3></div></div></div><a id="id264" class="indexterm"></a><p>Time to add some visual indication to our movement and jump into the world of animations. Thankfully, we don't have to worry about animating our character, all animations are already done for us and are included with the model.</p><p>In this section, we will talk about basic animations and how to play them. As our game continues to grow, we will add more advanced techniques to handle various animations.</p><p>Let's create a new script whose main purpose will be to handle and control all animations for our character, such as their speed, play order, and modes. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new script in the <span class="strong"><strong>Custom</strong></span> <span class="strong"><strong>scripts</strong></span> folder and call it <span class="strong"><strong>CH_Animation</strong></span>.</p></li><li><p>Declare a <code class="literal">private</code> variable<a id="id265" class="indexterm"></a> of a <span class="strong"><strong>CH_Controller</strong></span> type (script that handles movement, if you name it differently, use your name to declare its type), call it <span class="strong"><strong>Controller</strong></span>. This way we can reference any scripts, just by declaring them with a type of script's name.</p></li><li><a id="id266" class="indexterm"></a><p>Declare two functions—<code class="literal">Start</code> and <code class="literal">Awake</code>:</p><div class="informalexample"><pre class="programlisting">private var Controller : CH_Controller;
function Start (){}
function Awake (){}</pre></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec23"></a>Start function versus Awake function</h4></div></div></div><a id="id267" class="indexterm"></a><a id="id268" class="indexterm"></a><a id="id269" class="indexterm"></a><p>Let's talk a bit about the difference between these two functions. At first glance, there is none, and many people make the same mistake by mismatching them. This is a mistake that can lead to problems.</p><p>The <code class="literal">Awake()</code> function<a id="id270" class="indexterm"></a> is the first function that is called when you start a game. Right after you press the <span class="strong"><strong>Play</strong></span> key, the engine goes through all scripts and executes the <code class="literal">Awake</code> function in each of them.</p><p>The <code class="literal">Start()</code> function<a id="id271" class="indexterm"></a> is called right after all the <code class="literal">Awake()</code> functions on all objects are executed.</p><p>We can give both these functions a small test. Let's test this:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add debug logs in both of these functions. In <code class="literal">Awake</code>, write something like <code class="literal">I'm</code> <code class="literal">awake</code> and <code class="literal">I'm</code> <code class="literal">ready</code> <code class="literal">to</code> <code class="literal">start</code> in the <code class="literal">Start</code> function:</p></li><li><p>Attach this script to our character and hit <span class="strong"><strong>Play</strong></span>. Double-click at the debug line at the bottom and look at what we got—<span class="strong"><strong>I'm</strong></span> <span class="strong"><strong>awake</strong></span> printed before <span class="strong"><strong>I'm</strong></span> <span class="strong"><strong>ready</strong></span> <span class="strong"><strong>to</strong></span> <span class="strong"><strong>start</strong></span> as planned:</p><div class="informalexample"><pre class="programlisting">function Start (){
Debug.Log("I'm ready to start");
}
function Awake (){
Debug.Log("I'm awake");
}</pre></div></li></ol></div><p>Your console messages should be similar to those displayed on the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_12.jpg" /></div><p>Remember, there is no order in which the engine calls the <code class="literal">awake</code> or <code class="literal">start</code> functions among the objects by default, it can randomly choose one or another and call it from there. Another interesting thing is that the <code class="literal">Start()</code> function won't be called if an object is disabled. In other words, if we disable an object in the <code class="literal">Awake()</code> function, we can save some performance for our game to run faster at start-up.</p><a id="id272" class="indexterm"></a><a id="id273" class="indexterm"></a><a id="id274" class="indexterm"></a><p>Using specifics of these functions we should be prepared to use <code class="literal">Awake()</code> for referencing objects, scripts, variables etc. Assigning default properties and start-up functionality is better in the <code class="literal">Start()</code> function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec24"></a>Animation component and playing speed</h4></div></div></div><a id="id275" class="indexterm"></a><a id="id276" class="indexterm"></a><p>We will use this script to control speed of animations and movement speed for the character; therefore, we need to declare the following variables to control them:</p><div class="informalexample"><pre class="programlisting">public var forwardSpeed : float = 5.0;
public var backwardSpeed : float = 3.0;
public var strafingSpeed : float = 4.0;
public var runningSpeed : float = 10.0;
public var idleAnimationSpeed : float = 1.0;
public var forwardAnimationSpeed : float = 6.0;
public var runningAnimationSpeed : float = 3.0;
public var backwardAnimationSpeed : float = 1.0;
public var strafingAnimationSpeed : float = 3.0;
public var jumpingAnimationSpeed : float = 1.5;</pre></div><p>Variables in the preceding code snippet will control movement speed for our character based on direction, animation, and animation speed.</p><a id="id277" class="indexterm"></a><a id="id278" class="indexterm"></a><p>Let's get back to animations:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Remove the debug logs from this script and reference <code class="literal">CH_Controller</code> from this object in the <code class="literal">Awake</code> function:</p><div class="informalexample"><pre class="programlisting">function Awake(){
    Controller = this.gameObject.GetComponent(CH_Controller);
}</pre></div></li><li><p>In order for the object to play animations, we need to attach an animation component to our character. Select character and go to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Miscellaneous</strong></span> | <span class="strong"><strong>Animation</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_13.jpg" /></div></li><li><p>Inside <span class="strong"><strong>Animation Controller</strong></span>, click on a small circle, it will lead you to the <span class="strong"><strong>Select</strong></span> <span class="strong"><strong>AnimationClip</strong></span> window. Click on any of the available animations.</p></li><li><p>Under the <span class="strong"><strong>Animations</strong></span> drop-down menu, increase the size to <span class="strong"><strong>4</strong></span> and assign a unique animation to each <span class="strong"><strong>Element</strong></span>.</p></li><li><p>Uncheck the <span class="strong"><strong>Play</strong></span> <span class="strong"><strong>Automatically</strong></span> box. We don't want Unity to play random animation for us; we will take care of it through the code:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_14.jpg" /></div></li></ol></div><p>All the animation manipulations will be done through <span class="strong"><strong>Animation Controller</strong></span>. The first thing that we need to learn about animations is <span class="strong"><strong>WrapMode</strong></span>. <code class="literal">WrapMode</code> controls the play of animation—or repeating, to be more precise. There are a number of repeating modes available in Unity. They are as follows:<a id="id279" class="indexterm"></a></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Once</strong></span>: It plays the animation once and stops</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Loop</strong></span>: It plays the animation over and over again until told to stop</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Ping-pong</strong></span>: It plays the animation till the end, then reverses and plays it backwards</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Default</strong></span>: It reads a default repeat mode set higher up</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>ClampForever</strong></span>: It will play the animation till the end and then continuously keeps playing its last frame</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note07"></a>Note</h3><p>We can specify <code class="literal">WrapMode</code> for all animations by referencing just an animation component or an individual animation, by specifying a name in square brackets:</p><p><code class="literal">animation.wrapMode = WrapMode.Loop;</code></p><p>or</p><p><code class="literal">animation["idle"].wrapMode = WrapMode.Loop;</code></p></div></li></ul></div><p>To play an animation, we simply call the <span class="strong"><strong>Play</strong></span> function with name of the animation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec25"></a>Animation scripting</h4></div></div></div><a id="id280" class="indexterm"></a><p>In this section, we will put information learned in the preceding section into action. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>When script initializes, we need to set <span class="strong"><strong>WrapMode</strong></span> to <span class="strong"><strong>looping</strong></span> by default.</p></li><li><p>Specify <span class="strong"><strong>ClampForever</strong></span> <span class="strong"><strong>WrapMode</strong></span> for <code class="literal">"jump"</code> animation.</p></li><li><p>Set speed for all known animations.</p></li><li><p>First animation to play should be <code class="literal">"idle"</code>.</p></li></ol></div><p>Put the following code snippet inside the <code class="literal">Start</code> function<a id="id281" class="indexterm"></a>:</p><div class="informalexample"><pre class="programlisting">function Start(){
animation.wrapMode = WrapMode.Loop;
animation["jump"].wrapMode = WrapMode.ClampForever;
animation["idle"].speed = idleAnimationSpeed;
animation["walk_forward"].speed = forwardAnimationSpeed;
animation["run"].speed = runningAnimationSpeed;
animation["walk_backward"].speed = backwardAnimationSpeed;
animation["walk_side"].speed = strafingAnimationSpeed;
animation["jump"].speed = jumpingAnimationSpeed;
animation.Play("idle");
}</pre></div><a id="id282" class="indexterm"></a><p>Now that we have that, it's about time to add animation to our character's jump. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new function and call it <code class="literal">DetermineDirection()</code>.</p></li><li><p>We will start with jumping animations; first, we need to determine if the character is in the air.</p></li><li><p>We will utilize <code class="literal">jumpClimax</code>, implemented earlier in this chapter, to check if the character reached a jump climax.</p></li><li><p>Call <code class="literal">DetermineDirection</code> function from <code class="literal">Update</code>:</p><div class="informalexample"><pre class="programlisting">function Update (){
DetermineDirection();
}
function DetermineDirection (){
if (Controller.inAir){ 
if(!Controller.jumpClimax) {}
}
}</pre></div></li></ol></div><p>Jump can be performed from any height, therefore, we have no idea how long animation should be played for. <span class="strong"><strong>ClampForever</strong></span>,<a id="id283" class="indexterm"></a> a loop playing the last frame of the animation, will help us here.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"></a>Note</h3><p><code class="literal">CrossFade</code> is used to blend in between animations. Blending is a very important aspect of animations, as it helps to create numerous transitions from one animation to another.</p></div><p>Imagine that there was no blending. Our character would be walking, then instantly changing animation to jumping, shooting, landing, and so on. That will look weird and hard-edged. If we want to make smooth transactions from one animation to another, from jumping to landing to walking, for instance, we will have to manually create numerous animations. Thankfully, Unity can blend in between animations for us, with the <code class="literal">CrossFade</code> function<a id="id284" class="indexterm"></a>. <code class="literal">Crossfade</code> interpolates one basic animation into another, creating more complex and unique animations for our character to play. We can even specify a speed of fading by adding an extra float parameter, like the following one:</p><div class="informalexample"><pre class="programlisting">animation.CrossFade("jump", 0.3);</pre></div><p><code class="literal">0.3</code> seconds is a default value.</p><p>We will now add this functionality to our jump, right after we checked if our character didn't reach climax:</p><div class="informalexample"><pre class="programlisting">if(!Controller.jumpClimax){
animation.CrossFade("jump", 0.5,PlayMode.StopSameLayer);
}</pre></div><p>But what if our character reached jump climax? To fix that, we need to do the same thing we did before climax, but reverse the animation with the <code class="literal">Rewind</code> function:</p><div class="informalexample"><pre class="programlisting">else{
animation.Rewind ("jump");
}</pre></div><a id="id285" class="indexterm"></a><p>The only difference is that, once a character reaches climax, we want to reverse the animation. We will give its speed a negative value to make it play backwards; the rest of it is the same as before.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_15.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec26"></a>Walk, run, and idle animations</h4></div></div></div><a id="id286" class="indexterm"></a><a id="id287" class="indexterm"></a><a id="id288" class="indexterm"></a><a id="id289" class="indexterm"></a><a id="id290" class="indexterm"></a><a id="id291" class="indexterm"></a><p>The rest of the animations are as simple as <code class="literal">jump</code> animation, so here we go.</p><p>If the character is not moving in any direction (stands on the same spot), he should be playing <code class="literal">idle</code> animation:</p><div class="informalexample"><pre class="programlisting">else if (Controller.MoveDirection == Vector3.zero){    
        animation.CrossFade("idle");    
    }</pre></div><p>This script goes after the first <code class="literal">if</code> statement, at the very top. To determine whether the character is moving or not, we used the <code class="literal">MoveDirection</code> vector from <code class="literal">CH_Controller</code>.</p><p>Now we are left to deal with different movements. Realistically, we don't want our character to move with exactly the same speed in all directions. We will assign different values to the <code class="literal">Speed</code> variable in the <code class="literal">Controller</code> script based on the direction in which the character is moving:</p><div class="informalexample"><pre class="programlisting">else if (Controller.MoveDirection.z&gt; 0){}
else if (Controller.MoveDirection.z&lt; 0){}
else if (Controller.MoveDirection.x&gt; 0 || Controller.MoveDirection.x&lt; 0){}</pre></div><p>We will use the <code class="literal">MoveDirection</code> vector<a id="id292" class="indexterm"></a> to check the player's movement direction. Positive or negative <span class="strong"><strong>Z</strong></span> axis will tell us if the character is moving forward or backwards; <span class="strong"><strong>X</strong></span> axis controls side walk.</p><p>To play those animations we need to do three things. They are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Modify speed variable in <code class="literal">CH_Controller</code>.</p></li><li><p>Assign animation speed.</p></li><li><p>Crossfade the animation.</p></li></ol></div><p>We can crossfade the animation as follows:</p><div class="informalexample"><pre class="programlisting">else if (Controller.MoveDirection.z&gt; 0){
        Controller.Speed = forwardSpeed;
        animation.CrossFade("walk_forward",0.5, PlayMode.StopSameLayer);
    }
else if (Controller.MoveDirection.z&lt; 0){
        Controller.Speed = backwardSpeed;
        animation.CrossFade("walk_backward");
    }
else if (Controller.MoveDirection.x&gt; 0 || Controller.MoveDirection.x&lt; 0){
        Controller.Speed = strafingSpeed;
        animation.CrossFade("walk_side",0.5, PlayMode.StopSameLayer); 
    }</pre></div><p>We did exactly the same thing to every direction movement. The only exception should <a id="id293" class="indexterm"></a><a id="id294" class="indexterm"></a><a id="id295" class="indexterm"></a><a id="id296" class="indexterm"></a><a id="id297" class="indexterm"></a><a id="id298" class="indexterm"></a>be forward movement. That's where we will implement running. In theory, we will check <code class="literal">isRunning</code> from <code class="literal">CH_Controller</code> and rewrite the function for moving forward as follows:</p><div class="informalexample"><pre class="programlisting">if (Controller.isRunning){
    Controller.Speed = runningSpeed;
    animation.CrossFade("run",0.5, PlayMode.StopSameLayer);
 }
else{
    Controller.Speed = forwardSpeed;
    animation.CrossFade("walk_forward",0.5,PlayMode.StopSameLayer);
}</pre></div><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_02_16.jpg" /></div><p>The animation is now officially done.</p></div></div></div>