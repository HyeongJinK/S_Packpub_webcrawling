<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec51"></a>Object-oriented programming – basics</h2></div></div><hr /></div><a id="id1185" class="indexterm"></a><p>Object-oriented programming, or OOP, is a programming paradigm that uses data structures called <span class="strong"><strong>objects</strong></span> to store parameters and methods. To make it simple, every object has a number of parameters and functions that it can execute, and whole programming is based upon object manipulation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec98"></a>Encapsulation</h3></div></div></div><a id="id1186" class="indexterm"></a><p>One of the four fundamentals of OOP is <span class="strong"><strong>encapsulation</strong></span><a id="id1187" class="indexterm"></a>, the ability of objects to hide properties and methods. It might sound as if its only purpose is to protect them, and in general it is. There is no better way to hide the source code that you’ve been working on for so long if you decide to give your program to somebody to try. But, imagine that you are not working alone and wish to save your peers from reading and trying to understand thousands of lines of your code. The best way to do that is to hide everything that they wouldn’t need to use or even look at, and provide them only with everything necessary for their work. That’s when encapsulation comes in handy.</p><p>There are three types of access levels that are used:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">private</code>
<a id="id1188" class="indexterm"></a><a id="id1189" class="indexterm"></a>: visible only to the current class</p></li><li style="list-style-type: disc"><p><code class="literal">public</code>: visible to everybody<a id="id1190" class="indexterm"></a><a id="id1191" class="indexterm"></a></p></li><li style="list-style-type: disc"><p><code class="literal">protected</code>: visible to the current class and inherited classes</p></li></ul></div><p>Unity has a very interesting way to incorporate encapsulation by letting us choose which properties we want to be modified inside the editor and be visible in the <span class="strong"><strong>Inspector</strong></span> view. Basically, if we want any variables to be modified or seen in the editor, we need to give them <code class="literal">public</code> access level; all others will remain saved and hidden.<a id="id1192" class="indexterm"></a></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec99"></a>Classes</h3></div></div></div><a id="id1193" class="indexterm"></a><a id="id1194" class="indexterm"></a><p>Before we can create an object, we need to create its prototype or a template, which is called <span class="strong"><strong>class</strong></span>. A class is a construct that can create instances of itself. A class defines constituent members that enable its instances to have state and behavior. In general, class is referred to as a noun (cow, table, inventory). Inside the class, we can specify properties (data) and methods (functions).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec100"></a>Constructors</h3></div></div></div><a id="id1195" class="indexterm"></a><a id="id1196" class="indexterm"></a><p>The interesting feature of classes is a function that executes upon creation. Whenever we create a new instance of an object, we automatically call the so-called constructor function, which can even take arguments and do basic setup for the object. The constructor function must be named after class to be recognized as a constructor.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec73"></a>Code</h4></div></div></div><p>Perform the following steps:<a id="id1197" class="indexterm"></a></p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the constructor function for <code class="literal">ParentClass</code>
<a id="id1198" class="indexterm"></a>:</p><div class="informalexample"><pre class="programlisting">function ParentClass(){Debug.Log("Constructor function is called");}</pre></div></li><li><p>Instantiate <code class="literal">ParentClass</code> from the <code class="literal">Awake</code> function<a id="id1199" class="indexterm"></a>:</p><div class="informalexample"><pre class="programlisting">var inheritedClassSample= new ParentClass();</pre></div></li></ol></div><p>If we run the code now, as soon as the instance of <code class="literal">ParentClass</code> is instantiated, we will see a debug message that <code class="literal">"Constructor</code> <code class="literal">function</code> <code class="literal">is</code> <code class="literal">called"</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec101"></a>Inheritance</h3></div></div></div><a id="id1200" class="indexterm"></a><a id="id1201" class="indexterm"></a><p>One of the most wonderful features of classes is <span class="strong"><strong>inheritance</strong></span>. Whenever we create a new class, we can extend from an already existing class and inherit all its data and methods. Of course, we can regulate access level by making data private, which will make it accessible only by its original class.</p><p>Inheritance is widely used in OOP. Imagine that you need to create a number of weapons; you can create each class for the weapon separately, however, if we look closer, each weapon has some things in common. These common data and methods can be stored in a template class, and we can create each individual weapon class as a child of the template class. The template classes that are never instantiated, but use inheritance to create child classes, are called <span class="strong"><strong>abstract</strong></span>.<a id="id1202" class="indexterm"></a></p><a id="id1203" class="indexterm"></a><a id="id1204" class="indexterm"></a><p>If the class that we created is not meant to be extended from, we can declare it as final, which will prevent it from being inherited from.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec74"></a>Preparations</h4></div></div></div><a id="id1205" class="indexterm"></a><p>Let’s take a look at some examples of class manipulations. In this example, we will create a script that contains a couple of classes, and they will inherit from each other. Each class will have data and methods with different access levels to demonstrate how they work:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new script, and call it <code class="literal">OOP</code>.</p></li><li><p>Create a new scene, and place a random object in there.</p></li><li><p>Attach the <code class="literal">OOP</code> script to this object.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec75"></a>Code</h4></div></div></div><a id="id1206" class="indexterm"></a><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Declare a new <code class="literal">public</code> class and call it <code class="literal">ParentClass</code>:</p><div class="informalexample"><pre class="programlisting">public class ParentClass{}</pre></div></li><li><p>Inside <code class="literal">ParentClass</code>, declare the <code class="literal">private</code>, <code class="literal">protected</code>, and <code class="literal">public</code> variables:</p><div class="informalexample"><pre class="programlisting">protected var protectedVar : int = 1;
private var privateVar : int = 1;
public var publicVar : int = 1;</pre></div></li><li><p>Create three functions—<code class="literal">private</code>, <code class="literal">public</code> and <code class="literal">protected</code>:</p><div class="informalexample"><pre class="programlisting">private function voidFunction() : int
{Debug.Log("Private function called");}
public function getPrivateFunction():void
{voidFunction();}
protected function protectedFunction() : int
{return privateVar;}</pre></div></li><li><p>Create a new class, and call it <code class="literal">inheritedClass</code>
<a id="id1207" class="indexterm"></a><a id="id1208" class="indexterm"></a>. It will inherit from <code class="literal">ParentClass</code> and will be the final class:</p><div class="informalexample"><pre class="programlisting">public final class InheritedClass extends ParentClass{}</pre></div></li><li><p>Declare the <code class="literal">Awake</code> function outside the class, create a new instance of <code class="literal">inheritedClass</code>, and try calling the <code class="literal">public</code> and <code class="literal">protected</code> functions from the parent class:</p><div class="informalexample"><pre class="programlisting">function Awake(){
 var ClassSample = new InheritedClass();
ClassSample.getPrivateFunction();
Debug.Log( ClassSample.protectedFunction ());
}</pre></div></li></ol></div><a id="id1209" class="indexterm"></a><p>The result is predictable; the child class recognized the <code class="literal">public</code> and <code class="literal">protected</code> functions of the parent and successfully called them.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec102"></a>Polymorphism</h3></div></div></div><a id="id1210" class="indexterm"></a><a id="id1211" class="indexterm"></a><p>Inheritance is an amazing feature that allows us to save on copying and pasting the same code from one class to another and making our code more organized, but what if the methods that we wish to use in child classes need to be tweaked a bit? Thankfully, we don’t have to create new functions; we can simply rewrite existing ones. This concept in OOP is called <span class="strong"><strong>polymorphism</strong></span>. Polymorphism has two features that we need to keep in mind:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Method</strong></span> <span class="strong"><strong>overloading</strong></span><a id="id1212" class="indexterm"></a><a id="id1213" class="indexterm"></a>: This allows us to declare functions with the same naming signature within the class, but a different argument list</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Method</strong></span> <span class="strong"><strong>overriding</strong></span>: <a id="id1214" class="indexterm"></a><a id="id1215" class="indexterm"></a>This allows us to declare functions with the same naming signature as the parent class, but change what is actually being executed in them</p></li></ul></div><p>The argument list, really, is the only way to control an overloaded function, but what if we need to call an overridden function from the parent class? This can be done by calling <code class="literal">super.functionname()</code>. <code class="literal">super</code>
<a id="id1216" class="indexterm"></a> is a reference to a parent class and can be called from anywhere in the child class.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec76"></a>Code</h4></div></div></div><p>Perform the following steps:<a id="id1217" class="indexterm"></a></p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Inside <code class="literal">InheritedClass</code>, override <code class="literal">protectedFunction</code> and create a constructor function:</p><div class="informalexample"><pre class="programlisting">function InheritedClass(){}
public function protectedFunction(): int {return 5.1;}</pre></div></li><li><p>In the constructor function, call both the original and overridden <code class="literal">protectedFunction</code> function<a id="id1218" class="indexterm"></a>s:</p><div class="informalexample"><pre class="programlisting">Debug.Log("Calling super: " + super.protectedFunction());
Debug.Log("Calling protected: " + protectedFunction());</pre></div></li></ol></div><p>When we start the program, the constructor function will call two functions with the same <a id="id1219" class="indexterm"></a>naming signature, but from different classes.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec103"></a>Nested classes</h3></div></div></div><a id="id1220" class="indexterm"></a><a id="id1221" class="indexterm"></a><p>Classes can be the storage for class properties, as well as other classes. Classes that are stored within other classes are called <span class="strong"><strong>nested</strong></span> <span class="strong"><strong>classes</strong></span>. Nested classes can get access to the <code class="literal">public</code> and <code class="literal">protected</code> functions, methods, and properties of upper class.</p></div></div>