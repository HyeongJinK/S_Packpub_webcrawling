<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec25"></a>Tethering and soft body</h2></div></div><hr /></div><p>Finally, we get to see things interact with the world. We will see from a tether that will sway as you brush by or stick to <span class="strong"><strong>Rigidbody</strong></span> and swing, to soft body projectiles that will deform as they are fired at a hard surface. Unity's joint systems and cloth simulations can be used for different tasks, for example, tethering, which we will talk about in this chapter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>Tethering</h3></div></div></div><a id="id408" class="indexterm"></a><p>This feature can be a main mechanic, a supporting mechanic, an environmental feature, or just plainly used as a source of entertainment for the player. With the tether that we will create, we will go see how it is created, some of the difficulties in creating one, and the end potential of having one. Tethers are really fun, so I hope you enjoy the following and are prepared to dwell into the next few pages.</p><p>As stated in pretty much every one of the chapters, we are covering the basic fundamentals of the tools talked about in the book. Each can be explored beyond what is described and so the least we can do is point you in the right direction. For the tether, nothing else is different. We will have a tether with some basic functionality. It is by no means optimized, but will give a basis of comprehension when tackling the task of creating one. Without further deviation from the task at hand, let's script a tether.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec33"></a>Creating a tether</h4></div></div></div><a id="id409" class="indexterm"></a><p>The functionality that our tether will have is the ability to create a series of <span class="strong"><strong>Rigidbody</strong></span> links along a path determined by the placement of two points, begin and end. These points will also determine the length of the tether itself.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_14.jpg" /></div><p>We will also add onto the last joint a sticky segment script which, when a Rigidbody comes into contact with it, will attach the body, allowing it to be manipulated by the tethers swaying.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_15.jpg" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"></a>Creating assets</h3></div></div></div><a id="id410" class="indexterm"></a><p>First off, we will create all the assets needed for this script to take place. We will need:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Three spheres, of which two to represent the beginning point and endpoint of the tether and a third to represent what our tether segment will be. Call them <span class="strong"><strong>ChainStartPoint</strong></span>, <span class="strong"><strong>ChainEndPoint</strong></span>, and <span class="strong"><strong>tetherSegment</strong></span>.</p></li><li style="list-style-type: disc"><p>One empty <span class="strong"><strong>gameObject</strong></span> (call it<span class="strong"><strong> tetherManager</strong></span>), which will house all aspects of the tether creation (<span class="strong"><strong>ChainStartPoint</strong></span>, <span class="strong"><strong>ChainEndPoint</strong></span>).</p></li></ul></div><p>For the <span class="strong"><strong>ChainEndPoint</strong></span> sphere, we can leave it as it is. However, for the <span class="strong"><strong>tetherSegment</strong></span> and <span class="strong"><strong>ChainStartPoint</strong></span> spheres, we will need to add the <span class="strong"><strong>Rigidbody</strong></span> component and the <span class="strong"><strong>ConfigurableJoint</strong></span> component. The following screenshot represents the values that we want for the <span class="strong"><strong>ConfigurableJoint</strong></span> and <span class="strong"><strong>Rigidbody</strong></span> components:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_16.jpg" /></div><p>After you have created those three spheres and put the appropriate values in, we want to parent the <span class="strong"><strong>ChainStartPoint</strong></span><a id="id411" class="indexterm"></a> and <span class="strong"><strong>ChainEndPoint</strong></span> sphere<a id="id412" class="indexterm"></a>s to empty <span class="strong"><strong>tetherManager</strong></span>. After doing so, create a prefab of it. As for the <span class="strong"><strong>tetherSegment</strong></span> sphere<a id="id413" class="indexterm"></a>, we will create a <a id="id414" class="indexterm"></a>prefab of it and delete the original from the hierarchy:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_17.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec34"></a>Tether manager</h4></div></div></div><a id="id415" class="indexterm"></a><p>We can start writing the tether script. This script will give us control over the tether, the mesh, which is used as the joint segment, and the creation of the tether itself. So, go ahead, create a JavaScript and call it <code class="literal">tetherManager</code>. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The first two variables that we will write will be <code class="literal">p0</code> to represent the beginning and <code class="literal">p1</code> to represent the end. These variables should be declared as <code class="literal">private</code> with a type of <code class="literal">Vector3</code> and set to <code class="literal">Vector3.zero</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">private var p0 : Vector3 = Vector3.zero;
private var p1 : Vector3 = Vector3.zero;</pre></div></li><li><p>In the <code class="literal">Awake</code> function, we want to set the <code class="literal">p0</code> and <code class="literal">p1</code> variables to the transform of their relative points in the world. So, for <code class="literal">p0</code>, we will find the transform of the parented begin point specified by its name and then grab its transform position. We will then do the same for <code class="literal">p1</code>. It should look similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">p0 = transform.Find("ChainStartPoint").transform.position;
p1 = transform.Find("ChainEndPoint").transform.position;</pre></div></li><li><p>After these lines, we then want to find the <code class="literal">gameObject</code> instances of those points, again specified by name, and turn its renderer off using the <code class="literal">enabled</code> function and setting it to <code class="literal">false</code>. This is to make sure that at runtime, the endpoints are invisible and in the editor they can be seen:</p><div class="informalexample"><pre class="programlisting">gameObject.Find("ChainStartPoint").renderer.enabled = false;
gameObject.Find("ChainEndPoint").renderer.enabled = false;</pre></div></li><li><p>After the <code class="literal">Awake</code> function, we will create the <code class="literal">Start</code> function. The <code class="literal">Start</code> function will house the creation of the tether itself. The first thing we want to check in the function is that <code class="literal">p0</code> and <code class="literal">p1</code> are in the scene and are placed. One way to do this is to check if each is not at <code class="literal">vector3.zero</code>.</p></li><li><p>Inside the <code class="literal">if</code> statement, the first step is to grab the tether length. This variable will be declared within the <code class="literal">if</code> statement and can be called <code class="literal">chainLength</code>. To get the length of the tether, we subtract the endpoint from the beginning point using the magnitude. After grabbing the length we want, we need to grab the number of segments. The number of segments for the tether is determined by the length of the tether divided by the distance between those segments.</p></li></ol></div><p>We will then declare the <code class="literal">distanceBetweenSegments</code> variable<a id="id416" class="indexterm"></a> at the top of the script as <code class="literal">public</code> and a <code class="literal">float</code>. It can be defaulted between 0.1 to 0.6. You can go larger but the best results come between these values.</p><p>Essentially, the greater the distance between the segments, the fewer the number of segments <a id="id417" class="indexterm"></a>there will be in the tether:</p><div class="informalexample"><pre class="programlisting">var distanceBetweenSegments : float = 0.8;
function Start(){
    if(p0!=Vector3.zero &amp;&amp; p1!=Vector3.zero){
var chainLength = (p1 – p0).magnitude;
var numberOfSegments = chainLength / distanceBetweenSegments;}
}</pre></div><p>First, we check to make sure that the number of segments is greater than 0 because, if it is not, then there is no need to create a tether. There are a few variables to declare inside of this <code class="literal">if</code> statement. Next, we will set the tether creation point variable to the location of the begin point. Then, we have a variable, which will hold the number of segments that will be added on to the creation segment until we reach our endpoint. The last variable to be created is our <code class="literal">counter</code>. The <code class="literal">counter</code> variable will be equal to the number of segments to be created:</p><div class="informalexample"><pre class="programlisting">if (numberOfSegments =&gt; 0){
var segmentCreatorPosition = p0;
var meshSegmented = (p1 - p0) / numberOfSegments;
var counter =  numberOfSegments;
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec35"></a>Creation of tether</h4></div></div></div><a id="id418" class="indexterm"></a><p>We have reached the tether creation. We will want to use a <code class="literal">while</code> loop here to make sure that it creates the entire tether before it goes and does anything else. The <code class="literal">while</code> loop<a id="id419" class="indexterm"></a> will be controlled by the <code class="literal">counter</code> variable. As long as the <code class="literal">counter</code> is greater than <code class="literal">0</code>, we will loop through the <code class="literal">while</code> loop. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First off, inside the <code class="literal">while</code> loop, we want to create a new tether segment—<code class="literal">newSegment</code>. We will have a variable to hold the instantiation of the object.</p></li><li><p>Declare a new <code class="literal">meshSegment</code> variable<a id="id420" class="indexterm"></a> of a <code class="literal">GameObject</code> type, in a variable section of the script , outside the <code class="literal">Start</code> function.</p></li><li><p>Instantiate <code class="literal">newSegment</code> at the tether creation point and use the default <code class="literal">transform.rotation</code> for the object's rotation, inside the <code class="literal">while</code> loop.</p></li><li><p>After this, we want to push the newly created segment (<code class="literal">newSegment</code>) into the array of segments. This array will be called <code class="literal">meshSegments</code> declared in a variable section as an <code class="literal">Array</code> type.</p></li><li><p>Back inside the <code class="literal">while</code> loop, an <code class="literal">if</code> statement here will check and see if <code class="literal">newSegment</code> has a collider and, if it does, it will check the collision variable to determine whether that collider is a trigger or not.</p></li><li><p>In the following <code class="literal">if</code> statement, we will set up the collision of the newly created segment. At the top, declare a variable called <code class="literal">useCollision</code>
<a id="id421" class="indexterm"></a> or something along those lines.</p></li><li><p>Next, we want the mass of the segment to be affected by the <code class="literal">chainMass</code> variable<a id="id422" class="indexterm"></a> and the drag of the segment affected by the <code class="literal">chainDrag</code> variable<a id="id423" class="indexterm"></a>. These two variables should be declared at the top as <code class="literal">public</code> and as <code class="literal">floats</code> so that you can change them in editor.</p></li></ol></div><p>The following is an example of the code:</p><p>Created variables:</p><div class="informalexample"><pre class="programlisting">var meshSegment : GameObject = null;
var useCollision : boolean = true;    
private var meshSegments : Array = new Array();
var chainMass : float = 2.0;
var chainDrag : float = 0.0;</pre></div><p><code class="literal">while</code> loop:</p><div class="informalexample"><pre class="programlisting">while ( counter &gt; 0 ){
var newSegment = Instantiate( meshSegment, segmentCreatorPosition, transform.rotation );
meshSegments.Push( newSegment );
if ( newSegment.collider ){
    if ( useCollision )
        newSegment.collider.isTrigger = false;
    else
        newSegment.collider.isTrigger = true;
    }
}</pre></div><a id="id424" class="indexterm"></a><p>The following several lines will be affecting <span class="strong"><strong>ConfigurableJoint</strong></span> on the tether.</p><p>As the beginning of each line starts the same, we will just state it now and avoid having to repeat it. We need to access <span class="strong"><strong>ConfigurableJoint</strong></span><a id="id425" class="indexterm"></a> located on the new segments. This line will look like the following statement:</p><div class="informalexample"><pre class="programlisting">newSegment.GetComponent("ConfigurableJoint")</pre></div><p>After <code class="literal">("ConfigurableJoint")</code>, we will be accessing different attributes of the joint. The first will be <code class="literal">linearLimit.spring</code>. This value will become equal to the <code class="literal">chainSpringiness</code> variable<a id="id426" class="indexterm"></a> set up at the beginning. This variable controls how tight the tether is. The smaller this value, the less tight and more sway on the tether. This variable by default will be set to <code class="literal">420</code>.</p><p>The second attribute affected is <code class="literal">linearLimit.damper</code>. This value will be assigned to the <code class="literal">chainDamper</code> variable<a id="id427" class="indexterm"></a>, which will be declared as a <code class="literal">float</code>, <code class="literal">public</code> and with a value of <code class="literal">0</code>. This variable controls how fast the tether moves. The last one will be <code class="literal">breakForce</code> and it will be equal to the <code class="literal">chainTolerance</code> variable. This variable will be defaulted to <code class="literal">Mathf.Infinity</code>. Make sure that it is <code class="literal">public</code> and has the type of <code class="literal">float</code>.</p><p>The following are the variables that need to be declared:</p><div class="informalexample"><pre class="programlisting">var chainSpringiness : float = 420.0;
var chainDamper : float = 0.0;
var chainTolerence : float = Mathf.Infinity;</pre></div><p>So, let us take a look at what we have written inside of the <code class="literal">while</code> loop so far:</p><div class="informalexample"><pre class="programlisting">while( counter &gt; 0 ){
    var newSegment = Instantiate(meshSegment, segmentCreatorPosition, transform.rotation);
meshSegments.Push( newSegment );
    if(newSegment.collider ){
    if(useCollision )
        newSegment.collider.isTrigger = false;
    else
        newSegment.collider.isTrigger = true;
}
newSegment.rigidbody.mass = chainMass;
newSegment.rigidbody.drag = chainDrag;
newSegment.GetComponent("ConfigurableJoint").linearLimit.spring = chainSpringiness;
newSegment.GetComponent("ConfigurableJoint").linearLimit.damper = chainDamper;
newSegment.GetComponent("ConfigurableJoint").breakForce = chainTolerence;
}</pre></div><p>After assigning the attribute values of the <code class="literal">ConfigurableJoint</code>, we need to add a few more lines of code to the <code class="literal">while</code> loop.</p><a id="id428" class="indexterm"></a><p>The first will be another <code class="literal">if</code> statement. This statement is going to be checking to see if the first tether segment has been created. To do this, we use a variable to check if the last target has been created. The <code class="literal">lastTarget</code> variable is essentially going to hold the last segment created. If this variable is null, that means that this is indeed the first segment. Inside of this <code class="literal">if</code> statement, we will have this segment that becomes equal to another variable, which will hold the first created segment. Next, we will access the <code class="literal">ConfigurableJoint</code> attribute<a id="id429" class="indexterm"></a>—<code class="literal">connectedBody</code> and connect the <code class="literal">rigidbody</code>:</p><div class="informalexample"><pre class="programlisting">private var firstSegment: GameObject = null;
private var lastTarget : GameObject = null;
...
while(counter &gt; 0){
...
if ( lastTarget == null ){        
firstSegment = newSegment;
newSegment.GetComponent(ConfigurableJoint).connectedBody = transform.Find("ChainStartPoint").rigidbody;
}</pre></div><p>Lastly, for this statement, we will check the <code class="literal">restrainStartingPoint</code> variable<a id="id430" class="indexterm"></a> for the starting point. If it is true, we change the <code class="literal">isKinematic</code> property of the <code class="literal">rigidbody</code> to <code class="literal">true</code>. For the <code class="literal">else</code> statement, it will represent that this is not the first segment but has come afterwards. Inside of it, we will connect the new segment's <code class="literal">connectedBody</code> attribute<a id="id431" class="indexterm"></a> to the last segment's <code class="literal">rigidbody</code>. This in the end creates a series of connected joints.</p><p>Following the <code class="literal">else</code> statement<a id="id432" class="indexterm"></a>, have the last target variable equal to the new segment so that the last segment always equals the newly created segment. Next, have the segment creation position incremented by the mesh segmentation value. This is so that the distance between joints is in equal proportion. Lastly, decrement the counter by one.</p><a id="id433" class="indexterm"></a><p>The last line to add in this script will be to assign the stick segment script to the last joint created. As the mesh segments array is holding the created segments, we need the length of that array minus one to get the last segment in the array. Once done, we add the <code class="literal">StickySegment</code> component<a id="id434" class="indexterm"></a>. If you wish to have this turned off, comment out this line of code.</p><div class="informalexample"><pre class="programlisting">while( counter &gt; 0 ){
    var newSegment = Instantiate(meshSegment, segmentCreatorPosition, transform.rotation);
meshSegments.Push( newSegment );
    if(newSegment.collider ){
    if(useCollision )
        newSegment.collider.isTrigger = false;
    else
        newSegment.collider.isTrigger = true;
}
newSegment.rigidbody.mass = chainMass;
newSegment.rigidbody.drag = chainDrag;
newSegment.GetComponent("ConfigurableJoint").linearLimit.spring = chainSpringiness;
newSegment.GetComponent("ConfigurableJoint").linearLimit.damper = chainDamper;
newSegment.GetComponent("ConfigurableJoint").breakForce = chainTolerence;
if ( lastTarget == null ){    
firstSegment = newSegment;
newSegment.GetComponent("ConfigurableJoint").connectedBody = transform.Find("ChainStartPoint").rigidbody;
    if( restrainStartingPoint)
        firstSegment.rigidbody.isKinematic = true;
}
else{
newSegment.GetComponent(ConfigurableJoint).connectedBody = lastTarget.rigidbody;
}
                
                lastTarget = newSegment;
                segmentCreatorPosition += meshSegmented;
                counter--;
}
meshSegments[meshSegments.length - 1].AddComponent("StickySegment");</pre></div><p>Now that this script is written, make sure that you have all the variables declared and, when ready, we will move on to the <code class="literal">StickySegment</code> script<a id="id435" class="indexterm"></a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec36"></a>The StickySegment script</h4></div></div></div><a id="id436" class="indexterm"></a><p>This script is very small and can be written quickly. There are two functions and no variables. The script itself will give the end joint the ability to stick to <code class="literal">rigidbody</code> that comes in contact with it. With that being said, the first function to write is <code class="literal">OnCollisionEnter()</code>
<a id="id437" class="indexterm"></a>. The parameter will be declared as <code class="literal">other</code> with the type of <code class="literal">Collision</code>. An <code class="literal">if</code> statement checks to make sure that the collided object has a <code class="literal">rigidbody</code> connect, and if not, then do nothing. A single line is present in the <code class="literal">if</code> statement. This line calls the <code class="literal">StickTo</code> function and has the parameter of the collided <code class="literal">rigidbody</code> objects:</p><div class="informalexample"><pre class="programlisting">function OnCollisionEnter( other : Collision ){
    if(other.gameObject.rigidbody)
    StickTo(other.gameObject.rigidbody );
}</pre></div><p>The following list explains about the functions and variables used in the <code class="literal">StickySegment</code> script:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">StickTo</code> functio<a id="id438" class="indexterm"></a>n is next and carries the parameter of <code class="literal">other</code> as a <code class="literal">rigidbody</code> type. Inside of the function is an <code class="literal">if</code> statement checking to see if the end joint has <code class="literal">CharacterJoint</code> attached. If it does not, it proceeds. If it does, that means it is already attached to something and ends.</p></li><li style="list-style-type: disc"><p>Inside the <code class="literal">if</code> statement, a new variable is declared as <code class="literal">newStickyJoint</code> and it will have the <code class="literal">CharacterJoint</code> component<a id="id439" class="indexterm"></a> added onto this joint.</p></li><li style="list-style-type: disc"><p>Afterwards, have <code class="literal">connectedBody</code> equal to that of the collided object <code class="literal">rigidbody</code>.</p></li><li style="list-style-type: disc"><p>Just in case the joint has been caused to become kinematic, we will set its kinematic property to off.</p></li></ul></div><p>The following is the <code class="literal">StickTo</code> function:</p><div class="informalexample"><pre class="programlisting">function StickTo ( other : Rigidbody ){    
    if(!gameObject.GetComponent(CharacterJoint))    {
        var newStickyJoint = gameObject.AddComponent(CharacterJoint);
        newStickyJoint.connectedBody = other;
    }    
    if ( gameObject.rigidbody.isKinematic )
        gameObject.rigidbody.isKinematic = false;
}</pre></div><p>After this script is done, go back to <span class="strong"><strong>Inspector</strong></span> and add the <span class="strong"><strong>tetherManager</strong></span> script<a id="id440" class="indexterm"></a> to the <span class="strong"><strong>tetherManager</strong></span> object of the tether points. Make sure that the values of the <span class="strong"><strong>tetherManager</strong></span> are like those given in the following screenshot. Play around with them later, but for now, use these to make sure that it works. In the <span class="strong"><strong>Mesh</strong></span> <span class="strong"><strong>Segment</strong></span> variable, we will drag our mesh which will be instantiated. This is <span class="strong"><strong>tetherSegment</strong></span>, which we had initially created at the beginning of the section.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_18.jpg" /></div><a id="id441" class="indexterm"></a><p>Create any object, attach a <span class="strong"><strong>Rigidbody</strong></span> component<a id="id442" class="indexterm"></a> to it, and place it under the <span class="strong"><strong>ChainEndPoint</strong></span> object<a id="id443" class="indexterm"></a> so that they collide. Afterwards, it should be as simple as pressing <span class="strong"><strong>Play</strong></span>. Between your beginning point and endpoint, you should see a series of segments created to represent your tether.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_19.jpg" /></div><a id="id444" class="indexterm"></a><p>Congratulations! You have succeeded in the creation of the simple tether!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec37"></a>Tether scripts overview</h4></div></div></div><a id="id445" class="indexterm"></a><p>The following code snippet shows how the <code class="literal">tetherManager</code> script should look by now:</p><div class="informalexample"><pre class="programlisting">var meshSegment :GameObject = null;                            
var distanceBetweenSegments : float = 0.5;        
var useCollision : boolean = true;                    
var restrainStartingPoint : boolean = true;    
var chainMass : float = 0.1;                    
var chainDrag : float = 0.1;                
var chainSpringiness : float = 10.0;            
var chainDamper : float = 1.0;                
var chainTolerence : float = Mathf.Infinity;    
private var meshSegments : Array = new Array();
private var firstSegment: GameObject = null;
private var lastTarget : GameObject = null;
private var p0 : Vector3 = Vector3.zero;                                
private var p1 : Vector3 = Vector3.zero;    
                            
function Awake(){
    p0 = transform.Find("ChainStartPoint").transform.position;
    p1 = transform.Find("ChainEndPoint").transform.position;
    gameObject.Find("ChainStartPoint").renderer.enabled = false;
    gameObject.Find("ChainEndPoint").renderer.enabled = false;
}
function Start(){
    if ( p0 != Vector3.zero &amp;&amp; p1 !=Vector3.zero){
        var chainLength = ( p1 - p0 ).magnitude;
        var numberOfSegments = chainLength / distanceBetweenSegments;
        if ( numberOfSegments&gt;= 0 ){
            var segmentCreatorPosition = p0;
            var meshSegmented = (p1 - p0) / numberOfSegments;
            var counter =  numberOfSegments;
            while ( counter &gt; 0 ){
                var newSegment = Instantiate( meshSegment, segmentCreatorPosition,
transform.rotation );
                meshSegments.Push(newSegment );
                if ( newSegment.collider ){
                    if ( useCollision )
                        newSegment.collider.isTrigger = false;
                    else
                        newSegment.collider.isTrigger = true;
                }                
                newSegment.rigidbody.mass = chainMass;
                newSegment.rigidbody.drag = chainDrag;                            
                newSegment.GetComponent("ConfigurableJoint").linearLimit.spring = chainSpringiness;
                newSegment.GetComponent("ConfigurableJoint").linearLimit.damper = chainDamper;
                newSegment.GetComponent("ConfigurableJoint").breakForce =
                chainTolerence;
                if ( lastTarget == null ){    
                    firstSegment = newSegment;    
newSegment.GetComponent(ConfigurableJoint).connectedBody = transform.Find(ChainStartPoint).rigidbody;
                    if(restrainStartingPoint)
                        firstSegment.rigidbody.isKinematic = true;
                }
                else{
                    newSegment.GetComponent(ConfigurableJoint).connectedBody = lastTarget.rigidbody;
                }
                lastTarget = newSegment;
                segmentCreatorPosition += meshSegmented;
                counter--;
            }
            meshSegments[meshSegments.length -1].AddComponent("StickySegment");
        }
    }
}</pre></div><a id="id446" class="indexterm"></a><p>The following code snippet shows what the <code class="literal">StickSegment</code> script<a id="id447" class="indexterm"></a> should look like:</p><div class="informalexample"><pre class="programlisting">function OnCollisionEnter( other : Collision ){
    if(other.gameObject.rigidbody)
    StickTo(other.gameObject.rigidbody );
}

function StickTo ( other : Rigidbody ){
    if(!gameObject.GetComponent(CharacterJoint))    {
        var newStickyJoint = gameObject.AddComponent(CharacterJoint);
        newStickyJoint.connectedBody = other;
    }
    if ( gameObject.rigidbody.isKinematic )
        gameObject.rigidbody.isKinematic = false;
}</pre></div></div></div></div>