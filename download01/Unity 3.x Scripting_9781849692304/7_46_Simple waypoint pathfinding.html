<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec46"></a>Simple waypoint pathfinding</h2></div></div><hr /></div><a id="id976" class="indexterm"></a><p>When it comes to pathfinding, there are many types and each of them has a different function and ability. For pathfinding, there are various algorithms such as breadth-first search<a id="id977" class="indexterm"></a><a id="id978" class="indexterm"></a>, depth-first search<a id="id979" class="indexterm"></a><a id="id980" class="indexterm"></a>, Dijkstra<a id="id981" class="indexterm"></a><a id="id982" class="indexterm"></a>, and A*<a id="id983" class="indexterm"></a><a id="id984" class="indexterm"></a> for pathing waypoint and nav-mesh. A <span class="strong"><strong>nav-mesh</strong></span><a id="id985" class="indexterm"></a><a id="id986" class="indexterm"></a> is a mesh, which has its faces triangulated to form surfaces that can be transversed. Games such as Uncharted 2 and Killzone 3 use this form of navigation. With that being said, it is not uncommon to see the enemies navigating along using the different types of pathfinding techniques in different situations. The pathfinding type that we will use, as I have mentioned in the introductory section, is going to be a static waypoint navigation system.</p><p>In this section we will look into the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Setting up the hierarchy</p></li><li style="list-style-type: disc"><p>Writing the waypoint display script</p></li><li style="list-style-type: disc"><p>Setting up the path arrays</p></li><li style="list-style-type: disc"><p>Creating the <code class="literal">aiSimplePath</code> script</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec86"></a>Setting up the hierarchy</h3></div></div></div><a id="id987" class="indexterm"></a><p>What we need to do, before we move any further, is to set up the scene hierarchy. In the <code class="literal">Assets</code> folder for this chapter, there is an enemy prefab and a test level called "Scene". Drag the test level and the four enemies into the <span class="strong"><strong>Hierarchy</strong></span> view<a id="id988" class="indexterm"></a>. Once this is done, you should see the enemies and the level, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304_07_02.jpg" /></div><a id="id989" class="indexterm"></a><p>Now we need to decide our paths as well.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec87"></a>Writing the waypoint display script</h3></div></div></div><a id="id990" class="indexterm"></a><a id="id991" class="indexterm"></a><p>The script that we will be creating in this section will allow the user to have a gizmo icon, which is representative of our waypoints. It will allow us to turn the gizmo on and off in the scene view and game view as well. To make this happen, all we need to do is to create a new script called <code class="literal">WaypointNode_Display</code>
<a id="id992" class="indexterm"></a>. In here we need to call a single function called <code class="literal">OnDrawGizmos</code>
<a id="id993" class="indexterm"></a>. Then, in order to have the icon displayed, we need to set up the location of the image. For us, we want that location to be the location of the attached <code class="literal">gameObject</code>. The texture is located in the <code class="literal">Textures</code> folder and is called <code class="literal">waypointnode_icon</code>
<a id="id994" class="indexterm"></a>. To do all this, we use the <code class="literal">Gizmos.DrawIcon</code> function<a id="id995" class="indexterm"></a> as follows:</p><div class="informalexample"><pre class="programlisting">function OnDrawGizmos(){
    Gizmos.DrawIcon(transform.position, Application.dataPath + "\History\Chapter 7\Custom_textures\waypoint.png");
}</pre></div><p>Now that we have this script written, we can set up our waypoints for our paths. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create waypoint arrays.</p></li><li><p>Establish communication between them.</p></li><li><p>Make robots patrol the area using waypoints.</p></li></ol></div><a id="id996" class="indexterm"></a><a id="id997" class="indexterm"></a><p>Have a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304_07_03.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec88"></a>Setting up the path arrays</h3></div></div></div><a id="id998" class="indexterm"></a><a id="id999" class="indexterm"></a><p>If you would like to just move ahead to writing the pathfinding script, drag the path examples, located in the <span class="strong"><strong>Assets</strong></span> folder for this chapter, into the <span class="strong"><strong>Hierarchy</strong></span> view. These paths are already set up for you and have the waypoints set as well. We need to write the script before we can assign the paths to the enemies. After you do this, skip down to writing the <code class="literal">aiSimplePath</code> script<a id="id1000" class="indexterm"></a>.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304_07_04.jpg" /></div><p>For each enemy that is in the scene, we want to create an empty <code class="literal">gameObject</code>, which will be its path array and house the waypoints for that path. A path is not necessary for every enemy. Enemies can share paths and have multiple paths, but it will be easier to showcase the enemies' pathfinding and behavior if they have their own paths.</p><a id="id1001" class="indexterm"></a><a id="id1002" class="indexterm"></a><p>We want to create a waypoint prefab and drag the <span class="strong"><strong>waypointPointnode_Display</strong></span> script<a id="id1003" class="indexterm"></a> onto it. After that, we will create waypoints for the enemies. So, go ahead and place them around where you want. Keep in mind when you are placing them, the order in which you place them, and where and which path they are to be associated with. Once that is done, parent the appropriate waypoints to their path <code class="literal">gameObject</code> variables. We must now write the <code class="literal">aiSimplePath</code> script.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec89"></a>Creating the aiSimplePath script</h3></div></div></div><a id="id1004" class="indexterm"></a><a id="id1005" class="indexterm"></a><p>The <code class="literal">aiSimplePath</code> script will handle the enemy's navigation through waypoints, and later on, the tracking of injured bots, the player, and ammo. This path system will allow our enemy to be able to travel through the path and once at the last waypoint, he will have three options. The first option is to be able to loop back to the beginning of the first waypoint and the second one is to reverse and go back to the first waypoint along the path that the enemy came. A third option does present itself when an enemy is set to reverse. When the enemy is at the beginning of the array again and if <code class="literal">reverseLoop</code>
<a id="id1006" class="indexterm"></a> is set to <code class="literal">true</code>, the enemy will then travel through the array to the last waypoint and then back again to the beginning, and so forth. With these three options, we can have the enemies acting differently from each other.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec53"></a>Declaring variables</h4></div></div></div><a id="id1007" class="indexterm"></a><a id="id1008" class="indexterm"></a><p>First, let's define our path variables. To do this, we need to:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Declare variables for our path</p></li><li style="list-style-type: disc"><p>Define the object to be pursued (in this case, the player)</p></li><li style="list-style-type: disc"><p>Define the speed at which we want the enemy to travel</p></li></ul></div><p>Three of these variables, as mentioned previously, will represent the navigation of the path—<code class="literal">reverse</code>, <code class="literal">reverseLoop</code>, and <code class="literal">looping</code>. They are of the <code class="literal">boolean</code> type<a id="id1009" class="indexterm"></a> and <code class="literal">public</code> as well.</p><p>The next set deals with information gathering. We need to have one variable for housing the waypoint paths of the enemy, one variable that for holding all the waypoints in those paths, another one for the waypoint that we would like to get to and, lastly, a variable for the direction in which we are navigating through the waypoint array.</p><p>The <code class="literal">enemyPath</code> variable<a id="id1010" class="indexterm"></a> will be a <code class="literal">Transform</code> list and <code class="literal">public</code>. The <code class="literal">waypointArray</code> variable<a id="id1011" class="indexterm"></a> needs to be an array and, for default, set it to <code class="literal">new</code> <code class="literal">Array</code> and make it <code class="literal">private</code>. Create a third variable called <code class="literal">currentWaypoint</code>
<a id="id1012" class="indexterm"></a>, which will handle the tracking of the current waypoint to pursue. It will be an integer and <code class="literal">private</code> as well. The last path variable to create is the <code class="literal">arrayDirection</code> variable<a id="id1013" class="indexterm"></a>, which will keep track of the direction in which we are navigating through the array:</p><div class="informalexample"><pre class="programlisting">public var reverse : boolean;
public var reverseLoop : boolean;
public var looping : boolean;
public var enemyPath : Transform[];
private var waypointArray : Array = new Array();
private var currentWaypoint : int = 0;
private var arrayDirection : int;</pre></div><p>The object to be pursued is called <code class="literal">player,</code> and it is <code class="literal">public</code> and of the <code class="literal">GameObject</code> type<a id="id1014" class="indexterm"></a>. Next, we need to define the <code class="literal">speed</code> variable to set the speed at which the player will move, make it a <code class="literal">float</code> and <code class="literal">public</code>, too. Our last variable for now is the <code class="literal">stopRobot</code> variable<a id="id1015" class="indexterm"></a>, and it is <code class="literal">boolean</code> and <code class="literal">private</code>:</p><div class="informalexample"><pre class="programlisting">public var player : GameObject;
public var speed : float;
private var stopRobot : boolean;</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec54"></a>Starting up functions</h4></div></div></div><a id="id1016" class="indexterm"></a><a id="id1017" class="indexterm"></a><p>Once all the variables are in place, we will start our functions.</p><p>The <code class="literal">Awake</code> function<a id="id1018" class="indexterm"></a> will get all the waypoints in all the enemy paths through the <code class="literal">enemyPath</code> variable<a id="id1019" class="indexterm"></a> and add them to the waypoint array. It will then set the <code class="literal">arrayDirection</code> variable<a id="id1020" class="indexterm"></a> to the length of the waypoint array. A <code class="literal">for</code> loop<a id="id1021" class="indexterm"></a> is then used to loop through each path and a second <code class="literal">for</code> loop inside of the first one is used to grab the waypoints. Then, each waypoint in each path is added to the waypoint array. Naming convention for the nodes will make a difference, as it will determine the order in which enemies will be moving from one to another.</p><div class="informalexample"><pre class="programlisting">function Awake(){
    for(var path in enemyPath){
        for(var waypoint in path){
            waypointArray.Add(waypoint);
        }
    }
    arrayDirection = waypointArray.length;
}</pre></div><a id="id1022" class="indexterm"></a><p>After the <code class="literal">Awake</code> function, we will get down to the <code class="literal">EnemyPath</code> function<a id="id1023" class="indexterm"></a>. This is a mean beefy piece of code that allows our enemies to traverse the path.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec55"></a>Traversing the path</h4></div></div></div><a id="id1024" class="indexterm"></a><a id="id1025" class="indexterm"></a><p>The <code class="literal">EnemyPath</code> function will set the pathfinding for the enemies in various situations, such as patrolling, pursuing the enemy, locating ammo, and locating injured enemies.</p><p>At the beginning of the function, we first need to make sure that our pathfinding variables—<code class="literal">reverse</code>, <code class="literal">reverseLoop</code>, and <code class="literal">looping</code>—are set. Remember, when <code class="literal">reverse</code> is set to <code class="literal">true</code>, <code class="literal">looping</code> is <code class="literal">false</code>. <code class="literal">reverseLoop</code> can only be <code class="literal">true</code> if <code class="literal">reverse</code> is set to <code class="literal">true</code>, and when <code class="literal">looping</code> is set to <code class="literal">true</code>, <code class="literal">reverse</code> and <code class="literal">reverseLoop</code> are <code class="literal">false</code>.</p><p>Next, we will check if the robot has come to a complete stop for whatever reason, and if not, we will start our pathfinding. We need to define three variables—<code class="literal">velocity</code> (to deal with the speed that our enemy will move at), <code class="literal">moveDirection</code> (to deal with the facing direction of the enemy), and <code class="literal">Target</code> (to define the place where the enemy wants to go). All are of the <code class="literal">Vector3</code> type.</p><p>The code for the beginning of the function is as follows:</p><div class="informalexample"><pre class="programlisting">function EnemyPath(){    
    if(reverse){looping = false;}
    if(reverseLoop){looping = false; reverse = true;}
    if(looping){reverse = false; reverseLoop = false;}
    if(!stopRobot){
        var velocity : Vector3 = rigidbody.velocity
        var moveDirection : Vector3;
        var Target : Vector3;
}
}</pre></div><p>As mentioned previously, our enemy will be searching for the player, ammo, and injured bots, but before we get to writing that code, we will first just implement the following of the waypoints, and once the <code class="literal">aiSimpleBehaviour</code> script is written, we will return to this script and add the rest of the code.</p><p>In that case, we set our enemies to patrol. Our enemy will patrol through the waypoints of our waypoint array. We will use our <code class="literal">arrayDirection</code>
<a id="id1026" class="indexterm"></a> and <code class="literal">currentWaypoint</code> variable<a id="id1027" class="indexterm"></a>s to determine how we navigate through the waypoints. We will perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><a id="id1028" class="indexterm"></a><a id="id1029" class="indexterm"></a><p>If the <code class="literal">arrayDirection</code> variable<a id="id1030" class="indexterm"></a> equals our <code class="literal">waypointArray.length</code> and if our current waypoint is less than that, then it means that we are increasing through the array. Inside of the <code class="literal">if</code> statement, we need to set the <code class="literal">Target</code> and <code class="literal">moveDirection</code> variable<a id="id1031" class="indexterm"></a>s. The <code class="literal">Target</code> variable becomes the current waypoint position from the waypoint array, and <code class="literal">moveDirection</code> is <code class="literal">Target</code> minus the enemy's position.</p></li><li><p>Next, we will check whether we are at the last waypoint using the <code class="literal">Vector3.Distance</code> function to check our position against the last waypoint's position. If we are not at the last waypoint, and if we are not looping or reversing, we will set the enemy's <code class="literal">velocity</code> to <code class="literal">Vector3.zero</code> (This will stop the enemy's momentum).</p></li><li><p>If however, we are not at the last waypoint and are within the range of 1 from our next point, we will increment the current waypoint. (We use the magnitude function on our <code class="literal">moveDirection</code> variable to determine if the distance between the enemy and its target is in range. In this case, that range value is 1.)</p><p>If the magnitude between the enemy and the target is not less than <code class="literal">1</code> and therefore not in range, normalize our <code class="literal">moveDirection</code> variable, multiply with speed, and assign it to <code class="literal">velocity</code>.</p><p>The code for increasing through the waypoint array <code class="literal">if</code> statement is as follows:</p><div class="informalexample"><pre class="programlisting">if (arrayDirection == waypointArray.length &amp;&amp; currentWaypoint &lt; arrayDirection){
    Target = waypointArray[currentWaypoint].position;
    moveDirection = Target - transform.position;
if (Vector3.Distance(waypointArray[waypointArray.length-
1].position, transform.position) &lt; 1 &amp;&amp; !looping &amp;&amp; !reverse &amp;&amp;
!reverseLoop){
    velocity = Vector3.zero;
    }
    else if(moveDirection.magnitude &lt; 1){
    currentWaypoint++;
    }
    else{
    velocity = moveDirection.normalized * speed;
    }
}</pre></div><p>That ends the increasing through the waypoint array <code class="literal">if</code> statement. Right after it though, we need an <code class="literal">else</code> <code class="literal">if</code> statement, which will determine if we are decreasing through the waypoint array.</p></li><li><p>Next, we will check the <code class="literal">arrayDirection</code> variable<a id="id1032" class="indexterm"></a> again. If it is equal to <code class="literal">0</code> and if our current waypoint is greater than our array direction, it means that we are decreasing through the array. The <code class="literal">Target</code>
<a id="id1033" class="indexterm"></a> and <code class="literal">moveDirection</code> variable<a id="id1034" class="indexterm"></a>s can stay the same, but our next <code class="literal">if</code> statement will have different parameters.</p></li><li><a id="id1035" class="indexterm"></a><a id="id1036" class="indexterm"></a><p>We need to check that our range (remember, <code class="literal">moveDirection.magnitude</code>) is less than <code class="literal">1</code>, our current waypoint is equal to <code class="literal">0</code>, and that we are not doing a reverse loop. If all of these are true, we will set our <code class="literal">velocity</code> variable to <code class="literal">Vector3.zero</code>.</p></li><li><p>If our range to our target is less than <code class="literal">1</code>, we will decrement the <code class="literal">currentWaypoint</code> variable. If the enemy is not in range of the target, we will normalize our <code class="literal">moveDirection</code> variable, multiply with speed, and assign it to <code class="literal">velocity</code>.</p><p>The code for the decreasing through the waypoint array <code class="literal">if</code> statement is as follows:</p><div class="informalexample"><pre class="programlisting">else if(arrayDirection == 0 &amp;&amp; currentWaypoint &gt;= arrayDirection){
    Target = waypointArray[currentWaypoint].position;
    moveDirection = Target - transform.position;
    if(moveDirection.magnitude &lt; 1 &amp;&amp; currentWaypoint == 0 &amp;&amp; !reverseLoop) {
            velocity = Vector3.zero;
            }
            else if(moveDirection.magnitude &lt; 1 ) {
            currentWaypoint--;
    }
    else {
        velocity = moveDirection.normalized * speed;
    }
}</pre></div><p>Now we need to check if our enemy is looping or going in reverse in the <code class="literal">else</code> statement that follows right after the <code class="literal">else</code> <code class="literal">if</code> statement.</p></li><li><p>If looping, we will set the <code class="literal">currentWaypoint</code> variable<a id="id1037" class="indexterm"></a> to <code class="literal">0</code>.</p></li><li><p>If reversing looping, we will set the <code class="literal">arrayDirection</code> variable<a id="id1038" class="indexterm"></a> back to <code class="literal">waypointArray.length</code> and increment the <code class="literal">currentWaypoint</code> variable.</p></li><li><p>If just reverse, set the <code class="literal">arrayDirection</code> to <code class="literal">0</code> and decrement the <code class="literal">currentWaypoint</code> variable.</p></li><li><p>Lastly, at the bottom of the <code class="literal">!stopRobot</code> <code class="literal">if</code> statement, give the enemy's <code class="literal">rigidbody.velocity</code>, the <code class="literal">velocity</code> value and use the <code class="literal">transform.LookAt</code> function with the <code class="literal">Target</code> variable as the parameter to make an enemy look at <a id="id1039" class="indexterm"></a><a id="id1040" class="indexterm"></a>another enemy.</p><p>The code in the <code class="literal">else</code> statement and the final lines of the function are as follows:</p><div class="informalexample"><pre class="programlisting">else{    
    if(looping){
        currentWaypoint = 0;
    }
    else if(reverse){
    if (arrayDirection == 0 &amp;&amp;    
        Vector3.Distance(waypointArray[0].position,  
        transform.position) &lt; 1 &amp;&amp; reverseLoop){
                arrayDirection = waypointArray.length;
                currentWaypoint++;
    }
    else if(currentWaypoint == waypointArray.length){
                arrayDirection = 0;
                currentWaypoint--;
        }
    }
}
rigidbody.velocity = velocity;
transform.LookAt(Target);</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec56"></a>Shutting down the robot</h4></div></div></div><a id="id1041" class="indexterm"></a><a id="id1042" class="indexterm"></a><p>The <code class="literal">ShutDownRobot</code> function will set the <code class="literal">stopRobot</code> variable to the <code class="literal">stop</code> <code class="literal">boolean</code> variable of the function. If <code class="literal">stopRobot</code> is true, set <code class="literal">velocity</code> to <code class="literal">Vector3.zero</code>. The code for the <code class="literal">ShutDownRobot</code> function<a id="id1043" class="indexterm"></a> is as follows:</p><div class="informalexample"><pre class="programlisting">function ShutDownRobot(stop : boolean){
    stopRobot = stop;
    if(stopRobot){
    velocity = Vector3.zero;
    }
}</pre></div><p>The <code class="literal">Update</code> function<a id="id1044" class="indexterm"></a> is used to call the <code class="literal">EnemyPath</code> function<a id="id1045" class="indexterm"></a> as follows:</p><div class="informalexample"><pre class="programlisting">function Update(){
    EnemyPath();
}</pre></div><p>The <code class="literal">aiSimplePath</code> script is now complete, at least for the time being. We will set up <span class="strong"><strong>Inspector</strong></span> for our enemies next.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec57"></a>Hooking up the aiSimplePath script on Inspector</h4></div></div></div><a id="id1046" class="indexterm"></a><a id="id1047" class="indexterm"></a><p>We can now drag the <span class="strong"><strong>aiSimplePath</strong></span> script from the <span class="strong"><strong>Project</strong></span> view to the <span class="strong"><strong>Inspector</strong></span> view of our enemies. You should see that our path variable will allow us to drag our respective paths to our enemies. We also need to give a speed to our enemy. After that, you can set the type of navigation of the waypoints for the enemy to do. Press <span class="strong"><strong>Play</strong></span> in the editor, and if you have everything set up correctly, your enemy should travel along the path that you have specified for him.</p><p>We will have to come back to this script later, and add a couple of functions and some lines of code to make the enemy locate ammo and injured bots, and pursue the player. For the time being, however, the next section will deal with enemy statistics, shooting, and behaviors.</p></div></div></div>