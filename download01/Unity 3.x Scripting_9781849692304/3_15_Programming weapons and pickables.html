<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec19"></a>Programming weapons and pickables</h2></div></div><hr /></div><a id="id299" class="indexterm"></a><p>Weapons are fun! Weapons can shoot! But there are limits to weapon functionality, aren't there? Sometimes, weapons have a cooldown between each shot, reloading when ammo in a clip is out, primary and secondary fire (a usual thing is videogames), and choice between spawning a physical bullet or casting rays in certain directions to save frame rate. Weapons can be tricky, and it's always recommended to plan ahead for the required functionality of the weapon. <a id="id300" class="indexterm"></a>Pickables are easier, but can become a headache whenever we are dealing with particle effects and modifying stats.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec21"></a>Creating the base</h3></div></div></div><a id="id301" class="indexterm"></a><a id="id302" class="indexterm"></a><p>Before we start programming weapons and pickables, we should create a base to store statistics and make them affect our character. Create a script called <code class="literal">CH_PlayerStats</code>
<a id="id303" class="indexterm"></a> and attach it to the character. Declare the following <code class="literal">private</code> variable<a id="id304" class="indexterm"></a>s of <code class="literal">int</code> type—<code class="literal">Health</code>, <code class="literal">AmmoPrime</code>, <code class="literal">AmmoAlt</code>, <code class="literal">Money</code>. Create enumeration called <code class="literal">TypeofAmmo</code>
<a id="id305" class="indexterm"></a>, as shown in the code snippet just after the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_01.jpg" /></div><div class="informalexample"><pre class="programlisting">private var Health : int = 100;
private var AmmoPrime : int = 20;
private var AmmoAlt : int = 20;
private var Money : int = 0;
enum TypeofAmmo{
Prime,
Alt
};</pre></div><a id="id306" class="indexterm"></a><a id="id307" class="indexterm"></a><p>Declare the <code class="literal">GetAmmo</code> and <code class="literal">AddAmmo</code> function<a id="id308" class="indexterm"></a>s. To retrieve and set information we will be using enumerations:</p><div class="informalexample"><pre class="programlisting">function GetAmmo(Ammotype : int){
    switch (Ammotype){
        case TypeofAmmo.Prime:
            return AmmoPrime;
            break;
        case TypeofAmmo.Alt:
            return AmmoAlt;
            break;
        default:
            Debug.Log ("Wrong ammo type!");
    }
}
function AddAmmo(Ammotype : int , amount : int, modify : int){
    switch (Ammotype){
        case TypeofAmmo.Prime:
            if(modify)
            AmmoPrime += amount;
            else
            AmmoPrime = amount;
            break;
        case TypeofAmmo.Alt:
            if(modify)
            AmmoAlt += amount;
            else
            AmmoAlt = amount;
            break;
        default:
            Debug.Log ("wrong type");
    }
}</pre></div><p><code class="literal">AddAmmo</code> is asking for the type of ammo to change (<code class="literal">Ammotype</code> <code class="literal">:</code> <code class="literal">int</code>), the amount of ammo to add (<code class="literal">amount</code> <code class="literal">:</code> <code class="literal">int</code>), and if ammo needs to be modified or set (<code class="literal">modify</code> <code class="literal">:</code> <code class="literal">int</code>). We will go through the list of the <code class="literal">switch</code> statement<a id="id309" class="indexterm"></a>s and determine which type of ammo to add. If we send the wrong ammo type to function, the default case will tell us about it. <code class="literal">GetAmmo</code> is asking <a id="id310" class="indexterm"></a><a id="id311" class="indexterm"></a>only for the ammo type that will be returned.</p><p>Next, we will declare <code class="literal">GetHealth</code> and <code class="literal">AddHealth</code>, that will work in a similar way. <code class="literal">AddMoney</code> and <code class="literal">GetMoney</code> are made in a similar way, too:</p><div class="informalexample"><pre class="programlisting">function GetHealth(){return Health;}
function AddHealth(amount : int, modify : int){
    if(modify)
    Health += amount;
    else
    Health = amount;
}
function GetMoney(){return Money;}
function AddMoney( amount : int ){Money += amount;}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec22"></a>Programming the weapon</h3></div></div></div><a id="id312" class="indexterm"></a><p>Now, we will start the interesting part—programming the weapon. Our weapon will be unusual. It will be able to shoot as an assault rifle, yes, it will also shoot exploding toxic goo that we will create with interactive cloth, but we will talk about this in future chapters. For now, let's focus on the weapon.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_02.jpg" /></div><p>It so happens that a gun is already attached to a demonstrational model, so all we need to take care of is the proper particles to be emitted.</p><a id="id313" class="indexterm"></a><p>In the <span class="strong"><strong>customObjects</strong></span> folder<a id="id314" class="indexterm"></a>, you will find a prefab called <span class="strong"><strong>Sparks</strong></span><a id="id315" class="indexterm"></a>. It will be used to emit muzzle fire for us:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_03.jpg" /></div><p>Drag it to the scene and put it inside the <span class="strong"><strong>robot</strong></span> prefab<a id="id316" class="indexterm"></a>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_04.jpg" /></div><a id="id317" class="indexterm"></a><p>Open the <span class="strong"><strong>CH_Controller</strong></span> script<a id="id318" class="indexterm"></a>. We have many interesting functionalities to add to it. Let's start with variables. We will need variables to store information about current state of weapon, reloading, and projectiles:</p><div class="informalexample"><pre class="programlisting">public var bIsShooting : boolean = false;
public var bIsShootingAlt : boolean = false;
public var Muzzle : GameObject;
public var MuzzleAlt1 : GameObject;
public var MuzzleAlt2 : GameObject;
public var Projectile : Cloth;
public var projectileSpeed : float = 20.0;
private var Stats : CH_PlayerStats;
private var counter : boolean = false;
private var countTime : float = 0;
private var canShootPrime : boolean = true;
private var canShootAlt : boolean = true;
public var flush: ParticleEmitter;
private var bWeaponEquiped : boolean = false;</pre></div><p>The following list explains about the functions in the <code class="literal">CH_Controller</code> script<a id="id319" class="indexterm"></a> and their uses:</p><p><code class="literal">bIsShooting</code>
<a id="id320" class="indexterm"></a><a id="id321" class="indexterm"></a> and <code class="literal">bIsShootingAlt</code> <a id="id322" class="indexterm"></a><a id="id323" class="indexterm"></a>will determine if the gun is currently in a shooting state. This will greatly aid us when we go into animations.</p><p><code class="literal">Muzzle</code>
<a id="id324" class="indexterm"></a><a id="id325" class="indexterm"></a> will contain the location that our goo projectiles will shoot from.</p><p><code class="literal">MuzzleAlt1</code>
<a id="id326" class="indexterm"></a><a id="id327" class="indexterm"></a> and <code class="literal">MuzzleAlt2</code> will contain the location that our usual bullets will shoot from.</p><p><code class="literal">Projectile</code>
<a id="id328" class="indexterm"></a><a id="id329" class="indexterm"></a> is self explanatory; however, take a look at the variable type—<code class="literal">Cloth</code> that we gave to it. <code class="literal">InteractiveCloth</code> is a special type of object different from <code class="literal">GameObject</code>. We will talk more about this later in the chapter. The <span class="strong"><strong>Projectile</strong></span> prefab can be found inside the <span class="strong"><strong>customObjects</strong></span> folder.</p><p><code class="literal">projectileSpeed</code>
<a id="id330" class="indexterm"></a><a id="id331" class="indexterm"></a> will control the speed of our projectile.</p><p><code class="literal">Stats</code>
<a id="id332" class="indexterm"></a><a id="id333" class="indexterm"></a> is a reference to the <code class="literal">CH_PlayerStats</code> script that we just created to retrieve information from it.</p><p><code class="literal">Counter</code>
<a id="id334" class="indexterm"></a><a id="id335" class="indexterm"></a> and <code class="literal">countTime</code>
<a id="id336" class="indexterm"></a><a id="id337" class="indexterm"></a> will control the reload counter. <code class="literal">Counter</code> will check if we are reloading or not and <code class="literal">countTime</code> will control the reloading time.</p><p><code class="literal">canShootPrime</code>
<a id="id338" class="indexterm"></a><a id="id339" class="indexterm"></a> and <code class="literal">canShootAlt</code>
<a id="id340" class="indexterm"></a><a id="id341" class="indexterm"></a> will help us determine if we can shoot one type of fire or another. This is useful to be able to control animations and stop shooting when reloading.</p><p><code class="literal">Flush</code>
<a id="id342" class="indexterm"></a><a id="id343" class="indexterm"></a> is the particle emitter that we just attached to the muzzle.</p><p><code class="literal">bWeaponEquiped</code>
<a id="id344" class="indexterm"></a><a id="id345" class="indexterm"></a> will check if weapon is currently being equipped by character.</p><p>We will continue with the <code class="literal">CH_Controller</code> script. Declare a <code class="literal">Start</code> function. We will need <a id="id346" class="indexterm"></a>to store a reference to the <code class="literal">CH_PlayerStats</code> script<a id="id347" class="indexterm"></a> first. Now, we need to disable our particle emitter from emitting ahead of time. We will proceed with the <code class="literal">FixedUpdate</code> function<a id="id348" class="indexterm"></a> and start creating weapon control by registering player input. Exactly the same thing will be done to register alternative fire:</p><div class="informalexample"><pre class="programlisting">...
function Start(){
Stats = this.gameObject.GetComponent(CH_PlayerStats);
 if (flush)
flush.emit = false;
<span class="strong"><strong>}</strong></span>
function FixedUpdate(){
if (Input.GetKey (KeyCode.Mouse0) &amp;&amp; bWeaponEquiped){
        
        if(canShootPrime &amp;&amp; Stats.GetAmmo(0) &gt; 0){
        Shooting();
        bIsShooting = true;
        }
    }
if(Input.GetKey (KeyCode.Mouse1) &amp;&amp; bWeaponEquiped){
        
        if (canShootAlt &amp;&amp; Stats.GetAmmo(1) &gt; 0){
        bIsShootingAlt = true;
        AltShooting();
        }
if (!Input.GetKey (KeyCode.Mouse0))
    bIsShooting = false;
if (!Input.GetKey (KeyCode.Mouse1))
    bIsShootingAlt = false;
}</pre></div><p>We registered the mouse button down and made sure that the weapon is currently being equipped. Toggle <code class="literal">bIsShooting</code> and <code class="literal">bIsShootingAlt</code> to <code class="literal">true</code> and go through another series of checks to determine if we can shoot with a prime fire and alternative fire (<code class="literal">canShootPrime</code> and <code class="literal">canShootAlt</code>) and have more than 0 ammo available.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note09"></a>Note</h3><p><code class="literal">KeyCode.Mouse0</code> is the left mouse button, and <code class="literal">KeyCode.Mouse1</code> is the right mouse button.</p></div><p>Declare the <code class="literal">Shooting</code> function<a id="id349" class="indexterm"></a>; this will control everything that has to do with shooting the prime fire. Declare <code class="literal">AltShooting</code> to control alternative fire. We will also need to <a id="id350" class="indexterm"></a>register that if a player is not pressing any button, then <code class="literal">bIsShooting</code> and <code class="literal">bIsShootingAlt</code> should be false.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec28"></a>The Shooting function</h4></div></div></div><a id="id351" class="indexterm"></a><p>The next step will be to spawn the actual projectile that will kill enemies. To achieve this, we will instantiate a soft body projectile using the reference set by the <code class="literal">Projectile</code> variable and location specified in <span class="strong"><strong>Muzzle</strong></span> and kick it hard so it can fly. To make sure that our <code class="literal">Projectile</code> fires when the robot points a gun at the target and not when the gun is looking down, we will use coroutines, one in particular—<code class="literal">WaitForSeconds</code>. This will allow us to postpone execution of the code for a specified number of seconds.</p><p><span class="strong"><strong>Coroutines</strong></span><a id="id352" class="indexterm"></a> are computer program components that generalize subroutines to allow multiple entry points for suspending and resuming execution at certain locations.</p><p>We will deal with the <code class="literal">Shooting</code> function<a id="id353" class="indexterm"></a> first. The first thing that needs to happen when this function is called is a start of our reload. Sounds strange indeed, but this is the way we need to do it to avoid problems with two projectiles spawning at the same time. It is better to eliminate the problem without even giving it a chance to appear.</p><p>As mentioned previously, we are creating a local variable of a <code class="literal">Cloth</code> type and instantiating it right at the muzzle position. Next, we are getting into a Rigidbody analogy in <code class="literal">Cloth</code> called <code class="literal">InteractiveCloth</code>
<a id="id354" class="indexterm"></a> and adding a force at a specified position in a positive <span class="strong"><strong>Z</strong></span> direction with speed captured in the <code class="literal">projectileSpeed</code> variable.</p><p>Last, but not least, we will call the <code class="literal">AddAmmo</code> function<a id="id355" class="indexterm"></a> from a <code class="literal">CH_PlayerStats</code> script and decrease the number of available ammo by one. All of it will happen in the <code class="literal">CH_Controller</code> script<a id="id356" class="indexterm"></a>, after the last line of code:</p><div class="informalexample"><pre class="programlisting">...
function Shooting(){
canShootPrime = false;
counter = true;
yield WaitForSeconds (0.5);
var bullet : Cloth = Cloth.Instantiate(Projectile, Muzzle.transform.position,Muzzle.transform.rotation);
bullet.transform.GetComponent(InteractiveCloth).AddForceAtPosition(Muzzle.transform.TransformDirection(Vector3 (projectileSpeed* 10, 0, 0)), bullet.transform.position, 1.0, ForceMode.Impulse); 
Stats.AddAmmo (0, -1);
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip002"></a>Tip</h3><a id="id357" class="indexterm"></a><p><span class="strong"><strong>A word of warning</strong></span></p><p>Do not use <code class="literal">Cloth</code> to create goo projectiles in a real project, as it will affect your performance dramatically. The example in this book is for demonstration purposes only.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec29"></a>Shooting cooldown</h4></div></div></div><a id="id358" class="indexterm"></a><a id="id359" class="indexterm"></a><p>To prevent the character from shooting goo projectiles too often, we need to add a cooldown after every shot. Perform the following steps:</p><p>At the very beginning of the <code class="literal">FixedUpdate</code> function, we need to check if <code class="literal">counter</code> is true.</p><p>Increase the <code class="literal">countTime</code> variable<a id="id360" class="indexterm"></a> with every second.</p><p>When <code class="literal">countTime</code> reaches <code class="literal">3</code> or more, we will set <code class="literal">counter</code> to <code class="literal">false</code>. Allow shooting with prime fire and reset <code class="literal">countTime</code>.</p><p>Add the following code snippet at the very beginning of the <code class="literal">FixedUpdate</code> function<a id="id361" class="indexterm"></a>:</p><div class="informalexample"><pre class="programlisting">if (counter){
    countTime += Time.deltaTime;
    if (countTime &gt;= 3.0){
        counter = false;
        canShootPrime = true;
        countTime = 0.0;
        }    
    }</pre></div><p>Now our gun can shoot only once in three seconds.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec30"></a>Alternative shooting function</h4></div></div></div><a id="id362" class="indexterm"></a><p>Now that a prime shooting function is set up, we will move to alternative fire. In video games, instantiating projectiles when shooting a rocket launcher is totally fine and desirable, because we might want to show a flying rocket. But can you imagine what will happen if we decide to apply it to a machine gun?! This would be totally unacceptable, and would lead to frame rate killing. Instead, we will use raycasting, which is cheaper and faster than instantiation of a projectile. We will use raycasting for our alternative fire to fake an assault rifle.</p><p>Again, we are using a forward vector and shooting from the <code class="literal">MuzzleAlt1</code> and <code class="literal">MuzzleAlt2</code> positions with a created ray for 100 meters (it could be less if you want).</p><p>The reason to declare a new ray is to later retrieve information from colliding objects; in our case, we will need to get information from a point where the collision occurred to place sparks in that position and emit them, as shown in the screenshot just after the following code snippet. All of the following code will go after the <code class="literal">Shooting</code> function:</p><div class="informalexample"><pre class="programlisting">function AltShooting(){
var hit: RaycastHit;
Stats.AddAmmo(1, -1);
yield WaitForSeconds (0.5)
if (Physics.Raycast(MuzzleAlt1.transform.position, MuzzleAlt1.transform.right, hit, 100) || Physics.Raycast(MuzzleAlt2.transform.position, MuzzleAlt2.transform.right, hit, 100)){
flush.transform.position = hit.point;
flush.transform.rotation = Quaternion.FromToRotation(Vector3.up, hit.normal);
flush.Emit();
}
}</pre></div><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_05.jpg" /></div><p>And that's what we do in the preceding code. We place a particle in the position of a hit. Change its rotation based on the normal of the hit surface and activate it. <a id="id363" class="indexterm"></a>Awesome, now we have a fully functional weapon, well… close to functional. If we try to shoot it now, we will find that we can't fully control it. To solve this problem, we will have to add a few more animations, to make our character move.</p><div class="mediaobject"><img src="/graphics/9781849692304/graphics/2304EXP_03_06.jpg" /></div></div></div></div>