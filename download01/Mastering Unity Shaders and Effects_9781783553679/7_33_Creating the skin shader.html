<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec32"></a>Creating the skin shader</h2></div></div><hr /></div><p>Moving beyond the purely surface qualities of the model, we need to use a representation of the relative thickness of the model to properly define the subsurface scattering effect. We can calculate the thickness within a shader and then use it to define where the effect is visible.</p><p>We will start by creating a new shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Shaders</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>In an empty part of the <span class="strong"><strong>Assets</strong></span> panel, create a new shader like we have done before. Right-click and choose <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Shader</strong></span> | <span class="strong"><strong>Standard Surface Shader</strong></span> from the drop-down list.</p></li><li><p>In the <span class="strong"><strong>Assets</strong></span> panel, rename the shader <code class="literal">SSS_Skin</code>.</p></li><li><p>Double-click on the shader to open it in MonoDevelop.</p></li><li><p>In MonoDevelop, rename the shader as follows:</p><pre class="programlisting">        Shader "PACKT/SSS_Skin" &#13;
</pre><p>Next, we will make some changes to the <code class="literal">Properties</code>.</p></li><li><p>In the <code class="literal">Properties</code> block, delete the <code class="literal">_MainTex</code>, <code class="literal">_Glossiness</code>, and <code class="literal">_Metallic</code> lines.</p><p>We need to add a bump map property to correctly show the model's detail.</p></li><li><p>Add the following line:</p><pre class="programlisting">        _BumpMap ("Normal (Normal)", 2D) = "bump" {} &#13;
</pre><p>We will also add a scale slider to control the range of the effect.</p></li><li><p>Add the following line:</p><pre class="programlisting">        _Scale ("Thickness Scale", Range(0,1)) = 0.0 &#13;
</pre><p>Within the Cg snippet, there is a variable for the <code class="literal">_MainTex</code> property that no longer exists, we will rename it to work with the bump map.</p></li><li><p>Locate the following line:</p><pre class="programlisting">        sampler2D _MainTex; &#13;
</pre></li><li><p>Rename it as follows:</p><pre class="programlisting">        sampler2D _BumpMap; &#13;
</pre></li><li><p>In the <code class="literal">Input</code> struct, delete the <code class="literal">uv_MainTex</code> variable and add the following lines:</p><pre class="programlisting">        float2 uv_BumpMap; &#13;
        float3 worldPos; //added &#13;
        float3 worldNormal; &#13;
        INTERNAL_DATA &#13;
</pre><p>The <code class="literal">uv_BumpMap</code> variable stores the UV information of the normal map. We get the <code class="literal">worldPos</code> and <code class="literal">worldNormal</code> values from Unity, defining the position and normal based on global data. These are marked as <code class="literal">INTERNAL_DATA</code>.</p></li><li><p>Delete the <code class="literal">_Glossiness</code> and <code class="literal">_Metallic</code> variables and add the following line:</p><pre class="programlisting">        half _Scale; &#13;
</pre><p>This will allow us to use our scale slider.</p><p>In the <code class="literal">surf</code> function, we need to clean up a few lines of code that we do not need any more.</p></li><li><p>Select and delete the code within the <code class="literal">surf</code> function near the bottom of the shader code.</p><p>Next, we need to unpack our normal map as this will be used for the thickness.</p></li><li><p>Add the following line:</p><pre class="programlisting">        float3 n = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap)); &#13;
</pre><p>We will create a new variable for the normal so that it can be used in another calculation. We will specify the property name and the UV coordinates that we have previously added.</p></li><li><p>Add the next line of code:</p><pre class="programlisting">        float thickness = length (fwidth (WorldNormalVector (IN, &#13;
          n)))/length (fwidth (IN.worldPos)) * _Scale;&#13;
</pre><p>Here, we will create the variable thickness and calculate it using the <code class="literal">WorldNormal</code> and <code class="literal">WorldPos</code> variables that we get from Unity. We will multiply the result using our <code class="literal">_Scale</code> value as the factor.</p><p>We need to add a line of code to specify the output albedo.</p></li><li><p>Add the following line:</p><pre class="programlisting">        o.Albedo = _Color.rgb * thickness; &#13;
</pre><p>We will multiply the <code class="literal">Color</code> RGB values by our new thickness value. This will allow us to tint the thinnest parts of the model to see the effect more clearly.</p></li><li><p>Finally, add the output alpha line:</p><pre class="programlisting">        o.Alpha = _Color.a; &#13;
</pre><p>We set the alpha to be equal to the alpha channel value in the color used in the shader.</p></li><li><p>Save the shader and return to the main Unity interface.</p><p>Now that we have written the shader, let's use this in the astronaut's material and view it in our scene.</p></li><li><p>In the <code class="literal">PACKT_Materials</code> folder, locate and select the <code class="literal">Astronaut_crewsuit</code> material.</p></li><li><p>At the top of the<span class="strong"><strong> Inspector</strong></span>, set the material's shader to <span class="strong"><strong>PACKT</strong></span> | <span class="strong"><strong>SSS_Skin</strong></span> from the drop-down list.</p><p>The character's appearance will change in the <span class="strong"><strong>Scene</strong></span> and <span class="strong"><strong>Game</strong></span> views.</p></li><li><p>Reduce the <span class="strong"><strong>Thickness Scale</strong></span> value to <code class="literal">0.01</code>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_07_002.jpg" /><div class="caption">The calculated thickness visualized on the character model</div></div><p>
</p></li></ol></div><p>Thinner parts of the mesh will be lighter and tinted by the color that you choose in the material. It is the thin areas of the skin where we want to introduce the subsurface scattering to simulate the diffusion on light beneath the surface.</p><p>In the next step, we will add some texture inputs to the shader and make the subsurface effect dependent on lighting.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec36"></a>Adding complexity to the skin shader</h3></div></div></div><p>We have got a representation of the model's thickness, but we need to add the relevant input maps and the lighting calculation that will get the skin looking right.</p><p>Let's add the properties that we need first:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Back in MonoDevelop, add the following lines to the shader's <code class="literal">Properties</code> block:</p><pre class="programlisting">        _MainTex ("Albedo (RGB)", 2D) = "white" {} &#13;
        _Metallic ("Metal (R), Smoothness (A)", 2D) = "white" {} &#13;
</pre><p>We stripped these properties out of the shader previously, but we need the character's base albedo and metallic/smoothness inputs to approximate the surface color and level of shininess.</p></li><li><p>Next, add the following lines:</p><pre class="programlisting">        _SSS_Color ("Subsurface Color", Color) = (1.0, 1.0, 1.0, 1.0) &#13;
        _Diffusion ("Subsurface Diffusion", Float) = 0.0 &#13;
</pre><p>We will add an additional color property, <code class="literal">_SSS_Color</code>, for the subsurface color, freeing <code class="literal">_Color</code> to be used to tint the whole material as usual.</p><p>The diffusion property will be used to determine the depth of the light-scattering effect.</p></li><li><p>Within the Cg snippet, locate the <code class="literal">sampler2d _BumpMap</code> line and add the following code under it:</p><pre class="programlisting">        sampler2D _MainTex; &#13;
        sampler2D _Metallic; &#13;
</pre><p>Here, we set up the local variables to handle the texture input.</p><p>When we added the bump map, we amended the UV coordinate variable in the <code class="literal">Input</code> struct to use the coordinates tied to <code class="literal">_BumpMap</code>. We will amend this next.</p></li><li><p>Locate the <code class="literal">float2 uv_BumpMap</code> line in the <code class="literal">Input</code> struct.</p></li><li><p>Replace it with the following:</p><pre class="programlisting">        float2 uv_MainTex; &#13;
</pre><p>All our input maps will share the same UV coordinates.</p></li><li><p>After the closing bracket and semicolon of the <code class="literal">Input</code> struct, add the remaining variables:</p><pre class="programlisting">        fixed4 _SSS_Color; &#13;
        float _Diffusion; &#13;
</pre><p>We will use a <code class="literal">fixed4</code> type variable for the <code class="literal">_SSS_Color </code>property to handle all four channels of the color. The <code class="literal">_Diffusion</code> variable is set up as a float.</p></li><li><p>In the <code class="literal">surf</code> function, add the following lines:</p><pre class="programlisting">        fixed4 c = tex2D (_MainTex, IN.uv_MainTex); &#13;
        fixed4 m = tex2D (_Metallic, IN.uv_MainTex); &#13;
</pre><p>Both texture inputs use the same <code class="literal">_MainTex</code> UV coordinates.</p><p>We need to use the same UV coordinates in the bump map.</p></li><li><p>In the <code class="literal">float3 n</code> line, replace the <code class="literal">uv_BumpMap</code> reference with <code class="literal">uv_MainTex</code>.</p></li><li><p>Adjust the <code class="literal">o.Albedo</code> line to include the main texture and subsurface color <code class="literal">rgb</code> values by replacing it with the following:</p><pre class="programlisting">        o.Albedo = c.rgb * _Color.rgb; &#13;
</pre><p>We add the product of <code class="literal">SSS_Color</code> and <code class="literal">thickness</code> to the main texture <code class="literal">rgb</code>, essentially masking the color with the thickness.</p></li><li><p>Add the output lines for <code class="literal">Metallic</code> and <code class="literal">Smoothness</code> to use the relevant channels of the <code class="literal">_Metallic</code> texture map:</p><pre class="programlisting">        o.Metallic = m.r; &#13;
        o.Smoothness = m.a; &#13;
        Save the shader. &#13;
</pre></li><li><p>Return to the main Unity interface.</p><p>When the shader has compiled, there should be two additional texture slots in the <code class="literal">SSS_Skin</code> material in the <span class="strong"><strong>Inspector</strong></span>.</p><p>The appropriate textures are located in the <code class="literal">astronaut_crewsuit</code> subfolder within the <code class="literal">PACKT_Textures</code> project folder.</p></li><li><p>Drag the <code class="literal">crewsuit_albedo</code> texture to the material's <span class="strong"><strong>Albedo</strong></span> slot.</p></li><li><p>Next, drag the <code class="literal">crewsuit_metallic</code> texture to the material's <span class="strong"><strong>Metallic</strong></span> slot.</p></li><li><p>Change the <span class="strong"><strong>Color</strong></span> swatch at the top of the material back to white.</p></li><li><p>Set the <span class="strong"><strong>SSS_Color</strong></span> swatch to a bright red color.</p></li></ol></div><p>The results should appear as shown in the <span class="strong"><strong>Scene</strong></span> view:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_07_003.jpg" /><div class="caption">The calculated thickness added to the albedo with the subsurface color</div></div><p>
</p><p>At the moment, we have a nice glow effect on the thinner parts of the character, but for a better subsurface effect, we will integrate a custom lighting model.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec37"></a>Writing the custom lighting model</h3></div></div></div><p>At this stage, we want to add better interaction with the scene lighting. To create the appearance of translucency, we want thinner areas of the character model to show more bounced light if they have light behind them.</p><p>This will be handled in a custom light model:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Back in MonoDevelop, add the following code after the <code class="literal">surf</code> function's closing bracket:</p><pre class="programlisting">        inline fixed4 LightingSkinSSS (SurfaceOutput s, fixed3 lightDir, &#13;
          fixed3 viewDir, fixed atten)&#13;
        { &#13;
 &#13;
        } &#13;
</pre><p>Within the lighting model, we will grab the light direction, view direction, and attenuation ready to be used in our calculations.</p><p>We need to further define the light direction and how this interacts with the surface normal.</p></li><li><p>Add the following code after the opening bracket:</p><pre class="programlisting">        half3 diffLightDir = lightDir + s.Normal * _Diffusion; &#13;
        float transDot = max(0, dot(viewDir, -diffLightDir)) * _Scale; &#13;
        fixed3 transLight = transDot * _SSS_Color.rgb * atten; &#13;
        fixed3 transAlbedo = transLight * s.Albedo * _LightColor0.rgb; &#13;
</pre></li></ol></div><p>Here, we will create a variable called <code class="literal">diffLightDir</code>, which is a combination of <code class="literal">lightDir</code> and the surface normal, multiplied by the diffusion.</p><p>The next variable, <code class="literal">transDot</code>, returns a float value that is the result of the highest value of <code class="literal">viewDir</code> multiplied by the inversed <code class="literal">diffLightDir</code> and zero. The result is multiplied by our <code class="literal">_Scale</code> value.</p><p>Following this, we will create a <code class="literal">fixed3</code> variable, <code class="literal">transLight</code>, which is the product of <code class="literal">transDot</code>, the defined subsurface color and the light's attenuation.</p><p>Lastly, we will define <code class="literal">transAlbedo</code> as the product of <code class="literal">transLight</code>, the surface albedo and the light color.</p><p>The next calculations will define the light's effect on the surface:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following code:</p><pre class="programlisting">        half3 h = normalize (lightDir + viewDir); &#13;
        fixed diff = max(0, dot (s.Normal, lightDir)); &#13;
        float nh = max(0, dot(s.Normal, h)); &#13;
        float spec = pow (nh, s.Specular * 128.0) * s.Gloss; &#13;
        fixed3 diffAlbedo = (s.Albedo * (_LightColor0.rgb * diff) + &#13;
            (_LightColor0.rgb * spec)) * atten;&#13;
</pre><p>Here, we have added standard Unity <span class="strong"><strong>Blinn-Phong</strong></span> lighting to take care of the areas of the model where we do not see the subsurface effect.</p><p>Finally, we will process the albedo to include the diffused and translucent light additives:</p></li><li><p>Add the following code:</p><pre class="programlisting">        fixed4 c; &#13;
        c.rgb = diffAlbedo + transAlbedo; &#13;
        c.a = _LightColor0.a * atten; &#13;
        return c; &#13;
</pre><p>At this point, our shader may compile correctly, but we still need to make it use the new lighting model and adjust a few incompatible output types.</p></li><li><p>Near the top of the Cg snippet, locate the shader compile directive:</p><pre class="programlisting">        #pragma surface surf Standard fullforwardshadows &#13;
</pre></li><li><p>Make it to point to our new lighting model by amending it as follows:</p><pre class="programlisting">        #pragma surface surf SkinSSS fullforwardshadows &#13;
</pre></li><li><p>Scroll down to the <code class="literal">surf</code> function and replace the reference to <code class="literal">SurfaceOutputStandard</code> with <code class="literal">SurfaceOutput</code>.</p></li><li><p>Remove the <code class="literal">Metallic</code> output line to comply with the default surface output list.</p></li><li><p>Rename the <code class="literal">o.Smoothness</code> line to the following:</p><pre class="programlisting">        o.Gloss = m.a * m.r; &#13;
</pre></li><li><p>Save the shader.</p></li><li><p>Return to the main Unity interface to see the result in the <span class="strong"><strong>Scene</strong></span> and <span class="strong"><strong>Game </strong></span>views.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_07_004.jpg" /><div class="caption">The result of the custom lighting model</div></div><p>
</p></li></ol></div><p>The result is more subtle, with the diffusion working correctly, the light will appear to be more scattered rather than appearing as a surface glow.</p><p>At the moment, the subsurface effect appears across the whole model as the astronaut's body has a single material.</p><p>We can limit this to just the skin areas by using a texture map instead of calculating the thickness in the shader. We already have a thickness map ready to go. We will add this next.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec15"></a>Adding the thickness map input to the shader</h4></div></div></div><p>Using a texture map to define the thickness of the character for subsurface scattering makes it possible to apply the effect selectively to the model.</p><p>Let's start by taking a look at the map:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select the character's mesh by clicking on <code class="literal">PACKT_astronaut_crewSuit</code> in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p><p>Its components will appear in the <span class="strong"><strong>Inspector</strong></span>.</p></li><li><p>In the material components at the bottom, click on the character's albedo map.</p><p>The texture file will become highlighted in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Click the source texture, <code class="literal">crewsuit_albedo</code>, to see its import settings.</p></li><li><p>Within the material preview, click on the small RGB icon to see the texture's alpha map:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_07_005.jpg" /><div class="caption">The crewsuit_albedo texture's alpha channel</div></div><p>
</p><p>This thickness map has been generated in an external application. The thickness is only defined for the skin parts of the character, the other areas are left black and will not be affected.</p><p>We need to make a few changes to the shader code to use this map.</p></li><li><p>Return to MonoDevelop.</p></li><li><p>At the top of the shader, change the <code class="literal">_MainTex</code> property to read as follows:</p><pre class="programlisting">        _MainTex ("Albedo (RGB), Thickness (A)", 2D) = "white" {} &#13;
</pre></li><li><p>In the <code class="literal">Input</code> struct, delete the following lines of code:</p><pre class="programlisting">        float3 worldPos; &#13;
        float3 worldNormal; &#13;
        INTERNAL_DATA &#13;
</pre></li><li><p>In the lighting model, locate the <code class="literal">transLight</code> line and replace it with the following:</p><pre class="programlisting">        fixed3 transLight = transDot * s.Alpha * _SSS_Color.rgb * atten; &#13;
</pre><p>This will include the alpha channel in the translucency calculation.</p></li><li><p>Save the shader.</p></li><li><p>Return to the main Unity interface to see the results:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_07_006.jpg" /><div class="caption">The completed skin shader</div></div><p>
</p></li></ol></div><p>In the next section, we will create a custom eye shader.</p></div></div></div>