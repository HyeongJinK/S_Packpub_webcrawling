<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec16"></a>Creating a wireframe emissive material for the planet-surface scanner</h2></div></div><hr /></div><p>eow that we have demonstrated the use of emissive materials to create effects and light up our scene, we will go one step further and create a wireframe material to represent scanning the planet's surface. Rather than illuminating a part of the object's surface, we will be lighting up the object's geometric edges using this very specialized shader.</p><p>We will start by creating a new shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Shaders</code> folder.</p><p>When the folder's contents appear in the <span class="strong"><strong>Assets</strong></span> panel, create a new shader.</p></li><li><p>Right-click in an empty area of the panel, click on <span class="strong"><strong>Create</strong></span>, and choose <span class="strong"><strong>Shader</strong></span>.</p></li><li><p>Rename the new shader <code class="literal">Unlit_wire</code>.</p></li><li><p>In the <span class="strong"><strong>Assets</strong></span> panel, double-click on <code class="literal">Unlit_wire</code> to open it in <span class="strong"><strong>MonoDevelop</strong></span>.</p></li><li><p>When the shader opens in MonoDevelop, change the shader's directory by replacing the first line of code with the following:</p><pre class="programlisting">        Shader "PACKT/unlit_wireframe" { 
</pre></li><li><p>Select the <code class="literal">Properties</code> block and replace it with the following:</p><pre class="programlisting">        Properties 
        { 
            _Color ("Color", Color) = (0,0,0,0) 
            _EdgeColor ("Edge Color", Color) = (0,1,0,1) 
            _Width ("Width", float) = 0.1 
        } 
</pre><p>These are the three properties that our shader needs.</p><p>The <code class="literal">_Color</code> property defines an RGBA value that the model will use. The <code class="literal">_EdgeColor</code> property will define the unlit color of the wire. Lastly, <code class="literal">_Width</code> will define the thickness of the outline.</p></li><li><p>In the <code class="literal">subShader</code> block, replace the <code class="literal">Tags</code> line with the following code:</p><pre class="programlisting">        Tags { "RenderType"="Transparent" "Queue"="Transparent" } 
</pre><p>This line of code will allow the shader to be transparent.</p><p>The shader requires two passes to render the front and back faces of the geometry separately. We will create the first pass by defining it with tags and defining how it is blended.</p></li><li><p>Add the following code:</p><pre class="programlisting">        Pass 
        { 
            Blend SrcAlpha OneMinusSrcAlpha 
            Cull Front 
            AlphaTest Greater 0.5 
        } 
</pre><p>The Blend mode defines how the pass is added to the rest of the shader. There are two factors included here—the <span class="strong"><strong>source texture</strong></span> and the <span class="strong"><strong>destination texture</strong></span>. When we are just blending alphas, we will define this by writing Alpha as the source and/or destination.</p><p>The next line allows us to not render the front faces of the model. The front faces will be rendered in the second pass. We keep this order to render far away things first and avoid z-fighting issues.</p><p>The last line allows us to use cutout transparency, which will define pixels as completely transparent or completely opaque. Using real, per pixel transparency here would be costly to performance, and our Bloom effect would negate the visual clarity anyway.</p><p>The meat of the code uses a <span class="strong"><strong>Cg</strong></span> snippet.</p></li><li><p>Add the following code within the brackets of the pass beneath the <code class="literal">Blend</code> line:</p><pre class="programlisting">        CGPROGRAM 
        #pragma vertex vert 
        #pragma fragment frag 
 
        uniform float4 _Color; 
        uniform float4 _EdgeColor; 
        uniform float _Width; 
</pre><p>Here we will select the Cg shader elements to use and define our properties as variables we can use in the shader.</p></li><li><p>Next, add the following code:</p><pre class="programlisting">        struct appdata 
        { 
            float4 vertex : POSITION; 
            float4 texcoord1 : TEXCOORD0; 
            float4 color : COLOR; 
        }; 
</pre><p>Here, we are defining local variables that we use in our shader, such as vertex positions, texture coordinates, and a color.</p></li><li><p>Then, add the following code:</p><pre class="programlisting">        struct v2f 
        { 
            float4 pos : POSITION; 
            float4 texcoord1 : TEXCOORD0; 
            float4 color : COLOR; 
        }; 
</pre><p>Here, we will define the variables used for the vertex to fragment calculation that allows us to make the geometry visible in the scene.</p><p>Next, we need to define how this data is used in the shader.</p></li><li><p>Add the following code:</p><pre class="programlisting">        v2f vert (appdata v) 
        { 
            v2f o; 
            o.pos = mul( UNITY_MATRIX_MVP, v.vertex); 
            o.texcoord1 = v.texcoord1; 
            o.color = v.color; 
            return o; 
        } 
</pre><p>This block of code uses <code class="literal">appdata v</code> variable that we previously defined.</p><p>We will define the vertex to fragment the <code class="literal">o</code> variable (output), and then define the output color as the vertex color we have already defined using the UV coordinates.</p><p>Lastly, we will define the fragment part of the shader:</p></li><li><p>Add the following code:</p><pre class="programlisting">        fixed4 frag(v2f i) : COLOR 
        { 
            fixed4 answer; 
 
            float lx = step(_Width, i.texcoord1.x); 
            float ly = step(_Width, i.texcoord1.y); 
            float hx = step(i.texcoord1.x, 1.0 - _Width); 
            float hy = step(i.texcoord1.y, 1.0 - _Width); 
 
            answer = lerp(_EdgeColor, _Color, lx*ly*hx*hy); 
 
            return answer; 
        } 
        ENDCG 
</pre><p>Here, we are defining the final appearance of the geometry based on the properties that we defined at the top of the shader, and our vertex data that we got from the geometry.</p><p>Finally, we end the Cg snippet using <code class="literal">ENDCG</code>.</p></li><li><p>Delete the remaining default code within the <code class="literal">subShader</code>.</p></li><li><p>Save the shader and return to the main Unity interface.</p></li></ol></div><p>In the next step, we will use the shader in our scene.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec22"></a>Viewing the wireframe emissive shader in the scene</h3></div></div></div><p>We already have the geometry and a material in the scene that will use this shader.</p><p>The object is a sphere positioned in front of the ship's control console. The <code class="literal">planetscan</code> object represents the ship's scan of the planet's surface as it begins its descent to the surface.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> view, click on the <code class="literal">planetscan</code> object.</p><p>Its properties will appear in the <span class="strong"><strong>Inspector</strong></span>.</p></li><li><p>Uncheck the checkbox in the top left-hand corner of the <span class="strong"><strong>Inspector</strong></span> to make the game object visible:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/3529_03_08.jpg" /><div class="caption">The planetscan game object visible in the scene</div></div><p>
</p><p>At the bottom of the <span class="strong"><strong>Inspector</strong></span>, the object's current material is displayed. It is currently set to use a default Standard Shader material.</p></li><li><p>Click on the <span class="strong"><strong>Shader</strong></span> dropdown and select <code class="literal">PACKT - wireframeEmissive</code>.</p><p>The properties in the <span class="strong"><strong>Inspector</strong></span> will update to show those contained in the shader that we created.</p></li><li><p>Click on the color swatch next to the <span class="strong"><strong>Color</strong></span> property and set the alpha channel value to zero.</p></li><li><p>Click the <span class="strong"><strong>Edge Color</strong></span> swatch and enter the code <code class="literal">12F7BFFF</code> into the hex code field at the bottom of the color picker.</p></li><li><p>Set the <span class="strong"><strong>Width</strong></span> to a value of <code class="literal">0.01</code>.</p></li></ol></div><p>As our material is already being used in the scene, we should be able to see these changes on the <code class="literal">planetscan</code> object instantly:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/3529_03_09.jpg" /><div class="caption">The planetscan object with the wireframe shader</div></div><p>
</p><p>The wireframe shader responds to the Bloom effect really well as it is unlit; it is not otherwise affected by the scene lighting.</p><p>Note that just the back faces of the sphere are being rendered here.</p><p>At this point, we can return to MonoDevelop and add the second pass to render the front face of the sphere.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>Adding the wireframe shader's second pass</h3></div></div></div><p>Using the additional pass will allow us to render both sides of the sphere wireframe in a clean way:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Maximize MonoDevelop.</p></li><li><p>Select the entire <code class="literal">Pass</code> in the shader.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Tip</h3><p>If you select the opening bracket directly beneath the <code class="literal">Pass</code> tag, MonoDevelop will highlight the closing bracket allowing you to visualize the end of the block of code.</p></div></li><li><p>Copy the selected code by right-clicking and selecting <span class="strong"><strong>Copy</strong></span> from the drop-down list or using the <span class="emphasis"><em>Ctrl + C</em></span> hotkey combination (or <span class="emphasis"><em>Command + C</em></span> if you are working on a Mac).</p></li><li><p>Paste the copied code directly after the closing bracket. Use <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> + <span class="emphasis"><em>
<span class="strong"><strong>V</strong></span>
</em></span> (<span class="emphasis"><em>
<span class="strong"><strong>Command</strong></span>
</em></span> + <span class="emphasis"><em>
<span class="strong"><strong>V </strong></span>
</em></span>on a Mac), or the <span class="strong"><strong>Paste</strong></span> option from the right-click selection dropdown.</p><p>The code for the second pass is almost the same, we just need to cull the back faces rather than the front.</p></li><li><p>Near the top of the pasted <code class="literal">Pass</code>, locate the following line of code:</p><pre class="programlisting">        Cull Front 
</pre></li><li><p>Replace it with the following line:</p><pre class="programlisting">        Cull Back 
</pre></li><li><p>Save the shader.</p></li></ol></div><p>Return to the main Unity interface.</p><p>The shader should update automatically, allowing you to view the complete <code class="literal">planetScan</code> sphere in the <span class="strong"><strong>Game</strong></span> view:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/3529_03_10.jpg" /><div class="caption">The planetscan object now showing the additional shader pass</div></div><p>
</p><p>In the next step, we will add a projection cone to the sphere to complete this effect.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec9"></a>Completing the planet scan projection effect</h4></div></div></div><p>We can get the planet scan looking a little more like a projection by adding some more polish to the effect:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Models</code> folder.</p></li><li><p>The contents of the folder will appear in the <span class="strong"><strong>Assets </strong></span>panel.</p></li><li><p>In the <span class="strong"><strong>Assets</strong></span> panel, locate the <code class="literal">projectionCone</code> asset.</p><p>This is a simple cone model created in an external three-dimensional application. A lot of the time, Unity's primitives work great for simple effects, but at the time of writing, Unity does not have a cone primitive.</p></li><li><p>Drag <code class="literal">projectionCone</code> from the <span class="strong"><strong>Assets</strong></span> panel into the <span class="strong"><strong>Hierarchy</strong></span> panel to add it to the scene.</p></li><li><p>In the <span class="strong"><strong>Scene</strong></span> view, transform tools and the <span class="strong"><strong>Inspector</strong></span> to rotate the cone so that it is completely inverted and positioned directly beneath the <code class="literal">planetScan</code> sphere:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/3529_03_11.jpg" /><div class="caption">The unhidden projectionCone object in its initial state</div></div><p>
</p></li><li><p>When it is positioned correctly, drag the <code class="literal">PlanetScan</code> material from the <span class="strong"><strong>Assets</strong></span> panel onto the <code class="literal">projectionCone</code> game object:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/3529_03_12.jpg" /><div class="caption">The projectionCone object using the wireframe shader</div></div><p>
</p></li></ol></div><p>We have completed the setup of the emissive surfaces in our scene.</p><p>At this point, we should have a more interesting scene. We will continue adding to this in the next chapter.</p></div></div></div>