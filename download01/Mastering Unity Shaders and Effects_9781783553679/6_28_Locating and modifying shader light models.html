<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec28"></a>Locating and modifying shader light models</h2></div></div><hr /></div><p>When we have created shaders so far, we have relied on the default template that Unity provides and is easily accessible in the <span class="strong"><strong>Assets</strong></span> panel.</p><p>Let's start here and identify the part of the shader that handles scene lighting.</p><p>We will start by creating a default shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Shaders</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>In an empty area of the <span class="strong"><strong>Assets</strong></span> panel, create a new default shader. Right-click and navigate to <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Shader</strong></span> | <span class="strong"><strong>Standard Surface Shader</strong></span> from the drop-down list.</p></li><li><p>Rename the shader <code class="literal">TestLambert</code>.</p></li><li><p>Double-click on the new shader to open it in MonoDevelop.</p></li><li><p>In MonoDevelop, replace the first line with the following code:</p><pre class="programlisting">            Shader "PACKT/TestLambert" { &#13;
</pre></li><li><p>Locate the shader compile directives. This is the code within the Cg snippet that will be highlighted in magenta by default:</p><pre class="programlisting">            // Physically based Standard lighting model, and enable shadows on all light types &#13;
            #pragma surface surf Standard fullforwardshadows &#13;
 &#13;
            // Use shader model 3.0 target, to get nicer looking lighting &#13;
            #pragma target 3.0 &#13;
</pre><p>The lines of comment outline the function of the code, but the keywords actually refer to some external code that handles the lighting.</p><p>The <code class="literal">Standard</code> keyword defines a set of inputs that the shader uses, which is also accessed from an external source.</p><p>This code is contained in a Cg file called <code class="literal">UnityPBSLighting.cginc</code>, which is located in the following path within the Unity program file location on your machine:</p><p>
<span class="strong"><strong>Editor</strong></span> | <span class="strong"><strong>Data</strong></span> | <span class="strong"><strong>CGIncludes</strong></span>.</p></li><li><p>Navigate to this folder and open this file in MonoDevelop by double-clicking on it.</p></li><li><p>When the file opens in MonoDevelop, scroll down until you see the following code:</p><pre class="programlisting">            struct SurfaceOutputStandard &#13;
            { &#13;
                fixed3 Albedo; // base (diffuse or specular) color &#13;
                fixed3 Normal; // tangent space normal, if written &#13;
                half3 Emission; &#13;
                half Metallic; // 0=non-metal, 1=metal &#13;
                half Smoothness; // 0=rough, 1=smooth &#13;
                half Occlusion; // occlusion (default 1) &#13;
</pre></li></ol></div><p>This data structure defines the output types that we have been using in the Standard Shaders. Variables such as <code class="literal">fixed3</code> are called packed arrays; <code class="literal">fixed3</code> is a collection of three fixed variables.</p><p>The variables <code class="literal">float</code>, <code class="literal">half</code>, and <code class="literal">fixed</code> are all actually float variables of different precision.</p><p>These are outlined really well in Unity's official documentation, available at <a class="ulink" href="https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html" target="_blank">https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html</a>.</p><p>To summarize:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">float</code>: 32 bits, highest level of precision</p></li><li style="list-style-type: disc"><p>
<code class="literal">half</code>: 16 bits with three decimal digits of precision</p></li><li style="list-style-type: disc"><p>
<code class="literal">fixed</code>: 11 bits, lowest level of precision</p></li></ul></div><p>These variables are used in the shader based on how they are used. Typically, higher level calculations, such as those involving world coordinates, are done at a higher precision.</p><p>We will discuss these factors in <a class="link" href="#" linkend="ch09">Chapter 8</a>, <span class="emphasis"><em>Optimizing Shaders for Mobile</em></span>.</p><p>Next in the code is the lighting model:</p><pre class="programlisting">inline half4 LightingStandard (SurfaceOutputStandard s, half3 viewDir, UnityGI gi) &#13;
{ &#13;
    s.Normal = normalize(s.Normal); &#13;
    half oneMinusReflectivity; &#13;
    half3 specColor; &#13;
    s.Albedo = DiffuseAndSpecularFromMetallic (s.Albedo, s.Metallic, /*out*/ specColor, /*out*/ &#13;
      oneMinusReflectivity);&#13;
    // shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha) &#13;
    // this is necessary to handle transparency in physically correct way - only diffuse component gets &#13;
      affected by alpha&#13;
    half outputAlpha; &#13;
    s.Albedo = PreMultiplyAlpha (s.Albedo, s.Alpha, oneMinusReflectivity, /*out*/ outputAlpha); &#13;
    half4 c = UNITY_BRDF_PBS (s.Albedo, specColor, oneMinusReflectivity, s.Smoothness, s.Normal, &#13;
      viewDir, gi.light, gi.indirect);&#13;
    c.rgb += UNITY_BRDF_GI (s.Albedo, specColor, oneMinusReflectivity, s.Smoothness, s.Normal, &#13;
      viewDir, s.Occlusion, gi);&#13;
    c.a = outputAlpha; &#13;
    return c; &#13;
} &#13;
</pre><p>This block of code defines how the shader reacts to the light, it includes global illumination, which in this case is calculated in <code class="literal">UnityGI</code>, another external Cg file. In the sixth and seventh lines of proper code, we see that the lighting calculation uses <code class="literal">UNITY_BRDF_PBS</code> and <code class="literal">UNITY_BRDF_GI</code>. These definitions are included in an external file and assembled here using the surface output components.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note33"></a>Note</h3><p>The acronym <span class="strong"><strong>BRDF</strong></span> stands for <span class="strong"><strong>Bidirectional Reflectance Distribution Function</strong></span>. This is the lighting function that processes the scene light direction and strength with the surface normal and view direction to correctly affect the surface.</p></div><p>In the next step, we will switch to a simpler lighting model that we can fit entirely in our shader.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec34"></a>Modifying the shader lighting model</h3></div></div></div><p>To see the lighting model working directly in our shader, we need to start with the compile directive:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In MonoDevelop, return to the <code class="literal">TestLambert.shader</code> tab.</p></li><li><p>Locate the shader compile directive:</p><pre class="programlisting">            #pragma surface surf Standard fullforwardshadows &#13;
</pre></li><li><p>Replace this with the following:</p><pre class="programlisting">            #pragma surface surf Lambert &#13;
</pre></li></ol></div><p>Lambert is one of the simpler and cheaper lighting models as it does not include surface highlights.</p><p>If we save the shader at this point, Unity will show a syntax error in the console panel.</p><p>We need to define properties and surface output that are compatible with the lighting model.</p><p>We will start with the <span class="strong"><strong>Properties</strong></span> section:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <code class="literal">Properties</code> block, near the top of the shader, delete the following lines of code:</p><pre class="programlisting">            _Glossiness ("Smoothness", Range(0,1)) = 0.5 &#13;
            _Metallic ("Metallic", Range(0,1)) = 0.0 &#13;
</pre><p>We should also delete the variables that are created to accommodate these properties.</p></li><li><p>Select and delete the following lines of code:</p><pre class="programlisting">            half _Glossiness; &#13;
            half _Metallic; &#13;
</pre></li><li><p>In the <code class="literal">surf</code> function that follows the variables, remove the <code class="literal">Standard</code> keyword from the opening line.</p><p>Omitting this will tell Unity to use the built-in <code class="literal">SurfaceOutput</code> struct for this shader.</p><p>We have a few more changes to make to the <code class="literal">surf</code> function.</p></li><li><p>Select and delete the following lines of code:</p><pre class="programlisting">            o.Metallic = _Metallic; &#13;
            o.Smoothness = _Glossiness; &#13;
</pre></li><li><p>Save the shader.</p></li></ol></div><p>At this point, there should be no compile errors in the main Unity interface.</p><p>The shader compiled because we used another built-in lighting model by using the Lambert keyword in our compile directive.</p><p>The code that defines this model is located in another <code class="literal">CGIncludes</code> file called <code class="literal">Lighting.cginc</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip34"></a>Tip</h3><p>The advantage of separating lighting models and shader inputs is that it will reduce the processing time when multiple shaders share the same code.</p></div><p>We can apply the shader to an existing scene material to see how it looks:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, select the rover game object.</p><p>The object's components will appear in the <span class="strong"><strong>Inspector</strong></span>.</p></li><li><p>Scroll down until the rover's <span class="strong"><strong>Mesh Renderer</strong></span> component is visible.</p></li><li><p>Click on the small arrow next to the <code class="literal">Rover</code> material to expand it.</p></li><li><p>Switch to the new shader by clicking the <span class="strong"><strong>Shader</strong></span> button and choosing <span class="strong"><strong>PACKT</strong></span> | <span class="strong"><strong>TestLambert</strong></span> from the drop-down list.</p><p>You will see some major differences in the <span class="strong"><strong>Scene</strong></span> view:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_06_010.jpg" /><div class="caption">The rover model with Standard Specular material (left) and TestLambert material (right)</div></div><p>
</p><p>The metallic parts of the rover have become dark as this part of the model is handled mainly by the specular and glossiness channels of the original shader, and these are not present in the <code class="literal">TestLambert</code> shader.</p><p>In the next step, we will get all the external code into our shader so that we can make further changes.</p></li><li><p>Locate this file within the <code class="literal">CGIncludes</code> folder and open it in MonoDevelop.</p></li><li><p>First, locate the <code class="literal">SurfaceOutput</code> struct:</p><pre class="programlisting">            struct SurfaceOutput { &#13;
                fixed3 Albedo; &#13;
                fixed3 Normal; &#13;
                fixed3 Emission; &#13;
                half Specular; &#13;
                fixed Gloss; &#13;
                fixed Alpha; &#13;
            }; &#13;
</pre><p>This set of variables is defined as those used by the shader, so we need to copy this code into ours.</p></li><li><p>Select and copy the block of code.</p></li><li><p>Return to the <code class="literal">TestLambert.shader</code> tab in MonoDevelop and paste the code right after the shader variables.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p>The <code class="literal">SurfaceOutput</code> struct actually contains a bunch of variables (<code class="literal">Normal</code>, <code class="literal">Emission</code>, <code class="literal">Specular</code>, and <code class="literal">Gloss</code>) that we do not need in this shader. They are included because the struct is used for multiple shaders within Unity's framework. Leaving the extra variables here does not significantly contribute to the processing at runtime.</p></div><p>If we save the shader at this point, we will get some conflicts. The shader is still pointing to the built-in <code class="literal">Lambert</code> lighting model and we have a <code class="literal">SurfaceOutput</code> struct with the same name as the struct in this file.</p><p>The solution is to give the lighting model a unique name.</p></li><li><p>Locate the shader compile directive:</p><pre class="programlisting">            #pragma surface surf Lambert &#13;
</pre></li><li><p>Replace it with the following line:</p><pre class="programlisting">            #pragma surface surf MyLambert &#13;
</pre><p>We will still get compile errors at this point, as we are calling a lighting model that has not yet been defined.</p></li><li><p>Next, locate the <code class="literal">SurfaceOutput</code> struct and rename it <code class="literal">SurfaceOutputMyLambert</code>.</p><p>This will force the shader to use the internal surface output variables, rather than the built-in set, when it compiles.</p></li><li><p>After this struct, add the following code:</p><pre class="programlisting">            inline fixed4 LightingMyLambert (SurfaceOutputMyLambert s, fixed3 lightDir, half3 viewDir, &#13;
              fixed atten)&#13;
            { &#13;
                fixed diff = max (0, dot (s.Normal, lightDir)); &#13;
 &#13;
                fixed4 c; &#13;
                c.rgb = s.Albedo * _LightColor0.rgb * diff; &#13;
                c.a = s.Alpha; &#13;
                return c; &#13;
            } &#13;
</pre><p>Here, we are defining a new lighting model with a unique name, <code class="literal">LightingMyLambert</code>.</p><p>The lighting model uses the output variables from the struct, as well as lighting, view direction, and attenuation variables that we get from Unity.</p><p>The <code class="literal">diff</code> variable is a low-precision float derived from the surface normal, multiplied by the light direction. The <code class="literal">max</code> operator takes the highest number between this dot product and the other provided value, 0.</p><p>The variable defines the surface color. This is produced by multiplying the albedo by the light color and our <code class="literal">diff</code> variable.</p><p>The <code class="literal">_LightColor0</code> variable is obtained from Unity. This is the first light in the light array, it is usually a directional light.</p></li><li><p>Scroll down to the <code class="literal">surf</code> function and amend the opening line to use the new output variables list:</p><pre class="programlisting">            void surf (Input IN, inout SurfaceOutputMyLambert o) { &#13;
</pre></li><li><p>Save the shader and return to the main Unity interface.</p></li></ol></div><p>Unless anything has been missed, the shader should compile as before. This time, it is not accessing the external <code class="literal">CGIncludes</code> files.</p><p>In the next section, we will create a more complex lighting model for our scene.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec35"></a>Adding specularity to our custom lighting model</h3></div></div></div><p>The Lambert lighting model does not allow us to add specular highlights to our surfaces. Adding these highlights requires view directional data. We need to know where the surface is being viewed from, rather than just where the light is.</p><p>For this, we can use Unity's built-in view direction variable, <code class="literal">viewDir</code>.</p><p>Let's start by making a copy of the shader so that we can compare them:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Assets</strong></span> panel, select the <code class="literal">TestLambert</code> shader and duplicate it using the <span class="emphasis"><em>Ctrl + D</em></span> hotkey combination (use <span class="emphasis"><em>command + D</em></span> if you are working on a Mac).</p></li><li><p>Rename the new shader <code class="literal">TestSpec</code>.</p><p>Our first step is to add the appropriate properties that will allow us to demonstrate the specular.</p></li><li><p>Double-click on the <code class="literal">TestSpec</code> shader to open it in MonoDevelop.</p></li><li><p>Add the following code to the <code class="literal">Properties</code> section:</p><pre class="programlisting">            _Glossiness ("Smoothness", Range(0,1)) = 0.5 &#13;
            _Specular ("Specular", Range(0,1)) = 0.0 &#13;
</pre><p>We will add <code class="literal">Range</code> properties for the <code class="literal">_Glossiness</code> and <code class="literal">_Specular</code> components to allow us to control the highlight size and strength with sliders within the <span class="strong"><strong>Inspector</strong></span>.</p></li><li><p>Locate the shader compile directive (which is displayed in magenta in MonoDevelop) and replace it with the following:</p><pre class="programlisting">            #pragma surface surf MySpecular &#13;
</pre></li><li><p>Add the following code at the bottom of the variables list, further down in the shader code:</p><pre class="programlisting">            half _Glossiness; &#13;
            half _Specular; &#13;
</pre></li><li><p>Rename the <code class="literal">SurfaceOutputMyLambert</code> struct to point to the <code class="literal">MySpecular</code> data structure by rewriting the opening line as follows:</p><pre class="programlisting">            struct SurfaceOutputMySpecular { &#13;
</pre></li><li><p>Locate the opening line of the lighting model and rewrite it to point to the renamed surface output struct, as follows:</p><pre class="programlisting">            inline fixed4 LightingMySpecular (SurfaceOutputMySpecular, fixed3 lightDir, half3 viewDir, &#13;
              fixed atten)&#13;
            { &#13;
</pre><p>You will see that this line already contains a view direction variable called <code class="literal">viewDir</code>.</p><p>In the next step, we will include it in the lighting calculation.</p></li><li><p>Replace the remaining part of the light model with the following code:</p><pre class="programlisting">            half3 h = normalize (lightDir + viewDir); &#13;
            fixed diff = max (0, dot (s.Normal, lightDir)); &#13;
            float nh = max (0, dot (s.Normal, h)); &#13;
            float spec = pow (nh, s.Specular*128.0) * s.Gloss; &#13;
 &#13;
            fixed4 c; &#13;
            c.rgb = s.Albedo * _LightColor0.rgb * diff + _LightColor0.rgb * spec; &#13;
            c.a = s.Alpha; &#13;
 &#13;
            return c; &#13;
            } &#13;
</pre><p>Here, we will set up a few local variables to allow us to do some more complex calculations.</p><p>The <code class="literal">h</code> variable is a combination of the light direction and view direction, clamped with the normalize function.</p><p>The <code class="literal">diff</code>
<code class="literal">fixed</code> float takes the maximum number between 0 and the dot product of the surface normal and light direction.</p><p>The <code class="literal">nh</code> float is equal to the maximum value of 0 and the dot product of the surface normal and <code class="literal">h</code>.</p><p>The <code class="literal">spec</code> float returns the surface specular value increase to the value of <code class="literal">nh</code> multiplied by the surface gloss value.</p><p>These values are assembled in the surface albedo, multiplied by the light color.</p></li><li><p>In the <code class="literal">surf</code> function, at the bottom of the shader, add the two necessary output definitions:</p><pre class="programlisting">            o.Gloss = _Glossiness; &#13;
            o.Specular = _Specular; &#13;
</pre></li><li><p>Save the shader.</p><p>Let's apply the new specular shader to the rover vehicle to compare it to the Lambert lighting.</p></li><li><p>Select the <code class="literal">rover</code> game object by clicking on it in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>When its components appear in the <span class="strong"><strong>Inspector</strong></span>, scroll down to the <span class="strong"><strong>Mesh Renderer</strong></span> component.</p></li><li><p>In the <code class="literal">Rover</code> material parameters section, click on the <span class="strong"><strong>Shader</strong></span> button and choose <span class="strong"><strong>PACKT</strong></span> | <span class="strong"><strong>TestSpec</strong></span> from the drop-down list.</p></li></ol></div><p>You will notice a slight change in the rover's appearance in the <span class="strong"><strong>Scene</strong></span> view.</p><p>In the <span class="strong"><strong>Inspector</strong></span>, the <span class="strong"><strong>Smoothness</strong></span> slider will define the overall shininess of the surface and the <span class="strong"><strong>Specular</strong></span> slider will define the size of the highlighted area on the surface:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_06_011.jpg" /><div class="caption">The rover model with the custom specular lighting model applied</div></div><p>
</p><p>To define a varied surface with shiny and dull areas, we will need to incorporate texture maps. We will be covering this in detail in the next chapter when we explore more complex organic lighting effects.</p></div></div>