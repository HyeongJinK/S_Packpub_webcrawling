<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec34"></a>Creating the hair material</h2></div></div><hr /></div><p>In most games, hair is rendered using opacity-mapped planes rather than rendering individual strands. This efficiently gives the impression of multiple strands without the performance cost of the thousands of triangles that would have to be used for each strand.</p><p>In the scene, take a look at how the astronaut's hair currently appears:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_07_011.jpg" /><div class="caption">The astronaut's hair with a Standard Shader material</div></div><p>
</p><p>Right now, each lock of hair only renders in one direction.</p><p>We can improve this by rendering the back faces of the hair mesh and using a custom lighting model to produce more realistic lighting.</p><p>This time, we will use anisotropic lighting. This method emphasizes surface normals of objects viewed at glancing angles and is ideal for long hair.</p><p>Let's start by taking a look at the current material's input maps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, select the <code class="literal">astronaut_crewsuit</code> game object.</p></li><li><p>If necessary, expand the game object's hierarchy to view its child game objects.</p></li><li><p>Click on the <code class="literal">hair</code> game object to select it.</p></li><li><p>Scroll to the bottom of the <span class="strong"><strong>Inspector</strong></span> and click on the <code class="literal">crewsuit_hair</code> material to expand it and view its inputs:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_07_012.jpg" /><div class="caption">The crewsuit_hair material set up with a Standard Shader</div></div><p>
</p></li></ol></div><p>The hair material currently uses albedo and normal map inputs with a value applied for smoothness.</p><p>We will create the new custom shader next.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec39"></a>Creating the custom hair shader</h3></div></div></div><p>We have established the texture maps that will be used as inputs and can start building our new shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Shaders</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Right-click on an empty area of the <span class="strong"><strong>Assets</strong></span> panel and navigate to <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Shader</strong></span> | <span class="strong"><strong>Standard Surface Shader</strong></span> from the drop-down selection list.</p></li><li><p>Rename the new shader <code class="literal">Hair</code>.</p></li><li><p>Double-click on it to open it in MonoDevelop.</p><p>In MonoDevelop, we will start by setting the shader name and location.</p></li><li><p>Change the first line of the shader to the following:</p><pre class="programlisting">        Shader "PACKT/hair" { &#13;
</pre></li><li><p>Delete the <code class="literal">_Metallic</code> line from the <code class="literal">Properties</code> block.</p></li><li><p>Replace it with the following lines:</p><pre class="programlisting">        _SpecColor ("Specular Color", Color) = (1,1,1,1) &#13;
        _Direction ("Anisotropic Direction)", 2D) = "bump" {} &#13;
        _Anisotropic ("Anisotropy", Range(-1,1)) = -0.0 &#13;
</pre><p>We will add the <code class="literal">_SpecColor</code> property to control the color of the highlight. <code class="literal">_Direction</code> will use a normal map to define the highlighted details in the hair. The last property, <code class="literal">_Anisotropic</code>, will define the extent of the effect.</p></li><li><p>Further down in the shader, locate the <span class="strong"><strong>Level Of Detail</strong></span> (<span class="strong"><strong>LOD</strong></span>) line and add the following code under it:</p><pre class="programlisting">        Cull Off &#13;
</pre><p>This will ensure that the back faces of the hair mesh are rendered.</p></li><li><p>Scroll down to the Cg snippet and replace the Shader compile directive with the following:</p><pre class="programlisting">        #pragma surface surf HairAnisotropic alpha &#13;
</pre><p>We will be defining the custom lighting model further down in the shader.</p></li><li><p>Locate the following line:</p><pre class="programlisting">        sampler2D _MainTex; &#13;
</pre><p>We need to add similar variables to handle the anisotropic direction map.</p></li><li><p>Add the following line directly after this:</p><pre class="programlisting">        sampler2D _Direction; &#13;
</pre><p>Next, we need to add the variables to handle the extent of the anisotropic effect.</p></li><li><p>Add the following code:</p><pre class="programlisting">        float _Anisotropic; &#13;
</pre><p>Next, we need to add the variables needed by our custom lighting function.</p></li><li><p>Add the following code:</p><pre class="programlisting">        struct SurfaceHairAnisotropicOutput &#13;
        { &#13;
            fixed3 Albedo; &#13;
            fixed3 Normal; &#13;
            fixed3 Emission; &#13;
            fixed3 Direction; &#13;
            half Specular; &#13;
            fixed Gloss; &#13;
            fixed Alpha; &#13;
        }; &#13;
</pre><p>The next step is to add the lighting function.</p></li><li><p>Add the following code:</p><pre class="programlisting">        inline fixed4 LightingHairAnisotropic (SurfaceHairAnisotropicOutput &#13;
          s, fixed3 lightDir, half3 viewDir, fixed atten)&#13;
        { &#13;
            fixed3 lightView = normalize(lightDir + viewDir); &#13;
            float NdotL = saturate(dot(s.Normal, lightDir)); &#13;
            fixed NdotD = dot(normalize(s.Normal + s.Direction), &#13;
              lightView);&#13;
            float anisotropy = max(0, sin(radians((NdotD * _Anisotropic) * &#13;
              180)));&#13;
            float spec = saturate(pow(anisotropy, s.Gloss * 128) * &#13;
              s.Specular);&#13;
            fixed4 c; &#13;
            c.rgb = ((s.Albedo * _LightColor0.rgb * NdotL) + &#13;
              (_LightColor0.rgb * _SpecColor.rgb * spec)) * atten;&#13;
            c.a = s.Alpha; &#13;
            return c; &#13;
        } &#13;
</pre></li></ol></div><p>Here, we will define the shader lighting, inputting the light direction, view direction, and attenuation from Unity.</p><p>We will create a <code class="literal">fixed3</code> float named <code class="literal">lightView</code>, which adds the light direction and view direction together.</p><p>In the next line, we will create a <code class="literal">float</code> named <code class="literal">NdotL</code> based on the product of the surface normal and the light direction, clamped to the 0, <code class="literal">1</code> range using the <code class="literal">saturate</code> function.</p><p>Next, we will create a float called <code class="literal">NdotD</code> equal to the product of the surface normal and surface direction—provided by the normal map input.</p><p>The next line creates an <code class="literal">anisotropy</code> float. This is defined as the maximum of the two specified values, zero and the factor of <code class="literal">NdotD</code> and <code class="literal">_Anisotropic</code>, multiplied by <code class="literal">180</code>, and processed with the <code class="literal">sin radians</code> method to translate the light angle degree into a number value that we can work with.</p><p>The next value defines the specular as the saturated factor of the <code class="literal">anisotropy</code> and surface gloss multiplied by <code class="literal">128</code>. The product of this is further multiplied by the surface specular.</p><p>We preprocess the albedo output by defining <code class="literal">c.rgb</code> as the result of the surface albedo multiplied by the light color, multiplied by <code class="literal">NdotL</code>. This value is added to the result of the light color multiplied by the specular color and processed specular level and the light's attenuation.</p><p>We will define the fourth channel of <code class="literal">c</code> as being equal to our surface alpha, preserving the main texture's transparency.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Scroll down to the <code class="literal">surf</code> function and replace its opening line with the following:</p><pre class="programlisting">        void surf (Input IN, inout SurfaceHairAnisotropicOutput o) { &#13;
</pre><p>We will replace the standard output set with the custom variables that we defined in the <code class="literal">SurfaceHairAnisotropicOutput</code> struct.</p></li><li><p>Locate the fixed4 c line and replace it with the following:</p><pre class="programlisting">        fixed4 c = tex2D (_MainTex, IN.uv_MainTex); &#13;
</pre><p>We remove the reference to the <code class="literal">_Color</code> property to prevent it from affecting the transparency that is defined in the alpha channel.</p></li><li><p>Amend the <code class="literal">o.Albedo</code> line as follows:</p><pre class="programlisting">        o.Albedo = c.rgb * _Color.rgb; &#13;
</pre></li><li><p>Add the following line of code:</p><pre class="programlisting">        o.Direction = UnpackNormal(tex2D(_Direction, IN.uv_MainTex)); &#13;
</pre><p>Here, we will unpack the normal, storing it in the <code class="literal">o.Direction</code> slot. It shares UV coordinates with the main texture.</p></li><li><p>Scroll down to locate the <code class="literal">o.Metallic</code> and <code class="literal">o.Smoothness</code> lines and delete them.</p></li><li><p>Add the following code:</p><pre class="programlisting">        o.Specular = _SpecColor.rgb; &#13;
        o.Gloss = _Glossiness; &#13;
</pre></li><li><p>Save the shader and return to the main Unity interface.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span>, click on the Shader selection drop-down menu and choose the new shader by navigating to <span class="strong"><strong>PACKT</strong></span> | <span class="strong"><strong>hair</strong></span>.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, click on the <code class="literal">PACKT_Textures</code> folder to view its contents in the <span class="strong"><strong>Assets</strong></span> panel.</p></li><li><p>Locate the <code class="literal">hair_normal</code> texture asset and drag it to the<span class="strong"><strong> Anisotropic Direction</strong></span> texture slot in the hair material in the <span class="strong"><strong>Inspector</strong></span>.</p></li></ol></div><p>In the <span class="strong"><strong>Scene</strong></span> and <span class="strong"><strong>Game</strong></span> views, the resulting hair surface should have more pronounced highlights. The extent of the anisotropic effect can be adjusted by manipulating the <span class="strong"><strong>Anisotropy</strong></span> slider in the <span class="strong"><strong>Inspector</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781783553679/graphics/image_07_013.jpg" /><div class="caption">The hair model with the finished shader</div></div><p>
</p><p>The resulting hair surface has a wider spread of highlight to simulate the light bouncing off individual strands rather than a solid mass of geometry.
</p></div></div>