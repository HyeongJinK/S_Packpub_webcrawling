<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec54"></a>Techniques to make shaders more efficient</h2></div></div><hr /></div><p>What is a cheap shader? When first asked the question, it might be a little tough to answer, as there are many elements that go into making a more efficient shader. It <span>could</span><a id="id325209386" class="indexterm"></a> be the amount of memory used up by your variables. It could be the amount of textures the shader is using. It could also be that our shader is working fine, but we can actually produce the same visual effect with half the amount of data by reducing the amount of code we are using or data we are creating. We are going to explore a few of these techniques in this recipe and show how they can be combined to make your shader fast and efficient but still produce the high-quality visuals everyone expects from games today, whether on a mobile or PC.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec134"></a>Getting ready</h3></div></div></div><p>In order to get this recipe started, we need to gather a few resources together. So, let's perform the following tasks:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new scene and fill it with a simple sphere object and single directional light.</li><li>Create a new shader (<code class="literal">OptimizedShader01</code>) and material (<code class="literal">OptimizedShader01Mat</code>) and assign the shader to the material.</li><li>We then need to assign the material we just created to our sphere object in our
new scene:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/84cd5eec-e359-4ba3-b4b6-e11f1812c0ca.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Finally, modify the shader so that it uses a diffuse texture and normal map and includes your own custom <code class="literal">Lighting</code> function. </li></ol></div><pre class="programlisting">Properties 
{
  _MainTex ("Base (RGB)", 2D) = "white" {}
  _NormalMap ("Normal Map", 2D) = "bump" {}
}

SubShader 
{
  Tags { "RenderType"="Opaque" }
  LOD 200

  CGPROGRAM
  #pragma surface surf SimpleLambert 

  sampler2D _MainTex;
  sampler2D _NormalMap;

  struct Input 
  {
    float2 uv_MainTex;
    float2 uv_NormalMap;
  };

  inline float4 LightingSimpleLambert (SurfaceOutput s, 
                                       float3 lightDir, 
                                       float atten)
  {
   float diff = max (0, dot (s.Normal, lightDir));

   float4 c;
   c.rgb = s.Albedo * _LightColor0.rgb * (diff * atten * 2);
   c.a = s.Alpha;
   return c;
  }

  void surf (Input IN, inout SurfaceOutput o) 
  {
    fixed4 c = tex2D (_MainTex, IN.uv_MainTex);

    o.Albedo = c.rgb;
    o.Alpha = c.a;
    o.Normal = UnpackNormal(tex2D(_NormalMap, IN.uv_NormalMap));
  }
  ENDCG
} 
FallBack "Diffuse"</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Lastly, assign a base and normal map to your material (I used the <code class="literal">MudRockey</code> texture included in the assets for <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Post Processing Stack</em></span>). You should now have a setup similar to the following screenshot.</li><li>This setup will allow us to take a look at <span>some</span><a id="id325209562" class="indexterm"></a> of the basic concepts that go into optimizing shaders using Surface Shaders in Unity:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/641972e5-6843-46ca-a4f8-4e364d2f4642.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec135"></a>How to do it...</h3></div></div></div><p>We are going to build a simple <code class="literal">DiffuseShader</code> to take a look at a few ways in which you can optimize your shaders in general.</p><p>First, we'll optimize our variable types so that they use less memory when they are
processing data:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Let's begin with the <code class="literal">struct Input</code> in our shader. Currently, our UVs are being stored in a variable of the <code class="literal">float2</code> type.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Remember that floats provide the highest form of precision at a full 32 bits of memory. This is needed for complex trigonometry or exponents, but if you can handle less precision, it's much better to use either a half or a fixed instead. The half type provides up to 3 digits of precision using half the size, or 16 bits of memory. That means we can have a <code class="literal">half2</code> with the same amount of memory of a <span>single</span><a id="id325209652" class="indexterm"></a> float. We need to change this to use <code class="literal">half2</code> instead:</li></ol></div><pre class="programlisting">struct Input 
{
    half2 uv_MainTex;
    half2 uv_NormalMap;
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>We can then move to our <code class="literal">Lighting</code> function and reduce the variables' memory footprint by changing their types to the following:</li></ol></div><pre class="programlisting">inline fixed4 LightingSimpleLambert (SurfaceOutput s, fixed3 lightDir, fixed atten)
{
  fixed diff = max (0, dot(s.Normal, lightDir));

  fixed4 c;
  c.rgb = s.Albedo * _LightColor0.rgb * (diff * atten * 2);
  c.a = s.Alpha;
  return c;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li> In this case, we are using the lowest precision type of <code class="literal">fixed</code>, which is only 11  bits as compared to the <code class="literal">float</code> type's 32. This is useful for simple calculations such as color or texture data, which is perfect for this particular case.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note67"></a>Note</h3><p>In case you'd like a refresher on the fixed type as well as all of the other types we are using, please check out <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Creating Your First Shader</em></span>, or look at <a class="ulink" href="https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html" target="_blank">https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html</a>. </p></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Finally, we can complete this optimization pass by updating the variables in our <code class="literal">surf()</code> function. Since we're using texture data, it's fine for us to use a <code class="literal">fixed4</code> here instead:</li></ol></div><pre class="programlisting">void surf (Input IN, inout SurfaceOutput o) 
{
  fixed4 c = tex2D (_MainTex, IN.uv_MainTex);

  o.Albedo = c.rgb;
  o.Alpha = c.a;
  o.Normal = UnpackNormal(tex2D(_NormalMap, IN.uv_NormalMap));
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Now that we have our variables optimized, we are going to take advantage of a built-in <code class="literal">Lighting</code> function variable so that we can control how lights are processed by this shader. By doing this, we can greatly reduce the number of lights the shader processes. Modify the <code class="literal">#pragma</code> statement in your <span>shader</span><a id="id325453536" class="indexterm"></a> with the following code:</li></ol></div><pre class="programlisting">CGPROGRAM
#pragma surface surf SimpleLambert <span class="strong"><strong>noforwardadd</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>We can optimize this further by sharing UVs between the normal map and diffuse texture. To do this, we simply change the UV lookup in our <code class="literal">UnpackNormal()</code> function to use <code class="literal">_MainTex</code> UVs instead of the UVs of <code class="literal">_NormalMap</code>:</li></ol></div><pre class="programlisting">void surf (Input IN, inout SurfaceOutput o) 
{
  fixed4 c = tex2D (_MainTex, IN.uv_MainTex);

  o.Albedo = c.rgb;
  o.Alpha = c.a;
  o.Normal = UnpackNormal(tex2D(_NormalMap,<span class="strong"><strong> IN.uv_MainTex</strong></span>));
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>As we have removed the need for the normal map UVs, we need to make sure that we remove the normal map UV code from the <code class="literal">Input</code><code class="literal">struct</code>:</li></ol></div><pre class="programlisting">struct Input 
{
  half2 uv_MainTex;
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Finally, we can further optimize this shader by telling the shader that it only works with certain renderers:</li></ol></div><pre class="programlisting">CGPROGRAM
#pragma surface surf SimpleLambert <span class="strong"><strong>exclude_path:prepass</strong></span> noforwardadd</pre><p>The result of our optimization passes show us that we really don't notice a difference in the visual quality, but we have reduced the amount of time it takes for this <span>shader</span><a id="id325453658" class="indexterm"></a> to be drawn to the screen. You will learn about finding out how much time it takes for a shader to render in the next recipe, but the idea to focus on here is that we achieve the same result with fewer data. So keep this in mind when creating your shaders. The following screenshot shows us the final result of our shader:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/78220198-4eeb-4d74-b166-53e998dfd472.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec136"></a>How it works...</h3></div></div></div><p>Now that we have seen the ways in which we can optimize our shaders, let's dive in a bit deeper and really understand how all of these techniques work, why we should use them, and look at a couple of other techniques that you can try for yourself in your own shaders.</p><p>Let's first focus our attention on the size of the data each of our variables is storing when we declare them. If you are familiar with programming, then you will understand that you can declare values or variables with different sizes of types. This means that a float actually has a maximum size in memory. The <span>following</span><a id="id325453685" class="indexterm"></a> description will describe these variable types in much more detail:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Float</strong></span>: A float is a full 32-bit precision value and is the slowest of the three
different types we see here. It also has its corresponding values of <code class="literal">float2</code>, <code class="literal">float3</code>, and <code class="literal">float4</code>, which allow us to store multiple floats in one variable.</li><li style="list-style-type: disc"><span class="strong"><strong>Half</strong></span>: The half variable type is a <span>reduced</span><a id="id325453786" class="indexterm"></a> 16-bit floating point value and is suitable for store UV values and color values and much faster than using a float value. As with the float type, it has its corresponding values, which are <code class="literal">half2</code>, <code class="literal">half3</code>, and <code class="literal">half4</code>.</li><li style="list-style-type: disc"><span class="strong"><strong>Fixed</strong></span>: A fixed value is the <span>smallest</span><a id="id325453810" class="indexterm"></a> in size of the three types, but can be used for lighting calculations and colors and has the corresponding values of <code class="literal">fixed2</code>, <code class="literal">fixed3</code>, and <code class="literal">fixed4</code>.</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip68"></a>Note</h3><p>For more information on working with array types for shaders, check out the <span class="emphasis"><em>Using packed arrays</em></span> recipe from <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Surface Shaders and Texture Mapping</em></span>.</p></div><p>Our second phase of optimizing our simple shader was to declare the <code class="literal">noforwardadd</code> value to our <code class="literal">#pragma</code> statement. This is basically a switch that automatically tells Unity that any object with this particular shader receives only per-pixel light from a single directional light. Any other lights that are calculated by this <span>shader</span><a id="id325453856" class="indexterm"></a> will be forced to be processed as per-vertex lights using <span class="emphasis"><em>spherical harmonic</em></span> values produced internally by Unity. This is especially obvious when we place another light in the scene to light our sphere object because our shader is doing a per-pixel operation using the normal map.</p><p>This is great, but what if you wanted to have a bunch of directional lights in the scene and control over which of these lights is used for the main per-pixel light? Well, if you notice, each light has a <strong class="userinput"><code>Render Mode</code></strong> drop-down. If you click on this drop-down, you will see a couple of flags that can be set. These are <strong class="userinput"><code>Auto</code></strong>, <strong class="userinput"><code>Important</code></strong>, and <strong class="userinput"><code>Not Important</code></strong>. By selecting a light, you can tell Unity that a light should be considered more as a per-pixel light than a per-vertex light, by setting its render mode to <strong class="userinput"><code>Important</code></strong> and vice versa. If you leave a light set to <strong class="userinput"><code>Auto</code></strong>, then you will let Unity decide the best course of action:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/3561a9e3-df29-4a0e-8cb4-d7bdc32a570b.png" /></div><p>Place another light in your scene and remove the texture that is currently in the main texture for our shader. You will notice that the second point light does not react with the normal map, only the directional light that we created first. The concept here is that you save on per-pixel operations by just calculating all extra lights as vertex lights, and save performance by just calculating the main directional light as a per-pixel light. The following diagram visually demonstrates this concept as the point light is not reacting with the normal map:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/db8f87b8-6bd7-446b-aa31-71abfdccdf80.png" /></div><p>Finally, we did a bit of cleaning up and simply told the normal map texture to use the main texture's UV values, and we got rid of the line of code that pulled in a separate set of UV values specifically for the normal map. This is always a nice way to simplify your code and clean up any unwanted data.</p><p>We also declared <code class="literal">exclude_pass: prepass</code> in our <code class="literal">#pragma</code> statement so that this
shader wouldn't accept any custom lighting from the deferred renderer. This means that we can really use this shader effectively in the forward renderer only, which is set in the main camera's settings.</p><p>By taking a bit of time, you will be amazed at how much a <span>shader</span><a id="id325453928" class="indexterm"></a> can be optimized. You have seen how we can pack grayscale textures into a single RGBA texture as well as use lookup textures to fake lighting. There are many ways in which a shader can be optimized, which is why it is always an ambiguous question to ask in the first place, but knowing these different optimization techniques, you can cater your shaders to your game and target platform, ultimately resulting in very streamlined shaders and a nice steady frame rate.</p></div></div>