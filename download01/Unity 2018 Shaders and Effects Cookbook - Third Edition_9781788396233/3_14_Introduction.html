<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec21"></a>Introduction</h2></div></div><hr /></div><p>Surface Shaders were introduced in <a class="link" href="#" linkend="ch02"><span>Chapter 2</span></a>, <span class="emphasis"><em>Creating Your First Shader</em></span>, as the main type of shader that's used in Unity. This chapter will show you in detail what these actually are and how they work. Generally speaking, there are two essential steps in every Surface Shader. First, you have to specify certain physical properties of the material that you want to describe, such as its diffuse color, smoothness, and transparency. These properties are initialized in a function <span>called</span><a id="id325219389" class="indexterm"></a> theÂ <span class="strong"><strong>surface function</strong></span> and are stored in a structure called the <code class="literal">SurfaceOutput</code>. Secondly, the <code class="literal">SurfaceOutput</code> is passed to a lighting model. This is a special function that will also take information about the nearby lights in the scene. Both of these parameters are then used to calculate the final color for each pixel of your model. The lighting function is where the real calculations of a shader take place as it's the piece of code that determines how light should behave when it touches a material.</p><p>The following diagram loosely summarizes how a Surface Shader works. Custom lighting models will be explored in <a class="link" href="#" linkend="ch04"><span>Chapter 4</span></a>, <span class="emphasis"><em>Understanding Lighting Models</em></span>, while <a class="link" href="#" linkend="ch06"><span>Chapter 6</span></a>, <span class="emphasis"><em>Vertex Functions</em></span>, will focus on vertex modifiers:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/c50d3204-fd95-4a43-b184-abb226bf4333.png" /></div></div>