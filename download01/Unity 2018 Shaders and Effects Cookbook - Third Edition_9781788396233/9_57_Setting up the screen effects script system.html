<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec58"></a>Setting up the screen effects script system</h2></div></div><hr /></div><p>The process of creating screen effects is one in <span>which</span><a id="id325209385" class="indexterm"></a> we grab a full-screen image (or texture), use a shader to process its pixels on the GPU, and then send it back to Unity's renderer to apply it to the whole rendered image of the game. This allows us to perform per-pixel operations on the rendered image of the game in real time, giving us a more global artistic control.</p><p>Imagine if you had to go through and adjust each material on each object in your game to just adjust the contrast of the final look of your game. While not impossible, this would take a bit of labor to perform. By utilizing a screen effect, we can adjust the screen's final look as a whole, thereby giving us more Photoshop-like control over our game's final appearance.</p><p>In order to get a screen effect system up and running, we have to set up a single script to act as the courier of the game's current rendered image, or what Unity calls the <code class="literal">RenderTexture</code>. By utilizing this script to pass the <code class="literal">RenderTexture</code> to a shader, we can create a flexible system for establishing screen effects. For our first screen effect, we are going to create a very simple grayscale effect and make our game look black and white. Let's take a look at how this is done.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec144"></a>Getting ready</h3></div></div></div><p>In order to get our screen effects system up and running, we need to create a few assets for our current Unity project. By doing this, we will set ourselves up for the steps in the following sections:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In the current project, create a new scene to work in.</li><li>Create a simple sphere in the scene and assign it a new material (I called mine <code class="literal">RedMat</code>). This new material can be anything, but for our example, we will make a simple red material using the Standard Shader.</li><li>Finally, create a new directional light and save the scene.</li><li>We need to create a new C# script and call it <code class="literal">TestRenderImage.cs</code>. For organization purposes, create a folder called <code class="literal">Scripts</code> from the <strong class="userinput"><code>Project</code></strong> tab to put it in.</li></ol></div><p>With all of our assets ready, you should have a simple scene setup, which <span>looks</span><a id="id325453981" class="indexterm"></a> similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/8ebad4a4-1842-4762-8834-2c933504892c.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec145"></a>How to do it...</h3></div></div></div><p>In order to make our grayscale screen effect work, we need a script and shader. So, we will complete these two new items here and fill them in with the appropriate code to produce our first screen effect. Our first task is to complete the C# script. This will get the whole system running. After this, we will complete the shader and see the results of our screen effect. Let's complete our script and shader with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open the <code class="literal">TestRenderImage.cs</code> C# script and begin by entering a few variables that we will need to store important objects and data. Enter the following code at the very top of the <code class="literal">TestRenderImage</code> class:</li></ol></div><pre class="programlisting">#region Variables
public Shader curShader;
public float greyscaleAmount = 1.0f;
private Material screenMat;
#endregion</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li><span>In</span> order for us to edit the screen effect in real time, when the Unity editor isn't playing, we need to enter the following line of code just above the declaration of the <code class="literal">TestRenderImage</code> class:</li></ol></div><pre class="programlisting">using UnityEngine;

<span class="strong"><strong>[ExecuteInEditMode]</strong></span>
public class TestRenderImage : MonoBehaviour {</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>As our screen effect is using a shader to <span>perform</span><a id="id325453545" class="indexterm"></a> the pixel operations on our screen image, we have to create a material to run the shader. Without this, we can't access the properties of the shader. For this, we will create a C# property to check for a material, and create one if it doesn't find one. Enter the following code just after the declaration of the variables from <span class="emphasis"><em>step 1</em></span>:</li></ol></div><pre class="programlisting">#region Properties
Material ScreenMat
{
    get
    {
        if (screenMat == null)
        {
            screenMat = new Material(curShader);
            screenMat.hideFlags = HideFlags.HideAndDontSave;
        }
        return screenMat;
    }
}
#endregion</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>We now want to set up some checks in our script to see if the current target platform that we are building the Unity game on actually supports image effects. If it doesn't find anything at the start of this script, then the script will disable itself:</li></ol></div><pre class="programlisting">void Start()
{
    if (!SystemInfo.supportsImageEffects)
    {
        enabled = false;
        return;
    }

    if (!curShader &amp;&amp; !curShader.isSupported)
    {
        enabled = false;
    }
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>To actually grab the rendered image from the Unity renderer, we need to make use of the following built-in function that Unity provides us, called <code class="literal">OnRenderImage()</code>. Enter the following code so that we can have access to the current <code class="literal">RenderTexture</code>:</li></ol></div><pre class="programlisting">void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
{
    if (curShader != null)
    {
        ScreenMat.SetFloat("_Luminosity", greyscaleAmount);

        Graphics.Blit(sourceTexture, destTexture, ScreenMat);
    }
    else
    {
        Graphics.Blit(sourceTexture, destTexture);
    }
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Our screen effect has a variable called <code class="literal">grayScaleAmount</code> with which we can control how much grayscale we want for our final screen effect. So, in this case, we need to make the value go from <code class="literal">0</code> to <code class="literal">1</code>, where <code class="literal">0</code> is no grayscale effect and <code class="literal">1</code> is a full grayscale effect. We will perform this operation in the <code class="literal">Update()</code> function, which will be called every frame while the game is running:</li></ol></div><pre class="programlisting">void Update ()
{
    greyscaleAmount = Mathf.Clamp(greyscaleAmount, 0.0f, 1.0f);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Finally, we complete our script by doing a little bit of clean-up on objects we created when the script started:</li></ol></div><pre class="programlisting">void OnDisable()
{
  if(screenMat)
  {
    DestroyImmediate(screenMat);
  }
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>At this point, we can now apply this script to the camera, if it compiled without errors, in Unity. Let's apply the <code class="literal">TestRenderImage.cs</code> script to our main camera in our scene. You should see the <code class="literal">grayScaleAmount</code> value and a field for a shader, but the script throws an error to the console window. It says that it is missing an instance to an object and so won't process appropriately. If you recall from <span class="emphasis"><em>step 4</em></span>, we are doing some checks to see whether we have a shader <span>and if</span> the current platform supports the shader. As we haven't given the screen effect script a shader to work with, then the <code class="literal">curShader</code> variable is just null, which <span>throws</span><a id="id325453738" class="indexterm"></a> an error. Let's continue with our screen effects system by completing the shader.</li><li>Create a new shader called <code class="literal">ScreenGrayscale</code>. To begin our shader, we will populate our <code class="literal">Properties</code> with some variables so that we can send data to this shader:</li></ol></div><pre class="programlisting">Properties 
{
 _MainTex ("Base (RGB)", 2D) = "white" {}
 _Luminosity("Luminosity", Range(0.0, 1)) = 1.0
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Our shader is now going to utilize pure CG shader code instead of utilizing Unity's built-in Surface Shader code. This will make our screen effect more optimized as we need to work only with the pixels of the <code class="literal">RenderTexture.</code> So, we will delete everything inside of the <code class="literal">Pass</code> that was there before and create a new <code class="literal">Pass</code> block in our shader and fill it with some new <code class="literal">#pragma</code> statements that we haven't seen before:</li></ol></div><pre class="programlisting">SubShader 
{
  Pass
  {
    CGPROGRAM
    #pragma vertex vert_img
    #pragma fragment frag
    #pragma fragmentoption ARB_precision_hint_fastest
    #include "UnityCG.cginc"</pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>In order to access the data being sent to the shader from the Unity editor, we need to create the corresponding variables in our <code class="literal">CGPROGRAM</code>:</li></ol></div><pre class="programlisting">uniform sampler2D _MainTex;
fixed _Luminosity;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Finally, all we need to do is set up our pixel function, in this case called <code class="literal">frag()</code>. This is where the meat of the screen effect is. This function will process each pixel of the <code class="literal">RenderTexture</code> and return a new image to our <code class="literal">TestRenderImage.cs</code> script:</li></ol></div><pre class="programlisting">fixed4 frag(v2f_img i) : COLOR
{
  //Get the colors from the RenderTexture and the uv's
  //from the v2f_img struct
  fixed4 renderTex = tex2D(_MainTex, i.uv);

  //Apply the Luminosity values to our render texture
  float luminosity = 0.299 * renderTex.r + 0.587 * renderTex.g + 0.114 * renderTex.b;
  fixed4 finalColor = lerp(renderTex, luminosity, _Luminosity);

  renderTex.rgb = finalColor;

  return renderTex;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Lastly, change the <code class="literal">FallBack</code> line to the following:</li></ol></div><pre class="programlisting">FallBack off</pre><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>The final shader <span>should</span><a id="id325454123" class="indexterm"></a> look as follows:</li></ol></div><pre class="programlisting">Shader "CookbookShaders/Chapter09/Grayscale" 
{
  Properties 
  {
    _MainTex ("Base (RGB)", 2D) = "white" {}
    _Luminosity("Luminosity", Range(0.0, 1)) = 1.0
  }

  SubShader 
  {
    Pass
    {
      CGPROGRAM
      #pragma vertex vert_img
      #pragma fragment frag
      #pragma fragmentoption ARB_precision_hint_fastest
      #include "UnityCG.cginc"

      uniform sampler2D _MainTex;
      fixed _Luminosity;

      fixed4 frag(v2f_img i) : COLOR
      {
        //Get the colors from the RenderTexture and the uv's
        //from the v2f_img struct
        fixed4 renderTex = tex2D(_MainTex, i.uv);

        //Apply the Luminosity values to our render texture
        float luminosity = 0.299 * renderTex.r + 0.587 * renderTex.g + 0.114 * renderTex.b;
        fixed4 finalColor = lerp(renderTex, luminosity, _Luminosity);

        renderTex.rgb = finalColor;

        return renderTex;
      }

    ENDCG
    }
  }
  FallBack off
}</pre><p>Once the shader is complete, return to Unity and let it compile to see if any errors occurred. If not, assign the new shader to the <code class="literal">TestRenderImage.cs</code> script and change the value of the grayscale amount variable. You should see the game view go from a colored version of the game to a grayscale version of the game:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/8c400940-ad48-482e-b761-1862cd9cf55e.png" /></div><p>The following screenshot demonstrates this Screen Effect:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/dac0a50f-e243-4807-baaa-aba54f55dd34.png" /></div><p>With this complete, we now have an easy way to test out new screen effect shaders without having to write our whole screen effect system over and over again. Let's dive in a little <span>deeper</span><a id="id325454164" class="indexterm"></a> and learn about what's going on with the <code class="literal">RenderTexture</code> and how it is processed throughout its existence.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec146"></a>How it works...</h3></div></div></div><p>To get a screen effect up and running inside of Unity, we need to create a script and shader. The script drives the real-time update in the editor and is also responsible for capturing the <code class="literal">RenderTexture</code> from the main camera and passing it to the shader. Once the <code class="literal">RenderTexture</code> gets to the shader, we can use the shader to perform per-pixel operations.</p><p>At the start of the script, we perform a few checks to make sure that the current selected build platform actually supports screen effects and the shader itself. There are instances where a current platform will not support screen effects or the shader that we are using. So, the checks that we do in the <code class="literal">Start()</code> function ensure we don't get any errors if the platform doesn't support the screen system.</p><p>Once the script passes these checks, we initiate the screen effects system by calling the built-in <code class="literal">OnRenderImage()</code> function. This function is responsible for grabbing the <code class="literal">renderTexture</code>, giving it to the shader using the <code class="literal">Graphics.Blit()</code> function, and returning the processed image to the Unity renderer. You can <span>find</span><a id="id325454241" class="indexterm"></a> more information on <span>these</span><a id="id325454249" class="indexterm"></a> two functions at the following URLs:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">OnRenderImage</code>: <span><a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html</a></span></li><li style="list-style-type: disc"><code class="literal">Graphics.Blit</code>:<span class="strong"><strong> </strong></span><span><a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html</a></span></li></ul></div><p>Once the current <code class="literal">RenderTexture</code> reaches the shader, the shader takes it, processes it through the <code class="literal">frag()</code> function, and returns the final color for each pixel.</p><p>You can see how powerful this becomes as it gives us Photoshop-like control over the final rendered image of our game. These screen effects work sequentially like Photoshop layers on top of what<span> the camera sees</span>. When you place these screen effects one after the other, they will be processed in that order. These are just the bare bones steps to get a screen effect working, but it is the core of how the screen effects system works.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec147"></a>There's more...</h3></div></div></div><p>Now that we have our <span>simple</span><a id="id325465261" class="indexterm"></a> screen effect system up and running, let's take a look at some of the other useful information we can obtain from Unity's renderer:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/af13e8f7-2644-4513-aaa5-ca5c3db066c2.png" /></div><p>We can actually get the depth of everything in our current game by turning on Unity's built-in <strong class="userinput"><code>Depth</code></strong> mode. Once this is turned on, we can use the depth information for a ton of different effects. Let's take a look at how this is done:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Duplicate the sphere we <span>created</span><a id="id325465290" class="indexterm"></a> twice and create a plane underneath:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/e1a33be5-1ebb-4fb6-9ff0-fc2cbf378aa0.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Create a new shader by duplicating the <code class="literal">ScreenGreyscale</code> code by selecting it and pressing <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>D</em></span>. Once duplicated, rename the script to <code class="literal">SceneDepth</code>. Then double-click on this shader to open it in your script editor.</li><li>We will create the main texture (<code class="literal">_MainTex</code>) property and a property to control the power of the scene depth effect. Enter the following code in your shader:</li></ol></div><pre class="programlisting">Properties 
{
  _MainTex ("Base (RGB)", 2D) = "white" {}
<span class="strong"><strong>_DepthPower("Depth Power", Range(0, 1)) = 1</strong></span>
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Now we need to create the corresponding variables in our <code class="literal">CGPROGRAM</code>. We are going to add one more variable called <code class="literal">_CameraDepthTexture</code>. This is a built-in variable that Unity has provided us with through the use of the <code class="literal">UnityCG.cginclude</code> file. It gives us the depth <span>information</span><a id="id325465362" class="indexterm"></a> from the camera:</li></ol></div><pre class="programlisting">Pass
{
  CGPROGRAM
  #pragma vertex vert_img
  #pragma fragment frag
  #pragma fragmentoption ARB_precision_hint_fastest
  #include "UnityCG.cginc"

  uniform sampler2D _MainTex;
<span class="strong"><strong>  fixed _DepthPower;</strong></span>
<span class="strong"><strong>  sampler2D _CameraDepthTexture;</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>We will complete our depth shader by utilizing a couple of built-in functions that Unity provides us with, the <code class="literal">UNITY_SAMPLE_DEPTH()</code> and <code class="literal">linear01Depth()</code> functions. The first function actually gets the depth information from our <code class="literal">_CameraDepthTexture</code> and produces a single float value for each pixel. The <code class="literal">Linear01Depth()</code> function then makes sure that the values are within the <code class="literal">0</code><span>-</span><code class="literal">1</code> range by taking this final depth value to a power we can control, where the mid-value in the <code class="literal">0</code>-<code class="literal">1</code> range sits in the scene based off of the camera position:</li></ol></div><pre class="programlisting">fixed4 frag(v2f_img i) : COLOR
{
  //Get the colors from the RenderTexture and the uv's
  //from the v2f_img struct
  float depth = UNITY_SAMPLE_DEPTH(tex2D(_CameraDepthTexture, i.uv.xy));
  depth = pow(Linear01Depth(depth), _DepthPower);

  return depth;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>With our shader complete, let's turn our attention to the Unity editor and create a new script to work with. Select our <code class="literal">TestRenderImage</code> script and duplicate it. Name this new script <code class="literal">RenderDepth</code> and open it up in your script editor.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Update the script to have the same class name <span>as we renamed it to in the previous step (<code class="literal">RenderDepth</code>)</span>:</li></ol></div><pre class="programlisting">using UnityEngine;

[ExecuteInEditMode]
public class <span class="strong"><strong>RenderDepth</strong></span> : MonoBehaviour {</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>We need to add the <code class="literal">depthPower</code> variable to the script so that we can let users change the value in the editor:</li></ol></div><pre class="programlisting">#region Variables
public Shader curShader;
<span class="strong"><strong>public float depthPower = 0.2f;</strong></span>
private Material screenMat;
#endregion</pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Our <code class="literal">OnRenderImage()</code> function then needs to be <span>updated</span><a id="id325465532" class="indexterm"></a> so that it is passing the right value to our shader:</li></ol></div><pre class="programlisting">void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
{
    if (curShader != null)
    {
<span class="strong"><strong>ScreenMat.SetFloat("_DepthPower", depthPower);</strong></span>

        Graphics.Blit(sourceTexture, destTexture, ScreenMat);
    }
    else
    {
        Graphics.Blit(sourceTexture, destTexture);
    }
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>To complete our depth screen effect, we need to tell Unity to turn on the depth rendering in the current camera. This is done by simply setting the main camera's <code class="literal">depthTextureMode</code>:</li></ol></div><pre class="programlisting">void Update ()
{
    Camera.main.depthTextureMode = DepthTextureMode.Depth;
    depthPower = Mathf.Clamp(depthPower, 0, 1);
}</pre><p>With all the code set up, save <span>your</span><a id="id325465570" class="indexterm"></a> script and shader and return to Unity to let them both compile. Afterward, select the <strong class="userinput"><code>Main Camera</code></strong>, right-click on the <strong class="userinput"><code>TextRenderImage</code></strong> component, and select <strong class="userinput"><code>Remove Component</code></strong>. Afterward, attach this new component to the object and drag and drop our new shader inside. If no errors are encountered, you should see a result similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/fe66c0df-f346-47ff-a1cb-1662be7cf37d.png" /></div><p>Here's an <span>example</span><a id="id325465597" class="indexterm"></a> of what we can get if we tweak the values even more:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/4c27460b-ba96-4a88-8e6d-2b252c77ef18.png" /></div></div></div>