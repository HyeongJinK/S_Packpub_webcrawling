<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec44"></a>Animating vertices in a Surface Shader</h2></div></div><hr /></div><p>Now that we know how to access data on a per-vertex basis, let's expand our knowledge set to include other types of data and the position of a vertex.</p><p>Using a vertex function, we can access the position of each vertex in a mesh. This allows us to actually modify each individual vertex while the shader does the processing.</p><p>In this recipe, we will create a shader that will allow us to modify the positions of each vertex on a mesh with a sine wave. This technique can be used to create animations for objects such as flags or waves on an ocean.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec102"></a>Getting ready</h3></div></div></div><p>Let's gather our assets together so that we can create the code for our Vertex Shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new scene and place a plane mesh in the center of the scene (<strong class="userinput"><code>GameObject </code></strong>| <strong class="userinput"><code>3D Objects </code></strong>| <strong class="userinput"><code>Plane</code></strong>). </li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip57"></a>Note</h3><p>The <code class="literal">Plane</code> object created may seem to be a single quad but, in fact, has 121 verts, which we are going to be moving. Using a quad would provide unexpected results. To check for yourself, select the <code class="literal">Plane</code> object and, under the <strong class="userinput"><code>Plane (Mesh Filter)</code></strong> component, double-click on the <strong class="userinput"><code>Mesh</code></strong> property.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li><span>Create a new shader</span> (<code class="literal">VertexAnimation</code>) and material (<code class="literal">VertexAnimationMat</code>).</li><li>Finally, assign the shader to the material and the material to the plane mesh.</li></ol></div><p>Your scene <span>should</span><a id="id325442696" class="indexterm"></a> look <span>similar</span><a id="id325442705" class="indexterm"></a> to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/57d9530f-a3ca-413a-aadc-7087c93b7e87.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec103"></a>How to do it…</h3></div></div></div><p>With our scene ready to go, let's double-click on our newly created shader to open it in the code editor:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Let's <span>begin</span><a id="id325445059" class="indexterm"></a> with our <span>shader</span><a id="id325445067" class="indexterm"></a> and populate the <code class="literal">Properties</code> block:</li></ol></div><pre class="programlisting">Properties 
{
_MainTex ("Base (RGB)", 2D) = "white" {}
_tintAmount ("Tint Amount", Range(0,1)) = 0.5
_ColorA ("Color A", Color) = (1,1,1,1)
_ColorB ("Color B", Color) = (1,1,1,1)
_Speed ("Wave Speed", Range(0.1, 80)) = 5
_Frequency ("Wave Frequency", Range(0, 5)) = 2
_Amplitude ("Wave Amplitude", Range(-1, 1)) = 1
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>We now need to tell Unity that we are going to be using a vertex function by adding the following to the <code class="literal">#pragma</code> statement:</li></ol></div><pre class="programlisting">CGPROGRAM
<span class="strong"><strong>#pragma</strong></span> surface surf Lambert vertex:vert</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>In order to access the values that have been given to us by our properties, we need to declare a corresponding variable in our <code class="literal">CGPROGRAM</code> block:</li></ol></div><pre class="programlisting">sampler2D _MainTex;
float4 _ColorA;
float4 _ColorB;
float _tintAmount;
float _Speed;
float _Frequency;
float _Amplitude;
float _OffsetVal;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>We will be using the vertex position modification as a <code class="literal">vert</code> color as well. This will allow us to tint our object:</li></ol></div><pre class="programlisting">struct Input 
{
  float2 uv_MainTex;
  float3 vertColor;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>At this point, we can <span>perform</span><a id="id325451204" class="indexterm"></a> our vertex modification <span>using</span><a id="id325451212" class="indexterm"></a> a sine wave and vertex function. Enter the following code after the <code class="literal">Input struct</code>:</li></ol></div><pre class="programlisting">void vert(inout appdata_full v, out Input o)
{
  UNITY_INITIALIZE_OUTPUT(Input,o);
  float time = _Time * _Speed;
  float waveValueA = sin(time + v.vertex.x * _Frequency) * _Amplitude;

  v.vertex.xyz = float3(v.vertex.x, v.vertex.y + waveValueA, v.vertex.z);
  v.normal = normalize(float3(v.normal.x + waveValueA, v.normal.y, v.normal.z));
  o.vertColor = float3(waveValueA,waveValueA,waveValueA);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Finally, we complete our shader by performing a <code class="literal">lerp()</code> function between two colors so that we can tint the peaks and valleys of our new mesh, modified by our vertex function:</li></ol></div><pre class="programlisting">void surf (Input IN, inout SurfaceOutput o)
{
  half4 c = tex2D (_MainTex, IN.uv_MainTex);
  float3 tintColor = lerp(_ColorA, _ColorB, IN.vertColor).rgb; 
  o.Albedo = c.rgb * (tintColor * _tintAmount);
  o.Alpha = c.a;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>After completing the code for your shader, switch back to Unity and let the shader compile. Once compiled, select the <strong class="userinput"><code>Material</code></strong> and assign the <strong class="userinput"><code>Base (RGB)</code></strong><strong class="userinput"><code>Texture</code></strong> to the <code class="literal">UV Checker</code> material that is included in <code class="literal">Chapter 6 </code>| <code class="literal">Textures</code> folder of this book's example code.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>From there, assign <strong class="userinput"><code>Color A</code></strong> and <strong class="userinput"><code>Color B</code></strong> to different colors. After the changes, you should see something similar to the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/8db36537-fc42-4de7-abf2-28269785701c.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec104"></a>How it works…</h3></div></div></div><p>This particular shader uses the same <span>concept</span><a id="id325453514" class="indexterm"></a> from the last recipe, except that this time, we are modifying the positions of the vertices in the mesh. This is really useful if you don't want to rig up <span>simple</span><a id="id325454753" class="indexterm"></a> objects, such as a flag, and then animate them using a skeleton structure or hierarchy of <span>transforms</span>.</p><p>We simply create a sine wave value using the <code class="literal">sin()</code> function that is built into the Cg language. After calculating this value, we add it to the <span class="emphasis"><em>y</em></span> value of each vertex position, creating a wave-like effect.</p><p>We also modified the normal on the mesh just to give it more realistic shading based on the sine wave value.</p><p>You will see how easy it is to perform more complex vertex effects by utilizing the built-in vertex parameters that Surface Shaders give us.</p></div></div>