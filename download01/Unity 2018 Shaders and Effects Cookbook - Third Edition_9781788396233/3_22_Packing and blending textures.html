<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec29"></a>Packing and blending textures</h2></div></div><hr /></div><p>Textures are useful for storing not <span>only</span><a id="id325209370" class="indexterm"></a> loads of data, not <span>just</span><a id="id325209379" class="indexterm"></a> pixel colors as we generally tend to think of them, but also for multiple sets of pixels in both the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> directions and RGBA channels. We can actually pack multiple images into a single RGBA texture and use each of the R, G, B, and A components as individual textures themselves by extracting each of these components from the shader code.</p><p>The result of packing individual grayscale images into a single RGBA texture can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/537b6d56-f634-42de-b446-532361874252.png" /></div><p>Why is this helpful? Well, in terms of the amount of actual memory that your application takes up, textures are a large portion of your application's size. We can, of course, reduce the size of the image, but then we would lose details in how it can be represented. So, to begin reducing the size of your application, we can look at all of the images that we are using in our shader and see if we can merge these textures into a single texture. Using a single texture with multiple images in them requires fewer draw calls and less overhead than separate files. We can also use this concept to combine irregularly shaped textures (that being, those that are not squares) into a single one to take up less space than giving them their own full texture.</p><p>Any texture that is grayscale can be packed into one of the RGBA channels of another texture. This might sound a bit odd at first, but this recipe is going to demonstrate one of the uses of packing a texture and using these packed textures in a shader.</p><p>One example of using these packed <span>textures</span><a id="id325209413" class="indexterm"></a> is when you <span>want</span><a id="id325209421" class="indexterm"></a> to blend a set of textures together onto a single surface. You see this most often in terrain type shaders, where you need to blend into another texture nicely using some sort of control texture or the packed texture, in this case. This recipe covers this technique and shows you how to construct the beginnings of a nice four-texture blended terrain shader.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec60"></a>Getting ready</h3></div></div></div><p>Let's create a new shader file in your <code class="literal">Shaders</code> folder (<code class="literal">TextureBlending</code>) and then create a new material for this shader (<code class="literal">TextureBlendingMat</code>). The naming convention is entirely up to you for your shader and material files, so try your best to keep them organized, and easy to reference later on.</p><p>Once you have your shader and material ready, create a new scene in which we can test our shader. Inside to the scene, place the <code class="literal">Terrain_001</code> object from the <code class="literal">Chapter 3 </code>| <code class="literal">Models</code> folder and assign the <code class="literal">TextureBlendingMat</code> material to it:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/a28cee54-5bd9-4811-ba08-b8f1fd974af6.png" /></div><p>You will also need to gather up four textures that you would want to blend together. These can be anything, but for a nice terrain shader, you will want grass, dirt, rocky dirt, and rock textures. You can find these assets in <code class="literal">Chapter 1 </code>| <code class="literal">Standard Assets </code>| <code class="literal">Environment </code>| <code class="literal">TerrainAssets </code>| <code class="literal">SurfaceTextures</code><span>folder</span> in the example code for this book.</p><p>Finally, we will also need a blending <span>texture</span><a id="id325445053" class="indexterm"></a> that is <span>packed</span><a id="id325445062" class="indexterm"></a> with grayscale images. This will give us the four blending textures that we can use to direct how the color textures will be placed on the object surface.</p><p>We can use very intricate blending textures to create a very realistic distribution of terrain textures over a terrain mesh, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/0e78c464-e25a-45f9-89ff-e2d844008a78.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec61"></a>How to do it...</h3></div></div></div><p>Let's learn how to use packed textures by entering the code shown in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We need to add a few properties to our <code class="literal">Properties</code> block. We will need five <code class="literal">sampler2D</code> objects, or textures, and two <code class="literal">Color</code> properties:</li></ol></div><pre class="programlisting">Properties 
{ 
 _MainTint ("Diffuse Tint", Color) = (1,1,1,1) 
     
//Add the properties below so we can input all of our 
   textures 
  _ColorA ("Terrain Color A", Color) = (1,1,1,1) 
  _ColorB ("Terrain Color B", Color) = (1,1,1,1) 
  _RTexture ("Red Channel Texture", 2D) = ""{} 
  _GTexture ("Green Channel Texture", 2D) = ""{} 
  _BTexture ("Blue Channel Texture", 2D) = ""{} 
  _ATexture ("Alpha Channel Texture", 2D) = ""{} 
  _BlendTex ("Blend Texture", 2D) = ""{} 
} </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip40"></a>Note</h3><p>As always, remove the properties we are not using from the base shader from our code.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>We then need to <span>create</span><a id="id325445202" class="indexterm"></a> the <code class="literal">SubShader{}</code> section <span>variables</span><a id="id325445213" class="indexterm"></a> that will be our link to the data in the <code class="literal">Properties</code> block:</li></ol></div><pre class="programlisting">CGPROGRAM 
#pragma surface surf Lambert 

// Use shader model 3.5 target, to support enough textures
#pragma target 3.5
float4 _MainTint; 
float4 _ColorA; 
float4 _ColorB; 
sampler2D _RTexture; 
sampler2D _GTexture; 
sampler2D _BTexture; 
sampler2D _BlendTex; 
sampler2D _ATexture; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li><span>Due to the number</span> of items inside of our shader, we will need to <span>update</span><a id="id325451217" class="indexterm"></a> the target level version of our shader model to <code class="literal">3.5</code>:</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"></a>Note</h3><p>For more information on Shader Compilation Target Levels, check out: <a class="ulink" href="https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html" target="_blank">https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html</a>.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>So, now we have our texture properties and we are passing them to our <code class="literal">SubShader{}</code> function. In order to allow the user to change the tiling rates on a per-texture basis, we will need to modify our <code class="literal">Input</code> struct. This will allow us to use the tiling and offset parameters on each texture:</li></ol></div><pre class="programlisting">struct Input  
{ 
  float2 uv_RTexture; 
  float2 uv_GTexture; 
  float2 uv_BTexture; 
  float2 uv_ATexture; 
  float2 uv_BlendTex; 
}; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>In the <code class="literal">surf()</code> function, get the texture information and store it in its own variables so that we can work with the data in a clean, easy-to-understand way:</li></ol></div><pre class="programlisting">  void surf (Input IN, inout SurfaceOutput o) {
    //Get the pixel data from the blend texture 
    //we need a float 4 here because the texture 
    //will return R,G,B,and A or X,Y,Z, and W 
    float4 blendData = tex2D(_BlendTex, IN.uv_BlendTex); 

    //Get the data from the textures we want to blend 
    float4 rTexData = tex2D(_RTexture, IN.uv_RTexture); 
    float4 gTexData = tex2D(_GTexture, IN.uv_GTexture); 
    float4 bTexData = tex2D(_BTexture, IN.uv_BTexture); 
    float4 aTexData = tex2D(_ATexture, IN.uv_ATexture); </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip42"></a>Note</h3><p>Remember that due to us using Lambert, we will be using <code class="literal">SurfaceOutput</code> instead of <code class="literal">SurfaceOutputStandard</code> for the <code class="literal">surf</code> function.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Let's blend each of our <span>textures</span><a id="id325453560" class="indexterm"></a> together using the <code class="literal">lerp()</code> function. It takes three arguments, <code class="literal">lerp(value : a, value : b,</code> and <code class="literal">blend: c)</code>. The <code class="literal">lerp()</code> function takes in two <span>textures</span><a id="id325453600" class="indexterm"></a> and blends them with the float value given in the last argument:</li></ol></div><pre class="programlisting">//No we need to construct a new RGBA value and add all  
//the different blended texture back together 
float4 finalColor; 
finalColor = lerp(rTexData, gTexData, blendData.g); 
finalColor = lerp(finalColor, bTexData, blendData.b); 
finalColor = lerp(finalColor, aTexData, blendData.a);
finalColor.a = 1.0;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Finally, we multiply our blended texture by the color tint values and use the red channel to determine where the two different terrain tint colors go:</li></ol></div><pre class="programlisting">  //Add on our terrain tinting colors 
  float4 terrainLayers = lerp(_ColorA, _ColorB, blendData.r); 
  finalColor *= terrainLayers; 
  finalColor = saturate(finalColor); 

  o.Albedo = finalColor.rgb * _MainTint.rgb; 
  o.Alpha = finalColor.a;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Save your script and go back into Unity. Once there, you can assign the <code class="literal">TerrainBlend</code> texture to the <strong class="userinput"><code>Blend Texture</code></strong> property. Once you've done that, place different textures in the different channels in order to see our script in action:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/ae920f8e-648c-4a25-a93c-47e4bf51431a.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li><span>This</span> effect can be taken even further by using different textures and terrain tinting to create some great looking terrains with minimal effort. The result of blending together four terrain textures and creating a terrain tinting technique can be <span>seen</span><a id="id325453696" class="indexterm"></a> in <span>the</span><a id="id325453704" class="indexterm"></a> following screenshot:</li></ol></div><p></p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/f3543db4-f9e9-4b6f-87e9-d859fcbb6d2c.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec62"></a>How it works...</h3></div></div></div><p>This might seem like quite a few lines of code, but the concept behind blending is actually quite simple. For the technique to work, we have to employ the built-in <code class="literal">lerp()</code> function from the <code class="literal">CgFX</code> standard library. This function allows us to pick a value between argument one and argument two using argument three as the blend amount:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Function</p></td><td style="border-bottom: 0.5pt solid ; "><p>Description</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">lerp(a, b, f )</code></p></td><td style=""><p>This involves linear interpolation:</p><p><span class="emphasis"><em>(1 - f )* a + b * f</em></span></p><p>Here, <code class="literal">a</code> and <code class="literal">b</code> are matching vector or scalar types. The <code class="literal">f</code> parameter can be either a scalar or vector of the same type as <code class="literal">a</code> and <code class="literal">b</code>.</p></td></tr></tbody></table></div><p>So, for example, if we wanted to find the mid-value between <code class="literal">1</code> and <code class="literal">2</code>, we could feed the value <code class="literal">0.5</code> as the third argument to the <code class="literal">lerp()</code> function and it would return the value <code class="literal">1.5</code>. This works perfectly for our blending needs as the values of an individual channel in an RGBA texture are single float values, usually in the range of <code class="literal">0</code> to <code class="literal">1</code>.</p><p>In the shader, we simply take one of the channels from our <strong class="userinput"><code>Blend Texture</code></strong> and use it to drive the color that is picked in a <code class="literal">lerp()</code> function for each pixel. For instance, we take our grass texture and dirt texture, use the red channel from our blending texture, and feed this to a <code class="literal">lerp()</code> function. This will give us <span>the</span><a id="id325453865" class="indexterm"></a> correct <span>blended</span><a id="id325453874" class="indexterm"></a> color result for each pixel on the surface.</p><p>A more visual representation of what is happening when using the <code class="literal">lerp()</code> function is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/048e38e1-2608-43b1-b85a-520acf3b8dac.png" /></div><p>The shader code simply uses the four channels of the <strong class="userinput"><code>Blend Texture</code></strong> and all the color textures to create a final <strong class="userinput"><code>Blended Texture</code></strong>. This final texture then becomes the color that we can multiply with our diffuse lighting.</p></div></div>