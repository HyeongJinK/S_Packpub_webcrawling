<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec32"></a>Creating a custom diffuse lighting model</h2></div></div><hr /></div><p>If you are familiar with Unity 4, you may <span>know</span><a id="id325457683" class="indexterm"></a> that the default shader it provided was based on a <span>lighting</span><a id="id325457691" class="indexterm"></a> model called <span class="strong"><strong>Lambertian reflectance</strong></span>. This recipe will show you how it is possible to create a shader with a custom lighting model and explains the mathematics<span class="strong"><strong> </strong></span>involved and implementation. The following diagram shows the same geometry rendered with a Standard Shader (right) and a diffuse Lambert one (left):</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/aaf44609-d75b-4018-b379-a7f30aa2b304.png" /></div><p>Shaders based on Lambertian reflectance are classified as non-photorealistic; no object in the real world really looks like this. However, Lambert Shaders are still often used in low-poly games as they produce a neat contrast between the faces of complex geometries. The lighting model used to calculate the Lambertian reflectance is also very efficient, making it perfect for mobile games.</p><p>Unity has already provided us with a lighting function that we can use for our shaders. It is called the Lambertian lighting model. It is one of the more basic and efficient forms of reflectance, which you can find in a lot of games even today. As it is already built in the Unity Surface Shader language, we thought it best to start with this first and build on it. You can also find an example in the Unity reference manual, but we will go into more depth and explain where the data is coming from and why it is working the way it is. This will help you get a nice grounding in setting up <span>custom</span><a id="id325460897" class="indexterm"></a> lighting models so that we can build on this knowledge in the future recipes in this chapter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec66"></a>Getting ready</h3></div></div></div><p>Let's start by carrying out the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new shader and give it a name (<code class="literal">SimpleLambert</code>).</li><li>Create a new material, give it a name (<code class="literal">SimpleLambertMat</code>), and assign the new shader to its <code class="literal">shader</code> property.</li><li>Then, create a sphere object and place it roughly in the center of the scene and attach the new material to it.</li><li>Finally, let's create a directional light to cast some light on our object if one isn't created already.</li><li>When your assets have been set up in Unity, you should have a scene that resembles the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/9cfef2ae-2342-4073-80ed-8fdbc274cb69.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec67"></a>How to do it...</h3></div></div></div><p>The Lambertian reflectance can be <span>achieved</span><a id="id325463152" class="indexterm"></a> with the following changes to the shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Begin <span>by replacing the shader's <code class="literal">Properties</code> block with the following</span> :</li></ol></div><pre class="programlisting">Properties 
{
  _MainTex("Texture", 2D) = "white" 
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Since we are removing all of the other properties, remove the <code class="literal">_Glossiness</code>, <code class="literal">_Metallic</code>, and <code class="literal">_Color</code> declarations inside of the <code class="literal">SubShader</code> section.</li><li>Change the <code class="literal">#pragma</code> directive of the shader so that, instead of <code class="literal">Standard</code>, it uses our custom lighting model:</li></ol></div><pre class="programlisting">#pragma surface surf SimpleLambert  </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>If you try to run the script now, it will complain that it doesn't know what the <code class="literal">SimpleLambert</code> lighting model is. We will need to create a function called <code class="literal"><span><span>Lighting</span></span></code>  + the name that we gave here with instructions on how to light the object, which we will be writing later on in this recipe. In this case, it would be <code class="literal">LightingSimpleLambert</code>.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Use a very simple surface function, which just samples the texture according to its UV data:</li></ol></div><pre class="programlisting">void surf(Input IN, inout SurfaceOutput o) { 
  o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb; 
} </pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Add a function called <code class="literal">LightingSimpleLambert()</code> that will contain the following code for the Lambertian reflectance:</li></ol></div><pre class="programlisting">// Allows us to use the SimpleLambert lighting mode
half4 LightingSimpleLambert (SurfaceOutput s, half3 lightDir, 
                             half atten) 
{ 
  // First calculate the dot product of the light direction and the 
  // surface's normal
  half NdotL = dot(s.Normal, lightDir); 

  // Next, set what color should be returned
  half4 color; 

  color.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten); 
  color.a = s.Alpha; 

  // Return the calculated color
  return color; 
} </pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Save your script and <span>return</span><a id="id325453452" class="indexterm"></a> to the Unity editor. You should notice that it looks somewhat different than what was there before:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/eb1ccde1-4834-4a72-b3fc-4a6843fc266a.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>The effect is even easier to see if we use the cylinders we used in the previous chapter, <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Surface Shaders and Texture Mapping</em></span>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/ee904229-b423-4443-837b-6d8a489af731.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec68"></a>How it works...</h3></div></div></div><p>As previously seen in <a class="link" href="#" linkend="ch02"><span>Chapter 2</span></a>, <span class="emphasis"><em>Creating Your First Shader</em></span>, the <code class="literal">#pragma</code> directive is used to specify which surface function to use. Choosing a different lighting model works in a <span>similar</span><a id="id325453510" class="indexterm"></a> fashion: <code class="literal">SimpleLambert</code> forces Cg to look for a function called <code class="literal">LightingSimpleLambert()</code>. Note the <code class="literal">Lighting</code> at the beginning, which is omitted in the directive.</p><p>The <code class="literal">Lighting</code> function takes three parameters: the <span class="emphasis"><em>surface output</em></span> (which contains the physical properties such as the albedo and transparency), the <span class="emphasis"><em>direction</em></span> the light is coming from, and its <span class="emphasis"><em>attenuation</em></span>.</p><p>According to Lambertian reflectance, the amount of light a surface reflects depends on the angle between the incident light and surface normal. If you have played pool billiards, you are surely familiar with this concept; the direction of a ball depends on its incident angle against the wall. If you hit a wall at a 90 degree angle, the ball will come back at you; if you hit it with a very low angle, its direction will be mostly unchanged. The Lambertian model makes the same assumption; if the light hits a triangle at a 90 degree angle, all the light gets reflected back. The lower the angle, the less light is reflected back to you. This concept is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/104a9eaa-71a8-4e18-93e0-16b4c98a57ce.png" /></div><p>This simple concept has to be translated into a mathematical form. In vector algebra, the angle between two unit vectors can be calculated via an <span>operator</span><a id="id325453559" class="indexterm"></a> called <span class="strong"><strong>dot product</strong></span>. When the dot product is equal to zero, two vectors are orthogonal, which means that they make a 90-degree angle. When it is equal to one (or minus one), they are parallel to each other. Cg has a function called <code class="literal">dot()</code>, which implements the dot product extremely efficiently.</p><p>The following diagram shows a light source (sun) shining on a complex surface. <span class="strong"><strong>L</strong></span> indicates the light direction (called <code class="literal">lightDir</code> in the shader) and <span class="strong"><strong>N</strong></span><span>is the normal to the surface</span>. The light is <span>reflected</span><a id="id325453627" class="indexterm"></a> with the same angle that it hits the surface with:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/99958073-b626-4dba-971a-37868e055b1c.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note45"></a>Note</h3><p>For more information on normals and what they mean mathematically check out: <a class="ulink" href="https://en.wikipedia.org/wiki/Normal_(geometry)" target="_blank">https://en.wikipedia.org/wiki/Normal_(geometry)</a></p></div><p>Lambertian reflectance simply uses the <code class="literal">NdotL</code> dot <span>product</span><a id="id325453660" class="indexterm"></a> as a multiplicative coefficient for the intensity of light:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/b405fe09-711e-44e5-9b07-9e823b66cc58.png" /></div><p>When <span class="emphasis"><em>N</em></span> and <span class="emphasis"><em>L</em></span> are parallel, all the light is reflected back to the source, causing the geometry to appear brighter. The <code class="literal">_LightColor0</code> variable contains the color of the light that is calculated.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note46"></a>Note</h3><p>Prior to Unity 5, the intensity of the lights was different. If you are using an old diffuse shader based on the Lambertian model, you may notice that <code class="literal">NdotL</code> is multiplied by two: <code class="literal">(NdotL * atten * 2)</code>, rather than <code class="literal">(NdotL * atten)</code>. If you are importing a custom shader from Unity 4, you will need to correct this manually. Legacy Shaders, however, have already been designed taking this aspect into account.</p></div><p>When the dot product is negative, the light is coming from the opposite side of the triangle. This is not a problem for opaque geometries as triangles that are not facing the <span>camera</span><a id="id325453745" class="indexterm"></a> frontally are culled (discarded) and not rendered.</p><p>This basic Lambert is a great starting point when you are prototyping your shaders as you can get a lot accomplished in terms of writing the core functionality of the shader while not having to worry about the basic <code class="literal">Lighting</code> functions.</p><p>Unity has provided us with a lighting model that has already taken the task of creating a Lambert lighting for you. If you look at the <code class="literal">UnityCG.cginc</code> file found in your Unity's installation directory under the <code class="literal">Data</code> folder, you will notice that you have Lambert and BlinnPhong lighting models available for you to use. The moment you compile your shader with <code class="literal">#pragma surface surf Lambert</code>, you are telling the shader to utilize Unity's implementation of the Lambert <code class="literal">Lighting</code> function in the <code class="literal">UnityCG.cginc</code> file so that you don't have to write that code over and over again. We will explore how the BlinnPhong model works later in this chapter.</p></div></div>