<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec26"></a>Creating a shader with normal mapping</h2></div></div><hr /></div><p>Every triangle of a 3D model has a <span class="emphasis"><em>facing direction</em></span>, which is the direction that it is pointing toward. It is often represented with an arrow placed in the center of the <span>triangle</span><a id="id325209447" class="indexterm"></a> and is <span>orthogonal</span><a id="id325209456" class="indexterm"></a> to the surface. The facing direction plays an important role in the way light reflects on a surface. If two adjacent triangles face different directions, they will reflect lights at different angles, hence they'll be shaded differently. For curved objects, this is a problem: it is obvious that the geometry is made out of flat triangles.</p><p>To avoid this problem, the way the light reflects on a triangle doesn't take into account its facing direction, but its <span class="emphasis"><em>normal direction</em></span> instead. As stated in the <span class="emphasis"><em>Adding a texture to a shader</em></span> recipe, vertices can store data; the normal direction is the most used information after the UV data. This is a vector of unit length (which means it has a length of 1) that indicates the direction faced by the vertex.</p><p>Regardless of the facing direction, every point within a triangle has its own normal direction that is a linear interpolation of the ones stored in its vertices. This gives us the ability to fake the effect of high-resolution geometry on a low-resolution model.</p><p>The following screenshot shows the same geometric shape rendered with different per-vertex normals. In the <span>image, on the left</span>, normals are orthogonal to the face represented by its vertices; this indicates that there is a clear separation between each face. On the right, normals are interpolated along the surface, indicating that even if the surface is rough, a light should reflect as if it's smooth. It's easy to see that even if the three objects in the following screenshot share the same geometry, they reflect light differently. Despite being made out of flat triangles, the object on the right reflects light as if its surface was actually curved:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/b7217b8b-3f63-421a-84b8-015d821f6c37.png" /></div><p>Smooth objects with rough edges are a clear indication that per-vertex normals have been interpolated. This can be seen if we draw the direction of the normal stored in every vertex, as shown in the following screenshot. You should note that every triangle has only three normals, but as <span>multiple</span><a id="id325209495" class="indexterm"></a> triangles can <span>share</span><a id="id325453518" class="indexterm"></a> the same vertex, more than one line can come out of it:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/bf74ab39-f220-4d7f-9752-1e55dae311c4.png" /></div><p>Calculating the normals from the 3D model is a technique that has rapidly declined in favor of a more advanced one-normal mapping. Similar to what happens with texture mapping, the normal directions can be provided using an additional texture, usually called a normal map or bump map.</p><p>Normal maps are usually images where the red, green, and blue channels of the image are used to indicate the <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>, and <span class="emphasis"><em>Z</em></span> components of the normal direction. There <span>are</span><a id="id325453595" class="indexterm"></a> many ways to create normal maps these days. Some applications, such <span>as</span><a id="id325453604" class="indexterm"></a> CrazyBump (<span><a class="ulink" href="http://www.crazybump.com/" target="_blank">http://www.crazybump.com/</a></span>) and NDO Painter (<span><a class="ulink" href="http://quixel.se/ndo/" target="_blank">http://quixel.se/ndo/</a></span>), will take in 2D data and convert it to normal data for you. Other applications such as Zbrush 4R7 (<span><a class="ulink" href="http://www.pixologic.com/" target="_blank">http://www.pixologic.com/</a></span>) and AUTODESK (<span><a class="ulink" href="http://usa.autodesk.com/" target="_blank">http://usa.autodesk.com</a></span>) will take 3D-sculpted data and create <span>normal</span><a id="id325453634" class="indexterm"></a> maps for you. The actual process of creating <span>normal</span><a id="id325453642" class="indexterm"></a> maps is out of the scope of this book, but the links in the previous text should help you get started.</p><p>Unity makes the process of adding normals to your shaders quite an easy process in the Surface Shader realm using the <code class="literal">UnpackNormals()</code> function. Let's see how this is done.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec48"></a>Getting ready</h3></div></div></div><p>To begin this recipe, first <span>create</span><a id="id325453767" class="indexterm"></a> a new <span>scene</span><a id="id325453776" class="indexterm"></a> by selecting <strong class="userinput"><code>File </code></strong>| <strong class="userinput"><code>New Scene</code></strong>. Then, create a sphere game object by going to <strong class="userinput"><code>GameObject </code></strong>| <strong class="userinput"><code>3D Objects </code></strong>| <strong class="userinput"><code>Sphere</code></strong>. Double-click on the object in the <strong class="userinput"><code>Hierarchy</code></strong> tab to bring the object into focus in the <strong class="userinput"><code>Scene</code></strong> tab. You will also need to create a new standard Surface Shader file (<code class="literal">NormalShader</code>) and material (<code class="literal">NormalShaderMat</code>). Once created, set the material to a sphere in the <strong class="userinput"><code>Scene</code></strong> view. This will give us a clean workspace in which we can look at just the normal mapping technique:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/6e2a51bc-cff0-4ef7-b342-13ac833749bf.png" /></div><p>You will need a normal map for this recipe, but there is also one in the Unity project included with this book.</p><p>An <span>example</span><a id="id325453451" class="indexterm"></a> normal map <span>included</span><a id="id325453460" class="indexterm"></a> with this book's content is shown here:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/1c1e649a-9cbb-49ad-8165-f5e48c6705c6.png" /></div><p>You can see it for yourself in the <code class="literal"><span>Assets </span></code>|  <code class="literal">Chapter 03 </code>| <code class="literal">Textures</code> folder under <code class="literal">normalMapExample</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec49"></a>How to do it...</h3></div></div></div><p>The following are the steps to create a normal map shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Let's get the <code class="literal">Properties</code> block set up in order to have a color <code class="literal">Tint</code> and texture:</li></ol></div><pre class="programlisting">Properties 
{ 
  _MainTint ("Diffuse Tint", Color) = (0,1,0,1) 
  _NormalTex ("Normal Map", 2D) = "bump" {} 
} </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>In this case, I have 1 in the green and alpha channels and <code class="literal">0</code> for red and blue, so the default color will be green. For the <code class="literal">_NormalTex</code> property, we are using a 2D type, which means we can use a 2D image to dictate what each pixel will use. By initializing the texture as <code class="literal">bump</code>, we are telling Unity that <code class="literal">_NormalTex</code> will contain a normal map (sometimes referred to as bump maps as well, hence the bump name). If the texture is not set, it will be replaced by a grey texture. The color used (<code class="literal">0.5</code>, <code class="literal">0.5</code>, <code class="literal">0.5</code>, <code class="literal">1</code>) indicates no bump at all.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li> In the <code class="literal">SubShader{}</code> block, scroll <span>below</span><a id="id325209579" class="indexterm"></a>the <code class="literal">CGPROGRAM</code> statement <span>and</span><a id="id325209591" class="indexterm"></a> remove the original <code class="literal">_MainText</code>,  <code class="literal">_Glossiness</code>, <code class="literal">_Metallic</code>, and <code class="literal">_Color</code> definitions. Afterward, add in our <code class="literal">_NormalTex</code> and <code class="literal">_MainTint</code>: </li></ol></div><pre class="programlisting">    CGPROGRAM
    // Physically based Standard lighting model, and enable shadows 
    // on all light types
    #pragma surface surf Standard fullforwardshadows

    // Use shader model 3.0 target, to get nicer looking lighting
    #pragma target 3.0

    // Link the property to the CG program 
    sampler2D _NormalTex; 
    float4 _MainTint; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>We need to make sure that we update the <code class="literal">Input</code> <span>struct</span> with the proper variable name so that we can use the model's UVs for the normal map texture:</li></ol></div><pre class="programlisting">// Make sure you get the UVs for the texture in the struct 
struct Input 
{ 
  float2 uv_NormalTex; 
} </pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Finally, we extract the normal information from the normal map texture using the built-in <code class="literal">UnpackNormal()</code> function. Then, you only have to apply these new normals to the output of the Surface Shader:</li></ol></div><pre class="programlisting">void surf (Input IN, inout SurfaceOutputStandard o) {
  // Use the tint provided as the base color for the material
  o.Albedo = _MainTint;

  // Get the normal data out of the normal map texture 
  // using the UnpackNormal function 
  float3 normalMap = UnpackNormal(tex2D(_NormalTex, 
    IN.uv_NormalTex)); 

  // Apply the new normal to the lighting model 
  o.Normal = normalMap.rgb; 
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Save your script and return to the Unity editor. You should notice that the sphere has now become green by default if added. More importantly though, notice the <strong class="userinput"><code>Normal Map</code></strong> property that has been added. Drag and drop the normal map texture into the slot.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>You may notice some changes, but it may be hard to visually see what is going on. In the <strong class="userinput"><code>Normal Map</code></strong> property, change the <strong class="userinput"><code>Tiling</code></strong> to (<code class="literal">10</code>, <code class="literal">10</code>). This way, you <span>can</span><a id="id325453850" class="indexterm"></a> see the <span>normal</span><a id="id325453859" class="indexterm"></a> map duplicated 10 times over the course of the sphere in the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> axes instead of only once:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/09280c06-2052-4c09-bb7d-458ae116af61.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>The following screenshot demonstrates the result of our normal map shader:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/385d76bc-af09-44e3-b3f4-efbce244199f.png" /></div><p></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p>Shaders can have both a texture map and a normal map. It is not uncommon to use the same UV data to address both. However, it is possible to provide a secondary set of UVs in the vertex data (UV2), which are specifically used for the normal map.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec50"></a>How it works...</h3></div></div></div><p>The actual math to perform the <span>normal</span><a id="id325453912" class="indexterm"></a> mapping effect is <span>definitely</span><a id="id325453921" class="indexterm"></a> beyond the scope of this chapter, but Unity has done it all for us already. It has created the functions for us so that we don't have to keep doing it over and over again. This is another reason why Surface Shaders are a really efficient way to write shaders.</p><p>If you look in the <code class="literal">UnityCG.cginc</code> file found in the <code class="literal">Editor</code> | <code class="literal"><span>Data</span></code>| <code class="literal"><span>CGIncludes</span></code> folder in your Unity installation directory, you will find the definitions for the <code class="literal">UnpackNormal()</code> function. When you declare this function in your Surface Shader, Unity takes the normal map provided and processes it for you, giving you the correct type of data so that you can use it in your per-pixel lighting function. It's a huge time-saver! When sampling a texture, you get RGB values from <code class="literal">0</code> to <code class="literal">1</code>; however, the directions of a normal vector range from <code class="literal">-1</code> to <code class="literal">1</code>. <code class="literal">UnpackNormal()</code> brings these components into the right range.</p><p>Once you have processed the normal map with the <code class="literal">UnpackNormal()</code> function, you send it back to your <code class="literal">SurfaceOutput</code> struct so that it can be used in the lighting function. This is done by using <code class="literal">o.Normal = normalMap.rgb;</code>. We will see how the normal is actually used to calculate the final color of each pixel in <a class="link" href="#" linkend="ch04"><span>Chapter</span><span>4</span></a>, <span><span class="emphasis"><em>Understanding Lighting Models</em></span>.</span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec51"></a>There's more...</h3></div></div></div><p>You can also add some controls to your normal map shader that lets a user adjust the intensity of the normal map. This is easily done by modifying the <code class="literal">x</code> and <code class="literal">y</code> components of the normal map variable and then adding it all back together. Add another property to the <code class="literal">Properties</code> block and name it <code class="literal">_NormalMapIntensity</code>:</p><pre class="programlisting">_NormalMapIntensity("Normal intensity", Range(0,3)) = 1 </pre><p>In this case, we are giving the property the ability to be between <code class="literal">0</code> and <code class="literal">3</code> with a default value of <code class="literal">1</code>. Once created, you'll need to add the variable inside the SubShader:</p><pre class="programlisting">// Link the property to the CG program 
sampler2D _NormalTex; 
float4 _MainTint; 
<span class="strong"><strong>float _NormalMapIntensity;</strong></span></pre><p>After the property is added, we can make use of it. Multiply the <code class="literal">x</code> and <code class="literal">y</code> components of the unpacked normal map and reapply this value to the <span>normal</span><a id="id325454049" class="indexterm"></a> map variable with the <span>bolded</span><a id="id325454057" class="indexterm"></a> changes:</p><pre class="programlisting">void surf (Input IN, inout SurfaceOutputStandard o) {
  // Use the tint provided as the base color for the material
  o.Albedo = _MainTint;

  // Get the normal data out of the normal map texture 
  // using the UnpackNormal function 
  float3 normalMap = UnpackNormal(tex2D(_NormalTex, 
    IN.uv_NormalTex)); 
<span class="strong"><strong></strong></span>
<span class="strong"><strong>  normalMap.x *= _NormalMapIntensity; </strong></span>
<span class="strong"><strong>  normalMap.y *= _NormalMapIntensity; </strong></span>

<span class="strong"><strong>  // Apply the new normal to the lighting model </strong></span>
<span class="strong"><strong>  o.Normal = normalize(normalMap.rgb);</strong></span>
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>
Normal vectors are supposed to have lengths equal to one. Multiplying them for <code class="literal">_NormalMapIntensity</code> changes their length, making normalization necessary. The normalize function will take the vector and adjust it so that it is pointing in the correct direction but with a length of one, which is what we are looking for.</p></div><p>Now, you can let a user adjust the intensity of the normal map in the material's <strong class="userinput"><code>Inspector</code></strong> tab, as follows:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/d713669c-a5b0-4f6f-8571-8f2a459352b6.png" /></div><p>The following <span>screenshot</span><a id="id325465242" class="indexterm"></a> shows the result of <span>modifying</span><a id="id325465251" class="indexterm"></a> the normal map with our scalar values:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/b35c877b-ec37-4707-87da-d24d233eb826.png" /></div></div></div>