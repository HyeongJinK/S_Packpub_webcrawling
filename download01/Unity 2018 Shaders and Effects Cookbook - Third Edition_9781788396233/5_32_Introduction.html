<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec37"></a>Introduction</h2></div></div><hr /></div><p><span>All</span> the lighting models encountered in <a class="link" href="#" linkend="ch04"><span>Chapter 4</span></a>, <span class="emphasis"><em>Understanding Lighting Models</em></span>, were very primitive descriptions of how light behaves. The most important aspect during their making was <span class="emphasis"><em>efficiency</em></span>. Real-time shading is expensive, and techniques such as Lambertian or BlinnPhong are a compromise between computational cost and realism.</p><p>Having a more powerful GPU has allowed us to write progressively more sophisticated lighting models and rendering engines, with the aim of simulating how light actually behaves. This is, in a nutshell, the philosophy behind PBR. As the name suggests, it tries to get as close as possible to the physics behind the processes that give a unique look at each material. Despite this, the term PBR has been widely used in marketing campaigns and is more of a <span>synonym</span><a id="id325209390" class="indexterm"></a> for <span class="strong"><strong>state-of-the-art rendering</strong></span> rather than a well-defined technique.</p><p>Unity implements PBR in two main ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The first is a <span>completely</span><a id="id325209411" class="indexterm"></a> new lighting model (called Standard). Surface Shaders allow developers to specify the physical properties of a material, but they do not impose actual physical constraints on them. PBR fills this by gap using a lighting model that enforces principles of physics <span>such</span><a id="id325209419" class="indexterm"></a> as <span class="strong"><strong>energy conservation</strong></span> (an object cannot reflect more light than the <span>amount</span><a id="id325209437" class="indexterm"></a> it receives), <span class="strong"><strong>microsurface scattering</strong></span> (rough surfaces reflect light more erratically compared to smooth ones), <span class="strong"><strong>Fresnel reflectance</strong></span> (specular <span>reflections</span><a id="id325209453" class="indexterm"></a> appear at grazing angles), and <span class="strong"><strong>surface occlusion</strong></span> (the darkening of corners and other geometries that are hard to light). All these aspects, and many others, are used to calculate the <span>standard</span><a id="id325209464" class="indexterm"></a> lighting model.</li><li style="list-style-type: disc">The second aspect that makes PBR so <span>realistic</span><a id="id325209474" class="indexterm"></a> is called <span class="strong"><strong>Global Illumination</strong></span> (<span class="strong"><strong>GI</strong></span>) and is the simulation of physically-based light transport. It means that objects are not drawn in the scene as if they were separate entities. They all contribute to the final rendering as light can reflect on them before hitting something else. This aspect is not captured in the shaders themselves, but is an essential part of how the rendering engine works. Unfortunately, accurately simulating how light rays actually bounce over surfaces in real time is beyond the capabilities of modern GPUs. <span>Unity</span> makes some clever optimizations that allow us to retain visual fidelity without sacrificing performance. Some of the most advanced techniques (such as reflections), however, require user input.</li></ul></div><p>All of these aspects will be covered in this chapter. It is important to remember that PBR and GI do not automatically guarantee that your game will be photorealistic. Achieving photorealism is a very challenging task and, like every art, it requires great expertise and exceptional skills.</p></div>