<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec47"></a>Implementing a volumetric explosion</h2></div></div><hr /></div><p>The art of game <span>development</span><a id="id325209371" class="indexterm"></a> is a clever trade-off between realism and efficiency. This is particularly true for explosions; they are at the heart of many games, yet the physics behind them is often beyond the computational power of modern machines. Explosions are, essentially, nothing more than very hot balls of gas; hence, the only way to correctly simulate them is by integrating a fluid simulation into your game. As you can imagine, this is unfeasible for a runtime application, and many games simulate them simply with particles. When an object explodes, it is common to simply instantiate fire, smoke, and debris particles so that, together, they can achieve believable results. This approach, unfortunately, is not very realistic and is easy to spot. There is an intermediate technique that can be used to achieve a much more realistic effect: volumetric explosions. The idea behind this concept is that explosions are not treated like a bunch of particles; they are evolving 3D objects, not just flat 2D textures.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec113"></a>Getting ready</h3></div></div></div><p>Complete this recipe with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new shader for this effect (<code class="literal">VolumetricExplosion</code>).</li><li>Create a new material to host the shader (<code class="literal">VolumetricExplosionMat</code>).</li><li>Attach the material to a sphere. You can create one directly from the editor, navigating to <strong class="userinput"><code>GameObject </code></strong>| <strong class="userinput"><code>3D Object </code></strong>| <strong class="userinput"><code>Sphere</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/3d710a2a-e34a-4563-8529-17537f8999e7.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note60"></a>Note</h3><p>This recipe works well with the standard Unity Sphere, but if you need big explosions, you might need to use a high-poly sphere. In fact, a vertex function can only modify the vertices of a mesh. All the other points will be interpolated using the positions of the nearby vertices. Fewer vertices means a lower resolution for your explosions.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>For this recipe, you will also <span>need</span><a id="id325454158" class="indexterm"></a> a ramp texture that has, in a gradient, all the colors your explosions will have. You can create a texture like the following screenshot using GIMP or Photoshop:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/30fd1478-9d05-4fb5-943f-3c42f25fd7a4.png" /></div><p></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip61"></a>Note</h3><p>You can find this image (<code class="literal">explosionRamp</code>) in <code class="literal">Chapter 6 </code>| <code class="literal">Textures</code> folder in the example code provided with this book.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Once you have the picture, import it to Unity. Then, from its <strong class="userinput"><code>Inspector</code></strong>, make sure that <strong class="userinput"><code>Filter Mode</code></strong> is set to <strong class="userinput"><code>Bilinear</code></strong> and the <strong class="userinput"><code>Wrap Mode</code></strong> to <strong class="userinput"><code>Clamp</code></strong>. These two settings make sure that the ramp texture is sampled smoothly.</li><li>Lastly, you will need a noisy texture. You can search on the internet for freely available noise textures. The most commonly used ones are generated using Perlin noise. I have included an example in <code class="literal">Chapter 6 </code>| <code class="literal">Textures</code> folder for your use:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/2dd0375b-cde1-4a77-8adb-a7b00086f3c1.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec114"></a>How to do it…</h3></div></div></div><p>This effect works in two steps: a vertex function to change the geometry, and a surface function to give it the right color. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Remove the current properties and add the following properties to the shader:</li></ol></div><pre class="programlisting">Properties 
{
  _RampTex("Color Ramp", 2D) = "white" {}
  _RampOffset("Ramp offset", Range(-0.5,0.5))= 0

  _NoiseTex("Noise Texture", 2D) = "gray" {}
  _Period("Period", Range(0,1)) = 0.5

  _Amount("_Amount", Range(0, 1.0)) = 0.1
  _ClipRange("ClipRange", Range(0,1)) = 1
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Add their relative variables so that the Cg code of the shader can actually access them:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sampler2D</strong></span>_RampTex;
<span class="strong"><strong>half</strong></span>_RampOffset;

<span class="strong"><strong>sampler2D</strong></span>_NoiseTex;
<span class="strong"><strong>float</strong></span>_Period;

<span class="strong"><strong>half</strong></span>_Amount;
<span class="strong"><strong>half</strong></span>_ClipRange;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Change the <code class="literal">Input</code> structure so that it receives the UV data of the ramp texture:</li></ol></div><pre class="programlisting"><span class="strong"><strong>struct</strong></span>Input 
{
<span class="strong"><strong>  float2</strong></span>uv_NoiseTex;
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Add the following vertex function:</li></ol></div><pre class="programlisting"><span class="strong"><strong>void</strong></span>vert(<span class="strong"><strong>inout</strong></span>appdata_full v) {
<span class="strong"><strong>  float3</strong></span>disp = tex2Dlod(_NoiseTex, <span class="strong"><strong>float4</strong></span>(v.texcoord.xy,0,0));
<span class="strong"><strong>  float</strong></span>time = sin(_Time[3] *_Period + disp.r*10);
  v.vertex.xyz += v.normal * disp.r * _Amount * time;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Add <span>the</span><a id="id325453555" class="indexterm"></a> following surface function:</li></ol></div><pre class="programlisting">void surf(Input IN, inout SurfaceOutput o) 
{
  float3 noise = tex2D(_NoiseTex, IN.uv_NoiseTex);

  float n = saturate(noise.r + _RampOffset);

  clip(_ClipRange - n);

  half4 c = tex2D(_RampTex, float2(n,0.5));

  o.Albedo = c.rgb;
  o.Emission = c.rgb*c.a;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>We specify the vertex function in the <code class="literal">#pragma</code> directive, adding the <code class="literal">nolightmap</code> parameter to prevent Unity from adding realistic lighting to our explosion:</li></ol></div><pre class="programlisting"><span class="strong"><strong>#pragma</strong></span> surface surf Lambert vertex:vert nolightmap</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>The last step is selecting the material and, from its <strong class="userinput"><code>Inspector</code></strong>, attaching the two textures in the relative slots:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/3d95944f-a524-451b-8349-18892c416d96.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>This is animated material, meaning that it evolves over time. You can watch <span>the</span><a id="id325454268" class="indexterm"></a> material changing in the editor by clicking on <strong class="userinput"><code>Animated Materials</code></strong> from the <strong class="userinput"><code>Scene</code></strong> window:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/43b66c19-724b-4dcf-a8da-5fb5bbc15747.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec115"></a>How it works…</h3></div></div></div><p>If you are reading this recipe, you should already be familiar with how Surface Shaders and vertex modifiers work. The main idea behind this effect is to alter the geometry of the sphere in a seemingly chaotic way, exactly as it happens in a real explosion. The following screenshot shows you what such an explosion will look like inside the editor. You can see that the original mesh has been heavily deformed:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/e69665fb-bdce-4797-9353-eaf58f3ed430.png" /></div><p>The vertex function is a variant of <span>the</span><a id="id325209442" class="indexterm"></a> technique called normal extrusion introduced in the <span class="emphasis"><em>Extruding your models</em></span> recipe of this chapter. The difference here is that the amount of extrusion is determined both by the time and noise texture.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note62"></a>Note</h3><p>When you need a random number in Unity, you can rely on the <code class="literal">Random.Range()</code> function. There is no standard way to get random numbers in a shader, so the easiest way is to sample a noise texture.</p></div><p>There is no standard way to do this, so take this as an example only:</p><pre class="programlisting"><span class="strong"><strong>float</strong></span>time = sin(_Time[3] *_Period + disp.r*10);</pre><p>The built-in <code class="literal">_Time[3]</code> variable is used to get the current time from within the shader, and the red channel of the <code class="literal">disp.r</code> noise texture is used to make sure that each vertex moves independently. The <code class="literal">sin()</code> function makes the vertices go up and down, simulating the chaotic behavior of an explosion. Then, the normal extrusion takes place:</p><pre class="programlisting">v.vertex.xyz += v.normal * disp.r * _Amount * time;</pre><p>You should play with these numbers and variables until you find a pattern of movement that you are happy with.</p><p>The last part of the effect is achieved by the surface function. Here, the noise texture is used to sample a random color from the ramp texture. However, there are two more aspects that are worth noting. The first one is the introduction of <code class="literal">_RampOffset</code>. Its usage forces the explosion to sample colors from the left or right side of the texture. With positive values, the surface of the explosion tends to show more grey tones—exactly what happens when it is dissolving. You can use <code class="literal">_RampOffset</code> to determine how much fire or smoke there should be in your explosion. The second aspect introduced in the surface function is the usage of <code class="literal">clip()</code>. What <code class="literal">clip()</code> does is it clips (removes) pixels from the rendering pipeline. When invoked with a negative value, the current pixel is not drawn. This effect is controlled by <code class="literal">_ClipRange</code>, which determines which pixels of the volumetric explosions are going to be transparent.</p><p>By controlling both <code class="literal">_RampOffset</code> and <code class="literal">_ClipRange</code>, you have full <span>control</span><a id="id325209527" class="indexterm"></a> and can determine how the explosion behaves and <span>dissolves</span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec116"></a>There's more…</h3></div></div></div><p>The shader presented in this recipe makes a sphere look like an explosion. If you really want to use it, you should couple it with some scripts in order to get the most out of it. The best thing to do is to create an explosion object and make it into a prefab so that you can reuse it every time you need to. You can do this by dragging the sphere back into the <strong class="userinput"><code>Project</code></strong> window. Once it is done, you can create as many explosions as you want using the <code class="literal">Instantiate()</code> function.</p><p>It is worth noticing, however, that all the objects with the same material share the same look. If you have multiple explosions at the same time, they should not use the same material. When you are instantiating a new explosion, you should also duplicate its material. You can do this easily with this piece of code:</p><pre class="programlisting">GameObject explosion = Instantiate(explosionPrefab) as GameObject;
Renderer renderer = explosion.GetComponent&lt;Renderer&gt;();
Material material = new Material(renderer.sharedMaterial);
renderer.material = material;</pre><p>Lastly, if you are going to use this shader in a realistic way, you should attach a script to it that changes its size, <code class="literal">_RampOffset</code>, and <code class="literal">_ClipRange</code> according to the type of explosion that you want to recreate.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec117"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Much more can be done to make explosions realistic. The approach presented in this recipe only creates an empty shell; inside it, the explosion is actually empty.</li><li style="list-style-type: disc">An easy trick to improve this is to create particles inside it. However, you can only go so far with this.</li><li style="list-style-type: disc">The short movie, <span class="emphasis"><em>The Butterfly Effect</em></span> (<a class="ulink" href="http://unity3d.com/pages/butterfly" target="_blank">http://unity3d.com/pages/butterfly</a>), created by Unity Technologies in collaboration with Passion Pictures<span>and</span><a id="id325453687" class="indexterm"></a>Nvidia, is the perfect example.</li><li style="list-style-type: disc">It is based on the same concept of altering the geometry of a sphere, but it renders it with a technique called <span class="strong"><strong>volume ray casting</strong></span>.</li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">In a nutshell, it <span>renders</span><a id="id325453710" class="indexterm"></a> the <span>geometry</span><a id="id325453717" class="indexterm"></a> as if it's full. You can see an example in the following screenshot:</li></ul></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/8b10b5f7-0f44-4d37-b2d2-bf20c105fe8c.png" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">If you are looking for high-quality explosions, check out PyroTechnix (<a class="ulink" href="https://www.assetstore.unity3d.com/en/#!/content/16925" target="_blank">https://www.assetstore.unity3d.com/en/#!/content/16925</a>) in the Asset Store. It includes volumetric explosions <span>and</span><a id="id325453745" class="indexterm"></a> couples them with realistic shockwaves.</li></ul></div></div></div>