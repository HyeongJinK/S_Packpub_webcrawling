<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec45"></a>Extruding your models</h2></div></div><hr /></div><p>One of the biggest problems in <span>games</span><a id="id325209371" class="indexterm"></a> is repetition. Creating new content is a time-consuming task, and when you have to face thousands of enemies, chances are that they will all look the same. A relatively cheap technique to add variation to your models is using a shader that alters its basic geometry. This recipe will show you a <span>technique</span><a id="id325453452" class="indexterm"></a> called <span class="strong"><strong>normal extrusion</strong></span>, which can be used to create a chubbier or skinnier version of a model, as shown in the following screenshot of a soldier from the Unity camp demo:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/4fff81d8-4b6e-4e38-836d-a6d23502ae23.png" /></div><p>For ease of use, I have provided a prefab of the solider in the example code for this book under the <code class="literal">Chapter 6 </code>| <code class="literal">Prefabs</code> folder.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec105"></a>Getting ready</h3></div></div></div><p>For this recipe, you need to have access to the shader used by the model that you want to alter. Once you have it, we duplicate it so that we can edit it safely. It can be done as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Find the shader your model is using and, once selected, duplicate it by pressing <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>D</em></span>. If it is just using the Standard Shader, as in this example, it is also possible to just create a new Standard Material such as normal, and the Albedo map will automatically transfer over. Either way, rename this new shader <code class="literal">NormalExtrusion</code>.</li><li>Duplicate the original <span>material</span><a id="id325457696" class="indexterm"></a> of the model and assign the cloned shader to it.</li><li>Assign the new material to your model (<code class="literal">NormalExtrusionMat</code>) and start editing it.</li></ol></div><p>In order for this effect to work, your model should have <span class="strong"><strong>normals</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec106"></a>How to do it…</h3></div></div></div><p>To create this effect, start by modifying the duplicated shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Let's start by adding a property to our shader, which will be used to modulate its extrusion. The range presented here goes from <code class="literal">-0.0001</code> to <code class="literal">0.0001</code>, but you might have to adjust this according to your own needs:</li></ol></div><pre class="programlisting">__Amount ("Extrusion Amount", Range(-0.0001, 0.0001)) = 0</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Couple the property with its respective variable:</li></ol></div><pre class="programlisting">float _Amount;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Change the <code class="literal">#pragma</code> directive so that it now uses a vertex modifier. You can do this by adding <code class="literal">vertex:function_name</code> at the end of it. In our case, we have called the <code class="literal">vert:</code> function:</li></ol></div><pre class="programlisting">#pragma surface surf Standard vertex:vert</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Add the following vertex modifier:</li></ol></div><pre class="programlisting">void vert (inout appdata_full v) 
{
  v.vertex.xyz += v.normal * _Amount;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>The shader is now ready; you can use the Extrusion Amount slider in the material's <strong class="userinput"><code>Inspector</code></strong> tab to make your model skinnier or chubbier. Also, feel free to create a clone of the <span>material</span><a id="id325464992" class="indexterm"></a> in order to have different extrusion amounts for each character:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/f39062c0-24b3-4685-bce1-aea8f2ccd9ef.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec107"></a>How it works…</h3></div></div></div><p>Surface Shaders work in two steps. In all the previous chapters, we only explored its last one: the surface function. There is another function that can be used: the vertex modifier. It takes the data structure of a vertex (which is usually called <code class="literal">appdata_full</code>) and applies a transformation to it. This gives us the freedom to do virtually anything with the geometry of our model. We signal to the GPU that <span>such</span><a id="id325209437" class="indexterm"></a> a function exists by adding <code class="literal">vertex:vert</code> to the <code class="literal">#pragma</code> directive of the Surface Shader. You can refer to <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Fragment Shaders and Grab Passes</em></span>, to learn how vertex modifiers can be defined in a Vertex and Fragment Shader instead.</p><p>One of the most simple yet effective <span>techniques</span><a id="id325209461" class="indexterm"></a> that can be used to alter the geometry of a model is called normal extrusion. It works by projecting a vertex along its normal direction. This is done by the following line of code:</p><pre class="programlisting">v.vertex.xyz += v.normal * _Amount;</pre><p>The position of a vertex is displaced by <code class="literal">_Amount</code> units toward the vertex normal. If <code class="literal">_Amount</code> gets too high, the results can be quite unpleasant. With smaller values, however, you can add a lot of variation to your models.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec108"></a>There's more…</h3></div></div></div><p>If you have multiple enemies and want each one to have its own weight, you have to create a different material for each one of them. This is necessary as materials are normally shared between models and changing one will change all of them. There are several ways in which you can do this; the quickest one is to create a script that automatically does it for you. The following script, once attached to an object with a <code class="literal">Renderer</code>, will duplicate its first material and set the <code class="literal">_Amount</code> property automatically:</p><pre class="programlisting"><span class="strong"><strong>using</strong></span>UnityEngine;
<span class="strong"><strong>public class</strong></span> NormalExtruder : MonoBehaviour {
  [Range(-0.0001f, 0.0001f)]
<span class="strong"><strong>  public float</strong></span> amount = 0;
  // Use this for initialization
<span class="strong"><strong>  void</strong></span>Start () 
  {
    Material material = GetComponent&lt;Renderer&gt;().sharedMaterial;
    Material newMaterial = <span class="strong"><strong>new</strong></span>Material(material);
    newMaterial.SetFloat("_Amount", amount);
    GetComponent&lt;Renderer&gt;().material = newMaterial;
  }
}</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec7"></a>Adding extrusion maps</h4></div></div></div><p>This technique can actually be <span>improved</span><a id="id325209533" class="indexterm"></a> even further. We can add an <span>extra</span><a id="id325209542" class="indexterm"></a> texture (or use the alpha channel of the main one) to indicate the amount of extrusion. This allows for much better control over which parts are raised or lowered. The following code shows you how it is possible to achieve such an effect (the main difference from what we've done before is in bold):</p><pre class="programlisting">Shader "CookbookShaders/Chapter06/Normal Extrusion Map" 
{
  Properties
  {
    _MainTex("Texture", 2D) = "white" {}
    _ExtrusionTex("Extrusion map", 2D) = "white" {}
  _ Amount("Extrusion Amount", Range(-0.0001, 0.0001)) = 0
  }
  SubShader
  {
    Tags{ "RenderType" = "Opaque" }

    CGPROGRAM
    #pragma surface surf Standard vertex:vert
    struct Input 
    {
      float2 uv_MainTex;
    };

    float _Amount;

<span class="strong"><strong>sampler2D _ExtrusionTex;</strong></span>
<span class="strong"><strong>    void vert(inout appdata_full v) </strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      float4 tex = tex2Dlod (_ExtrusionTex, float4(v.texcoord.xy,0,0));</strong></span>
<span class="strong"><strong>      float extrusion = tex.r * 2 - 1;</strong></span>
<span class="strong"><strong>      v.vertex.xyz += v.normal * _Amount * extrusion;</strong></span>
<span class="strong"><strong>    }
</strong></span>
    sampler2D _MainTex;
    void surf(Input IN, inout SurfaceOutputStandard o) 
    {
      float4 tex = tex2D(_ExtrusionTex, IN.uv_MainTex);
      float extrusion = abs(tex.r * 2 - 1);

      o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;
      o.Albedo = lerp(o.Albedo.rgb, float3(0, 0,0), extrusion * _Amount   
                      / 0.0001 * 1.1);
    }
  ENDCG
  }

  Fallback "Diffuse"
}</pre><p>The red channel of <code class="literal">_ExtrusionTex</code> is used as a multiplying coefficient for normal extrusion. A value of <code class="literal">0.5</code> leaves the model unaffected; darker or lighter shades are used to extrude vertices inward or outward, respectively. You should note that in order to sample a <span>texture</span><a id="id325453547" class="indexterm"></a> within a vertex modifier, <code class="literal">tex2Dlod</code> should be <span>used</span><a id="id325453559" class="indexterm"></a> instead of <code class="literal">tex2D</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p>In shaders, color channels go from zero to one, although sometimes you need to represent negative values as well (such as inward extrusion). When this is the case, treat <code class="literal">0.5</code> as zero; consider having smaller values as negative and higher values as positive. This is exactly what happens with normals, which are usually encoded in RGB textures. The <code class="literal">UnpackNormal()</code> function is used to map a value in the range (0,1) on the range (-1,+1). Mathematically speaking, this is equivalent to <code class="literal">tex.r * 2 -1</code>.</p></div><p>Extrusion maps are perfect for zombifying characters by shrinking the skin to highlight the shape of the bones underneath. The following screenshot shows you how a healthy soldier can be transformed into a corpse using just a shader and extrusion map. Compared to the previous example, you may notice how the clothing is unaffected. The shader used in the following <span>screenshot</span> also darkens the extruded regions to give an even more emaciated look to the soldier:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/60a8b708-e7bd-4ab0-a6fe-d4162b4f8cb6.png" /></div></div></div></div>