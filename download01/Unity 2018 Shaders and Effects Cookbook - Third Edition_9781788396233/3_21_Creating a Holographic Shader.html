<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec28"></a>Creating a Holographic Shader</h2></div></div><hr /></div><p>More and more space-themed <span>games</span><a id="id325209443" class="indexterm"></a> are being released every year. An important part of a good sci-fi game is the way futuristic technology is presented and integrated into gameplay. There's nothing that screams futuristic more than holograms. Despite being present in many flavors, holograms are often represented as semi-transparent, thin projections of an object. This recipe shows you how to create a shader that simulates such effects. Take this as a starting point: you can add noise, animated scan lines, and vibrations to create a truly outstanding holographic effect. The following screenshot shows an example of a Holographic effect:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/32de58a0-827d-413a-9af1-0c46a377ff66.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec55"></a>Getting ready</h3></div></div></div><p>Create a shader called <code class="literal">Holographic</code>. Attach it to a material (<code class="literal">HolographicMat</code>) and assign it to a 3D model in your scene:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/eddf19d3-8b2f-406c-a8a5-60f9ccede187.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec56"></a>How to do it...</h3></div></div></div><p>The following changes will change our <span>existing</span><a id="id325209490" class="indexterm"></a> shader into a holographic one:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Remove the following properties as they will not be used:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">_Glossiness</code></li><li style="list-style-type: disc"><code class="literal">_Metallic</code></li></ul></div></li><li>Add the following property to the shader:</li></ol></div><pre class="programlisting">_DotProduct("Rim effect", Range(-1,1)) = 0.25 </pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Add its respective variable to the <code class="literal">CGPROGRAM</code> section:</li></ol></div><pre class="programlisting">float _DotProduct; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>As this material is transparent, add the following tags:</li></ol></div><pre class="programlisting">Tags 
{ 
  "Queue" = "Transparent" 
  "IgnoreProjector" = "True" 
  "RenderType" = "Transparent" 
} </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p>
According to the type of object that you will use, you might want its backside to appear. If this is the case, add <code class="literal">Cull Off</code> so that the back of the model won't be removed (<span class="emphasis"><em>culled</em></span>).</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>This shader is not trying to simulate a realistic material, so there is no need to use the PBR lighting model. <span class="strong"><strong>Lambertian reflectance</strong></span>, which is <span>very</span><a id="id325454789" class="indexterm"></a> cheap, is used instead. Additionally, we should disable any lighting with <code class="literal">nolighting</code> and signal to Cg that this is a Transparent Shader using <code class="literal">alpha:fade</code>:</li></ol></div><pre class="programlisting">#pragma surface surf Lambert alpha:fade nolighting </pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Change the <code class="literal">Input</code> structure so that Unity <span>will</span><a id="id325454843" class="indexterm"></a> fill it with the current view direction and the <span>world normal direction</span>:</li></ol></div><pre class="programlisting">struct Input 
{ 
  float2 uv_MainTex; 
  float3 worldNormal; 
  float3 viewDir; 
}; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Use the following surface function. Remember that since this shader is using Lambertian reflectance as its lighting function, the name of the <code class="literal">SurfaceOutput</code> structure should be changed accordingly to <code class="literal">SurfaceOutput</code> instead of <code class="literal">SurfaceOutputStandard</code>:</li></ol></div><pre class="programlisting">void surf(Input IN, inout SurfaceOutput o) 
{ 
  float4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color; 
  o.Albedo = c.rgb; 
 
  float border = 1 - (abs(dot(IN.viewDir, 
     IN.worldNormal))); 
  float alpha = (border * (1 - _DotProduct) + _DotProduct); 
  o.Alpha = c.a * alpha; 
} </pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Save your script and dive into Unity. From there, change the <strong class="userinput"><code>Color</code></strong> property in the <strong class="userinput"><code>HolographicMat</code></strong> and see your hologram come to life:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/0653702c-8751-4c8d-8e29-a6d4be58f2b8.png" /></div><p>You can now use the <strong class="userinput"><code>Rim effect</code></strong> slider to <span>choose</span><a id="id325457708" class="indexterm"></a> the strength of the holographic effect.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec57"></a>How it works...</h3></div></div></div><p>As mentioned previously, this shader works by showing only the silhouette of an object. If we look at the object from another angle, its outline will change. Geometrically speaking, the edges of a model are all those triangles whose <span class="emphasis"><em>normal direction</em></span> is orthogonal (90 degrees) to the current <span class="emphasis"><em>view direction</em></span>. The <code class="literal">Input</code> structure declares these parameters, <code class="literal">worldNormal</code> and <code class="literal">viewDir</code>, respectively.</p><p>The problem of understanding when two vectors are orthogonal can be solved using <code class="literal">_DotProduct</code>. This is an operator that takes two vectors and returns zero if they are orthogonal. We use <code class="literal">_DotProduct</code> to determine how close to zero the <code class="literal">_DotProduct</code> has to be for the triangle to fade completely.</p><p>The second aspect that is used in this shader is the gentle fading between the edge of the model (fully visible) and the angle determined by <code class="literal">_DotProduct</code> (invisible). This linear interpolation is effected as follows:</p><pre class="programlisting">float alpha = (border * (1 - _DotProduct) + _DotProduct); </pre><p>Finally, the original <code class="literal">alpha</code> from the texture is multiplied with the newly calculated coefficient to achieve the final look.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec58"></a>There's more...</h3></div></div></div><p>This technique is very simple and relatively inexpensive, and yet it can be used for a large variety of effects, such as the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The slightly colored atmosphere of a planet in sci-fi games</li><li style="list-style-type: disc">The edge of an object that has been selected or is currently under the mouse</li><li style="list-style-type: disc">A ghost or specter</li><li style="list-style-type: disc">Smoke coming out of an engine</li><li style="list-style-type: disc">The shockwave of an explosion</li><li style="list-style-type: disc">The bubble shield of a spaceship under attack</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec59"></a>See also</h3></div></div></div><p>The <code class="literal">_DotProduct</code> plays an important role in the <span>way</span><a id="id325463171" class="indexterm"></a> reflections are calculated. <a class="link" href="#" linkend="ch04"><span>Chapter 4</span></a>, <span class="emphasis"><em>Understanding Lighting Models</em></span>, will explain in detail how it works and why it is widely used in so many shaders.</p></div></div>