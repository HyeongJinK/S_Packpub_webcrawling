<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec56"></a>Modifying our shaders for mobile</h2></div></div><hr /></div><p>Now that we have seen quite a broad set of <span>techniques</span><a id="id325209386" class="indexterm"></a> for making <span>really</span><a id="id325453866" class="indexterm"></a> optimized shaders, let's take a look at writing a nice, high-quality shader targeted for a mobile device. It is actually quite easy to make a few adjustments to the shaders we have written so that they run faster on a mobile device. This includes elements such as using the <code class="literal">approxview</code> or <code class="literal">halfasview Lighting</code> function variables. We can also reduce the amount of textures we need and even apply better compression for the textures we are using. By the end of this recipe, we will have a nicely optimized normal-mapped, Specular Shader for use in our mobile games.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec141"></a>Getting ready</h3></div></div></div><p>Before we begin, let's get a fresh new scene and fill it with some objects to apply our <code class="literal">MobileShader</code>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new scene and fill it with a default sphere and single directional light.</li><li>Create a new material (<code class="literal">MobileMat</code>) and shader (<code class="literal">MobileShader</code>), and assign the shader to the material.</li><li>Finally, assign the material to our sphere object in our scene.</li></ol></div><p>When completed, you should have a scene similar to the one in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/d296e3d6-f7cf-4c2e-bd2b-83e45723532e.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec142"></a>How to do it...</h3></div></div></div><p>For this recipe, we will write a mobile-friendly shader from scratch and discuss the elements that make it more mobile friendly:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Let's first populate our <code class="literal">Properties</code> block with the textures required. In this case, we are going to use a single <code class="literal">_Diffuse</code> texture with the gloss map in its alpha channel, <code class="literal">Normal map</code>, and a slider for specular intensity:</li></ol></div><pre class="programlisting">Properties 
{
  _Diffuse ("Base (RGB) Specular Amount (A)", 2D) = "white" {}
  _SpecIntensity ("Specular Width", Range(0.01, 1)) = 0.5
  _NormalMap ("Normal Map", 2D) = "bump"{}
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Our next task is to set up our <code class="literal">#pragma</code> declarations. This will simply turn certain features of the Surface Shader on and off, ultimately making the shader cheaper or more expensive:</li></ol></div><pre class="programlisting">CGPROGRAM
<span class="strong"><strong>#pragma surface surf MobileBlinnPhong exclude_path:prepass nolightmap noforwardadd halfasview</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip71"></a>Note</h3><p>The highlighted line should be on one line.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Next, remove the <code class="literal">#pragma target 3.0</code> line, as we are not using any of the features of it.</li><li>We then need to make the connection between our <code class="literal">Properties</code> block and <code class="literal">CGPROGRAM</code>. This time, we are going to use the fixed variable type for our specular intensity slider in order to reduce its memory usage:</li></ol></div><pre class="programlisting">sampler2D _Diffuse;
sampler2D _NormalMap;
fixed _SpecIntensity;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>In order for us to map our textures to the surface of our object, we need to get some UVs. In this case, we are going to get only one set of UVs to keep the <span>amount</span><a id="id325457682" class="indexterm"></a> of data in our <span>shader</span><a id="id325457690" class="indexterm"></a> down to a minimum:</li></ol></div><pre class="programlisting">struct Input 
{
  half2 uv_Diffuse;
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>The next step is to fill in our <code class="literal">Lighting</code> function using a few of the new input variables that are available to us when using the new <code class="literal">#pragma</code> declarations:</li></ol></div><pre class="programlisting">inline fixed4 LightingMobileBlinnPhong (SurfaceOutput s, fixed3 lightDir, fixed3 halfDir, fixed atten)
    {
      fixed diff = max (0, dot (s.Normal, lightDir));
      fixed nh = max (0, dot (s.Normal, halfDir));
      fixed spec = pow (nh, s.Specular*128) * s.Gloss;

      fixed4 c;
      c.rgb = (s.Albedo * _LightColor0.rgb * diff + _LightColor0.rgb * spec) * (atten*2);
      c.a = 0.0;
      return c;
    }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Finally, we complete the shader by creating the <code class="literal">surf()</code> function and processing the final color of our surface:</li></ol></div><pre class="programlisting">void surf (Input IN, inout SurfaceOutput o) 
{
  fixed4 diffuseTex = tex2D (_Diffuse, IN.uv_Diffuse);
  o.Albedo = diffuseTex.rgb;
  o.Gloss = diffuseTex.a;
  o.Alpha = 0.0;
  o.Specular = _SpecIntensity;
  o.Normal = UnpackNormal(tex2D(_NormalMap, IN.uv_Diffuse));
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>When finished with the code portion of this recipe, save your shader and return to the Unity editor to let the shader compile. If no errors occurred, assign some properties for the <strong class="userinput"><code>Base</code></strong> and <strong class="userinput"><code>Normal Map</code></strong> properties:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/27a88787-63f3-451c-8f21-aa4e160e9b14.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Add a few point lights and some copies of the new object and you should see a result similar to the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/8eee4787-8bf9-4161-a37b-d9adf8118b6e.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec143"></a>How it works...</h3></div></div></div><p>So, let's begin the description of this <span>shader</span><a id="id325463158" class="indexterm"></a> by explaining what it does and doesn't do. First, it excludes the deferred lighting pass. This means that if you created a <code class="literal">Lighting</code> function that was connected to the deferred renderer's <code class="literal">prepass</code>, it wouldn't use that particular <code class="literal">Lighting</code> function and would look for the default <code class="literal">Lighting</code> function like the ones that we have been creating thus far in this book.</p><p>This particular <span>shader</span><a id="id325464994" class="indexterm"></a> does not support <span class="emphasis"><em>lightmapping</em></span> by Unity's internal light-mapping system. This just keeps the shader from trying to find light maps for the object that the shader is attached to, making the shader more performance-friendly because it is not having to perform the lightmapping check.</p><p>We included the <code class="literal">noforwardadd</code> declaration so that we process only per-pixel textures with a single directional light. All other lights are forced to become per-vertex lights and will not be included in any per-pixel operations you might do in the <code class="literal">surf()</code> function.</p><p>Finally, we are using the <code class="literal">halfasview</code> declaration to tell Unity that we aren't going to use the main <code class="literal">viewDir</code> parameter found in a normal <code class="literal">Lighting</code> function. Instead, we are going to use the half vector as the view direction and process our specular with this. This becomes much faster for the shader to process as it will be done on a per-vertex basis. It isn't completely accurate when it comes to simulating specular in the real world, but visually, on a mobile device, it looks just fine and the shader is more optimized.</p><p>It's techniques like these that make a shader more efficient and cleaner, codewise. Always make sure that you are using only the data you need while weighing this against your target hardware and the visual quality that the game requires. In the end, a cocktail of these techniques is what ultimately makes up your shaders for your games.</p></div></div>