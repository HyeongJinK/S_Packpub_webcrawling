<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec43"></a>Accessing a vertex color in a Surface Shader</h2></div></div><hr /></div><p>Let's begin this chapter by <span>taking</span><a id="id325209371" class="indexterm"></a> a look at how we can access the information of a model's vertex using the vertex function in a Surface Shader. This will arm us with the <span>knowledge</span><a id="id325460914" class="indexterm"></a> to start utilizing the elements contained within a model's vertex in order to create really useful and visually appealing effects.</p><p>A vertex in a vertex function can return information about itself that we need to be aware of. You can actually retrieve the vertices' normal directions as a float3 value and the position of the vertex as float3, and you can even store color values in each vertex and return that color as float4. This is what we will take a look at in this recipe. We need to see how to store color information and retrieve this stored color information inside each vertex of a Surface Shader.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec98"></a>Getting ready</h3></div></div></div><p>In order to write this shader, we need to prepare a few assets. </p><p>In order to view the colors of a vertex, we need to have a model that has had color applied to its vertices. While you could use Unity to apply colors, you would have to write a tool to allow an individual to apply the colors or write some scripts to achieve the color application.</p><p>In the case of this recipe, you can use a 3D modeling tool such as Maya or Blender to apply the colors to our model. There is a model available in the example code provided with the book in the <code class="literal">Chapter 06 </code>| <code class="literal">Models</code> folder (<code class="literal">VertexColorObject.fbx</code>) that you can obtain at the book's <span class="emphasis"><em>Support</em></span> page at <a class="ulink" href="https://www.packtpub.com/books/content/support" target="_blank">https://www.packtpub.com/books/content/support</a>.</p><p>The following steps will set us up to create this Vertex Shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new scene and place the imported model (<code class="literal">VertexColorObject</code>) in the scene.</li><li>Create a new <strong class="userinput"><code>Shader</code></strong> (<code class="literal">SimpleVertexColor</code>) and <strong class="userinput"><code>Material</code></strong> (<code class="literal">SimpleVertexColorMat</code>).</li><li>When completed, assign the shader to the material and then the material to the imported model.</li></ol></div><p>Your scene <span>should</span><a id="id325464998" class="indexterm"></a> now look <span>similar</span><a id="id325465006" class="indexterm"></a> to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/0372a966-a099-46f3-a3ac-05169a0ab8d6.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec99"></a>How to do it…</h3></div></div></div><p>With our scene, shader, and material created and ready to go, we can begin to write the code for our shader. Launch the shader by double-clicking on it in the <strong class="userinput"><code>Project</code></strong> tab in the Unity editor. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>As we are creating a very simple shader, we will not need to include any properties in our <code class="literal">Properties</code>block. We will still include a <code class="literal">Global Color Tint</code>, just to stay consistent with the other shaders in this book. Enter the following code in the<code class="literal">Properties</code> block of your shader:</li></ol></div><pre class="programlisting"><span class="strong"><strong>Properties</strong></span>
{
  _MainTint("Global Color Tint", Color) = (1,1,1,1)
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>This next <span>step</span><a id="id325209484" class="indexterm"></a> tells Unity <span>that</span><a id="id325209493" class="indexterm"></a> we will be including a vertex function in our shader:</li></ol></div><pre class="programlisting">CGPROGRAM
#pragma surface surf Lambert vertex:vert</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>As usual, if we have included properties in our <code class="literal">Properties</code> block, we must make sure to create a corresponding variable in our <code class="literal">CGPROGRAM</code> statement. Enter the following code just below the <code class="literal">#pragma</code> statement:</li></ol></div><pre class="programlisting">float4 _MainTint;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>We now turn our attention to the <code class="literal">Input struct</code>. We need to add a new variable in order for our <code class="literal">surf()</code> function to access the data given to us by our <code class="literal">vert()</code> function:</li></ol></div><pre class="programlisting">struct Input 
{
float2 uv_MainTex;
float4 vertColor;
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Now we can write our simple <code class="literal">vert()</code> function to gain access to the colors stored in each vertex of our mesh:</li></ol></div><pre class="programlisting">void vert(inout appdata_full v, out Input o)
{
  UNITY_INITIALIZE_OUTPUT(Input,o);
  o.vertColor = v.color;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Finally, we can use the vertex color data from our <code class="literal">Input struct</code> to be assigned to the <code class="literal">o.Albedo</code> parameters in the built-in <code class="literal">SurfaceOutput</code> struct:</li></ol></div><pre class="programlisting">void surf (Input IN, inout SurfaceOutput o) 
{
o.Albedo = IN.vertColor.rgb * _MainTint.rgb;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>With our code completed, we can now re-enter the Unity editor and let the shader compile. If all goes well, you should see something similar to the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/500eb5ff-3b61-4dab-b5f1-56966c7e4ecf.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec100"></a>How it works…</h3></div></div></div><p>Unity provides us <span>with</span><a id="id325209693" class="indexterm"></a> a way to <span>access</span><a id="id325453517" class="indexterm"></a> the vertex information of the model to which a shader is attached. This gives us the power to modify things such as the vertices' position and color. With this recipe, we have imported a mesh from Maya (though just about any 3D software application can be used), where vertex colors were added to <code class="literal">Verts</code>. You'll notice that by importing the model, the default material will not display the vertex colors. We actually have to write a shader to extract the vertex color and display it on the surface of the model. Unity provides us with a lot of built-in functionality when using Surface Shaders, which makes the process of extracting this vertex information quick and efficient.</p><p>Our first task is to tell Unity that we will be using a vertex function when creating our shader. We do this by adding the <code class="literal">vertex:vert</code> parameter to the <code class="literal">#pragma</code> statement of <code class="literal">CGPROGRAM</code>. This automatically makes Unity look for a vertex function named <code class="literal">vert()</code> when it goes to compile the shader. If it doesn't find one, Unity will throw a compiling error and ask you to add a <code class="literal">vert()</code> function to your shader.</p><p>This brings us to our next step. We have to actually code the <code class="literal">vert()</code> function, as seen in <span class="emphasis"><em>step 5</em></span>. We first use a built-in macro to make sure that the <code class="literal">0</code> variable is <span>initialized</span><a id="id325453563" class="indexterm"></a> to 0 <span>if it doesn't have anything that is a requirement if you are targeting</span> DirectX <span>11 or above.</span> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note56"></a>Note</h3><p>For more information on the macro, as well as all of the other macros that ShaderLab has to offer, check out: <a class="ulink" href="https://docs.unity3d.com/Manual/SL-BuiltinMacros.html" target="_blank">https://docs.unity3d.com/Manual/SL-BuiltinMacros.html</a>.</p></div><p>By having this function, we can access the built-in data struct called <code class="literal">appdata_full</code>. This built-in struct is where the vertex information is stored. So, we then extract the vertex color information by passing it to our <code class="literal">Input struct</code> by adding the code, <code class="literal">o.vertColor = v.color</code>. </p><p>The <code class="literal">o</code>variable represents our <code class="literal">Input struct</code> and the v variable is our <code class="literal">appdata_full vertex</code> data. In this case, we are simply taking the color information from the <code class="literal">appdata_full</code> struct and putting it in our <code class="literal">Input struct</code>. Once the vertex color is in our Input struct, we can use it in our <code class="literal">surf()</code> function. In the case of this recipe, we simply apply the color to the o.Albedo parameter to the built-in <code class="literal">SurfaceOutput</code> struct.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec101"></a>There's more…</h3></div></div></div><p>You can also access the fourth component from the <code class="literal">vert</code> color data. If you notice, the <code class="literal">vertColor</code> variable we declared in the <code class="literal">Input struct</code> is of the <code class="literal">float4</code> type. This <span>means</span><a id="id325453652" class="indexterm"></a> that we are also <span>passing</span><a id="id325453661" class="indexterm"></a> the alpha value of the vertex colors. Knowing this, you can use it to your advantage for the purpose of storing a fourth vertex color to perform effects such as transparency or giving yourself one more mask to blend two textures. It's really up to you and your production to determine if you really need to use the fourth component, but it is worth mentioning here.</p></div></div>