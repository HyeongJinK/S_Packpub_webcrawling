<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec25"></a>Scrolling textures by modifying UV values</h2></div></div><hr /></div><p>One of the most common <span>texture</span><a id="id325209370" class="indexterm"></a> techniques <span>used</span><a id="id325209379" class="indexterm"></a> in today's game industry is the process of allowing you to scroll the textures over the surface of an object. This allows you to create effects such as waterfalls, rivers, and lava flows. It's also a technique that is the basis of creating animated sprite effects, but we will cover this in a subsequent recipe of this chapter. First, let's see how we will create a simple scrolling effect in a Surface Shader.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec45"></a>Getting ready</h3></div></div></div><p>To begin this recipe, you will need to create a new shader file (<code class="literal">ScrollingUVs</code>) and material (<code class="literal">ScrollingUVMat</code>). This will set us up with a nice clean shader that we can use to study the scrolling effect by itself.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec46"></a>How to do it...</h3></div></div></div><p>To begin with, we will launch our new shader file that we just created and enter the code mentioned in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The shader will need two new properties that will allow us to control the speed of the texture scrolling. So, let's add a speed property for the <span class="emphasis"><em>X</em></span> direction and a speed property for the <span class="emphasis"><em>Y</em></span> direction, as shown in the following code:</li></ol></div><pre class="programlisting">Properties {
  _Color ("Color", Color) = (1,1,1,1)
  _MainTex ("Albedo (RGB)", 2D) = "white" {}
  _ScrollXSpeed ("X Scroll Speed", Range(0,10)) = 2 
  _ScrollYSpeed ("Y Scroll Speed", Range(0,10)) = 2 
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>When working in ShaderLab, <code class="literal">Properties</code> has a syntax that looks like the following:</li></ol></div><pre class="programlisting">Properties
{
    _propertyName("Name in Inspector", Type) = value
}</pre><p>Each property contained in the <code class="literal">Properties</code> block first has a name that is used in code to refer to the object, here specified as <code class="literal">_propertyName</code>. The underscore isn't required but is a common standard in place. Inside the parenthesis, you'll see two parameters. The first is a string that defines what text will be displayed in the <strong class="userinput"><code>Inspector</code></strong> for what this property is. The second parameter is the type of data we wish to store.</p><p>In our case, for the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> Scroll Speed, we are <span>creating</span><a id="id325442701" class="indexterm"></a> a number with a possible Range from 0 to 10. Lastly, we can initialize the property with a default value which is done on the end. As we've seen before, these properties will show up in the <strong class="userinput"><code>Inspector</code></strong> if you select a <span>material</span><a id="id325442713" class="indexterm"></a> that is <span>using</span><a id="id325442722" class="indexterm"></a> this shader.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note32"></a>Note</h3><p>For more information on Properties and how to create them, check out <a class="ulink" href="https://docs.unity3d.com/Manual/SL-Properties.html" target="_blank">https://docs.unity3d.com/Manual/SL-Properties.html</a>.</p></div><p>For this example, we don't need the <code class="literal">Smoothness</code> or <code class="literal">Metallic</code> properties, so we can remove them as well.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Modify the Cg properties in the <code class="literal">CGPROGRAM</code> section above the definition of <code class="literal">_MainTex</code> and create new variables so that we can access the values from our properties:</li></ol></div><pre class="programlisting">fixed _ScrollXSpeed; 
fixed _ScrollYSpeed; 
sampler2D _MainTex; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>We also need to remove the <code class="literal">_Glossiness</code> and <code class="literal">_Metallic</code> definitions as we are not using them anymore.</li><li>Modify the surface function to change the UVs given to the <code class="literal">tex2D()</code> function. Then, use the built-in <code class="literal">_Time</code> variable to animate the UVs over time when the <strong class="userinput"><code>Play</code></strong> button is pressed in the editor:</li></ol></div><pre class="programlisting">void surf (Input IN, inout SurfaceOutputStandard o) {
    // Create a separate variable to store our UVs 
    // before we pass them to the tex2D() function 
    fixed2 scrolledUV = IN.uv_MainTex; 

    // Create variables that store the individual x and y 
    // components for the UV's scaled by time 
    fixed xScrollValue = _ScrollXSpeed * _Time; 
    fixed yScrollValue = _ScrollYSpeed * _Time; 

    // Apply the final UV offset 
    scrolledUV += fixed2(xScrollValue, yScrollValue); 

    // Apply textures and tint 
    half4 c = tex2D(_MainTex, scrolledUV); 
    o.Albedo = c.rgb * _Color; 
    o.Alpha = c.a; 
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Once the script is finished, save it and then go back to the Unity editor. Go to the <code class="literal">Materials</code> folder and assign <code class="literal">ScrollingUVsMat</code> to use our <code class="literal">ScrollingUVs</code> shader. Once that is done, under the <strong class="userinput"><code>Albedo (RGB)</code></strong> property, drag and drop the water <span>texture</span><a id="id325445219" class="indexterm"></a> from the <span>example</span><a id="id325451202" class="indexterm"></a> code provided with this book to assign the property:</li></ol></div><p></p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/46c8fb68-cd8c-4253-b5f2-4b2bafaa0e6f.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>After this is created, we need to create an object that can use the shader. From a new scene, go ahead and select <strong class="userinput"><code>GameObject </code></strong>| <strong class="userinput"><code>3D Object </code></strong>| <strong class="userinput"><code>Plane</code></strong> and drag and drop the <code class="literal">ScrollingUVMat</code> material onto it.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Once applied, go ahead and play the game to see the shader in action:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/8aab7e69-9996-4f41-bce0-ed826997cba7.png" /></div><p>While it's not visible in this <span>still image</span>, you will notice that in the Unity editor, the object will now move in both the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> axes! Feel free to drag the <strong class="userinput"><code>X Scroll Speed</code></strong> and <strong class="userinput"><code>Y Scroll Speed</code></strong> properties in the <strong class="userinput"><code>Inspector</code></strong> tab to see how the changes affect how the object moves. Also, feel free to <span>move</span><a id="id325453413" class="indexterm"></a> the <span>camera</span><a id="id325453553" class="indexterm"></a> to make it easier to see if you would like.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip33"></a>Note</h3><p>If you modify a variable on a <strong class="userinput"><code>Material</code></strong> during gameplay, the value will stay changed, unlike how Unity typically works.</p></div><p>Pretty cool! With this knowledge, we can take this concept much further to create interesting visual effects. The following screenshot demonstrates the result of utilizing the scrolling UV system with multiple materials in order to create a simple river motion for your environments:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/0abf92a6-ec8d-4684-b839-ff37e35d77ee.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec47"></a>How it works...</h3></div></div></div><p>The scrolling system starts with the declaration of a couple of properties, which will allow the user of this shader to increase or decrease the speed of the scrolling effect itself. At their core, they are float values being passed from the material's <strong class="userinput"><code>Inspector</code></strong> tab to the surface function of the shader. For more information on shader properties, see <a class="link" href="#" linkend="ch02"><span>Chapter 2</span></a>, <span class="emphasis"><em>Creating Your First Shader</em></span>.</p><p>Once we have these float values from the material's <strong class="userinput"><code>Inspector</code></strong> tab, we can use them to offset our UV values in the shader.</p><p>To begin this process, we first store the UVs in a separate variable called <code class="literal">scrolledUV</code>. This variable has to be <code class="literal">float2</code>/<code class="literal">fixed2</code> because the UV values are being passed to us from the <code class="literal">Input</code> structure:</p><pre class="programlisting">struct Input 
{ 
  float2 uv_MainTex; 
} </pre><p>Once we have access to the mesh's UVs, we can offset them using our scroll speed variables and built-in <code class="literal">_Time</code> variable. This built-in variable returns a <span>variable</span><a id="id325453817" class="indexterm"></a> of the <code class="literal">float4</code> type, meaning <span>that</span><a id="id325454752" class="indexterm"></a> each component of this variable contains different values of time as it pertains to game time.</p><p>A complete description of these individual time values is <span>described</span><a id="id325454762" class="indexterm"></a> at the following link: <span><a class="ulink" href="http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html" target="_blank">http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a></span></p><p>This <code class="literal">_Time</code> variable will give us an incremented float value based on Unity's game time clock. So, we can use this value to move our UVs in a UV direction and scale that time with our scroll speed variables:</p><pre class="programlisting">// Create variables that store the individual x and y  
// components for the uv's scaled by time 
fixed xScrollValue = _ScrollXSpeed * _Time; 
fixed yScrollValue = _ScrollYSpeed * _Time; </pre><p>With the correct offset being calculated by time, we can add the new offset value back to the original UV position. This is why we are using the <code class="literal">+=</code> operator in the next line. We want to take the original UV position, add the new offset value, and then pass this to the <code class="literal">tex2D()</code> function as the texture's new UVs. This creates the effect of the texture moving on the surface. What we are really doing is manipulating the UVs, so we are faking the effect of the texture moving:</p><pre class="programlisting">scrolledUV += fixed2(xScrollValue, yScrollValue); 
half4 c = tex2D (_MainTex, scrolledUV); </pre></div></div>