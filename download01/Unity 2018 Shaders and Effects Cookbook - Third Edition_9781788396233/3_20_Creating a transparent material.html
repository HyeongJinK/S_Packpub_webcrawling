<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec27"></a>Creating a transparent material</h2></div></div><hr /></div><p>All the shaders we have seen so far have <span>something</span><a id="id325209370" class="indexterm"></a> in common; they are used for solid materials. If you want to improve the look of your game, transparent materials are often a good way to start. They can be used for anything from a fire effect to a glass window. Working with them, unfortunately, is slightly more complicated. Before rendering solid models, Unity orders them according to the distance from the camera (<span class="emphasis"><em>Z ordering</em></span>) and skips all the triangles that are facing away <span>from</span><a id="id325209382" class="indexterm"></a> the camera (<span class="strong"><strong>culling</strong></span>). When rendering transparent geometries, there are instances in which these two aspects can cause problems. This recipe will show you how to solve some of these issues when it comes to creating a transparent Surface Shader. This topic will be heavily revisited in <a class="link" href="#" linkend="ch07"><span>Chapter 7</span></a>, <span class="emphasis"><em>Fragment Shaders and Grab Passes</em></span>, where realistic glass and water shaders will be provided.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec52"></a>Getting ready</h3></div></div></div><p>This recipe requires a new shader, which we'll be calling <code class="literal">Transparent</code>, and a new material (<code class="literal">TransparentMat</code>) so that it can be attached to an object. As this is going to be a transparent glass window, a quad or plane is perfect (<strong class="userinput"><code>GameObject | 3D Objects </code></strong>| <strong class="userinput"><code>Quad</code></strong>). We will also need several other non-transparent objects to test the effect:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/d2506bfc-f348-4911-b123-084fa35baebc.png" /></div><p>In this example, we will use a PNG image file for the glass texture since it has support for an alpha channel that will be used to determine the transparency of the glass. The process of <span>creating</span><a id="id325209438" class="indexterm"></a> such an image depends on the software that you are using. However, these are the main steps that you will need to follow:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Find the image of the glass you want for your windows.</li><li>Open it with a photo editing software, such as <span class="emphasis"><em>GIMP</em></span> or <span class="emphasis"><em>Photoshop</em></span>.</li><li>Select the parts of the image that you want to be semi-transparent.</li><li>Create a white (full opacity) layer mask on your image.</li><li>Use the selection previously made to fill the layer mask with a darker color. White is treated as fully visible, black will be treated as invisible, and grey will be somewhere in the middle.</li><li>Save the image and import it into Unity.</li></ol></div><p>The toy image used in this recipe is a picture of stained glass from the <span class="emphasis"><em>Meaux Cathedral </em></span>in <span class="emphasis"><em>France</em></span> (<span><a class="ulink" href="https://en.wikipedia.org/wiki/Stained_glass" target="_blank">https://en.wikipedia.org/wiki/Stained_glass</a></span>). If you have followed all of these steps, your image should <span>look</span><a id="id325442717" class="indexterm"></a> like this (<span class="strong"><strong>RGB</strong></span> channels on the left, and <span class="strong"><strong>A</strong></span> channel on the right):</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/d30c8e69-b66c-4feb-80bc-6ce52579a02f.png" /></div><p>You can also make use of the image file in provided the example code for this book in <code class="literal">Chapter 3 </code>| <code class="literal">Textures</code> folder (<code class="literal">Meaux_Vitrail.psd</code>).</p><p>Attaching this image to the material will <span>cause</span><a id="id325445078" class="indexterm"></a> the image to show up, but we cannot see it behind the glass:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/2bc72cc2-76a8-4d3d-bbc9-087f7e2fe6dc.png" /></div><p>As we would like to see behind this, we can make adjustments to the shader to do exactly that.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec53"></a>How to do it...</h3></div></div></div><p>As mentioned previously, there are a few aspects that we need to take care of while using a Transparent Shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Remove the <code class="literal">_Glossiness</code> and <code class="literal">_Metallic</code> variables from the <code class="literal">Properties</code> and <code class="literal">SubShader</code> sections of the code as they aren't needed for this example.</li><li>In the <code class="literal">SubShader{}</code> section of <span>the</span><a id="id325445206" class="indexterm"></a> shader, modify the <code class="literal">Tags</code> section to the following so that we can signal that the shader is transparent:</li></ol></div><pre class="programlisting">Tags 
{ 
  "Queue" = "Transparent" 
  "IgnoreProjector" = "True" 
  "RenderType" = "Transparent" 
} </pre><p>Tags are used by the <code class="literal">SubShader</code> to know how and when items should be rendered. Similar to the dictionary type, tags are key-value pairs where the left-hand side is the tag <span>name</span><a id="id325451203" class="indexterm"></a> and the right-hand side is the value you wish for it to be set to.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note37"></a>Note</h3><p>For more information on tags in ShaderLab, check out: <a class="ulink" href="https://docs.unity3d.com/Manual/SL-SubShaderTags.html" target="_blank">https://docs.unity3d.com/Manual/SL-SubShaderTags.html</a></p></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>As this shader is designed for 2D materials, make sure that the back geometry of your model is not drawn by adding the following below the <code class="literal">LOD 200</code> line:</li></ol></div><pre class="programlisting">    LOD 200

    // Do not show back
    Cull Back

    CGPROGRAM
    // Physically based Standard lighting model, and enable shadows on all light types
    #pragma surface surf Standard alpha:fade </pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Tell the shader that this material is transparent and needs to be blended with what was drawn on the screen before:</li></ol></div><pre class="programlisting">#pragma surface surf Standard alpha:fade </pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Use this Surface Shader to determine <span>the</span><a id="id325453389" class="indexterm"></a> final color and transparency of the glass:</li></ol></div><pre class="programlisting">void surf(Input IN, inout SurfaceOutputStandard o) 
{ 
  float4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color; 
  o.Albedo = c.rgb; 
  o.Alpha = c.a; 
} </pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Afterward, save your script and dive back to the Unity editor:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/8e2c920e-5e58-45cf-bb22-1050df8cc6e7.png" /></div><p>Notice that you can now see the cube behind the glass. Perfect!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec54"></a>How it works...</h3></div></div></div><p>This shader introduces several new concepts. First of all, <code class="literal">Tags</code> are used to add information about how the object is going to be rendered. The really interesting one here is <code class="literal">Queue</code>. Unity, by default, will sort your objects for you based on the distance from the camera. So, as an object gets nearer to <span>the</span><a id="id325453565" class="indexterm"></a> camera, it is going to be drawn over all the objects that are further away from the camera. For most cases, this works out just fine for games, but you will find yourself in certain situations where you will want to have more control over the sorting of your objects in your scene. Unity has provided us with some default render queues, each with a unique value that directs Unity when to draw the object to the screen. These built-in render queues are called <code class="literal">Background</code>, <code class="literal">Geometry</code>, <code class="literal">AlphaTest</code>, <code class="literal">Transparent</code>, and <code class="literal">Overlay</code>. These queues weren't just created arbitrarily; they actually serve a purpose to make our lives easier when writing shaders and interacting with the real-time renderer.</p><p>Refer to the following table for descriptions on the usage of each of these individual render queues:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Render queue</strong></span></p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Render queue description</strong></span></p></th><th style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Render queue value</strong></span></p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Background</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>This render queue is rendered first. It is used for skyboxes and so on.</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">1000</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Geometry</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>This is the default render queue. This is used for most objects. Opaque geometry uses this queue.</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">2000</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">AlphaTest</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Alpha-tested geometry uses this queue. It's different from the <code class="literal">Geometry</code> queue as it's more efficient to render alpha-tested objects after all the solid objects are drawn.</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">2450</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Transparent</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>This render queue is rendered after <code class="literal">Geometry</code> and <code class="literal">AlphaTest</code> queues in back-to-front order. Anything alpha-blended (that is, shaders that don't write to the depth buffer) should go here, for example, glass and particle effects.</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">3000</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">Overlay</code></p></td><td style="border-right: 0.5pt solid ; "><p>This render queue is meant for overlay effects. Anything rendered last should go here, for example, lens flares.</p></td><td style=""><p><code class="literal">4000</code></p></td></tr></tbody></table></div><p> </p><p>So, once you know which render queue your object belongs to, you can <span>assign</span><a id="id325454776" class="indexterm"></a> its built-in render queue tag. Our shader used the <code class="literal">Transparent</code> queue, so we wrote <code class="literal">Tags{"Queue"="Transparent"}</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p>The fact that the <code class="literal">Transparent</code> queue is rendered after <code class="literal">Geometry</code> does <span class="emphasis"><em>not</em></span> mean that our glass will appear on top of all the other solid objects. Unity will draw the glass last, but it will not render pixels that belong to pieces of geometry hidden behind something else. This control is done using a technique called <span class="strong"><strong>ZBuffering</strong></span>. More information on how models are rendered can be found at the following link: <span><a class="ulink" href="http://docs.unity3d.com/Manual/SL-CullAndDepth.html" target="_blank">http://docs.unity3d.com/Manual/SL-CullAndDepth.html</a></span>.</p></div><p>The <code class="literal">IgnoreProjector</code> tag makes this object unaffected by Unity's projectors. Lastly, <code class="literal">RenderType</code> plays a <span>role</span><a id="id325454848" class="indexterm"></a> in <span class="strong"><strong>shader replacement</strong></span>, a topic that will be covered briefly in <a class="link" href="#" linkend="ch10"><span>Chapter 10</span></a>, <span class="emphasis"><em>Gameplay and Screen Effects</em></span>.</p><p>The last concept introduced is <code class="literal">alpha:fade</code>. This <span>indicates</span><a id="id325454872" class="indexterm"></a> that all the pixels from this material have to be blended with what was on the screen before according to their alpha values. Without this directive, the pixels will be drawn in the correct order, but they won't have any transparency.</p></div></div>