<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec49"></a>Understanding Vertex and Fragment Shaders</h2></div></div><hr /></div><p>The best way to <span>understand</span><a id="id325209370" class="indexterm"></a> how Vertex and Fragment Shaders work is by creating one yourself. This recipe will show you how to write one of these shaders, which will simply apply a texture to a model and multiply it by a given color, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/4a2fc152-e31e-4203-bbd9-a2589c000327.png" /></div><p>Notice how it works similarly to how the <span>Multiply</span> filter in Photoshop works. That's because we will be doing the same calculation done there!</p><p>The shader presented here is very simple, and it will be <span>used</span><a id="id325209510" class="indexterm"></a> as a starting base for all the other Vertex and Fragment Shaders.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec118"></a>Getting ready</h3></div></div></div><p>For this recipe, we will need a new shader. Follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new shader (<code class="literal">Multiply</code>).</li><li>Create a new material (<code class="literal">MultiplyMat</code>) and assign the shader to it.</li><li>Bring the soldier prefab from the <code class="literal">Chapter 06 </code>| <code class="literal">Prefabs</code> folder into the scene, and attach the new material to the prefab's head. The head can be found in the <code class="literal">Soldier</code> child of the <code class="literal">Soldier</code> object.</li><li>From there, in the <strong class="userinput"><code>Inspector</code></strong> tab, scroll down to the <strong class="userinput"><code>Skinned Mesh Renderer</code></strong> component and, under <strong class="userinput"><code>Materials</code></strong>, set <strong class="userinput"><code>Element 0</code></strong> to the new materials. Lastly, in the <code class="literal">Albedo (RGB)</code> property, drag and drop the <code class="literal">Unity_soldier_Head_DIF_01</code> texture. The following screenshot should help demonstrate what we are looking for:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/77a01ea7-d808-4dbd-9b3f-bfe8a061d7a8.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec119"></a>How to do it…</h3></div></div></div><p>In all the previous chapters, we have always been able to refit Surface Shaders. This is not the case any more, as Surface and Fragment Shaders are structurally different. We will <span>need</span><a id="id325209592" class="indexterm"></a> to implement the following changes:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Delete all the properties of the shader, replacing them with the following:</li></ol></div><pre class="programlisting">Properties 
{
 _Color ("Color", Color) = (1,0,0,1)
 _MainTex ("Albedo (RGB)", 2D) = "white" {}
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Delete all the code in the <code class="literal">SubShader</code> block and replace it with this:</li></ol></div><pre class="programlisting">SubShader 
{
 Pass 
 {
 CGPROGRAM

 #pragma vertex vert
 #pragma fragment frag

 half4 _Color;
 sampler2D _MainTex;

 struct vertInput 
 {
 float4 pos : POSITION;
 float2 texcoord : TEXCOORD0;
 };

 struct vertOutput 
 {
 float4 pos : SV_POSITION;
 float2 texcoord : TEXCOORD0;
 };

 vertOutput vert(vertInput input) 
 {
 vertOutput o;
 o.pos = mul(UNITY_MATRIX_MVP, input.pos);
 o.texcoord = input.texcoord;
 return o;
 }

 half4 frag(vertOutput output) : COLOR
 {
 half4 mainColour = tex2D(_MainTex, output.texcoord);
 return mainColour * _Color;
 }

 ENDCG
 }
}
FallBack "Diffuse"</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Save your shader script and return to the Unity editor. Once finished, modify the <strong class="userinput"><code>Color</code></strong> property of the <code class="literal">MultiplyMat</code> material and see that we get the <span>result</span><a id="id325453527" class="indexterm"></a> we are looking for:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/08fff1d9-def5-4ed3-a6b3-230920a96f7e.png" /></div><p>This will also be the base for all future Vertex and Fragment Shaders.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec120"></a>How it works…</h3></div></div></div><p>As the name suggests, Vertex and Fragment Shaders work in two steps. The model is first passed through a vertex function; the result is then inputted to a Fragment function. Both these functions are assigned using <code class="literal">#pragma</code> directives:</p><pre class="programlisting">#pragma vertex vert
#pragma fragment frag</pre><p>In this case, they are simply called <code class="literal">vert</code> and <code class="literal">frag</code>.</p><p>Conceptually speaking, fragments are closely related to pixels; the term fragment is often used to refer to the collection of data necessary to draw a pixel. This is also why Vertex and Fragment Shaders are <span>often</span><a id="id325453570" class="indexterm"></a> called <span class="strong"><strong>Pixel Shaders</strong></span>.</p><p>The vertex function takes the input data in a <span>structure</span><a id="id325453582" class="indexterm"></a> that is defined as <code class="literal">vertInput</code> in the shader:</p><pre class="programlisting">struct vertInput 
{
 float4 pos : POSITION;
 float2 texcoord : TEXCOORD0;
};</pre><p>Its name is totally arbitrary, but its content is not. Each field of the <code class="literal">struct</code> must be <span>decorated</span><a id="id325453605" class="indexterm"></a> with a <span class="strong"><strong>binding semantic</strong></span>. This is a feature of Cg that allows us to mark variables so that they will be initialized with certain data, such as normal vectors and the vertex position. The binding semantic, <code class="literal">POSITION</code>, indicates that when <code class="literal">vertInput</code> is inputted to the vertex function, <code class="literal">pos</code> will contain the position of the current vertex. This is similar to the vertex field of the <code class="literal">appdata_full</code> structure in a Surface Shader. The main difference is that <code class="literal">pos</code> is represented in model coordinates (relative to the 3D object), which we need to convert to view coordinates manually (relative to the position on the screen).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note63"></a>Note</h3><p>The vertex function in a Surface Shader is used to alter the geometry of the model only. In a Vertex and Fragment Shader, instead, the vertex function is necessary to project the coordinates of the model to the screen.</p></div><p>The mathematics behind this conversion is beyond the scope of this chapter. However, this transformation can be achieved by using the <code class="literal">UnityObjectToClipPos</code> function, which will take a point from object space to the camera's clip space in homogeneous coordinates. This is done by multiplying by the <span class="strong"><strong>model-view-projection matrix</strong></span>, and it is <span>essential</span><a id="id325453649" class="indexterm"></a> to find <span>the</span><a id="id325453690" class="indexterm"></a> position of a vertex <span>on</span> the screen:</p><pre class="programlisting">vertOutput o;
o.pos = UnityObjectToClipPos(input.pos);</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note64"></a>Note</h3><p>For more information on this and other helper <span>functions</span> that ShaderLab has built-in, check out <a class="ulink" href="https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html" target="_blank">https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html</a>.</p></div><p>The other piece of information initialized is <code class="literal">textcoord</code>, which uses the <code class="literal">TEXCOORD0</code> binding semantics to get the UV data of the first texture. No further processing is required, and this value can be passed directly to the fragment function (<code class="literal">frag</code>):</p><pre class="programlisting">o.texcoord = input.texcoord;</pre><p>While Unity will initialize <code class="literal">vertInput</code> for us, we are responsible for the initialization of <code class="literal">vertOutput</code>. Despite this, its fields still need to be decorated with binding semantics:</p><pre class="programlisting">struct vertOutput 
{
  float4 pos : SV_POSITION;
  float2 texcoord : TEXCOORD0;
};</pre><p>Once the vertex function has initialized <code class="literal">vertOutput</code>, the <span>structure</span><a id="id325453758" class="indexterm"></a> is passed to the fragment function (<code class="literal">frag</code>). This samples the main texture of the model and multiplies it by the color provided.</p><p>As you can see, the Vertex and Fragment Shader have no knowledge of the physical properties of the material. This means that the material does not have the same effect by light sources, and it does not have data regarding how light reflects to create bumped surfaces compared to a Surface Shader; it works closer to the <span>architecture</span><a id="id325453772" class="indexterm"></a> of the graphicsGPU.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec121"></a>There's more…</h3></div></div></div><p>One of the most confusing <span>aspects</span><a id="id325453785" class="indexterm"></a> of Vertex and Fragment Shaders is binding semantics. There are many others that you can use, and their meanings depend on context.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec10"></a>Input semantics</h4></div></div></div><p>The binding semantics in the <span>following</span><a id="id325453800" class="indexterm"></a> table can be used in <code class="literal">vertInput</code>, which is the structure that Unity provides to the vertex function. The fields decorated with this semantics will be initialized automatically:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Binding semantics</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">POSITION</code>, <code class="literal">SV_POSITION</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The position of a vertex in world coordinates (object space)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">NORMAL</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The normal of a vertex, relative to the world (not to the camera)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">COLOR</code>, <code class="literal">COLOR0</code>, <code class="literal">DIFFUSE</code>, <code class="literal">SV_TARGET</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The color information stored in the vertex</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">COLOR1</code>, <code class="literal">SPECULAR</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The secondary color information stored in the vertex (usually the specular)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">TEXCOORD0</code>, <code class="literal">TEXCOORD1</code>, <span>…</span>, <code class="literal">TEXCOORDi</code></p></td><td style=""><p>The i-th UV data stored in the vertex</p></td></tr></tbody></table></div><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec11"></a>Output semantics</h4></div></div></div><p>When binding, semantics are <span>used</span><a id="id325453996" class="indexterm"></a> in <code class="literal">vertOutput</code>; they do not <span>automatically</span><a id="id325454008" class="indexterm"></a> guarantee that fields will be initialized. Quite the opposite; it's our responsibility to do so. The compiler will do its best to ensure that the fields are initialized with the right data:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Binding semantics</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">POSITION</code>, <code class="literal">SV_POSITION</code>, <code class="literal">HPOS</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The position of a vertex in camera coordinates (clip space, from zero to one for each dimension)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">COLOR</code>, <code class="literal">COLOR0</code>, <code class="literal">COL0</code>, <code class="literal">COL</code>, <code class="literal">SV_TARGET</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The front primary color</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">COLOR1</code>, <code class="literal">COL1</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The front secondary color</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">TEXCOORD0</code>, <code class="literal">TEXCOORD1</code>, …, <code class="literal">TEXCOORDi</code>, <code class="literal">TEXi</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The i-th UV data stored in the vertex</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">WPOS</code></p></td><td style=""><p>The position, in pixels, in the window (origin in the lower left corner)</p></td></tr></tbody></table></div><p> </p><p>If, for any reason, you need a field that will contain a different type of data, you can decorate it with one of the many <code class="literal">TEXCOORD</code> data available. The compiler will not allow fields to be left undecorated.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec122"></a>See also</h3></div></div></div><p>You can refer to the NVIDIA Reference Manual to <span>check</span><a id="id325454141" class="indexterm"></a> the other binding semantics that are available in Cg:</p><p><a class="ulink" href="http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf" target="_blank">http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf</a></p></div></div>