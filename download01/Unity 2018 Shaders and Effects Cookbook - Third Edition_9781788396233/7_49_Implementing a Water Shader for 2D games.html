<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec52"></a>Implementing a Water Shader for 2D games</h2></div></div><hr /></div><p>The Glass Shader introduced in the <span>previous</span><a id="id325209385" class="indexterm"></a> recipe is static; its <span>distortion</span><a id="id325209394" class="indexterm"></a> never changes. It takes just a few changes to convert it to an animated material, making it perfect for 2D games that feature water. This uses a similar technique to the one shown in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span><span class="emphasis"><em>Vertex Functions</em></span></span>, <span>in the recipe entitled <span class="emphasis"><em>Animating Vertices in a Surface Shader</em></span></span>:</p><div class="mediaobject"><img src="/graphics/9781788396233/graphics/c4b8d58b-9aba-4046-a584-d9e61ba3b1c2.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec131"></a>Getting ready</h3></div></div></div><p>This recipe is based on the Vertex and Fragment Shaders described in the <span class="emphasis"><em>Using the grab pass to draw behind objects</em></span> recipe, as it will rely heavily on <code class="literal">GrabPass</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new Vertex and Fragment Shader. You can start by copying the one used in the previous recipe, <span class="emphasis"><em>Using the grab pass to draw behind objects</em></span>, as a base by selecting it and hitting <span class="emphasis"><em>Ctrl</em></span>+<span class="emphasis"><em>D</em></span> to duplicate it. Once duplicated, change its name to <code class="literal">WaterShader</code>.</li><li>Create a material that will use the shader (<code class="literal">WaterMat</code>).</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Assign the material to a flat geometry that will represent your 2D water. In order for this effect to work, you should have something <span>rendered</span><a id="id325209475" class="indexterm"></a> behind it so <span>that</span><a id="id325209483" class="indexterm"></a> you can see the water-like displacement: </li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/98e504f2-988b-4109-afda-64b2437883c6.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>This recipe requires a noise texture, which is used to get pseudo-random values. It is important that you choose a seamless noise texture, such as the ones generated by tileable 2D Perlin noise, as shown in the following screenshot. This ensures that when the material is applied to a large object, you will not see any discontinuity. In order for this effect to work, the texture has to be imported in Repeat mode. If you want a smooth and continuous look for your water, you should also set it to Bilinear from Inspector. These settings ensure that the texture is sampled correctly from the shader:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/22479163-aae8-4c7b-8581-f37f4874a050.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip65"></a>Note</h3><p>You can find an example noise texture in <code class="literal">Chapter 6</code> | <code class="literal">Textures</code> folder of the book's example code.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec132"></a>How to do it…</h3></div></div></div><p>To create this animated effect, you can start by refitting the shader. Follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Add the following properties:</li></ol></div><pre class="programlisting">_NoiseTex("Noise text", 2D) = "white" {}
_Colour ("Colour", Color) = (1,1,1,1)
_Period ("Period", Range(0,50)) = 1
_Magnitude ("Magnitude", Range(0,0.5)) = 0.05
_Scale ("Scale", Range(0,10)) = 1</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Add their <span>respective</span><a id="id325219406" class="indexterm"></a> variables to the <span>second</span><a id="id325442698" class="indexterm"></a> pass of the shader:</li></ol></div><pre class="programlisting">sampler2D _NoiseTex;
fixed4 _Colour;

float _Period;
float _Magnitude;
float _Scale;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Define the following input and output structures for the vertex function:</li></ol></div><pre class="programlisting">struct vertInput 
{
  float4 vertex : POSITION;
  fixed4 color : COLOR;
  float2 texcoord : TEXCOORD0;
};

struct vertOutput 
{
  float4 vertex : POSITION;
  fixed4 color : COLOR;
  float2 texcoord : TEXCOORD0;
  float4 worldPos : TEXCOORD1;
  float4 uvgrab : TEXCOORD2;
};</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>This shader needs to know the exact position of the space of every fragment. To do this, update the vertex function to the following:</li></ol></div><pre class="programlisting">// Vertex function
vertOutput vert(vertInput v) 
{
  vertOutput o;
  o.vertex = UnityObjectToClipPos(v.vertex);
  o.color = v.color;
  o.texcoord = v.texcoord;

  o.worldPos = mul(unity_ObjectToWorld, v.vertex);
  o.uvgrab = ComputeGrabScreenPos(o.vertex);

  return o;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Use the following Fragment function:</li></ol></div><pre class="programlisting">fixed4 frag (vertOutput i) : COLOR 
{
  float sinT = sin(_Time.w / _Period);

  float distX = tex2D(_NoiseTex, i.worldPos.xy / _Scale +                 float2(sinT,
    0) ).r - 0.5;
  float distY = tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(0,
    sinT) ).r - 0.5;

  float2 distortion = float2(distX, distY);
  i.uvgrab.xy += distortion * _Magnitude;
  fixed4 col = tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(i.uvgrab));
  return col * _Colour;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Save your script and return to the Unity editor. Afterward, select your Water Material (<code class="literal">WatMat</code>)and apply the noise texture. Afterward, tweak <span>the</span><a id="id325445088" class="indexterm"></a> properties <span>in</span><a id="id325445174" class="indexterm"></a> the Water Material and notice how it modifies the things behind it.</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/0ecfb48e-c813-4c53-b943-8013d2aaa0b0.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec133"></a>How it works…</h3></div></div></div><p>This shader is very similar to the one introduced in the <span class="emphasis"><em>Implementing a Glass Shader</em></span> recipe. The major difference is that this is an animated material; the displacement is not generated from a normal map, but takes into account the current time in order to create a constant animation. The code that displaces the UV data of the grab texture seems quite complicated; let's try to understand how it has been generated. The idea behind it is that a sinusoid function is used to make the water oscillate. This effect needs to evolve over time; to achieve this effect, the distortion generated by the shader depends on the current time that is retrieved with the built-in variable, <code class="literal">_Time</code>. The <code class="literal">_Period</code> variable determines the period of the sinusoid, which means how fast the waves appear:</p><pre class="programlisting">float2 distortion = float2( sin(_Time.w/_Period), 
  sin(_Time.w/_Period) ) – 0.5;</pre><p>The problem with this code is that you have the same displacement on the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> axes; as a result, the entire grab texture will rotate in a circular motion, which looks nothing like water. We obviously need to add some randomness to this.</p><p>The most common way to add random behaviors to shaders is by including a noise texture. The problem now is to find a way to sample <span>the</span><a id="id325445221" class="indexterm"></a> texture at seemingly random positions. The best <span>way</span><a id="id325453454" class="indexterm"></a> to avoid seeing an obvious sinusoid pattern is to use the sine waves as an offset in the UV data of the <code class="literal">_NoiseTex</code> texture:</p><pre class="programlisting">float sinT = sin(_Time.w / _Period);
float2 distortion = float2<span>( 
    tex2D(_NoiseTex, i.texcoord / _Scale + float2(sinT, 0) ).r - 0.5,
    tex2D(_NoiseTex, i.texcoord / _Scale + float2(0, sinT) ).r - 0.5
);</span></pre><p>The <code class="literal">_Scale</code> variable determines the size of the waves. This solution is closer to the final version but has a severe issue—if the water quad moves, the UV data follows it and you can see the water waves following the material rather than being anchored to the background. To solve this, we need to use the world position of the current fragment as the initial position for the UV data:</p><pre class="programlisting">float sinT = sin(_Time.w / _Period);
<span class="strong"><strong>float2 distortion = float2<span><span>( 
    tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(sinT, 0) ).r - 0.5,
    tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(0, sinT) ).r - 0.5
);</span></span>
i.uvgrab.xy += distortion * _Magnitude;</strong></span></pre><p>The result is a pleasant, seamless distortion, which doesn't move in any clear direction.</p><p>We can also improve the readability of the code by <span>breaking apart</span> the distortion into smaller steps:</p><pre class="programlisting">float sinT = sin(_Time.w / _Period);

float distX = tex2D(_NoiseTex, i.worldPos.xy / _Scale + 
  float2(sinT, 0) ).r - 0.5;
float distY = tex2D(_NoiseTex, i.worldPos.xy / _Scale + 
  float2(0, sinT) ).r - 0.5;

float2 distortion = float2(distX, distY);
i.uvgrab.xy += distortion * _Magnitude;</pre><p>That is what <span>you</span><a id="id325453512" class="indexterm"></a> should see in the final result.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note66"></a>Note</h3><p>As happens with all these special effects, there is no perfect solution. This recipe shows you a technique to create water-like distortion, but you are encouraged to play with it until you find an effect that fits the aesthetics of your game.</p></div><p> </p></div></div>