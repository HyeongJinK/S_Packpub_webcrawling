<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec50"></a>Using the grab pass to draw behind objects</h2></div></div><hr /></div><p>In the <span class="emphasis"><em>Adding transparency to PBR</em></span> recipe of <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Physically-Based Rendering</em></span>, we have seen how a material can be made transparent. Even if a <span>transparent</span><a id="id325209396" class="indexterm"></a> material can draw over a scene, it cannot change what has been drawn underneath it. This means that those Transparent Shaders cannot create distortions such as the ones typically seen in glass or water. In order to simulate them, we need to introduce another technique called a grab pass. This <span>allows</span><a id="id325209404" class="indexterm"></a> us to access what has been drawn on-screen so far, so that a shader can use it (or alter it) with no restrictions. To learn how to use grab passes, we will create a material that grabs what's rendered behind it and draws it again on the screen. It's a shader that, paradoxically, uses several operations to show no changes at all.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec123"></a>Getting ready</h3></div></div></div><p>This recipe requires the following operations:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a shader (<code class="literal">GrabShader</code>) that we will initialize later.</li><li>Create a material (<code class="literal">GrabMat</code>) to host the shader.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Attach the material to a flat piece of geometry, such as a quad. Place it in front of some other object so that you cannot see through it. The quad will appear transparent as soon as the shader is complete:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/78232494-2f20-410e-807f-6b9e8af4d796.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec124"></a>How to do it…</h3></div></div></div><p>To use a grab pass, you <span>need</span><a id="id325209458" class="indexterm"></a> to follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Remove the <code class="literal">Properties</code> section, and the <code class="literal">Input</code> section; this shader will not use any of them.</li><li>In the <code class="literal">SubShader</code> section, remove everything, and add the following to ensure the object is treated as being <code class="literal">Transparent</code>:</li></ol></div><pre class="programlisting">Tags{ "Queue" = "Transparent" }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Then, below that, add a grab pass:</li></ol></div><pre class="programlisting">GrabPass{ }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>After the <code class="literal">GrabPass</code>, we will need to add this extra pass:</li></ol></div><pre class="programlisting">Pass 
{
  CGPROGRAM
  #pragma vertex vert
  #pragma fragment frag

  #include "UnityCG.cginc"
  sampler2D _GrabTexture;

  struct vertInput 
  {
    float4 vertex : POSITION;
  };

  struct vertOutput 
  {
    float4 vertex : POSITION;
    float4 uvgrab : TEXCOORD1;
  };

  // Vertex function
  vertOutput vert(vertInput v) 
  {
    vertOutput o;
    o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);
    o.uvgrab = ComputeGrabScreenPos(o.vertex);
    return o;
  }
  // Fragment function
  half4 frag(vertOutput i) : COLOR 
  {
    fixed4 col = tex2Dproj(_GrabTexture, UNITY_PROJ_COORD(i.uvgrab));
    return col + half4(0.5,0,0,0);
  }
  ENDCG
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Save your script and <span>return</span><a id="id325442705" class="indexterm"></a> to the Unity editor. Upon getting back, you should notice your material now works the way you intend it to:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788396233/graphics/08e59f50-7669-4ed6-8291-188a5f57f272.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec125"></a>How it works…</h3></div></div></div><p>This recipe not only introduces grab passes, but also Vertex and Fragment Shaders; for this reason, we have to analyze the shader in detail.</p><p>So far, all the code has always been placed directly in the <code class="literal">SubShader</code> section. This is because our previous shaders required only a single pass. This time, two passes are required. The first one is the <code class="literal">GrabPass{}</code>, which is defined simply by <code class="literal">GrabPass{}</code>. The rest of the code is placed in the second pass, which is contained in a <code class="literal">Pass</code> block.</p><p>The second pass is not structurally different from the shader shown in the first recipe of this chapter; we use the vertex function, <code class="literal">vert</code>, to get the position of the vertex, and then we give it a color in the Fragment function frag. The difference is that vert calculates another important detail: the UV data for the <code class="literal">GrabPass{}</code>. The <code class="literal">GrabPass{}</code> automatically creates a texture that can be referred to as follows:</p><pre class="programlisting">sampler2D _GrabTexture;</pre><p>In order to sample this texture, we need its UV data. The <code class="literal">ComputeGrabScreenPos</code> function returns data that we can use later to sample the grab texture correctly. This is done in the Fragment Shader using the following line:</p><pre class="programlisting">fixed4 col = tex2Dproj(_GrabTexture, UNITY_PROJ_COORD(i.uvgrab));</pre><p>This is the standard way in which a texture is grabbed and applied to the screen in its correct position. If everything has been done correctly, this shader will simply clone what has been rendered behind the geometry. We will see in the following recipes how this technique can be used to create materials such as water and glass.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec126"></a>There's more…</h3></div></div></div><p>Every time you use a material with <code class="literal">GrabPass{}</code>, Unity will have to render the screen to a texture. This operation is very expensive and limits the number of <code class="literal">GrabPass</code> instances that you can use in a game. Cg offers a slightly different variation:</p><pre class="programlisting">GrabPass {"TextureName"}</pre><p>This line not only allows you to give a name to the texture, but also shares the texture with all the materials that have a <code class="literal">GrabPass</code> called <code class="literal">TextureName</code>. This means that if you have ten materials, Unity will only do a single <code class="literal">GrabPass</code> and share the texture with all of them. The main problem of this technique is that it doesn't allow for effects that can be stacked. If you are creating a glass with this technique, you won't be able to have two <span>glasses</span><a id="id325445200" class="indexterm"></a> one after the other.</p></div></div>