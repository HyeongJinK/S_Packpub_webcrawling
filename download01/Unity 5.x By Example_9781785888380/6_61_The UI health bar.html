<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec62"></a>The UI health bar</h2></div></div><hr /></div><p>In the <a id="id369" class="indexterm"></a>previous section, we introduced the first danger and hazard to the <a id="id370" class="indexterm"></a>game; namely, a Kill Zone that can damage and potentially kill the player. As a result, their health has the potential to reduce from its starting state. It's therefore useful both to us as developers and gamers to visualize the health status. For this reason, let's focus on rendering player health to the screen as a UI health bar. This configuration of objects will also be made as a prefab, allowing reuse across multiple scenes This will prove a highly useful feature. <span class="emphasis"><em>Figure 6.9</em></span> offers a glimpse of the future, displaying the result of our work to come:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_09.jpg" /><div class="caption"><p>Figure 6.9: Preparing to create player health</p></div></div><p>To get started, create a new GUI Canvas in the scene (any scene) by choosing <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Canvas</strong></span> from the application menu. Selecting this will automatically create an <span class="strong"><strong>EventSystem</strong></span> object in the scene, if one does not exist already. This object is essential for proper <a id="id371" class="indexterm"></a>use of the UI system. If you accidentally delete it, <span class="strong"><strong>EventSystem</strong></span> can be recreated by choosing <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Event System</strong></span> from <a id="id372" class="indexterm"></a>the application menu. The newly created Canvas object represents the surface on which the GUI will be drawn. See <span class="emphasis"><em>Figure 6.10</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_10.jpg" /><div class="caption"><p>Figure 6.10: Creating a GUI Canvas and Event System</p></div></div><p>Next, we'll create a new and separate camera object for the UI, adding it as a child of the newly created Canvas. By creating a separate camera for UI rendering, we can apply camera effects and other image adjustments separately to the UI, if we need to. To create a Camera as a child, right-click on the <span class="strong"><strong>Canvas</strong></span> object in the <span class="strong"><strong>Hierarchy</strong></span> panel and, from the <span class="strong"><strong>Context</strong></span> menu, choose <span class="strong"><strong>Camera</strong></span>. This adds a new camera object to the scene as a child of the selected object. See <span class="emphasis"><em>Figure 6.11</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_11.jpg" /><div class="caption"><p>Figure 6.11: Creating a camera child object</p></div></div><p>Now, configure the UI camera to be an Orthographic camera. We saw how to do this in the previous chapter, as well as earlier chapters too. <span class="emphasis"><em>Figure 6.12</em></span> displays the camera settings for an <a id="id373" class="indexterm"></a>orthographic camera. Remember that an Orthographic camera is truly 2D insofar as it removes perspective and foreshortening effects from the render result, which is appropriate for GUIs and other objects that live and <a id="id374" class="indexterm"></a>work in screen space. In addition, the camera <span class="strong"><strong>Depth</strong></span> field, from the <span class="strong"><strong>Object Inspector</strong></span>, should be higher than the main game camera to ensure that it renders on top of everything else. Otherwise, the GUI could potentially render beneath and be ineffectual in the game.</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_12.jpg" /><div class="caption"><p>Figure 6.12: Configuring an Orthographic camera for GUI rendering</p></div></div><p>The created camera is almost ready to go! However, right now, it's configured to render everything in the scene just like any other camera. This means that the scene is effectively being rendered twice by two separate cameras. This is not only wasteful and poor for <a id="id375" class="indexterm"></a>performance, but it makes the second camera totally unnecessary. Instead, we want the first and original camera to show everything in the scene, in terms of characters and environments, but to ignore GUI objects, and likewise, the newly created GUI camera should show only GUI objects. To fix this, select the main game camera and, from the <span class="strong"><strong>Object Inspector</strong></span>, click on the <span class="strong"><strong>Culling Mask</strong></span> drop-down list in the <span class="strong"><strong>Camera</strong></span> component. From here, remove the check mark for the UI layer. This drop-down list allows you to select layers to be ignored for the rendering from the selected camera. See <span class="emphasis"><em>Figure 6.13</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_13.jpg" /><div class="caption"><p>Figure 6.13: Ignore the UI layer for the main camera</p></div></div><p>Now, select the GUI camera object and, for the <span class="strong"><strong>Culling Mask</strong></span> field in the <span class="strong"><strong>Camera</strong></span> component, select the <span class="strong"><strong>Nothing</strong></span> option to deselect all options, and then enable the UI layer to render <a id="id376" class="indexterm"></a>only UI layer objects. See <span class="emphasis"><em>Figure 6.14</em></span>. Good <a id="id377" class="indexterm"></a>work!</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_14.jpg" /><div class="caption"><p>Figure 6.14: Ignoring all layers except the UI layer for the GUI camera</p></div></div><p>By default, any newly created Canvas is configured to work in the Screen Space Overlay mode, which means it renders on top of everything else in the scene that is not associated with any specific camera. In addition, all GUI elements will be sized and scaled on the basis of this. Consequently, to make our work simpler, let's start creating the GUI by first configuring the <span class="strong"><strong>Canvas</strong></span> object to work with the newly created GUI camera. To do this, select the <span class="strong"><strong>Canvas</strong></span> object and, from the <span class="strong"><strong>Canvas</strong></span> component in the <span class="strong"><strong>Object Inspector</strong></span>, change the <span class="strong"><strong>Render Mode</strong></span> from <span class="strong"><strong>Screen Space - Overlay</strong></span> to <span class="strong"><strong>Screen Space - Camera</strong></span>. Then, drag and drop the GUI camera object to the <span class="strong"><strong>Camera</strong></span> field. See <span class="emphasis"><em>Figure 6.15</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_15.jpg" /><div class="caption"><p>Figure 6.15: Configuring the Canvas component for camera rendering</p></div></div><p>Next, let's configure the <span class="strong"><strong>Canvas Scaler</strong></span> component, which is attached to the <span class="strong"><strong>Canvas</strong></span> object. This component is responsible for how the GUI appears when the screen size is changed, from either up-scaling or down-scaling. In short, for our game, the GUI should up- and down-scale relatively to the screen size. For this reason, change the <span class="strong"><strong>UI Scale Mode</strong></span> <a id="id378" class="indexterm"></a>drop-down to <span class="strong"><strong>Scale With Screen Size</strong></span>, and then enter the game <a id="id379" class="indexterm"></a>resolution of <code class="literal">1024 x 600</code> in the <span class="strong"><strong>Reference Resolution</strong></span> field. See <span class="emphasis"><em>Figure 6.16</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_16.jpg" /><div class="caption"><p>Figure 6.16: Adjusting the Canvas Scaler for responsive UI design</p></div></div><p>Now, we can start adding GUI elements to the game, knowing that they will appear correctly when added to the scene. To display health, a representation of the player will be useful. Create a new <span class="strong"><strong>Image</strong></span> object by right-clicking on the <span class="strong"><strong>Canvas</strong></span> object from the <span class="strong"><strong>Hierarchy</strong></span> panel and choosing <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Image</strong></span> from the context menu. Once created, select the <span class="strong"><strong>Image</strong></span> object and, from the <span class="strong"><strong>Object Inspector</strong></span> (in the <span class="strong"><strong>Image</strong></span> component), drag and drop the player head sprite from the <span class="strong"><strong>Project</strong></span> panel to the <span class="strong"><strong>Source Image</strong></span> field. Then, use the <span class="strong"><strong>Rect Transform</strong></span> tool (<span class="emphasis"><em>T</em></span> on the keyboard) to resize the image in place at the top-left corner of the screen. See <span class="emphasis"><em>Figure 6.17</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_17.jpg" /><div class="caption"><p>Figure 6.17: Adding a head image to the GUI Canvas</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"></a>Note</h3><p>If you cannot see the added head image, remember to assign the UI layer to render by the UI camera. In addition, you may need to offset the GUI camera back along the <span class="emphasis"><em>Z</em></span> axis to include the head sprite within the <span class="strong"><strong>Camera Frustum</strong></span> (Viewing Area).</p></div><p>Finally, anchor the Head Sprite to the top-left of the screen by clicking on the <span class="strong"><strong>Anchor Preset</strong></span> button <a id="id380" class="indexterm"></a>in the <span class="strong"><strong>Rect Transform</strong></span> component from the <span class="strong"><strong>Object Inspector</strong></span>. Choose top-left alignment. This locks the head sprite to the screen top-left, ensuring that the interface would look consistent at multiple resolutions. See <span class="emphasis"><em>Figure 6.18</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_18.jpg" /><div class="caption"><p>Figure 6.18: Anchoring the head position</p></div></div><p>To create the health bar, add a new <span class="strong"><strong>Image</strong></span> object to the GUI Canvas by right-clicking on the <span class="strong"><strong>Canvas</strong></span> and selecting <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Image</strong></span> from the context menu. For this object, leave the <span class="strong"><strong>Source Image</strong></span> field empty and choose red for the <span class="strong"><strong>Color</strong></span> field, <span class="strong"><strong>RGB (255,0,0)</strong></span>. This will represent the background <a id="id381" class="indexterm"></a>or <span class="emphasis"><em>red status</em></span> for the health bar when it's fully depleted. Then, use the <span class="strong"><strong>Rect Transform</strong></span> tool to resize the bar as needed, anchoring to the top-left screen corner. See <span class="emphasis"><em>Figure 6.19</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_19.jpg" /><div class="caption"><p>Figure 6.19: Creating the red health status</p></div></div><p>To complete the health bar, we'll need to use scripting. Specifically, we're going to overlap two <a id="id382" class="indexterm"></a>identical health bars on top of each other, one red and one green. We'll scale the green bar as the health reduces so that it reveals the red bar underneath. Before scripting this behavior, further configuration is necessary. Specifically, let's change the pivot of the health bar away from the center and to the middle-left point—the point from which the health bar should scale as it reduces and increases. To <a id="id383" class="indexterm"></a>do this, select the <span class="strong"><strong>Health bar</strong></span> object and, from the <span class="strong"><strong>Object Inspector</strong></span>, enter a new <span class="strong"><strong>Pivot</strong></span> value of <code class="literal">0</code> for <span class="strong"><strong>X</strong></span> and <code class="literal">0.5</code> for <span class="strong"><strong>Y</strong></span>. See <span class="emphasis"><em>Figure 6.20</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_20.jpg" /><div class="caption"><p>Figure 6.20: Repositioning the Pivot for the health bar</p></div></div><p>To create the green overlay for the health, select the red health bar and duplicate it. Name the duplicate <code class="literal">Health_Green</code> and drag and drop it to appear beneath the red version in the <span class="strong"><strong>Hierarchy</strong></span> panel. The ordering of objects in the hierarchy relates to the draw order for GUI elements—lower-order objects are rendered on top of higher-order objects. See <span class="emphasis"><em>Figure 6.21</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_06_21.jpg" /><div class="caption"><p>Figure 6.21: Creating a duplicate green bar</p></div></div><p>Now, we need to make a new script file linking the width of the green bar to the health of the player. This <a id="id384" class="indexterm"></a>means that reductions in health will reduce the width of the green bar, revealing the red bar beneath. Create a new script file named <a id="id385" class="indexterm"></a>
<code class="literal">HealthBar.cs</code> and attach it to the green bar. The following is the <span class="emphasis"><em>Code Sample 6.3</em></span> for the <code class="literal">HealthBar</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class HealthBar : MonoBehaviour
{
  //Reference to this transform component
  private RectTransform ThisTransform = null;

  //Catch up speed
  public float MaxSpeed = 10f;

    void Awake()
    {
      //Get transform component
      ThisTransform = GetComponent&lt;RectTransform&gt;();
    }

    void Start()
    {
      //Set Start Health
      if(PlayerControl.PlayerInstance!=null)
        ThisTransform.sizeDelta = new Vector2(Mathf.Clamp(PlayerControl.Health,0,100),ThisTransform.sizeDelta.y);
    }

    // Update is called once per frame
    void Update () 
    {
      //Update health property
      float HealthUpdate = 0f;

      if(PlayerControl.PlayerInstance!=null)
        HealthUpdate = Mathf.MoveTowards(ThisTransform.rect.width, PlayerControl.Health, MaxSpeed);

        ThisTransform.sizeDelta = new Vector2(Mathf.Clamp(HealthUpdate,0,100),ThisTransform.sizeDelta.y);
    }
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec26"></a>Code Sample 6.3</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <a id="id386" class="indexterm"></a>
<code class="literal">HealthBar</code> class is responsible for reducing the width of a green (on the top) health bar, based on the player health.</p></li><li style="list-style-type: disc"><p>The <a id="id387" class="indexterm"></a>
<code class="literal">SizeDelta</code> property of <code class="literal">RectTransform</code> is used to set the width of <code class="literal">RectTransform</code>. More information on this property can be found at the online Unity <a id="id388" class="indexterm"></a>documentation at <a class="ulink" href="http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html" target="_blank">http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html</a>.</p></li><li style="list-style-type: disc"><p>The <code class="literal">Mathf.MoveTowards</code> function is used to gradually and smoothly transition the <a id="id389" class="indexterm"></a>health bar width from its existing width to its destination width over time. That is, as and when player health is reduced, the health bar will decrease gradually as opposed to instantly. More information can be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html" target="_blank">http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html</a>.</p></li></ul></div><p>Finally, make a prefab of the UI objects by dragging and dropping the topmost <span class="strong"><strong>Canvas</strong></span> object from the <span class="strong"><strong>Hierarchy</strong></span> panel to the <span class="strong"><strong>Project</strong></span> panel in the <span class="strong"><strong>Prefab</strong></span> folder. This allows the UI system to be reused across multiple scenes.</p></div></div>