<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec74"></a>Enemy AI – range of sight</h2></div></div><hr /></div><p>Let's now <a id="id464" class="indexterm"></a>start developing enemy AI by thinking about our functional requirements. The enemies in the scene will begin in patrol mode, wandering the level from place to place searching for the player character. If the player is spotted, the enemy will change from patrolling and begin chasing the player, attempting to move closer to them for an attack. If the enemy reaches within attacking range of the player, the enemy will change from chasing to attacking. If the player outruns the enemy and successfully loses them, the enemy should stop chasing and return to patrolling again, searching for the player as they were doing initially. This, in sum, describes our needed enemy AI behavior.</p><p>To achieve this behavior, we'll need to code the line of sight functionality for the enemy. The enemy relies on being able to see the player character or determining whether the player is visible to the enemy at any one moment. This helps the enemy decide whether they should patrol or chase the player character. To code this, refer to the following code from the source file, <code class="literal">LineSight.cs</code>. This script file should be attached to the enemy character created so far from the previous chapter.</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------------------
public class LineSight : MonoBehaviour
{
  //------------------------------------------
  //How sensitive should we be to sight
  public enum SightSensitivity {STRICT, LOOSE};

  //Sight sensitivity
  public SightSensitivity Sensitity = SightSensitivity.STRICT;

  //Can we see target
  public bool CanSeeTarget = false;

  //FOV
  public float FieldOfView = 45f;

  //Reference to target
  private Transform Target = null;

  //Reference to eyes
  public Transform EyePoint = null;

  //Reference to transform component
  private Transform ThisTransform = null;

  //Reference to sphere collider
  private SphereCollider ThisCollider = null;

  //Reference to last know object sighting, if any
  public Vector3 LastKnowSighting = Vector3.zero;
  //------------------------------------------
  void Awake()
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
    ThisCollider = GetComponent&lt;SphereCollider&gt;();
    LastKnowSighting = ThisTransform.position;
    Target = GameObject.FindGameObjectWithTag("Player").GetComponent&lt;Transform&gt;();
  }
  //------------------------------------------
  bool InFOV()
  {
    //Get direction to target
    Vector3 DirToTarget = Target.position - EyePoint.position;

    //Get angle between forward and look direction
    float Angle = Vector3.Angle(EyePoint.forward, DirToTarget);

    //Are we within field of view?
    if(Angle &lt;= FieldOfView)
      return true;

    //Not within view
    return false;
  }
  //------------------------------------------
  bool ClearLineofSight()
  {
    RaycastHit Info;
  
    if(Physics.Raycast(EyePoint.position, (Target.position - EyePoint.position).normalized, out Info, ThisCollider.radius))
    {
      //If player, then can see player
      if(Info.transform.CompareTag("Player"))
        return true;
    }

    return false;
  }
  //------------------------------------------
  void UpdateSight()
  {
    switch(Sensitity)
    {
      case SightSensitivity.STRICT:
        CanSeeTarget = InFOV() &amp;&amp; ClearLineofSight();
      break;

      case SightSensitivity.LOOSE:
        CanSeeTarget = InFOV() || ClearLineofSight();
      break;
    }
  }
  //------------------------------------------
  void OnTriggerStay(Collider Other)
  {
    UpdateSight();

    //Update last known sighting
    if(CanSeeTarget)
      LastKnowSighting =  Target.position;
  }
  //------------------------------------------
  void OnTriggerExit(Collider Other)
  {
    if(!Other.CompareTag("Player"))return;

    CanSeeTarget = false;
  }
  //------------------------------------------
}
//------------------------------------------</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec29"></a>Code Sample 8.1</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <a id="id465" class="indexterm"></a>
<code class="literal">LineSight</code> class should be attached to any enemy character object. Its purpose is to calculate whether a direct line of sight is available between the player and enemy.</p></li><li style="list-style-type: disc"><p>The <code class="literal">CanSeeTarget</code> variable is a Boolean (<code class="literal">True</code>/<code class="literal">False</code>), which is updated on a per frame basis to describe whether the enemy can see the player <span class="emphasis"><em>right now</em></span> (for this frame). <code class="literal">True</code> means that the player is in sight of the enemy, and <code class="literal">false</code> means that the player is not visible.</p></li><li style="list-style-type: disc"><p>The <code class="literal">FieldOfView</code> variable is a floating point value that determines an angular margin on either side of the enemy eye-point, inside which objects (like the player) can be seen. The higher this value, the more chance the enemy has of seeing the player.</p></li><li style="list-style-type: disc"><p>The <code class="literal">InFOV</code> function returns <code class="literal">true</code> or <code class="literal">false</code> to indicate whether the player is within the enemy field of view. This ignores whether the player is occluded behind a wall or solid object (like a pillar). It simply takes the position of the enemy eyes, determines a vector to the player, and measures the angle between the forward vector and player. It compares this to the field of view, and returns <code class="literal">true</code> if the angle between enemy and player is less than the <code class="literal">FieldOfView</code> variable. In short, this function can tell you whether the enemy would see the player if there were a clear line of sight.</p></li><li style="list-style-type: disc"><p>The <code class="literal">ClearLineOfSight</code> function returns <code class="literal">true</code> or <code class="literal">false</code> to indicate whether there are any physical obstacles (Colliders), such as walls or props, between the enemy eye point and player. This does not consider whether the player is within the enemy field of view. This function, in combination with the <code class="literal">InFOV</code> function, can determine whether the enemy has a clear line of sight to the player and is within the field of view, and thus, whether the player is visible.</p></li><li style="list-style-type: disc"><p>The <code class="literal">OnTriggerStay</code> and <code class="literal">OnTriggerExit</code> functions are called when the player is within a trigger volume surrounding the enemy and when the player leaves this volume respectively. As we'll see, a sphere collider can be attached to the enemy character object to represent its horizon of view. This means the total distance, or radius, inside which the enemy could see the player, provided they were within the field of view and a clear line of sight existed.</p></li></ul></div><p>Now, attach <a id="id466" class="indexterm"></a>the <code class="literal">LineSight.cs</code> script file to the enemy character in the scene as well as a Sphere Collider component (marked as a Trigger) to approximate the viewing horizon of the enemy. See <span class="emphasis"><em>Figure 8.1</em></span>. Leave the <span class="strong"><strong>Field of View</strong></span> setting at <code class="literal">45</code>, although this can be increased, if needed, to around <code class="literal">90</code> to tweak the effectiveness of the enemy viewing range.</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_01.jpg" /><div class="caption"><p>Figure 8.1: Adding a horizon to the NPC</p></div></div><p>The <span class="strong"><strong>Eye Point</strong></span> field is, by default, set to <span class="strong"><strong>None</strong></span>, which represents a null value. This should refer to a specific location on the enemy character that acts as the eye point—the place from which the character can see. To create this point, add a new and empty game object to the scene using the application menu, <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span>. Name the object <code class="literal">Eye Point</code>, activate its visibility from the <span class="strong"><strong>Inspector</strong></span> using a Gizmo icon (so that it can be visible even when deselected), and then add it as a child object to the enemy. Afterward, position the object to the character eye point, making sure that the forward vector is <a id="id467" class="indexterm"></a>facing in the same direction. See <span class="emphasis"><em>Figure 8.2:</em></span>
</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_02.jpg" /><div class="caption"><p>Figure 8.2:  Adding an EyePoint</p></div></div><p>Now, drag and drop the Eye Point object from the <span class="strong"><strong>Hierarchy</strong></span> panel to the <span class="strong"><strong>Eye Point</strong></span> field for the LineSight component in the <span class="strong"><strong>Inspector</strong></span>. This specifies the Eye Point object as the eye point for the enemy character. This will be used in determining whether the enemy can see the player. Having a separate eye point object like this is useful as opposed to using the character position, which is typically at the feet location and not the eye. See <span class="emphasis"><em>Figure 8.3</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_03.jpg" /><div class="caption"><p>Figure 8.3: Defining the eye point for an NPC</p></div></div><p>Finally, the <code class="literal">LineSight</code> script determines the player location by first finding the player object in the scene using the <span class="strong"><strong>Player</strong></span> tag. Consequently, make sure that the <span class="strong"><strong>Player</strong></span> is tagged or <a id="id468" class="indexterm"></a>labeled using the <span class="strong"><strong>Player</strong></span> tag. See <span class="emphasis"><em>Figure 8.4</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_04.jpg" /><div class="caption"><p>Figure 8.4: Tagging the player object</p></div></div><p>Now take your game for a test run. When you approach the NPC object, the <span class="strong"><strong>Can See Target</strong></span> field will be enabled. See <span class="emphasis"><em>Figure 8.5</em></span>. Good work! The line of sight functionality is now completed. Let's move on!</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_05.jpg" /><div class="caption"><p>Figure 8.5: Testing the line of sight functionality</p></div></div></div></div>