<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec76"></a>The Patrol state</h2></div></div><hr /></div><p>The first of the <a id="id474" class="indexterm"></a>three states to implement for the NPC AI is the Patrol State. In the previous chapter, we configured an animated patrol object, which the NPC should follow continuously during this state. The patrol object moves around the level from a predefined animation asset, changing from one position to the next. However, previously, the NPC simply followed this object without end, whereas the Patrol State requires the NPC to consider whether the player can be seen on its route. If it can, the state should change. To support this functionality, the Patrol State and Start function of the <code class="literal">AI_Enemy</code> <a id="id475" class="indexterm"></a>class has been coded, as featured in the following code:</p><div class="informalexample"><pre class="programlisting">  void Start()
  {
    //Get random destination
    GameObject[] Destinations = GameObject.FindGameObjectsWithTag("Dest");
    PatrolDestination = Destinations[Random.Range(0, Destinations.Length)].GetComponent&lt;Transform&gt;();

    //Configure starting state
    CurrentState = ENEMY_STATE.PATROL;
  }
  //------------------------------------------
  public IEnumerator AIPatrol()
  {
    //Loop while patrolling
    while(currentstate == ENEMY_STATE.PATROL)
    {
      //Set strict search
      ThisLineSight.Sensitity = LineSight.SightSensitivity.STRICT;

      //Chase to patrol position
      ThisAgent.Resume();
      ThisAgent.SetDestination(PatrolDestination.position);

      //Wait until path is computed
      while(ThisAgent.pathPending)
        yield return null;

      //If we can see the target then start chasing
      if(ThisLineSight.CanSeeTarget)
      {
        ThisAgent.Stop();
        CurrentState = ENEMY_STATE.CHASE;
        yield break;
      }

      //Wait until next frame
      yield return null;
    }
  }</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec31"></a>Code Sample 8.3</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">Start</code> <a id="id476" class="indexterm"></a>function sets the initial state of the enemy character to Patrol. The coroutine AIPatrol handles this state.</p></li><li style="list-style-type: disc"><p>The AIPatrol coroutine loops infinitely for as long as the <code class="literal">Patrol</code> state is active. Remember that an infinite loop is not necessarily a bad thing when used in a coroutine and in combination with a yield statement. This allows prolonged behaviors to be coded neatly and easily over time.</p></li><li style="list-style-type: disc"><p>The <code class="literal">SetDestination</code> function is called to send <code class="literal">NavMeshAgent</code> to the specified destination. This is followed by a <code class="literal">pathPending</code> check, which is a variable of the <code class="literal">NavMeshAgent</code>. This check waits until the <code class="literal">pathPending</code> variable is false, indicating that a full traversable path has been calculated from the source to the destination. For short and simple journeys, a path may be calculated almost immediately, but for paths that are more complex, this can take much longer.</p></li><li style="list-style-type: disc"><p>During the Patrol state, we constantly check the <code class="literal">LineSight</code> component to determine whether the enemy has a direct line of sight to the player. If so, the enemy changes from the <code class="literal">Patrol</code> state to the <code class="literal">Chase</code> state.</p></li><li style="list-style-type: disc"><p>Remember that the yield return null statement will pause a coroutine until the next frame.</p></li></ul></div><p>Now, drag and drop the <code class="literal">AIEnemy</code> script to the NPC character in the scene, if you haven't already. The <code class="literal">Patrol</code> mode is configured to track a moving object, that is, the enemy will follow a moving destination. A moving destination was created in the previous chapter using the <span class="strong"><strong>Animation</strong></span> window to move an object around the scene over time, jumping from one place to another. See <span class="emphasis"><em>Figure 8.7</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_07.jpg" /><div class="caption"><p>Figure 8.7: Creating movable objects</p></div></div><p>To achieve movable objects, create one or more destination object in the scene and assign them a <span class="strong"><strong>Dest</strong></span> tag. Remember that the <code class="literal">start</code> function for <code class="literal">AIEnemy</code> searches the scene for all objects tagged as <span class="strong"><strong>Dest</strong></span> and <a id="id477" class="indexterm"></a>it uses these as destination points. See <span class="emphasis"><em>Figure 8.8</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_08.jpg" /><div class="caption"><p>Figure 8.8: Tagging destination objects</p></div></div></div></div>