<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec43"></a>Ammo spawning</h2></div></div><hr /></div><p>The <code class="literal">Ammo</code> prefab created <a id="id251" class="indexterm"></a>so far presents us with a technical problem that, if not taken seriously, has the potential to cause some serious performance <a id="id252" class="indexterm"></a>penalties for our game. Specifically, when the spaceship weapon is fired, we'll need to generate ammo that launches into the scene and destroys the enemies on collision. This is fine in general, but the problem is that the player could potentially press the fire button many times in quick succession and could even hold down the fire button for long periods of time, and thereby spawn potentially hundreds of ammo prefabs. We could, of course, use the <code class="literal">Instantiate</code> function seen already to generate these prefabs dynamically, but this is problematic because instantiate is computationally expensive. When used to generate many items in succession, it will typically cause a nightmarish slowdown that'll reduce the FPS to unacceptable levels. We need to avoid this!</p><p>The solution is <a id="id253" class="indexterm"></a>known as <span class="strong"><strong>Pooling</strong></span>, <span class="strong"><strong>Object Pooling</strong></span>, or <span class="strong"><strong>Object Caching</strong></span>. In essence, it means <a id="id254" class="indexterm"></a>that we must spawn a large and recyclable batch of ammo objects at <a id="id255" class="indexterm"></a>the level startup (a pool of objects) that initially, begin hidden or deactivated, and we simply activate the objects as and when needed (when the player fires a weapon). When the ammo collides with an enemy or when its lifetime <a id="id256" class="indexterm"></a>expires, we don't destroy the object entirely, we simply deactivate it again, returning it to the pool for reuse later if needed. In this way, we avoid all calls to <code class="literal">Instantiate</code> and simply recycle all ammo objects that we have. To get started with coding this functionality, we'll make an <code class="literal">AmmoManager</code> class. This class will be responsible for two features: first, generating a pool of ammo objects at scene startup, and second, giving us a valid and available ammo object from the pool on demand, such as on weapon-fire. Consider the following <code class="literal">AmmoManager</code> <span class="emphasis"><em>Code Sample 4.2</em></span> to achieve this:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
//------------------------------
public class AmmoManager : MonoBehaviour
{
  //------------------------------
  //Reference to ammo prefab
  public GameObject AmmoPrefab = null;

  //Ammo pool count
  public int PoolSize = 100;

  public Queue&lt;Transform&gt; AmmoQueue = new Queue&lt;Transform&gt;();

  //Array of ammo objects to generate
  private GameObject[] AmmoArray;

  public static AmmoManager AmmoManagerSingleton = null;
  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    if(AmmoManagerSingleton != null)
    {
      Destroy(GetComponent&lt;AmmoManager&gt;());
      return;
    }

    AmmoManagerSingleton = this;
    AmmoArray = new GameObject[PoolSize];

    for(int i=0; i&lt;PoolSize; i++)
    {
      AmmoArray[i] = Instantiate(AmmoPrefab, Vector3.zero, Quaternion.identity) as GameObject;
      Transform ObjTransform = AmmoArray[i].GetComponent&lt;Transform&gt;();
      ObjTransform.parent = GetComponent&lt;Transform&gt;();
      AmmoQueue.Enqueue(ObjTransform);
      AmmoArray[i].SetActive(false);
    }
  }
  //------------------------------
  public static Transform SpawnAmmo(Vector3 Position, Quaternion Rotation)
  {
    //Get ammo
    Transform SpawnedAmmo = AmmoManagerSingleton.AmmoQueue.Dequeue();

    SpawnedAmmo.gameObject.SetActive(true);
    SpawnedAmmo.position = Position;
    SpawnedAmmo.localRotation = Rotation;

    //Add to queue end
    AmmoManagerSingleton.AmmoQueue.Enqueue(SpawnedAmmo);

    //Return ammo
    return SpawnedAmmo;
  }
  //------------------------------
}
//------------------------------</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec20"></a>Code Sample 4.2</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">AmmoManager</code> <a id="id257" class="indexterm"></a>features an <code class="literal">AmmoArray</code> member variable, which holds a complete list (sequential array of references) of all ammo objects to be generated at startup (during the <code class="literal">Awake</code> event).</p></li><li style="list-style-type: disc"><p>
<code class="literal">AmmoArray</code> will be sized to <code class="literal">PoolSize</code>. This refers to the total number of ammo objects to be generated. The <code class="literal">Awake</code> function generates the ammo objects at the beginning of the level, and these are added to the queue with <code class="literal">Enqueue</code>.</p></li><li style="list-style-type: disc"><p>Once generated, each ammo object is deactivated with <code class="literal">SetActive(false)</code> and is held in the pool until needed.</p></li><li style="list-style-type: disc"><p>
<code class="literal">AmmoManager</code> uses the <code class="literal">Queue</code> class from the <code class="literal">Mono</code> library to manage how specific ammo objects are selected from the pool to be activated when fire is pressed. The queue works as a <span class="strong"><strong>First-In-First-Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>) object. That is, ammo objects <a id="id258" class="indexterm"></a>are added to the queue one at a time and can be removed when selected to be activated. The object removed from the queue is always the object at the front. More information on the <code class="literal">Queue</code> class can be found online at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx</a>.</p></li><li style="list-style-type: disc"><p>The <code class="literal">Enqueue</code> function of the <code class="literal">Queue</code> object is called during <code class="literal">Awake</code> to add objects initially to the queue, one by one, as they are generated.</p></li><li style="list-style-type: disc"><p>The <code class="literal">SpawnAmmo</code> <a id="id259" class="indexterm"></a>function should be called to generate a new item of ammo in the scene. This function does not rely on the <code class="literal">Instantiate</code> function but uses the <code class="literal">Queue</code> object instead. It removes the first ammo object from the queue, activates it, and then adds it to the end of the queue again behind all the other ammo objects. In this way, a cycle of generation and regeneration happens, allowing all ammo objects to be recycled.</p></li><li style="list-style-type: disc"><p>
<code class="literal">AmmoManager</code> is coded as a singleton object, meaning that one, and only one, instance of the object should exist in the scene at any one time. This functionality is achieved through the static member, <code class="literal">AmmoManagerSingleton</code>. For more information on singleton objects, refer to <span class="emphasis"><em>Mastering Unity Scripting</em></span> by <span class="emphasis"><em>Packt Publishing</em></span> at <a class="ulink" href="https://www.packtpub.com/game-development/mastering-unity-5x-scripting" target="_blank">https://www.packtpub.com/game-development/mastering-unity-5x-scripting</a>.</p></li></ul></div><p>To use this class, create a new <code class="literal">GameObject</code> in the scene called <code class="literal">AmmoManager</code> by selecting <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> from the application menu. Then, drag and drop the <code class="literal">AmmoManager</code> script from the <span class="strong"><strong>Project</strong></span> panel to select the object in the scene. Once created, drag and drop the <code class="literal">Ammo</code> prefab from the <code class="literal">Prefabs</code> folder to the <span class="strong"><strong>Ammo Prefab</strong></span> slot for the <span class="strong"><strong>Ammo Manager</strong></span> component in the <span class="strong"><strong>Object Inspector</strong></span>. See <span class="emphasis"><em>Figure 4.12</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_04_12.jpg" /><div class="caption"><p>Figure 4.12: Adding the Ammo Manager to an object</p></div></div><p>Now, the scene features an <code class="literal">AmmoManager</code> object to hold an ammo pool, offscreen and hidden. However, still nothing about our existing functionality actually connects a fire button press from the gamer with the generation of ammo in the scene. That is, we have no code to actually <a id="id260" class="indexterm"></a>make the ammo visible and working! This connection should now be made via the <code class="literal">PlayerController</code> script that we started in the previous chapter. This class should now be amended to handle ammo generation. The recoded <code class="literal">PlayerController</code> class is included in the following <span class="emphasis"><em>Code Sample 4.3</em></span>. The amendments are highlighted:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class PlayerController : MonoBehaviour
{
  //------------------------------
  private Rigidbody ThisBody = null;
  private Transform ThisTransform = null;

  public bool MouseLook = true;
  public string HorzAxis = "Horizontal";
  public string VertAxis = "Vertical";
  <span class="strong"><strong>public string FireAxis = "Fire1";</strong></span>

  public float MaxSpeed = 5f;
  <span class="strong"><strong>public float ReloadDelay = 0.3f;</strong></span>
  <span class="strong"><strong>public bool CanFire = true;</strong></span>

  <span class="strong"><strong>public Transform[] TurretTransforms;</strong></span>
  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    ThisBody = GetComponent&lt;Rigidbody&gt;();
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void FixedUpdate ()
  {
    //Update movement
    float Horz = Input.GetAxis(HorzAxis);
    float Vert = Input.GetAxis(VertAxis);
    Vector3 MoveDirection = new Vector3(Horz, 0.0f, Vert);
    ThisBody.AddForce(MoveDirection.normalized * MaxSpeed);

    //Clamp speed
    ThisBody.velocity = new Vector3(Mathf.Clamp(ThisBody.velocity.x, -MaxSpeed, MaxSpeed),
    Mathf.Clamp(ThisBody.velocity.y, -MaxSpeed, MaxSpeed),
    Mathf.Clamp(ThisBody.velocity.z, -MaxSpeed, MaxSpeed));

    //Should look with mouse?
    if(MouseLook)
    {
      //Update rotation - turn to face mouse pointer
      Vector3 MousePosWorld = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, 0.0f));
      MousePosWorld = new Vector3(MousePosWorld.x, 0.0f, MousePosWorld.z);

      //Get direction to cursor
      Vector3 LookDirection = MousePosWorld - ThisTransform.position;

      //FixedUpdate rotation
      ThisTransform.localRotation = Quaternion.LookRotation(LookDirection.normalized,Vector3.up);
    }

    //Check fire control
    if(Input.GetButtonDown(FireAxis) &amp;&amp; CanFire)
    {
      foreach(Transform T in TurretTransforms)
        AmmoManager.SpawnAmmo(T.position, T.rotation);

      CanFire = false;
      Invoke ("EnableFire", ReloadDelay);
    }
  }
  //------------------------------
  <span class="strong"><strong>void EnableFire()</strong></span>
  {
    CanFire = true;
  }
  //------------------------------
  public void Die()
  {
    Destroy(gameObject);
  }
}
//------------------------------</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec21"></a>Code Sample 4.3</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">PlayerController</code> <a id="id261" class="indexterm"></a>now features a <code class="literal">TurretTransform</code> array variable, listing all child empties being used as turret spawn locations.</p></li><li style="list-style-type: disc"><p>During the <code class="literal">Update</code> function, <code class="literal">PlayerController</code> checks for fire button presses. If detected, the code cycles through all turrets and spawns one ammo object at each turret location.</p></li><li style="list-style-type: disc"><p>Once ammo is fired, <code class="literal">ReloadDelay</code> is engaged (set to <code class="literal">true</code>). This means that the delay must first expire before new ammo can be fired again later.</p></li></ul></div><p>After adding this code to <code class="literal">PlayerController</code>, select the <code class="literal">Player</code> object in the scene and then drag and drop the <code class="literal">Turret</code> empty object on to the <code class="literal">TurretTransform</code> slot. This example uses only one turret, but you could add more if desired. See <span class="emphasis"><em>Figure 4.13</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_04_13.jpg" /><div class="caption"><p>Figure 4.13: Configuring TurretTransform for spawning ammo</p></div></div><p>Now you're ready to play test and fire ammo. By playing the scene and pressing fire on the keyboard or mouse (left-click), ammo will be generated. Excellent! However, on testing this, you may notice two main problems. First, the ammo appears too big or too small. Second, the ammo sometimes bounces, flips, or reacts to the player spaceship. Let's fix these in turn.</p><p>If the ammo appears <a id="id262" class="indexterm"></a>wrongly-sized, you can simply change the scale of the prefab. Select the <code class="literal">Ammo</code> prefab in the <span class="strong"><strong>Project</strong></span> panel, and from the <span class="strong"><strong>Object Inspector</strong></span>, enter a new scale in the <span class="strong"><strong>Transform</strong></span> component. See <span class="emphasis"><em>Figure 4.14</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_04_14.jpg" /><div class="caption"><p>Figure 4.14: Changing the Ammo prefab scale</p></div></div><p>If the ammo appears to bounce or react to the player spaceship, then we'll need to make the ammo immune or unresponsive to the player. To achieve this, we can use physics layers. In short, both the player spaceship and ammo should be added to a single layer, and all objects on <a id="id263" class="indexterm"></a>this layer should be defined as immune to each other in terms of physical reactions. First, select the <code class="literal">Player</code> object in the scene. Then, from the <span class="strong"><strong>Object Inspector</strong></span>, click on the <span class="strong"><strong>Layer</strong></span> drop-down, and choose <span class="strong"><strong>Add Layer</strong></span> from the context menu. See <span class="emphasis"><em>Figure 4.15</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_04_15.jpg" /><div class="caption"><p>Figure 4.15: Creating a new layer for Physics exclusions</p></div></div><p>Name the layer <code class="literal">Player</code>. This is to indicate that all objects attached to the layer are associated with the <code class="literal">Player</code>. See <span class="emphasis"><em>Figure 4.16</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_04_16.jpg" /><div class="caption"><p>Figure 4.16: Creating layers</p></div></div><p>Now, assign both the <code class="literal">Player</code> object in the scene and <code class="literal">Ammo</code> prefab in the <span class="strong"><strong>Project</strong></span> panel to the newly created <span class="strong"><strong>Player</strong></span> layer. Select each, and simply click on the <span class="strong"><strong>Layer</strong></span> drop-down, selecting the <span class="strong"><strong>Player</strong></span> <a id="id264" class="indexterm"></a>option. See <span class="emphasis"><em>Figure 4.17</em></span>. If prompted with a pop-up dialog, choose to change children also. This makes sure that all child objects are also associated with the same <span class="strong"><strong>Layer</strong></span> as the parent.</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_04_17.jpg" /><div class="caption"><p>Figure 4.17: Assigning Player and Ammo to the Player layer</p></div></div><p>Both <span class="strong"><strong>Player</strong></span> and <span class="strong"><strong>Ammo</strong></span> have now been assigned to the same layer. From here, we can make all objects in the same layer immune from each other insofar as <span class="strong"><strong>Physics</strong></span> applies. To do this, navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Physics</strong></span> from the application menu. See <span class="emphasis"><em>Figure 4.18</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_04_18.jpg" /><div class="caption"><p>Figure 4.18: Accessing Physics options</p></div></div><p>The global <span class="strong"><strong>Physics</strong></span> settings appear in the <span class="strong"><strong>Object Inspector</strong></span>. At the bottom of the <span class="strong"><strong>Inspector</strong></span>, the <span class="strong"><strong>Layer </strong></span>
<a id="id265" class="indexterm"></a>
<span class="strong"><strong>Collision Matrix</strong></span> displays how layers affect each other. Intersecting layers with a check mark can and will affect each other. For this reason, remove the check mark for the <span class="strong"><strong>Player</strong></span> layer to prevent collisions occurring between objects on this layer. See <span class="emphasis"><em>Figure 4.19</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_04_19.jpg" /><div class="caption"><p>Figure 4.19: Setting the Layer Collision Matrix for improved collisions</p></div></div><p>With the <span class="strong"><strong>Layer Collision Matrix</strong></span> set from the <span class="strong"><strong>Object Inspector</strong></span>, test run the game so far by pressing play on the toolbar. When you do this and press fire, ammo will issue from the turrets and no longer react to the player spaceship. The ammo should, however, collide with, and <a id="id266" class="indexterm"></a>destroy, the enemies. See <span class="emphasis"><em>Figure 4.20</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_04_20.jpg" /><div class="caption"><p>Figure 4.20: Destroying enemies by shooting guns!</p></div></div><p>Excellent work! We now have a spaceship that can fire weapons and destroy enemies, and the physics works as expected. Maybe you'd like to customize player controls a little or perhaps you want to <a id="id267" class="indexterm"></a>use a gamepad. The next section will explore this issue further.</p></div></div>