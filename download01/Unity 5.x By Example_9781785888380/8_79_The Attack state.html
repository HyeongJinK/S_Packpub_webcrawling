<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec78"></a>The Attack state</h2></div></div><hr /></div><p>The third and final state <a id="id481" class="indexterm"></a>for the NPC is the Attack state, during which the NPC is continually attacking the player. This state can only be reached from the Chase state. During a chase, the NPC must determine whether they have reached within attacking distance. If so, the NPC must change from chasing to attacking. If, during an attack, the player leaves the attacking distance, then the NPC must change from attacking to chasing. Consider the following code sample, which includes the complete <code class="literal">EnemyAI</code> class, with all coded and completed states:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------------------
public class AI_Enemy : MonoBehaviour
{
  //------------------------------------------
  public enum ENEMY_STATE {PATROL, CHASE, ATTACK};
  //------------------------------------------
  public ENEMY_STATE CurrentState
  {
    get{return currentstate;}

    set
    {
      //Update current state
      currentstate = value;

      //Stop all running coroutines
      StopAllCoroutines();

      switch(currentstate)
      {
        case ENEMY_STATE.PATROL:
          StartCoroutine(AIPatrol());
        break;

        case ENEMY_STATE.CHASE:
          StartCoroutine(AIChase());
        break;

        case ENEMY_STATE.ATTACK:
          StartCoroutine(AIAttack());
        break;
      }
    }
  }
  //------------------------------------------
  [SerializeField]
  private ENEMY_STATE currentstate = ENEMY_STATE.PATROL;

  //Reference to line of sight component
  private LineSight ThisLineSight = null;

  //Reference to nav mesh agent
  private NavMeshAgent ThisAgent = null;

  //Reference to player health
  private Health PlayerHealth = null;

  //Reference to player transform
  private Transform PlayerTransform = null;

  //Reference to patrol destination
  private Transform PatrolDestination = null;

  //Damage amount per second
  public float MaxDamage = 10f;
  //------------------------------------------
  void Awake()
  {
    ThisLineSight = GetComponent&lt;LineSight&gt;();
    ThisAgent = GetComponent&lt;NavMeshAgent&gt;();
    PlayerHealth = GameObject.FindGameObjectWithTag("Player").GetComponent&lt;Health&gt;();
    PlayerTransform = PlayerHealth.GetComponent&lt;Transform&gt;();
  }
  //------------------------------------------
  void Start()
  {
    //Get random destination
    GameObject[] Destinations = GameObject.FindGameObjectsWithTag("Dest");
    PatrolDestination = Destinations[Random.Range(0, Destinations.Length)].GetComponent&lt;Transform&gt;();

    //Configure starting state
    CurrentState = ENEMY_STATE.PATROL;
  }
  //------------------------------------------
  public IEnumerator AIPatrol()
  {
    //Loop while patrolling
    while(currentstate == ENEMY_STATE.PATROL)
    {
      //Set strict search
      ThisLineSight.Sensitity = LineSight.SightSensitivity.STRICT;

      //Chase to patrol position
      ThisAgent.Resume();
      ThisAgent.SetDestination(PatrolDestination.position);

      //Wait until path is computed
      while(ThisAgent.pathPending)
        yield return null;

      //If we can see the target then start chasing
      if(ThisLineSight.CanSeeTarget)
      {
        ThisAgent.Stop();
        CurrentState = ENEMY_STATE.CHASE;
        yield break;
      }

      //Wait until next frame
      yield return null;
    }
  }
  //------------------------------------------
  public IEnumerator AIChase()
  {
    //Loop while chasing
    while(currentstate == ENEMY_STATE.CHASE)
    {
      //Set loose search
      ThisLineSight.Sensitity = LineSight.SightSensitivity.LOOSE;

      //Chase to last known position
      ThisAgent.Resume();
      ThisAgent.SetDestination(ThisLineSight.LastKnowSighting);

      //Wait until path is computed
      while(ThisAgent.pathPending)
        yield return null;

      //Have we reached destination?
      if(ThisAgent.remainingDistance &lt;= ThisAgent.stoppingDistance)
      {
        //Stop agent
        ThisAgent.Stop();

        //Reached destination but cannot see player
        if(!ThisLineSight.CanSeeTarget)
          CurrentState = ENEMY_STATE.PATROL;
        else //Reached destination and can see player. Reached attacking distance
          CurrentState = ENEMY_STATE.ATTACK;

        yield break;
      }

      //Wait until next frame
      yield return null;
    }
  }
  //------------------------------------------
  public IEnumerator AIAttack()
  {
    //Loop while chasing and attacking
    while(currentstate == ENEMY_STATE.ATTACK)
    {
      //Chase to player position
      ThisAgent.Resume();
      ThisAgent.SetDestination(PlayerTransform.position);

      //Wait until path is computed
      while(ThisAgent.pathPending)
        yield return null;

      //Has player run away?
      if(ThisAgent.remainingDistance &gt; ThisAgent.stoppingDistance)
      {
        //Change back to chase
        CurrentState = ENEMY_STATE.CHASE;
        yield break;
      }
      else
      {
        //Attack
        PlayerHealth.HealthPoints -= MaxDamage * Time.deltaTime;
      }

      //Wait until next frame
      yield return null;
    }

    yield break;
  }
  //------------------------------------------
}
//------------------------------------------</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec33"></a>Code Sample 8.5</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">AIAttack</code> <a id="id482" class="indexterm"></a>coroutine runs on a frame-safe infinite loop for as long as the Attack state is active (the enemy will be attacking during this state).</p></li><li style="list-style-type: disc"><p>The <code class="literal">MaxDamage</code> variable specifies how much damage the enemy deals to the player per second.</p></li><li style="list-style-type: disc"><p>The <code class="literal">AIAttack</code> coroutine relies on the <code class="literal">Health</code> component to inflict damage. This is an additional custom component that encodes health. Both the player and enemy should have a health component to represent their health.</p></li></ul></div><p>The Health script (<code class="literal">Health.cs</code>) is referenced by the <code class="literal">AIEnemy</code> class (the Attack State) to inflict damage on the player. For this reason, the player character needs a <code class="literal">Health</code> component attached. The code for this component is included in the following code sample:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Health : MonoBehaviour 
{
  public float HealthPoints
  {
    get{return healthPoints;}
    set
    {
      healthPoints = value;

      //If health is &lt; 0 then die
      if(healthPoints &lt;= 0)
        Destroy(gameObject);
    }
  }

  [SerializeField]
  private float healthPoints = 100f;
}</pre></div><p>The <code class="literal">Health</code> script is pretty simple. It maintains a numerical health value that, when reduced to <code class="literal">0</code> or below, will destroy the host game object. This should at least be attached to the player character, allowing the NPC to inflict damage on approach. It could, however, also be <a id="id483" class="indexterm"></a>attached to the NPC objects, allowing the player to reciprocate an attack. See <span class="emphasis"><em>Figure 8.9</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_09.jpg" /><div class="caption"><p>Figure 8.9: Configuring player health</p></div></div><p>Great, we're almost ready to test this project. First, make a prefab from the enemy object, if you've not already done so, by dragging and dropping the NPC game object from either the <span class="strong"><strong>Scene</strong></span> view or <span class="strong"><strong>Hierarchy</strong></span> panel to the <span class="strong"><strong>Project</strong></span> panel. Then, add as many enemies as you want to the level. See <span class="emphasis"><em>Figure 8.10</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_10.jpg" /><div class="caption"><p>Figure 8.10: Creating an NPC prefab</p></div></div><p>Now, test the level by pressing the play icon on the toolbar and you should have a complete environment in which intelligent enemies can seek, chase, and attack the player with a significant degree of believability. In some cases, you may need to tweak or refine the enemy FOV to better <a id="id484" class="indexterm"></a>match your surroundings and character type. Good work! See <span class="emphasis"><em>Figure 8.11</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_11.jpg" /><div class="caption"><p>Figure 8.11: The completed level</p></div></div></div></div>