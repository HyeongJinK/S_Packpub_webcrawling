<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec33"></a>Player input</h2></div></div><hr /></div><p>The <code class="literal">Player</code> object is <a id="id189" class="indexterm"></a>now created in the scene, configured with both <span class="strong"><strong>Rigidbody</strong></span> and <span class="strong"><strong>Collider</strong></span> components. However, this object doesn't respond to player controls. In a twin-stick shooter, the player provides input on two axes and can typically shoot a weapon. This often means that keyboard WASD buttons guide player movements up, down, left, and right. In addition, mouse movement controls the direction in which the player is looking and aiming and the left mouse button typically fires a weapon. This is the control scheme required for our game. To implement this, we'll need to create a <code class="literal">PlayerController</code> script file. Right-click on the <code class="literal">Scripts</code> folder of the <span class="strong"><strong>Project</strong></span> panel and create a new C# script file named <code class="literal">PlayerController.cs</code>. See <span class="emphasis"><em>Figure 3.16</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_03_16.png.jpg" /><div class="caption"><p>Figure 3.16: Creating a player controller C# script file</p></div></div><p>In the <code class="literal">PlayerController.cs</code> script file, the following code (as shown in <span class="emphasis"><em>Code Sample 3.1</em></span>) should be featured. Comments follow this sample:</p><div class="informalexample"><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class PlayerController : MonoBehaviour
{
  //------------------------------
  private Rigidbody ThisBody = null;
  private Transform ThisTransform = null;
  
  public bool MouseLook = true;
  <span class="strong"><strong>public string HorzAxis = "Horizontal";</strong></span>
  <span class="strong"><strong>public string VertAxis = "Vertical";</strong></span>
  <span class="strong"><strong>public string FireAxis = "Fire1";</strong></span>
  public float MaxSpeed = 5f;

  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    ThisBody = GetComponent&lt;Rigidbody&gt;();
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void FixedUpdate ()
  {
    //Update movement
    <span class="strong"><strong>float Horz = Input.GetAxis(HorzAxis);</strong></span>
    <span class="strong"><strong>float Vert = Input.GetAxis(VertAxis);</strong></span>
    Vector3 MoveDirection = new Vector3(Horz, 0.0f, Vert);
    <span class="strong"><strong>ThisBody.AddForce</strong></span>(MoveDirection.normalized * MaxSpeed);
    
    //Clamp speed
    ThisBody.velocity = new Vector3(Mathf.Clamp(ThisBody.velocity.x, -MaxSpeed, MaxSpeed),
      Mathf.Clamp(ThisBody.velocity.y, -MaxSpeed, MaxSpeed),
      Mathf.Clamp(ThisBody.velocity.z, -MaxSpeed, MaxSpeed));
    
    //Should look with mouse?
    <span class="strong"><strong>if(MouseLook)</strong></span>
    {
      //Update rotation - turn to face mouse pointer
      Vector3 MousePosWorld = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x,Input.mousePosition.y, 0.0f));
        MousePosWorld = new Vector3(MousePosWorld.x, 0.0f, MousePosWorld.z);
      //Get direction to cursor
      Vector3 LookDirection = MousePosWorld - ThisTransform.position;
      
      //FixedUpdate rotation
      <span class="strong"><strong>ThisTransform.localRotation</strong></span> = Quaternion.LookRotation(LookDirection.normalized,Vector3.up);
    }

  }
}
//------------------------------</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec11"></a>Code Sample 3.1</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">PlayerController</code> class should be attached to the <code class="literal">Player</code> object in the scene. Overall, it accepts input from the player and will control the movement of the spaceship.</p></li><li style="list-style-type: disc"><p>The <a id="id190" class="indexterm"></a>
<code class="literal">Awake</code> function is called once when the object is created at the level start. During this function, two components are retrieved, namely, the <span class="strong"><strong>Transform</strong></span> component for controller player rotation and the <span class="strong"><strong>Rigidbody</strong></span> component for controller player movement. The <span class="strong"><strong>Transform</strong></span> component can be used to control player movement through the <span class="strong"><strong>Position</strong></span> property, but this ignores collisions and solid objects. The <span class="strong"><strong>Rigidbody</strong></span> component, in contrast, prevents the player object from passing through other solids.</p></li><li style="list-style-type: disc"><p>The <code class="literal">FixedUpdate</code> function is called once on each update of the physics system, which is a fixed number of times per second. <code class="literal">FixedUpdate</code> differs from <code class="literal">Update</code>, which is called once per frame and can vary on a per second basis as the frame rate fluctuates. If you ever need to control an object through the physics system, using components such as <span class="strong"><strong>Rigidbody</strong></span>, then you should always do so in <code class="literal">FixedUpdate</code> and not <code class="literal">Update</code>. This is a Unity convention that you should remember for best results.</p></li><li style="list-style-type: disc"><p>The <code class="literal">Input.GetAxis</code> function is called on each <code class="literal">FixedUpdate</code> to read the axial input data from an input device, such as the keyboard or gamepad. This function reads from two named axes, <code class="literal">Horizontal</code> (left-right) and <code class="literal">Vertical</code> (up-down). These work in a normalized space of <span class="emphasis"><em>-1</em></span> to <span class="emphasis"><em>1</em></span>. This means that when the left key is pressed and held down, the <code class="literal">Horizontal</code> axis returns <span class="emphasis"><em>-1</em></span> and, when the right key is being pressed and held down, the <code class="literal">Horizontal</code> axis returns <span class="emphasis"><em>1</em></span>. A value of <span class="emphasis"><em>0</em></span> indicates that either no relevant key is being pressed or both left and right are being pressed together, canceling each other out. A similar principle applies for the <code class="literal">Vertical</code> axis. Up refers to <span class="emphasis"><em>1</em></span>, down to <span class="emphasis"><em>-1</em></span>, and no keypress relates to <span class="emphasis"><em>0</em></span>. More information on the <code class="literal">GetAxis</code> function can be found <a id="id191" class="indexterm"></a>online in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Input.GetAxis.html" target="_blank">http://docs.unity3d.com/ScriptReference/Input.GetAxis.html</a>.</p></li><li style="list-style-type: disc"><p>The <code class="literal">Rigidbody.AddForce</code> function is used to apply a physical force to the <code class="literal">Player</code> object, moving it in a specific direction. <code class="literal">AddForce</code> encodes a velocity, moving the object in a specific direction by a specific strength. The direction is encoded in the <code class="literal">MoveDirection</code> vector, which is based on player input from both the <code class="literal">Horizontal</code> and <code class="literal">Vertical</code> axes. This direction is multiplied by our maximum speed to ensure that the object travels as fast as needed. For more <a id="id192" class="indexterm"></a>information on <code class="literal">AddForce</code>, see the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html" target="_blank">http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html</a>.</p></li><li style="list-style-type: disc"><p>The <a id="id193" class="indexterm"></a>
<code class="literal">Camera.ScreenToWorldPoint</code> function is used to convert the screen position of the mouse cursor in the game window into a position in the game world, giving the player a target destination to look at. This code is responsible for making the player look at the mouse cursor always. However, as we'll see soon, some further tweaking is required to make this code work properly. For <a id="id194" class="indexterm"></a>more information on <code class="literal">ScreenToWorldPoint</code>, see the Unity online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html" target="_blank">http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html</a>.</p></li></ul></div></div></div>