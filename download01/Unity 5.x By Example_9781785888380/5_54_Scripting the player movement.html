<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec56"></a>Scripting the player movement</h2></div></div><hr /></div><p>The game so far <a id="id336" class="indexterm"></a>features an environment with collision data and a multipart player object that interacts and responds to this environment. The player, however, cannot yet be controlled, and this section explores controller functionality further. The user will have two main input mechanics, namely, movement (walking left and right) and jumping. This input can be read seamlessly and easily using <code class="literal">CrossPlatformInputManager</code>, which is a native Unity asset package. This package was imported at the project creation phase, but it can be imported now via the application menu with <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Import Package</strong></span> | <span class="strong"><strong>CrossPlatformInput</strong></span>. Once imported, open the <code class="literal">Standard Assets</code> | <code class="literal">CrossPlatformInput</code> | <code class="literal">Prefabs</code> folder and drag and drop the <span class="strong"><strong>MobileTiltControlRig</strong></span> prefab to the scene. This prefab lets you read input data across a range of devices, mapping directly to the horizontal and vertical axes that we've already seen in previous chapters. See <span class="emphasis"><em>Figure 5.43</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_05_43.jpg" /><div class="caption"><p>Figure 5.43: Cross-platform input prefabs offer easy multidevice control</p></div></div><p>Let's now script player controls. To do this, create a new C# script named <code class="literal">PlayerControl.cs</code> and attach it to the Player character. The full source code for this file is given in <a id="id337" class="indexterm"></a>the  <span class="emphasis"><em>Code Sample 5.1</em></span>:</p><div class="informalexample"><pre class="programlisting">//--------------------------------
using UnityEngine;
using System.Collections;
using UnityStandardAssets.CrossPlatformInput;
//--------------------------------
public class PlayerControl : MonoBehaviour
{
  //--------------------------------
  public enum FACEDIRECTION {FACELEFT = -1, FACERIGHT = 1};
  //Which direction is the player facing - left or right?
  public FACEDIRECTION Facing = FACEDIRECTION.FACERIGHT;
  //Which objects are tagged as ground
  public LayerMask GroundLayer;
  //Reference to rigidbody
  private Rigidbody2D ThisBody = null;
  //Reference to transform
  private Transform ThisTransform = null;
  //Reference to feet collider
  public CircleCollider2D FeetCollider = null;
  //Are we touching the ground?
  public bool isGrounded = false;
  //What are the main input axes
  public string HorzAxis = "Horizontal";
  public string JumpButton = "Jump";
  //Speed variables
  public float MaxSpeed = 50f;
  public float JumpPower = 600;
  public float JumpTimeOut = 1f;
  //Can we jump right now?
  private bool CanJump = true;
  //Can we control player?
  public bool CanControl = true;
  public static PlayerControl PlayerInstance = null;
  //--------------------------------
  public static float Health
  {
    get
    {
      return _Health;
    }

    set
    {
      _Health = value;

      //If we are dead, then end game
      if(_Health &lt;= 0)
      {
        Die();
      }
    }
  }

  [SerializeField]
  private static float _Health = 100f;
  //--------------------------------
  // Use this for initialization
  void Awake ()
  {
    //Get transform and rigid body
    ThisBody = GetComponent&lt;Rigidbody2D&gt;();
    ThisTransform = GetComponent&lt;Transform&gt;();

    //Set static instance
    PlayerInstance = this;
  }
  //--------------------------------
  //Returns bool - is player on ground?
  private bool GetGrounded()
  {
    //Check ground
    Vector2 CircleCenter = new Vector2(ThisTransform.position.x, ThisTransform.position.y) + FeetCollider.offset;
    Collider2D[] HitColliders = Physics2D.OverlapCircleAll(CircleCenter, FeetCollider.radius, GroundLayer);
    if(HitColliders.Length &gt; 0) return true;
    return false;
  }
  //--------------------------------
  //Flips character direction
  private void FlipDirection()
  {
    Facing = (FACEDIRECTION) ((int)Facing * -1f);
    Vector3 LocalScale = ThisTransform.localScale;
    LocalScale.x *= -1f;
    ThisTransform.localScale = LocalScale;
  }
  //--------------------------------
  //Engage jump
  private void Jump()
  {
    //If we are grounded, then jump
    if(!isGrounded || !CanJump)return;

    //Jump
    ThisBody.AddForce(Vector2.up * JumpPower);
    CanJump = false;
    Invoke ("ActivateJump", JumpTimeOut);
  }
  //--------------------------------
  //Activates can jump variable after jump timeout
  //Prevents double-jumps
  private void ActivateJump()
  {
    CanJump = true;
  }
  //--------------------------------
  // Update is called once per frame
  void FixedUpdate ()
  {
    //If we cannot control character, then exit
    if(!CanControl || Health &lt;= 0f)
    {
      return;
    }

    //Update grounded status
    isGrounded = GetGrounded();
    float Horz = CrossPlatformInputManager.GetAxis(HorzAxis);
    ThisBody.AddForce(Vector2.right * Horz * MaxSpeed);

    if(CrossPlatformInputManager.GetButton(JumpButton))
      Jump();

    //Clamp velocity
    ThisBody.velocity = new Vector2(Mathf.Clamp(ThisBody.velocity.x, -MaxSpeed, MaxSpeed), 
      Mathf.Clamp(ThisBody.velocity.y, -Mathf.Infinity, JumpPower));

    //Flip direction if required
    if((Horz &lt; 0f &amp;&amp; Facing != FACEDIRECTION.FACELEFT) || (Horz &gt; 0f &amp;&amp; Facing != FACEDIRECTION.FACERIGHT))
      FlipDirection();
  }
  //--------------------------------
  void OnDestroy()
  {
    PlayerInstance = null;
  }
  //--------------------------------
  //Function to kill player
  static void Die()
  {
    Destroy(PlayerControl.PlayerInstance.gameObject);
  }
  //--------------------------------
  //Resets player back to defaults
  public static void Reset()
  {
    Health = 100f;
  }
  //--------------------------------
}
//--------------------------------</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec23"></a>Code Sample 5.1</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <a id="id338" class="indexterm"></a>
<code class="literal">PlayerControl</code> class is responsible for handling all player input, making the character move left and right and jump.</p></li><li style="list-style-type: disc"><p>To achieve player movement, a reference to the RigidBody2D component is retained in the <code class="literal">ThisBody</code> variable, which is retrieved in the <code class="literal">Awake</code> function. The <a id="id339" class="indexterm"></a>movement and motion of the player is set using the <code class="literal">RigidBody2D.Velocity</code> variable. More information on this variable can be found online at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html" target="_blank">http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html</a>.</p></li><li style="list-style-type: disc"><p>The <code class="literal">FlipDirection</code> function is used to invert the horizontal scale of the sprite, turning it to face left or right as needed (reversing the image direction, for example, <code class="literal">1</code> and <code class="literal">-1</code>). From Unity 5.3 onward, the <code class="literal">Flip</code> property of the <code class="literal">SpriteRenderer</code> component can be used instead.</p></li><li style="list-style-type: disc"><p>The <code class="literal">FixedUpdate</code> function is used instead of Update to update the movement of the player character because we're working with <code class="literal">RigidBody2D</code>â€”a physics-based component. All physics functionality should be updated in <code class="literal">FixedUpdate</code> that is invoked at a fixed interval each second as opposed to every <a id="id340" class="indexterm"></a>frame. More information can be found at the Unity online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html</a>.</p></li><li style="list-style-type: disc"><p>The <code class="literal">GetGrounded</code> function detects where any <code class="literal">CircleCollider</code> intersects and overlaps with any other collider in the scene on a specific layer. In short, this function indicates whether the player character is touching the ground at the position of the feet. If so, the player is able to jump; otherwise, the player cannot jump as they are already airborne. Double-jumping is not allowed in this game!</p></li></ul></div><p>For the preceding code to work correctly, a few tweaks must be made to both the scene and player character. Specifically, the <code class="literal">GetGrounded</code> function requires that the floor area of the level is grouped together on a single layer. This simply means that the level foreground should be on a distinctive layer from other objects. To achieve this, create a new layer named <code class="literal">Ground</code>, and then assign the foreground object to this layer. To create a new layer, select the foreground object and, from the <span class="strong"><strong>Object Inspector</strong></span>, click on the drop-down named <a id="id341" class="indexterm"></a>
<span class="strong"><strong>Layer</strong></span>. Then, select Add Layer from the context menu. See <span class="emphasis"><em>Figure 5.44</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_05_44.jpg" /><div class="caption"><p>Figure 5.44: Adding a new layer</p></div></div><p>Then, add <a id="id342" class="indexterm"></a>a new layer named <code class="literal">Ground</code> simply by entering <code class="literal">Ground</code> in an available type-in field. See <span class="emphasis"><em>Figure 5.45</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_05_45.jpg" /><div class="caption"><p>Figure 5.45: Creating a new ground layer</p></div></div><p>Now, assign the foreground object to the <code class="literal">Ground</code> layer. Simply select the foreground object, and then select the <span class="strong"><strong>Ground</strong></span> layer from the <span class="strong"><strong>Layer</strong></span> drop-down in the <span class="strong"><strong>Object Inspector</strong></span>. After the foreground object is assigned to the ground layer, the <code class="literal">PlayerControl</code> script requires us to indicate which layer has been designated for the ground. To achieve this, select the <span class="strong"><strong>Player</strong></span> object and, from the <span class="strong"><strong>Object Inspector</strong></span>, select the <span class="strong"><strong>Ground</strong></span> layer for the <span class="strong"><strong>Ground Layer</strong></span> field. See <span class="emphasis"><em>Figure 5.46</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_05_46.jpg" /><div class="caption"><p>Figure 5.46: Selecting the Ground layer for collision detection</p></div></div><p>In addition, the <span class="strong"><strong>Feet Collider</strong></span> slot needs assignment too in order to indicate which collider object should be used for ground collision detection. For this field, you need to drag and <a id="id343" class="indexterm"></a>drop the <span class="strong"><strong>CircleCollider</strong></span> component to the <span class="strong"><strong>Feet Collider</strong></span> slot. See <span class="emphasis"><em>Figure 5.47</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_05_47.jpg" /><div class="caption"><p>Figure 5.47: The Feet Collider detects when the character is in contact with the ground</p></div></div><p>Now, give the player character a test run. Simply click on the play icon on the toolbar and test out the controls of the player character. <span class="emphasis"><em>W</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>S</em></span>, <span class="emphasis"><em>D</em></span> (or the arrow keys) will move the player character around. The spacebar makes the character jump. See <span class="emphasis"><em>Figure 5.48</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_05_48.jpg" /><div class="caption"><p>Figure 5.48: Play testing with the player character</p></div></div></div></div>