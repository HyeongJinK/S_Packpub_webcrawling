<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec75"></a>An overview of Finite State Machines</h2></div></div><hr /></div><p>To create the <a id="id469" class="indexterm"></a>AI for an NPC object, in addition to the line of sight code that we already have, we need to use <span class="strong"><strong>Finite State Machines</strong></span> (<span class="strong"><strong>FSMs</strong></span>). An FSM is not a <span class="emphasis"><em>thing</em></span> or feature of Unity, nor is it a tangible aspect of the C# language. Rather, an FSM is a concept, framework, or idea that we can apply in code to achieve specific AI behaviors. It comes from a specific way of thinking about intelligent characters. Specifically, we can summarize the NPC for our level as existing within one of three possible states at any one time. These are patrol (when the enemy is wandering around), chase (when the enemy is running after the player), and attack (when the enemy has reached the player and is attacking). Each of these modes is a State and requires a unique and specific behavior and the enemy can be in only one of these three states at any one time. The enemy cannot, for example, be patrolling and chasing simultaneously or patrolling and attacking, because this wouldn't make sense within the logic of the world and game.</p><p>In addition to the states themselves, there is a rule set or group of connections between the states that determines when one state should change or move into another. For example, an NPC should only move from patrolling to chasing if they can see the player and they are not already attacking. Similarly, the NPC should only move from attacking to patrolling if they cannot see the player and they are not already patrolling or chasing. Thus, the combination of the States and rules governing their connections form a Finite State Machine. Consequently, any implementation in code that represents this behavior functionally is an FSM. There is no right or wrong way to code an FSM per se. There are simply different ways, some of which are better or worse for particular ends.</p><p>In this section, we'll code the FSM using Coroutines. Let's start by creating the main structure. Refer <a id="id470" class="indexterm"></a>to the following code in the file, <code class="literal">AI_Enemy.cs</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------------------
public class AI_Enemy : MonoBehaviour
{
  //------------------------------------------
  public enum ENEMY_STATE {PATROL, CHASE, ATTACK};
  //------------------------------------------
  public ENEMY_STATE CurrentState
  {
    get{return currentstate;}

    set
    {
      //Update current state
      currentstate = value;

      //Stop all running coroutines
      StopAllCoroutines();

      switch(currentstate)
      {
        case ENEMY_STATE.PATROL:
          StartCoroutine(AIPatrol());
        break;

        case ENEMY_STATE.CHASE:
          StartCoroutine(AIChase());
        break;

        case ENEMY_STATE.ATTACK:
          StartCoroutine(AIAttack());
        break;
      }
    }
  }
  //------------------------------------------
  [SerializeField]
  private ENEMY_STATE currentstate = ENEMY_STATE.PATROL;

  //Reference to line of sight component
  private LineSight ThisLineSight = null;

  //Reference to nav mesh agent
  private NavMeshAgent ThisAgent = null;

  //Reference to player transform
  private Transform PlayerTransform = null;

  //------------------------------------------
  void Awake()
  {
    ThisLineSight = GetComponent&lt;LineSight&gt;();
    ThisAgent = GetComponent&lt;NavMeshAgent&gt;();
    PlayerTransform = GameObject.FindGameObjectWithTag("Player").GetComponent&lt;Transform&gt;();
  }
  //------------------------------------------
  void Start()
  {

    //Configure starting state
    CurrentState = ENEMY_STATE.PATROL;
  }
  //------------------------------------------
  public IEnumerator AIPatrol()
  {
      yield break;

  }
  //------------------------------------------
  public IEnumerator AIChase()
  {

      yield break;
  }
  //------------------------------------------
  public IEnumerator AIAttack()
  {
    yield break;
  }
  //------------------------------------------
}
//------------------------------------------</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"></a>Note</h3><p>More <a id="id471" class="indexterm"></a>information on Coroutines can be found at the <a id="id472" class="indexterm"></a>online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html" target="_blank">http://docs.unity3d.com/Manual/Coroutines.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec30"></a>Code Sample 8.2</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">AI_Enemy</code> <a id="id473" class="indexterm"></a>class created so far does not represent the full and complete FSM but just the skeleton for its beginning. It illustrates the general structure. It features a single coroutine for each state.</p></li><li style="list-style-type: disc"><p>The <code class="literal">CurrentState</code> variable defines a property that selects the active state, terminating all existing coroutines and initiating the relevant one.</p></li><li style="list-style-type: disc"><p>Each state coroutine will run on a frame-safe infinite loop for as long as the state is active, allowing the enemy object to update its behavior, as we'll see shortly.</p></li></ul></div><p>Before proceeding, make sure that the <code class="literal">AI_Enemy</code> script is attached to the NPC object. See <span class="emphasis"><em>Figure 8.6</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/B05118_08_06.jpg" /><div class="caption"><p>Figure 8.6: Attaching the AI script to the NPC character</p></div></div></div></div>