<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec25"></a>Timers and countdowns</h2></div></div><hr /></div><p>You should <a id="id139" class="indexterm"></a>now have a level complete with geometry and coin objects. Thanks to our newly added <code class="literal">Coin.cs</code> script, the coins are both countable and collectible. Even so, the level still poses little or no challenge to the player because there's no way the level can be won or lost. Specifically, there's nothing for the player to achieve. This is why a time limit is important for the game: it defines a win and loss condition. Namely, collecting all coins before the timer expires results in a win condition and failing to achieve this results in a loss condition. Let's get started at creating a timer countdown for the level. To do this, create a new and empty game object by selecting <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> and rename this to <code class="literal">LevelTimer</code>. See <span class="emphasis"><em>Figure 2.25</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_02_25.jpg" /><div class="caption"><p>Figure 2.25: Renaming the timer object</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>Remember <a id="id140" class="indexterm"></a>that empty game objects cannot be seen by the player because they have no mesh renderer component. They are especially useful to create functionality and behaviors that don't correspond directly to physical and visible entities, such as timers, managers, and game logic controllers.</p></div><p>Next, create a new script file named <code class="literal">Timer.cs</code> and add it to the <code class="literal">LevelTimer</code> object in <span class="strong"><strong>Scene</strong></span>. By doing this, the timer functionality will exist in the scene. Make sure, however, that the timer script is added to one object, and no more than one. Otherwise, there will effectively be multiple, competing timers in the same scene. You can always search a scene to find all components of a specified type by using the <span class="strong"><strong>Hierarchy</strong></span> panel. To do this, click in the <span class="strong"><strong>Hierarchy</strong></span> search box and type <code class="literal">t:Timer</code>. Then press <span class="emphasis"><em>Enter</em></span> on the keyboard to confirm the search. This searches the scene for all objects with a component attached of the timer type, and the results are displayed in the <span class="strong"><strong>Hierarchy</strong></span> panel. Specifically, the <span class="strong"><strong>Hierarchy</strong></span> <a id="id141" class="indexterm"></a>panel is filtered to show only the matching objects. The <code class="literal">t</code> prefix in the search string indicates a search by type operation. See <span class="emphasis"><em>Figure 2.26</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_02_26.jpg" /><div class="caption"><p>Figure 2.26: Searching for objects with a component of matching type</p></div></div><p>You can easily cancel a search and return the <span class="strong"><strong>Hierarchy</strong></span> panel back to its original state by clicking on the small cross icon aligned to the right-hand side of the search field. This button can be tricky to <a id="id142" class="indexterm"></a>spot. See <span class="emphasis"><em>Figure 2.27</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_02_27.jpg" /><div class="caption"><p>Figure 2.27: Canceling a type search</p></div></div><p>The timer script itself must be coded if it's to be useful. The full source code for the <code class="literal">Timer.cs</code> file is given in the following <span class="emphasis"><em>Code Sample 2.6</em></span>. This source code is highly important if you've never scripted in Unity before. It demonstrates so many critical features. See the comments for a fuller explanation.</p><div class="informalexample"><pre class="programlisting">//-------------------------
using UnityEngine;
using System.Collections;
//-------------------------
public class Timer : MonoBehaviour
{
  //-------------------------
  //Maximum time to complete level (in seconds)
  public float MaxTime = 60f;
  //-------------------------
  //Countdown
  <span class="strong"><strong>[SerializeField]</strong></span>
  private float CountDown = 0;
  //-------------------------
  // Use this for initialization
  void Start () 
  {
    CountDown = MaxTime;
  }
  //-------------------------
  // Update is called once per frame
  <span class="strong"><strong>void Update () </strong></span>
  {
    //Reduce time
    CountDown -= <span class="strong"><strong>Time.deltaTime;</strong></span>

    //Restart level if time runs out
    if(CountDown &lt;= 0)
    {
      //Reset coin count
      Coin.CoinCount=0;
      <span class="strong"><strong>Application.LoadLevel(Application.loadedLevel);</strong></span>
    }
  }
  //-------------------------
}
//-------------------------</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec09"></a>Code Sample 2.6</h3></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In Unity, class <a id="id143" class="indexterm"></a>variables declared as <code class="literal">public</code> (such as <code class="literal">public float MaxTime</code>) are displayed as editable fields in the <span class="strong"><strong>Object Inspector</strong></span> of the editor. However, this applies to a range of supported data types only, but it's a highly useful feature. It means that developers can monitor and set <code class="literal">public</code> variables for classes directly from the <span class="strong"><strong>Inspector</strong></span> as opposed to changing and recompiling code every time a change is needed. The <code class="literal">private</code> variables, in contrast, are hidden from the <span class="strong"><strong>Inspector</strong></span> by default. However, you can force them to be visible, if needed, using the <code class="literal">SerializeField</code> attribute. The <code class="literal">private</code> variables prefixed with this attribute, such as the <code class="literal">CountDown</code> variable, will be displayed in the <span class="strong"><strong>Object Inspector</strong></span> just like a <code class="literal">public</code> variable, even though the variable's scope still remains <code class="literal">private</code>.</p></li><li style="list-style-type: disc"><p>The <code class="literal">Update</code> function is a Unity native event supported for all classes derived from <code class="literal">MonoBehaviour</code>. <code class="literal">Update</code> is invoked automatically once per frame for all active <code class="literal">GameObjects</code> in the scene. This means that all active game objects are notified about frame change events. In short, <code class="literal">Update</code> is therefore called many times per <a id="id144" class="indexterm"></a>second; the game FPS is a general indicator as to how many times each second. The actual number of calls will vary in practice from second to second. In any case, <code class="literal">Update</code> is especially useful to animate, update, and change objects over time. In the case of a <code class="literal">CountDown</code> class, it'll be useful to keep track of time as it passes, second by <a id="id145" class="indexterm"></a>second. More information on the <code class="literal">Update</code> function can be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p>In addition to the <code class="literal">Update</code> function called on each frame, Unity also supports two other related functions, namely, <code class="literal">FixedUpdate</code> and <code class="literal">LateUpdate</code>. <code class="literal">FixedUpdate</code> is used when coding with <span class="strong"><strong>Physics</strong></span>, as we'll see later, and is called a fixed number of times per frame. <code class="literal">LateUpdate</code> is called once per frame for each active object, but the <code class="literal">LateUpdate</code> call will always happen after every object has received an <code class="literal">Update</code> event. Thus, it happens after the <code class="literal">Update</code> cycle, making it a late update. There are reasons for this late update and we'll see them later in the book.</p><p>More information on <code class="literal">FixedUpdate</code> <a id="id146" class="indexterm"></a>can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html</a>. More information on the <code class="literal">LateUpdate</code> function can be found in <a id="id147" class="indexterm"></a>the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html</a>.</p></div></li><li style="list-style-type: disc"><p>When scripting, the static <code class="literal">Time.deltaTime</code> variable is constantly available and updated automatically by Unity. It always describes the amount of time (in seconds) that has passed since the previous frame ended. For example, if your game has a frame rate of 2 FPS (a very low frame rate!) then <code class="literal">deltaTime</code> will be <code class="literal">0.5</code>. This is because, in each second, there would be two frames, and thus each frame would be half a second. The <code class="literal">deltaTime</code> is useful because, if added over time, it tells you how much time in total has elapsed or passed since the game began. For this reason, <code class="literal">deltaTime</code> floating point variable is used heavily in the <code class="literal">Update</code> function for the timer to subtract the elapsed time from the countdown <a id="id148" class="indexterm"></a>total. More information can be found on <code class="literal">deltaTime</code> at the online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Time-deltaTime.html" target="_blank">http://docs.unity3d.com/ScriptReference/Time-deltaTime.html</a>.</p></li><li style="list-style-type: disc"><p>The static <code class="literal">Application.LoadLevel</code> function can be called anywhere in code to change the active scene at runtime. Thus, this function is useful to move the gamer from one level to another. It causes Unity to terminate the active scene, destroying all its contents, and load a new scene. It can also be used to restart the active scene, simply by loading the active level again. <code class="literal">Application.LoadLevel</code> is most appropriate for games with clearly defined levels that are separate from each other and have clearly defined beginnings and <a id="id149" class="indexterm"></a>endings. It is not, however, suitable for large open-world games in which large sprawling environments stretch on, seemingly without any breakage or disconnection. More information <a id="id150" class="indexterm"></a>on <code class="literal">Application.LoadLevel</code> can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html" target="_blank">http://docs.unity3d.com/ScriptReference/Application.LoadLevel.html</a>.</p></li></ul></div><p>After the timer script is created, select the <code class="literal">LevelTimer</code> object in the scene. From the <span class="strong"><strong>Object Inspector</strong></span>, you can set the maximum time (in seconds) that the player is allowed in order to complete the level. See <span class="emphasis"><em>Figure 2.28</em></span>. I've set the total time to <code class="literal">60</code> seconds. This means that all coins must be completed within <code class="literal">60</code> seconds from the level start. If the timer expires, the level is restarted.</p><div class="mediaobject"><img src="/graphics/9781785888380/graphics/figure_02_28.jpg" /><div class="caption"><p>Figure 2.28: Setting the level total time</p></div></div><p>Great work! You should now have a completed level with a countdown that works. You can collect coins <a id="id151" class="indexterm"></a>and the timer can expire. Overall, the game is taking shape. There is a further problem, however, which we'll address next.</p></div></div>