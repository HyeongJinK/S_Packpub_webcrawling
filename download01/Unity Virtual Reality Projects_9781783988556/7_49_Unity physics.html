<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec49"></a>Unity physics</h2></div></div><hr /></div><p>In Unity, the <a id="id399" class="indexterm"></a>behavior of an object that is based on physics is defined separately from its mesh (shape), materials (UV texture), and the renderer properties. The items that play into physics include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>The Rigidbody component</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>The Collider component</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>The Physic Material</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>The project Physics Manager</strong></span>
</p></li></ul></div><p>Basically, physics (in this context) is <a id="id400" class="indexterm"></a>defined by the positional and rotational forces that affect the transform of an object, such as gravity, friction, momentum, and collisions with other objects. It is not necessarily a perfect simulation of physics in the real world because it's optimized for performance and separation of concerns to facilitate animation. Besides, virtual worlds might just need their own laws of physics that aren't found in our God-given universe!</p><p>Unity 5 integrates the <a id="id401" class="indexterm"></a>
<span class="strong"><strong>NVIDIA PhysX</strong></span> engine, a real-time physics calculation middleware, which implements classical Newtonian mechanics for games and 3D applications. This multiplatform software is optimized to utilize fast hardware processors when present. It is accessible via the Unity scripting API.</p><p>A key to physics is the Rigidbody component that you add to objects. Rigidbodies have parameters for gravity, mass, and drag, among others. Rigidbodies can automatically react to gravity and collisions with other objects. No extra scripting is needed for this. During gameplay, the engine calculates each rigid object's momentum and updates its transform position and rotation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>Details on <a id="id402" class="indexterm"></a>Rigidbodies can be found at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rigidbody.html" target="_blank">http://docs.unity3d.com/ScriptReference/Rigidbody.html</a>.</p></div><p>Unity projects have a global gravity setting, found in the project's <a id="id403" class="indexterm"></a>Physics Manager by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Physics</strong></span>. As you might expect, the default gravity setting is a <span class="strong"><strong>Vector3</strong></span> with values (<code class="literal">0</code>, <code class="literal">-9.81</code>, <code class="literal">0</code>) that apply a downward force to all Rigidbodies. Gravity is in meters per second squared.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip21"></a>Note</h3><p>Rigidbodies can automatically react to gravity and collisions with other objects. Extra scripting is not needed for this.</p></div><p>In order to detect a collision, both the colliding objects must have a <a id="id404" class="indexterm"></a>Collider component. There are built-in colliders with basic geometric shapes such as a cube, sphere, cylinder, and a capsule. A mesh collider can assume an arbitrary shape. If you can, it's best to use one or more basic collider shapes that approximately fit the actual object rather than a mesh collider to reduce the expense of calculating the actual collisions during gameplay. (If you do, a mesh collider must be marked as convex and be limited to 255 triangles.)</p><p>When rigid objects collide, the forces pertinent to each object in the collision are applied to the others. The values of the resulting forces are calculated based on the objects' current velocity and body mass. Other factors are also taken into consideration, such as gravity and drag (that is, resistance). Furthermore, you have options to add constraints to freeze the position or rotation of a given object in any of its <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> axes.</p><p>The calculations can be further affected when a <a id="id405" class="indexterm"></a>Physic Material is assigned to the object's Collider, which adjusts the friction and the bounciness effects of the colliding objects. These properties will be applied only to the object that owns the Physic Material. (Note that it's really spelled <span class="emphasis"><em>Physic Material</em></span> rather than <span class="emphasis"><em>Physics Material</em></span> for historical reasons.)</p><p>So, let's say that Object A (Ball) hits Object B (Brick). If Object A has bounciness and Object B does not, Object A will have an impulse applied in the collision, but Object B will not. However, you have options to determine how their friction and bounciness combine, as we'll see next. It's not necessarily an accurate simulation of real-world physics. It's a game engine, not a computer-aided engineering modeler.</p><p>From a scripting point of view, Unity will trigger events (also known as <span class="emphasis"><em>messages</em></span>) when objects collide (<code class="literal">OnTriggerEnter</code>), each frame while objects are collided (<code class="literal">OnTriggerStay</code>), and when they've stopped colliding (<code class="literal">OnTriggerExit</code>).</p><p>If this sounds daunting, read on. The rest of this chapter breaks it down into understandable bits and pieces.</p></div>