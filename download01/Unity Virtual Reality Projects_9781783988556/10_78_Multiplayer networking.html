<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec75"></a>Multiplayer networking</h2></div></div><hr /></div><p>Before we begin implementation, let's take a look at what multiplayer networking is all about and define some terms.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec97"></a>Networking services</h3></div></div></div><p>Consider <a id="id553" class="indexterm"></a>a situation where you are running a VR application that is connected to a server, and several of your friends are running the same application on their own VR rigs at the same time. When you move your first-person view within the game, shoot things, or otherwise interact with the virtual environment, you expect the other players to see that, too. Their version of the game stays in sync with yours and vice versa. How does this work?</p><p>Your game creates a connection to a server. Other players are simultaneously connected to the same service. When you move, your character's new position is broadcast to each of the other connections, which then updates your avatar's position in their own views. Similarly, when your game receives the changed position of another character, it is updated in your view. The faster, the better. That is, the less delay (latency) between the <span class="emphasis"><em>send</em></span> and <span class="emphasis"><em>receive</em></span> messages and the corresponding screen updates, the more live, or real time, the interaction feels.</p><p>Multiplayer services should help you manage the sharing of the game's state between all active clients, the spawning of new players and objects, security considerations, as well as the management of low-level network connections, protocols, and the quality of service (such as data rate and performance).</p><p>Networking is built as a series of layers, where the low-level layers deal with details of the data transport and are agnostic to the content of the data. Middle and higher layers provide increasingly aggregated features that also may be more directly helpful for the networking application—in our case, multiplayer gaming and social VR. Ideally, the high-level layer will provide all you need to implement multiplayer features into your games with minimal custom scripting, while offering access to other layers through a clean API in case you have special requirements.</p><p>There are a number <a id="id554" class="indexterm"></a>of multiplayer services available, including Photon from Exit Games, and other services from Google, Apple, Microsoft, Amazon, and more.</p><p>The popular Photon Cloud service can be easily added using <a id="id555" class="indexterm"></a>their free <span class="strong"><strong>Photon Unity Networking</strong></span> (<span class="strong"><strong>PUN</strong></span>) package from the <a id="id556" class="indexterm"></a>Unity Asset Store (for more information, visit <a class="ulink" href="https://www.assetstore.unity3d.com/#/content/1786" target="_blank">https://www.assetstore.unity3d.com/#/content/1786</a>). If you are interested in trying<a id="id557" class="indexterm"></a> Photon with VR, take a look at <a class="ulink" href="http://www.convrge.co/multiplayer-oculus-rift-games-in-unity-tutorial" target="_blank">http://www.convrge.co/multiplayer-oculus-rift-games-in-unity-tutorial</a>, a blog post from Convrge.</p><p>Unity 5 has its own built-in Unity networking system, which was recently rewritten from scratch and greatly improved from what it was in Unity 4. Unity networking reduces the need for custom scripting and provides a feature-rich set of components and API that tightly integrate with Unity.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec98"></a>The network architecture</h3></div></div></div><p>The <a id="id558" class="indexterm"></a>key to networking is the client-server system architecture. We see this all around us in today's world—your web browser is a client and websites are hosted on a server. Your favorite music listening app is a client, and its streaming service is a server. Similarly, each instance of your game, when connected to a network, is a client. It talks to a server, which communicates the status and control information between all the other game clients.</p><p>I say <span class="emphasis"><em>server</em></span>, but it doesn't necessarily need to be a separate physical computer somewhere. It could be, but it's probably not. It's best to think of a client and server as <span class="emphasis"><em>processes</em></span>—instances of a program or an application running somewhere. A <a id="id559" class="indexterm"></a>
<span class="strong"><strong>cloud server</strong></span> is a virtual process that is accessible via the Internet as a service.</p><p>A single app can sometimes act as both a client and a server at the same time. This latter case, where the server and client are one, is said to be running as a host. With Unity networking, games can be run as a client, a server, and/or as a host.</p><p>Even so, a public <span class="strong"><strong>IP</strong></span> (<span class="strong"><strong>Internet Protocol</strong></span>) address<a id="id560" class="indexterm"></a> is needed for game instances to talk to one another. A lightweight relay server can provide this service with minimal resources.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec99"></a>Local versus server</h3></div></div></div><p>In Unity, you <a id="id561" class="indexterm"></a>can use scripting to create, or instantiate, new objects during gameplay. In a multiplayer situation, these objects need to be activated, or spawned, locally as well as on the network so that all the clients will know about it. A <span class="emphasis"><em>spawning system</em></span>
<a id="id562" class="indexterm"></a> manages objects across all the clients.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note29"></a>Note</h3><p>It is important to make a distinction between objects that are <span class="emphasis"><em>local player objects</em></span> versus the network ones. Local player objects are owned by you on your client.</p></div><p>For example, in a first-person experience, your player's avatar will be spawned with a Camera component, whereas the other players' avatars will not. It is also an important security consideration to prevent users from hacking a game and changing other player's characters.</p><p>Local player objects have <a id="id563" class="indexterm"></a>
<span class="emphasis"><em>local authority</em></span>, that is, the player object is responsible for controlling itself, such as its own movement. Otherwise, when the creation, movement, and destruction of objects are not controlled by a player, the authority should reside on the server.</p><p>On the other hand, <span class="emphasis"><em>server authority</em></span> is <a id="id564" class="indexterm"></a>needed. For example, when a game creates enemies at random locations, you'd want all the clients to get the same random locations. When a new player joins an ongoing game, the server helps create and set up objects that are active in the current gameplay. You wouldn't want an object to show up in its default position and then jump to a different current position as it's syncing with the other clients.</p><p>The following image from Unity documentation shows ways in which actions are performed across the network. The server makes <a id="id565" class="indexterm"></a>
<span class="strong"><strong>remote procedure calls</strong></span> (<span class="strong"><strong>RPC</strong></span>) to the client to spawn or update objects. </p><p>The client sends commands to the server to affect actions, which then are communicated to all the remote clients:</p><div class="mediaobject"><img src="/graphics/9781783988556/graphics/B04781_10_02.jpg" /></div><p>Real-time <a id="id566" class="indexterm"></a>networking is a deep engineering discipline. Layered network architectures aim to simplify and shield you from brutally arcane details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Note</h3><p>It all comes down to performance, security, and reliability. If you need to debug or optimize any of these in your multiplayer game, you may need to dig in your heels and work to gain a better understanding of what's going on under the hood.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec100"></a>The Unity networking system</h3></div></div></div><p>The <a id="id567" class="indexterm"></a>Unity networking engine includes a<a id="id568" class="indexterm"></a> robust set of high-level components (scripts) that make it easy to add multiplayer capabilities to your games. Some of the more important components include <span class="emphasis"><em>Network Identity</em></span>, <span class="emphasis"><em>Network Behavior</em></span>, <span class="emphasis"><em>Network Transform</em></span>, and <span class="emphasis"><em>Network Manager</em></span>.</p><p>The <span class="emphasis"><em>Network Identity</em></span> component<a id="id569" class="indexterm"></a> is required on each game object prefab that may be spawned (created) on clients. Internally, it provides a unique asset ID and other parameters so that objects can be unambiguously identified and spawned across the network.</p><p>The <span class="emphasis"><em>Network Behavior</em></span> class<a id="id570" class="indexterm"></a> is derived from <code class="literal">MonoBehavior</code> and provides network functionality to scripts. Details of the same are documented <a id="id571" class="indexterm"></a>at <a class="ulink" href="http://docs.unity3d.com/Manual/class-NetworkBehaviour.html" target="_blank">http://docs.unity3d.com/Manual/class-NetworkBehaviour.html</a>.</p><p>When you want<a id="id572" class="indexterm"></a> to synchronize the movement<a id="id573" class="indexterm"></a> and physics of objects, add a <span class="emphasis"><em>Network Transform</em></span> component. It's like a shortcut for the more general <code class="literal">SyncVar</code> variable synchronization with additional intelligent interpolation for smoother movement between updates.</p><p>The <a id="id574" class="indexterm"></a>
<span class="emphasis"><em>Network Manager</em></span> component is the glue that puts it all together. It handles the managing of connections, the spawning of objects across the network, and configuration.</p><p>When new player objects are spawned, you can specify a spawn position in the <span class="emphasis"><em>Network Manager</em></span> component. Alternatively, you can add game objects to your scene and give them a <a id="id575" class="indexterm"></a>
<span class="emphasis"><em>Network Start Position</em></span> component, which can be used by the spawning system.</p><p>Nonplayer objects that can get spawned can also be set in the <span class="emphasis"><em>Network Manager</em></span> spawn list. Additionally, the <span class="emphasis"><em>Network Manager</em></span> component handles scene changes and provides debugging information.</p><p>Related to the <span class="emphasis"><em>Network Manager</em></span> component is the matchmaking functionality, which can be configured to match up players, making them come together and start a game at the same time—a multiplayer <span class="emphasis"><em>lobby manager</em></span>, <a id="id576" class="indexterm"></a>where players can set themselves as ready for the game to start, is among the other useful features.</p></div></div>