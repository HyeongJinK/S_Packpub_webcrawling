<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec43"></a>Making a first person</h2></div></div><hr /></div><p>For making<a id="id327" class="indexterm"></a> a first person feature, let's take an <span class="emphasis"><em>agile</em></span> approach to development. This means (in part) that we'll start by defining our new feature, or story, with a set of requirements. Then, we'll incrementally build and test this feature, one requirement at a time, by iterating and refining our work as we go along. Experimentation is not only allowed, it's encouraged.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"></a>Note</h3><p>
<span class="strong"><strong>Agile software development</strong></span> is a broad term for methodologies that encourage small incremental and iterative developments in a fashion that's easy to respond to the changing and refined requirements.</p></div><p>
<span class="strong"><strong>Feature</strong></span>: <span class="emphasis"><em>As a first-person character, when I start walking, I will move through the scene in the direction I am looking until I indicate to stop walking.</em></span>
</p><p>Here are the requirements to achieve this feature:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Move in the direction you're looking</p></li><li style="list-style-type: disc"><p>Keep your feet on the ground</p></li><li style="list-style-type: disc"><p>Don't pass through solid objects</p></li><li style="list-style-type: disc"><p>Don't fall off the edge of the world</p></li><li style="list-style-type: disc"><p>Step over small objects and handle uneven terrain</p></li><li style="list-style-type: disc"><p>Start and stop moving with a head gesture (look down) or by clicking an input device</p></li></ul></div><p>This sounds reasonable.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec65"></a>Move in the direction you're looking</h3></div></div></div><p>We <a id="id328" class="indexterm"></a>already have a <code class="literal">MeMyselfEye</code> object containing the camera rig. We're going to turn it into a first-person controller. Our first requirement is to move about the scene in the direction you're looking. Add a script named <code class="literal">HeadLookWalk</code>. Keeping it simple, let's start by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select the <code class="literal">MeMyselfEye</code> object in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, select <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>New Script</strong></span> and name it <code class="literal">HeadLookWalk</code>.</p></li></ol></div><p>Then, open the script and code it, as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class HeadLookWalk : MonoBehaviour {
  public float velocity = 0.7f;

  void Update () {
    Vector3 moveDirection = Camera.main.transform.forward;
    moveDirection *= velocity * Time.deltaTime;
    transform.position += moveDirection;
  }
}</pre></div><p>The normal<a id="id329" class="indexterm"></a> walking speed for humans is about 1.4 meters per second. Let's be cool and travel half that velocity at 0.7 m/s. During <code class="literal">Update()</code>, we check the current direction in which the camera is facing (<code class="literal">camera.transform.forward</code>) and move the <code class="literal">MeMyselfEye</code> transform position in this direction at the current velocity.</p><p>Note the coding shortcuts for the self-modification of a variable. The last two lines of the preceding code could have been written out like this:</p><div class="informalexample"><pre class="programlisting">moveDirection = moveDirection * velocity * Time.deltaTime;
transform.position = transform.position  + moveDirection;</pre></div><p>Here, I used the <code class="literal">*=</code> and <code class="literal">+=</code> operators instead.</p><p>Save the script and the scene and try it in VR.</p><p>When you look forward, you move forward. Look left, move left. Look right, move right. It works!</p><p>Look up... <span class="emphasis"><em>Whoa!! Did you expect that?! We're freakin' flying!</em></span> You can move up, down, and all around as if you're Superman or a pilot of a drone. Presently, <code class="literal">MeMyselfEye</code> has no mass and physics, and does not respond to gravity. Nonetheless, it meets our requirement—to move in the direction you're looking. So let's continue.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec66"></a>Keep your feet on the ground</h3></div></div></div><p>The next<a id="id330" class="indexterm"></a> requirement wants you to keep your feet on the ground. We know that <code class="literal">GroundPlane</code> is flat and positioned at <span class="strong"><strong>Y</strong></span> = <code class="literal">0</code>. So, let's just add this simple constraint to the <code class="literal">HeadLookWalk</code> script, as follows:</p><div class="informalexample"><pre class="programlisting">  void Update () {
    Vector3 moveDirection = Camera.main.transform.forward;
    moveDirection *= velocity * Time.deltaTime;
<span class="strong"><strong>    moveDirection.y = 0.0f;</strong></span>
    transform.position += moveDirection;
  }</pre></div><p>Save the <a id="id331" class="indexterm"></a>script and try it in VR.</p><p>Not bad. Now, we can move around the <span class="strong"><strong>Y</strong></span> = <code class="literal">0</code> plane.</p><p>On the other hand, you're like a ghost, readily passing through the cube, sphere, and the other objects.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec67"></a>Don't pass through solid objects</h3></div></div></div><p>The third<a id="id332" class="indexterm"></a> requirement states—<span class="emphasis"><em>don't pass through solid objects</em></span>. Here's an idea. Give it a Rigidbody component and let the physics engine take care of it by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select the <code class="literal">MeMyselfEye</code> object in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, navigate to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Rigidbody</strong></span>.</p></li></ol></div><p>Try it in VR.</p><p>
<span class="emphasis"><em>Whoa!! What the...?</em></span> It was going fine there for a second, but as soon as you knock into the cube, you go spinning out of control in wild directions, like a spacewalk gone wrong in the movie <span class="emphasis"><em>Gravity</em></span>. Well, that's a Rigidbody for you. Forces are being applied in all directions and axes. Let's add some constraints, as follows:</p><p>In the <span class="strong"><strong>Inspector</strong></span> panel's <span class="strong"><strong>Rigidbody</strong></span> pane, check off the checkboxes for <span class="strong"><strong>Freeze Position: Y</strong></span> and <span class="strong"><strong>Freeze Rotation: X</strong></span> and <span class="strong"><strong>Z</strong></span>.</p><p>Try it in VR.</p><p>Now that's pretty nice! You're able to move by looking in a direction, you're not flying (the Y position is constrained), and you don't pass through solid objects. Instead, you slide past them since only the Y rotation is allowed.</p><p>Assuming that your <code class="literal">KillTarget</code> script is still running (from <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Gaze-based Control</em></span>), you should be able to stare at Ethan until he explodes. Do it, make Ethan explode... <span class="emphasis"><em>Whoa!</em></span> We just got blown out of here by the explosion, spinning out of control in wild directions again. Maybe we're just not ready for this powerful physics engine yet. We can probably address this in the scripting, but for the time being, let's abandon the Rigidbody idea. We'll come back to it in the next chapter.</p><p>You may recall that CC includes a Capsule Collider and supports movement that is constrained by collisions. We'll try that instead, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, click on the <span class="strong"><strong>Rigidbody</strong></span> pane's <span class="emphasis"><em>gear</em></span> icon and select <span class="strong"><strong>Remove Component</strong></span>.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, navigate to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Character Controller</strong></span>.</p></li></ol></div><p>Modify<a id="id333" class="indexterm"></a> the <code class="literal">HeadLookWalk</code> script, as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class HeadLookWalk : MonoBehaviour {
  public float velocity = 0.7f;

<span class="strong"><strong>  private CharacterController controller;</strong></span>

<span class="strong"><strong>  void Start () {</strong></span>
<span class="strong"><strong>    controller = GetComponent&lt;CharacterController&gt;();</strong></span>
<span class="strong"><strong>  }</strong></span>

  void Update () {
    Vector3 moveDirection = Camera.main.transform.forward;
    moveDirection *= velocity * Time.deltaTime;
    moveDirection.y = 0.0f;
<span class="strong"><strong>    controller.Move(moveDirection);</strong></span>
  }
}</pre></div><p>Instead of updating <code class="literal">transform.position</code> directly, we called the built-in <code class="literal">CharacterController.Move()</code> function and let it do it for us. It knows that the characters should behave with certain constraints.</p><p>Save the script and try it in VR.</p><p>This time, when we bump into objects (a cube or sphere), we kind of go over it and then remain in the air. The <code class="literal">Move()</code> function does not apply gravity to the scene for us. We need to add <a id="id334" class="indexterm"></a>that to the script, which isn't so hard (see the Unity API docs at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/CharacterController.Move.html" target="_blank">http://docs.unity3d.com/ScriptReference/CharacterController.Move.html</a>).</p><p>However, there is a simpler way. The <code class="literal">CharacterController.SimpleMove()</code> function applies gravity to the movement for us. Just replace the whole <code class="literal">Update()</code> function with the following one-liner:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  void Update () {</strong></span>
<span class="strong"><strong>    controller.SimpleMove(Camera.main.transform.forward * velocity);</strong></span>
<span class="strong"><strong>  }</strong></span>
</pre></div><p>The <code class="literal">SimpleMove()</code> function takes care of gravity and also handles <code class="literal">Time.deltaTime</code>. So, all that we need to give it is the movement direction vector. Also, since it's introducing<a id="id335" class="indexterm"></a> gravity, we don't need the <span class="strong"><strong>Y</strong></span> = <code class="literal">0</code> constraint either. Much simpler.</p><p>Save the script and try it in VR.</p><p>Awesome! I think we've met all the requirements so far. <span class="emphasis"><em>Just don't go walking off the edge...</em></span>
</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec68"></a>Don't fall off the edge of the world</h3></div></div></div><p>Now that <a id="id336" class="indexterm"></a>we have gravity, if we walk off the edge of the ground plane, you'll fall into oblivion. Fixing this isn't a first-person character thing. Just add some railings to the scene.</p><p>Use cubes, scale them to the desired thickness and length, then move them into position. Go ahead and do it. I won't give you the step-by-step instructions for it. For example, I used these transforms:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Scale</strong></span>: <code class="literal">0.1</code>, <code class="literal">0.1</code>, <code class="literal">10.0</code>
</p></li><li style="list-style-type: disc"><p>Railing 1: <span class="strong"><strong>Position</strong></span>: <code class="literal">-5</code>, <code class="literal">1</code>, <code class="literal">0</code>
</p></li><li style="list-style-type: disc"><p>Railing 2: <span class="strong"><strong>Position</strong></span>: <code class="literal">5</code>, <code class="literal">1</code>, <code class="literal">0</code>
</p></li><li style="list-style-type: disc"><p>Railing 3: <span class="strong"><strong>Position</strong></span>: <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">-5</code>; <span class="strong"><strong>Rotation</strong></span>: <code class="literal">0</code>, <code class="literal">90</code>, <code class="literal">0</code>
</p></li><li style="list-style-type: disc"><p>Railing 4: <span class="strong"><strong>Position</strong></span>: <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">5</code>; <span class="strong"><strong>Rotation</strong></span>: <code class="literal">0</code>, <code class="literal">90</code>, <code class="literal">0</code>
</p></li></ul></div><p>Try it in VR. Try to walk through the railings. Whew! This is safer.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec69"></a>Stepping over small objects and handling uneven terrain</h3></div></div></div><p>While <a id="id337" class="indexterm"></a>we're <a id="id338" class="indexterm"></a>at it, add a few things to walk on and over, such as a ramp and other obstacles. The result will look something like this:</p><div class="mediaobject"><img src="/graphics/9781783988556/graphics/B04781_06_12.jpg" /></div><p>Try it in <a id="id339" class="indexterm"></a>VR. Walk up the ramp and<a id="id340" class="indexterm"></a> step off the cube. Hey, this is fun!</p><p>The CC component is taking care of the requirement to step over small objects and handle uneven terrain. You might want to tinker with its <span class="strong"><strong>Slope Limit</strong></span> and <span class="strong"><strong>Step Offset</strong></span> settings.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec70"></a>Start and stop moving</h3></div></div></div><p>The <a id="id341" class="indexterm"></a>next requirement is <span class="emphasis"><em>to start and stop moving with a click or a head gesture</em></span>. First, we'll implement the click by using the <code class="literal">Clicker</code> class<a id="id342" class="indexterm"></a> that we wrote in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>VR Build and Run</em></span>, which checks whether any keys are pressed on the keyboard, mouse, or the Cardboard trigger.</p><p>Modify the <code class="literal">HeadLookWalk</code> script, as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class HeadLookWalk : MonoBehaviour {
  public float velocity = 0.7f;
<span class="strong"><strong>  public bool isWalking = false;</strong></span>

  private CharacterController controller;
<span class="strong"><strong>  private Clicker clicker = new Clicker();</strong></span>

  void Start() {
    controller = GetComponent&lt;CharacterController&gt; ();
  }

  void Update () {
<span class="strong"><strong>    if (clicker.clicked()) {</strong></span>
<span class="strong"><strong>      isWalking = !isWalking;</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    if (isWalking) {</strong></span>
      controller.SimpleMove (Camera.main.transform.forward * velocity);
<span class="strong"><strong>    }</strong></span>
  }
}</pre></div><p>By<a id="id343" class="indexterm"></a> adding a Boolean <code class="literal">isWalking</code> flag, we can switch<a id="id344" class="indexterm"></a> the forward movement on and off, which can be signaled by a key press.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec71"></a>Using head gestures to start/stop</h3></div></div></div><p>To add a<a id="id345" class="indexterm"></a> head gesture trigger for walking, we can use the <code class="literal">HeadGesture</code> class that we made in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>World Space UI</em></span> (assuming its still attached to a <code class="literal">GameController</code> object in your scene). We can modify the <code class="literal">HeadLookWalk</code> script, but let's keep this in a separate script that ties them together, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select the <code class="literal">MeMyselfEye</code> object in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, select <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>New Script</strong></span> and name it <code class="literal">GestureWalk</code>.</p></li></ol></div><p>Then, open the script and code it, as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class GestureWalk : MonoBehaviour {
  private HeadLookWalk lookWalk;
  private HeadGesture gesture;

  void Start () {
    lookWalk = GetComponent&lt;HeadLookWalk&gt; ();
    gesture = GameObject.Find ("GameController").GetComponent&lt;HeadGesture&gt; ();
  }

  void Update () {
    if (gesture.isMovingDown) {
      lookWalk.isWalking = !lookWalk.isWalking;
    }
  }
}</pre></div><p>We've made <a id="id346" class="indexterm"></a>the code more modular by separating the gesture input from the look-walk controller, modifying the <code class="literal">HeadLookWalk</code> Class's <code class="literal">public</code> variable, <code class="literal">isWalking</code>.</p><p>Now, we can also switch the forward movement on and off with a head-down gesture. <span class="emphasis"><em>Look ma, no hands!</em></span> You can walk around, start, and stop in VR without a keyboard, mouse, or a game controller. (It should be noted that this example is for fun. I'm not necessarily advocating that this is a good mechanism to use in your applications.)</p></div></div>