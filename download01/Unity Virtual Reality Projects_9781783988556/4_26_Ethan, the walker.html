<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec29"></a>Ethan, the walker</h2></div></div><hr /></div><p>A starting point for much of VR is gaming. So, we might as well start out from there, too! We are going to give our character, Ethan, a life of his own. Well, sort of (or not), because he's going to become a <span class="emphasis"><em>zombie!</em></span>
</p><p>We left<a id="id200" class="indexterm"></a> off at the diorama, with Ethan hanging out. You can make him run around the scene if you have a keyboard or gamepad, but in today's VR having that is not guaranteed. In fact, if you're viewing the scene with a Google Cardboard, it's pretty unlikely that you'll have a handheld controller (notwithstanding the Bluetooth game controllers). Let's be honest. Even with the Oculus Rift, requiring a keyboard or a gamepad controller is not very user-friendly, since you can't see your hands. Perhaps, there's another way to make him move around. One technique is to use the direction of your gaze while wearing your VR headset.</p><p>Before we attempt this, we'll first transform Ethan into a zombie and have him walk around aimlessly without any user control. We'll do this by giving him some AI and write a script that sends him to random target locations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec43"></a>Artificially intelligent Ethan</h3></div></div></div><p>To start, we <a id="id201" class="indexterm"></a>want to replace the <code class="literal">ThirdPersonController</code> prefab that we used initially with Unity's AI character, <code class="literal">AIThirdPersonController</code> using the following steps. Unity uses the word <span class="emphasis"><em>artificial intelligence</em></span> loosely to mean <span class="emphasis"><em>script-driven</em></span>. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the Unity project from the previous chapters with the <code class="literal">Diorama</code> scene, and have the <span class="strong"><strong>Characters</strong></span> package imported from <span class="strong"><strong>Standard Assets</strong></span>.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, open the <code class="literal">Standard Assets/Characters/ThirdPersonCharacter/Prefabs</code> folder and drag <code class="literal">AIThirdPersonController</code> into the scene. Name it <code class="literal">Ethan</code>.</p></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel (or in <span class="strong"><strong>Scene</strong></span>), select the previous <code class="literal">ThirdPersonController</code>, (the old Ethan). Then, in the <span class="strong"><strong>Inspector</strong></span> panel's <span class="strong"><strong>Transform</strong></span> pane, choose the <span class="emphasis"><em>gear</em></span> icon on the upper right of the <span class="strong"><strong>Transform</strong></span> pane and select <span class="strong"><strong>Copy Component</strong></span>.</p></li><li><p>Select <a id="id202" class="indexterm"></a>the new <code class="literal">Ethan</code> object (from the <span class="strong"><strong>Hierarchy</strong></span> panel or <span class="strong"><strong>Scene</strong></span>). Then, in the <span class="strong"><strong>Inspector</strong></span> panel's <span class="strong"><strong>Transform</strong></span> pane, choose the <span class="emphasis"><em>gear</em></span> icon and select <span class="strong"><strong>Paste Component Values</strong></span>.</p></li><li><p>Now you can delete the old <code class="literal">Ethan</code> object by selecting it from the <span class="strong"><strong>Hierarchy</strong></span> panel, right-clicking to open options, and clicking on <span class="strong"><strong>Delete</strong></span>.</p></li></ol></div><p>Note that this <a id="id203" class="indexterm"></a>controller has a <span class="strong"><strong>NavMesh Agent</strong></span> component and an <code class="literal">AICharacterControl</code> script. The NavMesh Agent has parameters for how Ethan will move around the scene. The <code class="literal">AICharacterControl</code> script takes a target object where Ethan will walk to. Let's populate that, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add an empty game object to the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>Reset its <span class="strong"><strong>Transform</strong></span> values.</p></li><li><p>Name the game object as <code class="literal">WalkTarget</code>.</p></li><li><p>Select Ethan and drag <code class="literal">WalkTarget</code> into the <span class="strong"><strong>Target</strong></span> property in the <span class="strong"><strong>Inspector</strong></span> panel's <span class="strong"><strong>AI Character Control</strong></span> pane.</p></li></ol></div><p>At this point, we have an AI character in the scene (<code class="literal">Ethan</code>), an empty game object that will be used as a navigation target (<code class="literal">WalkTarget</code>), and we told the AI Character Controller to use this target object. When we run the game, wherever <code class="literal">WalkTarget</code> is, Ethan will go there. But not yet.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec44"></a>The Navmesh bakery</h3></div></div></div><p>Ethan <a id="id204" class="indexterm"></a>cannot just go walking around without being told where he's allowed to roam! We need to define a "NavMesh"—a simplified geometrical plane that enables a character to plot its path around obstacles.</p><p>Create a <a id="id205" class="indexterm"></a>NavMesh by first identifying the static objects in the scene and then <span class="emphasis"><em>baking</em></span> it:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select each of the objects—the ground plane, the three cubes, and the sphere and in its <span class="strong"><strong>Inspector</strong></span> panel, check off the <span class="strong"><strong>Static</strong></span> checkbox (you can do each object separately or <span class="emphasis"><em>Ctrl</em></span> + click to select multiple items at once).</p></li><li><p>Select the <span class="strong"><strong>Navigation</strong></span> panel. If it's not already a tab in your editor, open the "Navigation" window from the main menu by navigating to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Navigation</strong></span>.</p></li><li><p>Click on<a id="id206" class="indexterm"></a> the <span class="strong"><strong>Bake</strong></span> button at the bottom of the panel.</p></li></ol></div><p>The <span class="strong"><strong>Scene</strong></span> view <a id="id207" class="indexterm"></a>should now show a blue overlay where the NavMesh is defined, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783988556/graphics/B04781_04_02.jpg" /></div><p>Let's test this out. Ensure that the <span class="strong"><strong>Game</strong></span> panel's <span class="strong"><strong>Maximize on Play</strong></span> is deselected. Click on the <span class="emphasis"><em>Play</em></span> mode button (triangle at the top of editor). In the <span class="strong"><strong>Hierarchy</strong></span> panel, select the <code class="literal">WalkTarget</code> object and ensure that the Translate gizmo is active in the <span class="strong"><strong>Scene</strong></span> panel (press the <span class="emphasis"><em>W</em></span> key on keyboard). Now, drag the red (X) and/or the blue (Z) arrow handles on the <code class="literal">WalkTarget</code> object to move it around the floor plane. As you do, Ethan should follow! Click on <span class="emphasis"><em>Play</em></span> again to stop Play Mode.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec45"></a>A random walker in the town</h3></div></div></div><p>Now, we'll <a id="id208" class="indexterm"></a>write a script that moves the <code class="literal">WalkTarget</code> object to random places.</p><p>If you've done anything more that tinker with Unity, you've probably already written at least some scripts. We're going to use C# for the programming language. For this first script, we'll take it slow. We will attach the script to the <code class="literal">WalkTarget</code> object, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select the <code class="literal">WalkTarget</code> object in the <span class="strong"><strong>Hierarchy</strong></span> panel or the <span class="strong"><strong>Scene</strong></span> view.</p></li><li><p>In its <span class="strong"><strong>Inspector</strong></span> panel, click on the <span class="strong"><strong>Add Component</strong></span> button.</p></li><li><p>Select <span class="strong"><strong>New Script</strong></span>.</p></li><li><p>Name it <code class="literal">RandomPosition</code>.</p></li><li><p>Ensure that the <span class="strong"><strong>C Sharp</strong></span> language is selected.</p></li><li><p>Click on <span class="strong"><strong>Create</strong></span> and <span class="strong"><strong>Add</strong></span>.</p></li><li><p>This should create a script component on the <code class="literal">WalkTarget</code> object. Double-click on the <code class="literal">RandomPosition</code> script in the slot to the right of <span class="strong"><strong>Script</strong></span> in the <span class="strong"><strong>Inspector</strong></span> pane to open it in the <span class="strong"><strong>MonoDevelop</strong></span> code editor.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec46"></a>Interlude – a quick introduction to Unity programming</h3></div></div></div><p>Unity <a id="id209" class="indexterm"></a>does a lot of things—it manages objects, renders them, animates them, calculates the physics of those objects, and so on. Unity itself is a program. It's made of code—probably a lot of good code written by some very smart people. This internal Unity code can be accessed by you, the game developer, through the Unity point-and-click editor interface that we've already been using. Within the Unity editor, scripts are manifested as configurable components. However, it's also made more directly accessible to you through the Unity scripting API.</p><p>
<span class="strong"><strong>API</strong></span> (short for <span class="strong"><strong>application programming interface</strong></span>), simply refers to published software functions <a id="id210" class="indexterm"></a>that you can access from your own scripts. Unity's API is very rich and nicely designed. That's one reason why people have written amazing plugin add-ons for Unity.</p><p>There are many programming languages in the world. Unity has chosen to support the C# language from Microsoft (as well as a flavor of JavaScript, which has its limitations). Computer languages have a specific syntax that must be obeyed. Otherwise, the computer will not understand your script. In Unity, script errors (and warnings) appear in the <span class="strong"><strong>Console</strong></span> panel of the editor as well as in the bottom footer of the app window.</p><p>The default <a id="id211" class="indexterm"></a>script editor for Unity is an integrated development environment, or an IDE, called <span class="strong"><strong>MonoDevelop</strong></span>. You can configure a different editor or an IDE if you want, like Microsoft's Visual Studio. MonoDevelop has some nice features such as auto-completion and pop-up help that understand the Unity documentation. C# scripts are text files that are named with a <code class="literal">.cs</code> extension.</p><p>In a <a id="id212" class="indexterm"></a>Unity C# script, some of the words and symbols are a part of the C# language itself, some come from the Microsoft .NET Framework, and others are provided by the Unity API. And then there's the code that you write.</p><p>An empty default Unity C# script looks like this:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class RandomPosition : MonoBehaviour {

  // Use this for initialization
  void Start () {

  }

  // Update is called once per frame
  void Update () {

  }
}</pre></div><p>Let's dissect it.</p><p>The first two lines indicate that this script needs some other stuff to run. The <code class="literal">using</code> keyword belongs to the C# language. The line using <code class="literal">UnityEngine</code>; says that we'll be using the <code class="literal">UnityEngine</code> API. The line using <code class="literal">System.Collections</code>; says that we also might use a library of functions named <code class="literal">Collections</code> to access lists of objects.</p><p>In C#, each line of code ends with a semicolon. Double slashes (<code class="literal">//</code>) indicate comments in the code, and anything from there to the end of that line will be ignored.</p><p>This Unity script defines a class named <code class="literal">RandomPosition</code>. <span class="strong"><strong>Classes</strong></span> are like code templates<a id="id213" class="indexterm"></a> with their own properties (variables) and behavior (functions). Classes derived from the <code class="literal">MonoBehaviour</code> base class are recognized by Unity and used when your game runs. The line public class <code class="literal">RandomPosition : MonoBehaviour</code> basically says, <span class="emphasis"><em>we are defining a new public class named "RandomPosition", which inherits all the abilities of the "MonoBehaviour" Unity base class</em></span>, including the capability of the <code class="literal">Start()</code> and <code class="literal">Update()</code> functions. The body of the class is enclosed in a pair of curly braces (<code class="literal">{}</code>).</p><p>When something is <code class="literal">public</code>, it can be seen by other code outside this specific script file. When it's <code class="literal">private</code>, it can only be referenced within this file. We want Unity to see the <code class="literal">RandomPosition</code> class.</p><p>Classes define<a id="id214" class="indexterm"></a> variables and functions. A <span class="strong"><strong>variable</strong></span> holds data values of a specific type, such as <code class="literal">float</code>, <code class="literal">int</code>, <code class="literal">boolean</code>, <code class="literal">GameObject</code>, <code class="literal">Vector3</code>, and so on. <span class="strong"><strong>Functions</strong></span> implement logic (step-by-step instructions). Functions can receive <span class="emphasis"><em>arguments</em></span>—variables enclosed in a parenthesis<a id="id215" class="indexterm"></a> used by <a id="id216" class="indexterm"></a>its <a id="id217" class="indexterm"></a>code—and can return new values when it's done.</p><p>Numeric <code class="literal">float</code> constants, such as <code class="literal">5.0f</code>, require an <code class="literal">f</code> at the end in C# to ensure that the data type is a <span class="emphasis"><em>simple</em></span> floating point value and not a <span class="emphasis"><em>double-precision</em></span> floating point value.</p><p>Unity will automatically call some special <code class="literal">message</code> functions if you've defined them. <code class="literal">Start()</code> and <code class="literal">Update()</code> are two examples. Empty versions of these are provided in the default C# script. The datatype in front of a function indicates the type of value returned. <code class="literal">Start()</code> and <code class="literal">Update()</code> do not return values. So, they're <code class="literal">void</code>.</p><p>Each <code class="literal">Start()</code> function from all <code class="literal">MonoBehaviour</code> scripts in your game are called before the gameplay begins. It's a good place for data initialization. All the <code class="literal">Update()</code> functions are called during each time slice, or frame, while the game is running. This is where most of the action lies.</p><p>Once you've written or modified a script in the MonoDevelop mode, save it. Then, switch to the Unity editor window. Unity will automatically recognize that the script has changed and will reimport it. If errors are found, it will report them right away in the <span class="strong"><strong>Console</strong></span> panel.</p><p>This is just some cursory introduction to Unity programming. As we work through the projects in this book, I will explain additional bits as they're introduced.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec47"></a>The RandomPosition script</h3></div></div></div><p>Now, we <a id="id218" class="indexterm"></a>want to move the <code class="literal">WalkTarget</code> object to a random location so that Ethan will head in that direction, wait a few seconds, and move the <code class="literal">WalkTarget</code> object again. That way, he'll appear to be wandering around aimlessly. We can do this with a script. Rather than developing the script incrementally, I'm presenting the finished version first, and we'll go through it line by line. The <code class="literal">RandomPosition.cs</code> script looks like this:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class RandomPosition : MonoBehaviour {

  void Start () {
    StartCoroutine (RePositionWithDelay());
  }

  IEnumerator RePositionWithDelay() {
    while (true) {
      SetRandomPosition();
      yield return new WaitForSeconds (5);
    }
  }

  void SetRandomPosition() {
    float x = Random.Range (-5.0f, 5.0f);
    float z = Random.Range (-5.0f, 5.0f);
    Debug.Log ("X,Z: " + x.ToString("F2") + ", " + z.ToString("F2"));
    transform.position = new Vector3 (x, 0.0f, z);
  }
}</pre></div><p>This <a id="id219" class="indexterm"></a>script defines a <code class="literal">MonoBehaviour</code> class named <code class="literal">RandomPosition</code>. The first thing we do when defining the class is declare any variables that we'll be using. A variable is a placeholder for a value. The value can be initialized here or assigned elsewhere, just as long as it has a value before the script needs to use it.</p><p>The meat of the script is further down—the function named <code class="literal">SetRandomPosition()</code>. Let's see what that does.</p><p>If you recall, the <code class="literal">GroundPlane</code> plane is 10 units square, with the origin in the middle. So, any (<span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Z</strong></span>) location on the plane will be within the range from <code class="literal">-5</code> to <code class="literal">5</code> along each axis. The line <code class="literal">float x = Random.Range (-5.0f, 5.0f)</code>; picks a random value within the given range and assigns it to a new <code class="literal">float x</code> variable. We do the same thing to get a random <span class="emphasis"><em>z</em></span> value. (Usually, I discourage <span class="emphasis"><em>hardcoding</em></span> constant values like this instead of using variables, but I'm keeping things simple for illustration purposes).</p><p>The line <code class="literal">Debug.Log ("X,Z: " + x.ToString("F2") + ", " + z.ToString("F2"))</code>; prints the <code class="literal">x</code> and <code class="literal">z</code> values in the <span class="strong"><strong>Console</strong></span> panel when the game is running. It'll output something like <code class="literal">X, Z: 2.33, -4.02</code> because <code class="literal">ToString("F2")</code> says round up to two decimal places. Note that we're using plus signs to combine the parts of the output string together.</p><p>We actually move the target to the given location with the line <code class="literal">transform.position = new Vector3 (x, 0.0f, z);</code>. We're setting the transform position of the object that this script is attached to. In Unity, values that have an X, Y, and Z are represented by the <code class="literal">Vector3</code> objects. So, we create a new one with the <code class="literal">x</code> and <code class="literal">z</code> values that we generated. We give <code class="literal">y=0</code> so that it sits on <code class="literal">GroundPlane</code>.</p><p>Each <code class="literal">MonoBehaviour</code> class has a built-in variable called <code class="literal">this</code>, which refers to the object that the script is attached to. That is, when the script is a component of an object and appears in<a id="id220" class="indexterm"></a> its <span class="strong"><strong>Inspector</strong></span> panel, the script can refer to its object as <code class="literal">this</code>. In fact, <code class="literal">this</code> is so obvious, if you want to call functions on the <code class="literal">this</code> object, you don't even need to say it. We could have said <code class="literal">this.transform.position = …</code>, but the <code class="literal">this</code> object is implied and is normally omitted. On the other hand, if you had a variable for some other object (for example, <code class="literal">GameObject that;</code>), then you'd need to say that when you set its position, like <code class="literal">that.transform.position = …</code>.</p><p>The last mysterious bit is how we handle time delays in Unity. In our case, the transform position should get changed once every 5 seconds. It's solved in several parts:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <code class="literal">Start()</code> function, there's the line <code class="literal">StartCoroutine (RePositionWithDelay());</code>. A <span class="strong"><strong>co-routine</strong></span> is a piece of code that runs separately <a id="id221" class="indexterm"></a>from the function from which it was called. So, this line kicks off the <code class="literal">RePositionWithDelay()</code> function in a co-routine.</p></li><li><p>Inside that, there's a <code class="literal">while (true)</code> loop, which as you might guess, runs forever (as long as the game is running).</p></li><li><p>It calls the <code class="literal">SetRandomPosition()</code> function, which actually repositions the object.</p></li><li><p>Then, at the bottom of this loop, we do a <code class="literal">yield return new WaitForSeconds (5);</code> sentence, which basically says to Unity, <span class="emphasis"><em>hey, go do what you want for 5 seconds and then come back here so that I can go through my loop again</em></span>.</p></li><li><p>For all of this to work, the <code class="literal">RePositionWithDelay</code> co-routine must be declared as the <code class="literal">IEnumerator</code> type (because the documentation says so).</p></li></ol></div><p>This <span class="emphasis"><em>co-routine / yield</em></span> mechanism, although an advanced programming topic, is a common pattern in time-sliced programs such as Unity.</p><p>Our script should be saved to a file named <code class="literal">RandomPosition.cs</code>.</p><p>We are now good to go. In the Unity editor, click on <span class="emphasis"><em>Play</em></span>. Ethan is running from one place to another like a madman!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec48"></a>"Zombie-ize" Ethan!</h3></div></div></div><p>Ok, that's <a id="id222" class="indexterm"></a>pretty random. Let's adjust the NavMesh steering parameters to slow him down to a nice zombie-like pace. For that, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select <code class="literal">Ethan</code> in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>Navigate to <span class="strong"><strong>Inspector</strong></span> | <span class="strong"><strong>Nav Mesh Agent</strong></span> | <span class="strong"><strong>Steering</strong></span>, set the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Speed</strong></span>: <code class="literal">0.3</code>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Angular Speed</strong></span>: <code class="literal">60</code>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Acceleration</strong></span>: <code class="literal">2</code>
</p></li></ul></div></li></ol></div><p>Play<a id="id223" class="indexterm"></a> again. He has slowed down. That's better.</p><p>One more finishing touch—let's turn him into a zombie. I have a texture image named <code class="literal">EthanZombie.png</code> that will help (included with this book). Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>From the <span class="strong"><strong>Assets</strong></span> tab on the main menu, select <span class="strong"><strong>Import New Asset...</strong></span>. Navigate to the files folder with the assets that came with this book.</p></li><li><p>Select the <code class="literal">EthanZombie.png</code> file.</p></li><li><p>Click on <span class="strong"><strong>Import</strong></span>. For tidiness, ensure that it resides in the <code class="literal">Assets/Textures</code> folder. (Alternatively, you can just drag and drop the file from Windows Explorer into the <span class="strong"><strong>Project</strong></span> panel folder.)</p></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, unfold the <code class="literal">Ethan</code> object (click on the triangle) and select <code class="literal">EthanBody</code>.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, unfold the <code class="literal">EthanWhite</code> shader by clicking on the triangle-icon to the left of <span class="strong"><strong>Shader</strong></span>.</p></li><li><p>Select the <code class="literal">EthanZombie</code> texture from the <code class="literal">Project Assets/Textures</code> folder.</p></li><li><p>Drag it onto the <span class="strong"><strong>Albedo</strong></span> texture map. It's a small square just to the left of the <span class="strong"><strong>Albedo</strong></span> label under <span class="strong"><strong>Main Maps</strong></span>.</p></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, select <code class="literal">EthanGlasses</code> and uncheck it to disable glasses in the <span class="strong"><strong>Inspector</strong></span> panel. After all, zombies don't need glasses!</p></li></ol></div><p>His portrait is featured at the top of this chapter! <span class="emphasis"><em>What'd you say? That's a lame looking zombie??</em></span> Well, maybe he's just recently turned. Go ahead and make a better one yourself. Use Blender, Gimp, or Photoshop and paint your own (or even import a whole different zombie humanoid model to replace <code class="literal">EthanBody</code> itself).</p><p>Now, build the project and try it in VR.</p><p>We're looking from a third-person perspective. You can look around and watch what's going on. It's kind of fun, and it's pretty interesting. And it's passive. Let's get more active.</p></div></div>