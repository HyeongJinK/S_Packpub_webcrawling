<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec30"></a>Go where I'm looking</h2></div></div><hr /></div><p>In this next script, instead of being random, we'll send Ethan to wherever we look. In Unity, this is accomplished by using <span class="strong"><strong>ray casting</strong></span>—like shooting a ray from the camera and seeing <a id="id224" class="indexterm"></a>what it hits (for more information, visit <a class="ulink" href="http://docs.unity3d.com/Manual/CameraRays.html" target="_blank">http://docs.unity3d.com/Manual/CameraRays.html</a>).</p><p>We're going <a id="id225" class="indexterm"></a>to create a new script, which will be attached to <code class="literal">WalkTarget</code> like before, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select the <code class="literal">WalkTarget</code> object in the <span class="strong"><strong>Hierarchy</strong></span> panel or the <span class="strong"><strong>Scene</strong></span> view.</p></li><li><p>In its <span class="strong"><strong>Inspector</strong></span> panel, click on the <span class="strong"><strong>Add Component</strong></span> button.</p></li><li><p>Select <span class="strong"><strong>New Script</strong></span>.</p></li><li><p>Name it <code class="literal">LookMoveTo</code>.</p></li><li><p>Ensure that the <span class="strong"><strong>C Sharp</strong></span> language is selected.</p></li><li><p>Click on <span class="strong"><strong>Create</strong></span> and <span class="strong"><strong>Add</strong></span>.</p></li></ol></div><p>This should create a script component on the <code class="literal">WalkTarget</code> object. Double-click on it to open it in the MonoDevelop code editor.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec49"></a>The LookMoveTo script</h3></div></div></div><p>In our <a id="id226" class="indexterm"></a>script, each time <code class="literal">Update()</code> is called, we'll read where the camera is pointing (by using its transform position and rotation), cast a ray in that direction, and ask Unity to tell us where it hits the ground plane. Then, we'll use this location to set the <code class="literal">WalkTarget</code> object's position.</p><p>Here's the full <code class="literal">LookMoveTo.cs</code> script:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class LookMoveTo : MonoBehaviour {
  public GameObject ground;

  void Update () {
    Transform camera = Camera.main.transform;
    Ray ray;
    RaycastHit hit;
    GameObject hitObject;

    Debug.DrawRay (camera.position,
      camera.rotation * Vector3.forward * 100.0f);

    ray = new Ray (camera.position,
      camera.rotation * Vector3.forward);
    if (Physics.Raycast (ray, out hit)) {
      hitObject = hit.collider.gameObject;
      if (hitObject == ground) {
        Debug.Log ("Hit (x,y,z): " + hit.point.ToString("F2"));
        transform.position = hit.point;
      }
    }
  }

}</pre></div><p>Let's go<a id="id227" class="indexterm"></a> through the script a bit at a time.</p><div class="informalexample"><pre class="programlisting">public GameObject ground;</pre></div><p>The first thing the script does is declare a variable for the <code class="literal">GroundPlane</code> object. Since it's <code class="literal">public</code>, we can use the Unity editor to assign the actual object:</p><div class="informalexample"><pre class="programlisting">  void Update () {
    Transform camera = Camera.main.transform;
    Ray ray;
    RaycastHit hit;
    GameObject hitObject;</pre></div><p>Inside <code class="literal">Update()</code>, we define a few local variables—<code class="literal">camera</code>, <code class="literal">ray</code>, <code class="literal">hit</code>, and <code class="literal">hitObject</code>, which have datatypes that are required by the Unity functions that we're going to use.</p><p>
<code class="literal">Camera.main</code> is the current active camera object (that is, tagged as "MainCamera"). We get its current transform, which will be assigned to the camera variable:</p><div class="informalexample"><pre class="programlisting">    ray = new Ray (camera.position,
      camera.rotation * Vector3.forward);</pre></div><p>Ignoring the handy <code class="literal">Debug</code> statements for a moment, we first determine the ray from the camera using <code class="literal">new Ray()</code>.</p><p>A <span class="strong"><strong>ray</strong></span> can<a id="id228" class="indexterm"></a> be defined by a starting position in the <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> space and a direction<a id="id229" class="indexterm"></a> vector. A <span class="strong"><strong>direction vector</strong></span> can be defined as the relative offsets from a 3D starting point to some other point in space. The forward direction, where Z is positive, is (0, 0, 1). Unity will do the math for us. So, if we take a unit vector (<code class="literal">Vector3.forward</code>), multiply it by a 3-axis rotation (<code class="literal">camera.rotation</code>), and scale it by a length (<code class="literal">100.0f</code>), we'll get a ray pointing in the same direction as the camera measuring 100 units long.</p><div class="informalexample"><pre class="programlisting">if (Physics.Raycast (ray, out hit)) {</pre></div><p>Then, we cast the ray and see if it hit anything. If so, the <code class="literal">hit</code> variable will now contain more details about what was hit, including the specific object in <code class="literal">hit.collider.gameObject</code>. (The <code class="literal">out</code> keyword means that the <code class="literal">hit</code> variable value is filled in by the <code class="literal">Physics.Raycast()</code> function.)</p><div class="informalexample"><pre class="programlisting">      if (hitObject == ground) {
        transform.position = hit.point;
      }</pre></div><p>We check whether the ray hit the <code class="literal">GroundPlane</code> object, and if so, we'll assign that as the position to move the <code class="literal">WalkTarget</code> object to the <code class="literal">hit</code> location.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip08"></a>Note</h3><p>The <code class="literal">==</code> <span class="emphasis"><em>compare</em></span> operator should not to be confused with <code class="literal">=</code>, which is the <span class="emphasis"><em>assignment</em></span> operator.</p></div><p>This <a id="id230" class="indexterm"></a>script contains two <code class="literal">Debug</code> statements, which are a useful way to monitor what's going on while a script is running in Play Mode. <code class="literal">Debug.DrawRay()</code> will draw the given ray in the <span class="strong"><strong>Scene</strong></span> view so that you can actually see it, and <code class="literal">Debug.Log()</code> will dump the current hit position to the console if and when there's a hit.</p><p>Save the script, switch into the Unity editor, and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>With <code class="literal">WalkTarget</code> selected, in the <span class="strong"><strong>Inspector</strong></span> panel, the <code class="literal">LookMoveTo</code> script component now has a field for the <code class="literal">GroundPlane</code> object.</p></li><li><p>From the <span class="strong"><strong>Hierarchy</strong></span> panel, select and drag the <code class="literal">GroundPlane</code> game object onto the <span class="strong"><strong>Ground</strong></span> field.</p></li></ol></div><p>Save the scene. The script pane looks like this:</p><div class="mediaobject"><img src="/graphics/9781783988556/graphics/B04781_04_03.jpg" /></div><p>Then, click on <span class="emphasis"><em>Play</em></span> button. Ethan should follow our gaze (at his own pace).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec50"></a>Adding a feedback cursor</h3></div></div></div><p>Given it's <a id="id231" class="indexterm"></a>not always obvious where your gaze is hitting the ground plane, we'll now add a cursor to the scene. It's really easy because what we've been doing is moving around an invisible, empty <code class="literal">WalkTarget</code> object. If we give it a mesh by using the following steps, it'll be visible:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, select the <code class="literal">WalkTarget</code> object.</p></li><li><p>Right–click on the mouse and navigate to <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Cylinder</strong></span>. This will create a cylindrical object parented by <code class="literal">WalkTarget</code>. (Alternatively, you can use the <span class="strong"><strong>GameObject</strong></span> tab on the main menu bar, and then drag and drop the object onto <code class="literal">WalkTarget</code>.)</p></li><li><p>Ensure that we're starting with the reset values of transform by clicking on <span class="strong"><strong>Reset</strong></span> from the <span class="emphasis"><em>gear</em></span> icon menu in the <span class="strong"><strong>Transform</strong></span> pane.</p></li><li><p>Select the new cylinder and in its <span class="strong"><strong>Inspector</strong></span> panel, change the <span class="strong"><strong>Scale</strong></span> to (<code class="literal">0.4</code>, <code class="literal">0.05</code>, <code class="literal">0.4</code>). This will create a flat disk with a diameter of <code class="literal">0.4</code>.</p></li><li><p>Disable its <span class="strong"><strong>Capsule Collider</strong></span> by unchecking that checkbox.</p></li><li><p>In <span class="strong"><strong>Mesh Render</strong></span>, you can also disable <span class="strong"><strong>Cast Shadows</strong></span>, <span class="strong"><strong>Receive Shadows</strong></span>, <span class="strong"><strong>Use Light Probes</strong></span>, and <span class="strong"><strong>Reflection Probes</strong></span>.</p></li></ol></div><p>Now, try to play again. The cursor disk follows our gaze.</p><p>If you want, decorate the disk better with a colored material. Better yet, find an appropriate texture. For example, we used a grid texture in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Objects and Scale</em></span>, for the <code class="literal">GridProjector</code> file (<code class="literal">Standard Assets/Effects/Projectors/Textures/Grid.psd</code>). The file <code class="literal">CircleCrossHair.png</code> is provided with the files for this book. Drop the texture onto the cylinder cursor. When you do, set its <span class="strong"><strong>Shader</strong></span> to <span class="strong"><strong>Standard</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec51"></a>Observations</h3></div></div></div><p>In this<a id="id232" class="indexterm"></a> project, we got Ethan to follow where we're looking by moving the <code class="literal">WalkTarget</code> object to a position on the ground plane determined by ray casting from the camera and seeing where it intersected that plane.</p><p>You may have noticed that the cursor seems to get <span class="emphasis"><em>stuck</em></span> when we slide our gaze over the cube and sphere. That's because the <span class="strong"><strong>physics engine</strong></span> has determined which object is hit first, never getting to the ground plane. In our script, we have the conditional statement <code class="literal">if (hitObject == ground)</code> before moving <code class="literal">WalkTarget</code>. Without it, the cursor would float over any object in 3D-space where the cast ray hits something. Sometimes, that's interesting, but in our case, it is not. We want to keep the cursor on the ground. However now, if the ray hits something other than the ground, it doesn't get repositioned and seems <span class="emphasis"><em>stuck</em></span>. Can you think of a way around it? Here's a hint—look up <code class="literal">Physics.RaycastAll</code>. Alright, I'll show<a id="id233" class="indexterm"></a> you. Replace the body of <code class="literal">Update()</code> with the following code:</p><div class="informalexample"><pre class="programlisting">    Transform camera = Camera.main.transform;
    Ray ray;
<span class="strong"><strong>    RaycastHit[] hits;</strong></span>
    GameObject hitObject;
    
    Debug.DrawRay (camera.position, camera.rotation * Vector3.forward * 100.0f);
    
    ray = new Ray (camera.position, camera.rotation * Vector3.forward);
<span class="strong"><strong>    hits = Physics.RaycastAll (ray);</strong></span>
<span class="strong"><strong>    for (int i = 0; i &lt; hits.Length; i++) {</strong></span>
<span class="strong"><strong>      RaycastHit hit = hits [i];</strong></span>
      hitObject = hit.collider.gameObject;
      if (hitObject == ground) {
        Debug.Log ("Hit (x,y,z): " + hit.point.ToString("F2"));
        transform.position = hit.point;
      }
<span class="strong"><strong>    }</strong></span>
</pre></div><p>On calling <code class="literal">RaycastAll</code>, we get back a list, or an array, of hits. Then we loop through each one looking for a ground hit anywhere along the path of the ray vector. Now our cursor will trace along the ground, whether or not there's another object in between.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"></a>Note</h3><p>
<span class="strong"><strong>Extra challenge</strong></span>: Another more efficient solution is to use the <span class="emphasis"><em>layer system</em></span>. Create a new layer, assign it to the plane, and pass it as an argument to <code class="literal">Physics.raycast()</code>. Can you see why that's much more efficient?</p></div></div></div>