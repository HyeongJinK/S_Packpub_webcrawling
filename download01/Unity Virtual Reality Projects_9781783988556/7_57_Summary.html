<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec57"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we took a grand tour of Unity's physics engine. First, I explained in layman's terms the relationship between Rigidbody, Colliders, and Physic Materials, and how the physics engine uses these to determine the velocity and collision of objects in the scene.</p><p>Then, we went through a variety of examples that showed how one can use the physics engine directly, indirectly, and not at all. The bouncy balls used the engine without scripting, but then we wrote scripts on top of it to implement a headshot game and a shower of balls. The trampoline examples use the physics engine to detect collisions, and we scripted the transfer force to another object. Lastly, we implemented our own gravity and bounce forces on a first-person character, including a jump gesture. We did all of this while orbiting the Earth! Wonders never cease!</p><p>Physics mechanics are very important in game design as well as virtual reality. Unity's robust physics API gives developers the tools that are required to build pretty accurate and believable scenes as well as transcend reality and invent your own physics and oddities.</p><p>In the next chapter, we'll set aside much of the interactive features that we did in the past few chapters and look at some more canned or passive, animated VR experiences, such as rides and walkthroughs, which are commonly referred to as <span class="emphasis"><em>riding on rails</em></span>.</p></div>