<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec35"></a>The reticle cursor</h2></div></div><hr /></div><p>A variant<a id="id261" class="indexterm"></a> of the visor HUD that is essential in first-person shooter games is a <span class="emphasis"><em>reticle</em></span> or crosshair cursor. The analogy here is that you're looking through a gun-sight or an eyepiece (rather than a visor), and your head movement is moving in unison with the gun or turret itself. You can do this with a regular game object (for example, Quad + texture image), but this chapter is about UI. So, let's use our canvas, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Find your <span class="strong"><strong>Main Camera</strong></span> object in the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>From the <span class="strong"><strong>Project</strong></span> panel, drag the <code class="literal">DefaultCanvas</code> prefab onto the camera object so that it becomes a child of the camera. Name it <code class="literal">ReticleCursor</code>.</p></li><li><p>Set the <span class="strong"><strong>Rect Transform</strong></span> component's <span class="strong"><strong>Pos X</strong></span>, <span class="strong"><strong>Pos Y</strong></span>, <span class="strong"><strong>Pos Z</strong></span> to (<code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">1</code>).</p></li><li><p>Delete its child objects—<span class="strong"><strong>Image</strong></span> and <span class="strong"><strong>Text</strong></span>.</p></li><li><p>Add a raw image child by selecting from the main menu bar navigating through <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Raw Image</strong></span> and making sure that it's a child of <code class="literal">ReticleCursor</code>.</p></li><li><p>In the <span class="strong"><strong>Raw Image</strong></span> panel's <span class="strong"><strong>Rect Transform</strong></span>, set <span class="strong"><strong>Pos X</strong></span>, <span class="strong"><strong>Pos Y</strong></span>, <span class="strong"><strong>Pos Z</strong></span> to (<code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">0</code>) and <span class="strong"><strong>Width</strong></span>, <span class="strong"><strong>Height</strong></span> to (<code class="literal">22</code>, <code class="literal">22</code>). Then, choose a noticeable <span class="strong"><strong>Color</strong></span> such as red in the <span class="strong"><strong>Raw Image (Script)</strong></span> properties.</p></li><li><p>Save the scene and try it in VR.</p></li></ol></div><p>If you'd like a nicer looking reticle, in the <span class="strong"><strong>Raw Image (Script)</strong></span> properties, populate the <span class="strong"><strong>Texture</strong></span> field with a cursor image. For example, click on the tiny <span class="emphasis"><em>circle</em></span> icon on the far right of the <span class="strong"><strong>Texture</strong></span> field. This opens the <span class="strong"><strong>Select Texture</strong></span> dialog. Find and select a suitable one, such as the <code class="literal">Crosshair</code> image. (A copy of <code class="literal">Crosshair.gif</code> is included with this book.) Just be sure to change the <span class="strong"><strong>Width</strong></span> and <span class="strong"><strong>Height</strong></span> to the size of your image (<code class="literal">Crosshair.gif</code> is 22 x 22 in size) and ensure that the <span class="strong"><strong>Anchor</strong></span> is set to <span class="strong"><strong>middle-center</strong></span>.</p><p>We set its <span class="strong"><strong>Pos Z</strong></span> to <code class="literal">1.0</code> so that the reticle floats in front of you at a one meter distance. A fixed distance cursor is fine in most UI situations. For example, this cursor in fine when you're picking something from a flat canvas that is also at a fixed distance from you.</p><p>However, this is world space. If another object is between you and the reticle, the reticle will be obfuscated.</p><p>Also, if you look at something much farther away, you'll refocus your eyes and have trouble viewing the cursor at the same time. (To emphasize this problem, try moving the cursor closer. For example, if you change the <span class="strong"><strong>Pos Z</strong></span> of the <code class="literal">ReticleCursor</code> to <code class="literal">0.5</code> or less, you might have to go cross-eyed to see it!) To compensate for these issues, we can ray cast and move the cursor to the actual distance of the object that you're looking at, resizing the cursor accordingly so that it appears to stay the same size. Here's a cheap version of this idea:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>With <code class="literal">ReticleCursor</code> selected, click on <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>New Script</strong></span>, name it <code class="literal">CursorPositioner</code>, and click on <span class="strong"><strong>Create</strong></span> and <span class="strong"><strong>Add</strong></span>.</p></li><li><p>Open the script in MonoDevelop by double-clicking on the name.</p></li></ol></div><p>Here's<a id="id262" class="indexterm"></a> the <code class="literal">CursorPositioner.cs</code> script:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using UnityEngine.EventSystems;
using System.Collections;

public class CursorPositioner : MonoBehaviour {
  private float defaultPosZ;

  void Start () {
    defaultPosZ = transform.localPosition.z;
  }

  void Update () {
    Transform camera = Camera.main.transform;
    Ray ray = new Ray (camera.position, camera.rotation * Vector3.forward);
    RaycastHit hit;
    if (Physics.Raycast (ray, out hit)) {
      if (hit.distance &lt;= defaultPosZ) {
        transform.localPosition = new Vector3(0, 0, hit.distance);
      } else {
        transform.localPosition = new Vector3(0, 0, defaultPosZ);
      }
    }
  }
}</pre></div><p>The <span class="strong"><strong>Rect Transform</strong></span> component's <span class="strong"><strong>Pos Z</strong></span> is found in the script in <code class="literal">transform.localPosition</code>. This script changes it to <code class="literal">hit.distance</code> if it's less than the given <span class="strong"><strong>Pos Z</strong></span>. Now, you can also move the reticle to a more comfortable distance, such as <span class="strong"><strong>Pos Z</strong></span> = <code class="literal">2</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>An <a id="id263" class="indexterm"></a>excellent tutorial by <code class="literal">@eVRydayVR</code> shows how to implement both, distance and size compensated world space reticles. You can visit <a class="ulink" href="https://www.youtube.com/watch?v=LLKYbwNnKDg" target="_blank">https://www.youtube.com/watch?v=LLKYbwNnKDg</a>, which is a video titled <span class="emphasis"><em>Oculus Rift DK2 – Unity Tutorial: Reticle</em></span>.</p></div><p>We just implemented our own cursor reticle, but many VR SDKs now also provide cursors (for Oculus Rift, see<a id="id264" class="indexterm"></a> <code class="literal">OVRCrosshair.cs</code>, and in Cardboard, it is a part of the <code class="literal">GazeInputModule.cs</code> utility), although they may or may not include distance and size compensation.</p></div>