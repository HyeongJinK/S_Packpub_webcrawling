<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec62"></a>Optimizing for performance and comfort</h2></div></div><hr /></div><p>Admittedly, this<a id="id487" class="indexterm"></a> chapter has been mostly about level design and is not specifically about virtual reality. However, I didn't want to just give you a pre-built Unity package and say, "Hey, import this so that we can do a walk-through!"</p><p>It should be abundantly clear by now that developing for VR has many facets (pun intended). Once you have a "fancy schmancy" scene created with models, textures, and lighting and you <a id="id488" class="indexterm"></a>provide a thrilling ride-through for your visitors, you'll inevitably need to start thinking about rendering performance, frames per second, latency, and motion sickness.</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p><span class="emphasis"><em>We developers rapidly become immune to all but the most obvious rendering errors, and as a result we are the worst people at testing our own code. It introduces a new and exciting variation of the coder's defense that "it works on my machine" – in this case, "it works for my brain".</em></span></p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution"><span class="emphasis"><em>Tom Forsyth, Oculus</em></span></span></td></tr></table></div><p>There are some very good articles that are written by experts and which outline the strategies and techniques that are used to optimize games for performant VR experiences. At the time of writing this book, here are some good references:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Squeezing Performance out of Your Unity Gear VR Game</em></span>, by Chris Pruett, Oculus, May 12, 2015, <a class="ulink" href="https://developer.oculus.com/blog/squeezing-performance-out-of-your-unity-gear-vr-game/" target="_blank">https://developer.oculus.com/blog/squeezing-performance-out-of-your-unity-gear-vr-game/</a>
</p></li><li style="list-style-type: disc"><p>
<span class="emphasis"><em>12 Performance Tricks for Optimizing VR Apps in Unity</em></span>, by Darshan Shankar, VR developer, May 12, 2015, <a class="ulink" href="http://dshankar.svbtle.com/performance-optimization-for-vr-apps" target="_blank">http://dshankar.svbtle.com/performance-optimization-for-vr-apps</a>
</p></li><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Unity VR Optimisation Hints and Tips</em></span>, Nick Pittom, VR developer "Crystal Rift", October 31, 2014, <a class="ulink" href="http://gamasutra.com/blogs/NickPittom/20141031/229074/Unity_VR_optimisation_hints_and_tips.php" target="_blank">http://gamasutra.com/blogs/NickPittom/20141031/229074/Unity_VR_optimisation_hints_and_tips.php</a>
</p></li><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Optimizing Graphics Performance</em></span>, Unity Manual, <a class="ulink" href="http://docs.unity3d.com/460/Documentation/Manual/OptimizingGraphicsPerformance.html" target="_blank">http://docs.unity3d.com/460/Documentation/Manual/OptimizingGraphicsPerformance.html</a>
</p></li><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Practical Guide to Optimization for Mobiles</em></span>, Unity Manual, <a class="ulink" href="http://docs.unity3d.com/Manual/MobileOptimizationPracticalGuide.html" target="_blank">http://docs.unity3d.com/Manual/MobileOptimizationPracticalGuide.html</a>
</p></li></ul></div><p>Many of the lessons and techniques that are applicable to mobile game development can be applied to VR as well.</p><p>Developing for VR is a moving target—the platform hardware, software SDK, and the Unity 3D engine itself are all changing and improving relatively rapidly. Blog posts and web-based articles can be readily updated or superseded as product improvements and new developer insights emerge. Like the other parts of this book, I need to ask myself whether we can break this down into basic principles that will stay relevant even as the details change.</p><p>In general, there are optimization techniques that focus on the design and/or limitations of each of the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Your game implementation and content</p></li><li style="list-style-type: disc"><p>The Unity engine rendering pipeline</p></li><li style="list-style-type: disc"><p>The target platform hardware and drivers</p></li></ul></div><p>The following discussion is a survey of things that you can do and an introduction for further reading and research.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec93"></a>Optimizing your implementation and content</h3></div></div></div><p>The one <a id="id489" class="indexterm"></a>thing that you have the most control over is the content that you're building. Some decisions that impact performance are the conscious, intentional, and creative ones. Maybe <a id="id490" class="indexterm"></a>you want hyper-realistic graphics with high-fidelity sound because it must be so awesome! Changes may constitute a difficult design compromise. However, it is very likely that with a little creative outside-the-box thinking and experimentation, you can achieve (nearly) identical visual results with a much better performance. Quality is not only how it looks, but also how it feels. So, optimizing for user experience is a fundamental decision.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec10"></a>Simplify your models</h4></div></div></div><p>Minimize<a id="id491" class="indexterm"></a> the number of vertices and faces in your model meshes. Avoid complex meshes. Remove faces that will never be seen, such as the ones inside solid objects. Clean up duplicate vertices and remove doubles. This will most likely be done in the same application that you used to create them in the first place. For example, Blender has the tools for this. Also, there are third-party tools that you can purchase to simplify model meshes. Less than 300 vertices for (nonstatic) meshes are required for dynamic batching (see the following section).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec11"></a>Using texture maps instead of complex meshes</h4></div></div></div><p>If you didn't <a id="id492" class="indexterm"></a>care about the polygon count, you could model surface detail and texture bumps with complex meshes that have many vertices. Of course, that's computationally impractical. Texture maps to the rescue! Consider normal maps versus height maps.</p><p>Normal maps are simple texture maps that are used to fake the lighting of bumps and dents on a model's surface. In some 3D renderings, you can succeed quite well with normal maps, but in VR, it looks just too flat. When you move your head, it appears like a wallpaper.</p><p>Height maps use a texture image to produce a very convincing representation of 3D surface geometry. Height maps are better than a normal map as they not only define the bumpiness of a <a id="id493" class="indexterm"></a>surface, but also provide parallax. However, as a shader, they're computationally expensive. Nevertheless, it's not as costly as doing it with meshes. See <a class="ulink" href="http://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html" target="_blank">http://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec12"></a>Limiting the objects to be drawn</h4></div></div></div><p>Occlusion <a id="id494" class="indexterm"></a>culling disables the rendering of objects when they are not seen by the camera because they are obscured (occluded) by other objects. Read the Unity page, <a class="ulink" href="http://docs.unity3d.com/Manual/OcclusionCulling.html" target="_blank">http://docs.unity3d.com/Manual/OcclusionCulling.html</a>, to learn how to set up occlusion culling in your projects.</p><p>Another way to reduce the details in a scene is by using Global Fog, which is based on distance. Objects further away than the fog limits will not be drawn. See the <span class="emphasis"><em>Project Graphics Settings</em></span>, <a class="ulink" href="http://docs.unity3d.com/Manual/class-GraphicsSettings.html" target="_blank">http://docs.unity3d.com/Manual/class-GraphicsSettings.html</a>.</p><p>Level of detail, or LOD groups, are a great way of simplifying geometry in such a way that things close up are detailed, while those further away are rendered with simpler models. Unity can automatically switch between each LOD geometry as the camera moves closer. See <a class="ulink" href="http://docs.unity3d.com/Manual/class-LODGroup.html" target="_blank">http://docs.unity3d.com/Manual/class-LODGroup.html</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Note</h3><p>The one thing that you have the most control over is the content that you're building. Minimize the number of vertices and faces in your model meshes. Height maps can be an effective substitute for complex geometry. The more you try to reduce the number of objects that need to be rendered, the better.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec13"></a>Lighting and shadow performance</h4></div></div></div><p>You also have a great deal of control over the number of lights, types of lights, their placement, and settings. Use baked lightmaps whenever possible, which pre-calculates the lighting<a id="id495" class="indexterm"></a> effects into a separate image rather than at runtime.</p><p>Use real-time<a id="id496" class="indexterm"></a> shadows sparingly. When an object casts shadows, a shadow map is generated, which will be used to render the other objects that might receive shadows. Shadows have a high rendering overhead and generally require high-end GPU hardware. Read up on it in the Unity manual, which can be found at <a class="ulink" href="http://docs.unity3d.com/Manual/LightPerformance.html" target="_blank">http://docs.unity3d.com/Manual/LightPerformance.html</a>.</p><p>Other techniques, such as light probes (either real-time or baked) and the choice of shaders (and the shader options), can make your scene look really amazing. However, they can also have a significant effect on the performance. Balancing aesthetics and graphics performance is an art and a science that I would love to master some day.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec14"></a>Optimizing your scripts</h4></div></div></div><p>Every <code class="literal">Update()</code> callback <a id="id497" class="indexterm"></a>function that you write is called for each frame. Remove unused updates. Use a state variable (and an <code class="literal">if</code> statement) to turn off the calculations when they are not needed.</p><p>At some point, you may have to use a profiling tool to see how your code is performing under the hood. The Unity <span class="strong"><strong>Profiler</strong></span> (see the following section) will run while your game is in the <span class="strong"><strong>Play Mode</strong></span> and provide details about where exactly it's spending its time and the duration for the same. If the <span class="strong"><strong>Profiler</strong></span> indicates that a large amount of time is spent on the scripts that you've written, you should consider another way to refactor the code so that it's more efficient. Often, this is related to memory management, but it could be math or physics. See <a class="ulink" href="http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html" target="_blank">http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec94"></a>Optimizing for the Unity rendering pipeline</h3></div></div></div><p>There are<a id="id498" class="indexterm"></a> a number of important performance considerations that are specific to how<a id="id499" class="indexterm"></a> Unity does its rendering. Some of these may be common for any graphics engine. Alternatively, they can change in the newer versions of Unity itself, since rendering is a competitive business; algorithms can be replaced and implementations reworked.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"></a>Note</h3><p>A 50-minute presentation from Unity – The Unity Rendering Pipeline (January, 2014) can be seen at <a class="ulink" href="https://unity3d.com/learn/resources/unity-rendering-pipeline" target="_blank">https://unity3d.com/learn/resources/unity-rendering-pipeline</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec15"></a>Life's a batch</h4></div></div></div><p>Perhaps, the <a id="id500" class="indexterm"></a>biggest bang for the buck is a feature in Unity that groups different meshes into a single batch, which is then shoveled into the graphics hardware all at once. This is much faster than sending the meshes separately. Meshes are actually first compiled into an OpenGL vertex buffer object, or a VBO (for more information, visit <a class="ulink" href="http://en.wikipedia.org/wiki/Vertex_Buffer_Object" target="_blank">http://en.wikipedia.org/wiki/Vertex_Buffer_Object</a>), but that's a low-level detail of the rendering pipeline.</p><p>Each batch <a id="id501" class="indexterm"></a>takes one draw call. Reducing the number of draw calls in a scene is more significant than the actual number of vertices or triangles.</p><p>There are two types of<a id="id502" class="indexterm"></a> batching—static batching and dynamic batching.</p><p>First, be sure to enable <span class="strong"><strong>Static Batching</strong></span> and <span class="strong"><strong>Dynamic Batching</strong></span> in <span class="strong"><strong>Player Settings</strong></span>.</p><p>For <a id="id503" class="indexterm"></a>static batching, simply mark the objects as static by checking off the <span class="strong"><strong>Static</strong></span> checkbox in the Unity <span class="strong"><strong>Inspector</strong></span> for each object in the scene. Marking an object static tells Unity that it will never move, animate, or scale. Unity will automatically batch together the meshes that share the same material into a single, large mesh.</p><p>The key here is the caveat—meshes that share the same material. All the meshes in a batch must have the same material settings—the same texture, shader, shader parameters, and the material pointer object.</p><p>How can this be? They're different objects! This can be done by combining multiple textures into a single macro-texture file or TextureAtlas and then UV-mapping as many models as will fit. It's a lot like a sprite image used for 2D and web graphics. Sound difficult? There are third-party tools, such as Pro Draw Call Optimize, that help you build these.</p><p>When managing textures in scripts, use <code class="literal">Renderer.sharedMaterial</code> rather than <code class="literal">Renderer.material</code> to avoid creating duplicate materials. Objects receiving a duplicate material will opt out of the batch.</p><p>You may recall that in the <span class="strong"><strong>Gallery</strong></span> project earlier in this chapter, we created separate materials for each <code class="literal">ArtworkRig Image</code> in a script. If tagged <span class="strong"><strong>Static</strong></span>, they will not be batched. However, it turns out that it's fine because the texture is a full-resolution photographic image—too big to merge with other textures anyway. The point is that sometimes, it's appropriate to worry about batching, and sometimes, it's not.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Note</h3><p>Marking an object <span class="strong"><strong>Static</strong></span> tells Unity that it will never move, animate, or scale. Unity will automatically batch together meshes that share the same material into a single large VBO, which is then shoveled into the graphics hardware all at once.</p></div><p>Dynamic batching is<a id="id504" class="indexterm"></a> similar to static batching. For objects that are not marked <span class="strong"><strong>Static</strong></span>, Unity will still try to batch them, albeit it will be a slower process since it needs to think about it frame by frame (the CPU cost). The shared material requirement still holds, as well as other restrictions such as vertex count (less than 300 vertices) and uniform <span class="strong"><strong>Transform Scale</strong></span> rules. See <a class="ulink" href="http://docs.unity3d.com/Manual/DrawCallBatching.html" target="_blank">http://docs.unity3d.com/Manual/DrawCallBatching.html</a>.</p><p>Currently, only <span class="strong"><strong>Mesh Renderers</strong></span> and <span class="strong"><strong>Particle Systems</strong></span> are batched. This means that skinned meshes, cloth, trail renderers, and other types of rendering components are not.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec16"></a>Multipass pixel filling</h4></div></div></div><p>Another <a id="id505" class="indexterm"></a>concern in the rendering pipeline is sometimes referred to as the pixel fillrate. If you think about it, the ultimate goal of rendering is to fill each pixel on the display device with the correct color value. If it has to paint any pixels more than once, that's more costly. For example, watch out for transparent particle effects such as smoke that touch many pixels with mostly transparent quads.</p><p>Actually for VR, Unity paints into a frame buffer memory that is larger than the physical display dimensions, which is then post-processed for ocular distortion correction – barrel effect and chromatic aberration correction – color separation, before getting tossed onto the HMD display. In fact, there may be multiple overlay buffers that get composited before the post-processing.</p><p>This multipass pixel filling<a id="id506" class="indexterm"></a> is how some advanced renderers work. Lighting and material effects such as multiple lights, dynamic shadows, and transparency (<span class="strong"><strong>Transparent</strong></span> and <span class="strong"><strong>Fade Render</strong></span> modes) are implemented in this way. Unity 5 Specular Shader as well. Basically, all the good stuff!</p><p>VBO batches with materials that require multipass pixel filling get submitted multiple times, thus increasing the net number of draw calls. Depending on your project, you may choose to either optimize the heck out of it and avoid multipass pixel filling altogether, or carefully curate the scenes with an understanding of what should have a high performance and what should have a high fidelity.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"></a>Note</h3><p>Depending on your project, you may choose to optimize the heck out of it and avoid multi-pass pixel filling altogether, or carefully curate the scenes with an understanding of which objects should have a high performance versus high fidelity.</p></div><p>Multipass can be avoided if you precalculate the lighting and shadows using baked lightmaps. It's the Unity 4.X way. Just use <span class="strong"><strong>Legacy Shaders/Lightmapped/Diffuse</strong></span> (see <a class="ulink" href="http://docs.unity3d.com/Manual/LightmapParameters.html" target="_blank">http://docs.unity3d.com/Manual/LightmapParameters.html</a>). However, if you bake, you lose Unity 5 software's awesome new physically-based shaders (<a class="ulink" href="http://blogs.unity3d.com/2015/02/18/working-with-physically-based-shading-a-practical-approach/" target="_blank">http://blogs.unity3d.com/2015/02/18/working-with-physically-based-shading-a-practical-approach/</a>).</p><p>Nevertheless, you can use <span class="strong"><strong>Light Probes</strong></span> to inexpensively simulate dynamic lighting of your dynamic objects. As the Unity manual states, "<span class="strong"><strong>Light Probes</strong></span> are baked cubemaps that store information about direct, indirect, and even emissive light at various points in your scene. As a <a id="id507" class="indexterm"></a>dynamic object moves, it interpolates samples of the nearby light probes to approximate the lighting at that specific position. This is a cheap way of simulating realistic lighting on dynamic objects without using expensive real-time lights". Visit <a class="ulink" href="http://docs.unity3d.com/Manual/LightProbes.html" target="_blank">http://docs.unity3d.com/Manual/LightProbes.html</a> for more information.</p><p>Set the total number of simultaneous lights in <span class="strong"><strong>Quality Settings</strong></span> to one. "<span class="emphasis"><em>The closest light will be rendered per-pixel, and surrounding lights will be calculated using spherical harmonics"</em></span>, Chris Pruett of Oculus explains. Alternatively, you can even drop all the pixel lights and rely on Light Probes.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec17"></a>Other rendering tips</h4></div></div></div><p>Nick Pittom<a id="id508" class="indexterm"></a> recommends that you should create textures at a 2048 resolution and import to the default setting of 1,024. This speeds up the renderer.</p><p>Another tip from Darshan Shankar when discussing GearVR is that when you are rendering to Android with quality settings for no shadows, you need to switch targets to the PC, bake the lighting with high resolution and the hard and soft shadows enabled, and then switch back to Android. See <a class="ulink" href="http://dshankar.svbtle.com/developing-crossplatform-vr-apps-for-oculus-rift-and-gearvr" target="_blank">http://dshankar.svbtle.com/developing-crossplatform-vr-apps-for-oculus-rift-and-gearvr</a> for more information.</p><p>What tips can you find or recommend? Maybe someone should start a forum or something! Visit <a class="ulink" href="http://forum.unity3d.com/" target="_blank">http://forum.unity3d.com/</a> for more information.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec95"></a>Optimizing for the target hardware and drivers</h3></div></div></div><p>Hardware <a id="id509" class="indexterm"></a>architectures are evolving towards performance that benefits graphics pipelines of virtual reality (and augmented reality). VR introduces requirements that weren't so important for traditional video gaming. For example, latency and dropped frames (where rendering a frame takes longer than the refresh rate) took a back seat to high-fidelity triple-AAA rendering capabilities. VR needs to render each frame in time and do it twice—once for each eye. Driven by the requirements of this emerging industry, semiconductor and hardware manufacturers are building new and improved architectures, which will inevitably impact how content developers think about optimization.</p><p>That said, you should develop and optimize for the lower spec machine or device that you want to target. If such optimizations necessitate undesirable compromises, consider separate versions of the game for high- versus low-end platforms. VR device manufacturers have started publishing minimum/recommended hardware specifications, which take much of the guesswork out of it.</p><p>Learn <a id="id510" class="indexterm"></a>the Unity <span class="strong"><strong>Quality</strong></span> settings (by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Quality</strong></span>) that can be configured on a per-target-platform basis. Start with the recommendations of your device manufacturer (such as Oculus) as regards the suggested values, and adjust as needed. For example, you can adjust parameters such as <span class="strong"><strong>Pixel Light Count</strong></span>, <span class="strong"><strong>Anti Aliasing</strong></span>, and <span class="strong"><strong>Soft Particles</strong></span>.</p><p>For instance, for mobile VR, it is recommended that you tune for CPU-bound versus GPU-bound usage. Some games will make the CPU work harder, others will impact the GPU. Normally, you should favor CPU over GPU. The Oculus Mobile SDK (GearVR) has an API that is used to throttle the CPU and GPU to control heat and battery drain.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec96"></a>Unity Profiler</h3></div></div></div><p>Optimizing can <a id="id511" class="indexterm"></a>be a lot of work, and a steep learning curve is required to get to grips with it. The good news is that it can be accomplished incrementally. Tackle the more obvious, bigger bang-for-the-buck things first, especially the ones that cause little or no visual degradation.</p><p>The Unity editor includes two built-in tools to assess performance—the <span class="strong"><strong>Stats</strong></span> pane and the <span class="strong"><strong>Profiler</strong></span> pane.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Note</h3><p>While profiling and optimizing, write down (or take a screenshot of) the stats and label them, perhaps in a spreadsheet, so that you can keep a log of your progress and measure the effectiveness of each technique that you try.</p></div><p>In the <span class="strong"><strong>Game</strong></span> panel, you can enable the <span class="strong"><strong>Stats</strong></span> pane, as shown in the following screenshot, which displays (among other things) the number of batches, triangles, vertices, and runtime frames per second. (See <a class="ulink" href="http://docs.unity3d.com/Manual/RenderingStatistics.html" target="_blank">http://docs.unity3d.com/Manual/RenderingStatistics.html</a>):</p><div class="mediaobject"><img src="/graphics/9781783988556/graphics/B04781_08_18.jpg" /></div><p>The<a id="id512" class="indexterm"></a> Unity <span class="strong"><strong>Profiler</strong></span> option is a performance instrumentation tool that reports how much time is spent in various areas of your game, including rendering and scripts. It records the statistics over time during gameplay and shows them in a timeline graph. Clicking lets you drill down into the details. See <a class="ulink" href="http://docs.unity3d.com/Manual/Profiler.html" target="_blank">http://docs.unity3d.com/Manual/Profiler.html</a>. Pictured in the following screenshot is a profile of the classic Oculus Tuscany demo scene:</p><div class="mediaobject"><img src="/graphics/9781783988556/graphics/B04781_08_19.jpg" /></div><p>Before you<a id="id513" class="indexterm"></a> start optimizing, get a handle on your performance of various camera locations in the scene for various animation and action sequences and different scenes. Write down (or take a screenshot of) the stats and label them, perhaps in a spreadsheet, so that you can keep a log of your progress and measure the effectiveness of each optimization technique that you try.</p></div></div>