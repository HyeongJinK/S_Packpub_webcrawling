<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>Pursuing and evading</h2></div></div><hr /></div><p>Pursuing and evading are <a id="id6" class="indexterm"></a>great behaviors to start with because they rely on the <a id="id7" class="indexterm"></a>most basic behaviors and extend their functionality by predicting the target's next step.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec17"></a>Getting ready</h3></div></div></div><p>We need a couple of basic behaviors called <code class="literal">Seek</code> and <code class="literal">Flee</code>; place them right after the <code class="literal">Agent</code> class in the scripts' execution order.</p><p>The following is the code for the <code class="literal">Seek</code> behaviour:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class Seek : AgentBehaviour
{
    public override Steering GetSteering()
    {
        Steering steering = new Steering();
        steering.linear = target.transform.position - transform.position;
        steering.linear.Normalize();
        steering.linear = steering.linear * agent.maxAccel;
        return steering;
    }
}</pre></div><p>Also, we need to <a id="id8" class="indexterm"></a>implement the <code class="literal">Flee</code> behavior:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class Flee : AgentBehaviour
{
    public override Steering GetSteering()
    {
        Steering steering = new Steering();
        steering.linear = transform.position - target.transform.position;
        steering.linear.Normalize();
        steering.linear = steering.linear * agent.maxAccel;
        return steering;
    }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec18"></a>How to do it...</h3></div></div></div><p><code class="literal">Pursue</code> and <code class="literal">Evade</code> are <a id="id9" class="indexterm"></a>essentially the same algorithm but differ in terms of the base class they derive from:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">Pursue</code> class, derived from <code class="literal">Seek</code>, and add the attributes for the prediction:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Pursue <span class="strong"><strong>: Seek</strong></span>
{
    public float maxPrediction;
    private GameObject targetAux;
    private Agent targetAgent;
}</pre></div></li><li><p>Implement the <code class="literal">Awake</code> function in order to set up everything according to the real target:</p><div class="informalexample"><pre class="programlisting">public override void Awake()
{
    base.Awake();
    targetAgent = target.GetComponent&lt;Agent&gt;();
    targetAux = target;
    target = new GameObject();
}</pre></div></li><li><p>As well as <a id="id10" class="indexterm"></a>implement the <code class="literal">OnDestroy</code> function, to properly handle the internal object:</p><div class="informalexample"><pre class="programlisting">void OnDestroy ()
{
    Destroy(targetAux);
}</pre></div></li><li><p>Finally, implement <a id="id11" class="indexterm"></a>the <code class="literal">GetSteering</code> function:</p><div class="informalexample"><pre class="programlisting">public override Steering GetSteering()
{
    Vector3 direction = targetAux.transform.position - transform.position;
    float distance = direction.magnitude;
    float speed = agent.velocity.magnitude;
    float prediction;
    if (speed &lt;= distance / maxPrediction)
        prediction = maxPrediction;
    else
        prediction = distance / speed;
    target.transform.position = targetAux.transform.position;
    target.transform.position += targetAgent.velocity * prediction;
    return base.GetSteering();
}</pre></div></li><li><p>To create the <code class="literal">Evade</code> behavior, the procedure is just the same, but it takes into account that <code class="literal">Flee</code> is the parent class:</p><div class="informalexample"><pre class="programlisting">public class Evade <span class="strong"><strong>: Flee</strong></span>
{
    // everything stays the same
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec19"></a>How it works...</h3></div></div></div><p>These behaviors rely on <code class="literal">Seek</code> and <code class="literal">Flee</code> and take into consideration the target's velocity in order to predict <a id="id12" class="indexterm"></a>where it will go next; they aim at that position <a id="id13" class="indexterm"></a>using an internal extra object.</p></div></div>