<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec35"></a>Planning navigation in several frames: time-sliced search</h2></div></div><hr /></div><p>When <a id="id133" class="indexterm"></a>dealing with large graphs, computing paths can <a id="id134" class="indexterm"></a>take a lot of time, even halting the game for a couple of seconds. This could ruins its overall experience, to say the least. Luckily enough there are methods to avoid this.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note04"></a>Note</h3><p>This recipe is built on top of the principle of using coroutines as a method to keep the game running smoothly while finding a path in the background; some knowledge about coroutines is required.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec116"></a>Getting ready</h3></div></div></div><p>We'll learn how to implement path-finding techniques using coroutines by refactoring the A* algorithm learned previously, but we will handle its signature as a different function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec117"></a>How to do it...</h3></div></div></div><p>Even though this recipe is only defining a function, please take into consideration the comments in the code to understand the indentation and code flow more effectively:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Modify the <code class="literal">Graph</code> class and add a couple of member variables. One for storing the path and the other to know whether the coroutine has finished:</p><div class="informalexample"><pre class="programlisting">public List&lt;Vertex&gt; path;
public bool isFinished;</pre></div></li><li><p>Declare the member function:</p><div class="informalexample"><pre class="programlisting">public IEnumerator GetPathInFrames(GameObject srcObj, GameObject dstObj, Heuristic h = null)
{
    //next steps
}</pre></div></li><li><p>Include the following member variables at the beginning:</p><div class="informalexample"><pre class="programlisting">isFinished = false;
path = new List&lt;Vertex&gt;();
if (srcObj == null || dstObj == null)
{
    path = new List&lt;Vertex&gt;();
    isFinished = true;
    yield break;
}</pre></div></li><li><p>Modify the loop to traverse the graph:</p><div class="informalexample"><pre class="programlisting">while (frontier.Count != 0)
{
    // changes over A*
<span class="strong"><strong>    yield return null;</strong></span>
    //////////////////////////////
    node = frontier.Remove();</pre></div></li><li><p>Also, include <a id="id135" class="indexterm"></a>the other path-retrieval <a id="id136" class="indexterm"></a>validations:</p><div class="informalexample"><pre class="programlisting">if (ReferenceEquals(node.vertex, dst))
{
    // changes over A*
<span class="strong"><strong>    path = BuildPath(src.id, node.vertex.id, ref previous);</strong></span>
<span class="strong"><strong>    break;</strong></span>
    //////////////////////////////
}</pre></div></li><li><p>Finally, reset the proper values and return control at the end of the function, after closing the main loop:</p><div class="informalexample"><pre class="programlisting">isFinished = true;
yield break;</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec118"></a>How it works...</h3></div></div></div><p>The yield return null statement inside the main loop works as a flag for delivering control to the higher-level functions, thus computing each new loop in each new frame using Unity's internal multi-tasking system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec119"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Finding the best-promising path with A*</em></span> recipe</p></li></ul></div><p>For further information about Coroutines and more examples, please refer to the official documentation <a id="id137" class="indexterm"></a>available online at:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html" target="_blank">http://docs.unity3d.com/Manual/Coroutines.html</a></p></li><li style="list-style-type: disc"><p><a class="ulink" href="https://unity3d.com/learn/tutorials/modules/intermediate/scripting/coroutines" target="_blank">https://unity3d.com/learn/tutorials/modules/intermediate/scripting/coroutines</a></p></li></ul></div></div></div>