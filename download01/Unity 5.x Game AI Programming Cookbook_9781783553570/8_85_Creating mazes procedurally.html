<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec85"></a>Creating mazes procedurally</h2></div></div><hr /></div><p>This is a completely <a id="id388" class="indexterm"></a>new recipe oriented toward having fun while creating maps and levels procedurally. The main recipe works by creating a maze completely procedurally. Furthermore, we will explore a gray area, where both level design and procedurally generated content meet.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec290"></a>Getting ready</h3></div></div></div><p>In this recipe, it is important to understand the concepts of Binary Space Partitioning and the Breadth-first Search algorithm learned in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Navigation</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec291"></a>How to do itâ€¦</h3></div></div></div><p>We will implement two <a id="id389" class="indexterm"></a>classes, one for the nodes to be partitioned and one for holding all the nodes and the maze representation, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">BSPNode</code> class and its members:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

[System.Serializable]
public class BSPNode
{
    public Rect rect;
    public BSPNode nodeA;
    public BSPNode nodeB;
}</pre></div></li><li><p>Implement the class constructor:</p><div class="informalexample"><pre class="programlisting">public BSPNode(Rect rect)
{
    this.rect = rect;
    nodeA = null;
    nodeB = null;
}</pre></div></li><li><p>Define the function for splitting the node into two subregions:</p><div class="informalexample"><pre class="programlisting">public void Split(float stopArea)
{
    // next steps
}</pre></div></li><li><p>Validate its base case:</p><div class="informalexample"><pre class="programlisting">if (rect.width * rect.height &gt;= stopArea)
    return;</pre></div></li><li><p>Initialize all the necessary function variables:</p><div class="informalexample"><pre class="programlisting">bool vertSplit = Random.Range(0, 1) == 1;
float x, y, w, h;
Rect rectA, rectB;</pre></div></li><li><p>Compute the horizontal split:</p><div class="informalexample"><pre class="programlisting">if (!vertSplit)
{
    x = rect.x;
    y = rect.y;
    w = rect.width;
    h = rect.height / 2f;
    rectA = new Rect(x, y, w, h);
    y += h;
    rectB = new Rect(x, y, w, h);
}</pre></div></li><li><p>Compute the <a id="id390" class="indexterm"></a>vertical split:</p><div class="informalexample"><pre class="programlisting">else
{
    x = rect.x;
    y = rect.y;
    w = rect.width / 2f;
    h = rect.height;
    rectA = new Rect(x, y, w, h);
    x += w;
    rectB = new Rect(x, y, w, h);
}</pre></div></li><li><p>Create the class for handling the dungeon and declare all its member variables:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections.Generic;

public class Dungeon : MonoBehaviour
{
    public Vector2 dungeonSize;
    public float roomAreaToStop;
    public float middleThreshold;
    public GameObject floorPrefab;

    private BSPNode root;
    private List&lt;BSPNode&gt; nodeList;
}</pre></div></li><li><p>Implement the function for splitting:</p><div class="informalexample"><pre class="programlisting">public void Split()
{
    float x, y, w, h;
    x = dungeonSize.x / 2f * -1f;
    y = dungeonSize.y / 2f * -1f;
    w = dungeonSize.x;
    h = dungeonSize.y;
    Rect rootRect = new Rect(x, y, w, h);
    root = new BSPNode(rootRect);
}</pre></div></li><li><p>Implement the <a id="id391" class="indexterm"></a>function for drawing the maze using the nodes:</p><div class="informalexample"><pre class="programlisting">public void DrawNode(BSPNode n)
{
    GameObject go = Instantiate(floorPrefab) as GameObject;
    Vector3 position = new Vector3(n.rect.x, 0f, n.rect.y);
    Vector3 scale = new Vector3(n.rect.width, 1f, n.rect.height);
    go.transform.position = position;
    go.transform.localScale = scale;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec292"></a>How it works...</h3></div></div></div><p>We divided the maze into two big data structures. The logical side that is handled via the BSP nodes and the visual and construction representation handled by the main <code class="literal">Maze</code> class. The idea behind this representation is to divide the space twice as many times as necessary until a condition is met. This is the Binary Space Partitioning.</p><p>We then created rooms for the leave nodes, and finally, we connected the regions on the tree from the bottom to the top (leaves to root).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec293"></a>There's more...</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>There's another technique that is a little bit simpler, but it requires more input from the art or level-design team. It creates a level with BFS using random pieces in a list and connects them.</p></li><li style="list-style-type: disc"><p>The pieces can be rotated.</p></li><li style="list-style-type: disc"><p>It can be improved by using the random function learned previously and tuning the pieces' placement on the list.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec294"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Finding the shortest path in a grid with BFS</em></span> recipe in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Navigation</em></span></p></li></ul></div></div></div>