<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>Creating the behavior template</h2></div></div><hr /></div><p>Before creating <a id="id0" class="indexterm"></a>our behaviors, we need to code the stepping stones that help us not only to create only intelligent movement, but also to build a modular system to change and add these behaviors. We will create custom data types and base classes for most of the algorithms covered in this chapter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec12"></a>Getting ready</h3></div></div></div><p>Our first step is to remember the update function order of execution:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Update</code></p></li><li style="list-style-type: disc"><p><code class="literal">LateUpdate</code></p></li></ul></div><p>Also, it's important to refresh so that we can select the scripts' order of execution. For our behaviors to work as intended, the rules for ordering are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Agent scripts</p></li><li style="list-style-type: disc"><p>Behavior scripts</p></li><li style="list-style-type: disc"><p>Behaviors or scripts based on the previous ones</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781783553570/graphics/3561_01_01.jpg" /><div class="caption"><p>This is an example of how to arrange the order of execution for the movement scripts. We need to pursue derives from Seek, which derives from AgentBehaviour.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec13"></a>How to do it...</h3></div></div></div><p>We need to <a id="id1" class="indexterm"></a>create three classes: <code class="literal">Steering</code>, <code class="literal">AgentBehaviour</code>, and <code class="literal">Agent</code>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p><code class="literal">Steering</code> serves as a custom data type for storing the movement and rotation of the agent:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class Steering
{
    public float angular;
    public Vector3 linear;
    public Steering ()
    {
        angular = 0.0f;
        linear = new Vector3();
    }
}</pre></div></li><li><p>Create the <code class="literal">AgentBehaviour</code> class, which is <a id="id2" class="indexterm"></a>the template class for most of the behaviors covered in this chapter:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class AgentBehaviour : MonoBehaviour
{
    public GameObject target;
    protected Agent agent;
    public virtual void Awake ()
    {
        agent = gameObject.GetComponent&lt;Agent&gt;();
    }
    public virtual void Update ()
    {
            agent.SetSteering(GetSteering());
    }
    public virtual Steering GetSteering ()
    {
        return new Steering();
    }
}</pre></div></li><li><p>Finally, <code class="literal">Agent</code> is the main component, and it makes use of behaviors in order to create intelligent movement. Create the file and its barebones:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class Agent : MonoBehaviour
{
    public float maxSpeed;
    public float maxAccel;
    public float orientation;
    public float rotation;
    public Vector3 velocity;
    protected Steering steering;
    void Start ()
    {
        velocity = Vector3.zero;
        steering = new Steering();
    }
    public void SetSteering (Steering steering)
    {
        this.steering = steering;
    }
}</pre></div></li><li><p>Next, we code <a id="id3" class="indexterm"></a>the <code class="literal">Update</code> function, which handles the movement according to the current value:</p><div class="informalexample"><pre class="programlisting">public virtual void Update ()
{
    Vector3 displacement = velocity * Time.deltaTime;
    orientation += rotation * Time.deltaTime;
    // we need to limit the orientation values
    // to be in the range (0 â€“ 360)
    if (orientation &lt; 0.0f)
        orientation += 360.0f;
    else if (orientation &gt; 360.0f)
        orientation -= 360.0f;
    transform.Translate(displacement, Space.World);
    transform.rotation = new Quaternion();
    transform.Rotate(Vector3.up, orientation);
}</pre></div></li><li><p>Finally, we implement the <code class="literal">LateUpdate</code> function, which takes care of updating the steering for the next frame according to the current frame's calculations:</p><div class="informalexample"><pre class="programlisting">public virtual void LateUpdate ()
{
    velocity += steering.linear * Time.deltaTime;
    rotation += steering.angular * Time.deltaTime;
    if (velocity.magnitude &gt; maxSpeed)
    {
        velocity.Normalize();
        velocity = velocity * maxSpeed;
    }
    if (steering.angular == 0.0f)
    {
        rotation = 0.0f;
    }
    if (steering.linear.sqrMagnitude == 0.0f)
    {
        velocity = Vector3.zero;
    }
    steering = new Steering();
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec14"></a>How it works...</h3></div></div></div><p>The idea is to be able to delegate the movement's logic inside the <code class="literal">GetSteering()</code> function on the behaviors that we will later build, simplifying our agent's class to a main calculation based on those.</p><p>Besides, we are guaranteed to set the agent's steering value before it is used thanks to Unity script and function execution orders.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec15"></a>There's more...</h3></div></div></div><p>This is a component-based approach, which means that we have to remember to always have an <code class="literal">Agent</code> script attached to <code class="literal">GameObject</code> for the behaviors to work as expected.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec16"></a>See also</h3></div></div></div><p>For further information <a id="id4" class="indexterm"></a>on Unity's game loop and the execution order of <a id="id5" class="indexterm"></a>functions and scripts, please refer to the official documentation available online at:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><a class="ulink" href="http://docs.unity3d.com/Manual/ExecutionOrder.html" target="_blank">http://docs.unity3d.com/Manual/ExecutionOrder.html</a></p></li><li style="list-style-type: disc"><p><a class="ulink" href="http://docs.unity3d.com/Manual/class-ScriptExecution.html" target="_blank">http://docs.unity3d.com/Manual/class-ScriptExecution.html</a></p></li></ul></div></div></div>