<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec66"></a>Working with the game-tree class</h2></div></div><hr /></div><p>The game <a id="id296" class="indexterm"></a>state can be represented in a lot of different ways, but you will learn how to create extendible classes in order to use the high-level board AI algorithms for different circumstances.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec225"></a>Getting ready…</h3></div></div></div><p>It is important to be clear on object-oriented programming, specifically on inheritance and polymorphism. This is because we'll be creating generic functions that can be applied to a number of board game decisions and then writing specific subclasses that inherit and further specify these functions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec226"></a>How to do it…</h3></div></div></div><p>We will build two <a id="id297" class="indexterm"></a>classes in order to represent game-tree with the help of the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the abstract class <code class="literal">Move</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public abstract class Move
{
    
}</pre></div></li><li><p>Create the pseudo-abstract class <code class="literal">Board</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Board
{
    protected int player;
    //next steps here
}</pre></div></li><li><p>Define the default constructor:</p><div class="informalexample"><pre class="programlisting">public Board()
{
    player = 1;
}</pre></div></li><li><p>Implement the virtual function for retrieving the next possible moves:</p><div class="informalexample"><pre class="programlisting">public virtual Move[] GetMoves()
{
    return new Move[0];
}</pre></div></li><li><p>Implement the virtual function for playing a move on the board:</p><div class="informalexample"><pre class="programlisting">public virtual Board MakeMove(Move m)
{
    return new Board();
}</pre></div></li><li><p>Define the virtual function for testing whether the game is over:</p><div class="informalexample"><pre class="programlisting">public virtual bool IsGameOver()
{
    return true;
}</pre></div></li><li><p>Implement the virtual function for retrieving the current player:</p><div class="informalexample"><pre class="programlisting">public virtual int GetCurrentPlayer()
{
    return player;
}</pre></div></li><li><p>Implement the <a id="id298" class="indexterm"></a>virtual function for testing the board's value for a given player:</p><div class="informalexample"><pre class="programlisting">public virtual float Evaluate(int player)
{
    return Mathf.NegativeInfinity;
}</pre></div></li><li><p>Also, implement the virtual function for testing the board's value for the current player:</p><div class="informalexample"><pre class="programlisting">public virtual float Evaluate()
{
    return Mathf.NegativeInfinity;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec227"></a>How it works…</h3></div></div></div><p>We have created the stepping stones for the next algorithms. The <code class="literal">Board</code> class works as a node in order to represent the current game state, and the <code class="literal">Move</code> class represents an edge. When the <code class="literal">GetMoves</code> function is called, we model the function for getting the edges in order to reach the neighbors of the current game state.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec228"></a>See also</h3></div></div></div><p>For more theoretical insights about the techniques in this chapter, please refer to Russel and Norvig's <span class="emphasis"><em>Artificial Intelligence: a Modern Approach</em></span> (adversarial search) and Ian Millington's <span class="emphasis"><em>Artificial Intelligence for Games</em></span> (board games).</p></div></div>