<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec55"></a>Improving influence with convolution filters</h2></div></div><hr /></div><p>Convolution <a id="id223" class="indexterm"></a>filters are usually applied via image processing software, but we can use the same principles to change a grid's influence <a id="id224" class="indexterm"></a>given a unit's value and its surroundings. In this recipe, we will explore a couple of algorithms to modify a grid using matrix filters.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec187"></a>Getting ready</h3></div></div></div><p>It is important to have grasped the concept of influence maps before implementing this recipe, so that you can understand the context in which it is applied.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec188"></a>How to do it…</h3></div></div></div><p>We will <a id="id225" class="indexterm"></a>implement the <code class="literal">Convolve</code> function:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Declare the <code class="literal">Convolve</code> function:</p><div class="informalexample"><pre class="programlisting">public static void Convolve(
        float[,] matrix,
        ref float[,] source,
        ref float[,] destination)
{
    // next steps
}</pre></div></li><li><p>Initialize the variables for handling the computations and traversal of arrays:</p><div class="informalexample"><pre class="programlisting">int matrixLength = matrix.GetLength(0);
int size = (int)(matrixLength – 1) / 2;
int height = source.GetLength(0);
int width = source.GetLength(1);
int I, j, k, m;</pre></div></li><li><p>Create the first loop for iterating over the destination and source grids:</p><div class="informalexample"><pre class="programlisting">for (i = 0; i &lt; width–- size; i++)
{
    for (j = 0; j &lt; height–- size; j++)
    {
        // next steps
    }
}</pre></div></li><li><p>Implement the second loop for iterating over the filter matrix:</p><div class="informalexample"><pre class="programlisting">destination[i, j] = 0f;
for (k = 0; k &lt; matrixLength; k++)
{
    for (m = 0; m &lt; matrixLength; m++)
    {
        int row = i + k–- size;
        int col = j + m–- size;
        float aux = source[row, col] * matrix[k,m];
        destination[i, j] += aux;
    }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec189"></a>How it works…</h3></div></div></div><p>We create a new grid to be swapped with the original source grid after the application of the matrix filter on each position. Then, we iterate over each position that is to be created as a destination grid and compute its result, taking the original grid's value and applying the matrix filter to it.</p><p>It is <a id="id226" class="indexterm"></a>important to note that the matrix filter must <a id="id227" class="indexterm"></a>be an odd-square array for the algorithm to work as expected.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec190"></a>There is more…</h3></div></div></div><p>The following <code class="literal">ConvolveDriver</code> function helps us iterate using the <code class="literal">Convolve</code> function implemented previously:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Declare the <code class="literal">ConvolveDriver</code> function:</p><div class="informalexample"><pre class="programlisting">public static void ConvolveDriver(
        float[,] matrix,
        ref float[,] source,
        ref float[,] destination,
        int iterations)
{
    // next steps
}</pre></div></li><li><p>Create the auxiliary variables for holding the grids:</p><div class="informalexample"><pre class="programlisting">float[,] map1;
float[,] map2;
int i;</pre></div></li><li><p>Swap the maps, regardless of whether the iterations are odd or even:</p><div class="informalexample"><pre class="programlisting">if (iterations % 2 == 0)
{
    map1 = source;
    map2 = destination;
}
else
{
    destination = source;
    map1 = destination;
    map2 = source;
}</pre></div></li><li><p>Apply the <a id="id228" class="indexterm"></a>previous function during the iterations and swap:</p><div class="informalexample"><pre class="programlisting">for (i = 0; i &lt; iterations; i++)
{
    Convolve(matrix, ref source, ref destination);
    float[,] aux = map1;
    map1 = map2;
    map2 = aux;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec191"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <a id="id229" class="indexterm"></a>
<span class="emphasis"><em>Introducing influence maps</em></span> recipe</p></li></ul></div></div></div>