<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec47"></a>Handling formations</h2></div></div><hr /></div><p>This is a key <a id="id184" class="indexterm"></a>algorithm for creating flocks or a group of military agents. It is designed to be flexible enough to give you the chance to create your own formations.</p><p>The end result from this recipe will be a set of target positions and rotations for each agent in the formation. Then, it is up to you to create the necessary algorithms to move the agent to the previous targets.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note05"></a>Note</h3><p>We can use the movement algorithms learnt in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Movement</em></span>, in order to target those positions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec155"></a>Getting ready</h3></div></div></div><p>We will need to create three base classes that are the data types to be used by the high-level classes and algorithms. The <code class="literal">Location</code> class is very similar to the <code class="literal">Steering</code> class and is used to define a target position and rotation given the formation's anchor point and rotation. The <code class="literal">SlogAssignment</code> class is a data type to match a list's indices and agents. Finally, the <code class="literal">Character</code> class component holds the target <code class="literal">Location</code> class.</p><p>The following is the code for the <code class="literal">Location</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Location
{
    public Vector3 position;
    public Quaternion rotation;

    public Location ()
    {
        position = Vector3.zero;
        rotation = Quaternion.identity;
    }

    public Location(Vector3 position, Quaternion rotation)
    {
        this.position = position;
        this.rotation = rotation;
    }
}</pre></div><p>The following is the code for the <code class="literal">SlotAssignment</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class SlotAssignment
{
    public int slotIndex;
    public GameObject character;

    public SlotAssignment()
    {
        slotIndex = -1;
        character = null;
    }
}</pre></div><p>The following is <a id="id185" class="indexterm"></a>the code for the <code class="literal">Character</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Character : MonoBehaviour
{
    public Location location;

    public void SetTarget (Location location)
    {
        this.location = location;
    }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec156"></a>How to do it…</h3></div></div></div><p>We will implement two classes—<code class="literal">FormationPattern</code> and <code class="literal">FormationManager</code>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">FormationPattern</code> pseudo-abstract class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class FormationPattern: MonoBehaviour
{
    public int numOfSlots;
    public GameObject leader;
}</pre></div></li><li><p>Implement the <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">void Start()
{
    if (leader == null)
        leader = transform.gameObject;
}</pre></div></li><li><p>Define the function for getting the position for a given slot:</p><div class="informalexample"><pre class="programlisting">public virtual Vector3 GetSlotLocation(int slotIndex)
{
    return Vector3.zero;
}</pre></div></li><li><p>Define the function for retrieving whether a given number of slots is supported by the formation:</p><div class="informalexample"><pre class="programlisting">public bool SupportsSlots(int slotCount)
{
    return slotCount &lt;= numOfSlots;
}</pre></div></li><li><p>Implement the <a id="id186" class="indexterm"></a>function for setting an offset in the locations, if necessary:</p><div class="informalexample"><pre class="programlisting">public virtual Location GetDriftOffset(List&lt;SlotAssignment&gt; slotAssignments)
{
    Location location = new Location();
    location.position = leader.transform.position;
    location.rotation = leader.transform.rotation;
    return location;
}</pre></div></li><li><p>Create the appropriate class for managing the formation:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class FormationManager : MonoBehaviour
{
    public FormationPattern pattern;
    private List&lt;SlotAssignment&gt; slotAssignments;
    private Location driftOffset;
}</pre></div></li><li><p>Implement the <code class="literal">Awake</code> function:</p><div class="informalexample"><pre class="programlisting">void Awake()
{
    slotAssignments = new List&lt;SlotAssignment&gt;();
}</pre></div></li><li><p>Define the function for updating the slot assignments given the list's order:</p><div class="informalexample"><pre class="programlisting">public void UpdateSlotAssignments()
{
    for (int i = 0; i &lt; slotAssignments.Count; i++)
    {
        slotAssignments[i].slotIndex = i;
    }
    driftOffset = pattern.GetDriftOffset(slotAssignments);
}</pre></div></li><li><p>Implement the <a id="id187" class="indexterm"></a>function for adding a character in the formation:</p><div class="informalexample"><pre class="programlisting">public bool AddCharacter(GameObject character)
{
    int occupiedSlots = slotAssignments.Count;
    if (!pattern.SupportsSlots(occupiedSlots + 1))
        return false;
    SlotAssignment sa = new SlotAssignment();
    sa.character = character;
    slotAssignments.Add(sa);
    UpdateSlotAssignments();
    return true;
}</pre></div></li><li><p>Implement the function for removing a character in the formation:</p><div class="informalexample"><pre class="programlisting">public void RemoveCharacter(GameObject agent)
{
    int index = slotAssignments.FindIndex(x =&gt; x.character.Equals(agent));
    slotAssignments.RemoveAt(index);
    UpdateSlotAssignments();
}</pre></div></li><li><p>Implement the function for updating the slots:</p><div class="informalexample"><pre class="programlisting">public void UpdateSlots()
{
    GameObject leader = pattern.leader;
    Vector3 anchor = leader.transform.position;
    Vector3 slotPos;
    Quaternion rotation;
    rotation = leader.transform.rotation;
    foreach (SlotAssignment sa in slotAssignments)
    {
        // next step
    }
}</pre></div></li><li><p>Finally, implement the <code class="literal">foreach</code> loop:</p><div class="informalexample"><pre class="programlisting">Vector3 relPos;
slotPos = pattern.GetSlotLocation(sa.slotIndex);
relPos = anchor;
relPos += leader.transform.TransformDirection(slotPos);
Location charDrift = new Location(relPos, rotation);
Character character = sa.character.GetComponent&lt;Character&gt;();
character.SetTarget(charDrift);</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec157"></a>How it works…</h3></div></div></div><p>The <code class="literal">FormationPattern</code> class contains the relative positions to a given slot. For example, a child <code class="literal">CircleFormation</code> class will implement the <code class="literal">GetSlotLocation</code> class, given the number of slots and its locations over 360 degrees. It is intended to be a basic class, so it is up to the manager to add a layer for permissions and rearrangement. That way, the designer can focus on simple formation scripting, deriving from the base class.</p><p>The <code class="literal">FormationManager</code> class, as stated earlier, handles the high-level layer and arranges the locations in line with the formation's needs and permissions. The calculations are based on the leader's position and rotation, and they apply the necessary transformations given the pattern's principles.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec158"></a>There is more…</h3></div></div></div><p>It is worth mentioning <a id="id188" class="indexterm"></a>that the <code class="literal">FormationManager</code> and <code class="literal">FormationPattern</code> classes are intended to be components of the same object. When the leader field in the manager is set to null, the leader is the object itself. That way, we could have a different leader object in order to have a clean inspector window and class modularity.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec159"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Refer to <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Movement</em></span>, the <span class="emphasis"><em>Arriving and leaving</em></span> recipe</p></li><li style="list-style-type: disc"><p>For further information on drift offset and how to play with this value, please refer to Ian Millington's book, <span class="emphasis"><em>Artificial Intelligence for Games</em></span></p></li></ul></div></div></div>