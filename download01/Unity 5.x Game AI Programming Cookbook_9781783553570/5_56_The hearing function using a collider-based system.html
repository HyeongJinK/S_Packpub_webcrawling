<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec59"></a>The hearing function using a collider-based system</h2></div></div><hr /></div><p>In this <a id="id244" class="indexterm"></a>recipe, we will emulate the sense of <a id="id245" class="indexterm"></a>hearing by developing two entities: a sound emitter and a sound receiver. It is based on the principles proposed by Millington for simulating a hearing system, and it uses the power of Unity colliders to detect receivers near an emitter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec200"></a>Getting ready</h3></div></div></div><p>As with the other recipes based on colliders, we will need collider components attached to every object that is to be checked, and rigid body components attached to either emitters or receivers.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec201"></a>How to do it…</h3></div></div></div><p>We will create the <code class="literal">SoundReceiver</code> class for our agents, and <code class="literal">SoundEmitter</code> for things such as alarms:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the class for the sound-receiver object:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class SoundReceiver : MonoBehaviour
{
    public float soundThreshold;
}</pre></div></li><li><p>Define the function for our own behavior that is handling the reception of sound:</p><div class="informalexample"><pre class="programlisting">public virtual void Receive(float intensity, Vector3 position)
{
    // TODO
    // code your own behaviour here
}</pre></div></li><li><p>Now, let's create the class for the sound-emitter object:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class SoundEmitter : MonoBehaviour
{
    public float soundIntensity;
    public float soundAttenuation;
    public GameObject emitterObject;
    private Dictionary&lt;int, SoundReceiver&gt; receiverDic;
}</pre></div></li><li><p>Initialize <a id="id246" class="indexterm"></a>the list of nearby receivers <a id="id247" class="indexterm"></a>and the emitter object, in case the component is attached directly:</p><div class="informalexample"><pre class="programlisting">void Start()
{
    receiverDic = new Dictionary&lt;int, SoundReceiver&gt;();
    if (emitterObject == null)
        emitterObject = gameObject;
}</pre></div></li><li><p>Implement the function for adding new receivers to the list when they enter the emitter bounds:</p><div class="informalexample"><pre class="programlisting">public void OnTriggerEnter(Collider coll)
{
    SoundReceiver receiver;
    receiver = coll.gameObject.GetComponent&lt;SoundReceiver&gt;();
    if (receiver == null)
        return;
    int objId = coll.gameObject.GetInstanceID();
    receiverDic.Add(objId, receiver);
}</pre></div></li><li><p>Also, implement the function for removing receivers from the list when they are out of reach:</p><div class="informalexample"><pre class="programlisting">public void OnTriggerExit(Collider coll)
{
    SoundReceiver receiver;
    receiver = coll.gameObject.GetComponent&lt;SoundReceiver&gt;();
    if (receiver == null)
        return;
    int objId = coll.gameObject.GetInstanceID();
    receiverDic.Remove(objId);
}</pre></div></li><li><p>Define the function for emitting sound waves to nearby agents:</p><div class="informalexample"><pre class="programlisting">public void Emit()
{
    GameObject srObj;
    Vector3 srPos;
    float intensity;
    float distance;
    Vector3 emitterPos = emitterObject.transform.position;
    // next step here
}</pre></div></li><li><p>Compute <a id="id248" class="indexterm"></a>sound attenuation <a id="id249" class="indexterm"></a>for every receiver:</p><div class="informalexample"><pre class="programlisting">foreach (SoundReceiver sr in receiverDic.Values)
{
    srObj = sr.gameObject;
    srPos = srObj.transform.position;
    distance = Vector3.Distance(srPos, emitterPos);
    intensity = soundIntensity;
    intensity -= soundAttenuation * distance;
    if (intensity &lt; sr.soundThreshold)
        continue;
    sr.Receive(intensity, emitterPos);
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec202"></a>How it works…</h3></div></div></div><p>The collider triggers help register agents in the list of agents assigned to an emitter. The sound emission function then takes into account the agent's distance from the emitter in order to decrease its intensity using the concept of sound attenuation.</p><div class="mediaobject"><img src="/graphics/9781783553570/graphics/3570_05_02.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec203"></a>There is more…</h3></div></div></div><p>We can develop a more flexible algorithm by defining different types of walls that affect sound intensity. It works by casting rays and adding up their values to the sound attenuation:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a dictionary for storing wall types as strings (using tags), and their corresponding attenuation:</p><div class="informalexample"><pre class="programlisting">public Dictionary&lt;string, float&gt; wallTypes;</pre></div></li><li><p>Reduce sound intensity this way:</p><div class="informalexample"><pre class="programlisting">intensity -= GetWallAttenuation(emitterPos, srPos);</pre></div></li><li><p>Define the function that was called in the previous step:</p><div class="informalexample"><pre class="programlisting">public float GetWallAttenuation(Vector3 emitterPos, Vector3 receiverPos)
{
    // next steps here
}</pre></div></li><li><p>Compute the necessary values for ray casting:</p><div class="informalexample"><pre class="programlisting">float attenuation = 0f;
Vector3 direction = receiverPos - emitterPos;
float distance = direction.magnitude;
direction.Normalize();</pre></div></li><li><p>Cast the ray and retrieve the hits:</p><div class="informalexample"><pre class="programlisting">Ray ray = new Ray(emitterPos, direction);
RaycastHit[] hits = Physics.RaycastAll(ray, distance);</pre></div></li><li><p>For <a id="id250" class="indexterm"></a>every wall type found via <a id="id251" class="indexterm"></a>tags, add up its value (stored in the dictionary):</p><div class="informalexample"><pre class="programlisting">int i;
for (i = 0; i &lt; hits.Length; i++)
{
    GameObject obj;
    string tag;
    obj = hits[i].collider.gameObject;
    tag = obj.tag;
    if (wallTypes.ContainsKey(tag))
        attenuation += wallTypes[tag];
}
return attenuation;</pre></div></li></ol></div></div></div>