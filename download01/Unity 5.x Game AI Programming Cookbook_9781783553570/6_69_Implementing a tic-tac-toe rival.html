<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec71"></a>Implementing a tic-tac-toe rival</h2></div></div><hr /></div><p>In order to <a id="id313" class="indexterm"></a>make use of the previous recipes, we will devise a way to implement a rival for a popular game: tic-tac-toe. Not only does it help us extend the base classes, but it also gives us a way to create rivals for our own board games.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec246"></a>Getting ready…</h3></div></div></div><p>We will need to create a specific move class for the tic-tac-toe board derived from the parent class we created at the beginning of the chapter:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class MoveTicTac : Move
{
    public int x;
    public int y;
    public int player;

    public MoveTicTac(int x, int y, int player)
    {
        this.x = x;
        this.y = y;
        this.player = player;
    }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec247"></a>How to do it…</h3></div></div></div><p>We will create a <a id="id314" class="indexterm"></a>new class, deriving it from <code class="literal">Board</code>, override its parent's methods, and create new ones.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">BoardTicTac</code> class, deriving it from <code class="literal">Board</code>, and add the corresponding member variables for storing the board's values:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;

public class BoardTicTac : Board
{
    protected int[,] board;
    protected const int ROWS = 3;
    protected const int COLS = 3;
}</pre></div></li><li><p>Implement the default constructor:</p><div class="informalexample"><pre class="programlisting">public BoardTicTac(int player = 1)
{
    this.player = player;
    board = new int[ROWS, COLS];
    board[1,1] = 1;
}</pre></div></li><li><p>Define the function for retrieving the next player in turn:</p><div class="informalexample"><pre class="programlisting">private int GetNextPlayer(int p)
{
    if (p == 1)
        return 2;
    return 1;
}</pre></div></li><li><p>Create a <a id="id315" class="indexterm"></a>function for evaluating a given position regarding a given player:</p><div class="informalexample"><pre class="programlisting">private float EvaluatePosition(int x, int y, int p)
{
    if (board[y, x] == 0)
        return 1f;
    else if (board[y, x] == p)
        return 2f;
    return -1f;
}</pre></div></li><li><p>Define a function for evaluating the neighbors of a given position regarding a given player:</p><div class="informalexample"><pre class="programlisting">private float EvaluateNeighbours(int x, int y, int p)
{
    float eval = 0f;
    int i, j;
    for (i = y - 1; i &lt; y + 2; y++)
    {
        if (i &lt; 0 || i &gt;= ROWS)
            continue;
        for (j = x - 1; j &lt; x + 2; j++)
        {
            if (j &lt; 0 || j &gt;= COLS)
                continue;
            if (i == j)
                continue;
            eval += EvaluatePosition(j, i, p);
        }
    }
    return eval;
}</pre></div></li><li><p>Implement a constructor for building new states with values:</p><div class="informalexample"><pre class="programlisting">public BoardTicTac(int[,] board, int player)
{
    this.board = board;
    this.player = player;
}</pre></div></li><li><p>Override the member function for getting the available moves from the current state:</p><div class="informalexample"><pre class="programlisting">public override Move[] GetMoves()
{
    List&lt;Move&gt; moves = new List&lt;Move&gt;();
    int i;
    int j;
    for (i = 0; i &lt; ROWS; i++)
    {
        for (j = 0; j &lt; COLS; j++)
        {
            if (board[i, j] != 0)
                continue;
            MoveTicTac m = new MoveTicTac(j, i, player);
            moves.Add(m);
        }
    }
    return moves.ToArray();
}</pre></div></li><li><p>Override the <a id="id316" class="indexterm"></a>function for retrieving a new state from a given move:</p><div class="informalexample"><pre class="programlisting">public override Board MakeMove(Move m)
{
    MoveTicTac move = (MoveTicTac)m;
    int nextPlayer = GetNextPlayer(move.player);
    int[,] copy = new int[ROWS, COLS];
    Array.Copy(board, 0, copy, 0, board.Length);
    copy[move.y, move.x] = move.player;
    BoardTicTac b = new BoardTicTac(copy, nextPlayer);
    return b;
}</pre></div></li><li><p>Define the function for evaluating the current state, given a player:</p><div class="informalexample"><pre class="programlisting">public override float Evaluate(int player)
{
    float eval = 0f;
    int i, j;
    for (i = 0; i &lt; ROWS; i++)
    {
        for (j = 0; j &lt; COLS; j++)
        {
            eval += EvaluatePosition(j, i, player);
            eval += EvaluateNeighbours(j, i, player);
        }
    }
    return eval;
}</pre></div></li><li><p>Implement the <a id="id317" class="indexterm"></a>function for evaluating the current state of the current player:</p><div class="informalexample"><pre class="programlisting">public override float Evaluate()
{
    float eval = 0f;
    int i, j;
    for (i = 0; i &lt; ROWS; i++)
    {
        for (j = 0; j &lt; COLS; j++)
        {
            eval += EvaluatePosition(j, i, player);
            eval += EvaluateNeighbours(j, i, player);
        }
    }
    return eval;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec248"></a>How it works…</h3></div></div></div><p>We define a new type of move for the board that works well with the base algorithms because they make use of it only at a high level as a data structure. The recipe's bread and butter come from overriding the virtual functions from the <code class="literal">Board</code> class in order to model the problem. We use a two-dimensional integer array for storing the players' moves on the board (0 represents an empty place), and we work out a heuristic for defining the value of a given state regarding its neighbors.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec249"></a>There is more…</h3></div></div></div><p>The functions for evaluating a board's (state) score have an admissible heuristic, but it's probably not optimal. It is up to us to revisit this problem and refactor the body of the aforementioned functions in order to have a better tuned rival.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec250"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Working with the game-tree class</em></span> recipe</p></li></ul></div></div></div>