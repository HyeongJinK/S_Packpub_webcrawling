<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec72"></a>Implementing a checkers rival</h2></div></div><hr /></div><p>You will learn how <a id="id318" class="indexterm"></a>to extend the previous recipes with an advanced example. In this case, you will learn how to model a checkers (draughts) board and its pieces in order to comply with the necessary functions to be used with our board-AI framework.</p><p>This approach uses a chess board (8 x 8) and its respective number of pieces (12). However, it can be easily parameterized in order to change these values in case we want to have a differently sized board.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec251"></a>Getting ready…</h3></div></div></div><p>First, we need to create a new type of movement for this particular case called <code class="literal">MoveDraughts</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class MoveDraughts : Move
{
    public PieceDraughts piece;
    public int x;
    public int y;
    public bool success;
    public int removeX;
    public int removeY;
}</pre></div><p>This data structure stores the piece to be moved, the new <code class="literal">x</code> and <code class="literal">y</code> coordinates if the movement is a successful capture, and the position of the piece to be removed.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec252"></a>How to do it…</h3></div></div></div><p>We will implement two core classes for modeling the pieces and the board, respectively. This is a long process, so read each step carefully:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new file called <code class="literal">PieceDraughts.cs</code> and add the following statements:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;</pre></div></li><li><p>Add the <code class="literal">PieceColor</code> data type:</p><div class="informalexample"><pre class="programlisting">public enum PieceColor
{
    WHITE,
    BLACK
};</pre></div></li><li><p>Add the <code class="literal">PieceType</code> data enum:</p><div class="informalexample"><pre class="programlisting">public enum PieceType
{
    MAN,
    KING
};</pre></div></li><li><p>Start <a id="id319" class="indexterm"></a>building the <code class="literal">PieceDraughts</code> class:</p><div class="informalexample"><pre class="programlisting">public class PieceDraughts : MonoBehaviour
{
    public int x;
    public int y;
    public PieceColor color;
    public PieceType type;
    // next steps here
}</pre></div></li><li><p>Define the function for setting up the piece logically:</p><div class="informalexample"><pre class="programlisting">public void Setup(int x, int y,
        PieceColor color,
        PieceType type = PieceType.MAN)
{
    this.x = x;
    this.y = y;
    this.color = color;
    this.type = type;
}</pre></div></li><li><p>Define the function for moving the piece on the board:</p><div class="informalexample"><pre class="programlisting">public void Move (MoveDraughts move, ref PieceDraughts [,] board)
{
    board[move.y, move.x] = this;
    board[y, x] = null;
    x = move.x;
    y = move.y;
    // next steps here
}</pre></div></li><li><p>If the move is a capture, remove the corresponding piece:</p><div class="informalexample"><pre class="programlisting">if (move.success)
{
    Destroy(board[move.removeY, move.removeX]);
    board[move.removeY, move.removeX] = null;
}</pre></div></li><li><p>Stop the process if the piece is <code class="literal">King</code>:</p><div class="informalexample"><pre class="programlisting">if (type == PieceType.KING)
    return;</pre></div></li><li><p>Change the type of piece if it is <code class="literal">Man</code> and it reaches the opposite border:</p><div class="informalexample"><pre class="programlisting">int rows = board.GetLength(0);
if (color == PieceColor.WHITE &amp;&amp; y == rows)
    type = PieceType.KING;
if (color == PieceColor.BLACK &amp;&amp; y == 0)
    type = PieceType.KING;</pre></div></li><li><p>Define the <a id="id320" class="indexterm"></a>function for checking if a move is inside the bounds of the board:</p><div class="informalexample"><pre class="programlisting">private bool IsMoveInBounds(int x, int y, ref PieceDraughts[,] board)
{
    int rows = board.GetLength(0);
    int cols = board.GetLength(1);
    if (x &lt; 0 || x &gt;= cols || y &lt; 0 || y &gt;= rows)
        return false;
    return true;
}</pre></div></li><li><p>Define the general function for retrieving the possible moves:</p><div class="informalexample"><pre class="programlisting">public Move[] GetMoves(ref PieceDraughts[,] board)
{
    List&lt;Move&gt; moves = new List&lt;Move&gt;();
    if (type == PieceType.KING)
        moves = GetMovesKing(ref board);
    else
        moves = GetMovesMan(ref board);
    return moves.ToArray();
}</pre></div></li><li><p>Start implementing the function for retrieving the moves when the piece's type is <code class="literal">Man</code>:</p><div class="informalexample"><pre class="programlisting">private List&lt;Move&gt; GetMovesMan(ref PieceDraughts[,] board)
{
    // next steps here
}</pre></div></li><li><p>Add the variable for storing the two possible moves:</p><div class="informalexample"><pre class="programlisting">List&lt;Move&gt; moves = new List&lt;Move&gt;(2);</pre></div></li><li><p>Define the variable for holding the two possible horizontal options:</p><div class="informalexample"><pre class="programlisting">int[] moveX = new int[] { -1, 1 };</pre></div></li><li><p>Define the variable for holding the vertical direction depending on the piece's color:</p><div class="informalexample"><pre class="programlisting">int moveY = 1;
if (color == PieceColor.BLACK)
    moveY = -1;</pre></div></li><li><p>Implement the loop for iterating through the two possible options and return the available moves. We will implement the body of the loop in the next step:</p><div class="informalexample"><pre class="programlisting">foreach (int mX in moveX)
{
    // next steps
}
return moves;</pre></div></li><li><p>Declare two <a id="id321" class="indexterm"></a>new variable for computing the next position to be considered:</p><div class="informalexample"><pre class="programlisting">int nextX = x + mX;
int nextY = y + moveY;</pre></div></li><li><p>Test the possible option if the move is out of bounds:</p><div class="informalexample"><pre class="programlisting">if (!IsMoveInBounds(nextX, y, ref board))
    continue;</pre></div></li><li><p>Continue with the next option if the move is being blocked by a piece of the same color:</p><div class="informalexample"><pre class="programlisting">PieceDraughts p = board[moveY, nextX];
if (p != null &amp;&amp; p.color == color)
    continue;</pre></div></li><li><p>Create a new move to be added to the list because we're good-to-go:</p><div class="informalexample"><pre class="programlisting">MoveDraughts m = new MoveDraughts();
m.piece = this;</pre></div></li><li><p>Create a simple move if the position is available:</p><div class="informalexample"><pre class="programlisting">if (p == null)
{
    m.x = nextX;
    m.y = nextY;
}</pre></div></li><li><p>Otherwise, test whether the piece can be captured and modify the move accordingly: </p><div class="informalexample"><pre class="programlisting">else
{
    int hopX = nextX + mX;
    int hopY = nextY + moveY;
    if (!IsMoveInBounds(hopX, hopY, ref board))
        continue;
    if (board[hopY, hopX] != null)
        continue;
    m.y = hopX;
    m.x = hopY;
    m.success = true;
    m.removeX = nextX;
    m.removeY = nextY;
}</pre></div></li><li><p>Add the <a id="id322" class="indexterm"></a>move to the list:</p><div class="informalexample"><pre class="programlisting">moves.Add(m);</pre></div></li><li><p>Start to implement the function for retrieving the available moves when the piece's type is <code class="literal">King</code>:</p><div class="informalexample"><pre class="programlisting">private List&lt;Move&gt; GetMovesKing(ref PieceDraughts[,] board)
{
    // next steps here
}</pre></div></li><li><p>Declare the variable for holding the possible moves:</p><div class="informalexample"><pre class="programlisting">List&lt;Move&gt; moves = new List&lt;Move&gt;();</pre></div></li><li><p>Create the variables for searching in four directions:</p><div class="informalexample"><pre class="programlisting">int[] moveX = new int[] { -1, 1 };
int[] moveY = new int[] { -1, 1 };</pre></div></li><li><p>Start implementing the loop for checking all the possible moves, and retrieve those moves. The next step will implement the body of the inner loop:</p><div class="informalexample"><pre class="programlisting">foreach (int mY in moveY)
{
    foreach (int mX in moveX)
    {
        // next steps here
    }                   
}
return moves;</pre></div></li><li><p>Create the variables for testing the moves and advances:</p><div class="informalexample"><pre class="programlisting">int nowX = x + mX;
int nowY = y + mY;</pre></div></li><li><p>Create a loop for going in that direction until the board's bounds are reached:</p><div class="informalexample"><pre class="programlisting">while (IsMoveInBounds(nowX, nowY, ref board))
{
    // next steps here
}</pre></div></li><li><p>Get the position's piece reference:</p><div class="informalexample"><pre class="programlisting">PieceDraughts p = board[nowY, nowX];</pre></div></li><li><p>If it is a piece <a id="id323" class="indexterm"></a>of the same color, go no further:</p><div class="informalexample"><pre class="programlisting">if (p != null &amp;&amp; p.color == color)
    break;</pre></div></li><li><p>Define a variable for creating the new available move:</p><div class="informalexample"><pre class="programlisting">MoveDraughts m = new MoveDraughts();
m.piece = this;</pre></div></li><li><p>Create a simple move if the position is available:</p><div class="informalexample"><pre class="programlisting">if (p == null)
{
    m.x = nowX;
    m.y = nowY;
}</pre></div></li><li><p>Otherwise, test whether the piece can be captured and modify the move accordingly:</p><div class="informalexample"><pre class="programlisting">else
{
    int hopX = nowX + mX;
    int hopY = nowY + mY;
    if (!IsMoveInBounds(hopX, hopY, ref board))
        break;
    m.success = true;
    m.x = hopX;
    m.y = hopY;
    m.removeX = nowX;
    m.removeY = nowY;
}</pre></div></li><li><p>Add the move and advance a step towards the current direction:</p><div class="informalexample"><pre class="programlisting">moves.Add(m);
nowX += mX;
nowY += mY;</pre></div></li><li><p>Create a new class called <code class="literal">BoardDraughts</code> in a new file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class BoardDraughts : Board
{
    public int size = 8;
    public int numPieces = 12;
    public GameObject prefab;
    protected PieceDraughts[,] board;
}</pre></div></li><li><p>Implement the <a id="id324" class="indexterm"></a>
<code class="literal">Awake</code> function:</p><div class="informalexample"><pre class="programlisting">void Awake()
{
    board = new PieceDraughts[size, size];
}</pre></div></li><li><p>Start implementing the <code class="literal">Start</code> function. It is important to note that this may vary depending on your game's spatial representation:</p><div class="informalexample"><pre class="programlisting">void Start()
{
    // TODO
    // initialization and board set up
    // your implementation may vary

    // next steps here
}</pre></div></li><li><p>Throw an error message if the template object doesn't have an attached <code class="literal">PieceDraught</code> script:</p><div class="informalexample"><pre class="programlisting">PieceDraughts pd = prefab.GetComponent&lt;PieceDraughts&gt;();
if (pd == null)
{
    Debug.LogError("No PieceDraught component detected");
    return;
}</pre></div></li><li><p>Add iterator variables:</p><div class="informalexample"><pre class="programlisting">int i;
int j;</pre></div></li><li><p>Implement the loop for placing the white pieces:</p><div class="informalexample"><pre class="programlisting">int piecesLeft = numPieces;
for (i = 0; i &lt; size; i++)
{
    if (piecesLeft == 0)
        break;
    int init = 0;
    if (i % 2 != 0)
        init = 1;
    for (j = init; j &lt; size; j+=2)
    {
        if (piecesLeft == 0)
            break;
        PlacePiece(j, i);
        piecesLeft--;
    }
}</pre></div></li><li><p>Implement the <a id="id325" class="indexterm"></a>loop for placing the black pieces:</p><div class="informalexample"><pre class="programlisting">piecesLeft = numPieces;
for (i = size - 1; i &gt;= 0; i--)
{
    if (piecesLeft == 0)
        break;
    int init = 0;
    if (i % 2 != 0)
        init = 1;
    for (j = init; j &lt; size; j+=2)
    {
        if (piecesLeft == 0)
            break;
        PlacePiece(j, i);
        piecesLeft--;
    }
}</pre></div></li><li><p>Implement the function for placing a specific piece. This could change in your game depending on its visualization:</p><div class="informalexample"><pre class="programlisting">private void PlacePiece(int x, int y)
{
    // TODO
    // your own transformations
    // according to space placements
    Vector3 pos = new Vector3();
    pos.x = (float)x;
    pos.y = -(float)y;
    GameObject go = GameObject.Instantiate(prefab);
    go.transform.position = pos;
    PieceDraughts p = go.GetComponent&lt;PieceDraughts&gt;();
    p.Setup(x, y, color);
    board[y, x] = p;
}</pre></div></li><li><p>Implement the <a id="id326" class="indexterm"></a>
<code class="literal">Evaluate</code> function with no parameters:</p><div class="informalexample"><pre class="programlisting">public override float Evaluate()
{
    PieceColor color = PieceColor.WHITE;
    if (player == 1)
        color = PieceColor.BLACK;
    return Evaluate(color);
}</pre></div></li><li><p>Implement the <code class="literal">Evaluate</code> function with a parameter:</p><div class="informalexample"><pre class="programlisting">public override float Evaluate(int player)
{
    PieceColor color = PieceColor.WHITE;
    if (player == 1)
        color = PieceColor.BLACK;
    return Evaluate(color);
}</pre></div></li><li><p>Start implementing the general function for evaluation:</p><div class="informalexample"><pre class="programlisting">private float Evaluate(PieceColor color)
{
    // next steps here
}</pre></div></li><li><p>Define the variables for holding the evaluation and assigning points:</p><div class="informalexample"><pre class="programlisting">float eval = 1f;
float pointSimple = 1f;
float pointSuccess = 5f;</pre></div></li><li><p>Create variables for holding the board's bounds:</p><div class="informalexample"><pre class="programlisting">int rows = board.GetLength(0);
int cols = board.GetLength(1);</pre></div></li><li><p>Define variables for iteration:</p><div class="informalexample"><pre class="programlisting">int i;
int j;</pre></div></li><li><p>Iterate throughout the board to look for moves and possible captures:</p><div class="informalexample"><pre class="programlisting">for (i = 0; i &lt; rows; i++)
{
    for (j = 0; j &lt; cols; j++)
    {
        PieceDraughts p = board[i, j];
        if (p == null)
            continue;
        if (p.color != color)
            continue;
        Move[] moves = p.GetMoves(ref board);
        foreach (Move mv in moves)
        {
            MoveDraughts m = (MoveDraughts)mv;
            if (m.success)
                eval += pointSuccess;
            else
                eval += pointSimple;
        }
    }
}</pre></div></li><li><p>Retrieve the <a id="id327" class="indexterm"></a>evaluation value:</p><div class="informalexample"><pre class="programlisting">return eval;</pre></div></li><li><p>Start developing the function for retrieving the board's available moves:</p><div class="informalexample"><pre class="programlisting">public override Move[] GetMoves()
{
    // next steps here
}</pre></div></li><li><p>Define the variables for holding the moves and the board's boundaries, and handling iteration:</p><div class="informalexample"><pre class="programlisting">List&lt;Move&gt; moves = new List&lt;Move&gt;();
int rows = board.GetLength(0);
int cols = board.GetLength(1);
int i;
int j;</pre></div></li><li><p>Get the moves from all the available pieces on the board:</p><div class="informalexample"><pre class="programlisting">for (i = 0; i &lt; rows; i++)
{
    for (j = 0; i &lt; cols; j++)
    {
        PieceDraughts p = board[i, j];
        if (p == null)
            continue;
        moves.AddRange(p.GetMoves(ref board));
    }
}</pre></div></li><li><p>Return the moves found:</p><div class="informalexample"><pre class="programlisting">return moves.ToArray();</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec253"></a>How it works…</h3></div></div></div><p>The board works in a similar fashion to the previous board, but it has a more complex process due to the rules of the game. The movements are tied to the pieces' moves, thus creating a cascading effect <a id="id328" class="indexterm"></a>that must be handled carefully. Each piece has two types of movement, depending on its color and type.</p><p>As we can see, the high-level rules are the same. It just requires a little bit of patience and thinking in order to develop good evaluation functions and procedures for retrieving the board's available moves.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec254"></a>There is more…</h3></div></div></div><p>The <code class="literal">Evaluate</code> function is far from being perfect. We implemented a heuristic based solely on the number of available moves and captured opponent pieces, giving room for improvement in order to avoid movements where a player's piece could be captured in the rival's next move.</p><p>Also, we should make our own changes to the <code class="literal">PlacePiece</code> function in the <code class="literal">BoardDraughts</code> class. We implemented a direct method that probably doesn't fit your game's spatial setup.</p></div></div>