<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec27"></a>Representing the world with Dirichlet domains</h2></div></div><hr /></div><p>Also <a id="id82" class="indexterm"></a>called a Voronoi polygon, a Dirichlet <a id="id83" class="indexterm"></a>domain is a way of dividing space into regions consisting of a set of points closer to a given seed point than to any other. This graph representation helps in distributing the space using Unity's primitives or existing meshes, thus not really adhering to the definition, but using the concept as a means to an end. Dirichlet domains are usually mapped using cones for delimiting the area of a given vertex, but we're adapting that principle to our specific needs and tool.</p><div class="mediaobject"><img src="/graphics/9781783553570/graphics/3561_02_03.jpg" /><div class="caption"><p>Example of a Voronoi Diagram or Voronoi Polygon</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec80"></a>Getting ready</h3></div></div></div><p>Before building our new <code class="literal">Graph</code> class, it's important to create the <code class="literal">VertexReport</code> class, make <a id="id84" class="indexterm"></a>some modifications to our <code class="literal">Graph</code> class, and add the <code class="literal">Vertex</code> tag in the project:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Prepend the <code class="literal">VertexReport</code> class to the <code class="literal">Graph</code> class specification, in the same file:</p><div class="informalexample"><pre class="programlisting">public class VertexReport
{
    public int vertex;
    public GameObject obj;
    public VertexReport(int vertexId, GameObject obj)
    {
        vertex = vertexId;
        this.obj = obj;
    }
}</pre></div></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>It's worth noting that the vertex objects in the scene must have a collider component attached to them, as well as the <code class="literal">Vertex</code> tag assigned. These objects can be either primitives or meshes, covering the maximum size of the area to be considered that vertex node.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec81"></a>How to do it...</h3></div></div></div><p>This can be seen as a two-step recipe. First we define the vertex implementation and then the <a id="id85" class="indexterm"></a>graph implementation, so everything works as intended:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, create the <code class="literal">VertexDirichlet</code> class deriving from <code class="literal">Vertex</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class VertexDirichlet : Vertex
{
    // next steps
}</pre></div></li><li><p>Define the <code class="literal">OnTriggerEnter</code> function for registering the object in the current vertex:</p><div class="informalexample"><pre class="programlisting">public void OnTriggerEnter(Collider col)
{
    string objName = col.gameObject.name;
    if (objName.Equals("Agent") || objName.Equals("Player"))
    {
        VertexReport report = new VertexReport(id, col.gameObject);
        SendMessageUpwards("AddLocation", report);
    }
}</pre></div></li><li><p>Define the <code class="literal">OnTriggerExit</code> function for the inverse procedure</p><div class="informalexample"><pre class="programlisting">public void OnTriggerExit(Collider col)
{
    string objName = col.gameObject.name;
    if (objName.Equals("Agent") || objName.Equals("Player"))
    {
        VertexReport report = new VertexReport(id, col.gameObject);
        SendMessageUpwards("RemoveLocation", report);
    }
}</pre></div></li><li><p>Create the <code class="literal">GraphDirichlet</code> class deriving from <code class="literal">Graph</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections.Generic;

public class GraphDirichlet : Graph
{
    Dictionary&lt;int, List&lt;int&gt;&gt; objToVertex;
}</pre></div></li><li><p>Implement <a id="id86" class="indexterm"></a>the <code class="literal">AddLocation</code> function we called before:</p><div class="informalexample"><pre class="programlisting">public void AddLocation(VertexReport report)
{
    int objId = report.obj.GetInstanceID();
    if (!objToVertex.ContainsKey(objId))
    {
        objToVertex.Add(objId, new List&lt;int&gt;());
    }
    objToVertex[objId].Add(report.vertex);
}</pre></div></li><li><p>Define the <code class="literal">RemoveLocation</code> function as well:</p><div class="informalexample"><pre class="programlisting">public void RemoveLocation(VertexReport report)
{
    int objId = report.obj.GetInstanceID();
    objToVertex[objId].Remove(report.vertex);
}</pre></div></li><li><p>Override the <code class="literal">Start</code> function to initialize the member variables:</p><div class="informalexample"><pre class="programlisting">public override void Start()
{
    base.Start();
    objToVertex = new Dictionary&lt;int, List&lt;int&gt;&gt;();
}</pre></div></li><li><p>Implement the <code class="literal">Load</code> function for connecting everything:</p><div class="informalexample"><pre class="programlisting">public override void Load()
{
    Vertex[] verts = GameObject.FindObjectsOfType&lt;Vertex&gt;();
    vertices = new List&lt;Vertex&gt;(verts);
    for (int i = 0; i &lt; vertices.Count; i++)
    {
        VertexVisibility vv = vertices[i] as VertexVisibility;
        vv.id = i;
        vv.FindNeighbours(vertices);
    }
}</pre></div></li><li><p>Override <a id="id87" class="indexterm"></a>the <code class="literal">GetNearestVertex</code> function:</p><div class="informalexample"><pre class="programlisting">public override Vertex GetNearestVertex(Vector3 position)
{
    Vertex vertex = null;
    float dist = Mathf.Infinity;
    float distNear = dist;
    Vector3 posVertex = Vector3.zero;
    for (int i = 0; i &lt; vertices.Count; i++)
    {
        posVertex = vertices[i].transform.position;
        dist = Vector3.Distance(position, posVertex);
        if (dist &lt; distNear)
        {
            distNear = dist;
            vertex = vertices[i];
        }
    }
    return vertex;
}</pre></div></li><li><p>Define the <code class="literal">GetNearestVertex</code> function, this time with a GameObject as input:</p><div class="informalexample"><pre class="programlisting">public Vertex GetNearestVertex(GameObject obj)
{
    int objId = obj.GetInstanceID();
    Vector3 objPos = obj.transform.position;
    if (!objToVertex.ContainsKey(objId))
        return null;
    List&lt;int&gt; vertIds = objToVertex[objId];
    Vertex vertex = null;
    float dist = Mathf.Infinity;
    for (int i = 0; i &lt; vertIds.Count; i++)
    {
        int id = vertIds[i];
        Vertex v = vertices[id];
        Vector3 vPos = v.transform.position;
        float d = Vector3.Distance(objPos, vPos);
        if (d &lt; dist)
        {
            vertex = v;
            dist = d;
        }
    }
    return vertex;
}</pre></div></li><li><p>Implement the <code class="literal">GetNeighbors</code> function:</p><div class="informalexample"><pre class="programlisting">public override Vertex[] GetNeighbours(Vertex v)
{
    List&lt;Edge&gt; edges = v.neighbours;
    Vertex[] ns = new Vertex[edges.Count];
    int i;
    for (i = 0; i &lt; edges.Count; i++)
    {
        ns[i] = edges[i].vertex;
    }
    return ns;
}</pre></div></li><li><p>Finally, define <a id="id88" class="indexterm"></a>the <code class="literal">GetEdges</code> function:</p><div class="informalexample"><pre class="programlisting">public override Edge[] GetEdges(Vertex v)
{
    return vertices[v.id].neighbours.ToArray();
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec82"></a>How it works...</h3></div></div></div><p>When the agents or players enter into the area of a vertex, it sends a message to the graph parent class, and indexes that vertex into the proper dictionary of objects, making the appropriate quantization easier. The same inverse principle applies when the player leaves the area. When the player is mapped into more than one vertex, the function returns the index of the closest one.</p><p>Also, we're using a dictionary to facilitate the process of translating object instance IDs to the indices of our vertex array.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec83"></a>There's more...</h3></div></div></div><p>Take into account that placing the vertices and making the connections between them (edges) must be done manually using the implemented method. You're encouraged to implement a way for getting a vertex's neighbors aimed at your own project if you need a more user-friendly (or automated) technique.</p><p>Finally, we'll explore <a id="id89" class="indexterm"></a>is an automated way to get a vertex's neighbors in the next recipe, using ray casting that will probably serve as a starting point.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec84"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Representing the world with points of visibility</em></span> recipe</p></li></ul></div></div></div>