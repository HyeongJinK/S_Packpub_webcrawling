<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec22"></a>Predicting a projectile's landing spot</h2></div></div><hr /></div><p>After a <a id="id54" class="indexterm"></a>projectile is shot, some agents need to make a run for it, if we're talking about a grenade, or look at it when we're developing a sports game. In either case, it's important to predict the projectile's landing spot in order to make decisions:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec62"></a>Getting ready</h3></div></div></div><p>Before we get into predicting the landing position, it's important to know the time left before it hits the ground (or reaches a certain position). Thus, instead of creating new behaviors, we need to update the <code class="literal">Projectile</code> class.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec63"></a>How to do it...</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, we need to add the <code class="literal">GetLandingTime</code> function to compute the landing time:</p><div class="informalexample"><pre class="programlisting">public float GetLandingTime (float height = 0.0f)
{
    Vector3 position = transform.position;
    float time = 0.0f;
    float valueInt = (direction.y * direction.y) * (speed * speed);
    valueInt = valueInt - (Physics.gravity.y * 2 * (position.y - height));
    valueInt = Mathf.Sqrt(valueInt);
    float valueAdd = (-direction.y) * speed;
    float valueSub = (-direction.y) * speed;
    valueAdd = (valueAdd + valueInt) / Physics.gravity.y;
    valueSub = (valueSub - valueInt) / Physics.gravity.y;
    if (float.IsNaN(valueAdd) &amp;&amp; !float.IsNaN(valueSub))
        return valueSub;
    else if (!float.IsNaN(valueAdd) &amp;&amp; float.IsNaN(valueSub))
        return valueAdd;
    else if (float.IsNaN(valueAdd) &amp;&amp; float.IsNaN(valueSub))
        return -1.0f;
    time = Mathf.Max(valueAdd, valueSub);
    return time;
}</pre></div></li><li><p>Now, we <a id="id55" class="indexterm"></a>add the <code class="literal">GetLandingPos</code> function to predict the landing spot:</p><div class="informalexample"><pre class="programlisting">public Vector3 GetLandingPos (float height = 0.0f)
{
    Vector3 landingPos = Vector3.zero;
    float time = GetLandingTime();
    if (time &lt; 0.0f)
        return landingPos;
    landingPos.y = height;
    landingPos.x = firePos.x + direction.x * speed * time;
    landingPos.z = firePos.z + direction.z * speed * time;
    return landingPos;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec64"></a>How it works...</h3></div></div></div><p>First, we solve the equation from the previous recipe for a fixed height and, given the projectile's current position and speed, we are able to get the time at which the projectile will reach the given height.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec65"></a>There's more...</h3></div></div></div><p>Take into account the <code class="literal">NaN</code> validation. It's placed that way because there may be two, one, or no solution to the equation. Furthermore, when the landing time is less than zero, it means the projectile won't be able to reach the target height.</p></div></div>