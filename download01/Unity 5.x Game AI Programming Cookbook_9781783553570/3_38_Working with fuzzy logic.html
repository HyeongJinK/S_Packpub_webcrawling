<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec43"></a>Working with fuzzy logic</h2></div></div><hr /></div><p>There are times <a id="id164" class="indexterm"></a>when we have to deal with gray areas, instead of binary-based values, to make decisions, and fuzzy logic is a set of mathematical techniques that help us with this task.</p><p>Imagine that we're developing an automated driver. A couple of available actions are steering and speed control, both of which have a range of degrees. Deciding how to take a turn, and at which speed, is what will make our driver different and possibly smarter. That's the type of gray area that fuzzy logic helps represent and handle.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec143"></a>Getting ready</h3></div></div></div><p>This recipe requires a set of states indexed by continuous integer numbers. As this representation varies from game to game, we handle the raw input from such states, along with their <span class="emphasis"><em>fuzzification</em></span>, in order to have a good general-purpose fuzzy decision maker. Finally, the decision maker returns a set of fuzzy values representing the degree of membership of each state.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec144"></a>How to do it...</h3></div></div></div><p>We will create two base classes and our fuzzy decision maker:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the parent class, <code class="literal">MembershipFunction</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class MembershipFunction : MonoBehaviour
{
    public int stateId;
    public virtual float GetDOM(object input)
    {
        return 0f;
    }
}</pre></div></li><li><p>Implement <a id="id165" class="indexterm"></a>the <code class="literal">FuzzyRule</code> class:</p><div class="informalexample"><pre class="programlisting">using System.Collections;
using System.Collections.Generic;

public class FuzzyRule
{
    public List&lt;int&gt; stateIds;
    public int conclusionStateId;
}</pre></div></li><li><p>Create the <code class="literal">FuzzyDecisionMaker</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class FuzzyDecisionMaker : MonoBehaviour
{
}</pre></div></li><li><p>Define the decision-making function signature and its member variables:</p><div class="informalexample"><pre class="programlisting">public Dictionary&lt;int,float&gt; MakeDecision(object[] inputs, MembershipFunction[][] mfList, FuzzyRule[] rules)
{
    Dictionary&lt;int, float&gt; inputDOM = new Dictionary&lt;int, float&gt;();
    Dictionary&lt;int, float&gt; outputDOM = new Dictionary&lt;int, float&gt;();
    MembershipFunction memberFunc;
    // next steps
}</pre></div></li><li><p>Implement the loops for traversing the inputs and populate the initial degree of membership (DOM) for each state:</p><div class="informalexample"><pre class="programlisting">foreach (object input in inputs)
{
    int r, c;
    for (r = 0; r &lt; mfList.Length; r++)
    {
        for (c = 0; c &lt; mfList[r].Length; c++)
        {
            // next step
        }
    }
}
// steps after next</pre></div></li><li><p>Define the body of the innermost loop, which makes use of the proper membership <a id="id166" class="indexterm"></a>functions to set (or update) the degrees of membership:</p><div class="informalexample"><pre class="programlisting">memberFunc = mfList[r][c];
int mfId = memberFunc.stateId;
float dom = memberFunc.GetDOM(input);
if (!inputDOM.ContainsKey(mfId))
{
    inputDOM.Add(mfId, dom);
    outputDOM.Add(mfId, 0f);
}
else
    inputDOM[mfId] = dom;</pre></div></li><li><p>Traverse the rules for setting the output degrees of membership:</p><div class="informalexample"><pre class="programlisting">foreach (FuzzyRule rule in rules)
{
    int outputId = rule.conclusionStateId;
    float best = outputDOM[outputId];
    float min = 1f;
    foreach (int state in rule.stateIds)
    {
        float dom = inputDOM[state];
        if (dom &lt; best)
            continue;
        if (dom &lt; min)
            min = dom;
    }
    outputDOM[outputId] = min;
}</pre></div></li><li><p>Finally, return the set of degrees of membership:</p><div class="informalexample"><pre class="programlisting">return outputDOM;</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec145"></a>How it works...</h3></div></div></div><p>We make use of the boxing/unboxing technique for handling any input via the object data type. The <span class="emphasis"><em>fuzzification</em></span> process is done with the help of our own membership functions, derived from the base class that we created in the beginning. Then, we take the minimum degree of membership for the input state for each rule and calculate the final degree of membership for each <a id="id167" class="indexterm"></a>output state given the maximum output from any of the applicable rules.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec146"></a>There's more...</h3></div></div></div><p>We can create an example membership function to define whether an enemy is in enraged mode, knowing that its life points (ranging from 0 to 100) are equal to or less than 30.</p><p>The following is the code for the example <code class="literal">MFEnraged</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System;
using System.Collections;

public class MFEnraged : MembershipFunction
{
    public override float GetDOM(object input)
    {
        if ((int)input &lt;= 30)
            return 1f;
        return 0f;
    }
}</pre></div><p>It's worth noting that it is a common requirement to have a complete set of rules; one for each combination of states from each input. This makes the recipe lack in scalability, but it works well for a smaller number of input variables and a small number of states per variable.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec147"></a>See also</h3></div></div></div><p>For more theoretical insights regarding (de)<span class="emphasis"><em>fuzzification</em></span> and scalability weaknesses, please refer to Ian Millington's book, <span class="emphasis"><em>Artificial Intelligence for Games</em></span>.</p></div></div>