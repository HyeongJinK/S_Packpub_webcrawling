<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec19"></a>Blending behaviors by priority</h2></div></div><hr /></div><p>Sometimes, weighted <a id="id40" class="indexterm"></a>blending is not enough because heavyweight behaviors dilute the contributions of the lightweights, but those behaviors need to play their part too. That's when priority-based blending comes into play, applying a cascading effect from high-priority to low-priority behaviors.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec47"></a>Getting ready</h3></div></div></div><p>The approach is very similar to the one used in the previous recipe. We must add a new member variable to our <code class="literal">AgentBehaviour</code> class. We should also refactor the <code class="literal">Update</code> function to incorporate <code class="literal">priority</code> as a parameter to the <code class="literal">Agent</code> class' <code class="literal">SetSteering</code> function. The new <a id="id41" class="indexterm"></a>
<code class="literal">AgentBehaviour</code> class should look something like this:</p><div class="informalexample"><pre class="programlisting">public class AgentBehaviour : MonoBehaviour
{
    public int priority = 1;
    // ... everything else stays the same
    public virtual void Update ()
    {
        agent.SetSteering(GetSteering(), priority);
    }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec48"></a>How to do it...</h3></div></div></div><p>Now, we need to make some changes to the <code class="literal">Agent</code> class:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add a new namespace from the library:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Generic;</pre></div></li><li><p>Add the member variable for the minimum steering value to consider a group of behaviors:</p><div class="informalexample"><pre class="programlisting">public float priorityThreshold = 0.2f;</pre></div></li><li><p>Add the member variable for holding the group of behavior results:</p><div class="informalexample"><pre class="programlisting">private Dictionary&lt;int, List&lt;Steering&gt;&gt; groups;</pre></div></li><li><p>Initialize the variable in the <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">groups = new Dictionary&lt;int, List&lt;Steering&gt;&gt;();</pre></div></li><li><p>Modify the <code class="literal">LateUpdate</code> function so that the steering variable is set by calling <code class="literal">GetPrioritySteering</code>:</p><div class="informalexample"><pre class="programlisting">public virtual void LateUpdate ()
{
    //  funnelled steering through priorities
    steering = GetPrioritySteering();
    groups.Clear();
    // ... the rest of the computations stay the same
    steering = new Steering();
}</pre></div></li><li><p>Modify the <code class="literal">SetSteering</code> function's signature and definition to store the steering values <a id="id42" class="indexterm"></a>in their corresponding priority groups:</p><div class="informalexample"><pre class="programlisting">public void SetSteering (Steering steering, int priority)
{
    if (!groups.ContainsKey(priority))
    {
        groups.Add(priority, new List&lt;Steering&gt;());
    }
    groups[priority].Add(steering);
}</pre></div></li><li><p>Finally, implement the <code class="literal">GetPrioritySteering</code> function to funnel the steering group:</p><div class="informalexample"><pre class="programlisting">private Steering GetPrioritySteering ()
{
    Steering steering = new Steering();
    float sqrThreshold = priorityThreshold * priorityThreshold;
    foreach (List&lt;Steering&gt; group in groups.Values)
    {
        steering = new Steering();
        foreach (Steering singleSteering in group)
        {
            steering.linear += singleSteering.linear;
            steering.angular += singleSteering.angular;
        }
        if (steering.linear.sqrMagnitude &gt; sqrThreshold ||
                Mathf.Abs(steering.angular) &gt; priorityThreshold)
        {
            return steering;
        }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec49"></a>How it works...</h3></div></div></div><p>By creating priority groups, we blend behaviors that are common to one another, and the first group in which the steering value exceeds the threshold is selected. Otherwise, steering from the <a id="id43" class="indexterm"></a>least-priority group is chosen.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec50"></a>There's more...</h3></div></div></div><p>We could extend this approach by mixing it with weighted blending; in this way, we would have a more robust architecture by getting extra precision on the way the behaviors make an impact on the agent in every priority level:</p><div class="informalexample"><pre class="programlisting">foreach (Steering singleSteering in group)
{
    steering.linear += singleSteering.linear * weight;
    steering.angular += singleSteering.angular * weight;
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec51"></a>See also</h3></div></div></div><p>There is an example of avoiding walls using priority-based blending in this project.</p></div></div>