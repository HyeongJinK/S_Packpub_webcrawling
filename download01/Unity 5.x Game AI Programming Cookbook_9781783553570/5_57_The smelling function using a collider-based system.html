<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec60"></a>The smelling function using a collider-based system</h2></div></div><hr /></div><p>Smelling <a id="id252" class="indexterm"></a>is one of the trickiest senses to <a id="id253" class="indexterm"></a>translate from the real to the virtual world. There are several techniques, but most of them are inclined to the use of colliders or graph logic.</p><p>Smelling can be simulated by computing a collision between an agent and odor particles scattered throughout the game level.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec204"></a>Getting ready</h3></div></div></div><p>As with the other recipes based on colliders, we will need collider components attached to every object that is to be checked, and rigid body components attached to either emitters or receivers.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec205"></a>How to do it…</h3></div></div></div><p>We will <a id="id254" class="indexterm"></a>develop the scripts for representing <a id="id255" class="indexterm"></a>odor particles and agents that are able to smell:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the particle's script and define its member variables for computing its lifespan:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class OdourParticle : MonoBehaviour
{
    public float timespan;
    private float timer;
}</pre></div></li><li><p>Implement the <code class="literal">Start</code> function for proper validations:</p><div class="informalexample"><pre class="programlisting">void Start()
{
    if (timespan &lt; 0f)
        timespan = 0f;
    timer = timespan;
}</pre></div></li><li><p>Implement the timer and destroy the object after its lifecycle:</p><div class="informalexample"><pre class="programlisting">void Update()
{
    timer -= Time.deltaTime;
    if (timer &lt; 0f)
        Destroy(gameObject);
}</pre></div></li><li><p>Create the class for representing the sniffer agent:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Smeller : MonoBehaviour
{
    private Vector3 target;
    private Dictionary&lt;int, GameObject&gt; particles;
}</pre></div></li><li><p>Initialize the dictionary for storing odor particles:</p><div class="informalexample"><pre class="programlisting">void Start()
{
    particles = new Dictionary&lt;int, GameObject&gt;();
}</pre></div></li><li><p>Add to the dictionary the colliding objects that have the odor-particle component <a id="id256" class="indexterm"></a>attached:</p><div class="informalexample"><pre class="programlisting">public void OnTriggerEnter(Collider coll)
{
    GameObject obj = coll.gameObject;
    OdourParticle op;
    op = obj.GetComponent&lt;OdourParticle&gt;();
    if (op == null)
        return;
    int objId = obj.GetInstanceID();
    particles.Add(objId, obj);
    UpdateTarget();
}</pre></div></li><li><p>Release the odor particles from the local dictionary when they are out of the agent's range or are destroyed:</p><div class="informalexample"><pre class="programlisting">public void OnTriggerExit(Collider coll)
{
    GameObject obj = coll.gameObject;
    int objId = obj.GetInstanceID();
    bool isRemoved;
    isRemoved = particles.Remove(objId);
    if (!isRemoved)
        return;
    UpdateTarget();
}</pre></div></li><li><p>Create <a id="id257" class="indexterm"></a>the function for computing the odor centroid according to the current elements in the dictionary:</p><div class="informalexample"><pre class="programlisting">private void UpdateTarget()
{
    Vector3 centroid = Vector3.zero;
    foreach (GameObject p in particles.Values)
    {
        Vector3 pos = p.transform.position;
        centroid += pos;
    }
    target = centroid;
}</pre></div></li><li><p>Implement the function for retrieving the odor centroids, if any:</p><div class="informalexample"><pre class="programlisting">public Vector3? GetTargetPosition()
{
    if (particles.Keys.Count == 0)
        return null;
    return target;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec206"></a>How it works…</h3></div></div></div><p>Just like the hearing recipe based on colliders, we use the trigger colliders in order to register odor particles in an agent's perception (implemented using a dictionary). When a particle is included or removed, the odor centroid is computed. However, we implement a <a id="id258" class="indexterm"></a>function for retrieving that centroid because when no odor particle is registered, the internal centroid position is not updated.</p><div class="mediaobject"><img src="/graphics/9781783553570/graphics/3570_05_03.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec207"></a>There is more…</h3></div></div></div><p>Particle emission <a id="id259" class="indexterm"></a>logic is left behind to be implemented according to our game's needs, and it's basically instantiating odor-particle prefabs. Also, it is recommended that you attach the rigid-body components to the agents. Odor particles are prone to be massively instantiated, reducing the game's performance.</p></div></div>