<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec38"></a>Choosing through a decision tree</h2></div></div><hr /></div><p>One of the <a id="id142" class="indexterm"></a>simplest mechanisms for tackling decision-making problems is decision trees, because they are fast and easy to grasp and implement. As a consequence, it's one of the most used techniques today; it is extensively used in other character-controlled scopes such as animations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec123"></a>Getting ready</h3></div></div></div><p>This recipe requires a good understanding of recursion and inheritance as we will constantly be implementing and calling virtual functions throughout the sections.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec124"></a>How to do it...</h3></div></div></div><p>This recipe requires a lot of attention due to the number of files that we will need to handle. Overall, we <a id="id143" class="indexterm"></a>will create a parent class <code class="literal">DecisionTreeNode</code>, from which we will derive the other ones. Finally, we will learn how to implement a couple of standard decision nodes:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, create the parent class, <code class="literal">DecisionTreeNode</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class DecisionTreeNode : MonoBehaviour
{
    public virtual DecisionTreeNode MakeDecision()
    {
        return null;
    }
}</pre></div></li><li><p>Create the pseudo-abstract class, <code class="literal">Decision</code>, deriving from the parent class, <code class="literal">DecisionTreeNode</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class Decision : DecisionTreeNode
{
    public Action nodeTrue;
    public Action nodeFalse;

    public virtual Action GetBranch()
    {
        return null;
    }
}</pre></div></li><li><p>Define the pseudo-abstract class, <code class="literal">Action</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class Action : DecisionTreeNode
{
    public bool activated = false;

    public override DecisionTreeNode MakeDecision()
    {
        return this;
    }
}</pre></div></li><li><p>Implement <a id="id144" class="indexterm"></a>the virtual function, <code class="literal">LateUpdate</code>:</p><div class="informalexample"><pre class="programlisting">public virtual void LateUpdate()
{
    if (!activated)
        return;
    // Implement your behaviors here
}</pre></div></li><li><p>Create the final class, <code class="literal">DecisionTree</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class DecisionTree : DecisionTreeNode
{
    public DecisionTreeNode root;
    private Action actionNew;
    private Action actionOld;
}</pre></div></li><li><p>Override the function, <code class="literal">MakeDecision</code>:</p><div class="informalexample"><pre class="programlisting">public override DecisionTreeNode MakeDecision()
{
    return root.MakeDecision();
}</pre></div></li><li><p>Finally, implement the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">void Update()
{
    actionNew.activated = false;
    actionOld = actionNew;
    actionNew = root.MakeDecision() as Action;
    if (actionNew == null)
        actionNew = actionOld;
    actionNew.activated = true;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec125"></a>How it works...</h3></div></div></div><p>Decision nodes choose which path to take, calling the <code class="literal">MakeDecision</code> function recursively. It is worth mentioning that branches must be decisions and leaves must be actions. Also, we should be careful not to create cycles within the tree.</p><div class="mediaobject"><img src="/graphics/9781783553570/graphics/3570_03_01.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec126"></a>There's more...</h3></div></div></div><p>We can create custom decisions and actions starting from the pseudo-abstract classes we already created. For <a id="id145" class="indexterm"></a>example, a decision on whether to attack or run away from the player.</p><p>The custom Boolean decision:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class DecisionBool : Decision
{
    public bool valueDecision;
    public bool valueTest;

    public override Action GetBranch()
    {
        if (valueTest == valueDecision)
            return nodeTrue;
        return nodeFalse;
    }
}</pre></div></div></div>