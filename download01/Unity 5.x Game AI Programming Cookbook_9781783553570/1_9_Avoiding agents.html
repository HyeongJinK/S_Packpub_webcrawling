<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec16"></a>Avoiding agents</h2></div></div><hr /></div><p>In crowd-simulation <a id="id30" class="indexterm"></a>games, it would be unnatural to see agents behaving entirely like particles in a physics-based system. The goal of this recipe is to create an agent capable of mimicking our peer-evasion movement.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec33"></a>Getting ready</h3></div></div></div><p>We need to create a tag called <span class="strong"><strong>Agent</strong></span> and assign it to those game objects that we would like to avoid, and we also need to have the <span class="strong"><strong>Agent</strong></span> script component attached to them.</p><div class="mediaobject"><img src="/graphics/9781783553570/graphics/3561_01_05.jpg" /><div class="caption"><p>An example of how should look the Inspector of a dummy agent to avoid</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec34"></a>How to do it...</h3></div></div></div><p>This recipe will <a id="id31" class="indexterm"></a>require the creation and handling of just one file:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">AvoidAgent</code> behavior, which is composed of a collision avoidance radius and the list of agents to avoid:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class AvoidAgent : AgentBehaviour
{
    public float collisionRadius = 0.4f;
    GameObject[] targets;
}</pre></div></li><li><p>Implement the <code class="literal">Start</code> function in order to set the list of agents according to the tag we created earlier:</p><div class="informalexample"><pre class="programlisting">void Start ()
{
    targets = GameObject.FindGameObjectsWithTag("Agent");
}</pre></div></li><li><p>Define the <code class="literal">GetSteering</code> function:</p><div class="informalexample"><pre class="programlisting">public override Steering GetSteering()
{
    // body
}</pre></div></li><li><p>Add the following variables to compute distances and velocities from agents that are nearby:</p><div class="informalexample"><pre class="programlisting">Steering steering = new Steering();
float shortestTime = Mathf.Infinity;
GameObject firstTarget = null;
float firstMinSeparation = 0.0f;
float firstDistance = 0.0f;
Vector3 firstRelativePos = Vector3.zero;
Vector3 firstRelativeVel = Vector3.zero;</pre></div></li><li><p>Find the closest agent that is prone to collision with the current one:</p><div class="informalexample"><pre class="programlisting">foreach (GameObject t in targets)
{
    Vector3 relativePos;
    Agent targetAgent = t.GetComponent&lt;Agent&gt;();
    relativePos = t.transform.position - transform.position;
    Vector3 relativeVel = targetAgent.velocity - agent.velocity;
    float relativeSpeed = relativeVel.magnitude;
    float timeToCollision = Vector3.Dot(relativePos, relativeVel);
    timeToCollision /= relativeSpeed * relativeSpeed * -1;
    float distance = relativePos.magnitude;
    float minSeparation = distance - relativeSpeed * timeToCollision;
    if (minSeparation &gt; 2 * collisionRadius)
        continue;
    if (timeToCollision &gt; 0.0f &amp;&amp; timeToCollision &lt; shortestTime)
    {
        shortestTime = timeToCollision;
        firstTarget = t;
        firstMinSeparation = minSeparation;
        firstRelativePos = relativePos;
        firstRelativeVel = relativeVel;
    }
}</pre></div></li><li><p>If there is <a id="id32" class="indexterm"></a>one, then get away:</p><div class="informalexample"><pre class="programlisting">if (firstTarget == null)
    return steering;
if (firstMinSeparation &lt;= 0.0f || firstDistance &lt; 2 * collisionRadius)
    firstRelativePos = firstTarget.transform.position;
else
    firstRelativePos += firstRelativeVel * shortestTime;
firstRelativePos.Normalize();
steering.linear = -firstRelativePos * agent.maxAccel;
return steering;</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec35"></a>How it works...</h3></div></div></div><p>Given a list of agents, we take into consideration which one is closest, and if it is close enough, we make it so the agent tries to escape from the expected route of that first one according to its current velocity so that they don't collide.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec36"></a>There's more</h3></div></div></div><p>This behavior works well when combined with other behaviors using blending techniques (some are included in <a id="id33" class="indexterm"></a>this chapter); otherwise it's a starting point for your own collision avoidance algorithms.</p></div></div>