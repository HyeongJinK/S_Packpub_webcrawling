<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec32"></a>Finding the shortest path with Dijkstra</h2></div></div><hr /></div><p>The <a id="id113" class="indexterm"></a>Dijkstra's algorithm was initially designed to solve the single-source shortest path problem for a graph. Thus, the algorithm <a id="id114" class="indexterm"></a>finds the lowest-cost route to everywhere from a single point. We will learn how to make use of it with two different approaches.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec102"></a>Getting ready</h3></div></div></div><p>The first thing to do is import the binary heap class from the <span class="strong"><strong>Game Programming Wiki</strong></span> (<span class="strong"><strong>GPWiki</strong></span>) into our project, given that neither the .Net framework nor Mono has a defined structure for handling binary heaps or priority queues.</p><p>For downloading the <a id="id115" class="indexterm"></a>source file and more information regarding GP Wiki's binary heap, please refer to the documentation online available at<a class="ulink" href="http://content.gpwiki.org/index.php/C_sharp:BinaryHeapOfT" target="_blank"> http://content.gpwiki.org/index.php/C_sharp:BinaryHeapOfT</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec103"></a>How to do it...</h3></div></div></div><p>We will learn how to implement the Dijkstra algorithm using the same number of parameters as the other algorithms, and then explain how to modify it to make maximum use of it <a id="id116" class="indexterm"></a>according to its original purpose.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Define the <code class="literal">GetPathDijkstra</code> function with its internal variables:</p><div class="informalexample"><pre class="programlisting">public List&lt;Vertex&gt; GetPathDijkstra(GameObject srcObj, GameObject dstObj)
{
    if (srcObj == null || dstObj == null)
        return new List&lt;Vertex&gt;();
    Vertex src = GetNearestVertex(srcObj.transform.position);
    Vertex dst = GetNearestVertex(dstObj.transform.position);
    GPWiki.BinaryHeap&lt;Edge&gt; frontier = new GPWiki.BinaryHeap&lt;Edge&gt;();
    Edge[] edges;
    Edge node, child;
    int size = vertices.Count;
    float[] distValue = new float[size];
    int[] previous = new int[size];

    // next steps
}</pre></div></li><li><p>Add the <a id="id117" class="indexterm"></a>source node to the heap (working as a priority queue) and assign a distance value of infinity to all of them but the source node:</p><div class="informalexample"><pre class="programlisting">node = new Edge(src, 0);
frontier.Add(node);
distValue[src.id] = 0;
previous[src.id] = src.id; 
for (int i = 0; i &lt; size; i++)
{
    if (i == src.id)
        continue;
    distValue[i] = Mathf.Infinity;
    previous[i] = -1;
}</pre></div></li><li><p>Define a loop to iterate while the queue is not empty:</p><div class="informalexample"><pre class="programlisting">while (frontier.Count != 0)
{
    node = frontier.Remove();
    int nodeId = node.vertex.id;
    // next steps
}
return new List&lt;Vertex&gt;();</pre></div></li><li><p>Code the procedure when arriving at the destination:</p><div class="informalexample"><pre class="programlisting">if (ReferenceEquals(node.vertex, dst))
{
    return BuildPath(src.id, node.vertex.id, ref previous);
}</pre></div></li><li><p>Otherwise, process the visited nodes and add its neighbors to the queue, and return the <a id="id118" class="indexterm"></a>path (not empty if <a id="id119" class="indexterm"></a>there is a path from source to destination vertex):</p><div class="informalexample"><pre class="programlisting">edges = GetEdges(node.vertex);
foreach (Edge e in edges)
{
    int eId = e.vertex.id;
    if (previous[eId] != -1)
        continue;
    float cost = distValue[nodeId] + e.cost;
    if (cost &lt; distValue[e.vertex.id])
    {
        distValue[eId] = cost;
        previous[eId] = nodeId;
        frontier.Remove(e);
        child = new Edge(e.vertex, cost);
        frontier.Add(child);
    }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec104"></a>How it works...</h3></div></div></div><p>The Dijkstra algorithm works in a similar way to BFS, but considers non-negative edge costs in order to build the best route from the source vertex to every other one. That's why we have an array for storing the previous vertex.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec105"></a>There's more...</h3></div></div></div><p>We will learn how to modify the current Dijkstra algorithm in order to approach the problem using pre-processing techniques and optimizing the path-finding time. It can be seen as three big steps: modifying the main algorithm, creating the pre-processing function (handy in <a id="id120" class="indexterm"></a>editor mode, for example), and, finally, defining the path-retrieval function.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Modify the main function's signature:</p><div class="informalexample"><pre class="programlisting">public int[] Dijkstra(GameObject srcObj)</pre></div></li><li><p>Change the returning value:</p><div class="informalexample"><pre class="programlisting">return previous;</pre></div></li><li><p>Remove the lines from step 4 in the <span class="emphasis"><em>How to do it</em></span> section:</p></li><li><p>Also, delete the following line at the beginning:</p><div class="informalexample"><pre class="programlisting">Vertex dst = GetNearestVertex(dstObj.transform.position);</pre></div></li><li><p>Create a new member value to the <code class="literal">Graph</code> class:</p><div class="informalexample"><pre class="programlisting">List&lt;int[]&gt; routes = new List&lt;int[]&gt;();</pre></div></li><li><p>Define the pre-processing function, called <code class="literal">DijkstraProcessing</code>:</p><div class="informalexample"><pre class="programlisting">public void DijkstraProcessing()
{
    int size = GetSize();
    for (int i = 0; i &lt; size; i++)
    {
        GameObject go = vertices[i].gameObject;
        routes.add(Dijkstra(go));
    }
}</pre></div></li><li><p>Implement <a id="id121" class="indexterm"></a>a new <code class="literal">GetPathDijkstra</code> function for path retrieval:</p><div class="informalexample"><pre class="programlisting">public List&lt;Vertex&gt; GetPathDijkstra(GameObject srcObj, GameObject dstObj)
{
    List&lt;Vertex&gt; path = new List&lt;Vertex&gt;();
    Vertex src = GetNearestVertex(srcObj);
    Vertex dst = GetNearestVertex(dstObj);
    return BuildPath(src.id, dst.id, ref routes[dst.id]);
}</pre></div></li></ol></div><p>In case you haven't noticed, we didn't implement the method <code class="literal">BuildPath</code>. This is because we talked about it at the end of the Depth-First Search recipe.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec106"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="emphasis"><em>Finding your way out of a maze with DFS</em></span>, recipe.</p></li></ul></div></div></div>