<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec49"></a>Creating good waypoints</h2></div></div><hr /></div><p>There are times <a id="id197" class="indexterm"></a>when the number of waypoints must be reduced at a certain point during the game or just for memory constraints. In this recipe, we will learn a technique called condensation that helps us deal with this problem, forcing the waypoints to compete with each other given their assigned value.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec164"></a>Getting ready</h3></div></div></div><p>In this recipe, we will deal with static member functions. It is important that we understand the use and value of static functions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec165"></a>How to do it…</h3></div></div></div><p>We will create the <code class="literal">Waypoint</code> class and add the functions for condensing the set of waypoints.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">Waypoint</code> class, deriving not only from <code class="literal">MonoBehaviour</code>, but also from the <code class="literal">IComparer</code> interface:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Waypoint : MonoBehaviour, IComparer
{
    public float value;
    public List&lt;Waypoint&gt; neighbours;
}</pre></div></li><li><p>Implement the <code class="literal">Compare</code> function from the aforementioned interface:</p><div class="informalexample"><pre class="programlisting">public int Compare(object a, object b)
{
    Waypoint wa = (Waypoint)a;
    Waypoint wb = (Waypoint)b;
    if (wa.value == wb.value)
        return 0;
    if (wa.value &lt; wb.value)
        return -1;
    return 1;
}</pre></div></li><li><p>Implement the <a id="id198" class="indexterm"></a>static function to compute whether an agent can move between two waypoints:</p><div class="informalexample"><pre class="programlisting">public static bool CanMove(Waypoint a, Waypoint b)
{
    // implement your own behaviour for
    // deciding whether an agent can move
    // easily between two waypoints
    return true;
}</pre></div></li><li><p>Start declaring the function for condensing the waypoints:</p><div class="informalexample"><pre class="programlisting">public static void CondenseWaypoints(List&lt;Waypoint&gt; waypoints, float distanceWeight)
{
    // next steps
}</pre></div></li><li><p>Initialize some variables and sort the waypoints in descending order:</p><div class="informalexample"><pre class="programlisting">distanceWeight *= distanceWeight;
waypoints.Sort();
waypoints.Reverse();
List&lt;Waypoint&gt; neighbours;</pre></div></li><li><p>Start the loop for computing each waypoint:</p><div class="informalexample"><pre class="programlisting">foreach (Waypoint current in waypoints)
{
    // next steps
}</pre></div></li><li><p>Retrieve the <a id="id199" class="indexterm"></a>waypoint neighbors, sort them, and start the loop to make them compete with each other:</p><div class="informalexample"><pre class="programlisting">neighbours = new List&lt;Waypoint&gt;(current.neighbours);
neighbours.Sort();
foreach (Waypoint target in neighbours)
{
    if (target.value &gt; current.value)
        break;
    if (!CanMove(current, target))
        continue;
    // next steps
}</pre></div></li><li><p>Compute the target's position:</p><div class="informalexample"><pre class="programlisting">Vector3 deltaPos = current.transform.position;
deltaPos -= target.transform.position;
deltaPos = Vector3.Cross(deltaPos, deltaPos);
deltaPos *= distanceWeight;</pre></div></li><li><p>Compute the target's overall value and decide whether to keep it or throw it:</p><div class="informalexample"><pre class="programlisting">float deltaVal = current.value - target.value;
deltaVal *= deltaVal;
if (deltaVal &lt; distanceWeight)
{
    neighbours.Remove(target);
    waypoints.Remove(target);
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec166"></a>How it works…</h3></div></div></div><p>The waypoints are ordered according to their relevance (such as height to be used as a sniping or advantage location) and then their neighbors are checked to see which ones are going to be dismissed from the condensation. Naturally, the less valuable waypoints are kept to the end of the computation cycle. In the next recipe, we will learn how to analyze waypoints.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec167"></a>See also</h3></div></div></div><p>Refer to the the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="emphasis"><em>Analyzing waypoints by height</em></span></p></li><li style="list-style-type: disc"><p><span class="emphasis"><em>Analyzing waypoints by cover and visibility</em></span></p></li></ul></div></div></div>