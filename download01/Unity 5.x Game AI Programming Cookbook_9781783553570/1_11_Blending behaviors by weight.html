<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec18"></a>Blending behaviors by weight</h2></div></div><hr /></div><p>Blending <a id="id38" class="indexterm"></a>techniques allow you to add behaviors and mix them without creating new scripts every time you need a new type of hybrid agent.</p><p>This is one of the most powerful techniques in this chapter, and it's probably the most used behaviour-blending approach because of its power and the low cost of implementation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec42"></a>Getting ready</h3></div></div></div><p>We must add a new member variable to our <code class="literal">AgentBehaviour</code> class called <code class="literal">weight</code> and preferably assign a default valueâ€”in this case, <code class="literal">1.0f</code>. Besides this, we should refactor the <code class="literal">Update</code> function to incorporate <code class="literal">weight</code> as a parameter to the <code class="literal">Agent</code> class' <code class="literal">SetSteering</code> function. All in all, the new <code class="literal">AgentBehaviour</code> class should look something like this:</p><div class="informalexample"><pre class="programlisting">public class AgentBehaviour : MonoBehaviour
{
    public float weight = 1.0f;

    // ... the rest of the class

    public virtual void Update ()
    {
        agent.SetSteering<span class="strong"><strong>(GetSteering(), weight)</strong></span>;
   }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec43"></a>How to do it...</h3></div></div></div><p>We just need to <a id="id39" class="indexterm"></a>change the <code class="literal">SetSteering</code> agent function's signature and definition:</p><div class="informalexample"><pre class="programlisting">public void SetSteering <span class="strong"><strong>(Steering steering, float weight)</strong></span>
{
    this.steering.linear += (weight * steering.linear);
    this.steering.angular += (weight * steering.angular);
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec44"></a>How it works...</h3></div></div></div><p>The weights are used to amplify the <code class="literal">steering</code> behavior result, and they're added to the main steering structure.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec45"></a>There's more...</h3></div></div></div><p>The weights don't necessarily need to add up to <code class="literal">1.0f</code>. The <code class="literal">weight</code> parameter is a reference for defining the relevance that the <code class="literal">steering</code> behavior will have among the other ones.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec46"></a>See also</h3></div></div></div><p>In this project, there is an example of avoiding walls, worked out using weighted blending.</p></div></div>