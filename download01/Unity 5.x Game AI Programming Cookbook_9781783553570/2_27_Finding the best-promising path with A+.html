<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec33"></a>Finding the best-promising path with A*</h2></div></div><hr /></div><p>The A* <a id="id122" class="indexterm"></a>algorithm is probably the most-used technique for path finding, given its implementation simplicity, and efficiency, and because it has room for optimization. It's no coincidence that there are several algorithms based on it. At the same time, A* shares some roots with the Dijkstra algorithm, so you'll find similarities in their implementations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec107"></a>Getting ready</h3></div></div></div><p>Just like Dijkstra's algorithm, this recipe uses the binary heap extracted from the GPWiki. Also, it is important to understand what delegates are and how they work for. Finally, we are entering into the world of informed search; that means that we need to understand what a heuristic is and what it is for.</p><p>In a nutshell, for the purpose of this recipe, a heuristic is a function for calculating the approximate <a id="id123" class="indexterm"></a>cost between two vertices in order to compare them to other alternatives and take the minimum-cost choice.</p><p>We need to add small changes to the Graph class:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Define a member variable as delegate:</p><div class="informalexample"><pre class="programlisting">public delegate float Heuristic(Vertex a, Vertex b);</pre></div></li><li><p>Implement Euclidean distance member function to use it as default heuristic:</p><div class="informalexample"><pre class="programlisting">public float EuclidDist(Vertex a, Vertex b)
{
    Vector3 posA = a.transform.position;
    Vector3 posB = b.transform.position;
    return  Vector3.Distance(posA, posB);
}</pre></div></li><li><p>Implement Manhattan distance function to use as a different heuristic. It will help us in comparing results using different heuristics:</p><div class="informalexample"><pre class="programlisting">public float ManhattanDist(Vertex a, Vertex b)
{
    Vector3 posA = a.transform.position;
    Vector3 posB = b.transform.position;
    return Mathf.Abs(posA.x - posB.x) + Mathf.Abs(posA.y - posB.y);
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec108"></a>How to do it...</h3></div></div></div><p>Even though this recipe covers defining a function, please take into consideration the comments in the code to understand the indentation and code flow more effectively:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Define the <code class="literal">GetPathAstar</code> function along with its member variables:</p><div class="informalexample"><pre class="programlisting">public List&lt;Vertex&gt; GetPathAstar(GameObject srcObj, GameObject dstObj, Heuristic h = null)
{
    if (srcObj == null || dstObj == null)
        return new List&lt;Vertex&gt;();
    if (ReferenceEquals(h, null))
        h = EuclidDist;

    Vertex src = GetNearestVertex(srcObj.transform.position);
    Vertex dst = GetNearestVertex(dstObj.transform.position);
    GPWiki.BinaryHeap&lt;Edge&gt; frontier = new GPWiki.BinaryHeap&lt;Edge&gt;();
    Edge[] edges;
    Edge node, child;
    int size = vertices.Count;
    float[] distValue = new float[size];
    int[] previous = new int[size];
    // next steps
}</pre></div></li><li><p>Add the <a id="id124" class="indexterm"></a>source node to the heap (working as a priority queue) and assign a distance value of infinity to all of them but the source node:</p><div class="informalexample"><pre class="programlisting">node = new Edge(src, 0);
frontier.Add(node);
distValue[src.id] = 0;
previous[src.id] = src.id;
for (int i = 0; i &lt; size; i++)
{
    if (i == src.id)
        continue;
    distValue[i] = Mathf.Infinity;
    previous[i] = -1;
}</pre></div></li><li><p>Declare the loop for traversing the graph:</p><div class="informalexample"><pre class="programlisting">while (frontier.Count != 0)
{
    // next steps
}
return new List&lt;Vertex&gt;();</pre></div></li><li><p>Implement the conditions for returning a path when necessary:</p><div class="informalexample"><pre class="programlisting">node = frontier.Remove();
int nodeId = node.vertex.id;
if (ReferenceEquals(node.vertex, dst))
{                 
    return BuildPath(src.id, node.vertex.id, ref previous);
}</pre></div></li><li><p>Get the vertex's neighbors (also called <code class="literal">successors</code> in some text books):</p><div class="informalexample"><pre class="programlisting">edges = GetEdges(node.vertex);</pre></div></li><li><p>Traverse the neighbors for computing the <code class="literal">cost</code> function:</p><div class="informalexample"><pre class="programlisting">foreach (Edge e in edges)
{
    int eId = e.vertex.id;
    if (previous[eId] != -1)
        continue;
    float cost = distValue[nodeId] + e.cost;
    // key point
    cost += h(node.vertex, e.vertex);
    // next step
}</pre></div></li><li><p>Expand <a id="id125" class="indexterm"></a>the list of explored nodes (frontier) and updating costs, if necessary:</p><div class="informalexample"><pre class="programlisting">if (cost &lt; distValue[e.vertex.id])
{
    distValue[eId] = cost;
    previous[eId] = nodeId;
    frontier.Remove(e);
    child = new Edge(e.vertex, cost);
    frontier.Add(child);
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec109"></a>How it works...</h3></div></div></div><p>A* works in a similar fashion to Dijkstra's algorithm. However, instead of choosing the real lowest-cost node from all the possible options, it chooses the most-promising one based on a given heuristic, and goes on from there. In our case, the default heuristic is based solely on the Euclidian distance between two vertices with the option of using Manhattan distance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec110"></a>There's more...</h3></div></div></div><p>You are welcome to play with different heuristic functions depending on the game and context, and the following is an example of how to do so:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Define a heuristic function in the <code class="literal">Graph</code> class:</p><div class="informalexample"><pre class="programlisting">public float Heuristic(Vertex a, Vertex b)
{
  float estimation = 0f;
  // your logic here
  return estimation;
}</pre></div></li></ol></div><p>The important thing here is that the heuristic we develop is both <span class="emphasis"><em>admissible</em></span> and <span class="emphasis"><em>consistent</em></span>. For more theoretical insights about these topics, please refer to <span class="emphasis"><em>Artificial Intelligence: A Modern Approach</em></span> by Russel and Norvig.</p><p>In case you haven't noticed, we didn't implement the method <code class="literal">BuildPath</code>. This is because we <a id="id126" class="indexterm"></a>talked about it at the end of the Depth-First Search recipe.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec111"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Finding the shortest path with Dijkstra</em></span> recipe</p></li><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Finding your way out of a maze with DFS</em></span> recipe</p></li></ul></div><p>For further information about Delegates, please refer to the official documentation available online at:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><a class="ulink" href="https://unity3d.com/learn/tutorials/modules/intermediate/scripting/delegates" target="_blank">https://unity3d.com/learn/tutorials/modules/intermediate/scripting/delegates</a></p></li></ul></div></div></div>