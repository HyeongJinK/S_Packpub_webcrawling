<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec51"></a>Analyzing waypoints by cover and visibility</h2></div></div><hr /></div><p>When dealing <a id="id202" class="indexterm"></a>with military games, especially FPS, we need to define a waypoint value, by its capacity, to be a good cover point with the maximum visibility for shooting or reaching other enemies visually. This recipe helps us compute a waypoint's value given these parameters.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec171"></a>Getting ready</h3></div></div></div><p>We need to create a function for checking whether a position is in the same room as others:</p><div class="informalexample"><pre class="programlisting">public bool IsInSameRoom(Vector3 from, Vector3 location, string tagWall = "Wall")
{
    RaycastHit[] hits;
    Vector3 direction = location - from;
    float rayLength = direction.magnitude;
    direction.Normalize();
    Ray ray = new Ray(from, direction);
    hits = Physics.RaycastAll(ray, rayLength);
    foreach (RaycastHit h in hits)
    {
        string tagObj = h.collider.gameObject.tag;
        if (tagObj.Equals(tagWall))
            return false;
    }
    return true;
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec172"></a>How to do it…</h3></div></div></div><p>We will create <a id="id203" class="indexterm"></a>the function that computes the quality of the waypoint:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Define the function with its parameters:</p><div class="informalexample"><pre class="programlisting">public static float GetCoverQuality(
        Vector3 location,
        int iterations,
        Vector3 characterSize,
        float radius,
        float randomRadius,
        float deltaAngle)
{
    // next steps
}</pre></div></li><li><p>Initialize the variable for handling the degrees of rotation, possible hits received, and valid visibility:</p><div class="informalexample"><pre class="programlisting">float theta = 0f;
int hits = 0;
int valid = 0;</pre></div></li><li><p>Start the main loop for the iterations to be computed on this waypoint and return the computed value:</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; iterations; i++)
{
    // next steps
}
return (float)(hits / valid);</pre></div></li><li><p>Create a random position near the waypoint's origin to see if the waypoint is easily reachable:</p><div class="informalexample"><pre class="programlisting">Vector3 from = location;
float randomBinomial = Random.Range(-1f, 1f);
from.x += radius * Mathf.Cos(theta) + randomBinomial * randomRadius;
from.y += Random.value * 2f * randomRadius;
from.z += radius * Mathf.Sin(theta) + randomBinomial * randomRadius;</pre></div></li><li><p>Check whether the random position is in the same room:</p><div class="informalexample"><pre class="programlisting">if (!IsInSameRoom(from, location))
    continue;
valid++;</pre></div></li><li><p>If the random position in the same room, then:</p><div class="informalexample"><pre class="programlisting">Vector3 to = location;
to.x += Random.Range(-1f, 1f) * characterSize.x;
to.y += Random.value * characterSize.y;
to.z += Random.Range(-1f, 1f) * characterSize.z;</pre></div></li><li><p>Cast a ray <a id="id204" class="indexterm"></a>to the visibility value to check whether:</p><div class="informalexample"><pre class="programlisting">Vector3 direction = to - location;
float distance = direction.magnitude;
direction.Normalize();
Ray ray = new Ray(location, direction);
if (Physics.Raycast(ray, distance))
    hits++;
theta = Mathf.Deg2Rad * deltaAngle;</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec173"></a>How it works…</h3></div></div></div><p>We create a number of iterations and then start putting random numbers around the waypoint to verify that it is reachable and hittable. After that, we compute a coefficient to determine its quality.</p></div></div>