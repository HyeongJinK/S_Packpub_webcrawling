<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec23"></a>Targeting a projectile</h2></div></div><hr /></div><p>Just like it's <a id="id56" class="indexterm"></a>important to predict a projectile's landing point, it's also important to develop intelligent agents capable of aiming projectiles. It wouldn't be fun if our rugby-player agents aren't capable of passing the ball.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec66"></a>Getting ready</h3></div></div></div><p>Just like the previous recipe, we only need to expand the <code class="literal">Projectile</code> class.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec67"></a>How to do it...</h3></div></div></div><p>Thanks to our previous hard work, this recipe is a real piece of cake:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">GetFireDirection</code> function:</p><div class="informalexample"><pre class="programlisting">public static Vector3 GetFireDirection (Vector3 startPos, Vector3 endPos, float speed)
{
    // body
}</pre></div></li><li><p>Solve the corresponding quadratic equation:</p><div class="informalexample"><pre class="programlisting">Vector3 direction = Vector3.zero;
Vector3 delta = endPos - startPos;
float a = Vector3.Dot(Physics.gravity, Physics.gravity);
float b = -4 * (Vector3.Dot(Physics.gravity, delta) + speed * speed);
float c = 4 * Vector3.Dot(delta, delta);
if (4 * a * c &gt; b * b)
    return direction;
float time0 = Mathf.Sqrt((-b + Mathf.Sqrt(b * b - 4 * a * c)) / (2*a));
float time1 = Mathf.Sqrt((-b - Mathf.Sqrt(b * b - 4 * a * c)) / (2*a));</pre></div></li><li><p>If shooting the projectile is feasible given the parameters, return a non-zero direction vector:</p><div class="informalexample"><pre class="programlisting">float time;
if (time0 &lt; 0.0f)
{
    if (time1 &lt; 0)
        return direction;
    time = time1;
}
else
{
    if (time1 &lt; 0)
        time = time0;
    else
        time = Mathf.Min(time0, time1);
}
direction = 2 * delta - Physics.gravity * (time * time);
direction = direction / (2 * speed * time);
return direction;</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec68"></a>How it works...</h3></div></div></div><p>Given a fixed speed, we solve the corresponding quadratic equation in order to obtain the desired direction (when <a id="id57" class="indexterm"></a>at least one time value is available), which doesn't need to be normalized because we already normalized the vector while setting up the projectile.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec69"></a>There's more...</h3></div></div></div><p>Take into account that we are returning a <span class="emphasis"><em>blank</em></span> direction when time is negative; it means that the speed is not sufficient. One way to overcome this is to define a function that tests different speeds and then shoots the projectile.</p><p>Another relevant improvement is to add an extra parameter of the type <code class="literal">bool</code> for those cases when we have two valid times (which means two possible arcs), and we need to shoot over an obstacle such as a wall:</p><div class="informalexample"><pre class="programlisting">if (isWall)
    time = Mathf.Max(time0, time1);
else
    time = Mathf.Min(time0, time1);</pre></div></div></div>