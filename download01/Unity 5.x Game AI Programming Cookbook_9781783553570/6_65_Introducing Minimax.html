<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec67"></a>Introducing Minimax</h2></div></div><hr /></div><p>Minimax is an <a id="id299" class="indexterm"></a>algorithm based on the decision to minimize the possible loss for the worst case (maximum loss). Besides game development and game theory, Minimax is a decision rule and is also used in statistics, decision theory, and philosophy.</p><p>This technique was originally formulated for the two-player zero-sum game theory, meaning that one player's win is the opponent's loss. However, in this case, it is flexible enough to handle more than two players.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec229"></a>Getting ready…</h3></div></div></div><p>It is important to know <a id="id300" class="indexterm"></a>the difference between a dynamic member function and a static member function, as well as recursion. A dynamic member function is bound to the instance of the class, while the static member function is bound to the class itself. The static method allows us to call it without instantiating an object. This is great for general-purpose algorithms, such as the one developed in this recipe.</p><p>In the case of recursion, it's not always clear that (unlike iteration) this is an iterative process that requires a base case (also called the stop condition) and a recursive case (the one to keep iterating).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec230"></a>How to do it…</h3></div></div></div><p>We will create the base class for handling all of our main algorithms and implement the <code class="literal">Minimax</code> function as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">BoardAI</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class BoardAI
{

}</pre></div></li><li><p>Declare the <code class="literal">Minimax</code> function:</p><div class="informalexample"><pre class="programlisting">public static float Minimax(
        Board board,
        int player,
        int maxDepth,
        int currentDepth,
        ref Move bestMove)
{
    // next steps here
}</pre></div></li><li><p>Consider the base case:</p><div class="informalexample"><pre class="programlisting">if (board.IsGameOver() || currentDepth == maxDepth)
    return board.Evaluate(player);</pre></div></li><li><p>Set the initial values depending on the player:</p><div class="informalexample"><pre class="programlisting">bestMove = null;
float bestScore = Mathf.Infinity;
if (board.GetCurrentPlayer() == player)
    bestScore = Mathf.NegativeInfinity;</pre></div></li><li><p>Loop through all the possible moves and return the best score:</p><div class="informalexample"><pre class="programlisting">foreach (Move m in board.GetMoves())
{
    // next steps here
}
return bestScore;</pre></div></li><li><p>Create a new <a id="id301" class="indexterm"></a>game state from the current move:</p><div class="informalexample"><pre class="programlisting">Board b = board.MakeMove(m);
float currentScore;
Move currentMove = null;</pre></div></li><li><p>Start the recursion:</p><div class="informalexample"><pre class="programlisting">currentScore = Minimax(b, player, maxDepth, currentDepth + 1, ref currentMove);</pre></div></li><li><p>Validate the score for the current player:</p><div class="informalexample"><pre class="programlisting">if (board.GetCurrentPlayer() == player)
{
    if (currentScore &gt; bestScore)
    {
        bestScore = currentScore;
        bestMove = currentMove;
    }
}</pre></div></li><li><p>Validate the score for the adversary:</p><div class="informalexample"><pre class="programlisting">else
{
    if (currentScore &lt; bestScore)
    {
        bestScore = currentScore;
        bestMove = currentMove;
    }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec231"></a>How it works…</h3></div></div></div><p>The algorithm works as a bounded depth-first search. In each step, the move is chosen by selecting the option that maximizes the player's score and assuming the opponent will take the option for minimizing it, until a terminal (leaf) node is reached.</p><p>The move tracking is done <a id="id302" class="indexterm"></a>using recursion, and the heuristic for selecting or assuming an option depends on the <code class="literal">Evaluate</code> function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec232"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Working with the game-tree class</em></span> recipe in this chapter</p></li></ul></div></div></div>