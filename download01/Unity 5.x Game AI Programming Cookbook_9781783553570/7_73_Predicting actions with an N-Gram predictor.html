<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec74"></a>Predicting actions with an N-Gram predictor</h2></div></div><hr /></div><p>Predicting <a id="id329" class="indexterm"></a>actions is a great way to give players <a id="id330" class="indexterm"></a>a challenge by going from random selection to selection based on past actions. One way to implement learning is by using probabilities in order to predict what the player will do next, and that's what an N-Gram predictor does.</p><p>To predict the next choice, N-Gram predictors hold a record of the probabilities of making a decision (which is usually a move), given all combinations of choices for the previous <span class="emphasis"><em>n</em></span> moves.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec255"></a>Getting ready…</h3></div></div></div><p>This recipe <a id="id331" class="indexterm"></a>makes use of general types. It is recommended that we have at least a basic understanding of how they work because <a id="id332" class="indexterm"></a>it's critical that we use them well.</p><p>The first thing to do is implement a data type for holding the actions and their probabilities; we'll call it <code class="literal">KeyDataRecord</code>.</p><p>The <code class="literal">KeyDataReconrd.cs</code> file should look like this:</p><div class="informalexample"><pre class="programlisting">using System.Collections;
using System.Collections.Generic;

public class KeyDataRecord&lt;T&gt;
{
    public Dictionary&lt;T, int&gt; counts;
    public int total;
    
    public KeyDataRecord()
    {
        counts = new Dictionary&lt;T, int&gt;();
    }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec256"></a>How to do it…</h3></div></div></div><p>Building N-Gram predictor is divided into five big steps. They are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the general class within a file named exactly the same:</p><div class="informalexample"><pre class="programlisting">using System.Collections;
using System.Collections.Generic;
using System.Text;

public class NGramPredictor&lt;T&gt;
{
    private int nValue;
    private Dictionary&lt;string, KeyDataRecord&lt;T&gt;&gt; data;
}</pre></div></li><li><p>Implement the constructor for initializing the member variables:</p><div class="informalexample"><pre class="programlisting">public NGramPredictor(int windowSize)
{
    nValue = windowSize + 1;
    data = new Dictionary&lt;string, KeyDataRecord&lt;T&gt;&gt;();
}</pre></div></li><li><p>Implement a <a id="id333" class="indexterm"></a>static function <a id="id334" class="indexterm"></a>for converting a set of actions into a string key:</p><div class="informalexample"><pre class="programlisting">public static string ArrToStrKey(ref T[] actions)
{
    StringBuilder builder = new StringBuilder();
    foreach (T a in actions)
    {
        builder.Append(a.ToString());
    }
    return builder.ToString();
}</pre></div></li><li><p>Define the function for registering a set of sequences:</p><div class="informalexample"><pre class="programlisting">public void RegisterSequence(T[] actions)
{
    string key = ArrToStrKey(ref actions);
    T val = actions[nValue - 1];
    if (!data.ContainsKey(key))
        data[key] = new KeyDataRecord&lt;T&gt;();
    KeyDataRecord&lt;T&gt; kdr = data[key];
    if (kdr.counts.ContainsKey(val))
        kdr.counts[val] = 0;
    kdr.counts[val]++;
    kdr.total++;
}</pre></div></li><li><p>Finally, implement the function for computing the prediction of the best action to take:</p><div class="informalexample"><pre class="programlisting">public T GetMostLikely(T[] actions)
{
    string key = ArrToStrKey(ref actions);
    KeyDataRecord&lt;T&gt; kdr = data[key];
    int highestVal = 0;
    T bestAction = default(T);
    foreach (KeyValuePair&lt;T,int&gt; kvp in kdr.counts)
    {
        if (kvp.Value &gt; highestVal)
        {
            bestAction = kvp.Key;
            highestVal = kvp.Value;
        }
    }
    return bestAction;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec257"></a>How it works…</h3></div></div></div><p>The predictor registers a set of actions according to the size of the window (the number of actions to register in order to make predictions) and assigns them a resulting value. For example, having a window size of 3, the first three are saved as a key to predict that it's possible that the <a id="id335" class="indexterm"></a>fourth one may follow.</p><p>The prediction <a id="id336" class="indexterm"></a>function computes how likely it is for an action to be the one that follows, given a set of previous actions. The more registered actions, the more accurate the predictor will be (with some limitations).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec258"></a>There is more…</h3></div></div></div><p>It is important to consider that the object of type T must override both the <code class="literal">ToString</code> function and Equals function in an admissible way for it to work correctly as an index in the internal dictionaries.</p></div></div>