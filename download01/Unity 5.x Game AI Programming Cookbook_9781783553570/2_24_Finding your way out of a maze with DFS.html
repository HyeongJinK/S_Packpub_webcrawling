<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec30"></a>Finding your way out of a maze with DFS</h2></div></div><hr /></div><p>The <a id="id104" class="indexterm"></a>
<span class="strong"><strong>Depth-First Search</strong></span> (<span class="strong"><strong>DFS</strong></span>) algorithm is a path-finding technique suitable for low-memory devices. Another common use is to build mazes with a few modifications to the list of nodes visited and discovered, however the main algorithm stays the same.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec93"></a>Getting ready</h3></div></div></div><p>This is a high-level algorithm that relies on each graph's implementation of the general functions, so the algorithm is implemented in the <code class="literal">Graph</code> class.</p><p>It is important to</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec94"></a>How to do it...</h3></div></div></div><p>Even though this recipe is only defining a function, please take into consideration the comments in the code to understand the indentation and code flow for effectively:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Declare the <code class="literal">GetPathDFS</code> function:</p><div class="informalexample"><pre class="programlisting">public List&lt;Vertex&gt; GetPathDFS(GameObject srcObj, GameObject dstObj)
{
    // next steps
}</pre></div></li><li><p>Validate if input objects are null:</p><div class="informalexample"><pre class="programlisting">if (srcObj == null || dstObj == null)
    return new List&lt;Vertex&gt;();</pre></div></li><li><p>Declare and <a id="id105" class="indexterm"></a>initialize the variables we need for the algorithm:</p><div class="informalexample"><pre class="programlisting">Vertex src = GetNearestVertex(srcObj.transform.position);
Vertex dst = GetNearestVertex(dstObj.transform.position);
Vertex[] neighbours;
Vertex v;
int[] previous = new int[vertices.Count];
for (int i = 0; i &lt; previous.Length; i++)
    previous[i] = -1;
previous[src.id] = src.id;
Stack&lt;Vertex&gt; s = new Stack&lt;Vertex&gt;();
s.Push(src);</pre></div></li><li><p>Implement the DFS algorithm for finding a path:</p><div class="informalexample"><pre class="programlisting">while (s.Count != 0)
{
    v = s.Pop();
    if (ReferenceEquals(v, dst))
    {
        return BuildPath(src.id, v.id, ref previous);
    }

    neighbours = GetNeighbours(v);
    foreach (Vertex n in neighbours)
    {
        if (previous[n.id] != -1)
            continue;
        previous[n.id] = v.id;
        s.Push(n);
    }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec95"></a>How it works...</h3></div></div></div><p>The algorithm is based on the iterative version of DFS. It is also based on the in-order traversing of a graph and the LIFO philosophy using a stack for visiting nodes and adding discovered ones.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec96"></a>There is moreâ€¦</h3></div></div></div><p>We called the <a id="id106" class="indexterm"></a>function <code class="literal">BuildPath</code>, but we haven't implemented it yet. It is important to note that this function is called by almost every other path-finding algorithm in this chapter, that's why it's not part of the main recipe.</p><p>This is the code for the <code class="literal">BuildPath</code> method:</p><div class="informalexample"><pre class="programlisting">private List&lt;Vertex&gt; BuildPath(int srcId, int dstId, ref int[] prevList)
{
    List&lt;Vertex&gt; path = new List&lt;Vertex&gt;();
    int prev = dstId;
    do
    {
        path.Add(vertices[prev]);
        prev = prevList[prev];
    } while (prev != srcId);
    return path;
}</pre></div></div></div>