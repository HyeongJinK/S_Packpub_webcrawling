<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec42"></a>Implementing behavior trees</h2></div></div><hr /></div><p>Behavior trees <a id="id160" class="indexterm"></a>can be seen as a synthesis of a number of other artificial intelligence techniques, such as finite-state machines, planning, and decision trees. In fact, they share some resemblance to FSMs, but instead of states, we think in terms of actions spanned across a tree structure.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec139"></a>Getting ready</h3></div></div></div><p>This recipe requires us to understand Coroutines.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec140"></a>How to do it...</h3></div></div></div><p>Just like decisions trees, we will create three pseudo-abstract classes for handling the process:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the base class, <code class="literal">Task</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Task : MonoBehaviour
{
    public List&lt;Task&gt; children;
    protected bool result = false;
    protected bool isFinished = false;
}</pre></div></li><li><p>Implement the finalization function:</p><div class="informalexample"><pre class="programlisting">public virtual void SetResult(bool r)
{
    result = r;
    isFinished = true;
}</pre></div></li><li><p>Implement the function for creating behaviors:</p><div class="informalexample"><pre class="programlisting">public virtual IEnumerator Run()
{
    SetResult(true);
    yield break;
}</pre></div></li><li><p>Implement <a id="id161" class="indexterm"></a>the general function for starting behaviors:</p><div class="informalexample"><pre class="programlisting">public virtual IEnumerator RunTask()
{
    yield return StartCoroutine(Run());
}</pre></div></li><li><p>Create the <code class="literal">ConditionBT</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ConditionBT : Task
{
    public override IEnumerator Run()
    {
        isFinished = false;
        bool r = false;
        // implement your behaviour here
        // define result (r) whether true or false
        //---------
        SetResult(r);
        yield break;
    }
}</pre></div></li><li><p>Create the base class for actions:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ActionBT : Task
{
    public override IEnumerator Run()
    {
        isFinished = false;
        // implement your behaviour here
        //---------
        return base.Run();
    }
}</pre></div></li><li><p>Implement <a id="id162" class="indexterm"></a>the <code class="literal">Selector</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Selector : Task
{
    public override void SetResult(bool r)
    {
        if (r == true)
            isFinished = true;
    }

    public override IEnumerator RunTask()
    {
        foreach (Task t in children)
            yield return StartCoroutine(t.RunTask());
    }
}</pre></div></li><li><p>Implement also the <code class="literal">Sequence</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Sequence : Task
{
    public override void SetResult(bool r)
    {
        if (r == true)
            isFinished = true;
    }

    public override IEnumerator RunTask()
    {
        foreach (Task t in children)
            yield return StartCoroutine(t.RunTask());
    }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec141"></a>How it works...</h3></div></div></div><p>Behavior trees work in a <a id="id163" class="indexterm"></a>similar fashion to decision trees. However, the leaf nodes are called tasks and there are some branch nodes that are not conditions, but run a set of tasks in one of two ways; Selector and Sequence. Selectors run a set of tasks and return true when one of their tasks return true, it can be seen as an OR node. Sequences run a set of tasks and return true when all of their tasks return true, it can be seen as an AND node.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec142"></a>See also</h3></div></div></div><p>For more theoretical insights, refer to Ian Millington's book, <span class="emphasis"><em>Artificial Intelligence for Games.</em></span></p></div></div>