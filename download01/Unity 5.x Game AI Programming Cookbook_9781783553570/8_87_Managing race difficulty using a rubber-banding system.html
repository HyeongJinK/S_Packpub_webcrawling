<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec87"></a>Managing race difficulty using a rubber-banding system</h2></div></div><hr /></div><p>We usually <a id="id393" class="indexterm"></a>want to create experiences <a id="id394" class="indexterm"></a>that adapt to the player, and racing games are a good field for this, given that there is this gap of the cheater agent.</p><p>In this case, we will explore a middle ground for this using a framework that allows you to come up with your own heuristic for managing the speed of the vehicle given its status. It doesn't matter if it is an arcade racing game or simulation; the framework aims to work in a similar fashion for both the cases.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec299"></a>Getting ready</h3></div></div></div><p>It is important to have grasped the basic skills in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Movement</em></span>, in order to be able to develop a strategy to extend the framework for your own needs—that is, understanding the <a id="id395" class="indexterm"></a>principles of <a id="id396" class="indexterm"></a>how the agent class works and how the behaviors help the player move toward an object. In a nutshell, we are talking about vector operations.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec300"></a>How to do it...</h3></div></div></div><p>We will implement three different classes for handling low-level and high-level AIs as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the class for the basic rival agent:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class RacingRival : MonoBehaviour
{
    public float distanceThreshold;
    public float maxSpeed;
    public Vector3 randomPos;
    protected Vector3 targetPosition;
    protected float currentSpeed;
    protected RacingCenter ghost;
}</pre></div></li><li><p>Implement the <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">void Start()
{
    ghost = FindObjectOfType&lt;RacingCenter&gt;();
}</pre></div></li><li><p>Define the <code class="literal">Update</code> function for handling the target position to follow:</p><div class="informalexample"><pre class="programlisting">public virtual void Update()
{
    targetPosition = transform.position + randomPos;
    AdjustSpeed(targetPosition);
}</pre></div></li><li><p>Define your function for adjusting the speed accordingly:</p><div class="informalexample"><pre class="programlisting">public virtual void AdjustSpeed(Vector3 targetPosition)
{
    // TODO
    // your own behaviour here
}</pre></div></li><li><p>Create <a id="id397" class="indexterm"></a>the class for <a id="id398" class="indexterm"></a>handling the ghost rider or an invincible racer:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class RacingCenter : RacingRival
{
    public GameObject player;
}</pre></div></li><li><p>Implement the initial function for finding its target:</p><div class="informalexample"><pre class="programlisting">void Start()
{
    player = GameObject.FindGameObjectWithTag("Player");
}</pre></div></li><li><p>Override the <code class="literal">Update</code> function, so the invincible car can adapt to the player's behavior:</p><div class="informalexample"><pre class="programlisting">public override void Update()
{
    Vector3 playerPos = player.transform.position;
    float dist = Vector3.Distance(transform.position, playerPos);
    if (dist &gt; distanceThreshold)
    {
        targetPosition = player.transform.position;
        base.Update();
    }
}</pre></div></li><li><p>Implement its special behavior:</p><div class="informalexample"><pre class="programlisting">public override void AdjustSpeed(Vector3 targetPosition)
{

    // TODO
    // Use in case the base behaviour also applies
    base.AdjustSpeed(targetPosition);
}</pre></div></li><li><p>Create the class for handling the high-level AI:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class Rubberband : MonoBehaviour
{
    RacingCenter ghost;
    RacingRival[] rivals;
}</pre></div></li><li><p>Assign <a id="id399" class="indexterm"></a>each racer its <a id="id400" class="indexterm"></a>random position in the rubber system. We are using a circular rubber band in this case:</p><div class="informalexample"><pre class="programlisting">void Start()
{
    ghost = FindObjectOfType&lt;RacingCenter&gt;();
    rivals = FindObjectsOfType&lt;RacingRival&gt;();
    foreach (RacingRival r in rivals)
    {
        if (ReferenceEquals(r, ghost))
            continue;
        r.randomPos = Random.insideUnitSphere;
        r.randomPos.y = ghost.transform.position.y;
    }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec301"></a>How it works…</h3></div></div></div><p>The high-level AI rubber system assigns the positions to be held by the racers. Each racer has its own behavior for adjusting speed, especially the invincible racer. This agent works as the center of the mass of the rubber band. If its dance from the player exceeds the threshold, it will adapt. Otherwise, it'll stay just the same, wobbling.</p></div></div>