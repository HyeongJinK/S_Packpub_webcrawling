<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec80"></a>Creating emergent particles using a harmony search</h2></div></div><hr /></div><p>Being a musician <a id="id359" class="indexterm"></a>myself, this recipe is one that is <a id="id360" class="indexterm"></a>close to my heart. Imagine a group of musicians with a base theme in mind. But, they've never played with each other, and as the song changes, they must adapt to the core tones with their instruments and their styles. The emulation of this adaptation is implemented using an algorithm called harmony search.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec275"></a>Getting ready…</h3></div></div></div><p>We will need to define an objective function as a delegate in order to set it up before calling the function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec276"></a>How to do it…</h3></div></div></div><p>We will now implement the algorithm in a class:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">HarmonySearch</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class HarmonySearch : MonoBehaviour
{

}</pre></div></li><li><p>Define the public inputs that are to be tuned:</p><div class="informalexample"><pre class="programlisting">[Range(1, 100)]
public int memorySize = 30;
public int pitchNum;
// consolidation rate
[Range(0.1f, 0.99f)]
public float consRate = 0.9f;
// adjustment rate
[Range(0.1f, 0.99f)]
public float adjsRate = 0.7f;
public float range = 0.05f;
public int numIterations;
[Range(0.1f, 1.0f)]
public float par = 0.3f;</pre></div></li><li><p>Define a <a id="id361" class="indexterm"></a>list of bounds. This is a <code class="literal">Vector2</code>, so <code class="literal">x</code> will represent the lowest bound and y the highest <a id="id362" class="indexterm"></a>bound. The number of bounds must be equal to the number of pitches:</p><div class="informalexample"><pre class="programlisting">public Vector2[] bounds;</pre></div></li><li><p>Define the private members for the algorithm:</p><div class="informalexample"><pre class="programlisting">private float[,] memory;
private float[] solution;
private float fitness;
private float best;</pre></div></li><li><p>Implement the initialization function:</p><div class="informalexample"><pre class="programlisting">private void Init()
{
    memory = new float[memorySize, pitchNum];
    solution = new float[memorySize];
    fitness = ObjectiveFunction(memory);
}</pre></div></li><li><p>Start defining the function for creating harmony:</p><div class="informalexample"><pre class="programlisting">private float[] CreateHarmony()
{
    float[] vector = new float[pitchNum];
    int i;
    // next steps
}</pre></div></li><li><p>Iterate through the number of pitches (instruments):</p><div class="informalexample"><pre class="programlisting">for (i = 0; i &lt; pitchNum; i++)
{
    // next steps
}</pre></div></li><li><p>Compute the new number of the possible new harmonies, given a random value:</p><div class="informalexample"><pre class="programlisting">if (Random.value &lt; consRate)
{
    int r = Random.Range(0, memory.Length);
    float val = memory[r, i];
    if (Random.value &lt; adjsRate)
        val = val + range * Random.Range(-1f, 1f);
    if (val &lt; bounds[i].x)
        val = bounds[i].x;
    if (val &gt; bounds[i].y)
        val = bounds[i].y;
    vector[i] = val;
}</pre></div></li><li><p>Define <a id="id363" class="indexterm"></a>the value in case <a id="id364" class="indexterm"></a>it needs to be randomized:</p><div class="informalexample"><pre class="programlisting">else
{
    vector[i] = Random.Range(bounds[i].x, bounds[i].y);
}</pre></div></li><li><p>Retrieve the new vector:</p><div class="informalexample"><pre class="programlisting">return vector;</pre></div></li><li><p>Define the function that will make everything work:</p><div class="informalexample"><pre class="programlisting">public float[] Run()
{
    // next steps
}</pre></div></li><li><p>Initialize the values:</p><div class="informalexample"><pre class="programlisting">Init();
int iterations = numIterations;
float best = Mathf.Infinity;</pre></div></li><li><p>Call the previous functions and computations to find the best list of pitches:</p><div class="informalexample"><pre class="programlisting">while (iterations != 0)
{
    iterations--;
    float[] harm = CreateHarmony();
    fitness = ObjectiveFunction(harm);
    best = Mathf.Min(fitness, best);
    memory = harm;
}</pre></div></li><li><p>Return the best list of pitches:</p><div class="informalexample"><pre class="programlisting">return</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec277"></a>How it works…</h3></div></div></div><p>The algorithm <a id="id365" class="indexterm"></a>initializes all the values, given the public inputs and its inner members. It iterates several times in order to find the best <a id="id366" class="indexterm"></a>list of pitches among the set of bounds and the different tones created using the previously defined objective function.</p></div></div>