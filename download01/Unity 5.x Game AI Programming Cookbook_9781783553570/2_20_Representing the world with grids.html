<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec26"></a>Representing the world with grids</h2></div></div><hr /></div><p>A grid is the <a id="id59" class="indexterm"></a>most used structure for representing <a id="id60" class="indexterm"></a>worlds in games because it is easy to implement and visualize. However, we will lay the foundations for advanced graph representations while learning the basis of graph theory and properties.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec75"></a>Getting ready</h3></div></div></div><p>First, we need to create an abstract class called <code class="literal">Graph</code>, declaring the virtual methods that every graph representation implements. It is done this way because, no matter how the vertices and edges are represented internally, the path-finding algorithms remain high-level, thus avoiding the implementation of the algorithms for each type of graph representation.</p><p>This class works as a parent class for the different representations to be learned in the chapter and it's a good starting point if you want to implement graph representations not covered in the book.</p><p>The following is the code for the <code class="literal">Graph</code> class:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the backbone with the member values:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public abstract class Graph : MonoBehaviour
{
    public GameObject vertexPrefab;
    protected List&lt;Vertex&gt; vertices;
    protected List&lt;List&lt;Vertex&gt;&gt; neighbours;
    protected List&lt;List&lt;float&gt;&gt; costs;
    // next steps
}</pre></div></li><li><p>Define the Start function:</p><div class="informalexample"><pre class="programlisting">public virtual void Start()
{
    Load();
}</pre></div></li><li><p>Define the Load function, mentioned previously:</p><div class="informalexample"><pre class="programlisting">public virtual void Load() { }</pre></div></li><li><p>Implement the function for getting the graph's size:</p><div class="informalexample"><pre class="programlisting">public virtual int GetSize()
{
    if (ReferenceEquals(vertices, null))
        return 0;
    return vertices.Count;
}</pre></div></li><li><p>Define the function for finding the nearest vertex given a position:</p><div class="informalexample"><pre class="programlisting">public virtual Vertex GetNearestVertex(Vector3 position)
{
    return null;
}</pre></div></li><li><p>Implement <a id="id61" class="indexterm"></a>the function for getting the vertex <a id="id62" class="indexterm"></a>given its ID:</p><div class="informalexample"><pre class="programlisting">public virtual Vertex GetVertexObj(int id)
{
    if (ReferenceEquals(vertices, null) || vertices.Count == 0)
        return null;
    if (id &lt; 0 || id &gt;= vertices.Count)
        return null;
    return vertices[id];
}</pre></div></li><li><p>Implement the function for retrieving a vertex' neighbours:</p><div class="informalexample"><pre class="programlisting">public virtual Vertex[] GetNeighbours(Vertex v)
{
    if (ReferenceEquals(neighbours, null) || neighbours.Count == 0)
        return new Vertex[0];
    if (v.id &lt; 0 || v.id &gt;= neighbours.Count)
        return new Vertex[0];
    return neighbours[v.id].ToArray();
}</pre></div></li></ol></div><p>We also need a <code class="literal">Vertex</code> class, with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections.Generic;
[System.Serializable]
public class Vertex : MonoBehaviour
{
    public int id;
    public List&lt;Edge&gt; neighbours;
    [HideInInspector]
    public Vertex prev;
}</pre></div><p>Following, we need to create a class for storing a vertex' neighbours with their costs. This class will be called <code class="literal">Edge</code>, and let's implement it:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">Edge</code> class, deriving from <code class="literal">IComparable</code>:</p><div class="informalexample"><pre class="programlisting">using System;

[System.Serializable]
public class Edge : IComparable&lt;Edge&gt;
{
    public float cost;
    public Vertex vertex;
    // next steps
}</pre></div></li><li><p>Implement <a id="id63" class="indexterm"></a>its constructor:</p><div class="informalexample"><pre class="programlisting">public Edge(Vertex vertex = null, float cost = 1f)
{
    this.vertex = vertex;
    this.cost = cost;
}</pre></div></li><li><p>Implement <a id="id64" class="indexterm"></a>the comparison member function:</p><div class="informalexample"><pre class="programlisting">public int CompareTo(Edge other)
{
    float result = cost - other.cost;
    int idA = vertex.GetInstanceID();
    int idB = other.vertex.GetInstanceID();
    if (idA == idB)
        return 0;
    return (int)result;
}</pre></div></li><li><p>Implement the function for comparing two edges:</p><div class="informalexample"><pre class="programlisting">public bool Equals(Edge other)
{
    return (other.vertex.id == this.vertex.id);
}</pre></div></li><li><p>Override the function for comparing two objects:</p><div class="informalexample"><pre class="programlisting">public override bool Equals(object obj)
{
    Edge other = (Edge)obj;
    return (other.vertex.id == this.vertex.id);
}</pre></div></li><li><p>Override the function for retrieving the hash code. This is necessary when overriding the previous member function:</p><div class="informalexample"><pre class="programlisting">public override int GetHashCode()
{
    return this.vertex.GetHashCode();
}</pre></div></li></ol></div><p>Besides creating the previous classes, it's important to define a couple of prefabs based on the cube primitive in order to visualize the ground (maybe a low-height cube) and walls or obstacles. The prefab for the ground is assigned to the <code class="literal">vertexPrefab</code> variable and the wall prefab is assigned to the <code class="literal">obstaclePrefab</code> variable that is declared in the next section.</p><p>Finally, create a <a id="id65" class="indexterm"></a>directory called <code class="literal">Maps</code> to store the text files for <a id="id66" class="indexterm"></a>defining the maps.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec76"></a>How to do it...</h3></div></div></div><p>Now, it's time to go in-depth and be concrete about implementing our grid graph. First, we implement all the functions for handling the graph, leaving space for your own text files, and in a following section we'll learn how to read<code class="literal">.map</code> files, which is an open format used by a lot of games:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the <code class="literal">GraphGrid</code> class deriving from Graph</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System;
using System.Collections.Generic;
using System.IO;

public class GraphGrid : Graph
{
    public GameObject obstaclePrefab;
    public string mapName = "arena.map";
    public bool get8Vicinity = false;
    public float cellSize = 1f;
    [Range(0, Mathf.Infinity)]
    public float defaultCost = 1f;
    [Range(0, Mathf.Infinity)]
    public float maximumCost = Mathf.Infinity;
    string mapsDir = "Maps";
    int numCols;
    int numRows;
    GameObject[] vertexObjs;
    // this is necessary for
    // the advanced section of reading
    // from an example test file
    bool[,] mapVertices;
    // next steps
}</pre></div></li><li><p>Define the <code class="literal">GridToId</code> and <code class="literal">IdToGrid</code> functions for transforming a position in the grid into a vertex index, and vice versa, respectively</p><div class="informalexample"><pre class="programlisting">private int GridToId(int x, int y)
{
    return Math.Max(numRows, numCols) * y + x;
}

private Vector2 IdToGrid(int id)
{
    Vector2 location = Vector2.zero;
    location.y = Mathf.Floor(id / numCols);
    location.x = Mathf.Floor(id % numCols);
    return location;
}</pre></div></li><li><p>Define the <a id="id67" class="indexterm"></a>
<code class="literal">LoadMap</code> function for reading the <a id="id68" class="indexterm"></a>text file:</p><div class="informalexample"><pre class="programlisting">private void LoadMap(string filename)
{
    // TODO
    // implement your grid-based
    // file-reading procedure here
    // using
    // vertices[i, j] for logical representation and
    // vertexObjs[i, j] for assigning new prefab instances
}</pre></div></li><li><p>Override the LoadGraph function:</p><div class="informalexample"><pre class="programlisting">public override void LoadGraph()
{
    LoadMap(mapName);
}</pre></div></li><li><p>Override the <code class="literal">GetNearestVertex</code> function. This is the traditional way, without considering that the resulting vertex is an obstacle. In the next steps we will learn how to do it better:</p><div class="informalexample"><pre class="programlisting">public override Vertex GetNearestVertex(Vector3 position)
{
    position.x = Mathf.Floor(position.x / cellSize);
    position.y = Mathf.Floor(position.z / cellSize);
    int col = (int)position.x;
    int row = (int)position.z;
    int id = GridToId(col, row);
    return vertices[id];
   }</pre></div></li><li><p>Override the <code class="literal">GetNearestVertex</code> function. It's is based on the Breadth-First Search <a id="id69" class="indexterm"></a>algorithm that we will learn in <a id="id70" class="indexterm"></a>depth later in the chapter:</p><div class="informalexample"><pre class="programlisting">public override Vertex GetNearestVertex(Vector3 position)
{
    int col = (int)(position.x / cellSize);
    int row = (int)(position.z / cellSize);
    Vector2 p = new Vector2(col, row);
    // next steps
}</pre></div></li><li><p>Define the list of explored positions (vertices) and the queue of position to be explored:</p><div class="informalexample"><pre class="programlisting">List&lt;Vector2&gt; explored = new List&lt;Vector2&gt;();
Queue&lt;Vector2&gt; queue = new Queue&lt;Vector2&gt;();
queue.Enqueue(p);</pre></div></li><li><p>Do it while the queue still have elements to explore. Otherwise, return null:</p><div class="informalexample"><pre class="programlisting">do
{
    p = queue.Dequeue();
    col = (int)p.x;
    row = (int)p.y;
    int id = GridToId(col, row);
    // next steps
} while (queue.Count != 0);
return null;</pre></div></li><li><p>Retrieve it immediately if it's a valid vertex:</p><div class="informalexample"><pre class="programlisting">if (mapVertices[row, col])
    return vertices[id];</pre></div></li><li><p>Add the position to the list of explored, if it's not already there:</p><div class="informalexample"><pre class="programlisting">if (!explored.Contains(p))
{
    explored.Add(p);
    int i, j;
    // next step
}</pre></div></li><li><p>Add all its valid neighbors to the queue, provided they're valid:</p><div class="informalexample"><pre class="programlisting">for (i = row - 1; i &lt;= row + 1; i++)
{
    for (j = col - 1; j &lt;= col + 1; j++)
    { 
        if (i &lt; 0 || j &lt; 0)
            continue;
        if (j &gt;= numCols || i &gt;= numRows)
            continue;
        if (i == row &amp;&amp; j == col)
            continue;
        queue.Enqueue(new Vector2(j, i));
    }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec77"></a>How it works...</h3></div></div></div><div class="mediaobject"><img src="/graphics/9781783553570/graphics/3561_02_02.jpg" /></div><p>The algorithm makes <a id="id71" class="indexterm"></a>use of its private functions in order to adapt itself to the general functions derived from the parent's class, and it relies on <a id="id72" class="indexterm"></a>simple mathematical functions to convert from a two-dimensional vector position to a one-dimensional vector, or vertex index.</p><p>The <code class="literal">LoadMap</code> function is open to your own implementation, but in the next section we we'll learn a way to implement and read certain kinds of text files containing maps based on grids.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec78"></a>There's more...</h3></div></div></div><p>We'll learn a way to <a id="id73" class="indexterm"></a>implement the <code class="literal">LoadMap</code> function by <a id="id74" class="indexterm"></a>using the <code class="literal">.map</code> file format as an example:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Define the function and create a <code class="literal">StreamReader</code> object for reading the file</p><div class="informalexample"><pre class="programlisting">private void LoadMap(string filename)
{
    string path = Application.dataPath + "/" + mapsDir + "/" + filename;
    try
    {
        StreamReader strmRdr = new StreamReader(path);
        using (strmRdr)
        {
            // next steps in here
        }
    }
    catch (Exception e)
    {
        Debug.LogException(e);
    }
}</pre></div></li><li><p>Declare and initialize the necessary variables</p><div class="informalexample"><pre class="programlisting">int j = 0;
int i = 0;
int id = 0;
string line;
Vector3 position = Vector3.zero;
Vector3 scale = Vector3.zero;</pre></div></li><li><p>Read the header of the file containing its height and width</p><div class="informalexample"><pre class="programlisting">line = strmRdr.ReadLine();// non-important line
line = strmRdr.ReadLine();// height
numRows = int.Parse(line.Split(' ')[1]);
line = strmRdr.ReadLine();// width
numCols = int.Parse(line.Split(' ')[1]);
line = strmRdr.ReadLine();// "map" line in file</pre></div></li><li><p>Initialize the member variables, allocating memory at the same time:</p><div class="informalexample"><pre class="programlisting">vertices = new List&lt;Vertex&gt;(numRows * numCols);
neighbours = new List&lt;List&lt;Vertex&gt;&gt;(numRows * numCols);
costs = new List&lt;List&lt;float&gt;&gt;(numRows * numCols);
vertexObjs = new GameObject[numRows * numCols];
   mapVertices = new bool[numRows, numCols];</pre></div></li><li><p>Declare the for loop for iterating over the characters in the following lines</p><div class="informalexample"><pre class="programlisting">for (i = 0; i &lt; numRows; i++)
{
    line = strmRdr.ReadLine();
    for (j = 0; j &lt; numCols; j++)
    {
        // next steps in here
    }
}</pre></div></li><li><p>Assign true <a id="id75" class="indexterm"></a>or false to the logical representation <a id="id76" class="indexterm"></a>depending on the character read</p><div class="informalexample"><pre class="programlisting">bool isGround = true;
if (line[j] != '.')
    isGround = false;
mapVertices[i, j] = isGround;</pre></div></li><li><p>Instantiate the proper prefab</p><div class="informalexample"><pre class="programlisting">position.x = j * cellSize;
position.z = i * cellSize;
id = GridToId(j, i);
if (isGround)
    vertexObjs[id] = Instantiate(vertexPrefab, position, Quaternion.identity) as GameObject;
else
    vertexObjs[id] = Instantiate(obstaclePrefab, position, Quaternion.identity) as GameObject;</pre></div></li><li><p>Assign the new game object as a child of the graph and clean-up its name</p><div class="informalexample"><pre class="programlisting">vertexObjs[id].name = vertexObjs[id].name.Replace("(Clone)", id.ToString());
Vertex v = vertexObjs[id].AddComponent&lt;Vertex&gt;();
v.id = id;
vertices.Add(v);
neighbours.Add(new List&lt;Vertex&gt;());
costs.Add(new List&lt;float&gt;());
float y = vertexObjs[id].transform.localScale.y;
scale = new Vector3(cellSize, y, cellSize);
vertexObjs[id].transform.localScale = scale;
vertexObjs[id].transform.parent = gameObject.transform;</pre></div></li><li><p>Create a pair of nested loops right after the previous loop, for setting up the neighbors for each vertex:</p><div class="informalexample"><pre class="programlisting">for (i = 0; i &lt; numRows; i++)
{
    for (j = 0; j &lt; numCols; j++)
    {
        SetNeighbours(j, i);
    }
}</pre></div></li><li><p>Define the <a id="id77" class="indexterm"></a>SetNeighbours function, called <a id="id78" class="indexterm"></a>in the previous step:</p><div class="informalexample"><pre class="programlisting">protected void SetNeighbours(int x, int y, bool get8 = false)
{
    int col = x;
    int row = y;
    int i, j;
    int vertexId = GridToId(x, y);
    neighbours[vertexId] = new List&lt;Vertex&gt;();
    costs[vertexId] = new List&lt;float&gt;();
    Vector2[] pos = new Vector2[0];
    // next steps
}</pre></div></li><li><p>Compute the proper values when we need vicinity of eight (top, bottom, right, left, and corners):</p><div class="informalexample"><pre class="programlisting">if (get8)
{
    pos = new Vector2[8];
    int c = 0;
    for (i = row - 1; i &lt;= row + 1; i++)
    {
        for (j = col -1; j &lt;= col; j++)
        {
            pos[c] = new Vector2(j, i);
            c++;
        }
    }       
}</pre></div></li><li><p>Set up everything for vicinity of four (no corners):</p><div class="informalexample"><pre class="programlisting">else
{
    pos = new Vector2[4];
    pos[0] = new Vector2(col, row - 1);
    pos[1] = new Vector2(col - 1, row);
    pos[2] = new Vector2(col + 1, row);
    pos[3] = new Vector2(col, row + 1);   
}</pre></div></li><li><p>Add the <a id="id79" class="indexterm"></a>neighbors in the lists. It's the same <a id="id80" class="indexterm"></a>procedure regarding the type of vicinity:</p><div class="informalexample"><pre class="programlisting">foreach (Vector2 p in pos)
{
    i = (int)p.y;
    j = (int)p.x;
    if (i &lt; 0 || j &lt; 0)
        continue;
    if (i &gt;= numRows || j &gt;= numCols)
        continue;
    if (i == row &amp;&amp; j == col)
        continue;
    if (!mapVertices[i, j])
        continue;
    int id = GridToId(j, i);
    neighbours[vertexId].Add(vertices[id]);
    costs[vertexId].Add(defaultCost);
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec79"></a>See also</h3></div></div></div><p>For further information about the map's format used and getting free maps from several acclaimed titles, please <a id="id81" class="indexterm"></a>refer to the <span class="emphasis"><em>Moving AI Lab's</em></span> website, led by Professor Sturtevant, available online at <a class="ulink" href="http://movingai.com/benchmarks/" target="_blank">http://movingai.com/benchmarks/</a></p></div></div>