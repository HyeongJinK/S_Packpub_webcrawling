<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec75"></a>Improving the predictor: Hierarchical N-Gram</h2></div></div><hr /></div><p>The N-Gram <a id="id337" class="indexterm"></a>predictor can be improved by having a handler with several other predictors ranging from 1 to n, and obtaining the best possible action after comparing the best guess from each one of them.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec259"></a>Getting ready…</h3></div></div></div><p>We need to make some adjustments prior to implementing the hierarchical N-Gram predictor.</p><p>Add the following member function to the <code class="literal">NGramPredictor</code> class:</p><div class="informalexample"><pre class="programlisting">public int GetActionsNum(ref T[] actions)
{
    string key = ArrToStrKey(ref actions);
    if (!data.ContainsKey(key))
        return 0;
    return data[key].total;
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec260"></a>How to do it…</h3></div></div></div><p>Just like the <a id="id338" class="indexterm"></a>N-Gram predictor, building the hierarchical version takes a few steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create the new class:</p><div class="informalexample"><pre class="programlisting">using System;
using System.Collections;
using System.Text;

public class HierarchicalNGramP&lt;T&gt;
{
    
    public int threshold;
    public NGramPredictor&lt;T&gt;[] predictors;
    private int nValue;
}</pre></div></li><li><p>Implement the constructor for initializing member values:</p><div class="informalexample"><pre class="programlisting">public HierarchicalNGramP(int windowSize)
{
    nValue = windowSize + 1;
    predictors = new NGramPredictor&lt;T&gt;[nValue];
    int i;
    for (i = 0; i &lt; nValue; i++)
        predictors[i] = new NGramPredictor&lt;T&gt;(i + 1);
}</pre></div></li><li><p>Define a function for registering a sequence, just like its predecessor:</p><div class="informalexample"><pre class="programlisting">public void RegisterSequence(T[] actions)
{
    int i;
    for (i = 0; i &lt; nValue; i++)
    {
        T[] subactions = new T[i+1];
        Array.Copy(actions, nValue - i - 1, subactions, 0, i+1);
        predictors[i].RegisterSequence(subactions);
    }
}</pre></div></li><li><p>Finally, implement the function for computing the prediction:</p><div class="informalexample"><pre class="programlisting">public T GetMostLikely(T[] actions)
{
    int i;
    T bestAction = default(T);
    for (i = 0; i &lt; nValue; i++)
    {
        NGramPredictor&lt;T&gt; p;
        p = predictors[nValue - i - 1];
        T[] subactions = new T[i + 1];
        Array.Copy(actions, nValue - i - 1, subactions, 0, i + 1);
        int numActions = p.GetActionsNum(ref actions);
        if (numActions &gt; threshold)
            bestAction = p.GetMostLikely(actions);
    }
    return bestAction;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec261"></a>How it works…</h3></div></div></div><p>The hierarchical <a id="id339" class="indexterm"></a>N-Gram predictor works almost exactly like its predecessor, with the difference being that it holds a set of predictors and computes each main function using its children. Registering sequences, or finding out the most likely future action, works by decomposing the set of actions and feeding the children with them.</p></div></div>