<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec23"></a>React AI</h2></div></div><hr /></div><p>For this demo, we <a id="id96" class="indexterm"></a>will duplicate the path-following behavior demo in React from <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Pathfinding</em></span>, and then update it to see some emergent behavior develop from it. We will need to complete the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Create a world with some walls</p></li><li style="list-style-type: disc"><p>Create target markers in the scene</p></li><li style="list-style-type: disc"><p>Create a script with a custom editor to find the targets</p></li><li style="list-style-type: disc"><p>Create the behavior</p></li><li style="list-style-type: disc"><p>Create NPCs and assign the behavior</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec08"></a>Setting up a scene with React</h3></div></div></div><p>To start <a id="id97" class="indexterm"></a>out with, we will need a basic environment for <a id="id98" class="indexterm"></a>characters to walk in. Create a plane, call it <span class="strong"><strong>Floor</strong></span>, and add some cubes, shaping them into walls. These will need to be static so that Unity's navigation mesh can find them. Then, we'll need to select the floor and add the navigation mesh. If you've forgotten how to do any of this, it is all covered in the React tutorial in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Pathfinding</em></span>.</p><p>Next, we need some targets. We'll use a different approach for this from our previous demos and let GameObjects mark the targets. Create an empty GameObject and call it <span class="strong"><strong>Targets</strong></span>. Underneath it, add more empty GameObjects. Give them all a tag, <code class="literal">NpcActivityTarget</code>, which you might need to create. Distribute these targets to different locations on the screen like this:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_04_01.jpg" /></div><p>The preceding screenshot shows how our basic React scene setup with targets should look like.</p><p>Now, we <a id="id99" class="indexterm"></a>need a script that can find these locations. It <a id="id100" class="indexterm"></a>will be based on our earlier scripts and will contain three methods: one to find a target, one to move to a target, and another to hang around.</p><p>You can find the completed script at <span class="strong"><strong>Disk</strong></span> | <span class="strong"><strong>Scripts</strong></span> | <span class="strong"><strong>React AI</strong></span> | <span class="strong"><strong>LookBusy.cs</strong></span>. To get the tags to show up as a dropdown, we've also provided a custom editor, which is also available at <span class="strong"><strong>Disk</strong></span> | <span class="strong"><strong>Scripts</strong></span> | <span class="strong"><strong>React AI</strong></span> | <span class="strong"><strong>TagOption.cs</strong></span>. You will need to put this under <code class="literal">Assets/Editor</code> for it to work in Unity. <span class="strong"><strong>TagOptions</strong></span> is a script that does nothing more than give a<a id="id101" class="indexterm"></a> drop-down selector for the tag to be used. <span class="strong"><strong>LookBusy</strong></span> uses the selected tag to find objects that are targets in the game.</p><p>Here are a couple of the methods inside the script. These are easy to reproduce or modify on your own:</p><div class="informalexample"><pre class="programlisting">GameObject[] targets = GameObject.FindGameObjectsWithTag(this.SelectedTag);
// If there are not at least two targets to choose from return an error
if(targets.Length &lt; 2) 
{
  Debug.LogWarning("LookBusy.cs:FindTarget() --&gt; There are less than 2 targets with the tag, '" + this.SelectedTag + "'. This script wants more positions.");
  yield return NodeResult.Failure;
  yield break;
}
// From the targets randomly select one and if it is closer than our minimum distance return it, otherwise keep trying a constant number of times before failing
int attempts = 0;
  
while(Vector3.Distance(this.Destination.transform.position, this.transform.position) &lt; this.MinimumDistance)
{
  this.Destination = targets[Random.Range(0, targets.Length)];
if(attempts &gt;= 25) 
{
    Debug.LogWarning("LookBusy.cs:FindTarget() --&gt; Could not find a target farther than the mininum distance. Either lower the mininum distance or space the targets farther apart.");
    yield return NodeResult.Failure;
  }
}
yield return NodeResult.Success;
}</pre></div><p>In this script, we first check whether we have at least two targets in the game tagged to select from, and if we don't have them, the script reports an error. You'll notice that the error doesn't break<a id="id102" class="indexterm"></a> the game, it just gives a specific warning <a id="id103" class="indexterm"></a>on the log of what you need and where the log was posted from. Next, the script selects a random position from the list of nodes, and if the position within a character's minimum distance (and not the same target the character is already on), the script returns the position. This random position is chosen from the list of nodes no more than a constant number of times, that is, 25 times. This random choosing method doesn't guarantee success, but it is a quick and easy way to choose a random target.</p><p>Besides picking a random place for a character to walk to, we also need a random amount of time for the NPC to stay at the location they go to. The <code class="literal">HangAround</code> method does this:</p><div class="informalexample"><pre class="programlisting">public Action HangAround()
{
  // Choose a random time to wait
  float randomtime = Random.Range(this.ShortWaitTime, this.LongWaitTime);
  while(totalTime &lt; randomtime)
  {
    totalTime += UnityEngine.Time.deltaTime;
    yield return NodeResult.Continue;
  }
  totalTime = 0;
  yield return NodeResult.Success;
}</pre></div><p>The <code class="literal">HangAround</code> function<a id="id104" class="indexterm"></a> just makes us wait a few seconds. First, it selects how long to wait, and then, once this amount of time passes, returns a success. Notice that we return <code class="literal">NodeResult.Continue</code>. This tells the script to wait until the next update and then try to get, then see if it is finished yet. (Yield is used so the game doesn't freeze up.)</p><p>The <code class="literal">MoveToTarget</code> function<a id="id105" class="indexterm"></a> isn't given here as it is nearly identical to the function we used in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Pathfinding</em></span>, except that now we are going after the target specified randomly from <code class="literal">FindTarget</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec09"></a>Building behavior trees in React</h3></div></div></div><p>Now that we <a id="id106" class="indexterm"></a>have our behavior methods, we can build <a id="id107" class="indexterm"></a>the behavior tree. Right-click on your project's <code class="literal">Assets</code> folder and navigate to <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Reactable</strong></span>. Rename it to <code class="literal">LookBusyReactable</code>. Then, right-click on it and select <span class="strong"><strong>Edit Reactable</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_04_02.jpg" /></div><p>The preceding is a screenshot of the behavior tree editor completed. Right-click on <span class="strong"><strong>Root</strong></span> and navigate to <span class="strong"><strong>Add</strong></span> | <span class="strong"><strong>Branch</strong></span> | <span class="strong"><strong>Sequence</strong></span>. This is so it completes each step before moving on to the next. Right-click on <span class="strong"><strong>Sequence</strong></span> and navigate to <span class="strong"><strong>Add</strong></span> | <span class="strong"><strong>Leaf</strong></span> | <span class="strong"><strong>Action</strong></span>. Do this three times:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>For the first one, click on the empty checkbox and navigate to <span class="strong"><strong>Scripts</strong></span> | <span class="strong"><strong>LookBusy</strong></span> | <span class="strong"><strong>FindTarget</strong></span>. This is part of the <code class="literal">LookBusy.cs</code> script that we added earlier.</p></li><li><p>For the second one, do the same but instead navigate to <span class="strong"><strong>Scripts</strong></span> | <span class="strong"><strong>LookBusy</strong></span> | <span class="strong"><strong>MoveToTarget</strong></span>.</p></li><li><p>For the third one, navigate to <span class="strong"><strong>Scripts</strong></span> | <span class="strong"><strong>LookBusy</strong></span> | <span class="strong"><strong>HangAround</strong></span>.</p></li></ol></div><p>The AI will find a random target from the list of GameObjects with the correct tag, <span class="strong"><strong>NpcActivityTarget</strong></span>, as we set in the <code class="literal">LookBusy</code> script. Then, it moves to that target and hangs around for 2 to 4 seconds.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec10"></a>Setting up wandering characters with React</h3></div></div></div><p>Finally, we <a id="id108" class="indexterm"></a>will create the NPCs and assign <a id="id109" class="indexterm"></a>a behavior. For this, you can use a character similar to the first, just a sphere stretch 2x tall, with a small cube on the front of it so that we can see the direction it is facing. Add the <code class="literal">LookBusy</code> script to the NPC:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_04_03.jpg" /></div><p>This is <a id="id110" class="indexterm"></a>how the <code class="literal">LookBusy</code> script options <a id="id111" class="indexterm"></a>look like.</p><p>
<span class="strong"><strong>Minimum Distance</strong></span> is how far away you can be from the target and still be satisfied that you reached it. <span class="strong"><strong>Short Wait Time</strong></span> and <span class="strong"><strong>Long Wait Time</strong></span> are time ranges (in seconds) you hang around for, and <span class="strong"><strong>NpcActivityTarget</strong></span> is the tag that the GameObjects have to identify as targets.</p><p>Next, add <span class="strong"><strong>Nav Mesh Agent</strong></span> to the NPC so that it can navigate around the level. Finally, add the <code class="literal">Reactor</code> script and set its <span class="strong"><strong>Reactable</strong></span> property to <span class="strong"><strong>LookBusyReactable</strong></span>, which is the behavior tree we created earlier.</p><p>This completes all the steps needed to have NPC characters wander around in a game using React. You should now be able to create as many characters as you like and have them walk around a level.</p></div></div>