<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec40"></a>Creating cover AI</h2></div></div><hr /></div><p>Our AI <a id="id232" class="indexterm"></a>enemy will just keep attacking the player as long as it is close enough to the ship. However, this isn't very realistic; we'd like the enemy ship to attack for a little bit but then duck and head for cover. We could have this hiding behavior be based on a response to the player fighting back, but for this demo, we will make it a constant value of 5 seconds; after attacking the player for 5 seconds, it will hide.</p><p>To set this up, first we'll add an <code class="literal">isHidingbool</code> variable to our behavior tree that is set to true after 5 seconds of attacking. Create a new <span class="strong"><strong>constraint</strong></span> node under the <span class="strong"><strong>root</strong></span> parallel node with the <span class="strong"><strong>playerAttack != null &amp;&amp; isHiding == false</strong></span> expression. This node's children start when <code class="literal">playerAttack</code> is valid and we are not already hiding from the player. Add a <span class="strong"><strong>sequencer</strong></span> node under this constraint so it will go through all of its children. The first child needs to be a new timer node with the <span class="strong"><strong>Seconds</strong></span> value of <span class="strong"><strong>5</strong></span> and <span class="strong"><strong>Returns</strong></span> set to <span class="strong"><strong>Success</strong></span>. Next, copy the <span class="strong"><strong>don't attack</strong></span> node and add it below the timer so that the enemy won't attack as it's running to hide.</p><p>Then, add another <span class="strong"><strong>expression</strong></span> node to set <code class="literal">isHiding</code> to true; its expression value should be <span class="strong"><strong>isHiding = true</strong></span>. The behavior tree should be like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_08_09.jpg" /></div><p>Finally, we <a id="id233" class="indexterm"></a>need to have hiding spots to go to. These are often predefined; in shooting games, hiding spots are defined based on paths the player is expected to take. To do this, create a few navigation targets by going to <span class="strong"><strong>RAIN</strong></span> | <span class="strong"><strong>Create Navigation Target</strong></span> and add them to some good cover spots for the enemy. Here's how they can be arranged:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_08_10.jpg" /></div><p>This is<a id="id234" class="indexterm"></a> how we set up navigation targets for hiding spots.</p><p>Next, we need to have the AI choose a point to take cover. Lastly, we need to select and move to a hiding spot. To organize the tree better, add a <span class="strong"><strong>selector</strong></span> node above the hiding <span class="strong"><strong>constraint</strong></span> node. Then, add another <span class="strong"><strong>constraint</strong></span> node below the <span class="strong"><strong>selector</strong></span> node and create a custom action node with a new <code class="literal">ChooseHidingSpot</code> class.</p><p>The tree should look like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_08_11.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"></a>Note</h3><p>When <a id="id235" class="indexterm"></a>creating larger trees, giving the nodes descriptive names helps keep the tree organized and easy to understand.</p></div><p>The following is the code for our action to choose a hiding spot:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_08_12.jpg" /></div><p>Here, when <a id="id236" class="indexterm"></a>we start the action, we find all the <code class="literal">NavigationTargetRig</code> objects and store them in the <code class="literal">coverPoints</code> array. Then, we go through each target and find the one closest to the enemy. Once we have the closest target, we store it in <code class="literal">hideTarget</code> and start moving to it.</p><p>As an addition to this, we can have the enemy start attacking again after hiding. Add the following line right before <code class="literal">ActionResult.SUCCESS</code> is returned:</p><div class="informalexample"><pre class="programlisting">ai.WorkingMemory.SetItem("isHiding", false);</pre></div><p>This just updates the memory to set the hiding value to false and the attack will restart. This is a simple extension and the attack can be easily extended to better attack behaviors.</p></div>