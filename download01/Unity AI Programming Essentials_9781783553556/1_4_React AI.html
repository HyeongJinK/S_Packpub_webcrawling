<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>React AI</h2></div></div><hr /></div><p>Different <a id="id7" class="indexterm"></a>Methods' React, a $45 AI, introduces a behavior tree and the use of a navigation mesh, or NavMesh. A <span class="strong"><strong>NavMesh</strong></span> is a series of interconnected polygons <a id="id8" class="indexterm"></a>forming a complex area used for travel. It creates a simplified graph of the level that is inputted into the pathfinding system. This simplified graph that it creates is smoother and tends to have characters that travel better than a grid-based graph. A behavior tree<a id="id9" class="indexterm"></a> is a parent-child structure used for making decisions in many AIs. We will look at behavior trees and navigation meshes in more detail in the later chapters. NavMesh is a basic feature available in Unity, but the behavior tree is not. Unlike the other two AIs shown, this AI requires a bit more coding to get started, but not much.</p><p>To begin<a id="id10" class="indexterm"></a> with, you'll need a new scene, as well as to import React AI from the Asset Store. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add a plane or another ground type. Then add several obstacle objects, such as cubes. Make sure that each of the objects we just created are marked static at the top of the Inspector, or the NavMesh won't identify them later on. The scene should look like this:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_01_04.jpg" /></div></li><li><p>Next, find <a id="id11" class="indexterm"></a>the <span class="strong"><strong>Window</strong></span> menu and select <span class="strong"><strong>Navigation</strong></span>. At the<a id="id12" class="indexterm"></a> bottom of the <span class="strong"><strong>Navigation</strong></span> tab, click on the <span class="strong"><strong>Bake</strong></span> command. You have now generated a simple navigation mesh for your characters to navigate. It will highlight the areas that NavMesh AIs can walk, as seen here:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_01_05.jpg" /></div></li><li><p>Let's add a player who can move around the world now. Add a capsule and name it <code class="literal">Player</code>. Fortunately, the demo contains a simple script for controlling a player who you can find (and add) by navigating to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Scripts</strong></span> | <span class="strong"><strong>Simple Player Control</strong></span>. Now, this doesn't move the object around on its own; instead it drives a <span class="strong"><strong>Character Controller</strong></span> object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>
<span class="strong"><strong>Character Controller</strong></span><a id="id13" class="indexterm"></a> is a type of an object that you can inherit in your code classes that many AIs can operate. In this case, there is a basic Character Controller type to simply move a given object around.</p></div></li><li><p>When adding the component, just start typing <code class="literal">Character Controller</code> in the search box, and it will show you all the similar component names. Add <span class="strong"><strong>Character Controller</strong></span>. Now, the player should be controllable. You will probably need to increase the speed to 1 to detect the player movement.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note03"></a>Note</h3><p>Make sure that the game object, and any body parts, do not have collider components. Controllers detect colliders to determine whether or not they can move to a given place.</p></div></li><li><p>Next, we'll <a id="id14" class="indexterm"></a>add an enemy in the same way, with <span class="strong"><strong>Capsule</strong></span>. The<a id="id15" class="indexterm"></a> enemy needs a component called <span class="strong"><strong>Nav Mesh Agent</strong></span>, which is a component capable of using a NavMesh to move around, so add it. Now, the game object has the ability to walk around, but it has nowhere to go. To get it moving, we need to add the enemy AI agent.</p></li><li><p>Next, we get to the AI for the enemy agent. In React, a behavior tree is called a <span class="strong"><strong>Reactable</strong></span>. To <a id="id16" class="indexterm"></a>add a reactor, we start the <span class="strong"><strong>Project</strong></span> explorer, in a folder of our choice, by navigating to <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Reactable</strong></span>.</p></li><li><p>Once created, rename it to <code class="literal">EnemyMovement</code>. In the Inspector, it has a list of behaviors for it. We'll need to add a script, which can be found in the book's contents: <code class="literal">\Scripts\React AI\FollowThePlayer.cs</code>. Without going in-depth in the code, let me explain the following key points:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The C# file was copied from a sample script provided with React AI that made a character move away from a target.</p></li><li style="list-style-type: disc"><p>It was rebuilt to make the player the target destination, and also to turn seeking on and off by using a button. It is not hard to adapt these scripts.</p></li><li style="list-style-type: disc"><p>Unlike normal mono behaviors, you use a special <code class="literal">Go</code> method. The go method is called by React AI only if it is selected to be used.</p></li><li style="list-style-type: disc"><p>In the<a id="id17" class="indexterm"></a> <code class="literal">Start</code> method, we see it obtain the NavMeshAgent that we attached to the enemy in the Inspector panel.</p></li><li style="list-style-type: disc"><p>In <a id="id18" class="indexterm"></a>the <code class="literal">Go</code> method, we see it feeding the destination to the NavMeshAgent, and then checking to see whether it has already found a path. Once it does, it just goes.</p></li><li style="list-style-type: disc"><p>All uses of that agent are still following standard Unity calls to use NavMesh, and can be applied without using the AI, by placing this code in a traditional behavior <code class="literal">Update</code> method.</p></li></ul></div><p>This script needs to be added to the Inspector for the <span class="strong"><strong>EnemyMovement</strong></span> asset, and also to the <code class="literal">Enemy</code> game object.</p></li><li><p>Once the script is attached to the enemy, the Inspector will reveal that it has a target. Drag the player from the <span class="strong"><strong>Hierarchy</strong></span> panel into the player attribute on the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>Finally, we have the behavior tree to set up. In the <span class="strong"><strong>Project</strong></span> panel, right-click on the <span class="strong"><strong>EnemyMovement</strong></span> asset, and click on <span class="strong"><strong>Edit</strong></span> <span class="strong"><strong>Reactable</strong></span>. A behavior tree pops up an editor, which is how we train our AI.</p></li></ol></div><p>For this <a id="id19" class="indexterm"></a>chapter, we'll just<a id="id20" class="indexterm"></a> give it a one track mind to follow the player. With <span class="strong"><strong>Root</strong></span> selected, click on the <span class="strong"><strong>Action</strong></span> button under <span class="strong"><strong>Leaf</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553556/graphics/3556OT_01_06.jpg" /></div><p>Since we only have one action in the behavior list, it selects it by default. What makes the behavior tree nice is that we can make decisions, or check whether the target is within X distance then try to follow, otherwise do something elseâ€“all from the designer. The next section on RAIN also uses a behavior tree, and most of the same basic types are used in both RAIN and React.</p><p>This took more steps than the previous AI, but there is also more going on. It is playable now.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip02"></a>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div>