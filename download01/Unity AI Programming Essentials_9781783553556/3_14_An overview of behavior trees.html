<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec18"></a>An overview of behavior trees</h2></div></div><hr /></div><p>For <a id="id47" class="indexterm"></a>game AI, we need to define logic for the different AI entity characters in the game, that is, how they will act and react to different things in the game environment. The traditional and simpler way to do this is to use <span class="strong"><strong>Finite State Machines</strong></span> (<span class="strong"><strong>FSMs</strong></span>). In <a id="id48" class="indexterm"></a>this approach, each character can be in a distinct state, and an FSM is a graph that defines states (nodes) and their transitions (edges). A simple example would be an enemy entity with two states, patrol and attack. The FSM will start in a patrol state, and when it gets close to a player, it transitions to an attack state. FSMs work for very simple state setups such as this, but they don't scale well, as the states and transitions have to be manually configured, usually through code. What if instead of the two states, our enemy character was more realistic and had 10 or even 100 different states, with many transitions between each? This becomes very difficult to manage and implement.</p><p>The popular alternative to FSMs is behavior trees. Behavior trees are a different way to define logic for characters that scale easily to having many states. Instead of defining states and transitions, behavior trees focus on defining behaviors, also called tasks, for characters. Each<a id="id49" class="indexterm"></a> behavior is a node in the tree and can consist of different sub-behaviors; so, instead of a <a id="id50" class="indexterm"></a>general graph, a tree is created of different behaviors, where each behavior is a node on the graph.</p><p>At every update for the character, the behavior tree is traversed, starting at the root node and searching down the tree. The different behavior nodes execute and return if the task is running, or has completed successfully or failed. If the node is in a running state, it is updated. Behavior trees are built by creating and configuring different behavior nodes.</p><p>We will focus on RAIN's behavior tree system in this chapter. We can use a different behavior tree system or create one from scratch; the basic logic is the same for all implementations. When using a behavior tree system, the most important thing to know are the different node types that we can use; so, let's look at RAIN's different behavior nodes.</p></div>