<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec328"></a>Time for action – score!</h2></div></div><hr /></div><p>Because the solution requires two functions that each need to access the lists of win and block opportunities, those<a id="id997" class="indexterm"></a> lists need to be defined at the top of the code as member variables that any function can access:</p><div class="informalexample"><pre class="programlisting"> var aGrid:GameObject[,];
  var gameIsOver:boolean;
  var moves:int;
<span class="strong"><strong>  var aBlockOpportunities:List.&lt;GameObject&gt;;</strong></span>
<span class="strong"><strong>  var aWinOpportunities:List.&lt;GameObject&gt;;</strong></span>
</pre></div><p>This is the combined <code class="literal">WinOrBlock</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>function WinOrBlock():GameObject</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  aBlockOpportunities = new List.&lt;GameObject&gt;();</strong></span>
<span class="strong"><strong>  aWinOpportunities = new List.&lt;GameObject&gt;();</strong></span>
<span class="strong"><strong>  // Empty out these lists before we start searching.</strong></span>
<span class="strong"><strong>  // Check the rows for 2 in a row:</strong></span>
<span class="strong"><strong>  CheckFor2InARow([Vector2(0,0), Vector2(1,0), Vector2(2,0)]);</strong></span>
<span class="strong"><strong>  CheckFor2InARow([Vector2(0,1), Vector2(1,1), Vector2(2,1)]);</strong></span>
<span class="strong"><strong>  CheckFor2InARow([Vector2(0,2), Vector2(1,2), Vector2(2,2)]);</strong></span>
<span class="strong"><strong>  // Check the columns for 2 in a row:</strong></span>
<span class="strong"><strong>  CheckFor2InARow([Vector2(0,0), Vector2(0,1), Vector2(0,2)]);</strong></span>
<span class="strong"><strong>  CheckFor2InARow([Vector2(1,0), Vector2(1,1), Vector2(1,2)]);</strong></span>
<span class="strong"><strong>  CheckFor2InARow([Vector2(2,0), Vector2(2,1), Vector2(2,2)]);</strong></span>
<span class="strong"><strong>  // Check the diagonals for 2 in a row:</strong></span>
<span class="strong"><strong>  CheckFor2InARow([Vector2(0,0), Vector2(1,1), Vector2(2,2)]);</strong></span>
<span class="strong"><strong>  CheckFor2InARow([Vector2(0,2), Vector2(1,1), Vector2(2,0)]);</strong></span>
<span class="strong"><strong>  // If there are any opportunities to win, return one at random:</strong></span>
<span class="strong"><strong>  if(aWinOpportunities.Count &gt; 0) return </strong></span>
<span class="strong"><strong>    aWinOpportunities[Random.Range(0, aWinOpportunities.Count)];</strong></span>
<span class="strong"><strong>  // If there are any opportunities to block, return one at random:</strong></span>
<span class="strong"><strong>  if(aBlockOpportunities.Count &gt; 0) return </strong></span>
<span class="strong"><strong>    aBlockOpportunities[Random.Range(0, aBlockOpportunities.Count)];</strong></span>
<span class="strong"><strong>  // There are no opportunities to win or block, so return null:</strong></span>
<span class="strong"><strong>  return null;</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Each <code class="literal">CheckFor2InARow</code> call updates the <code class="literal">aWinOpportunities</code> and <code class="literal">aBlockOpportunities</code> lists if the function finds two X's or O's in a row. Finally, here is the <code class="literal">CheckFor2InARow</code> companion<a id="id998" class="indexterm"></a> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>function CheckFor2InARow(coords:Vector2[])</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  var p1InThisRow:int = 0; // the number of X's in this row</strong></span>
<span class="strong"><strong>  var p2InThisRow:int = 0; // the number of O's in this row</strong></span>
<span class="strong"><strong>  var player:int;</strong></span>
<span class="strong"><strong>  var square:GameObject = null;</strong></span>
<span class="strong"><strong>  var coord:Vector2;</strong></span>
<span class="strong"><strong>  // Step through each of the 3 Square coordinates </strong></span>
<span class="strong"><strong>    that were passed in:</strong></span>
<span class="strong"><strong>  for (var i:int = 0; i&lt;3; i++)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    coord = coords[i];</strong></span>
<span class="strong"><strong>    player = GetPlayer(coord.x,coord.y);</strong></span>
<span class="strong"><strong>    // Find the piece in this Square</strong></span>
<span class="strong"><strong>    if(player == 1)</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      p1InThisRow ++; // Tally up an X</strong></span>
<span class="strong"><strong>    } else if(player == 2) {</strong></span>
<span class="strong"><strong>      p2InThisRow ++; // Tally up an O</strong></span>
<span class="strong"><strong>    } else {</strong></span>
<span class="strong"><strong>      square = aGrid[coord.x,coord.y];</strong></span>
<span class="strong"><strong>      // This Square is empty. Store it for later.</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  if(square != null)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    // We found an empty Square in this row.</strong></span>
<span class="strong"><strong>    if(p2InThisRow == 2)</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      // There are two O's in a row with an empty Square.</strong></span>
<span class="strong"><strong>      aWinOpportunities.Add(square);</strong></span>
<span class="strong"><strong>      // Add a win opportunity to the list.</strong></span>
<span class="strong"><strong>    } else if (p1InThisRow == 2) {</strong></span>
<span class="strong"><strong>      // There are two X's in a row with an empty Square.</strong></span>
<span class="strong"><strong>      aBlockOpportunities.Add(square);</strong></span>
<span class="strong"><strong>      // Add a block opportunity to the list.</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec125"></a>
<span class="emphasis"><em>What just happened – the search is on</em></span>
</h3></div></div></div><p>The <code class="literal">WinOrBlock</code> function kicks off by emptying out the <code class="literal">aBlockOpportunities</code> and <code class="literal">aWinOpportunities</code> arrays.</p><div class="informalexample"><pre class="programlisting"> aBlockOpportunities = new List.&lt;GameObject&gt;();
  aWinOpportunities = new List.&lt;GameObject&gt;();
  // Empty out these lists before we start searching.</pre></div><p>By doing this, we ensure<a id="id999" class="indexterm"></a> that any results leftover from earlier searches are swept out, and we start fresh.</p><p>The next eight lines are nearly identical. They all pass a different set of three squares to the <code class="literal">CheckFor2InARow</code> function.<a id="id1000" class="indexterm"></a></p><div class="informalexample"><pre class="programlisting"> CheckFor2InARow([Vector2(1,0), Vector2(1,1), Vector2(1,2)]);</pre></div><p>This call, for example, passes in the three squares in the column that runs straight down the middle of the grid.</p><div class="informalexample"><pre class="programlisting">if(aWinOpportunities.Count &gt; 0) return aWinOpportunities[Random.Range(0, aWinOpportunities.Count)];</pre></div><p>This line, like the one that follows it, determines whether there's at least one element in the <code class="literal">aWinOpportunities</code> array. If there is,<a id="id1001" class="indexterm"></a> it grabs one at random and returns it.</p><p>Let's take a closer look at the <code class="literal">CheckFor2InARow</code> function.<a id="id1002" class="indexterm"></a></p><div class="informalexample"><pre class="programlisting"> var p1InThisRow:int = 0; // the number of X's in this row
  var p2InThisRow:int = 0; // the number of O's in this row
  var player:int;
  var square:GameObject = null;
  var coord:Vector2;</pre></div><p>These variable declarations at the top are all used inside the loop, as we've seen before.</p><div class="informalexample"><pre class="programlisting"> for (var i:int = 0; i&lt;3; i++)</pre></div><p>We loop through the three coordinates that were passed in through the <code class="literal">coords</code> array in the function definition.</p><div class="informalexample"><pre class="programlisting"> coord = coords[i];</pre></div><p>First, we pull out a pair of coordinates at the ith index and store it in the coord variable.</p><div class="informalexample"><pre class="programlisting"> player = GetPlayer(coord.x,coord.y);
  // Find the piece in this Square</pre></div><p>Next, we use our prebuilt <code class="literal">GetPlayer</code> function<a id="id1003" class="indexterm"></a> to return the value of the player variable on the square at the specified coordinates.</p><div class="informalexample"><pre class="programlisting"> if(player == 1)
  {
    p1InThisRow ++; // Tally up an X</pre></div><p>If the square's player value is set to <code class="literal">1</code>, we increment the value of the <code class="literal">p1InThisRow</code> variable.</p><div class="informalexample"><pre class="programlisting"> } else if(player == 2) {
    p2InThisRow ++; // Tally up an O</pre></div><p>Otherwise, if the square's player value is <code class="literal">2</code>, we increment the <code class="literal">p2InThisRow</code> variable.</p><div class="informalexample"><pre class="programlisting"> } else {
    square = aGrid[coord.x,coord.y]; // This Square is empty. Store it for later.
  }</pre></div><p>If the player value is neither <code class="literal">1</code> nor <code class="literal">2</code>, then the square is empty. Store a reference to it in the square variable for safekeeping.</p><div class="informalexample"><pre class="programlisting"> if(square != null)</pre></div><p>If we really did find an empty square somewhere in that row, it's possible that there's a win or block opportunity here.</p><div class="informalexample"><pre class="programlisting"> if(p2InThisRow == 2)</pre></div><p>More specifically, if there was an empty square and there were two Os in the row, this is a win opportunity.</p><div class="informalexample"><pre class="programlisting"> aWinOpportunities.Add(square);</pre></div><p>We want to add this square to the list of win opportunities.</p><div class="informalexample"><pre class="programlisting"> } else if (p1InThisRow == 2) {</pre></div><p>Likewise, if there was an empty<a id="id1004" class="indexterm"></a> square and there are two Xs in the row.</p><div class="informalexample"><pre class="programlisting"> aBlockOpportunities.Add(square);</pre></div><p>we'll keep track of this square as a block possibility.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec126"></a>Shut your trap</h3></div></div></div><p>We're closing in on a completed AI routine. The last check we have to make is to set a trap if an opportunity exists, or to prevent a trap if the opponent has that chance. If you're getting antsy, you can test the game now by using double slashes to comment out these two lines of code:</p><div class="informalexample"><pre class="programlisting"> // if(square == null) square = CreateTrap();
  // if(square == null) square = PreventTrap();</pre></div><p>You'll figure out pretty quickly how important trap-blocking intelligence is. Just place an X in a corner.</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_13_08.jpg" /></div><p>The artificial intelligence steps through its logic as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Try to win or block (fail)</p></li><li style="list-style-type: disc"><p>If you can't block, try<a id="id1005" class="indexterm"></a> to set a trap (this step is commented out)</p></li><li style="list-style-type: disc"><p>If you can't set a trap, try to prevent the opponent from setting a trap (this step is commented out)</p></li><li style="list-style-type: disc"><p>If there's no trap to prevent, play the center (done!)</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_13_09.jpg" /></div></li></ul></div><p>The computer plays the center. Then you play the opposite corner.</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_13_10.jpg" /></div><p>The computer steps through its logic again, from the top:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Try to win or block (fail)</p></li><li style="list-style-type: disc"><p>If you can't block, try to set a trap (this step is commented out)</p></li><li style="list-style-type: disc"><p>If you can't set a trap, try to prevent the opponent from setting a trap (this step is commented out)</p></li><li style="list-style-type: disc"><p>If there's no trap to prevent, play the center (fail)</p></li><li style="list-style-type: disc"><p>If the center is taken, play a corner (done!)</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_13_11.jpg" /></div></li></ul></div><p>This leaves you to take that third corner, and to set an unwinnable trap for the computer. In this way, you can reliably win against the computer every single time.</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_13_12.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec127"></a>Detecting the tri-corner trap</h3></div></div></div><p>As John Rambo once said, "to win Tic Tac Toe, you gotta <span class="emphasis"><em>become </em></span>Tic Tac Toe". Before we can prevent or set a trap, we need to understand what constitutes a trap.</p><p>There are four possible trap scenarios in Tic Tac Toe:</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_13_13.jpg" /></div><p>Because our artificial intelligence does what it does, the only possible trap scenario we can manage against the computer is the<a id="id1006" class="indexterm"></a> <span class="strong"><strong>Tri-Corner</strong></span>. Try it yourself. You won't be able to set up <a id="id1007" class="indexterm"></a>
<span class="strong"><strong>Interior-L</strong></span>, <a id="id1008" class="indexterm"></a>
<span class="strong"><strong>Exterior-L</strong></span>, or <span class="strong"><strong>Staggered Row</strong></span><a id="id1009" class="indexterm"></a> traps, because of the steps the computer already takes. That's good news! That means that the Tri-Corner trap is the only one we have to worry about.</p><p>Just as we did with the <code class="literal">Win()</code> and <code class="literal">Block()</code> functions, let's look at what it will take to detect a Tri-Corner trap<a id="id1010" class="indexterm"></a> for both the player and the opponent:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>To create a trap, count up the number of corners I control. If I control two corners and a third corner is available, take it.</p></li><li style="list-style-type: disc"><p>To prevent a trap, count up the number of corners the opponent controls. If the opponent controls two corners, take a side to force him to defend (thus preventing him from grabbing that third corner).</p></li></ul></div><p>As before, it looks like there's considerable overlap between these two functions. We can probably combine them into a single function like we did with the <code class="literal">Win</code> and <code class="literal">Block</code> functions.</p></div></div>