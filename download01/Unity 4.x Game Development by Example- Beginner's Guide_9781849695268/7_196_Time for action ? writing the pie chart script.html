<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec198"></a>Time for action – writing the pie chart script</h2></div></div><hr /></div><p>With these <code class="literal">Texture2D</code> variables defined, and the images stored in those variables, we can control the images with our script.<a id="id595" class="indexterm"></a> Let's lay down some code, and pick through the aftermath when we're finished:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Because of the switcheroo we have to pull off with the two yellow half-moon pieces, knowing when the clock has passed the halfway point is pretty important with this clock. Let's create an <code class="literal">isPastHalfway</code> variable<a id="id596" class="indexterm"></a> inside our <code class="literal">OnGUI</code> function:</p><div class="informalexample"><pre class="programlisting">function OnGUI ()
{
<span class="strong"><strong>   var isPastHalfway:boolean = percent &lt; 50;</strong></span>
</pre></div><p>(Confused? Remember that our <code class="literal">percent</code> variable means "percent remaining", not "percent elapsed". When percent is less than 50, we've passed the halfway mark).</p></li><li><p>Define a rectangle in which to draw the textures:</p><div class="informalexample"><pre class="programlisting">var isPastHalfway:boolean = percent &lt; 50;
<span class="strong"><strong>var clockRect:Rect = Rect(0, 0, 128, 128);</strong></span>
</pre></div></li><li><p>On the next line, draw the background blue texture and the foreground shiny texture:</p><div class="informalexample"><pre class="programlisting">var clockRect:Rect = Rect(0, 0, 128, 128);
<span class="strong"><strong>GUI.DrawTexture(clockRect, back, ScaleMode.StretchToFill, true, 0);</strong></span>
<span class="strong"><strong>GUI.DrawTexture(clockRect, shiny, ScaleMode.StretchToFill, true, 0);</strong></span>
</pre></div></li><li><p>Save the script and play the game. <a id="id597" class="indexterm"></a>You should see your shiny blue clock glimmering at you in the top-left corner of the screen:</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_07_25.jpg" /></div></li><li><p>Next, we'll add a condition check and draw the red "finished" graphic over the top of everything when percent goes below zero (which means that time is up). Add that bit just above the "shiny" texture draw so that the shiny picture still layers on top of the red "finished" graphic:</p><div class="informalexample"><pre class="programlisting">  GUI.DrawTexture(clockRect, back, ScaleMode.StretchToFill, true, 0);
<span class="strong"><strong>  if(percent &lt; 0)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>     GUI.DrawTexture(clockRect, finished, ScaleMode.StretchToFill,</strong></span>
<span class="strong"><strong>      true, 0);</strong></span>
<span class="strong"><strong>  }</strong></span>
  GUI.DrawTexture(clockRect, shiny, ScaleMode.StretchToFill, true,
    0);</pre></div></li><li><p>Save the script and play the game<a id="id598" class="indexterm"></a> again to confirm that it's working. When time runs out, your blue clock should turn red:</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_07_26.jpg" /></div></li><li><p>Let's set up a <code class="literal">rotation</code> variable<a id="id599" class="indexterm"></a> at the top of the OnGUI function. We'll use the <code class="literal">percent</code> value to figure out how far along the 360 degree spectrum we should be rotating those yellow half-circle pieces. Note that once again, we're using the same ratio math that we used earlier with our bar clock:</p><div class="informalexample"><pre class="programlisting">var clockRect:Rect = Rect(0, 0,128,128);
<span class="strong"><strong>var rot:float = (percent/100) * 360;</strong></span>
</pre></div><p>If you want to see it working, try adding a <code class="literal">Debug.Log()</code> or <code class="literal">print()</code> statement underneath to track the value of <code class="literal">rot</code>. The value should hit 360 when the clock times out.</p></li><li><p>We have to set two more variables before the fun begins—a <code class="literal">centerPoint</code> and a <code class="literal">startMatrix</code>. We'll go over both in a moment:</p><div class="informalexample"><pre class="programlisting">   var rot:float = (percent/100) * 360;
<span class="strong"><strong>   var centerPoint:Vector2 = Vector2(64, 64);</strong></span>
<span class="strong"><strong>   var startMatrix:Matrix4x4  = GUI.matrix;</strong></span>
</pre></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec82"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>One important thing to know is that, unlike 3D <span class="strong"><strong>GameObjects</strong></span> like the <span class="strong"><strong>Paddle</strong></span> and <span class="strong"><strong>Ball</strong></span> from our keep-up game, GUI textures<a id="id600" class="indexterm"></a> can't be rotated. Even if you apply them to a <span class="strong"><strong>GameObject</strong></span> and rotate the <span class="strong"><strong>GameObject</strong></span>, the textures won't rotate (or will skew in a very strange way). We know we need to rotate those two half-circle pieces to make the pie clock count down, but because of this limitation, we'll have to find a creative workaround.</p><p>Here's the game plan: we're going to use a method of the <code class="literal">GUIUtility</code> class called <code class="literal">RotateAroundPivot</code>. The <code class="literal">centerPoint</code> value we created defines the point around which we'll rotate. <code class="literal">RotateAroundPivot</code> rotates the <span class="emphasis"><em>entire GUI</em></span>. It's as if the GUI controls were stickers on a sheet of glass, and instead of rotating the stickers, we're rotating the sheet of glass.</p><p>So we're going to follow these steps to rotate those half-circles:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Draw the blue clock background.</p></li><li><p>Rotate the GUI using the <code class="literal">rot</code> (rotation) value we set.</p></li><li><p>Draw the yellow half-circle pieces in their rotated positions. This is like stamping pictures on a piece of paper with a stamp pad. The background has already been stamped. Then, we rotate the paper and stamp the half-circles on top of it.</p></li><li><p>Rotate the GUI back to its original position.</p></li><li><p>Draw or stamp the "finished" graphic (if the timer is finished) and the shiny image.</p></li></ol></div><p>So, the background, the red "finished" image, and the shiny image all get drawn when the GUI is in its normal orientation, while the half-circle pieces get drawn when the GUI is rotated. Kinda neat, huh? That's what the <code class="literal">startMatrix</code> variable<a id="id601" class="indexterm"></a> is all about. We're storing the matrix transformation of the GUI so that we can rotate it back to its "start" position <a id="id602" class="indexterm"></a>later.</p></div></div>