<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec119"></a>Educated guesses</h2></div></div><hr /></div><p>These are the two lines from our code we'd like to understand better:</p><div class="informalexample"><pre class="programlisting">var target : Quaternion = Quaternion.Euler (tiltAroundX, 0, tiltAroundZ);
// Dampen towards the target rotation
transform.rotation = Quaternion.Slerp(transform.rotation, target,Time.deltaTime * smooth);</pre></div><p>Let's actually start from the bottom up.</p><p>In the final line of code, we're setting <code class="literal">transform.rotation</code> to something, which will turn the paddle somehow. That much, we get. We can probably also guess that <code class="literal">Quaternion</code> is one of those built-in classes that we looked at, like <code class="literal">Input</code>—both <code class="literal">Quaternion</code> and <code class="literal">Input</code> start with a capital letter, and light up when we type them.</p><p>
<code class="literal">Slerp</code> sounds weird, but it starts with a capital letter and has round brackets next to it. We've seen that same structure when we called functions earlier in our code, like <code class="literal">Input.GetAxis()</code> and <code class="literal">Debug.Log()</code>. And, just like those two functions, <code class="literal">Slerp()</code><a id="id342" class="indexterm"></a> needs some extra information to do what it does. These are called <a id="id343" class="indexterm"></a>
<span class="strong"><strong>arguments</strong></span>, and we've used them a few times already. We stuck something inside the brackets of <code class="literal">Debug.Log()</code> to make it appear at the bottom of the Unity window. Giving data to a function to make it do what it does is called <a id="id344" class="indexterm"></a>
<span class="strong"><strong>passing arguments</strong></span>.</p><p>So, what do we have? A class (or blueprint) called <code class="literal">Quaternion</code>, with a function called <code class="literal">Slerp()</code> that asks for three pieces of information—three<a id="id345" class="indexterm"></a> <span class="strong"><strong>arguments</strong></span>. For a better idea of which arguments <code class="literal">Slerp()</code> needs, type <code class="literal">Quaternion.Slerp(</code> into the Script, and read the code hinting that pops up). <code class="literal">Slerp()</code> needs these three arguments to do what it does:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">From</code>, which needs to be of type <code class="literal">UnityEngine.Quaternion</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">to</code>, which needs to be of type <code class="literal">UnityEngine.Quaternion</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">t</code>, which needs to be of type <code class="literal">float</code>
</p></li></ul></div><p>We can already see that we're passing in the <code class="literal">transform.rotation</code> value<a id="id346" class="indexterm"></a> of the <span class="strong"><strong>Paddle</strong></span> as the <code class="literal">from</code> argument, which means that <code class="literal">transform.rotation</code> must be of type <code class="literal">Quaternion</code>.</p><p>For the <code class="literal">to</code> argument, we're passing <code class="literal">target</code>, which is a variable of type <code class="literal">Quaternion</code>. We defined it one line earlier.</p><p>Finally, for the <code class="literal">t</code> argument, we're passing <code class="literal">Time.deltaTime</code> and multiplying it by the value of our <code class="literal">smooth</code> variable, which we defined way up at the top of our Script as <code class="literal">5.0</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Tip</h3><p>
<span class="strong"><strong>Time.deltaTime</strong></span>
</p><p>You'll see <code class="literal">Time.deltaTime</code> very often in your Unity travels. <code class="literal">deltaTime</code><a id="id347" class="indexterm"></a> is a property of the <code class="literal">Time</code> class; it represents the amount of time that elapsed between this frame and the last. You <a id="id348" class="indexterm"></a>usually use it to make your game move according to time rather than according to the frame rate. Frame rates can change depending on how powerful a player's computer is, but time remains consistent.</p><p>Think back to when we were moving the paddle <code class="literal">2</code> units on each <code class="literal">Update</code> call. If you were running a fast computer that ran your game at 100 frames per second, then in one second the paddle will travel 200 units. If you were running your game on a slower computer that ran at only 50 fps, the Paddle would only travel 100 units in 1 second.</p><p>
<code class="literal">Time.deltaTime</code>, conversely, is the great equalizer. Using <code class="literal">Time.deltaTime</code>, the amount that you want to move your <span class="strong"><strong>GameObject</strong></span> is calculated and spread out across 1 second. By switching from a frame-based model to a time-based model, your game will run more consistently on both the slow computer and the fast computer, because 1 second is 1 second, no matter how zippy the computer may be.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec53"></a>More on Slerp</h3></div></div></div><p>We've used our brains to try to figure out what this code is doing, so now it's time to fill in our knowledge gaps a little more.</p><p>
<span class="strong"><strong>Slerp</strong></span> is a frankenword meaning <span class="strong"><strong>Spherical linear interpretation</strong></span>. You might already have<a id="id349" class="indexterm"></a> guessed that it lets us move from one <code class="literal">Quaternion</code> rotation to another. The interpolation (or spread-outedness of the motion) happens across <code class="literal">t</code>, or time.</p><p>If we were to pseudocode this statement:</p><div class="informalexample"><pre class="programlisting">  transform.rotation = Quaternion.Slerp(transform.rotation, target,Time.deltaTime * smooth);</pre></div><p>It might go something like this:</p><p>
<span class="emphasis"><em>On every frame, rotate the</em></span><a id="id350" class="indexterm"></a>
<span class="emphasis"><em> paddle, starting at the paddle's current rotation. Rotate towards our target rotation. Use the amount of time that's elapsed between frames to stretch out (interpolate) the motion. Reduce the jerkiness of the motion by constantly supplying the paddle's updated rotation value.</em></span>
</p></div></div>