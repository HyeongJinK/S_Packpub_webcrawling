<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec181"></a>C# Addendum</h2></div></div><hr /></div><p>Let's see what it takes to convert this script from Unity JavaScript to C#. The complete C# script is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class GameScriptCSharp : MonoBehaviour
{

  private int cols = 4; // the number of columns in the card grid
  private int rows = 4; // the number of rows in the card grid
  private int totalCards = 16;
  private int matchesNeededToWin; 
  private int matchesMade = 0; // At the outset, the player has not made any matches
  private int cardW = 100; // Each card's width and height is 100 pixels
  private int cardH = 100;
  private List&lt;Card&gt; aCards; // We'll store all the cards we create in this array
  private Card[,] aGrid; // This 2d array will keep track of the shuffled, dealt cards
  private List&lt;Card&gt; aCardsFlipped; // This generic array list will store the two cards that the player flips over
  private bool playerCanClick; // We'll use this flag to prevent the player from clicking buttons when we don't want him to
  private bool playerHasWon = false; // Store whether or not the player has won. This should probably start out false :)  
  
  
  private void Start()
  {
    matchesNeededToWin = totalCards / 2; // If there are 16 cards, the player needs to find 8 matches to clear the board
    
    playerCanClick = true; // We should let the player play, don't you think?
    
    // Initialize some empty Collections:
    aCards = new List&lt;Card&gt;(); // this Generic List is our deck of cards. It can only ever hold instances of the Card class.
    aGrid = new Card[rows,cols]; // The rows and cols variables help us define the dimensions of this 2D array
    aCardsFlipped = new List&lt;Card&gt;(); // This List will store the two cards the player flips over. 
    
    BuildDeck();
  
    // Loop through the total number of rows in our aGrid List:  
    for(int i = 0; i&lt;rows; i++)
    {
      // For each individual grid row, loop through the total number of columns in the grid:
      for(int j = 0; j&lt;cols; j++)
      { 
        int someNum = Random.Range(0,aCards.Count);
        aGrid[i,j] = aCards[someNum];
        aCards.RemoveAt(someNum);
      }
    }
  }

  private void OnGUI()
  {
    GUILayout.BeginArea (new Rect (0,0,Screen.width,Screen.height)); 
    BuildGrid();
    if(playerHasWon) BuildWinPrompt();
    GUILayout.EndArea();
  }

  private void BuildWinPrompt()
  {
    int winPromptW = 120;
    int winPromptH = 90;
    
    float halfScreenW = Screen.width/2;
    float halfScreenH = Screen.height/2;
    
    int halfPromptW = winPromptW/2;
    int halfPromptH = winPromptH/2;
    
    GUI.BeginGroup(new Rect(halfScreenW-halfPromptW, halfScreenH-halfPromptH, winPromptW, winPromptH));
    GUI.Box (new Rect (0,0,winPromptW,winPromptH), "A Winner is You!!");
    
    int buttonW = 80;
    int buttonH = 20;
    
    if(GUI.Button(new Rect(halfPromptW-(buttonW/2),halfPromptH-(buttonH/2),buttonW,buttonH),"Play Again"))
    {
      Application.LoadLevel("Title");
    }
    GUI.EndGroup();
  }


  private void BuildGrid()
  {
  
    GUILayout.BeginVertical();
    GUILayout.FlexibleSpace();
    for(int i = 0; i&lt;rows; i++)
    {
      GUILayout.BeginHorizontal();
      GUILayout.FlexibleSpace();
      for(int j = 0; j&lt;cols; j++)
      {
          Card card = aGrid[i,j];  
          string img; 
          if(card.isMatched)
          {
            img = "blank";
          } else {
       
            if(card.isFaceUp)
            {
              img = card.img;
            } else {
              img = "wrench";
            }   
  
          }
          
          GUI.enabled = !card.isMatched;
        if(GUILayout.Button((Texture2D)Resources.Load(img, typeof(Texture2D)), GUILayout.Width(cardW)))
        {
          print ("playerCanClick = " + playerCanClick);
          if(playerCanClick)
          {
            FlipCardFaceUp(card);
          }
        }
        GUI.enabled = true;      
      }
      GUILayout.FlexibleSpace();
      GUILayout.EndHorizontal();   
    }
    GUILayout.FlexibleSpace();
    GUILayout.EndVertical();
  }

  private void BuildDeck()
  {
    int totalRobots = 4;  // we've got four robots to work with
    Card card; // this stores a reference to a card
    int id = 0;
  
    for(int i = 0; i&lt;totalRobots; i++)
    {
      List&lt;string&gt; aRobotParts = new List&lt;string&gt;();
      
      aRobotParts.Add("Head");
      aRobotParts.Add("Arm");
      aRobotParts.Add("Leg");
      
      for(int j=0; j&lt;2; j++)
      {
        int someNum = Random.Range(0, aRobotParts.Count);
        string theMissingPart = aRobotParts[someNum];
        
        aRobotParts.RemoveAt(someNum);
          
        card = new Card("robot" + (i+1) + "Missing" + theMissingPart,id);
        aCards.Add(card);
             
        card= new Card("robot" + (i+1) + theMissingPart, id);
        aCards.Add(card);     
        id++;
      }       
    }
  }
  
  private void FlipCardFaceUp(Card card)
  {
     card.isFaceUp = true;
     
     if(aCardsFlipped.IndexOf(card) &lt; 0)
     {
      aCardsFlipped.Add(card);
      
      if(aCardsFlipped.Count == 2)
      {
        playerCanClick = false;
             
        Invoke("CheckCards", 1);
      }
    }
  }
  
  private void CheckCards()
  {
    if(aCardsFlipped[0].id == aCardsFlipped[1].id)
    {
      // Match!
      aCardsFlipped[0].isMatched = true;
      aCardsFlipped[1].isMatched = true;
      
      matchesMade ++;
              
      if(matchesMade &gt;= matchesNeededToWin)
      {
        playerHasWon = true;
      }
                    
    } else {
      aCardsFlipped[0].isFaceUp = false;
      aCardsFlipped[1].isFaceUp = false;
    }
    
    aCardsFlipped = new List&lt;Card&gt;();
      
    playerCanClick = true;
  }
  
}</pre></div><p>Most of the conversion work here is standard. You have to change the way variables are declared by putting the type before the variable name, and deleting the colon. You should add the <span class="strong"><strong>private</strong></span> access modifier to your functions and variables. You should add <code class="literal">void</code> to most functions, because they don't return a value. No problem! We've seen all this before.</p><p>The only significant change to the code is the way we're treating that <code class="literal">yield</code> command. In JavaScript, it's a trifle. In C#, using <code class="literal">yield</code> is a little more complex, and it involves splitting your code into a separate function and returning <code class="literal">IEnumerator</code> data types and all manner of things that curl the hair of a Beginner's Guide author.</p><p>To make things simple, we've replaced <code class="literal">yield</code> with the simple and elegant <code class="literal">Invoke</code> function. Here's how it works:</p><div class="informalexample"><pre class="programlisting">  Invoke("CheckCards", 1);</pre></div><p>This means that your code grinds to a halt for one second, after which it fires the <code class="literal">CheckCards</code> function. So we've moved the function's remaining code into a new function called <code class="literal">CheckCards</code>. When the player flips a second card, there's a 1 second pause, and then the <code class="literal">CheckCards</code> function runs.</p><p>The <code class="literal">Invoke</code> function is so simple and elegant; you could put it in a puffy dress and take it to prom.</p></div>