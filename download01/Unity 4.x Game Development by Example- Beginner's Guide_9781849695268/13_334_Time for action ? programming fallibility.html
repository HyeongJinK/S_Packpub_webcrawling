<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec330"></a>Time for action – programming fallibility</h2></div></div><hr /></div><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_13_14.jpg" /></div><p>As we've discovered in the other games we've built, if the human player ain't happy, ain't nobody happy. We need to tweak the code so that our hideously perfect computer intellect makes mistakes<a id="id1014" class="indexterm"></a> every so often. But how do you program fallibility, an excruciatingly human trait, into the cold, unerring calculations of an unfeeling computer?</p><p>Well, you just throw some dice around.</p><p>By grabbing a random number as a success condition at each step of the computer's "thinking", we can simulate an error in judgment where the computer makes a "mistake".</p><p>Set the <code class="literal">square</code> variable to null off the top of the <a id="id1015" class="indexterm"></a>
<code class="literal">ComputerTakeATurn</code> function, and then add in a few dice throws:</p><div class="informalexample"><pre class="programlisting">function ComputerTakeATurn()
{
  var square:GameObject = <span class="strong"><strong>null</strong></span>;
  <span class="strong"><strong>if(Random.value &gt; 0.5f)</strong></span> square = WinOrBlock();
  if(square == null <span class="strong"><strong>&amp;&amp; Random.value &gt; 0.5f</strong></span>) square = PreventOrCreateTrap();
  if(square == null <span class="strong"><strong>&amp;&amp; Random.value &gt; 0.5f</strong></span>) square = GetCentre();
  if(square == null <span class="strong"><strong>&amp;&amp; Random.value &gt; 0.5f</strong></span>) square = GetEmptyCorner();
  if(square == null <span class="strong"><strong>&amp;&amp; Random.value &gt;0.5f</strong></span>) square = GetEmptySide();
  if(square == null) square = GetRandomEmptySquare();
  PlacePiece(OPiece, square);
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec130"></a>
<span class="emphasis"><em>What just happened – roll for initiative</em></span>
</h3></div></div></div><p>At each step of the computer's "thought" process, we're pulling a random number. If there's no valid move from the previous step and the computer passes a Dungeons and Dragons-style "roll for initiative", the computer is allowed to complete the next (and most desirable) check for a move.</p><p>If the computer fails the random number roll, the logic falls through to the next prioritized strategic move, where the computer player must again survive a random number check. The result is that by failing a "die roll" (when the random number is, randomly, less than 0.5f, about half the time), the computer makes a mistake and misses an important strategic step.</p><p>When you play the game, you'll see that it's now much more possible to defeat the computer player, because we've used random numbers to simulate errors in judgment (or, to put it in more human terms, "brain farts").</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note30"></a>Note</h3><p>Failing a dice roll on the <a id="id1016" class="indexterm"></a>
<code class="literal">WinOrBlock()</code> function makes the computer seem <span class="emphasis"><em>especially</em></span> stupid. When given the chance, who <span class="emphasis"><em>wouldn't</em></span> spot a chance to win the game or block the opponent? You might consider removing the conditional statement before the <code class="literal">WinOrBlock()</code> function call to prevent your human player from catching on that you're deliberately dumbing down your AI.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec131"></a>Turning it up to "Smart"</h3></div></div></div><p>Interestingly, this 0.5f float value handily represents the computer's level of intellect. If we crank that number up, it becomes less likely that the computer will fail a random number check, and the computer becomes "smarter" by messing up less often. By tuning the number down, the computer becomes more prone to error. Simply put, we can create a dumber computer with the turn of a dial, by replacing all those instances of 0.5f with a variable called <code class="literal">difficulty</code>, and setting that variable off the top of the game.</p><p>Having a master knob to mess around with the computer's artificial intellect is very useful, because it enables us to create different difficulty levels. We can allow the player to choose easy, medium, or hard, or a number from 1 to 10 at the beginning of the game, and tweak the float value behind the scenes to react accordingly. We can even adjust the variable up or down depending on how often the human player is winning or losing!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec132"></a>Code encore</h3></div></div></div><p>In case your own intellect was dialed down to 0.2f and you goofed somewhere along the way, here's the <a id="id1017" class="indexterm"></a>complete GameLogic code for the Tic Tac Toe game all in one shot:</p><div class="informalexample"><pre class="programlisting">#pragma strict
 
import System.Collections.Generic;
 
var XPiece:GameObject;
var OPiece:GameObject;
var currentPlayer:int = 1;
var prompt:GUIText;
var aSquares:GameObject[];
var aGrid:GameObject[,];
var gameIsOver:boolean;
var moves:int;
var aBlockOpportunities:List.&lt;GameObject&gt;;
var aWinOpportunities:List.&lt;GameObject&gt;;


function Start ()
{
  ShowPlayerPrompt();
  
  aGrid = new GameObject[3,3];

  var theSquare:GameObject;
  var theScript:Square;

  for(var i:int =0; i &lt; aSquares.Length; i++)
  {
    theSquare = aSquares[i];
    theScript = theSquare.GetComponent.&lt;Square&gt;();
    aGrid[theScript.x,theScript.y] = theSquare;
  }
  
}


function ClickSquare(square:GameObject)
{
  if(gameIsOver) return;
  
  PlacePiece(XPiece,square);
  
  if(!gameIsOver)
  {
    yield WaitForSeconds(2);
    ComputerTakeATurn();
  }

}


function PlacePiece(piece:GameObject,square:GameObject)
{

  moves ++;
  Instantiate(piece, square.transform.position, Quaternion.identity);
  square.GetComponent.&lt;Square&gt;().player = currentPlayer;
  if(CheckForWin(square))
  {
    gameIsOver = true;
    ShowWinnerPrompt();
    return;
  } else if(moves &gt;= 9) {
    gameIsOver = true;
    ShowStalematePrompt();
    return;
  }


  
  currentPlayer ++;
  if(currentPlayer &gt; 2) currentPlayer = 1;
  
  ShowPlayerPrompt();
}

function ComputerTakeATurn()
{

  var square:GameObject = null;
  
  if(Random.value &gt; 0.5f) square = WinOrBlock();
  if(square == null &amp;&amp; Random.value &gt; 0.5f) square = PreventOrCreateTrap();
  if(square == null &amp;&amp; Random.value &gt; 0.5f) square = GetCentre();
  if(square == null &amp;&amp; Random.value &gt; 0.5f) square = GetEmptyCorner();
  if(square == null &amp;&amp; Random.value &gt; 0.5f) square = GetEmptySide();

  
  PlacePiece(OPiece, square);
}

function GetRandomEmptySquare():GameObject
{
  var square:GameObject
  var aEmptySquares:List.&lt;GameObject&gt; = new List.&lt;GameObject&gt;();
  
  for(var i:int = 0; i &lt; aSquares.Length; i++)
  {
    square = aSquares[i];
    if(square.GetComponent.&lt;Square&gt;().player == 0) aEmptySquares.Add(square);
  }
  square = aEmptySquares[Random.Range(0,aEmptySquares.Count)];
  return square;
}

function WinOrBlock():GameObject
{
  aBlockOpportunities = new List.&lt;GameObject&gt;();
  aWinOpportunities = new List.&lt;GameObject&gt;(); // Empty out these lists before we start searching.
  
  // Check the rows for 2 in a row:
  CheckFor2InARow([Vector2(0,0), Vector2(1,0), Vector2(2,0)]);
  CheckFor2InARow([Vector2(0,1), Vector2(1,1), Vector2(2,1)]);
  CheckFor2InARow([Vector2(0,2), Vector2(1,2), Vector2(2,2)]);
  
  // Check the columns for 2 in a row:
  CheckFor2InARow([Vector2(0,0), Vector2(0,1), Vector2(0,2)]);
  CheckFor2InARow([Vector2(1,0), Vector2(1,1), Vector2(1,2)]);
  CheckFor2InARow([Vector2(2,0), Vector2(2,1), Vector2(2,2)]);
  
  // Check the diagonals for 2 in a row:
  CheckFor2InARow([Vector2(0,0), Vector2(1,1), Vector2(2,2)]);
  CheckFor2InARow([Vector2(0,2), Vector2(1,1), Vector2(2,0)]);
  
  // If there are any opportunities to win, return one at random:
  if(aWinOpportunities.Count &gt; 0) 
    return aWinOpportunities[Random.Range(0, aWinOpportunities.Count)];
  
  // If there are any opportunities to block, return one at random:
  if(aBlockOpportunities.Count &gt; 0)
    return aBlockOpportunities[Random.Range(0, aBlockOpportunities.Count)];
  
  // There are no opportunities to win or block, so return null:
  return null;
}

function PreventOrCreateTrap():GameObject
{
  var aP1Corners:List.&lt;GameObject&gt; = new List.&lt;GameObject&gt;(); // Create an empty list to store X-controlled corners
  var aP2Corners:List.&lt;GameObject&gt; = new List.&lt;GameObject&gt;(); // Create an empty list to store O-controlled corners
  var aOpenCorners:List.&lt;GameObject&gt; = new List.&lt;GameObject&gt;(); // Create an empty list to store unoccupied corners
  
  var aCorners:GameObject[] = [aGrid[0,0],aGrid[2,0],aGrid[0,2],aGrid[2,2]]; // Create an array to store the corner coordinates
  
  var player:int;
  var square:GameObject;
  
  // Loop through the corner coordinates:
  var i:int;
  for(i = 0; i &lt; 4; i++)
  {
    square = aCorners[i];
    player = square.GetComponent.&lt;Square&gt;().player; // Find the piece that's in this corner
    if(player == 1)
    {
      aP1Corners.Add(square); // If it's an X, add it to the X-controlled corners lists
    } else if (player == 2) {
      aP2Corners.Add(square); // If it's an O, add it to the X-controlled corners lists
    } else {
      aOpenCorners.Add(square); // If it's empty, add it to the empty corners list
    }
  }

  // Set a trap!
  // If O has two corners and there's at least one empty corner, //randomly return an empty corner from the empty corners list:
  if( aP2Corners.Count == 2 &amp;&amp; aOpenCorners.Count &gt; 0) 
    return aOpenCorners[Random.Range(0,aOpenCorners.Count)];
  
  // Prevent a trap!
  // If X has two corners, take a side to force him to defend:
  if(aP1Corners.Count == 2) return GetEmptySide();
  
  // If there's no trap to set or prevent, return null:
  return null;
}



function CheckFor2InARow(coords:Vector2[])
{
  var p1InThisRow:int = 0; // the number of X's in this row
  var p2InThisRow:int = 0; // the number of O's in this row
  var player:int;
  var square:GameObject = null;
  var coord:Vector2;
  // Step through each of the 3 Square coordinates // that were passed in:
  for (var i:int = 0; i&lt;3; i++)
  {
    coord = coords[i];
    player = GetPlayer(coord.x,coord.y); // Find the piece in this Square
    if(player == 1)
    {
      p1InThisRow ++; // Tally up an X
    } else if(player == 2) {
      p2InThisRow ++; // Tally up an O
    } else {
      square = aGrid[coord.x,coord.y]; // This Square is empty. //Store  it for later.
    }
  }
  
  if(square != null)
  {
    // We found an empty Square in this row.
    if(p2InThisRow == 2)
    {
       // There are two O's in a row with an empty Square.
       aWinOpportunities.Add(square); // Add a win opportunity to the list.
    } else if (p1InThisRow == 2) {
       // There are two X's in a row with an empty Square.
       aBlockOpportunities.Add(square); // Add a block opportunity to the list.
    }
  }
}



function GetEmptySide():GameObject
{
  var aEmptySides:List.&lt;GameObject&gt; = new List.&lt;GameObject&gt;();
  if(GetPlayer(1,0) == 0) aEmptySides.Add(aGrid[1,0]);
  if(GetPlayer(0,1) == 0) aEmptySides.Add(aGrid[0,1]);
  if(GetPlayer(2,1) == 0) aEmptySides.Add(aGrid[2,1]);
  if(GetPlayer(1,2) == 0) aEmptySides.Add(aGrid[1,2]);
  if(aEmptySides.Count &gt; 0) return aEmptySides[Random.Range(0,aEmptySides.Count)];
  return null;
}

function GetEmptyCorner():GameObject
{
  var aEmptyCorners:List.&lt;GameObject&gt; = new List.&lt;GameObject&gt;();
  
  if(GetPlayer(0,0) == 0) aEmptyCorners.Add(aGrid[0,0]);
  if(GetPlayer(2,0) == 0) aEmptyCorners.Add(aGrid[2,0]);
  if(GetPlayer(0,2) == 0) aEmptyCorners.Add(aGrid[0,2]);
  if(GetPlayer(2,2) == 0) aEmptyCorners.Add(aGrid[2,2]);
  
  if(aEmptyCorners.Count &gt; 0) return aEmptyCorners[Random.Range(0,aEmptyCorners.Count)];
  
  return null;
}

function GetCentre():GameObject
{
  if( GetPlayer(1,1) == 0 ) return aGrid[1,1];
  return null;
}




function ShowPlayerPrompt()
{
  if(currentPlayer == 1)
  {
    prompt.text = "Player 1, place an X.";
  } else {
    prompt.text = "Player 2, place an O.";
  }
}

function ShowWinnerPrompt()
{
  if(currentPlayer == 1)
  {
    prompt.text = "X gets 3 in a row. Player 1 wins!";
  } else {
    prompt.text = "O gets 3 in a row. Player 2 wins!";
  }
  
  yield WaitForSeconds(3);
  Application.LoadLevel(0);
  
}

function ShowStalematePrompt()
{
  prompt.text = "Stalemate!  Neither player wins.";
  
  yield WaitForSeconds(3);
  Application.LoadLevel(0);
}



function CheckForWin(square:GameObject):boolean
{
  var theScript:Square = square.GetComponent.&lt;Square&gt;();

  //Check the squares in the same column:
  if(GetPlayer(theScript.x,0) == currentPlayer &amp;&amp; GetPlayer(theScript.x,1) == currentPlayer &amp;&amp; GetPlayer(theScript.x,2) == currentPlayer) return true;
  
  // Check the squares in the same row:
  if(GetPlayer(0,theScript.y) == currentPlayer &amp;&amp; GetPlayer(1,theScript.y) == currentPlayer &amp;&amp; GetPlayer(2,theScript.y) == currentPlayer) return true;

  // Check the diagonals:
  if(GetPlayer(0,0) == currentPlayer &amp;&amp; GetPlayer(1,1) == currentPlayer &amp;&amp; GetPlayer(2,2) == currentPlayer) return true;
  if(GetPlayer(2,0) == currentPlayer &amp;&amp; GetPlayer(1,1) == currentPlayer &amp;&amp; GetPlayer(0,2) == currentPlayer) return true;
  
  return false; // If we get this far without finding a win, return false to signify "no win".

}


function GetPlayer(x:int, y:int):int
{
  return aGrid[x,y].GetComponent.&lt;Square&gt;().player;
}</pre></div></div></div>