<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec155"></a>Build that grid</h2></div></div><hr /></div><p>Between the area <a id="id436" class="indexterm"></a>statements, we want to build the grid of card buttons. But, to keep the code from getting hard to understand, we could make a function call out to a separate piece of code, just to keep things looking clean and easy to read. Modify your <code class="literal">OnGUI</code> code:</p><div class="informalexample"><pre class="programlisting">function OnGUI () {
   GUILayout.BeginArea (Rect (0,0,Screen.width,Screen.height));
<span class="strong"><strong>     BuildGrid();</strong></span>
   GUILayout.EndArea();
<span class="strong"><strong>   print("building grid!");</strong></span>
}</pre></div><p>That <code class="literal">building grid!</code> line is just so that you can be sure something's happening. I like to add statements like these so that I can see into the "mind" of my computer, and to make sure certain functions are getting executed. Remember that your <code class="literal">print</code> statements show up in the status bar at the bottom of the screen or in the console window if you have it open.</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_05_30.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip27"></a>Tip</h3><p>Note that if we actually try to run the code now, we'll get an error. Unity has no idea what the <code class="literal">BuildGrid</code> function is, because we haven't written it yet!</p></div><p>Let's write that <code class="literal">BuildGrid</code> function. Add this code to the bottom of the script, outside and apart from the other chunks:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>function BuildGrid()</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  GUILayout.BeginVertical();</strong></span>
<span class="strong"><strong>  for(var i:int=0; i&lt;rows; i++)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    GUILayout.BeginHorizontal();</strong></span>
<span class="strong"><strong>    for(var j:int=0; j&lt;cols; j++)</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      var card:Card = aGrid[i,j];         </strong></span>
<span class="strong"><strong>      if(GUILayout.Button(Resources.Load(card.img),</strong></span>
<span class="strong"><strong>          GUILayout.Width(cardW)))</strong></span>
<span class="strong"><strong>      {</strong></span>
<span class="strong"><strong>        Debug.Log(card.img);</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    GUILayout.EndHorizontal();   </strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  GUILayout.EndVertical();</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec61"></a>
<span class="emphasis"><em>What just happened â€“ grokking the code</em></span>
</h3></div></div></div><p>We start by wrapping the<a id="id437" class="indexterm"></a> whole thing in vertical layout tags. Controls are stacked vertically by default within a layout area, but we're explicitly calling <code class="literal">BeginVertical</code> and <code class="literal">EndVertical</code> because of some fancy layout gymnastics that we're going to perform a few steps later.</p><p>Next, we build a nested loop. Just as before, we're looping through the columns and rows. We wrap the inner loop in a horizontal layout area with the <code class="literal">BeginHorizontal</code> and <code class="literal">EndHorizontal</code> calls. By doing this, each new card button we lay down will be stacked horizontally instead of vertically.</p><p>Finally, inside the inner loop, we're using an unfamiliar statement to create a button:</p><div class="informalexample"><pre class="programlisting">if(GUILayout.Button(Resources.Load(card.img), GUILayout.Width(cardW)))</pre></div><p>In that first parameter, we're passing <code class="literal">Resources.Load</code> to fill the button with a picture instead of a piece of text. We pass the name of the picture we want to the <code class="literal">Resources.Load</code> call. Because every card's <code class="literal">img</code> variable is set to <code class="literal">robot</code>, Unity pulls the picture labeled <code class="literal">robot</code> from the <span class="strong"><strong>Resources</strong></span> folder in the <span class="strong"><strong>Assets</strong></span> library and sticks it on the button.</p><p>The second parameter is a sort of an override. We don't want our card buttons stretching to fill the width of the layout area, so we pass the <code class="literal">cardW</code> (which is set to <code class="literal">100</code> pixels at the top of the script) to the <code class="literal">GUILayout.Width</code> method.</p><p>The net result is that we loop four times, and on each loop we lay down a row of four buttons, each with a picture of a robot.</p><p>Save the script and test your<a id="id438" class="indexterm"></a> game. You should see a 4 x 4 grid of buttons, each with a yellow robot picture on it.</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_05_31.jpg" /></div></div></div>