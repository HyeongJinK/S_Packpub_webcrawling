<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec332"></a>C# addendum</h2></div></div><hr /></div><p>As promised, the complete translated C# code for the Tic Tac Toe game follows. There were a few tricky spots in the code that required a bit of tap dancing:</p><p>When a function returns a value, the value type needs to be declared in the function signature before the function name. So this function declaration in Unity Javascript:</p><div class="informalexample"><pre class="programlisting">  function CheckForWin(square:GameObject):boolean</pre></div><p>is translated like this in C#:</p><div class="informalexample"><pre class="programlisting">  private bool CheckForWin(GameObject square)</pre></div><p>In an earlier chapter, we dodged the requirements of the <code class="literal">waitForSeconds</code> method and used a different function entirely. Now that we've had more experience with return statements, we can discuss what's required.</p><p>In C#, this line:</p><div class="informalexample"><pre class="programlisting">  yield WaitForSeconds(3);</pre></div><p>becomes:</p><div class="informalexample"><pre class="programlisting">  yield return new WaitForSeconds(3);</pre></div><p>The <code class="literal">WaitForSeconds</code> method returns a result of type <code class="literal">IEnumerator</code>. Therefore, any C# function that uses <code class="literal">WaitForSeconds</code> must return <code class="literal">IEnumerator</code>. The <code class="literal">ShowStalematePrompt</code> declaration, for example, which uses the <code class="literal">WaitForSeconds</code> method, translates from this:</p><div class="informalexample"><pre class="programlisting">  function ShowStalematePrompt()</pre></div><p>to this:</p><div class="informalexample"><pre class="programlisting">  private IEnumerator ShowStalematePrompt()</pre></div><p>Remember that any variable that you want to access in the Inspector panel needs the <code class="literal">public</code> access modifier. The <code class="literal">x</code> and <code class="literal">y</code> variables in the C# <code class="literal">SquareCSharp</code> script are a good example:</p><div class="informalexample"><pre class="programlisting">  public int x;
  public int y;</pre></div><p>Because the <code class="literal">SquareCSharp</code> script accesses the <code class="literal">ClickSquare</code> method in the <code class="literal">GameLogicCSharp</code> script, the <code class="literal">ClickSquare</code> method also has to be set to <code class="literal">public</code>:</p><div class="informalexample"><pre class="programlisting">  public IEnumerator ClickSquare(GameObject square)</pre></div><p>Note that the <code class="literal">ClickSquare</code> method also uses <code class="literal">WaitForSeconds</code>, so it needs to return a value of type <code class="literal">IEnumerator</code>. This poses a problem, because this line:</p><div class="informalexample"><pre class="programlisting">  if(gameIsOver) return;</pre></div><p>Since the function is expecting us to <code class="literal">return</code> a value of type <code class="literal">IEnumerator</code>, we can't use a naked <code class="literal">return</code> keyword, because it doesn't return anything. We can get around the issue by replacing <code class="literal">return</code> with this:</p><div class="informalexample"><pre class="programlisting">  yield break;</pre></div><p>Here, then, are the two Tic Tac Toe scripts completely translated into C#:</p><p>
<span class="strong"><strong>SquareCSharp.cs</strong></span>
</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class SquareCSharp : MonoBehaviour {

  public int x;
  public int y;
  public int player = 0;
  private GameObject gameLogic;
  
  
  private void Start ()
  {
    gameLogic = GameObject.Find("GameLogic");
  }
  
  private void OnMouseDown()
  {
    print ("player = " + player);
    if(player == 0)
    {
      print ("let's do this");
      gameLogic.GetComponent&lt;GameLogicCSharp&gt;().ClickSquare(gameObject);
    }
  }
}</pre></div><p>
<span class="strong"><strong>GameLogicCSharp.cs</strong></span>
</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class GameLogicCSharp : MonoBehaviour
{

  public GameObject XPiece;
  public GameObject OPiece;
  private int currentPlayer = 1;
  public GUIText prompt;
  public GameObject[] aSquares;
  private GameObject[,] aGrid;
  private bool gameIsOver;
  private int moves;

  private List&lt;GameObject&gt; aBlockOpportunities;
  private List&lt;GameObject&gt; aWinOpportunities;

  private void Start()
  {
    ShowPlayerPrompt();
    
    aGrid = new GameObject[3,3];
  
    GameObject theSquare;
    SquareCSharp theScript;
  
    for(int i = 0; i &lt; aSquares.Length; i++)
    {
      theSquare = aSquares[i];
      theScript = theSquare.GetComponent&lt;SquareCSharp&gt;();
      aGrid[theScript.x,theScript.y] = theSquare;
    }
    
  }
  
  
  public IEnumerator ClickSquare(GameObject square)
  {
    print ("click square!");
    if(gameIsOver || currentPlayer == 2) yield break;
  
    PlacePiece(XPiece, square);
  
    print ("keep going");
    
    if(!gameIsOver)
    {
      yield return new WaitForSeconds(0.5f);
      ComputerTakeATurn();
    }
  }


  private void ComputerTakeATurn()
  {
    GameObject square = null;
    
    if(Random.value &gt; 0.5f) square = WinOrBlock();
    if(square == null &amp;&amp; Random.value &gt; 0.5f) square = PreventOrCreateTrap();
    if(square == null &amp;&amp; Random.value &gt; 0.5f) square = GetCentre();
    if(square == null &amp;&amp; Random.value &gt; 0.5f) square = GetEmptyCorner();
    if(square == null) square = GetEmptySide();
    
    PlacePiece(OPiece, square);
    
  }

  private GameObject GetEmptySide()
  {
    List&lt;GameObject&gt; aEmptySides = new List&lt;GameObject&gt;();
    
    if(GetPlayer(1,0) == 0) aEmptySides.Add(aGrid[1,0]);
    if(GetPlayer(0,1) == 0) aEmptySides.Add(aGrid[0,1]);
    if(GetPlayer(2,1) == 0) aEmptySides.Add(aGrid[2,1]);
    if(GetPlayer(1,2) == 0) aEmptySides.Add(aGrid[1,2]);
    
    if(aEmptySides.Count &gt; 0) return aEmptySides[Random.Range(0,aEmptySides.Count)];
    
    return null;
  }
  
  private GameObject GetEmptyCorner()
  {
    List&lt;GameObject&gt; aEmptyCorners = new List&lt;GameObject&gt;();
    
    if(GetPlayer(0,0) == 0) aEmptyCorners.Add(aGrid[0,0]);
    if(GetPlayer(2,0) == 0) aEmptyCorners.Add(aGrid[2,0]);
    if(GetPlayer(0,2) == 0) aEmptyCorners.Add(aGrid[0,2]);
    if(GetPlayer(2,2) == 0) aEmptyCorners.Add(aGrid[2,2]);
    
    if(aEmptyCorners.Count &gt; 0) return aEmptyCorners[Random.Range(0,aEmptyCorners.Count)];
    
    return null;
  }
  
  private GameObject GetCentre()
  {
    if( GetPlayer(1,1) == 0 ) return aGrid[1,1];
    return null;
  }
  private GameObject WinOrBlock()
  {
    aBlockOpportunities = new List&lt;GameObject&gt;();
    aWinOpportunities = new List&lt;GameObject&gt;(); // Empty out these lists before we start searching.
    
    // Check the rows for 2 in a row:
    CheckFor2InARow(new Vector2[] {new Vector2(0,0), new Vector2(1,0), new Vector2(2,0)});		
    CheckFor2InARow(new Vector2[] {new Vector2(0,1), new Vector2(1,1), new Vector2(2,1)});
    CheckFor2InARow(new Vector2[] {new Vector2(0,2), new Vector2(1,2), new Vector2(2,2)});
    
    // Check the columns for 2 in a row:
    CheckFor2InARow(new Vector2[] {new Vector2(0,0), new Vector2(0,1), new Vector2(0,2)});
    CheckFor2InARow(new Vector2[] {new Vector2(1,0), new Vector2(1,1), new Vector2(1,2)});
    CheckFor2InARow(new Vector2[] {new Vector2(2,0), new Vector2(2,1), new Vector2(2,2)});
    
    // Check the diagonals for 2 in a row:
    CheckFor2InARow(new Vector2[] {new Vector2(0,0), new Vector2(1,1), new Vector2(2,2)});
    CheckFor2InARow(new Vector2[] {new Vector2(0,2), new Vector2(1,1), new Vector2(2,0)});
  
    // If there are any opportunities to win, return one at random:
    if(aWinOpportunities.Count &gt; 0) return aWinOpportunities[Random.Range(0, aWinOpportunities.Count)];
    
    // If there are any opportunities to block, return one at random:
    if(aBlockOpportunities.Count &gt; 0) return aBlockOpportunities[Random.Range(0, aBlockOpportunities.Count)];
    
    // There are no opportunities to win or block, so return null:
    return null;
  }
   private void CheckFor2InARow(Vector2[] coords)
  {
  
    int p1InThisRow = 0; // the number of X's in this row
    int p2InThisRow = 0; // the number of O's in this row
    int player;
    GameObject square = null;	
    Vector2 coord;
    
    // Step through each of the 3 Square coordinates that were passed in:
    for (int i = 0; i&lt;3; i++)
    {
      coord = coords[i];
      player = GetPlayer((int)coord.x, (int)coord.y); // Find the piece in this Square
      if(player == 1)
      {
        p1InThisRow ++; // Tally up an X
      } else if(player == 2) {
        p2InThisRow ++; // Tally up an O
      } else {
        square = aGrid[(int)coord.x, (int)coord.y]; // This Square is empty. Store it for later.
      }
    }
    
    if(square != null)
    {
      // We found an empty Square in this row.
      if(p2InThisRow == 2)
      {
        // There are two O's in a row with an empty Square.aWinOpportunities.Add(square); // Add a win opportunity to the list.
      } else if (p1InThisRow == 2) {
        // There are two X's in a row with an empty Square.aBlockOpportunities.Add(square); // Add a block opportunity to the list.
      }
    }
  }
  
  private GameObject PreventOrCreateTrap()
  {
    List&lt;GameObject&gt; aP1Corners = new List&lt;GameObject&gt;(); // Create an empty list to store X-controlled corners
    List&lt;GameObject&gt; aP2Corners = new List&lt;GameObject&gt;(); // Create an empty list to store O-controlled corners
    List&lt;GameObject&gt; aOpenCorners = new List&lt;GameObject&gt;(); // Create an empty list to store unoccupied corners
    
    GameObject[] aCorners = new GameObject[] {aGrid[0,0],aGrid[2,0],aGrid[0,2],aGrid[2,2]}; // Create an array to store the corner coordinates
    
    int player;
    GameObject square;
    
    // Loop through the corner coordinates:
    int i;
    for(i = 0; i &lt; 4; i++)
    {
      square = aCorners[i];
      player = square.GetComponent&lt;SquareCSharp&gt;().player; // Find the piece that's in this corner
      if(player == 1)
      {
        aP1Corners.Add(square); // If it's an X, add it to the X-controlled corners lists
      } else if (player == 2) {
        aP2Corners.Add(square); // If it's an O, add it to the X-controlled corners lists
      } else {
        aOpenCorners.Add(square); // If it's empty, add it to the empty corners list
      }
    }
  
    // Set a trap!
    // If O has two corners and there's at least one empty corner, randomly return an empty corner from the empty corners list:
    if( aP2Corners.Count == 2 &amp;&amp; aOpenCorners.Count &gt; 0) return aOpenCorners[Random.Range(0,aOpenCorners.Count)];
    
    // Prevent a trap!
    // If X has two corners, take a side to force him to defend:
    if(aP1Corners.Count == 2) return GetEmptySide();
    
    // If there's no trap to set or prevent, return null:
    return null;
    
  }
  
  private void PlacePiece(GameObject piece, GameObject square)
  {
    moves ++;
  
    Instantiate(piece, square.transform.position, Quaternion.identity);
    square.GetComponent&lt;SquareCSharp&gt;().player = currentPlayer;
    
    if(CheckForWin(square))
    {
      gameIsOver = true;
      ShowWinnerPrompt();
      return;
    } else if(moves &gt;= 9) {
      gameIsOver = true;
      ShowStalematePrompt();
      return;
    }
  
    currentPlayer ++;
    if(currentPlayer &gt; 2) currentPlayer = 1;
    
    ShowPlayerPrompt();
  }
  
  private void ShowPlayerPrompt()
  {
    if(currentPlayer == 1)
    {
      prompt.text = "Player 1, place an X.";
    } else {
      prompt.text = "Player 2, place an O.";
    }
    
  }
  
  private IEnumerator ShowWinnerPrompt()
  {
    if(currentPlayer == 1)
    {
      prompt.text = "X gets 3 in a row. Player 1 wins!";
    } else {
      prompt.text = "O gets 3 in a row. Player 2 wins!";
    }
    
    yield return new WaitForSeconds(3);
    Application.LoadLevel(0);	
  }
  
  private IEnumerator ShowStalematePrompt()
  {
    prompt.text = "Stalemate!  Neither player wins.";
    
    yield return new WaitForSeconds(3);
    Application.LoadLevel(0);
  }
  
  private bool CheckForWin(GameObject square)
  {
    SquareCSharp theScript = square.GetComponent&lt;SquareCSharp&gt;();
  
    //Check the squares in the same column:
    if(GetPlayer(theScript.x,0) == currentPlayer &amp;&amp; GetPlayer(theScript.x,1) == currentPlayer &amp;&amp; GetPlayer(theScript.x,2) == currentPlayer) return true;
    
    // Check the squares in the same row:
    if(GetPlayer(0,theScript.y) == currentPlayer &amp;&amp; GetPlayer(1,theScript.y) == currentPlayer &amp;&amp; GetPlayer(2,theScript.y) == currentPlayer) return true;
    
    // Check the diagonals:
    if(GetPlayer(0,0) == currentPlayer &amp;&amp; GetPlayer(1,1) == currentPlayer &amp;&amp; GetPlayer(2,2) == currentPlayer) return true;
    if(GetPlayer(2,0) == currentPlayer &amp;&amp; GetPlayer(1,1) == currentPlayer &amp;&amp; GetPlayer(0,2) == currentPlayer) return true;
    
    return false; // If we get this far without finding a win, return false to signify "no win".
    
  }
  
  private int GetPlayer(int x, int y)
  {
    return aGrid[x,y].GetComponent&lt;SquareCSharp&gt;().player;
  }
}</pre></div></div>