<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec179"></a>Time for action – checking for victory</h2></div></div><hr /></div><p>Our <code class="literal">matchesMade</code>, <code class="literal">matchesNeededToWin</code>, and <code class="literal">playerHasWon</code> variables have been standing at the ready this <a id="id494" class="indexterm"></a>whole time. Let's finally make use of them.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add these few lines to the <code class="literal">FlipCardFaceUp</code> function, where you're detecting a match:</p><div class="informalexample"><pre class="programlisting">if(aCardsFlipped[0].id == aCardsFlipped[1].id)
 {
   // Match!
   aCardsFlipped[0].isMatched = true;
   aCardsFlipped[1].isMatched = true;
            
   <span class="strong"><strong>matchesMade ++;</strong></span>
            
   <span class="strong"><strong>if(matchesMade &gt;= matchesNeededToWin)</strong></span>
   <span class="strong"><strong>{</strong></span>
     <span class="strong"><strong>playerHasWon = true;</strong></span>
   <span class="strong"><strong>}</strong></span>
</pre></div></li><li><p>Add a new function call to the <code class="literal">OnGUI</code> function:</p><div class="informalexample"><pre class="programlisting">  function OnGUI () {
     GUILayout.BeginArea (Rect (0,0,Screen.width,Screen.height)); 
     BuildGrid();
     <span class="strong"><strong>if(playerHasWon) BuildWinPrompt();</strong></span>
     GUILayout.EndArea();
   }</pre></div></li><li><p>And, now, we'll use some <code class="literal">GUILayout</code> commands that we learned in the last chapter to display a "win" prompt to the player. Write this new function apart from the other <a id="id495" class="indexterm"></a>functions, and make sure it's not wedged inside any other function's curlies:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> function BuildWinPrompt()</strong></span>
<span class="strong"><strong>   {</strong></span>
<span class="strong"><strong>     var winPromptW:int = 120;</strong></span>
<span class="strong"><strong>  var winPromptH:int = 90;</strong></span>
<span class="strong"><strong>   </strong></span>
<span class="strong"><strong>   var halfScreenW:float = Screen.width/2;</strong></span>
<span class="strong"><strong>   var halfScreenH:float = Screen.height/2;</strong></span>
<span class="strong"><strong>   </strong></span>
<span class="strong"><strong>   var halfPromptW:int = winPromptW/2;</strong></span>
<span class="strong"><strong>   var halfPromptH:int = winPromptH/2;</strong></span>
<span class="strong"><strong>   </strong></span>
<span class="strong"><strong>   GUI.BeginGroup(Rect(halfScreenW-halfPromptW, halfScreenH-</strong></span>
<span class="strong"><strong>     halfPromptH, winPromptW, winPromptH));</strong></span>
<span class="strong"><strong>   GUI.Box (Rect (0,0,winPromptW,winPromptH), "A Winner is </strong></span>
<span class="strong"><strong>     You!!");</strong></span>
<span class="strong"><strong>   </strong></span>
<span class="strong"><strong>   var buttonW:int = 80;</strong></span>
<span class="strong"><strong>   var buttonH:int = 20;</strong></span>
<span class="strong"><strong>   </strong></span>
<span class="strong"><strong>   if(GUI.Button(Rect(halfPromptW-(buttonW/2),halfPromptH-</strong></span>
<span class="strong"><strong>     (buttonH/2),buttonW,buttonH),"Play Again"))</strong></span>
<span class="strong"><strong>   {</strong></span>
<span class="strong"><strong>      Application.LoadLevel("Title");</strong></span>
<span class="strong"><strong>   }</strong></span>
<span class="strong"><strong>      GUI.EndGroup();</strong></span>
<span class="strong"><strong> }</strong></span>
</pre></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec74"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>This method uses 90 % recycled knowledge. We store a few variables to help us remember where the middle of the screen is, store the half width and height of the prompt we're about to draw, and then draw and position it using a fixed layout (instead of an automatic layout, like our grid of cards).</p><p>The remaining unknown 10 % uses a wrapper called a <span class="strong"><strong>Group</strong></span>, which helps us collect UI controls together.</p><div class="informalexample"><pre class="programlisting">GUI.Box (Rect (0,0,winPromptW,winPromptH), "A Winner is You!!");</pre></div><p>This draws a box at the origin point of the Group (which is centered on the screen). Feel free to change the box label, "<span class="strong"><strong>A Winner is You!</strong></span>", to something equally sarcastic.</p><p>Inside that box, we draw a <span class="strong"><strong>Button</strong></span> control with the label <span class="strong"><strong>Play Again</strong></span>. When clicked, we link the player to the <span class="strong"><strong>Title Scene</strong></span> where the game starts all over again and much fun is repeatedly had, until the player dies of old age and the Earth crashes into the sun.</p><div class="mediaobject"><img src="/graphics/9781849695268/graphics/5268OT_06_08.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec75"></a>Have a go hero – extra credit</h3></div></div></div><p>As you now know<a id="id496" class="indexterm"></a> how to create, label, and position buttons; create scenes, and link scenes to each other with buttons; and draw text and graphics to the screen, here are a few challenges for you that will give your already complete game even more bells and whistles:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Create a <span class="strong"><strong>Credits</strong></span> screen, and link to it from either the <span class="strong"><strong>Title Scene</strong></span> or the <span class="strong"><strong>Play Again</strong></span> prompt. Be sure to credit yourself for absolutely everything, with perhaps a token nod to Grandma. You've earned it!</p></li><li style="list-style-type: disc"><p>Create an <span class="strong"><strong>Instructions</strong></span> screen. This is an excuse to throw some color into the game, and church up what is really just a simple flip n' match Memory game. Here's some copy for you to use and adapt:</p><p>
<span class="emphasis"><em>"Professor Wrecker had a wild night and smashed up the robotics lab again! Can you put the ruined robots back together while the Professor sleeps it off?"</em></span>
</p><p>Hilarious <span class="emphasis"><em>and</em></span> kid-friendly.</p></li><li style="list-style-type: disc"><p>Create some new elements near the edge of your grid—eight cards with silhouettes of the robots on them. As the player finds matches and the clickable cards are blanked out, swap the silhouettes for the repaired robots. This may give the player a stronger sense of a goal.</p></li><li style="list-style-type: disc"><p>Create a new set of graphics with four additional robots. Add them to your <span class="strong"><strong>Resources</strong></span> folder, name them properly, and see if you can adjust the code so that all eight robots get dealt into the deck.</p></li><li style="list-style-type: disc"><p>Explore the other UI controls Unity has to offer. Try expanding those game instructions to a 30-page-long epic (NOT a good idea in real life, but we're just practising here). Hook those monstrous instructions up to a scroll bar. Add a checkbox for the player stating, "I have read and agreed to these instructions." Do not let your player play the game until he has scrolled to the bottom of the instructions. This is probably a terrible design decision, but we'll make some concessions for the sake of your education. Just be sure to hide your home address from the player so that you don't get any bricks through your window or flaming bags of poo on your doorstep.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec76"></a>Endgame</h3></div></div></div><p>You've created a fully <a id="id497" class="indexterm"></a>working flip n' match Memory game that'll be a sure-fire hit with Grandma, especially if she sees her shout-out in the credits. In this chapter, you:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Used <code class="literal">FlexibleSpace</code> to center your automatic <code class="literal">GUILayout</code>
</p></li><li style="list-style-type: disc"><p>Learned how to pull random numbers and bend them to your nefarious will</p></li><li style="list-style-type: disc"><p>Figured out how to disable the GUI, flip Boolean flags, pause code execution, and prevent the player from clicking on stuff he's not supposed to</p></li><li style="list-style-type: disc"><p>Built an entire functioning game using only the Unity GUI system</p></li><li style="list-style-type: disc"><p>Learned how to break a game's design into smaller functional steps that you can add to a to-do list</p></li></ul></div><p>Remember that any 3D game will likely require a decent amount of 2D programming. User interfaces like shops, inventory screens, level select screens, and character creation tools usually display items in grid layouts with selectable buttons, changing pictures, control-limiting logic, and a lot of the same stuff we've covered off in this chapter. Consider these past two chapters training for all the amazing user interfaces you'll build for your games.</p><p>Astronauts don't<a id="id498" class="indexterm"></a> train in space—they train in simulators. And, just like an astronaut in a NASA-constructed spinning thrill ride, this chapter may have left your head reeling! We covered a <span class="emphasis"><em>lot</em></span> of ground here, but the good news is that the pages in this book aren't going anywhere. Meditate on them. Read them again and again. Take your time to let it all sink in before charging on to the next chapter.</p></div></div>