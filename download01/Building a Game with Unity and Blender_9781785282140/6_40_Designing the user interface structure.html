<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec41"></a>Designing the user interface structure</h2></div></div><hr /></div><p>Since we have already done the splash screen, let's dive into the main menu! The previous flow<a id="id847" class="indexterm"></a> chart doesn't actually explain anything about how the main menu should function. Therefore, we need to design another flow chart to explain the structure of the main menu.</p><p>Our game is really simple, so we don't have many buttons on the menu—just simple start game and quit game buttons. By clicking on the different buttons, it will bring us to another user interface that does a different thing. We need to brainstorm all these details and put them into the flow chart.</p><div class="mediaobject"><img src="/graphics/9781785282140/graphics/B04610_06_06.jpg" /></div><p>After you have done that, we will move over to Unity again and start designing our main menu based on the preceding flow chart. First, create a new scene called <code class="literal">MainMenu</code>, because the name of the scene has to match the name specified in the <code class="literal">Application.LoadLevel()</code> function in our previous script.</p><p>The first thing we see right after the splash screen is a menu with two buttons: <span class="strong"><strong>Start Game</strong></span> and <span class="strong"><strong>Quit Game</strong></span>, which are contained in a panel object. Above it is the game logo. The way to construct the main menu is quite similar to the splash screen, except an additional panel object and two buttons are added to the user interface.</p><div class="mediaobject"><img src="/graphics/9781785282140/graphics/B04610_06_07.jpg" /></div><p>The panel can be created by going to <span class="strong"><strong>Game Object</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Panel</strong></span>, and the buttons can be added by going to <span class="strong"><strong>Game Object</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Button</strong></span>. It's pretty simple and straightforward. You can change<a id="id848" class="indexterm"></a> the button text by expanding the button from the hierarchy, and you will now see a text object under the button. Select it and you will be able to change the text on the <span class="strong"><strong>Inspector</strong></span> panel. Subsequently, you can delete the text object, if you are going for a fully graphical type of button.</p><p>Below are the other menus that are present in the flow chart. At this moment, the user interface is not yet functional, but you have to be aware of their functionality and why it's being added to the UI in the first place. If you have any doubts or are questioning the design, it's never too late to go back to the flow chart and make some changes.</p><div class="mediaobject"><img src="/graphics/9781785282140/graphics/B04610_06_08.jpg" /></div><p>Each of these <a id="id849" class="indexterm"></a>menus is contained in a separate canvas, which makes it easy to show and hide the entire menu from the script. You can try it in the Unity Editor by selecting one of the canvases and checking/unchecking the checkbox located beside the object name on the <span class="strong"><strong>Inspector</strong></span> panel. You will see the entire menu disappear and reappear when you do that. More on this will be covered later in the chapter.</p><div class="mediaobject"><img src="/graphics/9781785282140/graphics/B04610_06_09.jpg" /></div><p>Once everything has been confirmed and all the required UI elements have been put in place, we will start writing the code to make it functional!</p><p>In Unity, create a new C# script called <code class="literal">MainMenu.cs</code>. This time, we are not manipulating the color or anything related to the UI elements, so we don't have to include the <code class="literal">UnityEngine.UI</code> dependency. However, we will activate and deactivate different canvases based on the state of the UI. To do that, we need to declare four variables to store the pointers to all the different menus for later use.</p><div class="informalexample"><pre class="programlisting">public GameObject mainMenuUI;
public GameObject startGameUI;
public GameObject exitGameUI;
public GameObject newGameUI;</pre></div><p>Make sure they are public so that it will appear on the <span class="strong"><strong>Inspector</strong></span> panel in the Unity Editor. Next, we<a id="id850" class="indexterm"></a> only want the first menu to appear when the scene is loaded, and not the others. One way to do this is to make sure that only the first menu is shown and the rest are hidden before building the game, but sometimes we tend to be careless, so in order to avoid such a problem, we manually set it in the <code class="literal">Start()</code> function.</p><div class="informalexample"><pre class="programlisting">void Start ()
{
  mainMenuUI.SetActive (true);
  startGameUI.SetActive (false);
  exitGameUI.SetActive (false);
  newGameUI.SetActive (false);
}</pre></div><p>After that, we have to create several functions that will be called by each of the buttons when pressed. What the functions do are mostly switch between different UIs by calling the <code class="literal">SetActive()</code> function to turn on or turn off the canvases. It's very easy to do this if we have designed the flow chart early on and have just followed it. This is why it's very important to make sure the flow chart is correct before we start writing any code.</p><p>The full code is here:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class MainMenu : MonoBehaviour
{
  public GameObject mainMenuUI;
  public GameObject startGameUI;
  public GameObject exitGameUI;
  public GameObject newGameUI;

  void Start ()
  {
    mainMenuUI.SetActive (true);
    startGameUI.SetActive (false);
    exitGameUI.SetActive (false);
    newGameUI.SetActive (false);
  }

  public void StartGamePressed ()
  {
    mainMenuUI.SetActive (false);
    startGameUI.SetActive (true);
  }

  public void QuitGamePressed ()
  {
    mainMenuUI.SetActive (false);
    exitGameUI.SetActive (true);
  }

  public void ContinuePressed ()
  {
    Application.LoadLevel ("Level01");
  }

  public void NewGamePressed ()
  {
    startGameUI.SetActive (false);
    newGameUI.SetActive (true);
  }

  public void QuitGameYesPressed ()
  {
    // Quit game and close the application
    Application.Quit ();
  }

  public void QuitGameNoPressed ()
  {
    exitGameUI.SetActive (false);
    mainMenuUI.SetActive (true);
  }

  public void NewGameYesPressed ()
  {
    // Jump to game level
    Application.LoadLevel ("Level01");
  }

  public void NewGameNoPressed ()
  {
    newGameUI.SetActive (false);
    startGameUI.SetActive (true);
  }
}</pre></div><p>For now, both<a id="id851" class="indexterm"></a> the <span class="strong"><strong>Continue</strong></span> and <span class="strong"><strong>New Game</strong></span> buttons will bring the player to the game scene without loading any saved data. This is because we will only learn how to save progression in the next chapter. Stay tuned.</p><p>To hook up the buttons to the preceding functions, select one of the buttons and scroll down to the bottom of the <span class="strong"><strong>Inspector</strong></span> panel. There you will see a column with a label called <span class="strong"><strong>On Click()</strong></span>. Then, click on the <span class="strong"><strong>+</strong></span> button and drag the game object that has the <code class="literal">MainMenu</code> script attached to the input field. Then, click on the combo box on the right side and select the function that you want to call when the button is clicked. This is a really handy feature in Unity.</p><div class="mediaobject"><img src="/graphics/9781785282140/graphics/B04610_06_11.jpg" /></div><p>Once you are done setting all the buttons in the main menu scene, let's move on to the pause menu. If you refer back to the game structure, you will see a pause menu in the flow chart that can be accessed from the in-game scene. That particular flow chart, however, never explained how the pause menu actually works. Therefore, we need to create another flow chart just for the pause menu. Most of the things in the pause menu are similar to the main menu, except this time, we have to deal with keyboard input because the pause menu will be triggered when the player presses the <span class="strong"><strong>Escape</strong></span> button on the keyboard.</p><div class="mediaobject"><img src="/graphics/9781785282140/graphics/B04610_06_12.jpg" /></div><p>As for <a id="id852" class="indexterm"></a>constructing the user interface, the steps are also very similar to the previous UI. The only difference now is that the background image is in black with 50% transparency. This is because we want the player to still be able to look at the 3D scene in the background when the game is paused.</p><div class="mediaobject"><img src="/graphics/9781785282140/graphics/B04610_06_13.jpg" /></div><p>For the coding part, it's very similar to the main menu as well—switching between different canvases when clicking on the buttons. This time, however, we have two confirmation dialogs that look exactly the same but gog to different states when the buttons are <a id="id853" class="indexterm"></a>pressed. We don't want to create the same UI twice, so instead we make use of enumeration (or enum for short) in C# to check which state we should navigate to when clicking on the buttons on the dialog.</p><p>First, create a new C# script called <code class="literal">PauseMenu.cs</code>. Then, at the top of your script, declare an enumeration called <code class="literal">mode</code>, which consists of two members: <code class="literal">mainMenu</code> and <code class="literal">quit</code>. Enumeration is essentially a way to assign a meaningful name to a set of integers so that programmers can easily remember it when writing code.</p><div class="informalexample"><pre class="programlisting">enum mode { mainMenu, quit };</pre></div><p>Inside your <code class="literal">PauseMenu</code> class, declare two variables for the UI pointers and an integer variable called <code class="literal">selectedMode</code>. We will set this variable when a button is pressed to call out the confirmation dialog. This way, we will know which state it's going to navigate when the button on the dialog is pressed.</p><div class="informalexample"><pre class="programlisting">public GameObject pauseMenuUI;
public GameObject confirmUI;
mode selectedMode;</pre></div><p>In the <code class="literal">Start()</code> function, again, manually display the first canvas and hide the other one to avoid a careless mistake.</p><div class="informalexample"><pre class="programlisting">void Start ()
{
  pauseMenuUI.SetActive (false);
  confirmUI.SetActive (false);
}</pre></div><p>In the <code class="literal">Update()</code> function, we check whether the <span class="emphasis"><em>Esc</em></span> key is pressed by calling <code class="literal">Input.GetKeyDown()</code> and insert <code class="literal">KeyCode.Escape</code> as the input variable. The function will return <code class="literal">true</code> if the <span class="emphasis"><em>Esc</em></span> key is pressed, and thus pausing the game.</p><p>There are many ways to pause a game. The simplest method is to just stop the in-game time by setting the time scale to zero. This way, everything will be frozen, including all animations, special effects, and game logic that relies on in-game time. By setting the time scale back to one, the game will continue as it is.</p><p>Another thing that I have added to the pause menu script is unlocking the game cursor and unhiding it when the game resumes. This is because later in this chapter, I will be hiding the game cursor when constructing character movement. More on this will be covered later.</p><div class="informalexample"><pre class="programlisting">void Update ()
{
  if (Input.GetKeyDown (KeyCode.Escape))
  {
    if (Time.timeScale == 1)
    {
      Time.timeScale = 0;
      pauseMenuUI.SetActive (true);

      Cursor.lockState = CursorLockMode.None;
      Cursor.visible = true;
    }
    else
    {
      Time.timeScale = 1;
      pauseMenuUI.SetActive (false);

      Cursor.lockState = CursorLockMode.Locked;
      Cursor.visible = false;
    }
  }
}</pre></div><p>Now, I will<a id="id854" class="indexterm"></a> explain a little bit about the usage of enumeration we declared earlier in this script. If we refer back to the flow chart, we can see that the confirmation menu is used to navigate to two different states: one to the main menu, and another one to quit the game completely.</p><p>Therefore, when the <span class="strong"><strong>Back to Main Menu</strong></span> button is pressed, we need to set the <code class="literal">selectedMode</code> variable to <code class="literal">mainMenu</code> before activating the confirmation dialog.</p><div class="informalexample"><pre class="programlisting">public void BackMainMenuPressed()
{
  selectedMode = mode.mainMenu;

  pauseMenuUI.SetActive (false);
  confirmUI.SetActive (true);
}</pre></div><p>The same goes for the <span class="strong"><strong>Quit Game</strong></span> button. Set the <code class="literal">selectedMode</code> variable to quit before showing the dialog.</p><div class="informalexample"><pre class="programlisting">public void QuitGamePressed()
{
  selectedMode = mode.quit;

  pauseMenuUI.SetActive (false);
  confirmUI.SetActive (true);
}</pre></div><p>Thus, when clicking on the <span class="strong"><strong>Yes</strong></span> button on the <span class="strong"><strong>confirmation</strong></span> dialog, we must check the <code class="literal">selectedMode</code> variable and trigger the relevant action accordingly, which in this case, is loading the main menu scene <code class="literal">if selectedMode is mainmenu</code> and quitting the game completely<a id="id855" class="indexterm"></a> if otherwise.</p><div class="informalexample"><pre class="programlisting">public void YesPressed()
{
  if (selectedMode == mode.mainMenu)
  {
    Application.LoadLevel("MainMenu");
  }
  else
  {
    Application.Quit();
  }
}</pre></div><p>The full code is here:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

enum mode { mainMenu, quit };

public class PauseMenu : MonoBehaviour
{
  public GameObject pauseMenuUI;
  public GameObject confirmUI;
  mode selectedMode;

  void Start ()
  {
    pauseMenuUI.SetActive (false);
    confirmUI.SetActive (false);
  }

  void Update ()
  {
    if (Input.GetKeyDown (KeyCode.Escape))
    {
      if (Time.timeScale == 1)
      {
        Time.timeScale = 0;
        pauseMenuUI.SetActive (true);

        Cursor.lockState = CursorLockMode.None;
        Cursor.visible = true;
      }
      else
      {
        Time.timeScale = 1;
        pauseMenuUI.SetActive (false);

        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
      }
    }
  }

  public void ContinueGamePressed()
  {
    Time.timeScale = 1;
    pauseMenuUI.SetActive (false);
  }

  public void BackMainMenuPressed()
  {
    selectedMode = mode.mainMenu;

    pauseMenuUI.SetActive (false);
    confirmUI.SetActive (true);
  }

  public void QuitGamePressed()
  {
    selectedMode = mode.quit;

    pauseMenuUI.SetActive (false);
    confirmUI.SetActive (true);
  }

  public void YesPressed()
  {
    if (selectedMode == mode.mainMenu)
    {
      Application.LoadLevel("MainMenu");
    }
    else
    {
      Application.Quit();
    }
  }

  public void NoPressed()
  {
    confirmUI.SetActive (false);
    pauseMenuUI.SetActive (true);
  }
}</pre></div></div>