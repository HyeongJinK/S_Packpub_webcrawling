<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec28"></a>Working with the camera</h2></div></div><hr /></div><p>If you try and move the player left and right at the moment, our hero happily bobs along. However, you will quickly notice that we run into a problem: the hero soon disappears from the edge of the screen. To solve this, we need to make the camera follow the hero.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip42"></a>Tip</h3><p>When creating new scripts to implement something, remember that just about every game that has been made with Unity has most likely implemented either the same thing or something similar. So, in most cases, we will have something to work from. Don't just start a script from scratch (unless it is a very small one to solve a tiny issue) if you can help it.</p><p>Once you become more experienced, it is better to just use these scripts as a reference and try to create your own and improve on them, unless they are from a maintained library.</p></div><p>Create a new script called <code class="literal">FollowCamera</code> in the <code class="literal">Assets\Scripts folder</code>, remove the <code class="literal">Start</code> and <code class="literal">Update</code> functions, and then add the following variable declarations:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
public class FollowCamera : MonoBehaviour { 
 
    // Distance between player and camera in horizontal direction 
    public float xOffset = 0f; 
    // Distance between player and camera in vertical direction 
    public float yOffset = 0f; 
    
    // Reference to the player's transform. 
    public Transform player;     
} 
</pre><p>The <code class="literal">xOffset</code> and <code class="literal">yOffset</code> variables are provided so that we can make the player not perfectly centered with the camera.</p><p>Before we go further, we will attach the <code class="literal">FollowCamera.cs</code> script to the <span class="strong"><strong>Main Camera</strong></span>. Select the <span class="strong"><strong>Main Camera</strong></span> from the Hierarchy and drag and drop the <code class="literal">FollowCamera.cs</code> script into the <span class="strong"><strong>Inspector</strong></span> of the <span class="strong"><strong>Main Camera</strong></span> below the <span class="strong"><strong>Add Component</strong></span> button. The <span class="strong"><strong>Inspector</strong></span> should now look like the following:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_04_033.jpg" /></div><p>
</p><p>Because we initialized all of the variables as <code class="literal">public</code>, they can all be adjusted from within the Inspector without having to open the <code class="literal">FollowCamera.cs</code> script by simply changing the numbers in the slots next to the variables.</p><p>Notice that the <code class="literal">player</code> variable was declared as a <code class="literal">public Transform</code>, and there is a slot next to <span class="strong"><strong>Player</strong></span> that says <code class="literal">None (Transform)</code>. This means that we can drag and drop any transform into the <span class="strong"><strong>Player</strong></span> slot. However, we don't want to put just any <span class="strong"><strong>Transform</strong></span> in the slot, we want our player character's GameObject to appear in that slot. Because the GameObject <span class="strong"><strong>Player</strong></span> has a <span class="strong"><strong>Transform</strong></span> component attached to it, we can place it in this spot.</p><p>Drag and drop the <span class="strong"><strong>Player</strong></span> GameObject from the Hierarchy into this slot. You should now see the following:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_04_034.jpg" /></div><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note43"></a>Note</h3><p>Rather than dragging and dropping the <code class="literal">Player</code> into the <span class="strong"><strong>Player</strong></span> slot, you could have also included the following code in an awake function:</p><p>
<code class="literal">void Awake(){</code>
<code class="literal">// check the player reference.</code>
<code class="literal"> player = GameObject.Find("Player").transform;</code>
<code class="literal">    if (player == null){</code>
<code class="literal">        Debug.LogError("Player object not found");</code>
<code class="literal">    }</code>
<code class="literal"> }</code></p><p>It is really a matter of preference. I personally prefer the drag and drop method as I feel that functionality is a big benefit of Unity's interface.</p></div><p>To finish our script, we need to write code that will make the camera follow the player. Before we can do that, let's discuss the differences between the <code class="literal">Update()</code>, <code class="literal">FixedUpdate()</code>, and <code class="literal">LateUpdate()</code> functions.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec48"></a>Comparing Update, FixedUpdate, and LateUpdate</h3></div></div></div><p>There is usually a lot of debate about which update method should be used within a Unity game. To put it simply, the <code class="literal">FixedUpdate</code> method is called on a regular basis throughout the lifetime of the game and is generally used for physics and time-sensitive code. The <code class="literal">Update</code> method, however, is only called after the end of each frame that is drawn to the screen, as the time taken to draw the screen can vary (due to the number of objects to be drawn and so on). So, the <code class="literal">Update</code> call ends up being fairly irregular. <code class="literal">LateUpdate</code> is the last of the update functions to be called. It is called after all other update functions have been called.</p><p>General rules of thumb are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">Update()</code>: This is used for most things that you want to have continually checked or run.</p></li><li style="list-style-type: disc"><p>
<code class="literal">FixedUpdate()</code>: This is the best update function to be used with physics.</p></li><li style="list-style-type: disc"><p>
<code class="literal">LateUpdate()</code>: This is best for camera movement or other items you want to update after everything else has been updated.</p></li></ul></div><p>While the preceding are general rules of thumb, they are not set in stone, and it really depends on the game and what you are trying to accomplish.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec49"></a>Moving our camera with the player</h3></div></div></div><p>We want the camera to follow the player left and right, but not up and down. As stated earlier, generally, the best update function to use with a camera is the <code class="literal">LateUpdate</code>, so we will use the following code to make the camera follow the player:</p><pre class="programlisting">void LateUpdate() { 
    this.transform.position = new Vector3(player.transform.position.x + 
      xOffset, this.transform.position.y + yOffset, -10); 
} 
</pre><p>The preceding code sets the camera's <code class="literal">x</code> position with that of the player plus some padding. It also fixes the camera's <code class="literal">y</code> and <code class="literal">z</code> positions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec50"></a>The perils of resolution</h3></div></div></div><p>When dealing with cameras, there is always one thing that will trip us up as soon as we try to build for another platform-resolution.</p><p>By default, the Unity player in the editor runs in the <span class="strong"><strong>Free Aspect</strong></span> mode, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_04_035.jpg" /></div><p>
</p><p>The <span class="strong"><strong>Aspect</strong></span> mode (from the <span class="strong"><strong>Aspect</strong></span> drop-down) can be changed to represent the resolutions supported by each platform you can target.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>You can also make your own resolutions by clicking the plus sign at the bottom of the drop-down menu and providing your own values.</p></div><p>To change the build target, go into your project's <span class="strong"><strong>Build Settings</strong></span> by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Build Settings</strong></span> or by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>B</em></span>, select a platform, and click on the <span class="strong"><strong>Switch Platform</strong></span> button, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_04_037.jpg" /></div><p>
</p><p>When you change the <span class="strong"><strong>Aspect</strong></span> drop-down menu to view in one of these resolutions, you will notice how the aspect ratio for what is drawn to the screen changes by either stretching or compressing the visible area. If you run the editor player in full screen by clicking on the <span class="strong"><strong>Maximize on Play</strong></span> button and then clicking on the play icon, you will see this change more clearly. Alternatively, you can run your project on a target device to see the proper perspective output.</p><p>The reason I bring this up here is that if you used fixed bounds settings for your camera or GameObjects, then these values may not work for every resolution, thereby putting your settings out of range or (in most cases) too undersized.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec51"></a>Setting our aspect ratio and camera parameters</h3></div></div></div><p>For now, we will leave our target build as <span class="strong"><strong>PC, Mac, &amp; Linux Standalone</strong></span>. Change the aspect ratio to <code class="literal">4:</code>3 in the <span class="strong"><strong>Game</strong></span> view. Also, change the size variable to <code class="literal">5</code>, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_04_038.jpg" /></div><p>
</p><p>You should now see the following in the <span class="strong"><strong>Game</strong></span> view:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_04_039.jpg" /></div><p>
</p></div></div>