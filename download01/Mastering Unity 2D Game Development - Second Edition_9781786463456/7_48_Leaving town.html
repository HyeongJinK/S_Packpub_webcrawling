<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec48"></a>Leaving town</h2></div></div><hr /></div><p>Currently, our character can walk back and forth in the town and walk around in the map, but she can't go between the two scenes. Since the game will start off in the town, let's begin by allowing the character to leave the <code class="literal">Town</code> and enter the <code class="literal">Overworld</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec88"></a>Creating a NavigationManager script</h3></div></div></div><p>To navigate between scenes, we could add a simple <code class="literal">SceneManager</code> script that says when you hit this collider, go to a specific scene, but if you are planning a larger world with a large number of interactions, it is better if we build a separate navigation system so that we have everything in one place; it's just easier to manage that way.</p><p>This separation is a fundamental part of any good game design. Keeping the logic and game functionality separate makes it easier to maintain in the future, especially when you need to take internationalization into account (but we will learn more about that later).</p><p>In <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>The Town View</em></span>, we created a <code class="literal">NavigationPrompt</code> script that we will rewrite and tie into a manager script. As you may recall, we added the tag <code class="literal">Borders</code> to the <code class="literal">LeftBorder</code> and <code class="literal">RightBorder</code>. This allowed the <code class="literal">NavigationPrompt</code> text to output the message <code class="literal">"leave town"</code> in the console.</p><p>Let's return to our <code class="literal">Town</code> scene and change these tags. Create new tags called <code class="literal">Construction</code> and <code class="literal">Overworld</code>. Apply the <code class="literal">Construction</code> tag to the <code class="literal">LeftBorder</code> and the <code class="literal">Overworld</code> tag to the <code class="literal">RightBorder</code>, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_07_015.jpg" /></div><p>
</p><p>Next, let's create a new C# script called <code class="literal">NavigationManager</code> in <code class="literal">Assets\Scripts\Navigation</code> and then replace its contents with the following lines of code:</p><pre class="programlisting">using System.Collections.Generic; &#13;
 &#13;
public static class NavigationManager{ &#13;
 &#13;
    public static Dictionary&lt;string, string&gt; RouteInformation = new &#13;
      Dictionary&lt;string, string&gt;() { &#13;
        { "Overworld","The big bad world"}, &#13;
        { "Construction", "The construction area"}, &#13;
    }; &#13;
 &#13;
    public static string GetRouteInfo(string destination){ &#13;
        return RouteInformation.ContainsKey(destination) ? &#13;
          RouteInformation[destination] : null; &#13;
    } &#13;
 &#13;
  public static bool CanNavigate(string destination) { &#13;
    return true; &#13;
  } &#13;
 &#13;
  public static void NavigateTo(string destination){ &#13;
    //we'll talk about this in a second :) &#13;
  } &#13;
}  &#13;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note84"></a>Note</h3><p>Notice the <code class="literal">?</code> and <code class="literal">:</code> operators in the following statement:</p><p>
<code class="literal">RouteInformation.ContainsKey(destination) ? RouteInformation[destination] : null;</code>These operators are C# conditional operators. They are effectively the shorthand of the following:</p><p>
<code class="literal">if(RouteInformation.ContainsKey(destination)) </code>
<code class="literal">{</code>
<code class="literal"> return RouteInformation[destination]; </code>
<code class="literal">}</code>
<code class="literal"> else</code>
<code class="literal"> {</code>
<code class="literal"> return null;</code>
<code class="literal"> }</code>
</p><p>Shorter, neater, and much nicer, don't you think?</p><p>For more information, see the MSDN C# page at <a class="ulink" href="http://bit.ly/csharpconditionaloperator" target="_blank">http://bit.ly/csharpconditionaloperator</a>.</p></div><p>The script is very basic for now, but contains several following key elements that can be expanded to meet the design goals of your game:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">RouteInformation</code>: This is a list of all the possible destinations in the game in a dictionary</p><p>This is a static list of possible destinations in the game, and it is a core part of the manager as it has everywhere you can travel in the game in one place.</p></li><li style="list-style-type: disc"><p>
<code class="literal">GetRouteInfo</code>: This is a basic information extraction function</p><p>This is a simple controlled function to interrogate the destination list. In this example, we just return the text to be displayed in the prompt, which allows more detailed descriptions that we could use in tags. You could use this to provide alternate prompts, depending on what the player is carrying and whether they have a lit torch, for example.</p></li><li style="list-style-type: disc"><p>
<code class="literal">CanNavigate</code>: This is a test to see if navigation is possible</p><p>If you are going to limit a player's travel, you need a way to test if they can move, allowing logic in your game to make alternate choices if the player cannot. You could use a different system for this by placing some sort of block in front of a destination to limit choice (as used in the likes of Zelda), such as an NPC or rock. As this is only an example, we can always travel and add logic to control it if you wish.</p></li><li style="list-style-type: disc"><p>
<code class="literal">NavigateTo</code>: This is a function to instigate navigation</p><p>Once a player can travel, you can control exactly what happens in the game: does navigation cause the next scene to load straight away or does the current scene fade out and then a traveling screen is shown before fading the next level in? Currently, there is nothing here, because we have a few more things to take care of before we can navigate to new scenes.</p></li></ul></div><p>You will notice that the script is a static class. This means it sits in the background, only exists once in the game, and is accessible from anywhere. This pattern is useful for fixed information that isn't attached to anything; it just sits in the background waiting to be queried.</p><p>With this class now created, we will update the <code class="literal">NavigationPrompt</code> script to communicate with our <code class="literal">NavigationMananger</code> script. Update the collision function in the <code class="literal">NavigationPrompt</code> script to now reference the <code class="literal">NavigationMananger</code>, rather than looking directly at the object's tags, as the shown in the following code:</p><pre class="programlisting">void OnCollisionEnter2D(Collision2D col){ &#13;
    if(NavigationManager.CanNavigate(this.tag)){ &#13;
          Debug.Log("attempting to exit via "+ tag); &#13;
        NavigationManager.NavigateTo(this.tag); &#13;
    } &#13;
}  &#13;
</pre><p>We will also remove this script from the <code class="literal">Player</code> and add it to the <code class="literal">LeftBorder</code> and <code class="literal">RightBorder</code>. To remove it from the <code class="literal">Player</code>, remove it from the <code class="literal">Player</code> prefab in the <code class="literal">Assets/Prefabs/Characters</code> folder. You will notice when the prefab is changed, it updates in the scene. This will also be true of the <code class="literal">Player</code> in the <code class="literal">Overworld</code> scene.</p><p>Now when you run into the borders, a message will appear in the console telling you that the player is attempting to leave town and the tag of the exit the player is attempting to use. Because there is no code in the <code class="literal">NavigationManager.NavigateTo</code> function, nothing else happens yet.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec89"></a>Blocking off paths</h3></div></div></div><p>We still have a bit of work to do to our <code class="literal">NavigationManager</code> script. Let's add code that enables us to have a simple mechanism to say whether a route is traversable or not. (In real scenarios, this should be serialized or it should have a manager for the player to remember where the player has traveled; otherwise, it is never going to get unlocked.)</p><p>Open up the <code class="literal">NavigationManager</code> script and create a new <code class="literal">struct</code> method as follows at the top of the class:</p><pre class="programlisting">public struct Route{ &#13;
    public string RouteDescription; &#13;
    public bool CanTravel; &#13;
}  &#13;
</pre><p>Next, we need to update the <code class="literal">RouteInformation</code> variable to use this new <code class="literal">struct</code> method and update the information for the two destinations that we have already configured in our manager. This should enable us to state that you can travel to the big bad world but not to the construction area, as follows:</p><pre class="programlisting">public static Dictionary&lt;string, Route&gt; RouteInformation = new  &#13;
Dictionary&lt;string, Route&gt;() { &#13;
  { "Overworld", new Route { RouteDescription = "The big bad world",  &#13;
    CanTravel = true} &#13;
  }, &#13;
  { "Construction", new Route { RouteDescription = "The construction area",  &#13;
    CanTravel = false} &#13;
  }, &#13;
}; &#13;
</pre><p>As we are now using a <code class="literal">struct</code> method for our destination information, we also need to update the <code class="literal">GetRouteInfo</code> method to access the dictionary correctly and return the routes' description if found; we do this using the following code:</p><pre class="programlisting">public static string GetRouteInfo(string destination) &#13;
{ &#13;
  return RouteInformation.ContainsKey(destination) ?  &#13;
    RouteInformation[destination].RouteDescription : &#13;
    null; &#13;
} &#13;
</pre><p>With that in place, all we need to do is check whether the <code class="literal">CanTravel</code> flag is <code class="literal">true</code> when the system requests, and if you're allowed to travel, update the <code class="literal">CanNavigate</code> method with the following code:</p><pre class="programlisting">public static bool CanNavigate(string destination) &#13;
{ &#13;
  return RouteInformation.ContainsKey(destination) ?  &#13;
    RouteInformation[destination].CanTravel :  &#13;
    false; &#13;
} &#13;
</pre><p>Here, we simply look at the destination from our route information and return with information on whether the player is allowed to travel there or not.</p><p>Now, when you try to go to the construction area, you won't get the prompt from <code class="literal">NavigationPrompt</code> about attempting to leave.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec90"></a>Updating build settings to include new scenes</h3></div></div></div><p>Before we can have code send us from scene to scene, we must update our build settings. To add new scenes, we need to set up the <span class="strong"><strong>Build Settings</strong></span> options for our project to tell it we have some additional scenes to choose from. Open <span class="strong"><strong>Build Settings</strong></span> by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Build Settings</strong></span> from the main menu or using <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>B</em></span> on the keyboard. The <span class="strong"><strong>Build Settings</strong></span> window looks this:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_07_016.jpg" /></div><p>
</p><p>As you can see in the preceding screenshot, the <span class="strong"><strong>Scenes In Build</strong></span> list is currently empty. So, when we run the game, it will just run the current scene in the editor.</p><p>To update this list, either drag the scenes from the project Hierarchy or use the <span class="strong"><strong>Add Current</strong></span> button to add the scene you are currently viewing. So, add the two current scenes into the <span class="strong"><strong>Scenes In Build</strong></span> list, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_07_017.jpg" /></div><p>
</p><p>Now, one important thing to note is the order of the scenes. As you may expect, Unity will always start the project with scene 0, so be sure that the town is the first scene in the list. You can do this by simply dragging the scenes up or down.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip85"></a>Tip</h3><p>This ordering of scenes is very useful and powerful. Some developers like to put levels in order so that they can use the index to progress through.</p><p>However, if you are having trouble with a particular scene in your game when running on a device, another trick is to reorder the scenes in the build so that the troublesome one is the starting scene. This saves you from having to keep playing through until you get to that scene or writing code to accelerate you. Granted, you need to ensure that whatever settings required for the scene are set on load if you debug this way.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec91"></a>Changing scenes</h3></div></div></div><p>Now that both of our scenes are in the <span class="strong"><strong>Build Settings</strong></span>, we can write code to navigate between them. Return to the <code class="literal">NavigationManager</code> script and add the following code at the top of the script:</p><pre class="programlisting">using UnityEngine.SceneManagement;  &#13;
And update the NavigateTo function as such: &#13;
public static void NavigateTo(string destination){ &#13;
    SceneManager.LoadScene(destination); &#13;
}  &#13;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note86"></a>Note</h3><p>In older versions of Unity, you could transition between scenes using <code class="literal">Application.LoadLevel ("name of level");</code> however, this code is now depreciated and will no longer work.</p></div><p>Now when you exit toward the left side of the <code class="literal">Town</code>, you immediate enter the <code class="literal">Overworld</code>.</p></div></div>