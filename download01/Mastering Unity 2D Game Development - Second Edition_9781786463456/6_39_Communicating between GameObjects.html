<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec40"></a>Communicating between GameObjects</h2></div></div><hr /></div><p>In any game, there are planned interactions between any components within the game. These could be as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Physics collision tests</p></li><li style="list-style-type: disc"><p>Reacting to being shot or shooting</p></li><li style="list-style-type: disc"><p>Opening and closing doors</p></li><li style="list-style-type: disc"><p>Triggers, switches, or traps</p></li><li style="list-style-type: disc"><p>Two or more characters talking</p></li></ul></div><p>There are several ways in which you can achieve this, and each has its own particular traits. The selection of the implementations depends on what you need to achieve. The methods are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Delegates</p></li><li style="list-style-type: disc"><p>Events</p></li><li style="list-style-type: disc"><p>Messaging</p></li></ul></div><p>In this section, we will go through each method in detail and highlight the best uses of each.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec66"></a>Delegates</h3></div></div></div><p>We encounter delegates in our everyday lives. Sometimes they are managers, sometimes they are subordinates, and they could even be the barista at your local coffee shop. Effectively, delegates are methods that accept pieces of work to do on behalf of someone else.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip52"></a>Tip</h3><p>Another form of delegates is to use the C# generics and the <code class="literal">Action</code> or <code class="literal">Action&lt;T&gt;</code> methods, which is a shorthand version of the implementations mentioned in the next section. For more information about generics and <code class="literal">Action</code>, refer to <a class="ulink" href="http://msdn.microsoft.com/en-us/library/018hxwa8(v=vs.110).aspx" target="_blank">http://msdn.microsoft.com/en-us/library/018hxwa8(v=vs.110).aspx</a>.</p></div><p>There are two main patterns in which delegates are used: the configurable method pattern and the delegation pattern.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec23"></a>The configurable method pattern</h4></div></div></div><p>The configurable method pattern is used when a piece of work or function is passed to another method to be used to complete a task. This pattern is usually used where different pieces of code can perform a common task in unique ways, such as walking, running, or patrolling. All these tasks can be the default behaviors of a character. Refer to the following figure:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_06_003.jpg" /></div><p>
</p><p>Here, you will have your code calling a <code class="literal">Delegate</code> method, but the contents of this method can be different depending on what you have set it to.</p><p>For instance, refer to the following code:</p><pre class="programlisting"> using System;&#13;
 using UnityEngine; public class Delegates1{&#13;
     //Define delegate method signature&#13;
     delegate void RobotAction();&#13;
     //private property for delegate use&#13;
     RobotAction myRobotAction;&#13;
     void Start (){&#13;
         //Set the default method for the delegate&#13;
         myRobotAction = RobotWalk;&#13;
     }&#13;
     void Update(){&#13;
         //Run the selected delegate method on update&#13;
         myRobotAction();&#13;
     }&#13;
     //public method to tell the robot to walk&#13;
     public void DoRobotWalk(){&#13;
         //set the delegate method to the walk function&#13;
         myRobotAction = RobotWalk;&#13;
     }&#13;
     void RobotWalk(){&#13;
         Debug.Log("Robot walking");&#13;
     }&#13;
     //public method to tell the robot to run&#13;
     public void DoRobotRun(){&#13;
         //set the delegate method to the run function&#13;
         myRobotAction = RobotRun;&#13;
     }&#13;
     void RobotRun(){&#13;
         Debug.Log("Robot running");&#13;
     }&#13;
 }  &#13;
</pre><p>This means that when the <code class="literal">DoRobotWalk</code> method is called, it will set the delegate to the <code class="literal">Walk</code> method, and once updated, it will run the <code class="literal">Walk</code> behavior. If you call the <code class="literal">DoRobotRun</code> public method, it will change the delegate to the <code class="literal">Run</code> behavior, and once updated, it will run the <code class="literal">Run</code> behavior. This is a very simple kind of state machine with no conditions around.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec24"></a>The delegation pattern</h4></div></div></div><p>The delegation pattern is used where a method calls out to a helper library, and on completion of the required task, continues on back in the <code class="literal">main</code> function, as shown in the following figure:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_06_004.jpg" /></div><p>
</p><p>This is usually used with what you might download from the Web. When the download is finished, we do something with what we have downloaded.</p><p>For instance, refer to the following code:</p><pre class="programlisting"> using System;&#13;
 using System.Collections.Generic;&#13;
 public class Delegates2{&#13;
     public class Worker{&#13;
         List&lt;string&gt; WorkCompletedfor = new List&lt;string&gt;();&#13;
         public void DoSomething(string ManagerName,Action myDelegate){&#13;
             //Audits that work was done for which manager&#13;
             WorkCompletedfor.Add(ManagerName);&#13;
             //Begin work&#13;
             myDelegate();&#13;
         }&#13;
     }&#13;
     public class Manager{&#13;
         private Worker myWorker = new Worker();&#13;
         public void PieceOfWork1(){&#13;
             //A piece of very long tedious work&#13;
         }&#13;
         public void PieceOfWork2() {&#13;
             //You guessed it, yet more tedious work&#13;
         }&#13;
         public void DoWork() {&#13;
             //Send worker to do job 1&#13;
             myWorker.DoSomething("Manager1",PieceOfWork1);&#13;
             //Send worker to do job 2&#13;
             myWorker.DoSomething("Manager1", PieceOfWork2);&#13;
         }&#13;
     }&#13;
 } &#13;
</pre><p>Alternatively, you could just express it using the C# lambdas, which simply means you don't need to declare separate functions:</p><pre class="programlisting">public void DoWork2(){&#13;
      private Worker myWorker = new Worker();&#13;
      //Send worker to do job 1&#13;
      myWorker.DoSomething("Manager1", () =&gt;&#13;
      {&#13;
          //A piece of very long tedious work&#13;
      });&#13;
      //Send worker to do job 2&#13;
        myWorker.DoSomething("Manager2", () =&gt;&#13;
        {&#13;
              //You guessed it, yet more tedious work&#13;
        });&#13;
 }  &#13;
</pre><p>If your delegate also uses a string as a parameter, the preceding example could be used as a download pattern where a helper library does the entire download and just returns the XML asset. This asset can then be unpacked and used in the game in your <code class="literal">main</code> function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec25"></a>Compound delegates</h4></div></div></div><p>Both the configurable method pattern and delegation pattern are very powerful techniques when used correctly.</p><p>Another feature of delegates is that they can be compounded, meaning you can assign multiple functions to a single delegate. Also, when a delegate is called, all the methods assigned to the delegate will run, as shown in the following code. This feature is very handy when you want to chain several common functions together instead of one:</p><pre class="programlisting"> using UnityEngine;&#13;
 using System.Collections;&#13;
 public class WorkerManager{&#13;
     void DoWork() {&#13;
         DoJob1();&#13;
         DoJob2();&#13;
         DoJob3();&#13;
     }&#13;
     private void DoJob1(){&#13;
         //Do some filing&#13;
     }&#13;
     private void DoJob2(){&#13;
         //Make coffee for the office&#13;
     }&#13;
     private void DoJob3(){&#13;
         //Stick it to the man&#13;
     }&#13;
 }  &#13;
</pre><p>You can achieve the same output but with more flexibility using the following code:</p><pre class="programlisting"> //A more intelligent WorkerManager&#13;
 public class WorkerManager2{&#13;
     //WorkerManager delegate&#13;
     delegate void MyDelegateHook();&#13;
     MyDelegateHook ActionsToDo;&#13;
     public string WorkerType = "Peon";&#13;
     //On Startup, assign jobs to the worker; note this is&#13;
     //configurable instead of fixed&#13;
     void Start(){&#13;
         //Peons get lots of work to do&#13;
         if (WorkerType == "Peon"){&#13;
             ActionsToDo += DoJob1;&#13;
             ActionsToDo += DoJob2;&#13;
         }&#13;
         //Everyone else plays golf&#13;
         else{&#13;
             ActionsToDo += DoJob3;&#13;
         }&#13;
     }&#13;
     //With Update, do the actions set on ActionsToDo&#13;
     void Update(){&#13;
         ActionsToDo(); &#13;
     }&#13;
     private void DoJob1(){&#13;
         //Do some filing&#13;
     }&#13;
     private void DoJob2(){&#13;
         //Make coffee for the office&#13;
     }&#13;
     private void DoJob3(){&#13;
         //Play Golf&#13;
     }&#13;
 }   &#13;
</pre><p>This also means it's dynamic and you can add additional functions to the delegate that will be called whenever the delegate is called.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip53"></a>Tip</h3><p>Word to the wise: only use chained delegates when you absolutely need the flexibility to do so, as they are a more complex pattern to implement. They are also difficult to debug should something untoward happen.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec67"></a>Events</h3></div></div></div><p>We can describe events as <span class="emphasis"><em>expected announcements</em></span>. Imagine you have a bat phone at your desk; when it rings, you know it's <span class="emphasis"><em>Batman</em></span> on the other end, usually telling you some trouble has been averted. Events are similar to this pattern where there is a hook; this is where you can listen for something to happen and then do something with that event. When it occurs, additionally, through events, you can pass this information to provide yourself with additional informaon about what has occurred, as depicted in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_06_005.jpg" /></div><p>
</p><p>In the following code, events use delegates to describe how they are going to communicate. It defines the form that communication will take and what information will be passed when the event is fired:</p><pre class="programlisting">//Delegate method definition &#13;
public delegate void ClickAction(); &#13;
 &#13;
//Event hook using delegate method signature &#13;
public static event ClickAction OnClicked; &#13;
</pre><p>Now, when an event needs to be initiated in your class, all it needs to do to notify any other code that is listening to the event is call the event such as a method using <code class="literal">delegate</code> as the signature.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip54"></a>Tip</h3><p>However, what you must be careful about is if no one is listening to the event (no one has subscribed to it). To avoide this, you need to check that <code class="literal">delegate</code> is <span class="emphasis"><em>not </em></span>
<code class="literal">null</code> before you call it.</p></div><p>Refer to the following code:</p><pre class="programlisting">void Update(){ &#13;
  //If the space bar is pressed, this item has been clicked &#13;
  if (Input.GetKeyDown(KeyCode.Space)){ &#13;
   &#13;
    //Trigger the event delegate if there is a subscriber &#13;
    if (OnClicked != null){ &#13;
 &#13;
      OnClicked(); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>With the event exposed, any other class or GameObject that needs to be informed about the occurrence of the event just needs to subscribe to the event as follows, using the <code class="literal">+=</code> syntax:</p><pre class="programlisting">void Start(){ &#13;
 &#13;
  //Hook on to the function's onClicked event and run the &#13;
  //Events_OnClicked method when it occurs &#13;
  OnClicked += Events_OnClicked; &#13;
} &#13;
 &#13;
  //Subordinate method &#13;
  void Events_OnClicked(){ &#13;
    Debug.Log("The button was clicked"); &#13;
  } &#13;
 &#13;
void OnDestroy(){ &#13;
  //Unsubscribe from the event to clean up &#13;
  OnClicked -= Events_OnClicked; &#13;
} &#13;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note55"></a>Note</h3><p>It's always a good idea to clean up after yourself and unsubscribe from the events when you no longer need them, as shown in the preceding code, using the <code class="literal">-=</code> syntax.</p></div><p>This is a very simple example, but you could imagine exposing an event for when an enemy is destroyed and hooking your score system into it so that the score is incremented every time an enemy dies.</p><p>A better way is to write a separate method to call when you need to trigger the event; refer to the following code. In this way, you don't have the preceding code repeated throughout:</p><pre class="programlisting">//Safe method for calling the event &#13;
void Clicked(){ &#13;
  //Trigger the event delegate if there is a subscriber &#13;
  if (OnClicked != null){ &#13;
    OnClicked(); &#13;
  } &#13;
} &#13;
</pre><p>Now, all you have to do whenever the event needs to be fired is call the <code class="literal">Clicked</code> method that is shown in the preceding code, which is always safe and won't crash if there are no subscribers.</p><p>As a help, this code is the template I always use when creating an event. To simplify its creation, all you have to do to use it each time is change the name, and if necessary, the delegate signature if you need additional parameters; the following code will tell you how to do this:</p><pre class="programlisting">//Logging template to send a string/report every time something //happens &#13;
public delegate void LogMessage(string message); &#13;
public static event LogMessage Log; &#13;
 &#13;
void OnLog(string message){ &#13;
  if (Log != null){ &#13;
    Log(message); &#13;
  } &#13;
} &#13;
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec68"></a>Messaging</h3></div></div></div><p>Communication is a key factor in any game. A lot of times, we just use colliders or physics to notify two components that there is something to be aware of. This is a very basic form of communication. Other times, we use referencing or (in the case of Unity) trawl through the project's Hierarchy to find another GameObject to communicate with or notify.</p><p>Unity has its own messaging-type functions, such as <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code>. Both functions actually implement event-style code (as in the preceding case) without actually declaring events, but they are very slow and shouldn't be used extensively.</p><p>The <code class="literal">SendMessage</code> function will call a named method on a GameObject (any method with the same name) with a <span class="emphasis"><em>single</em></span> optional parameter as follows:</p><pre class="programlisting">void OnCollisionEnter(Collision col) &#13;
{ &#13;
  col.gameObject.SendMessage("IHitYou"); &#13;
} &#13;
</pre><p>So, it will call the <code class="literal">IHitYou</code> method on whatever you will collide with. By default, this will not cause an error to be raised if whatever you collide with does not have the <code class="literal">IHitYou</code> method. However, if you wish, you can change this by adding <code class="literal">SendMessageOptions</code> when you call <code class="literal">SendMessage</code>, as follows:</p><pre class="programlisting">void OnCollisionEnter(Collision col) &#13;
{ &#13;
  col.gameObject.SendMessage("IHitYou", SendMessageOptions.RequireReceiver); &#13;
} &#13;
</pre><p>If you want to send a value (there can only be one) with the call, just add it after the method name and before <code class="literal">SendMessageOptions</code> (if set).</p><p>The <code class="literal">BroadcastMessage</code> method works in a similar way but will attempt to run your selected method on the selected <code class="literal">gameObject</code> and <span class="emphasis"><em>all</em></span> its children, as follows:</p><pre class="programlisting">void OnCollisionEnter(Collision col) &#13;
{ &#13;
  col.gameObject.BroadcastMessage("IHitYou"); &#13;
} &#13;
</pre><p>Using either of the methods (as stated) is very slow. This is because it has to try and discover (under the hood) if the GameObject (and its children if using broadcast) has the method first; it will then attempt to run it. As Unity will not know until your game starts running and whether a GameObject will have that method, it has to perform this each and every time you try it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec69"></a>A better way</h3></div></div></div><p>To break this dependency between the GameObjects and the need to keep references or the need to discover each other at the design or runtime stage, we need an intermediary that all objects know about, that is, a <code class="literal">Manager</code> class.</p><p>With this <code class="literal">Manager</code> class, it will manage the list of GameObjects that want to listen to the messages and provide an easy way to notify anyone who's listening.</p><p>To implement this, we will use the singleton behavior described earlier by creating three simple, reusable components as a test case.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note56"></a>Note</h3><p>The <code class="literal">MessagingManager.cs</code>, <code class="literal">MessagingClientBroadcast.cs</code>, and <code class="literal">MessagingClientReceiver.cs</code> scripts created next will be used with our game.</p></div><p>First, we create the <code class="literal">Manager</code> class itself. So, create a <code class="literal">MessagingManager.cs</code> C# script and then replace its contents as follows:</p><pre class="programlisting">using System; &#13;
using System.Collections.Generic; &#13;
using UnityEngine; &#13;
 &#13;
public class MessagingManager : MonoBehaviour &#13;
{ &#13;
  //Static singleton property &#13;
  public static MessagingManager Instance { get; private set; } &#13;
 &#13;
  // public property for manager &#13;
  private List&lt;Action&gt; subscribers = new List&lt;Action&gt;(); &#13;
} &#13;
</pre><p>The first property is the singleton instance for the <code class="literal">Manager</code> class, while the second is a list of delegates that will be used to keep track of who needs to be notified.</p><p>Next, we add the <code class="literal">Awake</code> function to initialize the singleton approach:</p><pre class="programlisting">void Awake() &#13;
{ &#13;
  Debug.Log("Messaging Manager Started"); &#13;
  //First, we check if there are any other instances conflicting &#13;
  if (Instance != null &amp;&amp; Instance != this) &#13;
  { &#13;
    //Destroy other instances if it's not the same &#13;
    Destroy(gameObject); &#13;
  } &#13;
 &#13;
  //Save our current singleton instance &#13;
  Instance = this; &#13;
 &#13;
  //Make sure that the instance is not destroyed between scenes &#13;
  //(this is optional) &#13;
  DontDestroyOnLoad(gameObject); &#13;
} &#13;
</pre><p>This is the same as before but with a little extra debug information, so you can see when it is initialized in the <span class="strong"><strong>Console</strong></span> window.</p><p>Then, we add a method, so we can register recipients or subscribers to the messages (with the associated <code class="literal">UnSubscribe</code> and <code class="literal">ClearAllSubscribers</code> methods), as follows:</p><pre class="programlisting">//The Subscribe method for manager &#13;
public void Subscribe(Action subscriber) &#13;
{ &#13;
  Debug.Log("Subscriber registered"); &#13;
  subscribers.Add(subscriber); &#13;
} &#13;
 &#13;
//The Unsubscribe method for manager &#13;
public void UnSubscribe(Action subscriber) &#13;
{ &#13;
  Debug.Log("Subscriber registered"); &#13;
  subscribers.Remove(subscriber); &#13;
} &#13;
 &#13;
//Clear subscribers method for manager &#13;
public void ClearAllSubscribers() &#13;
{ &#13;
  subscribers.Clear(); &#13;
} &#13;
</pre><p>This method just adds the delegate you passed to the <code class="literal">Manager</code> class to be added to the notification list.</p><p>Finally, we add a <code class="literal">Broadcast</code> method that tells the messaging system to let all the subscribers know that something has happened; the following code tells us how to do this:</p><pre class="programlisting">public void Broadcast() &#13;
{ &#13;
  Debug.Log("Broadcast requested, No of Subscribers = " + subscribers.Count); &#13;
  foreach (var subscriber in subscribers) &#13;
  { &#13;
    subscriber(); &#13;
  } &#13;
} &#13;
</pre><p>Here, we simply loop through all the subscribers and notify them using their delegates; very simple!</p><p>As you can see, this is just a very basic messenger that, when called, will tell anyone who is listening that something has happened; there will be no extra information, no details, just an event. This is like the fire alarm in your building; when it goes off, you just run, you don't (usually) ask, you don't question, you just know that when that alarm goes off, you need to get out of the building!</p><p>To finish this <code class="literal">Manager</code> class off, simply create an empty GameObject in your scene and add the script to it. There are ways to do this automatically, but I find this way to be cleaner so that you always know what the active agents in the scene are.</p><p>Putting this to use is simple. As mentioned before, we need three scripts; we have the <code class="literal">Manager</code> class, so now we need a client and a broadcast agent.</p><p>For the broadcast agent, create a C# script named <code class="literal">MessagingClientBroadcast</code> and replace its contents with the following code:</p><pre class="programlisting">using UnityEngine; &#13;
 &#13;
public class MessagingClientBroadcast : MonoBehaviour { &#13;
 &#13;
  void OnCollisionEnter2D(Collision2D col) &#13;
  { &#13;
    MessagingManager.Instance.Broadcast(); &#13;
  } &#13;
} &#13;
</pre><p>The preceding code is just a simple example so that when attached to an object with a 2D collider, it will trigger a broadcast. To test it, just add it to one or both of the border objects in our game scene. In this way, if the player tries to leave the scene, it will ring the alarm bells.</p><p>At the moment though, no one is listening, so let's add a listener/receiver. Create another C# script and name it <code class="literal">MessagingClientReceiver</code>. This script will register for events and log in to the <span class="strong"><strong>Console</strong></span> window with some information about the object it's attached to (obviously, there will be no information from the broadcast event as it has none); the following code will tell you how to do this:</p><pre class="programlisting">using UnityEngine; &#13;
 &#13;
public class MessagingClientReceiver : MonoBehaviour &#13;
{ &#13;
  void Start() &#13;
  { &#13;
    MessagingManager.Instance.Subscribe(ThePlayerIsTryingToLeave); &#13;
  } &#13;
 &#13;
  void ThePlayerIsTryingToLeave() &#13;
  { &#13;
    Debug.Log("Oi Don't Leave me!! - " + tag.ToString()); &#13;
  } &#13;
} &#13;
</pre><p>In simple words, when the GameObject script is attached to a startup, it will register itself with the <code class="literal">MessagingManager</code> script, telling the <code class="literal">Manager</code> class to run the second method in the script when the event occurs. As stated before, this just logs in to the <span class="strong"><strong>Console</strong></span> window for now so that we have something to see.</p><p>Just for fun, also add this script to one or both of the borders in our scene; this is simply because we don't have anything else at the moment. You could add it to the player, making the event an alarm that goes off and changing the <code class="literal">ThePlayerIsTryingToLeave</code> method to cause the player to run in the opposite direction if you wish.</p><p>If you run the project now, you will get the following results:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>One message telling you that the <code class="literal">MessagingManager</code> script has started.</p></li><li style="list-style-type: disc"><p>One message per subscriber that has registered with the manager (although in the <span class="strong"><strong>Console</strong></span> window, you may just see <span class="strong"><strong>2</strong></span> next to the event because it is the same, if you have <span class="strong"><strong>Collapse</strong></span> in the <span class="strong"><strong>Console</strong></span> window selected).</p></li><li style="list-style-type: disc"><p>When the event is triggered, you will get one message per subscriber to tell you that they have received it. Note that each message from the client is particular to the GameObject you attached it to as the message is different.</p></li></ul></div><p>Now, you could have just executed the preceding code using the <code class="literal">Send</code> or <code class="literal">Broadcast</code> Unity methods, and it would have been much simpler. However, you should note that since we are using a single <code class="literal">Manager</code> class, which is a static instance in the scene, at no point should any of the GameObjects involved need to know about each other. There is no need to search the Hierarchy or add components to each other at editing time; it just works.</p></div></div>