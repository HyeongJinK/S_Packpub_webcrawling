<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec69"></a>Selecting a target</h2></div></div><hr /></div><p>Before we can attack an enemy, we must select which enemy to attack. When an enemy is selected, the player needs some visual representation to confirm they have, in fact, selected an enemy. To do this, let's add some selection logic for our enemies and a nice visual effect in 2D. First, we'll create the prefab for this with a little animation and then get ready to attach our <code class="literal">BattleManager</code> script using the variable we added earlier.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec123"></a>The selection circle prefab</h3></div></div></div><p>To show the player which enemy is selected, the following circle will spin below the enemy:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_10_008.jpg" /></div><p>
</p><p>So, add <code class="literal">SelectionCircle.png</code> to your project from the assets that accompany this title to the <code class="literal">Assets\Sprites\Props</code> folder.</p><p>Next, we'll create a prefab of this sprite in our scene for later use. This simply sets up how we want to use it visually, and since we are going to use it several times over in the scene, using prefabs means that there will only be one instance with many copies.</p><p>Now, drag the <code class="literal">SelectionCircle</code> image on to the scene (if it doesn't work, you are looking at the game view, which means that you need to switch to the <span class="strong"><strong>Scene</strong></span> tab) and set the properties, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_10_009.jpg" /></div><p>
</p><p>Finally, drag the object from the <span class="strong"><strong>Scene</strong></span> Hierarchy into the <code class="literal">Assets\Prefabs\Props</code> folder to create the prefab, ensuring its name is <code class="literal">SelectionCircle</code>. Then, delete the object from the scene, as we no longer need it.</p><p>Now, in the <code class="literal">Battle</code> scene, in the editor, select the <code class="literal">BattleManager</code> GameObject in the <span class="strong"><strong>Hierarchy</strong></span>; once you do this, drag the <code class="literal">SelectionCircle</code> prefab on to the <span class="strong"><strong>Selection Circle</strong></span> property for the <code class="literal">BattleManager</code> script to attach it to the <code class="literal">BattleManager</code> GameObject.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec124"></a>Adding selection logic to the EnemyController class</h3></div></div></div><p>With everything set up in the <code class="literal">BattleManager</code> GameObject, we can now return to the <code class="literal">EnemyController</code> script and make it so that the <code class="literal">SelectionCircle</code> prefab highlights a Dragon if the player clicks on it.</p><p>First, we need a couple of properties in the <code class="literal">EnemyController</code> script to keep a reference to our <code class="literal">SelectionCircle</code> prefab and determine whether the current enemy is selected or not. So, add the following to the top of the <code class="literal">EnemyController</code> class:</p><pre class="programlisting">  private bool selected; &#13;
  GameObject selectionCircle; &#13;
</pre><p>Now, to liven up the selection process a bit, let's add some spin to the selection circle when it is on the screen. To do this, we'll add a simple coroutine to constantly update the selection circles' rotation transform (simple and effective). We could have used the 2D animation system to do the same thing, but it's a bit too much for a simple rotation (unless you want to do more fancy things with the selection circle, such as add particles, have the circle jump up and down while spinning, and so on).</p><p>So, in the <code class="literal">EnemyController</code> script, add the following coroutine function:</p><pre class="programlisting">IEnumerator SpinObject(GameObject target) &#13;
{ &#13;
  while (true) &#13;
  { &#13;
    target.transform.Rotate(0, 0, 180 * Time.deltaTime); &#13;
    yield return null; &#13;
  } &#13;
} &#13;
</pre><p>Nothing fancy; you just need to rotate the object on its <span class="emphasis"><em>z</em></span> axis over time.</p><p>If you want the circle to spin faster or slower, just alter the amount of <span class="emphasis"><em>z</em></span> axis rotation you apply. Here, I have it set to spin <code class="literal">180</code> degrees every second, one full spin every 2 seconds.</p><p>Next, when the player clicks on a Dragon, we use the combination of the <code class="literal">BoxCollider2D</code> and <code class="literal">OnMouseDown</code> functions to select the Dragon and display the selection circle.</p><p>Add a new <code class="literal">BoxCollider2D</code> component to the <code class="literal">Dragon</code> prefab and then add the following function to the <code class="literal">EnemyController</code> script:</p><pre class="programlisting"> void OnMouseDown() &#13;
    { &#13;
        if (battleManager.CanSelectEnemy) &#13;
        { &#13;
            selectionCircle = (GameObject)GameObject.Instantiate(battleManager.selectionCircle); &#13;
            selectionCircle.transform.parent = transform; &#13;
            selectionCircle.transform.localPosition = new Vector3 (0f,-1f, 0f); &#13;
            selectionCircle.transform.localScale = new Vector3 (4f, 4f, 1f); &#13;
            StartCoroutine("SpinObject", selectionCircle); &#13;
            battleManager.SelectEnemy(this, EnemyProfile.name); &#13;
            GetComponent&lt;Attack&gt;().attackSelected=false; &#13;
            battleManager.battleStateManager.SetBool("PlayerReady",true); &#13;
        } &#13;
    }  &#13;
</pre><p>Now, once an enemy is selected, the selection circle should appear below it with the following logic:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a clone of the <code class="literal">SelectionCircle</code> prefab.</p></li><li><p>Set its parent to the selected Dragon.</p></li><li><p>Set its local position so that it is just below the Dragon.</p></li><li><p>Make it appear a bit bigger.</p></li><li><p>Start <code class="literal">SelectionCircle</code>, spinning with its coroutine.</p></li><li><p>Tell the <span class="strong"><strong>BattleManager</strong></span> GameObject that we have selected a target to destroy.</p></li><li><p>Reset the <code class="literal">attackSelected</code> Boolean in the <code class="literal">Attack</code> script so that the next round will perform properly.</p></li><li><p>Change the state of the battle so that the attack will now be performed.</p></li></ol></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip119"></a>Tip</h3><p>The <code class="literal">SelectedEnemy()</code> function don't exist on the <code class="literal">BattleManager</code> script yet, so we will return to those shortly. So, you will see this function highlighted red within <span class="strong"><strong>MonoDevelop</strong></span> and also get an error message in the console.</p></div><p>We are done with the <code class="literal">EnemyController</code> script now.</p><p>To finish off the selection logic, let's return to the <code class="literal">BattleManager</code> script and add the two missing functions as follows:</p><pre class="programlisting">public void SelectEnemy(EnemyController enemy, string name) &#13;
{ &#13;
  selectedTarget = enemy; &#13;
  selectedTargetName = name; &#13;
} &#13;
</pre><p>The preceding function is pretty simple. It sets the two variables we created earlier for the <code class="literal">selectedTarget</code> and <code class="literal">selectedTargetName</code> and gets the <code class="literal">EnemyController</code> component for the selected target.</p><p>However, we still can't select the enemy to attack yet, as our <code class="literal">BattleManager</code> script does not let us do it. Since we want to control the flow of what the player does, we do not enable this until they have first selected an attack.</p><p>To enable you to select an enemy and then progress on to the battle, we need to update the <code class="literal">case BattleState.Player_Move</code> as follows:</p><pre class="programlisting">case BattleState.Player_Move: &#13;
    if (GetComponent&lt;Attack&gt;().attackSelected==true){ &#13;
        canSelectEnemy=true; &#13;
    } &#13;
    break;  &#13;
</pre><p>You'll notice that even though the game has changed over to the next state, you can still click on the enemies and add selection circles under them. So, to fix this, update the <code class="literal">case BattleState.Player_Attack</code> as follows:</p><pre class="programlisting">case BattleState.Player_Attack: &#13;
     canSelectEnemy=false; &#13;
     break;  &#13;
</pre><p>Now the battle can ensue. The player selects an attack and a target, and the battle moves on to the next phase. In this new phase, the player can no longer select attacks or enemies and will not be able to do so again until it is their turn.</p><p>Now, when you run the project, the flow of the battle will be as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The battle begins.</p></li><li><p>The introduction is played, informing the player of the battle.</p></li><li><p>The player can select from a list of attacks.</p></li><li><p>When an attack is selected, the attack is highlighted by an outline.</p></li><li><p>The player is asked to select a target.</p></li><li><p>The selected enemy gets the red ring of death circling their feet, and they probably get a sense of foreboding.</p></li><li><p>The <code class="literal">Battle</code> state manager gets informed that the player has completed his/her move and is ready by setting the <code class="literal">PlayerReady</code> property in the state machine to <code class="literal">true</code>.</p></li></ol></div><p>So, when you run the project, your scene should look like the following with the player no longer being able to select anything:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_10_010.jpg" /></div><p>
</p></div></div>