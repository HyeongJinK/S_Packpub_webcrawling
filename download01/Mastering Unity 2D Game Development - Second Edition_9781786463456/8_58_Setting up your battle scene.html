<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec57"></a>Setting up your battle scene</h2></div></div><hr /></div><p>As you would expect, we need to create a new scene for our battles. You may want to create several scenes for different battle areas or you may want to define one generic scene and randomize the contents of that scene to add variation. Obviously, there are pros and cons to each approach, but ultimately the choice is up to you.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec99"></a>Building the new scene</h3></div></div></div><p>For now, we will keep things simple and just create a new scene and then configure it as our battle area. If you have not already made the scene called <code class="literal">BattleScene</code> in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Building Your Project and Character</em></span>, do so now.</p><p>Make it look pretty with some additional background scene elements. I have added the <code class="literal">ForestBackground.png</code> image to the background with an <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> scale set to <code class="literal">1.5</code> to better fit the camera, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_004.jpg" /></div><p>
</p><p>I also imported the <code class="literal">ForestForegroundElements.png</code> image in <span class="strong"><strong>Multiple Sprite</strong></span> mode. I sliced it by hand so that the grass was in one long sprite and the bushes were in two separate sprites, like so:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_005.jpg" /></div><p>
</p><p>I placed these items in the scene with an <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> scale set to <code class="literal">1.5</code> and their <span class="strong"><strong>alpha</strong></span> values set to <code class="literal">168</code> so that they were semi-transparent, as shown in the following screen shot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_006.jpg" /></div><p>
</p><p>Notice that I lined everything up with the bottom of the camera.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip91"></a>Tip</h3><p>Remember to group your additional environmental assets under a single empty GameObject to keep them tidy in the <span class="strong"><strong>Project</strong></span> Hierarchy. Also, set the sprite layer and order appropriately for all elements, including the background texture.</p><p>If you're having trouble getting your background and foreground objects to display in the correct order, don't forget about sprite sorting layers and sorting order!</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec100"></a>Adding the first enemy</h3></div></div></div><p>We need to create a prefab for our first enemy. Doing so is simple. First, let's start with the Dragon character in the asset pack (<code class="literal">dragon.png</code>):</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Split its sprite up using the Automatic <span class="strong"><strong>Sprite Editor.</strong></span>
</p></li><li><p>Drag sprite image <code class="literal">dragon_0</code> on to the scene .</p></li><li><p>Rename the new GameObject <code class="literal">Dragon.</code>
</p></li><li><p>Set its Sprite Sorting Layer to Middleground.</p></li><li><p>Change its <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> scale to <code class="literal">0.5</code>.</p></li><li><p>Set its <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> position to 0.</p></li></ol></div><p>The enemy should look like this:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_007.jpg" /></div><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note92"></a>Note</h3><p>I created the sprite sheet for the Dragon by combining Flappy Dragon sprite sheets provided by bevouliin on OpenGameArt.Org found at <a class="ulink" href="http://opengameart.org/content/flappy-dragon-sprite-sheets" target="_blank">http://opengameart.org/content/flappy-dragon-sprite-sheets</a>. If you are interested in more enemy sprite sheets, check out the other resources provided by bevouliin at <a class="ulink" href="http://opengameart.org/users/bevouliin" target="_blank">http://opengameart.org/users/bevouliin</a>.</p></div><p>With the enemy in place, it's time to give the nasty little fellow some logic; we won't use this just yet in this chapter, but it's good to have it from the beginning (see <a class="link" href="#" linkend="ch10">Chapter 10</a>, <span class="emphasis"><em>The Battle Begins</em></span>, for the applied AI).</p><p>Create a new animator controller called <code class="literal">DragonAI.controller</code> by right-clicking in your <code class="literal">Assets\Animation\Controllers folder</code> and selecting <span class="strong"><strong>Create | Animator Controller.</strong></span>
</p><p>Double-clicking on the new controller brings up the basic Animator view, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_008.jpg" /></div><p>
</p><p>Next, we need some parameters to control the state machine, so add the following parameters to the controller by clicking on the <span class="emphasis"><em>+</em></span> symbol on the parameters bar and selecting the correct data type, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_009.jpg" /></div><p>
</p><p>The parameters to be added and their data types are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">EnemiesInBattle</code>: Int</p></li><li style="list-style-type: disc"><p>
<code class="literal">PlayerHealth</code>: Int</p></li><li style="list-style-type: disc"><p>
<code class="literal">EnemyHealth</code>: Int</p></li><li style="list-style-type: disc"><p>
<code class="literal">PlayerSeen</code>: Bool</p></li><li style="list-style-type: disc"><p>
<code class="literal">PlayerAttacking</code>: Bool</p></li></ul></div><p>Now that we have some input parameters, we need our states. So, create the states shown in the following screenshot on the current animation layer by right-clicking within the window and navigating to <span class="strong"><strong>Create State</strong></span> | <span class="strong"><strong>Empty</strong></span>:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_010.jpg" /></div><p>
</p><p>The states to be added are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Idle</p></li><li style="list-style-type: disc"><p>Run Away</p></li><li style="list-style-type: disc"><p>Attack</p></li><li style="list-style-type: disc"><p>Defend</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note93"></a>Note</h3><p>You should note that the first state will be colored orange, whereas the rest are colored gray. This is simply because the first one you create becomes the default state (the state the state machine will start with). You can change the default state at any time by right-clicking on it and selecting <span class="strong"><strong>Set As Default</strong></span>.</p></div><p>With the parameters and states in place, all that is left is to connect everything up and finalize the state machine. So, as we did in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Getting Animated</em></span>, we need to create some transitions between the states along with the conditions for those transitions, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_011.jpg" /></div><p>
</p><p>As seen in the preceding screenshot, the states and their transitions are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Idle -&gt; Attack - PlayerSeen = true</em></span>
</p></li></ul></div><p>Dragon attacks the player when she sees him</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Idle -&gt; Defend - PlayerSeen = true and PlayerAttacking = true</em></span>
</p></li></ul></div><p>If the player attacks first when they are seen by the Dragon, then defend</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Attack -&gt; Defend - PlayerAttacking = true</em></span>
</p></li></ul></div><p>Switch to defend if the player attacks</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Defend -&gt; Attack - PlayerAttacking = false</em></span>
</p></li></ul></div><p>As soon as the player stops attacking, switch back to attack</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Any State -&gt; Idle - PlayerSeen = false</em></span>
</p></li></ul></div><p>If the Dragon loses sight of the player at any time, go back to idle</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Any State -&gt; Run Away - EnemyHealth &lt; 2 and PlayerHealth &gt; 2</em></span>
</p></li></ul></div><p>The Dragon is basically a coward; if at any time its health drops too low and the player is a lot healthier, then it will fly away as fast as its little wings will take it</p><p>Now that we have an AI state machine for our Dragon, select the <span class="strong"><strong>Dragon</strong></span> GameObject in the <span class="strong"><strong>Scene</strong></span> Hierarchy and add a new <span class="strong"><strong>Animator</strong></span> Component in the <span class="strong"><strong>Inspector</strong></span> menu by dragging the newly created animator to it, which should now look like the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_012.jpg" /></div><p>
</p><p>Now that we have our Dragon set up, we just need to create a prefab from it. So, drag the <span class="strong"><strong>Dragon</strong></span> GameObject from the <span class="strong"><strong>Scene</strong></span> Hierarchy and place it in the <code class="literal">Assets\Prefabs\Characters</code> folder. You can now delete the original in the scene as we don't need it anymore.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note94"></a>Note</h3><p>If you ever need to change or add to a prefab, you can do this at any time by selecting the prefab and updating it in the <span class="strong"><strong>Inspector</strong></span> menu. This will automatically update any scene object created from the prefab. However, if you add the prefab to the scene and then change it, the changes you make will only be for that instance in the scene and will not update the prefab.</p><p>As noted previously, you can also update the prefab from the instance by clicking on the <span class="strong"><strong>Apply</strong></span> button.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec101"></a>Spawning the Dragons</h3></div></div></div><p>Now that we have our Dragon enemy, we need to be able to randomly drop some Dragons into the battle. For this, we need to set up some spawning points (because we don't want them to appear just anywhere) and a script to manage them.</p><p>First, create a new empty GameObject in the scene and call it <code class="literal">SpawnPoints</code>. Position it at (0,0,0). This is just a container to keep the spawn points all together. Create an empty child object of the <code class="literal">SpawnPoints</code> GameObject by right-clicking on <code class="literal">SpawnPoints</code> in the Hierarchy and selecting <span class="strong"><strong>Create Empty</strong></span>. Rename it <code class="literal">Spawn1</code>. Change its display icon to the blue diamond, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_013.jpg" /></div><p>
</p><p>Duplicate this object eight times (by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span>) so that you have a total of nine children of <code class="literal">SpawnPoints</code>. Now name them <code class="literal">Spawn1</code>, <code class="literal">Spawn2</code>, and so on, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_014.jpg" /></div><p>
</p><p>Now, position each spawn point in the scene where you want a Dragon to appear.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip95"></a>Tip</h3><p>While doing this, I find that adding the prefab manually to each spawn point and then positioning it makes it a lot easier to find the right spot. However, remember that the order in which you add them to the scene is important as it affects what order they are drawn in.</p></div><p>After a bit of tinkering, I ended up with the following (I also added the <code class="literal">Protagonist_4</code> sprite for effect):</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_015.jpg" /><div class="caption"><p>The spawn point markers</p></div></div><p>
</p><p>The following screenshot is an example scene where all nine Dragons have spawned in:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_016.jpg" /><div class="caption"><p>An example scene where all nine Dragons have spawned in</p></div></div><p>
</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip96"></a>Tip</h3><p>If you added prefabs of the Dragons to each of your spawn points to help with position the points correctly, don't forget to delete the Dragons from the scene at this point.</p></div><p>Now that we know where the Dragons are going to appear, we just need to get them there, so we'll manage this with a <code class="literal">BattleManager</code> script.</p><p>The purpose of this script is to manage the life cycle of the battle scene—from setting up the battle scene, to taking turns to attack, and to finalizing the battle once complete.</p><p>We start off by creating a new <code class="literal">BattleManager</code> C# script and placing it in the <code class="literal">Scripts</code> folder along with the other managers (if you wish, you can create a separate <code class="literal">Managers</code> folder and organize them there). As this script only works when we are in a battle, there is no need to make it a singleton. Battles come and go and they should only last for the length of the current battle.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note97"></a>Note</h3><p>For now, we will just set up the framework for the battle scene and get it populated. Our poor hero has no chance to defend herself yet, so we'll just let her run away.</p></div><p>First, we'll add some variables that we can configure from the scene using the following code:</p><pre class="programlisting">public GameObject[] EnemySpawnPoints; &#13;
public GameObject[] EnemyPrefabs; &#13;
public AnimationCurve SpawnAnimationCurve; &#13;
</pre><p>The lines in the preceding code maintain the spawn points the battle manager knows about, the possible enemy prefabs it can spawn into the scene, and a curve that we can use later to control how we animate the Dragons. We'll set up the animation curve shortly.</p><p>Next, we have some control variables to manage the battle as it ensues. This is done using the following code:</p><pre class="programlisting">private int enemyCount; &#13;
    &#13;
enum BattlePhase &#13;
{ &#13;
    PlayerAttack, &#13;
    EnemyAttack &#13;
} &#13;
private BattlePhase phase;      &#13;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note98"></a>Note</h3><p>These states are only temporary. In <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Getting Ready to Fight</em></span>, and <a class="link" href="#" linkend="ch10">Chapter 10</a>, <span class="emphasis"><em>The Battle Begins</em></span>, we will build on this for a more full-fledged system using Mecanim.</p></div><p>We keep a count of how many enemies are active in the scene as well as what phase the battle is in at the moment (along with our own enumeration of the states the battle can be in; you can always add more). Finally, we have a flag to monitor whether the enemy characters have actually started fighting.</p><p>Now when the script runs, it needs to initialize the battle arena; so add the following code to the <code class="literal">Start</code> method:</p><pre class="programlisting">void Start () { &#13;
    // Calculate how many enemies &#13;
    enemyCount = Random.Range(1, EnemySpawnPoints.Length); &#13;
    // Spawn the enemies in &#13;
    StartCoroutine(SpawnEnemies()); &#13;
    // Set the beginning battle phase &#13;
    phase = BattlePhase.PlayerAttack; &#13;
} &#13;
</pre><p>Keeping things simple for now, we generate a random number of Dragons who will attack (or be found wandering around the wood waiting to be chopped). Then, we spawn them in using a coroutine and start the battle with the player going first.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note99"></a>Note</h3><p>Since we simply need a fixed random number and we are only doing it at the beginning of the scene, we are just using the Unity <code class="literal">Random</code> function. If we needed a more complex random selection or more frequent selection, we would change this to something more complex or preloaded.</p></div><p>Now that we know how many Dragons we need in the battle, we can spawn them in. I've used a coroutine here so we can animate them one by one as follows:</p><pre class="programlisting">IEnumerator SpawnEnemies() &#13;
{ &#13;
    // Spawn enemies in over time &#13;
    for (int i = 0; i &lt; enemyCount; i++) &#13;
    { &#13;
        var newEnemy = &#13;
            (GameObject)Instantiate(EnemyPrefabs[0]); &#13;
        newEnemy.transform.position = new Vector3(10, -1, 0); &#13;
 &#13;
        yield return StartCoroutine( &#13;
            MoveCharacterToPoint( &#13;
                EnemySpawnPoints[i], newEnemy)); &#13;
        newEnemy.transform.parent = &#13;
            EnemySpawnPoints[i].transform; &#13;
    } &#13;
} &#13;
</pre><p>Here, we loop through how many Dragons we'll need, create a new instance using the prefab we created earlier, set its position off screen, and then animate it on to the screen using yet another coroutine (shown in the following code). When the coroutine finishes animating, we anchor it to the spawn point it was meant for.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note100"></a>Note</h3><p>I put the Enemy prefabs into an array so we can support multiple types of enemies in the battle.</p></div><p>So that the Dragons don't just appear at their spawn points, but rather move in to their spawn points, we use the <code class="literal">AnimationCurve</code> parameter we added to the script and a co-routine. This will move the Dragon from off-screen to its intended spawn point with the following code:</p><pre class="programlisting">IEnumerator MoveCharacterToPoint(GameObject destination,  &#13;
GameObject character) &#13;
{ &#13;
    float timer = 0f; &#13;
    var StartPosition = character.transform.position; &#13;
    if (SpawnAnimationCurve.length &gt; 0) &#13;
    { &#13;
        while (timer &lt; SpawnAnimationCurve.keys[ &#13;
            SpawnAnimationCurve.length - 1].time) &#13;
        { &#13;
            character.transform.position =  &#13;
                Vector3.Lerp(StartPosition,  &#13;
                    destination.transform.position,  &#13;
                        SpawnAnimationCurve.Evaluate(timer)); &#13;
 &#13;
            timer += Time.deltaTime; &#13;
            yield return new WaitForEndOfFrame(); &#13;
        } &#13;
    } &#13;
    else &#13;
    { &#13;
        character.transform.position =  &#13;
            destination.transform.position; &#13;
    } &#13;
} &#13;
</pre><p>In the preceding code, we work out where the GameObject is starting from and then use a <code class="literal">while</code> loop to keep the GameObject moving until it finally reaches its destination. However, to improve things, we will base the loop on the length of the <code class="literal">AnimationCurve</code> parameter we have defined for this transition.</p><p>This allows greater flexibility and allows us to have more complex and longer animations as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>First we check whether there are animation steps (keys) within <code class="literal">AnimationCurve</code> (if you want something to just pop in to place, then don't configure a curve)</p></li><li style="list-style-type: disc"><p>If there are keys in the animation, then we keep iterating until we reach the last key in the animation based on the time of that step and our current iteration time</p></li></ul></div><p>Then, within the loop, we use <code class="literal">Lerp</code> for the position of the object from start to finish using the animation curve to control its time and rate.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note101"></a>Note</h3><p>We only go to the next animation step when the next frame is ready (using the <code class="literal">WaitForEndOfFrame</code> function), else the animation would happen all at once; so we do it gradually each frame.</p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip102"></a>Tip</h3><p>You could use <code class="literal">yield return null</code>; however, this happens indeterminately and could cause the coroutine to be called several times per frame depending on how long the last render/draw took. Since this is a smooth animation, we need to process it for each frame. If it is another operation that just needs controlled cycles/iterations, returning <code class="literal">null</code> may be preferred.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec35"></a>Creating the BattleManager</h4></div></div></div><p>Now we need to create an object in the scene on which the <code class="literal">BattleManager</code> script will be attached. Add a new empty GameObject to the battle scene, name it <code class="literal">BattleManager</code>, and then attach the new script to it. The following screenshot shows the script with the <code class="literal">EnemySpawnPoints </code>and <code class="literal">EnemyPrefabs </code>arrays expanded:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_017.jpg" /></div><p>
</p><p>Once the script is attached to the empty GameObject, it is time to add the spawn points we created earlier to <code class="literal">EnemySpawnPoints</code>, the Dragon prefab to the <code class="literal">EnemyPrefabs</code> parameter, and the <span class="strong"><strong>Spawn Animation Curve</strong></span>. You'll notice the two arrays are empty and there is currently just an empty gray box for the <code class="literal">SpawnAnimationCurve</code>.</p><p>Let's start by adding the spawn points we created earlier to the <code class="literal">EnemySpawnPoints</code> array. This is achieved by dragging the individual spawn points from the Hierarchy over the words, <span class="strong"><strong>Enemy Spawn Points</strong></span>. Once you have dragged all nine spawn points to the array, you should see the following:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_018.jpg" /></div><p>
</p><p>Now, from the <span class="strong"><strong>Project</strong></span> view, drag the Dragon prefab over the words <span class="strong"><strong>Enemy Prefabs</strong></span>. Even though we only have one type of enemy right now, an array was used so that multiple enemies could be added. You should see the following:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_019.jpg" /></div><p>
</p><p>The last thing we are going to do is set up the animation curve. If you click on the gray box, the <span class="strong"><strong>Curve</strong></span> window should pop up. Select the last curve option, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_020.jpg" /></div><p>
</p><p>Now that you have everything set up, your <code class="literal">BattleManager</code> script should appear as follows:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_021.jpg" /></div><p>
</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec102"></a>Allowing the player to run away</h3></div></div></div><p>To start with, we are only going to give the player the option to run away. We will achieve this by adding a button to the scene and then creating code that will execute when that button is pressed.</p><p>To make the button, select <span class="strong"><strong>Create | UI | Button</strong></span>. Then, set its anchor and pivot point to the top-left corner. You'll notice that a text object is a child of the button object. Change the <code class="literal">Text</code> property to say <span class="strong"><strong>Run Away</strong></span>. Your Game view should now look like the following:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_022.jpg" /></div><p>
</p><p>Add a <code class="literal">CanvasGroup</code> component to the Canvas so that we can adjust its interactivity and visibility later. For now, set the <code class="literal">alpha</code> to 0, and deselect <span class="strong"><strong>Interactable</strong></span> and <span class="strong"><strong>Blocks Raycasts</strong></span>. The button should now longer be visible in your game view.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note103"></a>Note</h3><p>Remember, we used a <span class="strong"><strong>CanvasGroup</strong></span> component on the dialog box in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>NPCs and Interactions</em></span>.</p></div><p>We now need to write some logic for this button to follow. We want this button to only be visible during the player's battle phase and we want it to have the player return to the <code class="literal">Overworld</code> scene.</p><p>Return to your <code class="literal">BattleMananger</code> script and add the following to the top of the script:</p><pre class="programlisting">using UnityEngine.UI;  &#13;
</pre><p>The preceding line of code will allow us to have a variable related to a <code class="literal">CanvasGroup</code>.</p><p>Add the following variable declaration:</p><pre class="programlisting">public CanvasGroup theButtons;  &#13;
</pre><p>Now add the following code:</p><pre class="programlisting">void Update(){&#13;
     if (phase == BattlePhase.PlayerAttack){&#13;
         theButtons.alpha=1;&#13;
         theButtons.interactable=true;&#13;
         theButtons.blocksRaycasts=true;&#13;
     }else{&#13;
         theButtons.alpha=0;&#13;
         theButtons.interactable=false;&#13;
         theButtons.blocksRaycasts=false;&#13;
     }&#13;
 }&#13;
 public void RunAway() {&#13;
     NavigationManager.NavigateTo("Overworld");&#13;
 }  &#13;
</pre><p>The <code class="literal">Update</code> function will turn the buttons on and off depending on whether or not it is the player's turn. The <code class="literal">RunAway</code> function will exit to the <code class="literal">Overworld</code> scene.</p><p>When you save the code, you should see a new public variable displaying in the <code class="literal">BattleManager</code> Inspector. Drag and drop the Canvas in to the slot next to <span class="strong"><strong>The Buttons</strong></span>, to assign it to the <code class="literal">CanvasGroup theButtons</code> variable.</p><p>Currently, the <code class="literal">RunAway </code>function is not linked to the button we created earlier. To have this function activate whenever the button is pressed, we need to view the Button's Inspector. You will see at the bottom of the Button's Inspector the following:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_023.jpg" /></div><p>
</p><p>This list being left empty means that nothing happens when the button is clicked. Click on the <span class="strong"><strong>+</strong></span> sign at the bottom:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_024.jpg" /></div><p>
</p><p>In the first drop-down, select <span class="strong"><strong>Editor and Runtime</strong></span>. The slot below it that says <span class="strong"><strong>None (Object) </strong></span>tells the button on which object the script it needs to look at is attached. Since our <code class="literal">RunAway</code> function is on the <code class="literal">BattleMananger</code> object, we will drag and drop that <code class="literal">BattleMananger </code>to this slot.</p><p>Once you do that, the drop-down that says <span class="strong"><strong>No Function</strong></span> will now be interactable. The drop-down will now list all public scripts that are attached to the <code class="literal">BattleMananger</code>. From this drop-down, select <span class="strong"><strong>BattleMananger | RunAway</strong></span>, letting the button know it needs to look at the <code class="literal">BattleMananger</code> script and run the <code class="literal">RunAway</code> function when clicked, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_025.jpg" /></div><p>
</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec103"></a>Starting the battle</h3></div></div></div><p>We have our battle scene up and running, and when the player runs away, she will return to the <code class="literal">Overworld</code>. Wouldn't it be nice to also enter the battle scene? So let's add that.</p><p>We don't want the player to enter a battle when she is right on top of a town and want different areas to have higher probabilities of encountering a battle. So, to begin with, we will create some battle areas.</p><p>Return to the <code class="literal">Overworld</code> scene. Create an empty GameObject and call it <code class="literal">BattleZones</code>. As always, when creating empty GameObjects that will act as a holder, set its <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> position to 0. Now, create an empty GameObject as a child of <code class="literal">BattleZones</code> and call it <code class="literal">Zone</code>. Add a <code class="literal">BoxCollider2D</code> component to it and set<code class="literal"> IsTrigger</code> to true. Give it a red oval icon.</p><p>Leave the <code class="literal">Zone</code> GameObject as is for now, as we will come back to it in a minute. First, we have to write a script to attach to it.</p><p>Create a new C# script in the <code class="literal">Scripts</code> folder and call it <code class="literal">RandomBattle</code>.</p><p>We'll start by declaring some variables:</p><pre class="programlisting">public int battleProbability;&#13;
int encounterChance=100; &#13;
public int secondsBetweenBattles;&#13;
public string battleSceneName;  &#13;
</pre><p>Three of the preceding defined variables are set to public so that we can easily change them for individual battle zones. The first variable, <code class="literal">battleProbability</code>, represents the probability of encountering a battle within the given zone. The second variable,<code class="literal"> encounterChance</code>, will hold a randomly generated number. If this number is less than or equal to <code class="literal">battleProbability</code>, a battle will occur.</p><p>The third variable,<code class="literal"> secondsBetweenBattles</code>, will determine how much time will pass between each <span class="emphasis"><em>try</em></span> at a battle. So, if <code class="literal">encounterChance</code> is assigned a random number and it is greater than<code class="literal"> battleProbability</code>, the amount of time designated by <code class="literal">secondsBetweenBattles</code> will pass before a new random number is assigned to <code class="literal">encounterChance</code>, thus, creating another attempt at battle.</p><p>The last variable,<code class="literal"> battleSceneName</code>, will be the string name of the scene that should load. Right now we only have one scene, but if you wanted to add multiple battle scenes, this will allow you to easily change the scene that loads.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip104"></a>Tip</h3><p>If you had multiple battle scenes, you could make things more interesting by making a <code class="literal">battleSceneName</code> array variable and randomly selecting between multiple scenes similar to the way we selected spawn points for the dragons.</p></div><p>To be able to load scenes through code, we need to add the following to the top of our script:</p><pre class="programlisting">using UnityEngine.SceneManagement;  &#13;
</pre><p>We are going to continually check if a battle should occur while the player is within the specific zone. To do so, we will use <code class="literal">OnTriggerEnter2D</code>, <code class="literal">OnTriggerStay2D</code>, and <code class="literal">OnTriggerExit2D</code> methods:</p><pre class="programlisting">void OnTriggerEnter2D(Collider2D col){&#13;
    encounterChance=Random.Range(1,100);&#13;
    if(encounterChance&gt;battleProbability){&#13;
        StartCoroutine(RecalculateChance());&#13;
    }&#13;
 }  &#13;
  &#13;
IEnumerator RecalculateChance(){&#13;
     while (encounterChance&gt;battleProbability){&#13;
        yield return new WaitForSeconds(secondsBetweenBattles);&#13;
             encounterChance=Random.Range(1,100);&#13;
     }&#13;
 }&#13;
 void OnTriggerStay2D(Collider2D col){&#13;
     if(encounterChance&lt;=battleProbability){&#13;
         Debug.Log("Battle");&#13;
         SceneManager.LoadScene(battleSceneName);&#13;
     }&#13;
 }&#13;
 void OnTriggerExit2D(Collider2D col){&#13;
      encounterChance=100;&#13;
      StopCoroutine(RecalculateChance());&#13;
 }  &#13;
</pre><p>When the player enters the zone (<code class="literal">OnTriggerEnter2D</code>), a random number (<code class="literal">encounterChance</code>) will be generated to determine if a battle will occur. If the battle does not occur, a random number will be generated in the <code class="literal">RecalculateChance</code> function. As long as the player is within the zone (<code class="literal">OnTriggerStay2D</code>), battles will be continually attempted. If a random number is successfully within the probability range, the appropriate scene will load. Once the player exits the zone (<code class="literal">OnTriggerExit2D</code>), battles will no longer be attempted until the player reenters the zone.</p><p>Now we can attach the <code class="literal">RandomBattle</code> script to the <code class="literal">Zone</code> object we created earlier. I'm going to set the <code class="literal">RandomBattle</code> values, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_026.jpg" /></div><p>
</p><p>Now save this zone as a prefab in the <code class="literal">Prefabs/Environments</code> folder so that we can easily reuse it. Do not delete the current zone from the scene; we are just going to rename it now and change its parameters a bit so that it appears as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_027.jpg" /></div><p>
</p><p>Let's make another zone that has a higher chance of battle. Drag the zone prefab to the <code class="literal">BattleZones</code> holder to make it a new child. Rename it and changes its values, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_028.jpg" /></div><p>
</p><p>Before this will work, we need to add <code class="literal">BattleScene</code> to our build settings. Now, random battles will occur when the player walks in these zones.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec104"></a>Saving the map position</h3></div></div></div><p>So, the player will pop back and forth between the overworld and battles. As the player hits the button to run away, we see a very obvious problem: the map scene is starting afresh back at home. This is simply because we are not tracking where the player left the previous scene.</p><p>There are two ways to handle this: either we record where exactly everything is in every scene and where the player enters and exits or we can simply track the last known position (or possibly a mixture of the two?).</p><p>For now, let us simply implement the last known position method. To do this, we are going to need a central place to remember everything about our game world (well, at least the important bits we want to track), such as the player's stats, options and preferences they have set, and where they have been in the world. Some of these will need saving for the next time the player runs the game and some are just for the current instantiation, but we will cover saving and loading later in <a class="link" href="#" linkend="ch13">Chapter 13</a>, <span class="emphasis"><em>Putting a Bow on It</em></span>.</p><p>The settings we need don't have to be part of any scene, actively tracked in the scene, or even interact with other game components. So, we don't need a class that implements <code class="literal">MonoBehaviour</code> or <code class="literal">ScriptableObject</code>; however, we do need it to be around all the time and not be reloaded in every scene. For this, we need a very simple <code class="literal">static</code> class (we implemented one of these earlier in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>The World Map</em></span>, with <code class="literal">NavigationManager</code>).</p><p>Create a new C# script in <code class="literal">Assets\Scripts\Classes</code> called <code class="literal">GameState</code> and populate it with the following code:</p><pre class="programlisting">using System.Collections.Generic; &#13;
using UnityEngine; &#13;
 &#13;
public static class GameState { &#13;
 &#13;
    public static Player CurrentPlayer = &#13;
      ScriptableObject.CreateInstance&lt;Player&gt;(); &#13;
    public static Dictionary&lt;string, Vector3&gt; LastScenePositions = new &#13;
      Dictionary&lt;string, Vector3&gt;(); &#13;
} &#13;
</pre><p>Here, we have some simple properties that do the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Track the player's stats</p></li><li style="list-style-type: disc"><p>A flag to note whether the player is running home away from a battle</p></li><li style="list-style-type: disc"><p>A dictionary to record the scenes the player has been to and the last position they were in that scene</p></li></ul></div><p>This was simple enough, but to avoid unnecessary code duplication, I have also added some helper methods to the <code class="literal">GameState</code> class to manage and simplify the use of the <code class="literal">LastScenePositions</code> dictionary (to save time later).</p><p>So, add the following code to the end of the <code class="literal">GameState</code> class:</p><pre class="programlisting">    public static Vector3 GetLastScenePosition(string sceneName) &#13;
    { &#13;
        if (GameState.LastScenePositions.ContainsKey(sceneName)) &#13;
        { &#13;
            var lastPos = GameState.LastScenePositions[sceneName]; &#13;
            return lastPos; &#13;
        } &#13;
        else &#13;
        { &#13;
            return Vector3.zero; &#13;
        } &#13;
    } &#13;
 &#13;
    public static void SetLastScenePosition( &#13;
        string sceneName, Vector3 position) &#13;
    { &#13;
        if (GameState.LastScenePositions.ContainsKey(sceneName)) &#13;
        { &#13;
            GameState.LastScenePositions[sceneName] = position; &#13;
        } &#13;
        else &#13;
        { &#13;
            GameState.LastScenePositions.Add(sceneName, position); &#13;
        } &#13;
    } &#13;
</pre><p>The preceding code is fairly similar but it ensures simple and effective use of any dictionary class, checking the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>When you request a value from the dictionary, it checks whether it exists first and then returns it</p></li><li style="list-style-type: disc"><p>If the value doesn't exist in the dictionary yet, it returns a default value</p></li><li style="list-style-type: disc"><p>When you add a new value to the dictionary, it checks whether it already exists, and if it does, then it updates the existing value</p></li><li style="list-style-type: disc"><p>If the value does not exist when you try to add it, it just adds it to the dictionary</p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip105"></a>Tip</h3><p>Dictionaries are powerful when used correctly: you can find values by index (in this case a string) or you can find them by ID (like in arrays). You can even loop over dictionaries with <code class="literal">for</code> or <code class="literal">foreach</code> loops.</p><p>However, depending on how you use them, they may not perform well and can also generate garbage, so use them carefully.</p><p>For more details, see the C# article at <a class="ulink" href="http://blogs.msdn.com/b/shawnhar/archive/2007/07/02/twin-paths-to-garbage-collector-nirvana.aspx" target="_blank">http://blogs.msdn.com/b/shawnhar/archive/2007/07/02/twin-paths-to-garbage-collector-nirvana.aspx</a>. The article is based on XNA but rings true for any C# platform.</p><p>There are also considerations when you need to serialize the values from a dictionary since they are handled differently on some platforms and, in some cases, are not even supported for serialization.</p></div><p>With the <code class="literal">GameState</code> class in place, we will create a <code class="literal">MapPosition</code> script for the map to load the last position if one exists, and save the last position when exiting the scene (and in any other scene that will need the logic).</p><p>Add the following <code class="literal">Awake</code> method to the newly created <code class="literal">MapPosition</code> script:</p><pre class="programlisting">void Awake() &#13;
{ &#13;
    var lastPosition = &#13;
      GameState.GetLastScenePosition(SceneManager.GetActiveScene().name); &#13;
 &#13;
    if (lastPosition != Vector3.zero) &#13;
    { &#13;
        transform.position = lastPosition; &#13;
    } &#13;
} &#13;
</pre><p>The preceding code simply looks for a last position for the current scene, and if there is one, it moves the player to it.</p><p>Similarly, when closing the scene, we just need to store the last position. To do so, we add an <code class="literal">OnDestroy</code> method as follows and save the player's current position:</p><pre class="programlisting">void OnDestroy() &#13;
{ &#13;
    GameState.SetLastScenePosition( &#13;
        SceneManager.GetActiveScene().name, transform.position); &#13;
} &#13;
</pre><p>Attach the <code class="literal">MapPosition</code> script to the player in the Player prefab so that it updates to all instances of the player. This will allow the player to appropriately spawn in both the town and the overworld.</p><p>Initially, it seems like this works very well. But, as is common with programming, sometimes you add a new feature and it breaks something else (or multiple other things).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec105"></a>Stop immediately re-entering battle</h3></div></div></div><p>The first thing you may notice was affected by saving our map position is that since we spawn in a battle zone, it's possible that we immediately re-enter battle. This can be fixed by adding a new Boolean variable to the <code class="literal">GameState </code>script:</p><pre class="programlisting">public static bool justExitedBattle;  &#13;
</pre><p>We will turn this value on and off with the <code class="literal">BattleManager</code> and <code class="literal">RandomBattle</code> scripts.</p><p>Update the<code class="literal"> BattleManager</code> script in the following way:</p><pre class="programlisting">public void RunAway() {&#13;
    GameState.justExitedBattle=true;&#13;
    NavigationManager.NavigateTo("Overworld");&#13;
}  &#13;
</pre><p>Update the <code class="literal">RandomBattle</code> script in the following way:</p><pre class="programlisting">void OnTriggerEnter2D(Collider2D col){&#13;
    if(!GameState.justExitedBattle){&#13;
        encounterChance=Random.Range(1,100);&#13;
        if(encounterChance&gt;battleProbability){&#13;
            StartCoroutine(RecalculateChance());&#13;
        } &#13;
    }else{&#13;
        StartCoroutine(RecalculateChance());&#13;
        GameState.justExitedBattle=false;&#13;
    }&#13;
}  &#13;
</pre><p>Now if <code class="literal">GameState.justExitedBattle</code> is true, the value that checks if an encounter happens will not be calculated until after the time between battles has elapsed.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec106"></a>Going back to town</h3></div></div></div><p>Since adding in the ability to save the map positions, the game goes crazy if you try to enter and exit the town. Now, since the player's last position is being saved, when the player exits town, she continuously goes back and forth between the town and the overworld. This is because when the scene loads, she is touching the collider that loads the previous scene.</p><p>This is a little more complicated to fix, but not by too much. The big problem is that our colliders are being instantly triggered when the scene loads. So, we will be changing the script associated with those colliders causing scene loads (<code class="literal">NavigationPrompt</code>) as well as our <code class="literal">GameState </code>and <code class="literal">MapPositions</code> scripts.</p><p>Reopen the <code class="literal">GameState</code> script and add the following variable:</p><pre class="programlisting">public static bool saveLastPosition=true;  &#13;
</pre><p>Now reopen the<code class="literal"> MapPosition</code> script and adjust the code as follows:</p><pre class="programlisting">void OnDestroy(){&#13;
   if(GameState.saveLastPosition){&#13;
        GameState.SetLastScenePosition(SceneManager.GetActiveScene().name,&#13;
          transform.position);&#13;
    }&#13;
 }  &#13;
</pre><p>The last script we need to change is the <code class="literal">NavigationPrompt</code> script. Add the following variable:</p><pre class="programlisting">public Vector3 startingPosition;  &#13;
</pre><p>Open it and add the following to both the <code class="literal">OnCollisionEnter2D</code> and <code class="literal">OnTriggerEnter2D </code>methods:</p><pre class="programlisting">GameState.saveLastPosition=false; GameState.SetLastScenePosition(SceneManager.GetActiveScene().name, &#13;
  startingPosition);  &#13;
</pre><p>Now we're done with changing code! Essentially what these changes have done is create a Boolean variable that tells us if we will or will not save the last game position. If we do not save the last position, we load a specific <code class="literal">Vector3</code> value instead of grabbing the player's last position when in the scene.</p><p>For this to work appropriately, we need to adjust the parameters of the GameObjects in our <code class="literal">Town</code> and <code class="literal">Overworld</code> scenes that have the <code class="literal">NavigationPrompt</code> script attached to them.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip106"></a>Tip</h3><p>If you forget which objects in a scene have a specific script attached to them, right-click on the script in the Project view and select <span class="strong"><strong>Find References in Scene</strong></span>.</p></div><p>In the <code class="literal">Overworld</code> scene, select the <code class="literal">Town</code> GameObject. Change the <code class="literal">StartingPosition</code> values of the <code class="literal">NavigationPrompt</code> script to the position at which you want the player to start. I used the following properties that place the player where she appears in the screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_029.jpg" /></div><p>
</p><p>In the <code class="literal">Town </code>scene, select the <code class="literal">RightBorder</code> GameObject. Change the <code class="literal">StartingPosition</code> values of the <code class="literal">NavigationPrompt</code> script to the position you want the player to start at. I used the following properties that place the player where she appears in the screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_08_030.jpg" /></div><p>
</p><p>Now the player's position will be appropriately saved when entering and exiting the town.</p></div></div>