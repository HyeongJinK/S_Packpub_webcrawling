<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec39"></a>Advanced programming techniques</h2></div></div><hr /></div><p>As part of this chapter, we will start to go in depth with some advanced programming techniques. These enable us to structure our code better and add management to our game project, instead of just adding GameObjects to the scene.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note50"></a>Note</h3><p>Some of the scripts created in the following sections will only be for example purposes and will not be implemented in our game. However, it is recommended that you follow along. Any scripts that will be needed for our game will be readdressed in the <span class="emphasis"><em>Adding NPCs and A Conversation System</em></span> section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec65"></a>Singletons and managers</h3></div></div></div><p>Any project of a sufficient size and complexity is going to run into issues related to managing your GameObjects as and when they are added and removed from a scene. If you don't get your design right from the start, you are setting yourself up for a world of mess later. A common way to handle this is to use one of the three patterns—single instance managers, singletons, or a dependency—system to manage these controllers for you.</p><p>Singletons are scripts that are ubiquitous to your project. They are called singletons, because the scripts creates only a single instance of itself. There are two main ways through which you can implement the singleton pattern in Unity. The first way is to use a public static parameter within a class to maintain the runtime class. This also allows any other script to access it from anywhere in the game and is useful if you want other events to cause the manager to do something, for example, things related to conversation systems or traps. You can also use an empty GameObject in the scene and attach a singleton pattern script to it. However, you could cause conflicts if you add more than one pattern.</p><p>Managers, on the other hand, are just central scripts that are particular to an individual scene to control and maintain the flow of the scene for one or many items.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec21"></a>The manager approach - using empty GameObjects</h4></div></div></div><p>Whereas singletons are game wide, there is often a cause for just a scene-based manager. Implementing this using an empty GameObject is very easy. Simply use <span class="strong"><strong>Create Empty</strong></span> from the <span class="strong"><strong>GameObject</strong></span> menu or the keyboard shortcut, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_06_001.jpg" /></div><p>
</p><p>The placement of the new GameObject is up to you. If your controller's position is important (like with an enemy spawner), place it where you want the objects to spawn from. If not, it doesn't matter; it just needs to be in the scene somewhere. As it's an empty GameObject, it will not be visible within your scene.</p><p>Then, create your manager script, and simply attach your script to the new empty GameObject.</p><p>For example, if you wanted to spawn enemy objects from a collection according to a simple repeating interval, you could use the following code:</p><pre class="programlisting">public class EnemySpawnManager : MonoBehaviour{ &#13;
     &#13;
    public float spawnTime = 5f; &#13;
    //The amount of time between each spawn. &#13;
    public float spawnDelay = 3f; &#13;
    //The amount of time before spawning starts. &#13;
    public GameObject[] enemies; &#13;
    //Array of enemy prefabs. &#13;
 &#13;
    void Start (){ &#13;
        //Start calling the Spawn function repeatedly after a delay. &#13;
        InvokeRepeating("Spawn", spawnDelay, spawnTime); &#13;
    } &#13;
         &#13;
    void Spawn (){ &#13;
        //Instantiate a random enemy. &#13;
        int enemyIndex = Random.Range(0, enemies.Length); &#13;
        Instantiate(enemies[enemyIndex],  &#13;
            transform.position, transform.rotation); &#13;
    } &#13;
}  &#13;
</pre><p>Then, simply attach your script to the new empty GameObject. For it to function, you will need to assign the prefabs of the types of <code class="literal">enemies</code> you want to appear in the scene by attaching them to the <span class="strong"><strong>Enemies</strong></span> property, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_06_002.jpg" /></div><p>
</p><p>The the preceding code, the <span class="strong"><strong>Enemies</strong></span> property is an array. If you view the preceding screenshot you will see that the <span class="strong"><strong>Enemies</strong></span> property has an arrow next to it. This indicates that the property can be expanded. When adding objects to an array in the Inspector, you simply drag the object over the name of the array. It will then be added as an object in the array. You will see technique implemented later in this chapter as well as in future chapters.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec22"></a>The singleton approach - using the C# singleton pattern</h4></div></div></div><p>The manager approach is fine in most cases, but you have to control each instance of the controller where it is placed. Moreover, you cannot interact with it or trigger it without more configurations added to the <code class="literal">Manager</code> class, and then either bind the manager to other objects or use the <code class="literal">Find</code> function.</p><p>If you need a true manager, a better approach is to employ the singleton pattern for <code class="literal">Manager</code> class; refer to the following example:</p><pre class="programlisting">public class MySingletonManager : MonoBehaviour { &#13;
 &#13;
    //Static singleton property &#13;
    public static MySingletonManager Instance { &#13;
        get; private set; &#13;
    } &#13;
 &#13;
    //public property for manager &#13;
    public string MyTestProperty = "Hello World"; &#13;
 &#13;
    void Awake(){ &#13;
        //Save our current singleton instance &#13;
        Instance = this; &#13;
    } &#13;
 &#13;
    //public method for manager &#13;
    public void DoSomethingAwesome() &#13;
    { } &#13;
}  &#13;
</pre><p>The preceding code is just a very basic singleton implementation, which you can attach to any GameObject in the scene.</p><p>Then, you can access the properties and functions within the singleton script by simply calling the following method from anywhere within your project:</p><pre class="programlisting">//Set the public property of the singleton &#13;
MySingletonManager.Instance.MyTestProperty = "World Hello"; &#13;
 &#13;
//Run the public method from the singleton &#13;
MySingletonManager.Instance.DoSomethingAwesome(); &#13;
</pre><p>The class can run just as any other class with updates, fixed updates, and so on. It can also be expanded very quickly.</p><p>One of the other common uses of this pattern is the use of global variables for your project. However, if you intend to use your singleton class across the scenes, you will also need to ensure that it is not destroyed when the scene unloads with a simple update. This is done by calling <code class="literal">DontDestroyOnLoad</code> when you initialize the class, as shown in the following code:</p><pre class="programlisting">public class MySingletonManager : MonoBehaviour { &#13;
     //static singleton property&#13;
     public static MySingletonManager Instance { &#13;
         get;&#13;
         private set; &#13;
     }&#13;
     //public property for manager&#13;
     public string MyTestProperty = "Hello World";&#13;
     void Awake(){&#13;
         //First we check if there are any other instances conflicting&#13;
         if (Instance != null &amp;&amp; Instance != this)&#13;
         {&#13;
             //Destroy other instances if they are not the same&#13;
             Destroy(gameObject);&#13;
         }&#13;
         //Save our current singleton instance&#13;
         Instance = this;&#13;
         //Make sure that the instance is not destroyed&#13;
         //between scenes (this is optional)&#13;
         DontDestroyOnLoad(gameObject);&#13;
     }&#13;
     //public method for manager&#13;
     public void DoSomethingAwesome()&#13;
     {    }&#13;
 }  &#13;
</pre><p>There are more complicated setups for singletons. If you so wish, you can read them at <a class="ulink" href="http://wiki.unity3d.com/index.php/Singleton" target="_blank">http://wiki.unity3d.com/index.php/Singleton</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note51"></a>Note</h3><p>There is another pattern named <span class="strong"><strong>Dependency Injection</strong></span>. A more robust way to handle the need of manager- or factory-type requirements in any project is to implement an <span class="strong"><strong>Inversion of Control</strong></span> (<span class="strong"><strong>IoC</strong></span>) pattern, such as Dependency Injection.</p><p>Dependency Injection is a large subject, so we won't cover it in this book. The goal here is to make you aware of all the options when architecting your project. If you would like more detailed information on Dependency Injection, I'd recommend the post at <a class="ulink" href="http://blog.sebaslab.com/ioc-container-for-unity3d-part-2/" target="_blank">http://blog.sebaslab.com/ioc-container-for-unity3d-part-2/</a> to start with, and then you can work up from there.</p><p>Dependency Injection is a very powerful tool when employed correctly and can make your project a lot easier, so it is worth looking at it if you are serious. However, care is needed in its use, and it should not be used everywhere; it should only be used where it solves a particular problem.</p><p>A good Unity-based IoC framework is <span class="strong"><strong>StrangeIOC</strong></span>, which can be found at <a class="ulink" href="http://strangeioc.github.io/strangeioc/TheBigStrangeHowTo.html" target="_blank">http://strangeioc.github.io/strangeioc/TheBigStrangeHowTo.html</a>.</p></div></div></div></div>