<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec67"></a>Beefing up the enemy AI</h2></div></div><hr /></div><p>At the moment, <code class="literal">Dragon</code> is just a sprite drawn on the screen with an AI system that just sits idle in the background. So, let's expand on this and give our Dragons some muscle power.</p><p>As stated earlier, to keep the player engaged, you need to have a varied amount of enemies in the battle and they need to be challenging enough to make the player think and apply tactics.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec119"></a>The enemy profile/controller</h3></div></div></div><p>First, we'll create a new profile for the enemies, starting off with a new enumeration for the enemy class. Create a new C# script named <code class="literal">EnemyClass</code> in <code class="literal">Assets\Scripts\Classes</code> and replace its contents with the following code:</p><pre class="programlisting">public enum EnemyClass &#13;
{ &#13;
  Dragon, &#13;
  Blob, &#13;
  NastyPeiceOfWork &#13;
} &#13;
</pre><p>I've used just a couple of examples, as we will only be using the <code class="literal">Dragon</code> for now. Next, create a new <code class="literal">Enemy</code> class C# script in the same folder, as follows:</p><pre class="programlisting">public class Enemy : Entity &#13;
{ &#13;
 &#13;
  public EnemyClass Class; &#13;
} &#13;
</pre><p>The preceding code just extends the base <code class="literal">Entity</code> class for our enemies and adds the <code class="literal">EnemyClass</code> enumeration we just created.</p><p>Now that we have a profile for the enemy, we need a controller to make the enemy perform actions in a controlled way. So, create another C# script named <code class="literal">EnemyController</code> in <code class="literal">Assets\Scripts</code>, starting with the following variables:</p><pre class="programlisting">using System.Collections; &#13;
using UnityEngine; &#13;
 &#13;
public class EnemyController : MonoBehaviour { &#13;
 &#13;
  private BattleManager battleManager; &#13;
  public Enemy EnemyProfile; &#13;
  Animator enemyAI; &#13;
 &#13;
  public BattleManager BattleManager &#13;
  { &#13;
    get &#13;
      { &#13;
        return battleManager; &#13;
      } &#13;
      set &#13;
      { &#13;
        battleManager = value; &#13;
      } &#13;
  } &#13;
} &#13;
</pre><p>The preceding code gives us the missing <code class="literal">EnemyController</code> class that we used in the <code class="literal">BattleManager</code> script with the following properties:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A tight reference to the <code class="literal">BattleManager</code> script, which is needed because the enemies are directly affected by the battle as it is ensued</p></li><li style="list-style-type: disc"><p>The enemy profile</p></li><li style="list-style-type: disc"><p>A reference to the AI animator controller we created in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Encountering Enemies and Running Away</em></span>
</p></li></ul></div><p>As the AI needs information about the battle, we need to ensure that it has kept each frame up to date. So, for this, we add an <code class="literal">UpdateAI</code> method and call it from the <code class="literal">Update</code> method to keep the AI up to date, as follows:</p><pre class="programlisting">void Update() &#13;
{ &#13;
  UpdateAI(); &#13;
} &#13;
 &#13;
public void UpdateAI() &#13;
{ &#13;
  if (enemyAI != null &amp;&amp; EnemyProfile != null) &#13;
  { &#13;
    enemyAI.SetInteger("EnemyHealth", EnemyProfile.health); &#13;
    enemyAI.SetInteger("PlayerHealth",        GameState.CurrentPlayer.health); &#13;
    enemyAI.SetInteger("EnemiesInBattle",        battleManager.EnemyCount); &#13;
  } &#13;
} &#13;
</pre><p>The preceding code just sets the properties of the AI to the current values.</p><p>Next, we need to grab the reference to the AI that is currently configured against the GameObject that will be used by the preceding <code class="literal">UpdateAI</code> function in the <code class="literal">Awake</code> method:</p><pre class="programlisting">public void Awake() &#13;
{ &#13;
  enemyAI = GetComponent&lt;Animator&gt;(); &#13;
  if (enemyAI == null) &#13;
  { &#13;
    Debug.LogError("No AI System Found"); &#13;
  } &#13;
} &#13;
</pre><p>There are several logging options in Unity, from the basic <code class="literal">Log</code> to the more detailed <code class="literal">LogWarning</code> and <code class="literal">LogError</code>. These logging options provide us with more detail while debugging our project, so use them wisely.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip117"></a>Tip</h3><p>To save sanity when you are adding more content to the game, it is worthwhile to add <code class="literal">Debug</code> comments, surrounding them with important components or scripts required by an object. Using them this way does not affect the performance and can save you hours of searching for the reason for a crash because you forgot to add something.</p><p>However, do not use <code class="literal">Debug.Log</code> extensively or in the normal operation of your game, as it kills the performance!</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec120"></a>Updating the Dragon prefab</h3></div></div></div><p>The following are the steps that need to be followed to update the <span class="strong"><strong>Dragon</strong></span> prefab:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The <span class="strong"><strong>Dragon</strong></span> prefab we created earlier now needs this new <code class="literal">EnemyController</code> class attached to it. Select the <span class="strong"><strong>Dragon</strong></span> prefab from the <code class="literal">Assets\Prefabs\Characters folder</code>, click on the <span class="strong"><strong>Add Component</strong></span> button in the <span class="strong"><strong>Inspector</strong></span> window, and navigate to <span class="strong"><strong>Scripts</strong></span> | <span class="strong"><strong>Enemy Controller </strong></span>(notice it breaks your script's name it to two words based on your capitalization), as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_10_001.jpg" /></div><p>
</p></li><li><p>Once added, the updated <span class="strong"><strong>Dragon</strong></span> will look like the following screenshot in the <span class="strong"><strong>Inspector</strong></span> window:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_10_002.jpg" /></div><p>
</p></li></ol></div><p>As you can see, we cannot currently edit the <span class="strong"><strong>Enemy Profile</strong></span> tab from the editor (as this requires a custom Inspector. Hence, we are doing it through the code. You can use a scriptable object asset and assign it to the tab, and I've already shown you how to do this.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec121"></a>Setting up the enemy profile in the code</h3></div></div></div><p>Returning back to the <code class="literal">BattleManager</code> script, the area where we push our Dragons into action is in the <code class="literal">SpawnEnemies</code> coroutine. Now, instead of just throwing sprites at the screen, we can add some real danger to the mix for our humble player using the following code:</p><pre class="programlisting">IEnumerator SpawnEnemies() &#13;
{ &#13;
  //Spawn enemies in over time &#13;
  for (int i = 0; i &lt; enemyCount; i++) &#13;
  { &#13;
    var newEnemy = (GameObject)Instantiate(EnemyPrefabs[0]); &#13;
    newEnemy.transform.position = new Vector3(10, -1, 0); &#13;
    yield return StartCoroutine( &#13;
    MoveCharacterToPoint(EnemySpawnPoints[i], newEnemy)); &#13;
    newEnemy.transform.parent = EnemySpawnPoints[i].transform; &#13;
 &#13;
    var controller = newEnemy.GetComponent&lt;EnemyController&gt;(); &#13;
 &#13;
    controller.BattleManager = this; &#13;
 &#13;
    var EnemyProfile = ScriptableObject.CreateInstance&lt;Enemy&gt;(); &#13;
    EnemyProfile.Class = EnemyClass.Dragon; &#13;
    EnemyProfile.level = 1; &#13;
    EnemyProfile.damage = 1; &#13;
    EnemyProfile.health = 20; &#13;
    EnemyProfile.name = EnemyProfile.Class + " " + i.ToString(); &#13;
     &#13;
    controller.EnemyProfile = EnemyProfile; &#13;
  } &#13;
  BattleStateManager.SetBool("BattleReady", true); &#13;
} &#13;
</pre><p>Now, as we loop through the number of enemies being added to the battle, we grab the <code class="literal">EnemyController</code> class attached to the <span class="strong"><strong>Dragon</strong></span> prefab, create a new <code class="literal">EnemyProfile</code> class, give it some values, and, finally, initialize the controller with the new <code class="literal">EnemyProfile</code> class.</p><p>Ideally, you should change this generation to something that is a bit more structured instead of just initializing it this way, but you should get the picture.</p><p>Now that we have a stronger opponent, let's select an attack and then select the enemy we wish to attack.</p></div></div>