<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec41"></a>Background tasks and coroutines</h2></div></div><hr /></div><p>Next up in the fabulous journey of scripting, we will cover the treacherous realm of background tasks. We use the background tasks to start something (in the background) so that it runs independently of the normal game update and draw cycle.</p><p>The following diagram shows that we can have a second process that runs alongside our main game:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_06_006.jpg" /></div><p>
</p><p>This is usually used for systems that are continually running and not for the main events on the screen, such as AI, a background trading system, or even a continual webservice gathering data for the game.</p><p>Unity also has the ability to synchronize these background threads with a simple function that pauses the operation (or returns the control back to Unity) until the next frame of the game is drawn (<code class="literal">WaitForEndOfFrame</code> or <code class="literal">WaitForFixedUpdate</code>), which gives you a pattern similar the following diagram:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781786463456/graphics/image_06_007.jpg" /></div><p>
</p><p>The benefit of this is that you can wait for the last update or draw cycle to finish before running your process. You might do this if you want to render what is drawn on the screen to an image, and either save it to a disk or upload it to a web service or website.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note57"></a>Note</h3><p>The Unity documents provide a good example of using this behavior; you can find them at <a class="ulink" href="https://docs.unity3d.com/Documentation/ScriptReference/WaitForEndOfFrame.html" target="_blank">https://docs.unity3d.com/Documentation/ScriptReference/WaitForEndOfFrame.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec70"></a>Enter coroutines</h3></div></div></div><p>The proper way to implement long-running tasks in Unity is through the use of a feature called <span class="strong"><strong>coroutines</strong></span>. In simple words, coroutines are Unity's way of launching code in the background, but they do have a few caveats and features around them, though.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p>Coroutines, by default, run on the same thread as the normal game loop. If you are not careful, they can stop your game from running.</p><p>For more information on coroutines and the default execution order of methods, refer to the article in the Unity docs at <a class="ulink" href="https://docs.unity3d.com/Documentation/Manual/ExecutionOrder.html" target="_blank">https://docs.unity3d.com/Documentation/Manual/ExecutionOrder.html</a>.</p></div><p>Coroutines are also helpful for creating functions that you want to trigger after a set amount of seconds.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec71"></a>IEnumerator</h3></div></div></div><p>At their core, coroutines are just normal methods, but they are implemented using a particular generic interface named <code class="literal">IEnumerator</code> as their return type. This enables Unity to track the method's state through several iterations (runs).</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip59"></a>Tip</h3><p>Don't confuse <code class="literal">IEnumerator</code> with <code class="literal">IEnumerable</code> when defining your coroutines; otherwise, you will find that they won't work.</p></div><p>To create a basic coroutine, you simply need to set up the method shown in the following code:</p><pre class="programlisting">IEnumerator MyCoroutine() &#13;
{ &#13;
  //Do something &#13;
  //Then return &#13;
  yield return null; &#13;
 &#13;
} &#13;
</pre><p>This creates a simple single-use coroutine that performs a single function, and when it's finished, it will die and go away.</p><p>A more common pattern is to have a loop of some kind within the function that will not finish until some condition is met; this is done by either using a <code class="literal">while</code> or <code class="literal">for</code> loop as follows:</p><pre class="programlisting">IEnumerator MyCoroutine (){ &#13;
  bool complete = false; &#13;
  while (!complete) &#13;
  { &#13;
    //Do some repetitive task &#13;
    //When done set complete to true &#13;
 &#13;
    //Then return control after each step &#13;
    yield return null; &#13;
  } &#13;
} &#13;
</pre><p>The preceding code will simply run in the background until the condition is met; for example, a timer that is counting down should stop when it reaches 0.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec72"></a>Yielding</h3></div></div></div><p>The <code class="literal">yield</code> operator suspends the current method on the current instruction line until the operation is complete; however, it also allows the CPU to continue between each result that is returned by the called method or the instruction. The following example will pause the loop for 2 seconds between the iterations while returning the control back to the process.</p><p>Here's an example; say we have a function to print 10 lines:</p><pre class="programlisting">IEnumerator Print10Lines() &#13;
{ &#13;
  for (int i = 0; i &lt; 10; i++) &#13;
  { &#13;
    print("Line" + i.ToString()); &#13;
    yield return new WaitForSeconds(2); &#13;
  } &#13;
} &#13;
</pre><p>When the preceding code runs, it will simply loop 10 times, and each time it will print out the line number. However, before continuing, it will wait for 2 seconds.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note60"></a>Note</h3><p>Do not confuse <code class="literal">IEnumerator</code> with <code class="literal">IEnumerable</code>. coroutines and the <code class="literal">yield</code> keyword only work in a method that returns an <code class="literal">IEnumerator</code> feature. This is an easy mistake that can leave you scratching your head for hours.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec73"></a>Starting coroutines</h3></div></div></div><p>There are actually two types of coroutine (it is best to think of them in that way, even though they are actually the same thing): those that are just launched (<code class="literal">fire</code> and <code class="literal">forget</code>) and those that can be managed. The difference is just in the way they are called. The <code class="literal">fire</code> and <code class="literal">forget</code> coroutine functions are simply called using the following code:</p><pre class="programlisting">StartCoroutine(MyCoroutine()); //or &#13;
StartCoroutine(MyCoroutine(MyParameter)); //to use parameters &#13;
</pre><p>In the preceding code, the <code class="literal">MyCoroutine</code> function is started using the <code class="literal">delegate</code> method. Once started, it will not finish until either the function ends or <code class="literal">StopAllCoroutines()</code> is called. Now, start the coroutine using the following code:</p><pre class="programlisting">StartCoroutine("MyCoroutine"); //or  &#13;
StartCoroutine("MyCoroutine", myParameter); //to use parameters &#13;
</pre><p>In the preceding code, you specify the name of your coroutine function and the method's name using a string. This enables you to stop the coroutine from running any time (and from anywhere) using the following code:</p><pre class="programlisting">StopCoroutine("MyCoroutine"); &#13;
</pre><p>The invocation path is something to be kept in mind. You might ask why not just use the second method all the time. The answer is simple. Unity has to use slower methods to discover the method it needs to track when you provide the coroutine's name as a string; just passing the method's name is quicker and smoother. The best advice would be to use each type according to its strengths. Only use the string launch method when you need to manage a background task and use the method names when it is a short-lived function that is solely aimed at accomplishing a single task. For everything else, just weigh up the pros and cons of each approach as you implement it.</p><p>Coroutines can be powerful additions to the arsenal of your game's framework, but they need to be implemented wisely; too many additions to your game (obviously) will just grind it to a halt. If you only ever use the <code class="literal">fire</code> and <code class="literal">forget</code> coroutines, you won't be able to stop them without shutting down all the rest as well (including those you started by naming them as a string).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec74"></a>Closing the gap</h3></div></div></div><p>So now that we understand how we call coroutines, to make the <code class="literal">Print10Lines</code> method described earlier, we will call it as follows:</p><pre class="programlisting">void Example1() &#13;
{ &#13;
  StartCoroutine(Print10Lines()); &#13;
  print("I started printing lines"); &#13;
} &#13;
</pre><p>As explained, the preceding code will kick off the <code class="literal">Print10Lines</code> function and then continue forward while the routing to print the lines continues simultaneously. On the other hand, the following code will print 10 lines, and only after it is finished will it continue and notify you that printing has finished:</p><pre class="programlisting">IEnumerator Example2() &#13;
{ &#13;
  yield return StartCoroutine(Print10Lines()); &#13;
  print("I have finished printing lines"); &#13;
} &#13;
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip61"></a>Tip</h3><p>Any method that has a return type of <code class="literal">IEnumerator</code> has to be called using one of the <code class="literal">StartCoroutine</code> methods; just calling any method with <code class="literal">IEnumerator</code> on its own will do nothing. So, keep this in mind if you are wondering why something is not being called.</p></div></div></div>