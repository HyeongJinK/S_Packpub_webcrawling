<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec76"></a>Examples</h2></div></div><hr /></div><p>In this chapter, we are going to cover a <span>few</span><a id="id325334225" class="indexterm"></a> examples of frequently used mobile-specific UI interactions.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec94"></a>Adding press-and-hold/long-press functionality</h3></div></div></div><p>Press-and-hold is utilized frequently in <span>mobile</span><a id="id325369892" class="indexterm"></a> games. Many games that use right-click on the PC or web use press-and-hold when they are converted to the mobile platform.</p><p>To demonstrate how to implement <strong class="userinput"><code>Press and Hold</code></strong> functionality, we will create a button that has a growing ring that represents hold time. Once a specified amount of time has passed, a function will fire:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/4cd10fb5-c063-4f50-a602-178cc44b5389.png" /></div><p>When working this example, it is important to remember that even though the code is referencing a pointer, this functionality does not <span>work</span><a id="id325369928" class="indexterm"></a> exclusively with a mouse. Placing a finger on a touchscreen functions in the same way as a pointer down, and picking up the finger works the same as a pointer up.</p><p>To create a button with a growing ring that represents hold time, complete the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new scene named <code class="literal">Chapter10Example1</code> in the <code class="literal">Assets/Scenes</code> folder and open the new scene.</li><li>Select <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>UI</code></strong> | <strong class="userinput"><code>Button</code></strong> to create a new button in the scene.</li><li>Set the button's <strong class="userinput"><code>Transition</code></strong> type on the button component to <code class="literal">None</code>.</li><li>Change the text on the button to say <strong class="userinput"><code>Press and Hold</code></strong>.</li><li>Right-click the button in the hierarchy and select <strong class="userinput"><code>UI</code></strong> | <strong class="userinput"><code>Image</code></strong> to add an <span>image child to</span> the <code class="literal">Button</code>.</li><li>Change the <strong class="userinput"><code>Width</code></strong> and <strong class="userinput"><code>Height</code></strong> on the image's <strong class="userinput"><code>Rect Transform</code></strong> to <code class="literal">50</code>.</li><li>Assign the <code class="literal">circular meter_1</code> image to the <strong class="userinput"><code>Source Image</code></strong> of the image component.</li><li>Change the <strong class="userinput"><code>Image Type</code></strong> to <strong class="userinput"><code>Filled</code></strong> and change the <strong class="userinput"><code>Fill Amount</code></strong> to <code class="literal">0</code>.</li><li>To create the press-and-hold functionality on the <code class="literal">Button</code>, we will utilize the <strong class="userinput"><code>Pointer Down</code></strong> and <strong class="userinput"><code>Pointer Up</code></strong> Events. Add the <strong class="userinput"><code>Event Trigger</code></strong> component to the <code class="literal">Button</code> object.</li><li>Select <strong class="userinput"><code>Add New Event Type</code></strong> and select <strong class="userinput"><code>PointerDown</code></strong>.</li><li>Select <strong class="userinput"><code>Add New Event Type</code></strong> and select <strong class="userinput"><code>PointerUp</code></strong>.</li><li>Now we need to actually write the functions that will be called by the Event Triggers we set up in the previous steps. Create a new script in the <code class="literal">Assets/Scripts</code> folder called <code class="literal">LongHoldButton</code>.</li><li>Before opening the script, go ahead and attach it as a component to <code class="literal">Button</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Add the <code class="literal">UnityEngine.UI</code> namespace to the top of the script with the following:</li></ol></div><pre class="programlisting">using UnityEngine.UI;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>To check how long the button is being pressed, we will use a Boolean variable that checks to see if the button is being held and a few different variables related to time. Add the following variable declaration to your script:</li></ol></div><pre class="programlisting">bool buttonPressed=false;
float startTime=0f;
float holdTime=0f;
public float longHoldTime=1f;</pre><p>The <code class="literal">buttonPressed</code> variable will be set to <code class="literal">true</code> with the <code class="literal">PointerDown</code> Event and <code class="literal">false</code> with the <code class="literal">PointerUp</code> Event. The <code class="literal">startTime</code> variable will be set to the current time when the <code class="literal">PointerDown</code> Event is triggered. The <code class="literal">holdTime</code> variable will determine how much time has passed since <code class="literal">startTime</code>. The <code class="literal">longHoldTime</code> variable is the amount of time the <code class="literal">Button</code> must be held down before the long-press is complete. It is public so that it can be easily customized.</p><div class="orderedlist"><ol class="orderedlist arabic" start="16" type="1"><li>The last variable we need will <span>represent</span><a id="id325630618" class="indexterm"></a> the radial filling image. Add the following variable declaration to your code:</li></ol></div><pre class="programlisting">public Image radialFillImage;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="17" type="1"><li>Now we need to write a function that will be called by both the <strong class="userinput"><code>Pointer</code></strong><strong class="userinput"><code>Down</code></strong> and <strong class="userinput"><code>Pointer Up</code></strong> Events:</li></ol></div><pre class="programlisting">public void PressAndRelease(bool pressStatus){
    buttonPressed=pressStatus;

    if(buttonPressed==false){
        holdTime=0;
        radialFillImage.fillAmount=0;
    }else{
        startTime=Time.time;
    }
}</pre><p>This function accepts a Boolean variable from the Event Trigger. It then sets the value of <code class="literal">buttonPressed</code> to the passed value.
When the button is released, a value of <code class="literal">false</code> will be passed to the function. If the value passed is <code class="literal">false</code>, the amount of time that has passed, <code class="literal">holdTime</code>, is reset to <code class="literal">0</code> and the <code class="literal">radialFillImage</code> is reset to have a <code class="literal">fillAmount</code> of <code class="literal">0</code>.
When the button is pressed, the <code class="literal">startTime</code> value will be set to the current time.</p><div class="orderedlist"><ol class="orderedlist arabic" start="18" type="1"><li>Create a function that will be called once the full amount of time needed for the long-press, specified by <code class="literal">longHoldTime</code>, has completed:</li></ol></div><pre class="programlisting">public void LongPressCompleted(){
    radialFillImage.fillAmount=0;
    Debug.Log(do something after long press);
}</pre><p>This function doesn't really do anything <span>but</span><a id="id325630705" class="indexterm"></a> reset the filling image and print out a <code class="literal">Debug.Log</code>. However, you can later reuse this code and replace the <code class="literal">Debug.Log</code> line with more interesting and meaningful actions.</p><div class="orderedlist"><ol class="orderedlist arabic" start="19" type="1"><li>The <code class="literal">Update()</code> function can be used to make the timer count upward. Adjust the <code class="literal">Update()</code> function as follows:</li></ol></div><pre class="programlisting">void Update () {
    if(buttonPressed==true){
        holdTime=Time.time-startTime;
        if(holdTime&gt;=longHoldTime){
            buttonPressed=false;
            LongPressCompleted();
        }else{
            radialFillImage.fillAmount=holdTime/longHoldTime;
        }
    }
}</pre><p>This code makes the value of <code class="literal">holdTime</code> tick upward if the value <code class="literal">buttonPressed</code> is set to <code class="literal">true</code>. Remember, <code class="literal">buttonPressed</code> will be set to <code class="literal">true</code> by a <code class="literal">PointerDown</code> event and <code class="literal">false</code> with a <code class="literal">PointerUp</code> event. So, it will only be <code class="literal">true</code> if the player has pressed the button and not yet released it.
Once the <code class="literal">holdTime</code> value reaches the value specified by <code class="literal">longHoldTime</code>, the timer will stop ticking up, because <code class="literal">buttonPressed</code> will be reset to <code class="literal">false</code>. Additionally, the function <code class="literal">LongPressCompleted()</code> is called. If <code class="literal">longHoldTime</code> has not yet been reached, the image's radial fill will update to represent the percentage of total required time that has transpired.</p><div class="orderedlist"><ol class="orderedlist arabic" start="20" type="1"><li>Now that the script is completed, we can hook up the <code class="literal">PressAndRelease()</code> function with the Event Triggers on the button. Add the <code class="literal">PressAndRelease</code> function from the static list to both the <strong class="userinput"><code>Pointer Down</code></strong> and <strong class="userinput"><code>Pointer Up</code></strong> Event Triggers. Since the <code class="literal">PressAndRelease()</code> function accepts a Boolean variable, there is a checkbox representing the Boolean value that should be passed. Select the checkbox for the <strong class="userinput"><code>Pointer Down</code></strong> Event (sending <code class="literal">true</code>) but not for the <strong class="userinput"><code>Pointer Up</code></strong> Event (sending <code class="literal">false</code>).</li></ol></div><div class="mediaobject"><img src="/graphics/9781787125520/graphics/a828a6ab-bf80-45f2-b20d-11dc1610763c.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="21" type="1"><li>Now we need to assign the image to the <strong class="userinput"><code>Radial Fill Image</code></strong> slot on the <code class="literal">LongHoldButton</code> component.</li></ol></div><p>Playing the game now will demonstrate the <span>image</span><a id="id325369185" class="indexterm"></a> radially filling when you hold the button and printing do something at long press in the console. If you release the button before the fill has completed, it will go away and reset for when you start clicking again.</p><p>Press-and-hold is a pretty common functionality, and while it isn't a pre-installed Event in the Unity Event library, luckily it isn't too difficult to hook up. I recommend holding on to that script so that you can reuse it for future use.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec95"></a>Creating a static four-directional virtual D-pad</h3></div></div></div><p>A D-pad is simply four <span>buttons</span><a id="id325369202" class="indexterm"></a> on a directional pad. To create a D-pad for a mobile game, you just need to create a graphic that contains four <span>buttons</span><a id="id325369212" class="indexterm"></a> on the directions.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note104"></a>Note</h3><p>The art used in this example was obtained from <a class="ulink" href="https://opengameart.org/content/onscreen-controls-8-styles" target="_blank">https://opengameart.org/content/onscreen-controls-8-styles</a>.</p></div><p>To create a virtual D-pad, complete the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new scene named <code class="literal">Chapter10Example2</code> in the <code class="literal">Assets/Scenes</code> folder and open the new scene.</li><li>Import the <code class="literal">d-pad buttons.png</code> sprite sheet into the <code class="literal">Assets/Sprites</code> folder.</li><li>Change the newly imported sprite's <strong class="userinput"><code>Sprite Mode</code></strong> to <strong class="userinput"><code>Multiple</code></strong> and automatically slice it.</li><li>Create a new Canvas with <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>UI</code></strong> | <strong class="userinput"><code>Canvas</code></strong>. Name the new Canvas <code class="literal">D-Pad Canvas</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>The size of a D-pad is incredibly important on mobile devices. Even if the screen gets smaller, you'll probably want the D-pad to be about the same size. If it gets too small, the game can be unplayable or uncomfortable. Therefore, set the Canvas Scaler's <strong class="userinput"><code>UI Scale Mode</code></strong> to <strong class="userinput"><code>Constant Physical Size</code></strong>.</li><li>Add a new image as a child of <code class="literal">D-Pad Canvas</code> with <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>UI</code></strong> | <strong class="userinput"><code>Canvas</code></strong> and rename it <code class="literal">d-pad background</code>.</li><li>Set the <strong class="userinput"><code>Source Image</code></strong> to <code class="literal">d-pad buttons_4</code>.</li><li>Set its anchor and pivot to the lower-left corner of the <span>screen</span><a id="id325369323" class="indexterm"></a> and its <strong class="userinput"><code>Pos X</code></strong> and <strong class="userinput"><code>Pos Y</code></strong> to <code class="literal">30</code>.</li><li>Set its <strong class="userinput"><code>Width</code></strong> and <strong class="userinput"><code>Height</code></strong> to <code class="literal">200</code>:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/4f204efb-f827-4ea4-8cae-52a32a61a332.png" /></div></li><li>Right-click on <code class="literal">d-pad background</code> and add a <span>new</span><a id="id325369369" class="indexterm"></a> button as a child with <strong class="userinput"><code>UI</code></strong> | <strong class="userinput"><code>Button</code></strong>. Rename the new button <code class="literal">Up</code>.</li><li>Remove its child <code class="literal">Text</code> object.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Set the <strong class="userinput"><code>Pos X</code></strong>, <strong class="userinput"><code>Pos Y</code></strong>, <strong class="userinput"><code>Width</code></strong>, and <strong class="userinput"><code>Height</code></strong> of the <code class="literal">Up</code> Button to <code class="literal">0</code>, <code class="literal">65</code>, <code class="literal">60</code>, and <code class="literal">60</code>, respectively:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/6c7125e3-8907-4735-8412-b2336dacc58d.png" /></div></li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Duplicate the <code class="literal">Up</code> button three times and rename the duplicates <code class="literal">Right</code>, <code class="literal">Left</code>, and <code class="literal">Down</code>.</li><li>Set the <code class="literal">Right</code> button's <strong class="userinput"><code>Pos X</code></strong> and <strong class="userinput"><code>Pos Y</code></strong> to <code class="literal">65</code> and <code class="literal">0</code>, respectively.</li><li>Set the <code class="literal">Left</code> button's <strong class="userinput"><code>Pos X</code></strong> and <strong class="userinput"><code>Pos Y</code></strong> to <code class="literal">-65</code> and <code class="literal">0</code>, respectively.</li><li>Set the <code class="literal">Down</code> button's <strong class="userinput"><code>Pos X</code></strong> and <strong class="userinput"><code>Pos Y</code></strong> to <code class="literal">0</code> and <code class="literal">-65</code>, respectively. You should now have four buttons positioned as follows:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/e25d0423-0cbc-43de-b1fa-87d7bf246a48.png" /></div>
These four buttons cover the entire area of the arms of the directional pad. They will act as the hit area for the directions.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="17" type="1"><li>We only really want these four buttons for their hit area and don't want to actually have them visible in the UI. Select all <span>four</span><a id="id325369570" class="indexterm"></a> of the buttons and set the alpha value on the <strong class="userinput"><code>Color</code></strong> property of their image component to <code class="literal">0</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="18" type="1"><li>Since the directional pad image is static <span>and</span><a id="id325369627" class="indexterm"></a> not split into four separate buttons, any transitions applied to it would cover the whole image. However, we can make the individual directions look as if they are being pressed and have some sort of color transition by adding sub-images for the arrows on the directions. Right-click the <code class="literal">Up</code> button and add an image as a child with <strong class="userinput"><code>UI</code></strong> | <strong class="userinput"><code>Image</code></strong>. Rename the new image <code class="literal">Arrow</code>.</li><li>Assign the <code class="literal">d-pad buttons_5</code> sprite to the <strong class="userinput"><code>Source Image</code></strong> on its image component and select <strong class="userinput"><code>Preserve Aspect</code></strong>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="20" type="1"><li>Scale and move the image so that it is appropriately lined up with the arrow displayed on the <code class="literal">d-pad background</code> image:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/8919c3e9-b618-4000-a2d1-affc6663cddc.png" /></div></li><li>Select the <strong class="userinput"><code>Color</code></strong> slot on the <code class="literal">Arrow</code> image component and use the eye dropper tool to grab the color of the arrows from the <code class="literal">d-pad background</code> image.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="22" type="1"><li>Create <code class="literal">Arrow</code> children <span>for</span><a id="id325369704" class="indexterm"></a> each of the <span>other</span><a id="id325369713" class="indexterm"></a> three buttons, and size, position, and color them appropriately. Once completed, your D-pad and hierarchy should appear as follows:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/70678c13-eeae-41e4-8fd7-bfe183d39240.png" /></div></li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="23" type="1"><li>Now, so that the D-pad will react visually when the four directions are pressed, we will set the four Arrows to have a color tint button, <strong class="userinput"><code>Transitions</code></strong> when the four buttons are pressed. For each button, drag its child <code class="literal">Arrow</code> into the <strong class="userinput"><code>Target Graphic</code></strong> slot on its button component. Now, when you press the individual buttons, you will see a slight change in color of the arrows, indicating which direction is pressed. You may wish to change the pressed color to something a bit more drastic than the default gray, if you are having difficulty telling that a <span>change</span><a id="id325369748" class="indexterm"></a> is occurring.</li><li>Add the script named <code class="literal">DPad.cs</code> from the book's code bundle to the <code class="literal">Assets/Scripts</code> folder. This is an incredibly simple script that contains four functions that only write to the console. Hooking up these four functions to the individual directional buttons won't do anything fun, but it will <span>allow</span><a id="id325369766" class="indexterm"></a> us to see logs in the console that let us know the buttons are performing as they should.</li><li>Attach the script to the <code class="literal">d-pad background</code> object.</li><li>Select each of the four directional buttons and, with all of them selected, add an <strong class="userinput"><code><strong class="userinput"><code>On Click (</code></strong>)</code></strong> Event to the button component.</li><li>Now, drag the <code class="literal">d-pad background</code> into the object slot of the <strong class="userinput"><code>On Click ()</code></strong> Event.</li><li>Select each button individually and assign the appropriate functions, <code class="literal">PressUp</code>, <code class="literal">PressDown</code>, <code class="literal">PressLeft</code>, and <code class="literal">PressRight</code>, to their <strong class="userinput"><code>On <strong class="userinput"><code>C</code></strong></code></strong><strong class="userinput"><code>lick ()</code></strong> Events.</li></ol></div><p>Playing the game and selecting the four directional buttons should result in the appropriate message being displayed on the console.</p><p>Many D-pads actually accept nine inputs: the four directs, the four diagonals (corners), and the center. If you want to accept diagonal inputs as well as a center-click for your D-pad, I'd suggest using a grid layout group to evenly space your nine buttons.</p><p>Since D-pads tend to allow press-and-hold, you may want to combine the process used in this example with actions similar to those described in the previous example. Instead of using the <strong class="userinput"><code>On Click ()</code></strong> Event, you could set up an Event Trigger for using the <code class="literal">OnPointerDown</code> and <code class="literal">OnPointerUp</code> Events. These events could then set a Boolean variable <code class="literal">true</code> and <code class="literal">false</code>. For example, on the <code class="literal">Right</code> button, you could have the <code class="literal">OnPointerDown</code> Event set a variable called <code class="literal">moveRight</code> to <code class="literal">true</code> and the <code class="literal">OnPointerUp</code> Event set <code class="literal">moveRight</code> to <code class="literal">false</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec96"></a>Creating a floating eight-directional virtual analog stick</h3></div></div></div><p>In this example, we will create a floating eight-directional virtual analog stick. First, we will create an eight-directional D-pad <span>that</span><a id="id325628396" class="indexterm"></a> simulates a <span>control</span><a id="id325628405" class="indexterm"></a> stick that moves in the direction the player drags:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/5d839986-bf3a-462a-81c4-001cbc16b5d4.png" /></div><p>Then, we will expand the eight-directional D-pad so that it is floating, which means it will not be visible in the scene until the player presses somewhere in the screen. Then it will appear where the player's thumb is located and perform the eight-direction movement based on the player's thumb dragging.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec75"></a>Setting up the eight-directional virtual analog stick</h4></div></div></div><p>To create an analog stick that <span>moves</span><a id="id325628433" class="indexterm"></a> in eight directions, as shown in the previous image, complete the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new scene named <code class="literal">Chapter10Example3</code> in the <code class="literal">Assets/Scenes</code> folder and open the new scene.</li><li>Create a new image with <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>UI</code></strong> | <strong class="userinput"><code>Image</code></strong>. Name the new image <code class="literal">Stick Base</code>.</li><li>Add the <code class="literal">d-pad buttons_15</code> sprite to the <strong class="userinput"><code>Source Image</code></strong> slot of its image component.</li><li>Right-click <code class="literal">Stick Base</code> in the hierarchy and select <strong class="userinput"><code>UI</code></strong> | <strong class="userinput"><code>Image</code></strong> to add an image child to the <code class="literal">Stick Base</code>. Name the child <code class="literal">Stick</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Resize the <code class="literal">Stick</code> image to match the <code class="literal">Stick Base</code> by setting its <strong class="userinput"><code>Rect Transform</code></strong> stretch and anchor to stretch fully across both directions.</li><li>Add the <code class="literal">d-pad buttons_0</code> sprite to the <strong class="userinput"><code>Source Image</code></strong> slot of the <code class="literal">Stick</code> image component.</li><li>Set the <strong class="userinput"><code>Left</code></strong>, <strong class="userinput"><code>Top</code></strong>, <strong class="userinput"><code>Right</code></strong>, and <strong class="userinput"><code>Bottom</code></strong> properties of the  <strong class="userinput"><code>Rect Transform</code></strong> all to <code class="literal">20</code> to give some padding <span>around</span><a id="id325628548" class="indexterm"></a> the edges of the <code class="literal">Stick</code>.</li><li>Now, set the pivot and position to <strong class="userinput"><code>middle center</code></strong>. This is an important step! Without doing this, the <code class="literal">Stick</code> will not move around appropriately on the <code class="literal">Stick Base</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781787125520/graphics/4044cbac-65f4-4a05-a593-6981bcaff354.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>That's all there is for the setup to get our virtual analog stick working. We'll just leave it in the center of the screen for now. Now we need to write some code. Create a new script in the <code class="literal">Assets/Script</code> folder and name it <code class="literal">FloatingAnalogStick</code>.</li><li>Add the <code class="literal">UnityEngine.UI</code> namespace to the top of the script with the following:</li></ol></div><pre class="programlisting">using UnityEngine.UI;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>To make the stick wiggle around on top of the base, we need the following variables:</li></ol></div><pre class="programlisting">public RectTransform theStick;
Vector2 mouseStartPosition;
Vector2 mouseCurrentPosition;
public int dragPadding=30;
public int stickMoveDistance=30;</pre><p>The first three variables should be pretty self-explanatory. The <code class="literal">dragPadding</code> variable will be used to determine how far the player has to drag the stick before it actually registers as being moved. The <code class="literal">stickMoveDistance</code> variable specifies how far the stick will actually move outward in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> directions.</p><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Before we write the code that checks how far the player has dragged their finger, let's add a few dummy functions that would allow this analog stick to actually control something in the future. Add the following functions to your script:</li></ol></div><pre class="programlisting">public void MovingLeft(){
    Debug.Log(move left);
}

public void MovingRight(){
    Debug.Log(move right);
}

public void MovingUp(){
    Debug.Log(move up);
}

public void MovingDown(){
    Debug.Log(move down);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>The <code class="literal">Stick</code> will move outward when <span>the</span><a id="id325628660" class="indexterm"></a> player moves their finger from their starting finger-down position. So, let's create a function that will find the starting position when the player begins dragging their finger. Add the following function to your script:</li></ol></div><pre class="programlisting">public void StartingDrag(){
    mouseStartPosition=Input.mousePosition;
}</pre><p>Remember, when working with a touchscreen, <code class="literal">Input.mousePostion</code> will give the value of the touch position.</p><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Now let's create a function that checks how far the player has dragged their finger and moves the <code class="literal">Stick</code> based on that information. Add the following function to your script:</li></ol></div><pre class="programlisting">public void Dragging(){
    float xPos;
    float yPos;
    mouseCurrentPosition=Input.mousePosition;
    if(mouseCurrentPosition.x&lt;mouseStartPosition.x-dragPadding){
        MovingLeft();
        xPos=-10;
    }else
    if(mouseCurrentPosition.x&gt;mouseStartPosition.x+dragPadding){
        MovingRight();
        xPos=10;
    }else{
        xPos=0;
    }

    if(mouseCurrentPosition.y&gt;mouseStartPosition.y+dragPadding){
        MovingUp();
        yPos=10;
    }else if(mouseCurrentPosition.y&lt;mouseStartPosition.y-dragPadding){
        MovingDown();
        yPos=-10;
    }else{
        yPos=0;
    }

    theStick.anchoredPosition=new Vector2(xPos,yPos);
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>The last piece we need to add is something that will reset the stick to its original position once the player stops dragging or lifts up their finger. Add the following function to your script:</li></ol></div><pre class="programlisting">public void StoppedDragging(){
    theStick.anchoredPosition=Vector2.zero;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="16" type="1"><li>Now we need to hook this script and these functions to the items within the scene. Add the <code class="literal">FloatingAnalogStick</code> script to the <code class="literal">Stick Base</code> image.</li><li>Add the <code class="literal">Stick</code> image to the <strong class="userinput"><code>Stick</code></strong> property in the <code class="literal">Floating Analog Stick</code> component.</li><li>Add an Event Trigger component to the <code class="literal">Stick Base</code> object with <strong class="userinput"><code>Add Component</code></strong> | <strong class="userinput"><code>Events</code></strong> | <strong class="userinput"><code>Event Trigger</code></strong>. This will allow the user to use Event Types other than <strong class="userinput"><code>On Click()</code></strong>.</li><li>Add the <strong class="userinput"><code>Begin Drag</code></strong>, <strong class="userinput"><code>Drag</code></strong>, and <strong class="userinput"><code>End Drag</code></strong> Event Types with the <strong class="userinput"><code>Add New Event Type</code></strong> button.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="20" type="1"><li>Add the appropriate functions on the <code class="literal">FloatingAnalogStick</code> script attached to the <code class="literal">Stick Base</code> to the Events:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/4779ae56-7ef9-4029-bd15-3cdee1ab588d.png" /></div></li></ol></div><p>If you play the game now, you should see <span>the</span><a id="id325628828" class="indexterm"></a> eight-directional analog stick responding appropriately. Clicking on it and dragging in any direction will cause the stick to move in the direction of the drag.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec76"></a>Making the eight-directional virtual analog stick float</h4></div></div></div><p>If all you want is an eight-directional analog stick, you're good to go! But, if you want the analog stick to float—appear where the players <span>press</span><a id="id325628843" class="indexterm"></a> and disappear when they lift their finger—you have to do a little bit more work.</p><p>To make the analog stick appear where the player clicks, complete the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>First, we need to create an area where the player will click to bring up the analog stick. Right-click <code class="literal">Canvas</code> in the hierarchy and select <strong class="userinput"><code>UI</code></strong> | <strong class="userinput"><code>Button</code></strong> to add a <code class="literal">Button</code> child to the <code class="literal">Canvas</code>. Rename the <code class="literal">Button</code> to <code class="literal">Click Area</code>.</li><li>Remove the <code class="literal">Text</code> child object from the <code class="literal">Click Area</code>.</li><li>Stretch the <code class="literal">Click Area</code> to fill the whole <code class="literal">Canvas</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Add some padding to the sides of <code class="literal">Click Area</code> by changing the <strong class="userinput"><code>Left</code></strong>, <strong class="userinput"><code>Top</code></strong>, <strong class="userinput"><code>Right</code></strong>, and <strong class="userinput"><code>Bottom</code></strong> properties on the <strong class="userinput"><code>Rect Transform</code></strong> to <code class="literal">50</code>. I have added this padding so that the player cannot click on the very <span>edge</span><a id="id325628933" class="indexterm"></a> of the screen and have the analog stick appear mostly off screen.</li><li>In the hierarchy, move <code class="literal">Click Area</code> so that it is above <code class="literal">Stick Base</code>. Now the <code class="literal">Click Area</code> will render behind the analog stick:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/05dac17d-b0ff-4b04-aae2-5d48a63e6d1e.png" /></div></li><li>Open up your <code class="literal">FloatingAnalogStick</code> code so that we can add some functionality to it.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>To make the position of our analog stick more easily hook to the position of the mouse on the screen, we should move our stick base so that it is centered at the lower-left corner of the <code class="literal">Canvas</code>. Set the anchor and position to the <strong class="userinput"><code>bottom left</code></strong> anchor preset.</li><li>Now, set the <strong class="userinput"><code>X</code></strong> and <strong class="userinput"><code>Y</code></strong><strong class="userinput"><code>Pivot</code></strong> properties to <code class="literal">0.5</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Set the <strong class="userinput"><code>Pos X</code></strong> and <strong class="userinput"><code>Pos Y</code></strong> properties to <code class="literal">-1</code>. This should place the analog stick at the lower-left corner of the Canvas (or screen) with its pivot point set to its center:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/700ac585-5b31-469d-b21c-ab5903d04264.png" /></div></li><li>We need two more variables now to <span>get</span><a id="id325629094" class="indexterm"></a> the analog stick to appear where we want it to in the scene. Add the following variable to your script:</li></ol></div><pre class="programlisting">public RectTransform theBase;
public bool stickAdded=false; </pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Now, create the following function:</li></ol></div><pre class="programlisting">public void AddTheStick(){
    theBase.anchoredPosition=Input.mousePosition;
    theStick.anchoredPosition=Vector2.zero;
    mouseStartPosition=Input.mousePosition;
    stickAdded=true;
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Add the following <code class="literal">Update()</code> function:</li></ol></div><pre class="programlisting">void Update(){
    if(stickAdded==true){
    Dragging();

        if(Input.GetMouseButtonUp(0)){
            stickAdded=false;
            StoppedDragging();
        }
    }
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Add <code class="literal">Stick Base</code> to the <code class="literal">Base</code> slot:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/550b58d1-ad29-471d-8ad5-59ef66a08c1d.png" /></div></li><li>Add the <strong class="userinput"><code>Event Trigger</code></strong> component to the <code class="literal">Click Area</code>.</li><li>Add the following <strong class="userinput"><code>Pointer Down</code></strong> Event to the <code class="literal">Click Area</code>:
<div class="mediaobject"><img src="/graphics/9781787125520/graphics/cc5a8506-d2ff-4bfc-8dcd-b1b92a537a71.png" /></div>
Playing the game now will have the <span>analog</span><a id="id325629189" class="indexterm"></a> stick appear where you click and move around with your dragging.</li><li>Add a <strong class="userinput"><code>Canvas Group</code></strong> component to the <code class="literal">Stick Base</code>.</li><li>Set <strong class="userinput"><code>Alpha</code></strong> to <code class="literal">0</code>, <strong class="userinput"><code>Interactable</code></strong> to <code class="literal">false</code>, and <strong class="userinput"><code>Blocks Raycast</code></strong> to <code class="literal">false</code>.</li><li>Add the following variable:</li></ol></div><pre class="programlisting">CanvasGroup theBaseVisibility;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="19" type="1"><li>Add the following <code class="literal">Awake()</code> function:</li></ol></div><pre class="programlisting">void Awake(){
    theBaseVisibility=theBase.GetComponent&lt;CanvasGroup&gt;();
  }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="20" type="1"><li>Add the following to the <code class="literal">AddTheStick()</code> function:</li></ol></div><pre class="programlisting">theBaseVisibility.alpha=1;
theBaseVisibility.interactable=true;
theBaseVisibility.blocksRaycasts=true;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="21" type="1"><li>Add the following to the innermost <code class="literal">if</code> statement <span>within</span><a id="id325629348" class="indexterm"></a> the <code class="literal">Update()</code> function:</li></ol></div><pre class="programlisting">theBaseVisibility.alpha=0;
theBaseVisibility.interactable=false;
theBaseVisibility.blocksRaycasts=false;</pre><p>Now the analog stick will appear when the player presses down, move in the direction of their finger, and disappear when the player lifts up the finger.</p></div></div></div>