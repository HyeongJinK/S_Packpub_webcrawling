<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec61"></a>Animator Controller</h2></div></div><hr /></div><p>Whenever an Animation Clip is created for an object, an <strong class="userinput"><code>Animator</code></strong> is automatically created for it (if one does not already exist). An Animator <span>component</span><a id="id325334206" class="indexterm"></a> is also automatically added to the object. When we created the <code class="literal">SliderExampleAnimation</code> Animation Clip on the <code class="literal">Slider</code> in the preceding section, an Animator named <code class="literal">Slider</code> was created and the Animator component was attached to the <code class="literal">Slider</code>:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/d75aa575-00ff-40cc-b398-627f45bcf857.png" /></div><p>An Animator is needed to play Animation Clips because it determines when Animation Clips are played.</p><p>An Animator is a type of decision <span>tree</span><a id="id325368600" class="indexterm"></a> known as a <span class="strong"><strong>state machine</strong></span>. It <span>holds</span><a id="id325368611" class="indexterm"></a> a collection of <span class="strong"><strong>states</strong></span>. States are essentially "statuses at a moment in time." The <span class="strong"><strong>current state</strong></span> of a state machine would be a representation of what is happening at <span>this</span><a id="id325368626" class="indexterm"></a> moment. So, for example, if there was a state machine describing my actions and behaviors, my <span class="emphasis"><em>current state</em></span> would be <span class="emphasis"><em>typing on the keyboard</em></span>. My state machine would have other states that I could eventually transition to, such as <span class="emphasis"><em>sleeping</em></span> or <span class="emphasis"><em>crying about approaching deadlines</em></span> if certain conditions are met.</p><p>States in the Animator are represented <span>by</span><a id="id325599121" class="indexterm"></a> rectangles called <span class="strong"><strong>nodes</strong></span>. States are connected by transitions that are represented by arrow lines. These transitions occur after either a predetermined time or a set of conditions have been met. The current state will have a blue, animated status bar on it telling you the percentage of the state that has been completed. If the current state is waiting on a transition to occur, this status bar may loop or stop in the full position until the conditions of the transition are met:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/17e12643-8956-45f9-9296-9acfc2f36821.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip87"></a>Note</h3><p>The bottom-right corner of the Animator Window displays the name of the current Animator controller as well as its folder location. This can be very helpful when you have many different Animators, as it tells you which Animator you are working with.</p></div><p>States can be empty or represent <span>Animation</span><a id="id325599149" class="indexterm"></a> Clips. If a state represents an Animation Clip, it will have an Animation Clip set to its <strong class="userinput"><code>Motion</code></strong> property in its <strong class="userinput"><code>Inspector</code></strong>, as with the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/667a6e3a-3057-40b5-a52a-e62ab9cae846.png" /></div><p>Most states will be colored gray, but those colored otherwise will represent special states. Every Animator will have an <code class="literal">Entry</code> node (green), an <code class="literal">Exit</code> node (red), and a <code class="literal">Any State</code> node (blue) within it. The first state you add to an Animator will be assigned the Default Layer State (orange). You can change the state of the Default Layer State at any time.  Note that Animator Layers are discussed in a later section.</p><p>The <code class="literal">Entry</code> and <code class="literal">Exit</code> nodes essentially work as "gates" between state machines. You can have state machines within state machines, and these "gates" decide what happens after the state machine is entered and exited, respectively. So, the <code class="literal">Entry</code> node represents the instance the state machine starts, and the <code class="literal">Exit</code> node represents the instance it stops.</p><p>The <code class="literal">Entry</code> node always transitions to the Default Layer State, and you cannot define the conditions of the transition, so the transition will always happen automatically and instantly. Therefore, you can think of the Default Layer State as the <span class="emphasis"><em>first</em></span> state that will occur when the state machine begins.</p><p>The <code class="literal">Any State</code> node is an <span class="emphasis"><em>all encompassing</em></span> state. You use this state when you want a transition to happen, regardless of the current state. You can only transition away from the <code class="literal">Any State</code> node. Continuing with the example of a state machine that describes my behavior, I would have a transition from <code class="literal">Any State</code> to the state of <span class="emphasis"><em>crying about approaching deadlines</em></span>, because no matter what I am currently doing, I could burst into tears if the condition "deadline is within 24 hours" is met.</p><p>As stated before, the Animator will stay on the current state until a specified amount of time has passed or a set of conditions have been met. Selecting a transition arrow will display the conditions of transition:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/ba70eb7b-8028-46ef-a78d-eb821ce0aea5.png" /></div><p>The transition from the preceding screenshot <span>requires</span><a id="id325601406" class="indexterm"></a> both a specified amount of time and a condition. The transition also isn't instantaneous and <span>tak</span>es <code class="literal">0.25</code> to complete.</p><p><span>The</span><strong class="userinput"><code>Conditions</code></strong> that must be met for a transition to occur are set by the Animator's <strong class="userinput"><code>Parameters</code></strong>, which can be found and created in the top-left corner of the Animator Window:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/95854263-30ba-4cbe-a00b-c2a4bfd44567.png" /></div><p>The values of these parameters can be set from scripts. There are four types of parameters: <code class="literal">Float</code>, <code class="literal">Int</code>, <code class="literal">Bool</code>, and <code class="literal">Trigger</code>. The first three are named for their value type, but a <code class="literal"><span>Trigger</span></code> is a little less obvious. A Trigger is a Boolean parameter that instantly resets itself to <code class="literal">False</code> after it is used by a transition. <span>Trigger Parameters</span> are helpful for creating floodgate type actions where the animation has to stop and wait before it can proceed to the next state. These are preferred over <span>Bool Parameters</span> in instances where the states and transitions form a loop, because a <span>Bool Parameter</span> would have to be manually reset before the state looped back around.</p><p>When you look at the list of <strong class="userinput"><code>Parameters</code></strong>, you can tell which type they are by the value on the right. <code class="literal">Float</code> Parameters have decimal numbers, <code class="literal">Int</code> Parameters have integers, <code class="literal">Bool</code> Parameters have square checkboxes, and <code class="literal">Trigger</code> Parameters have circular radio buttons.</p><p>Since Animators are state machines, they can be used to accomplish much more than animations. Animators can be used to keep track of complex game logic. For example, I created the following state machine for a match three RPG to keep track of what was currently happening in the game. Using it to keep track of the current state of the <span>game</span><a id="id325630347" class="indexterm"></a> allowed me to restrict what the player could do based on what was happening in the game.</p><p>For example, if the enemy character was attacking, the player would not interact with the pieces on the <span>board:</span></p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/fb4f3a3b-eb21-4ab2-8218-704e13e6f8ee.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec86"></a> The Animator of Transition Animations</h3></div></div></div><p>In <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Buttons</em></span>, we took a look at Button Animation Transitions and created a simple animation for a <span>Button</span>. We let the Button <span>component</span><a id="id325630389" class="indexterm"></a> automatically generate the Animator for us, but never looked at the Animator or did anything with it. Now that we've discussed Animators, let's look at the Animator of <span>the</span><code class="literal">Play Button</code> saved in <code class="literal">Assets/Animations</code>:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/5ac6e789-16a9-42fc-bffc-0559bf7cb6ea.png" /></div><p>As you can see from the preceding screenshot, the Animator that was automatically generated for us isn't particularly complicated and its setup is pretty self-explanatory. It contains states to hold the following four Animation Clips: <code class="literal">Normal</code>, <code class="literal">Highlighted</code>, <code class="literal">Pressed</code>, and <code class="literal">Disabled</code>. All of the Animation Clips transition from <code class="literal">Any State</code>. Also, there are four <code class="literal">Trigger</code> Parameters: <code class="literal">Normal</code>, <code class="literal">Highlighted</code>, <code class="literal">Pressed</code>, and <code class="literal">Disabled</code>.</p><p>Automatically generating an Animator for any of the UI elements that allow for Transition Animations will result in the exact same setup. Even though this Animator is preset for you, you are free to adjust it however you see fit.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec87"></a>Animator layers</h3></div></div></div><p>When using the Animator, if you have a state <span>with</span><a id="id325630459" class="indexterm"></a> transitions to multiple nodes, only one transition can occur. For example, in the following screenshot, the <code class="literal">ChooseAState</code>state can only transition to one of the other states at once, even if the transition conditions for all are met; this is true regardless the type of Parameter that you use:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/ab5e6ed5-e50b-4bd5-8600-144369514f37.png" /></div><p>A Forking Animation example in the Chapter8Text Scene</p><p>If you want multiple animations to trigger at once, you can use Animation Layers. The following layer set up will have all three states running simultaneously:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/bde319e7-28da-4430-a9e2-6ee6ac5152a9.png" /></div><p>An Animation Layers example in the Chapter8Text Scene</p><p>I've found that the most common need for something like this is when you have an object made of multiple sprite sheets and you want <span>multiple</span><a id="id325630498" class="indexterm"></a> sprite sheet animations to trigger at the same time, and putting them all on the same Animation Clip doesn't make sense. For example, I've worked on a game where a 2D character had multiple interchangeable parts, and each part had its own sprite sheet animation. It was necessary to have the "idle" animation for each part start all at the same time. Since the parts could be swapped out, there were multiple combinations of parts that could be achieved, and it would not have made sense to make all the different possible idle animation combinations. It also wouldn't have made sense to give each possible part its own Animator. So, I made a layer for each body part and was able to have the individual sprite animations all play at the same time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec88"></a>Setting Animation Parameters in scripts</h3></div></div></div><p>You can set the values of the Animator Parameters via scripts using the <code class="literal">SetFloat()</code>, <code class="literal">SetInteger()</code>, <code class="literal">SetBool()</code>, and <code class="literal">SetTrigger()</code>, and <code class="literal">ResetTrigger()</code> functions of the Animator class. You reference the Animator Parameter variables by the <span>string</span><a id="id325630529" class="indexterm"></a> names assigned to them within the Animator.</p><p>To set the Animation Parameters, you first get the Animator on which the Parameters were defined; you can do this with either a public <code class="literal">Animator</code> variable or using <code class="literal">GetComponent&lt;Animator&gt;()</code>. Then, you call the necessary function on <span>the</span><code class="literal">Animator</code>.</p><p>For example, the following script would set the Animator Parameters defined in the following sc<span>reenshot</span>:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/12acac34-931d-4502-bff2-133fa1284e80.png" /></div><pre class="programlisting">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Chapter8Examples : MonoBehaviour {
    Animator theAnimator;

    void Awake(){
        theAnimator=GetComponent&lt;Animator&gt;();
    }

    public void SetAnimatorParameters(){
        theAnimator.SetFloat("FloatParameter", 1.0f);
        theAnimator.SetInteger("IntParameter", 1);
        theAnimator.SetBool("BoolParameter", true);
        theAnimator.SetTrigger("TriggerParameter"); //sets to true
        theAnimator.ResetTrigger("TriggerParameter"); //sets to false
    }
}</pre><p>The benefit of using a Trigger is that you usually don't have to reset it, as it instantly resets the moment a transition uses it. However, if you will set a Trigger and the transition is never reached, you will need to reset it using <code class="literal">ResetTrigger()</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec89"></a>Animator behaviours</h3></div></div></div><p>If you want to write code that fires at specific <span>points</span><a id="id325630587" class="indexterm"></a> within a state, you can use a unique class of scripts known as State Machine Behaviours. State Machine Behaviours can be added to any state node you create within the Animator. I specify "you create" because you cannot add them to the <code class="literal">Entry</code> node, <code class="literal">Exit</code> node, or <code class="literal">Any State</code> node.</p><p>You can create a new State Machine Behaviour by selecting a state and clicking on <strong class="userinput"><code>Add Behaviour</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781787125520/graphics/b2bfc164-f99c-4450-9827-0f7e977f09bd.png" /></div><p>All new State Machine Behaviours created in this way are saved in the <code class="literal">Assets</code> folder.</p><p>When you open the script, it will be automatically populated with the following code:</p><pre class="programlisting">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ChooseAStateBehavior : StateMachineBehaviour {

<span><span class="emphasis"><em>// OnStateEnter is called when a transition starts and the state         
      //machine starts to evaluate this state</em></span>
<span class="emphasis"><em>//override public void OnStateEnter(Animator animator, 
      //AnimatorStateInfo stateInfo, int layerIndex) {</em></span>
<span class="emphasis"><em>//</em></span>
<span class="emphasis"><em>//}</em></span>

<span class="emphasis"><em>// OnStateUpdate is called on each Update frame between 
     //OnStateEnter and OnStateExit callbacks</em></span>
<span class="emphasis"><em>//override public void OnStateUpdate(Animator animator, 
     //AnimatorStateInfo stateInfo, int layerIndex) {</em></span>
<span class="emphasis"><em>//</em></span>
<span class="emphasis"><em>//}</em></span>

<span class="emphasis"><em>// OnStateExit is called when a transition ends and the state 
     //machine finishes evaluating this state</em></span>
<span class="emphasis"><em>//override public void OnStateExit(Animator animator, 
     //AnimatorStateInfo stateInfo, int layerIndex) {</em></span>
<span class="emphasis"><em>//</em></span>
<span class="emphasis"><em>//}</em></span>

<span class="emphasis"><em>// OnStateMove is called right after Animator.OnAnimatorMove(). 
     //Code that processes and affects root motion should be 
     //implemented here</em></span>
<span class="emphasis"><em>//override public void OnStateMove(Animator animator, 
     //AnimatorStateInfo stateInfo, int layerIndex) {</em></span>
<span class="emphasis"><em>//</em></span>
<span class="emphasis"><em>//}</em></span>

<span class="emphasis"><em>// OnStateIK is called right after Animator.OnAnimatorIK(). Code 
     //that sets up animation IK (inverse kinematics) should be 
     //implemented here.</em></span>
<span class="emphasis"><em>//override public void OnStateIK(Animator animator, 
     //AnimatorStateInfo stateInfo, int layerIndex) {</em></span>
<span class="emphasis"><em>//</em></span>
<span class="emphasis"><em>//}</em></span>
}</span></pre><p>Note that this class is derived from <code class="literal">StateMachineBehaviour</code> rather than <code class="literal">MonoBehaviour</code>, like the scripts we attach to GameObjects.</p><p>There are a few functions prewritten in the <span>script</span><a id="id325631362" class="indexterm"></a> for you, along with descriptions on how to use them. Just as <code class="literal">Awake()</code>, <code class="literal">Start()</code>, and <code class="literal">Update()</code> are predefined functions for <code class="literal">MonoBehaviour</code>, <code class="literal">OnStateEnter()</code>, <code class="literal">OnStateUpdate()</code>, <code class="literal">OnStateExit()</code>, <code class="literal">OnStateIK()</code>, and <code class="literal">OnStateMove()</code> are predefined functions that call as specific times. You can delete whichever functions you don't want to use. You can also write other functions within this script, and they are not restricted to these predefined ones.</p><p>These functions can do whatever you want them to do, even set the Animator Parameters of your Animator.</p><p>I find State Machine Behaviours to be incredibly helpful, because I use state machines extensively to control the logic of my games. Earlier, in this section, I showed you a state machine I created for a match three RPG. I used multiple State Machine Behaviours to let my other scripts know when the states had changed, call functions from other scripts at specified times, and so on.</p></div></div>