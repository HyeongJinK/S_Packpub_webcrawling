<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec36"></a>Accessing a vertex color in a Surface Shader</h2></div></div><hr /></div><p>Let's begin this <a id="id263" class="indexterm"></a>chapter by taking a look at how we <a id="id264" class="indexterm"></a>can access the information of a model's vertex using the vertex function in a Surface Shader. This will arm us with the knowledge to start utilizing the elements contained within a model's vertex to create really useful and visually appealing effects.</p><p>A vertex in a vertex function can return information about itself that we need to be aware of. You can actually retrieve the vertices' normal directions as a <code class="literal">float3</code> value, the position of the vertex as <code class="literal">float3</code>, and you can even store color values in each vertex and return that color as <code class="literal">float4</code>. This is what we will take a look at in this recipe. We need to see how to store color <a id="id265" class="indexterm"></a>information and retrieve this stored color information inside each vertex of a Surface Shader.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec91"></a>Getting ready</h3></div></div></div><p>In order to write this shader, we need to prepare a few assets. The following steps will set us up to create this Vertex Shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In order to view the colors of a vertex, we need to have a model that has had color applied to <a id="id266" class="indexterm"></a>its vertices. While you could use Unity to apply colors, you would have to write a tool to allow an individual to apply the colors or write some scripts to achieve the color application. In the case of this recipe, we simply utilized <span class="strong"><strong>Maya</strong></span> to apply the colors to our model. This <a id="id267" class="indexterm"></a>model is available on the book's <span class="strong"><strong>Support</strong></span> page at <a class="ulink" href="https://www.packtpub.com/books/content/support" target="_blank">https://www.packtpub.com/books/content/support</a>.</p></li><li><p>Create a new scene and place the imported model in the scene.</p></li><li><p>Create a new shader and material. When completed, assign the shader to the material and then the material to the imported model.</p></li></ol></div><p>Your scene should now look similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_05_01.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec92"></a>How to do it…</h3></div></div></div><p>With our scene, shader, and material created and ready to go, we can begin to write the code for our shader. Launch the shader by double-clicking on it in the <span class="strong"><strong>Project</strong></span> tab in the Unity editor. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>As we are creating a very simple shader, we will not need to include any properties in our <code class="literal">Properties</code> block. We will still include a global tint color, just to stay <a id="id268" class="indexterm"></a>consistent with the other shaders <a id="id269" class="indexterm"></a>in this book. Enter the following code in the <code class="literal">Properties</code> block of your shader:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Properties </strong></span>
{
  _MainTint("Global Color Tint", Color) = (1,1,1,1)
}</pre></div></li><li><p>This next step tells Unity that we will be including a vertex function in our shader:</p><div class="informalexample"><pre class="programlisting">CGPROGRAM
<span class="strong"><strong>#pragma</strong></span> surface surf Lambert vertex:vert</pre></div></li><li><p>As usual, if we have included properties in our <code class="literal">Properties</code> block, we must make sure to create a corresponding variable in our <code class="literal">CGPROGRAM</code> statement. Enter the following code just below the <code class="literal">#pragma</code> statement:</p><div class="informalexample"><pre class="programlisting">float4 _MainTint;</pre></div></li><li><p>We now turn our attention to the <code class="literal">Input</code> struct. We need to add a new variable in order for our <code class="literal">surf()</code> function to access the data given to us by our <code class="literal">vert()</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>struct</strong></span> Input 
{
  float2 uv_MainTex;
  float4 vertColor;
};</pre></div></li><li><p>Now, we can write our simple <code class="literal">vert()</code> function to gain access to the colors stored in each vertex of our mesh:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> vert(inout appdata_full v, out Input o)
{
  o.vertColor = v.color;
}</pre></div></li><li><p>Finally, we can use the vertex color data from our <code class="literal">Input</code> struct to be assigned to the <code class="literal">o.Albedo</code> parameters in the built-in <code class="literal">SurfaceOutput</code> struct:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> surf (Input IN, inout SurfaceOutput o) 
{
  o.Albedo = IN.vertColor.rgb * _MainTint.rgb;
}</pre></div></li><li><p>With our code completed, we can now re-enter the Unity editor and let the shader <a id="id270" class="indexterm"></a>compile. If all goes well, you should <a id="id271" class="indexterm"></a>see something similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_05_02.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec93"></a>How it works…</h3></div></div></div><p>Unity provides us with a way to access the vertex information of the model to which a shader is attached. This gives us the power to modify things such as the vertices' position and color. With this recipe, we have imported a mesh from Maya (though just about any 3D software application can be used), where vertex colors were added to <code class="literal">Verts</code>. You'll notice that by importing the model, the default material will not display the vertex colors. We actually have to write a shader to extract the vertex color and display it on the surface of the model. Unity provides us with a lot of built-in functionality when using Surface Shaders, which make the process of extracting this vertex information quick and efficient.</p><p>Our first task is to tell Unity that we will be using a vertex function when creating our shader. We do this by adding the <code class="literal">vertex:vert</code> parameter to the <code class="literal">#pragma</code> statement of <code class="literal">CGPROGRAM</code>. This automatically makes Unity look for a vertex function named <code class="literal">vert()</code> when it goes to compile the shader. If it doesn't find one, Unity will throw a compiling error and ask you to add a <code class="literal">vert()</code> function to your shader.</p><p>This brings us to our next step. We have to actually code the <code class="literal">vert()</code> function, as seen in step 5. By having this function, we can access the built-in data struct called <code class="literal">appdata_full</code>. This built-in struct is where the vertex information is stored. So, we then extract the vertex color information by passing it to our <code class="literal">Input</code> struct by adding the code, <code class="literal">o.vertColor = v.color</code>.</p><p>The <code class="literal">o</code> variable represents our <code class="literal">Input</code> struct and the <code class="literal">v</code> variable is our <code class="literal">appdata_full</code> vertex data. In this case, we are simply taking the color information from the <code class="literal">appdata_full</code> struct and putting <a id="id272" class="indexterm"></a>it in our <code class="literal">Input</code> struct. Once the vertex <a id="id273" class="indexterm"></a>color is in our <code class="literal">Input</code> struct, we can use it in our <code class="literal">surf()</code> function. In the case of this recipe, we simply apply the color to the <code class="literal">o.Albedo</code> parameter to the built-in <code class="literal">SurfaceOutput</code> struct.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec94"></a>There's more…</h3></div></div></div><p>One can also access a fourth component from the <code class="literal">vert</code> color data. If you notice, the <code class="literal">vertColor</code> variable we declared in the <code class="literal">Input</code> struct is of the <code class="literal">float4</code> type. This means that we are also passing the alpha value of the vertex colors. Knowing this, you can use it to your advantage for the purpose of storing a fourth vertex color to perform effects such as transparency or giving yourself one more mask to blend two textures. It's really up to you and your production to determine if you really need to use the fourth component, but it is worth mentioning here.</p><p>With Unity 5, we now have the ability to target shaders to DirectX 11. This is great, but it means that the compiling process for the shaders is now a bit pickier. This means that we need to include one more line of code to our shader to initialize the output of the vertex information properly. The following code shows what the vertex function code looks like, if you are using DirectX 11 in your shader:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> vert(inout appdata_full v, out Input o)
{
  UNITY_INITIALIZE_OUTPUT(Input, o);
  o.vertColor = v.color;
}</pre></div><p>By including this line of code, your Vertex Shader will not throw any warnings, which say that it won't compile to DirectX 11 appropriately.</p></div></div>