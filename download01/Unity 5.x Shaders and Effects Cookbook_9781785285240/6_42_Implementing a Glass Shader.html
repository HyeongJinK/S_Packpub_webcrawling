<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec44"></a>Implementing a Glass Shader</h2></div></div><hr /></div><p>Glass is a very <a id="id346" class="indexterm"></a>complicated material; it should not be a surprise that other chapters have already created shaders to simulate it in the <span class="emphasis"><em>Adding transparency to PBR</em></span> recipe of <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Creating Test Cases and Writing Scenarios for Behavior Driven Development in Symfony</em></span>. However, there is an effect that transparency cannot reproduce deformations. Most glasses are not perfect, hence they create distortions when we look through them. This recipe will teach you how to do this. The idea behind this effect is to use a Vertex and Fragment Shader with a grab pass, and then sample the grab texture with a little change to its UV data to create a distortion. You can see the effect in the following image, using the glass-stained textures from the <span class="emphasis"><em>Unity Standard Assets</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_06_02.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec120"></a>Getting ready</h3></div></div></div><p>The setup for this recipe is similar to the one presented in the previous chapter:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create new Vertex and Fragment Shaders. You can start by copying the one used in the <a id="id347" class="indexterm"></a>previous recipe, <span class="emphasis"><em>Using grab pass</em></span>, as a base.</p></li><li><p>Create a material that will use the shader.</p></li><li><p>Assign the material to a quad or another flat geometry that will simulate your glass.</p></li><li><p>Place some objects behind it so that you can see the distortion effect.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec121"></a>How to do it…</h3></div></div></div><p>Let's start by editing the Vertex and Fragment Shaders:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add these two properties to the <code class="literal">Properties</code> block:</p><div class="informalexample"><pre class="programlisting">_MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
_BumpMap("Noise text", 2D) = "bump" {}
_Magnitude("Magnitude", Range(0,1)) = 0.05</pre></div></li><li><p>Add their variables in the second pass:</p><div class="informalexample"><pre class="programlisting">sampler2D _MainTex;
sampler2D _BumpMap;
float  _Magnitude;</pre></div></li><li><p>Add the texture information in the input and output structures:</p><div class="informalexample"><pre class="programlisting">float2 texcoord : TEXCOORD0;</pre></div></li><li><p>Transfer the UV data from the input to the output structure:</p><div class="informalexample"><pre class="programlisting">o.texcoord = v.texcoord;</pre></div></li><li><p>Use the following fragment function:</p><div class="informalexample"><pre class="programlisting">half4 frag(vertOutput i) : COLOR {
        half4 mainColour = tex2D(_MainTex, i.texcoord);

    half4 bump = tex2D(_BumpMap, i.texcoord);
    half2 distortion = UnpackNormal(bump).rg;

    i.uvgrab.xy += distortion * _Magnitude;

    fixed4 col = tex2Dproj(_GrabTexture, UNITY_PROJ_COORD(i.uvgrab));
    return col * mainColour * _Colour;
}</pre></div></li><li><p>This material is transparent so it changes its tags in the <code class="literal">SubShader</code> block:</p><div class="informalexample"><pre class="programlisting">Tags{ "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Opaque" }</pre></div></li><li><p>What's left <a id="id348" class="indexterm"></a>now is to set the texture for the glass and a normal map to displace the grab texture.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec122"></a>How it works…</h3></div></div></div><p>The core that this shader uses is a grab pass to take what has already been rendered on the screen. The part where the distortion takes place is in the fragment function. Here, a normal map is unpacked and used to offset the UV data of the grab texture:</p><div class="informalexample"><pre class="programlisting">half4 bump = tex2D(_BumpMap, i.texcoord);
half2 distortion = UnpackNormal(bump).rg;

i.uvgrab.xy += distortion * _Magnitude;</pre></div><p>The <code class="literal">_Magnitude</code> slide is used to determine how strong the effect is.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec123"></a>There's more…</h3></div></div></div><p>This effect is very generic; it grabs the screen and creates a distortion based on a normal map. There is no reason <a id="id349" class="indexterm"></a>why it shouldn't be used to simulate more interesting things. Many games use distortions around explosions or other sci-fi devices. This material can be applied to a sphere and, with a different normal map, it would simulate the heat wave of an explosion perfectly.</p></div></div>