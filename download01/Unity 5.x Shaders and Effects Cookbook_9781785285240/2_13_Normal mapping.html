<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>Normal mapping</h2></div></div><hr /></div><p>Every triangle of a <a id="id109" class="indexterm"></a>3D model has a <span class="emphasis"><em>facing direction</em></span>, which is the direction that it is pointing toward. It is often represented with an arrow placed in the center of the triangle and orthogonal to the surface. The facing direction plays an important role in the way light reflects on a surface. If two adjacent triangles face different directions, they will reflect lights at different angles, hence they'll be shaded differently. For curved objects, this is a problem: it is obvious that the geometry is made out of flat triangles.</p><p>To avoid this problem, the way the light reflects on a triangle doesn't take into account its facing direction, but its <span class="emphasis"><em>normal direction</em></span> instead. As stated in <span class="emphasis"><em>Adding a texture to a shader</em></span> recipe, vertices can store data; the normal direction is the most used information after the UV data. This is a vector of unit length that indicates the direction faced by the vertex. Regardless of the facing direction, every point within a triangle has its own normal direction that is a linear interpolation of the ones stored in its vertices. This gives us the ability to fake the effect of high-resolution geometry on a low-resolution model. The following image shows the same geometric shape rendered with different per-vertex normals. In the image on the left, normals are orthogonal to the face represented by its vertices; this indicates that there is a clear separation between each face. On the right, normals are interpolated along the surface, indicating that even if the surface is rough, light should reflect as if it's smooth. It's easy to see that even if the three objects in the following image share the same geometry, they reflect light differently. Despite being made out of flat triangles, the object on the right reflects light as if its surface was actually curved:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_02_05.jpg" /></div><p>Smooth objects with rough edges are a clear indication that per-vertex normals have been interpolated. This can be seen if we draw the direction of the normal stored in every vertex, as shown in the following image. You should note that every triangle has only three normals, but as multiple triangles can share the same vertex, more than one line can come out of it:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_02_06.jpg" /></div><p>Calculating the normals from the 3D model is a technique that has rapidly declined in favor of a more advanced one—normal mapping. Similar to what happens with texture mapping, the normal directions can be provided using an additional texture, usually called normal map or <a id="id110" class="indexterm"></a>bump map. Normal maps are usually RGB images, where the RGB components are used to indicate the X, Y, and Z components of the normal direction. There are many ways to create normal maps these days. Some applications <a id="id111" class="indexterm"></a>such as <span class="strong"><strong>CrazyBump</strong></span> (<a class="ulink" href="http://www.crazybump.com/" target="_blank">http://www.crazybump.com/</a>) and <a id="id112" class="indexterm"></a>
<span class="strong"><strong>NDO Painter</strong></span> (<a class="ulink" href="http://quixel.se/ndo/" target="_blank">http://quixel.se/ndo/</a>) will take in 2D data and convert it to normal data for you. Other applications such as <a id="id113" class="indexterm"></a>
<span class="strong"><strong>Zbrush 4R7</strong></span> (<a class="ulink" href="http://www.pixologic.com/" target="_blank">http://www.pixologic.com/</a>) and <a id="id114" class="indexterm"></a>
<span class="strong"><strong>AUTODESK</strong></span> (<a class="ulink" href="http://usa.autodesk.com" target="_blank">http://usa.autodesk.com</a>) will take 3D sculpted data and create normal maps for you. The actual process of creating normal maps is definitely out of the scope of this book, but the links in the previous text should help you get started.</p><p>Unity makes the process of adding normals to your shaders quite an easy process in the Surface Shader realm using the <code class="literal">UnpackNormals()</code> function. Let's see how this is done.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec41"></a>Getting ready</h3></div></div></div><p>Create a new material and shader and set them up on a new object in the <span class="strong"><strong>Scene</strong></span> view. This will give us a clean workspace in which we can look at just the normal mapping technique.</p><p>You will need a normal map for this recipe, but there is also one in the Unity project included with this book.</p><p>An example normal map included with this book's contents is shown here:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_02_07.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec42"></a>How to do it…</h3></div></div></div><p>The following are the <a id="id115" class="indexterm"></a>steps to create a normal map shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's get the <code class="literal">Properties</code> block set up in order to have a color tint and texture:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Properties</strong></span>
{
  _MainTint ("Diffuse Tint", Color) = (1,1,1,1)
  _NormalTex ("Normal Map", 2D) = "bump" {}
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>By initializing the texture as <code class="literal">bump</code>, we are telling Unity that <code class="literal">_NormalTex</code> will contain a normal map. If the texture is not set, it will be replaced by a grey texture. The color used <code class="literal">(0.5,0.5,0.5,1)</code> indicates no bump at all.</p></div></li><li><p>Link the properties to the Cg program by declaring them in <code class="literal">SubShader{}</code> below the <code class="literal">CGPROGRAM</code> statement:</p><div class="informalexample"><pre class="programlisting">CPROGRAM
#pragma surface surf Lambert

// Link the property to the CG program
sampler2D _NormalTex;
float4 _MainTint;</pre></div></li><li><p>We need to make sure that we update the <code class="literal">Input</code> struct with the proper variable name so that we can use the model's UVs for the normal map texture:</p><div class="informalexample"><pre class="programlisting">// Make sure you get the UVs for the texture in the struct
<span class="strong"><strong>struct</strong></span> Input
{
  float2 uv_NormalTex;
}</pre></div></li><li><p>Finally, we extract the normal information from the normal map texture using the built-in <a id="id116" class="indexterm"></a>
<code class="literal">UnpackNormal()</code> function. Then, you only have to apply these new normals to the output of the Surface Shader:</p><div class="informalexample"><pre class="programlisting">// Get the normal data out of the normal map texture
// using the UnpackNormal function
float3 normalMap = UnpackNormal(tex2D(_NormalTex, IN.uv_NormalTex));

// Apply the new normal to the lighting model
o.Normal = normalMap.rgb;</pre></div></li></ol></div><p>The following image demonstrates the result of our normal map shader:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_02_08.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>Shaders can have both a texture map and normal map. It is not uncommon to use the same UV data to address both. However, it is possible to provide a secondary set of UVs in the vertex data (UV2) specifically used for the normal map.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec43"></a>How it works…</h3></div></div></div><p>The actual math to <a id="id117" class="indexterm"></a>perform the normal mapping effect is definitely beyond the scope of this chapter, but Unity has done it all for us already. It has created the functions for us so that we don't have to keep doing it over and over again. This is another reason why Surface Shaders are a really efficient way to write shaders.</p><p>If you look in the <code class="literal">UnityCG.cginc</code> file found in the <code class="literal">Data</code> folder in your Unity installation directory, you will find the definitions for the <code class="literal">UnpackNormal()</code> function. When you declare this function in your Surface Shader, Unity takes the provided normal map and processes it for you and gives you the correct type of data so that you can use it in your per-pixel lighting function. It's a huge time-saver! When sampling a texture, you get RGB values from 0 to 1; however, the directions of a normal vector range from -1 to +1. <code class="literal">UnpackNormal()</code> brings these components in the right range.</p><p>Once you have processed the normal map with the <code class="literal">UnpackNormal()</code> function, you send it back to your <code class="literal">SurfaceOutput</code> struct so that it can be used in the lighting function. This is done by <code class="literal">o.Normal = normalMap.rgb;</code>. We will see how the normal is actually used to calculate the final color of each pixel in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Understanding Lighting Models</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec44"></a>There's more…</h3></div></div></div><p>You can also add some controls to your normal map shader that lets a user adjust the intensity of the normal map. This is easily done by modifying the <code class="literal">x</code> and <code class="literal">y</code> components of the normal map variable and then adding it all back together. Add another property to the <code class="literal">Properties</code> block and name it <code class="literal">_NormalMapIntensity</code>:</p><div class="informalexample"><pre class="programlisting">_NormalMapIntensity("Normal intensity", Range(0,1)) = 1</pre></div><p>Multiply the <code class="literal">x</code> and <code class="literal">y</code> components of the unpacked normal map and reapply this value to the normal map variable:</p><div class="informalexample"><pre class="programlisting">fixed3 n = UnpackNormal(tex2D(_BumpTex, IN.uv_ uv_MainTex)).rgb;
n.x *= _NormalMapIntensity;
n.y *= _NormalMapIntensity;
o.Normal = normalize(n);</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>Normal vectors are supposed to have lengths equal to one. Multiplying them for <code class="literal">_NormalMapIntensity</code> changes their length, making normalization necessary.</p></div><p>Now, you can let a user adjust the intensity of the normal map in the material's <span class="strong"><strong>Inspector</strong></span> tab. The following image <a id="id118" class="indexterm"></a>shows the result of modifying the normal map with our scalar values:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_02_09.jpg" /></div></div></div>