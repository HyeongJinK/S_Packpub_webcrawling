<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec51"></a>Setting up the screen effects script system</h2></div></div><hr /></div><p>The <a id="id395" class="indexterm"></a>process of creating screen effects is one in which we grab a fullscreen image (or texture), use a shader to process its pixels on the GPU, and then send it back to Unity's renderer to apply it to the whole rendered image of the game. This allows us to perform per-pixel operations on the rendered image of the game in real time, giving us a more global artistic control.</p><p>Imagine if you had to go through and adjust each material on each object in your game to just adjust the contrast of the final look of your game. While not impossible, this would take a bit of labor to perform. By utilizing a screen effect, we can adjust the screen's final look as a whole, thereby giving us a more Photoshop-like control over our game's final appearance.</p><p>In order to get a <a id="id396" class="indexterm"></a>Screen effect system up and running, we have to set up a single script to act as the courier of the game's current rendered image or, what Unity calls, the Render Texture. By utilizing this script to pass the Render Texture to a shader, we can create a flexible system to create screen effects. For our first screen effect, we are going to create a very simple grayscale effect, where we can make our game look black and white. Let's take a look at how this is done.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec137"></a>Getting ready</h3></div></div></div><p>In order to get our Screen Effects system up and running, we need to create a few assets for our current Unity project. By doing this, we will set ourselves up for the steps in the following sections:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In the current project, we need to create a new C# script and call it <code class="literal">TestRenderImage.cs</code>.</p></li><li><p>Create a new shader and call it <code class="literal">ImageEffect.shader</code>.</p></li><li><p>Create a simple sphere in the scene and assign it a new material. This new material can be anything, but for our example, we will make a simple red, specular material.</p></li><li><p>Finally, create a new directional light and save the scene.</p></li></ol></div><p>With all of our assets ready, you should have a simple scene setup, which looks similar to the following image:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_01.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec138"></a>How to do it…</h3></div></div></div><p>In order to make our grayscale screen effect work, we need a script and shader. So, we will complete these two new items here and fill them in with the appropriate code to produce our first <a id="id397" class="indexterm"></a>screen effect. Our first task is to complete the C# script. This will get the whole system running. After this, we will complete the shader and see the results of our Screen Effect. Let's complete our script and shader with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the <code class="literal">TestRenderImage.cs</code> C# script and let's begin by entering a few variables that we will need to store important objects and data. Enter the following code at the very top of the <code class="literal">TestRenderImage</code> class:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_02.jpg" /></div></li><li><p>In order for us to edit the Screen Effect in real time, when the Unity editor isn't playing, we need to enter the following line of code just above the declaration of the <code class="literal">TestRenderImage</code> class:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_03.jpg" /></div></li><li><p>As our <a id="id398" class="indexterm"></a>Screen Effect is using a shader to perform the pixel operations on our Screen image, we have to create a material to run the shader. Without this, we can't access the properties of the shader. For this, we will create a C# property to check for a material, and create one if it doesn't find one. Enter the following code just after the declaration of the variables from step 1:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_04.jpg" /></div></li><li><p>We now want to set up some checks in our script to see if the current target platform that we are building the Unity game on actually supports image effects. If it doesn't find anything at the start of this script, then the script will disable itself:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_05.jpg" /></div></li><li><p>To actually grab the Rendered Image from the Unity Renderer, we need to make use of the <a id="id399" class="indexterm"></a>following built-in function that Unity provides us, called <code class="literal">OnRenderImage()</code>. Enter the following code so that we can have access to the current Render Texture:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_06.jpg" /></div></li><li><p>Our Screen effect has a variable called <code class="literal">grayScaleAmount</code> with which we can control how much grayscale we want for our final Screen Effect. So, in this case, we need to make the value go from 0 – 1, where 0 is no grayscale effect and 1 is full grayscale effect. We will perform this operation in the <code class="literal">Update()</code> function so that it sets every frame this script is running:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_07.jpg" /></div></li><li><p>Finally, we complete our script by doing a little bit of clean up on objects we created when the script started:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_08.jpg" /></div><p>At this point, we can now apply this script to the camera, if it compiled without errors, in Unity. Let's apply the <code class="literal">TestRenderImage.cs</code> script to our main <a id="id400" class="indexterm"></a>camera in our scene. You should see the <code class="literal">grayScaleAmount</code> value and a field for a shader, but the script throws an error to the console window. It says that it is missing an instance to an object and so won't process appropriately. If you recall from step 4, we are doing some checks to see whether we have a shader and the current platform supports the shader. As we haven't given the Screen Effect script a shader to work with, then the <code class="literal">curShader</code> variable is just null, which throws the error. Let's continue our Screen Effects system by completing the shader.</p></li><li><p>To begin our shader, we will populate our properties with some variables so that we can send data to this shader:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_09.jpg" /></div></li><li><p>Our shader is now going to utilize pure CG shader code instead of utilizing Unity's built-in Surface Shader code. This will make our Screen Effect more optimized as we need to work only with the pixels of the Render Texture. So, we will create a new <code class="literal">Pass</code> block in our shader and fill it with some new <code class="literal">#pragma</code> statements that we haven't seen before:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_10.jpg" /></div></li><li><p>In order to access the data being sent to the shader from the Unity editor, we need to <a id="id401" class="indexterm"></a>create the corresponding variables in our <code class="literal">CGPROGRAM</code>:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_11.jpg" /></div></li><li><p>Finally, all we need to do is set up our pixel function, in this case, called <code class="literal">frag()</code>. This is where the meat of the Screen Effect is. This function will process each pixel of the Render Texture and return a new image to our <code class="literal">TestRenderImage.cs</code> script:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_12.jpg" /></div></li></ol></div><p>Once the shader is complete, return to Unity and let it compile to see if any errors occurred. If not, assign the new shader to the <code class="literal">TestRenderImage.cs</code> script and change the value of the grayscale amount variable. You should see the game view go from a colored version of the game to a grayscale version of the game. The following image demonstrates this Screen Effect:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_13.jpg" /></div><p>With this <a id="id402" class="indexterm"></a>complete, we now have an easy way to test out new Screen Effect shaders without having to write our whole Screen Effect system over and over again. Let's dive in a little deeper and learn about what's going on with the Render Texture and how it is processed throughout its existence.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec139"></a>How it works…</h3></div></div></div><p>To get a screen effect up and running inside of Unity, we need to create a script and shader. The script drives the real-time update in the editor and is also responsible for capturing the Render Texture from the main camera and passing it to the shader. Once the render texture gets to the shader, we can use the shader to perform per-pixel operations.</p><p>At the start of the script, we perform a few checks to make sure that the current selected build platform actually supports screen effects and the shader itself. There are instances where a current platform will not support Screen Effects or the shader that we are using. So the checks that we do in the <code class="literal">Start()</code> function make sure we don't get any errors if the platform doesn't support the screen system.</p><p>Once the script passes these checks, we initiate the Screen Effects system by calling the built-in function, <code class="literal">OnRenderImage()</code>. This function is responsible for grabbing the renderTexture, giving it to the shader using the <code class="literal">Graphics.Blit()</code> function, and returning the processed image to the Unity renderer. You can find more information on these two functions at the following URLs:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>OnRenderImage:</strong></span>
<a id="id403" class="indexterm"></a>
<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html</a>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Graphics.Blit:</strong></span>
<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html</a>
</p></li></ul></div><p>Once the current <a id="id404" class="indexterm"></a>render texture reaches the shader, the shader takes it, processes it through the <code class="literal">frag()</code> function, and returns the final color for each pixel.</p><p>You can see how powerful this becomes as it gives us Photoshop-like control over the final rendered image of our game. These screen effects work sequentially like Photoshop layers in the camera. When you place these screen effects one after the other, they will be processed in that order. These are just the bare bones steps to get a screen effect working, but it <a id="id405" class="indexterm"></a>is the core of how the screen effects system works.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec140"></a>There's more…</h3></div></div></div><p>Now that we have our simple Screen Effect system up and running, let's take a look at some of the other useful information we can obtain from Unity's renderer:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_43.jpg" /></div><p>We can actually get the depth of everything in our current game by turning on Unity's built-in Depth mode. Once this is turned on, we can use the depth information for a ton of different effects. Let's take a look at how this is done:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new shader and call it <code class="literal">SceneDepth_Effect</code>. Then double-click on this shader to open it in the <span class="strong"><strong>MonoDevelop</strong></span> editor.</p></li><li><p>We will create the Main Texture property and a property to control the power of the scene depth effect. Enter the following code in your shader:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_44.jpg" /></div></li><li><p>Now we need to create the corresponding variables in our <code class="literal">CGPROGRAM</code>. We are going to add one more variable called <code class="literal">_CameraDepthTexture</code>. This is a built-in variable <a id="id406" class="indexterm"></a>that Unity has provided us with through the use of the UnityCG <code class="literal">cginclude</code> file. It gives us the depth information from the camera:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_45.jpg" /></div></li><li><p>We will complete our depth shader by utilizing a couple of built-in functions that Unity provides us with, the <code class="literal">UNITY_SAMPLE_DEPTH()</code> and <code class="literal">linear01Depth()</code> functions. The first function actually gets the depth information from our _<code class="literal">CameraDepthTexture</code> and produces a single float value for each pixel. The <code class="literal">Linear01Depth()</code> function then makes sure that the values are within the 0-1 range by taking this final depth value to a power we can control, where the mid-value on the 0-1 range sits in the scene based off of the camera position:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_46.jpg" /></div></li><li><p>With our shader complete, let's turn our attention to our Screen Effects script. We <a id="id407" class="indexterm"></a>need to add the <code class="literal">depthPower</code> variable to the script so that we can let users change the value in the editor:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_47.jpg" /></div></li><li><p>Our <code class="literal">OnRenderImage()</code> function then needs to be updated so that it is passing the right value to our shader:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_48.jpg" /></div></li><li><p>To complete our depth Screen effect, we need to tell Unity to turn on the depth rendering in the current camera. This is done by simply setting the main camera's <code class="literal">depthTextureMode</code>:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_49.jpg" /></div></li></ol></div><p>With all the code set up, save your script and shader and return to Unity to let them both compile. If no errors <a id="id408" class="indexterm"></a>are encountered, you should see a result similar to the following image:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_10_50.jpg" /></div></div></div>