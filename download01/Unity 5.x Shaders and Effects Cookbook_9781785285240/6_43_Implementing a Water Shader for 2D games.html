<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec45"></a>Implementing a Water Shader for 2D games</h2></div></div><hr /></div><p>The Glass <a id="id350" class="indexterm"></a>Shader introduced in the previous recipe is <a id="id351" class="indexterm"></a>static; its distortion never changes. It takes just a few changes to convert it to an animated material, making it perfect for 2D games, which feature water. This recipe uses a similar technique to the one shown in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Animating Vertices in a Surface Shader</em></span>:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_06_03.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec124"></a>Getting ready</h3></div></div></div><p>This recipe is based on the Vertex and Fragment Shaders described in the <span class="emphasis"><em>Using grab pass</em></span> recipe as it will rely heavily on grab pass.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new grab pass shader; you can write your own or start with the one presented in the <span class="emphasis"><em>Using grab pass</em></span> recipe.</p></li><li><p>Create a new material for your shader.</p></li><li><p>Assign the material to a flat geometry that will represent your 2D water. In order for this effect to work, you should have something rendered behind it so that you can see the water-like displacement.</p></li><li><p>This recipe requires a noise texture, which is used to get pseudo-random values. It is important that you choose a seamless noise texture, such as the ones generated by tileable 2D Perlin noise, as shown in the following image. This ensures that when the material is applied to a large object, you will not see any discontinuity. In order for this effect to work, the texture has to be imported in the <a id="id352" class="indexterm"></a>
<span class="strong"><strong>Repeat</strong></span> mode. If you want a smooth and continuous look for your water, you should also set it to <span class="strong"><strong>Bilinear</strong></span> from <span class="strong"><strong>Inspector</strong></span>. These settings ensure that the texture is sampled correctly from the shader:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_06_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec125"></a>How to do it…</h3></div></div></div><p>To create this <a id="id353" class="indexterm"></a>animated effect, you can start by <a id="id354" class="indexterm"></a>refitting the shader. Follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following properties:</p><div class="informalexample"><pre class="programlisting">_NoiseTex("Noise text", 2D) = "white" {}
_Colour ("Colour", Color) = (1,1,1,1)

_Period ("Period", Range(0,50)) = 1
_Magnitude ("Magnitude", Range(0,0.5)) = 0.05
_Scale ("Scale", Range(0,10)) = 1</pre></div></li><li><p>Add their respective variables to the second pass of the shader:</p><div class="informalexample"><pre class="programlisting">sampler2D _NoiseTex;    
fixed4 _Colour;

float _Period;
float _Magnitude;
float _Scale;</pre></div></li><li><p>Define the following output structure for the vertex function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>struct</strong></span> vertInput {
    float4 vertex : POSITION;
    fixed4 color : COLOR;
    float2 texcoord : TEXCOORD0;

    float4 worldPos : TEXCOORD1;
    float4 uvgrab : TEXCOORD2;
};</pre></div></li><li><p>This shader <a id="id355" class="indexterm"></a>needs to know the exact position of the space of every fragment. To do this, add the following line to the vertex function:</p><div class="informalexample"><pre class="programlisting">o.worldPos = mul(_Object2World, v.vertex);</pre></div></li><li><p>Use the following fragment function:</p><div class="informalexample"><pre class="programlisting">fixed4 frag (vertInput i) : COLOR {
        float sinT = sin(_Time.w / _Period);
    float2 distortion = float2(
 tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(sinT, 0) ).r - 0.5,
     tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(0, sinT) ).r - 0.5
    );

    i.uvgrab.xy += distortion * _Magnitude;

    fixed4 col = tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(i.uvgrab));
    return col * _Colour;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec126"></a>How it works…</h3></div></div></div><p>This shader is very similar to the one introduced in the <span class="emphasis"><em>Implementing a Glass Shader</em></span> recipe. The major difference is that this is an animated material; the displacement is not generated from a normal map but takes into account the current time in order to create a constant animation. The code that displaces the UV data of the grab texture seems quite complicated; let's try to understand how it has been generated. The idea behind it is that a sinusoid function is used to make the water oscillate. This effect needs to evolve over time; to achieve this effect, the distortion generated by the shader depends on the current time that is retrieved with the built-in variable, <code class="literal">_Time</code>. The <code class="literal">_Period</code> variable determines the period of the sinusoid, which means how fast the waves appear:</p><div class="informalexample"><pre class="programlisting">float2 distortion = float2( sin(_Time.w/_Period), sin(_Time.w/_Period) ) – 0.5;</pre></div><p>The problem with this code is that you have the same displacement on the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> axes; as a result, the entire grab texture will rotate in a circular motion, which looks nothing like water. We obviously need to add some randomness to this.</p><p>The most common way to add random behaviors to shaders is by including a noise texture. The problem now is to find a way to sample the texture at seemingly random positions. The best way to avoid <a id="id356" class="indexterm"></a>seeing an obvious sinusoid pattern is to <a id="id357" class="indexterm"></a>use the sine waves as an offset in the UV data of the noise texture:</p><div class="informalexample"><pre class="programlisting">float sinT = sin(_Time.w / _Period);
float2 distortion = float2
(    tex2D(_NoiseTex, i.texcoord / _Scale + float2(sinT, 0) ).r - 0.5,
    tex2D(_NoiseTex, i.texcoord / _Scale + float2(0, sinT) ).r - 0.5
);</pre></div><p>The <code class="literal">_Scale</code> variable determines the size of the waves. This solution is closer to the final version, but has a severe issue—if the water quad moves, the UV data follows it and you can see the water waves following the material rather than being anchored to the background. To solve this, we need to use the world position of the current fragment as the initial position for the UV data:</p><div class="informalexample"><pre class="programlisting">float sinT = sin(_Time.w / _Period);
float2 distortion = float2
(    tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(sinT, 0) ).r - 0.5,
    tex2D(_NoiseTex, i.worldPos.xy / _Scale + float2(0, sinT) ).r - 0.5
);
i.uvgrab.xy += distortion * _Magnitude;</pre></div><p>The result is a <a id="id358" class="indexterm"></a>pleasant, seamless distortion, which doesn't move in any clear direction.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note27"></a>Note</h3><p>As it happens <a id="id359" class="indexterm"></a>with all these special effects, there is no perfect solution. This recipe shows you a technique to create water-like distortion, but you are encouraged to play with it until you find an effect that fits the aesthetics of your game.</p></div></div></div>