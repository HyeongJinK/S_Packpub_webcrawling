<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec48"></a>Profiling your shaders</h2></div></div><hr /></div><p>Now that we know <a id="id372" class="indexterm"></a>how we can reduce the overhead that our shaders might take, let's take a look at how to find problematic shaders in a scene where you might have a lot of shaders or a ton of objects, shaders, and scripts, all running at the same time. To find a single object or shader among a whole game can be quite daunting, but Unity provides us with its built-in Profiler. This allows us to actually see, on a frame-by-frame basis, what is happening in the game and each item being used by the GPU and CPU.</p><p>Using the Profiler, we can isolate items such as shaders, geometry, and general rendering items using its interface to create blocks of profiling jobs. We can filter out items till we are looking at the performance of just a single object. This then lets us see the effects on the CPU and GPU that the object has while it is performing its functions at runtime.</p><p>Let's take a look through the different sections of the Profiler and learn how to debug our scenes and, most importantly, our shaders.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec130"></a>Getting ready</h3></div></div></div><p>Let's use our Profiler by <a id="id373" class="indexterm"></a>getting a few assets ready and launching the Profiler window:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's use the scene from the last recipe and launch the Unity Profiler from <span class="strong"><strong>Window</strong></span>|<span class="strong"><strong>Profiler</strong></span> or <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>7</em></span>.</p></li><li><p>Let's also duplicate our sphere a couple more times to see how that affects our rendering.</p></li></ol></div><p>You should see something similar to the following image:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_11.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec131"></a>How to do it…</h3></div></div></div><p>To use the Profiler, we <a id="id374" class="indexterm"></a>will take a look at some of the UI elements of this window. Before we hit play, let's take a look at how to get the information we need <a id="id375" class="indexterm"></a>from the profiler:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, click on the larger blocks in the <span class="strong"><strong>Profiler</strong></span> window called <span class="strong"><strong>GPU Usage</strong></span>, <span class="strong"><strong>CPU Usage</strong></span>, and <span class="strong"><strong>Rendering</strong></span>. You will find these blocks on the left-hand side of the upper window:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_12.jpg" /></div><p>Using these blocks, we can see different data specific to those major functions of our <a id="id376" class="indexterm"></a>game. The <span class="strong"><strong>CPU Usage</strong></span> is showing us what most of our scripts are doing as well as physics and overall rendering. The <span class="strong"><strong>GPU Usage</strong></span> block is giving us detailed information about the elements that are specific to our lighting, shadows, and render queues. Finally, the <a id="id377" class="indexterm"></a>
<span class="strong"><strong>Rendering</strong></span> block is giving us information about the drawcalls and amount of geometry we have in our scene at any one frame.</p><p>By clicking on each of these blocks, we can isolate the type of data we see during our profiling session.</p></li><li><p>Now, click on the tiny colored blocks in one of these <span class="strong"><strong>Profile</strong></span> blocks and hit play or <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>P</em></span> to run the scene.</p><p>This lets us dive down even deeper into our profiling session so that we can filter out what is being reported back for us. While the scene is running, uncheck all of the boxes, except for <span class="strong"><strong>Opaque</strong></span> in the <span class="strong"><strong>GPU Usage</strong></span> block. Notice that we can now see just how much time is being used to render the objects that are set to the Render Queue of Opaque:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_13.jpg" /></div></li><li><p>Another great function of the <span class="strong"><strong>Profiler</strong></span> window is the action of clicking and dragging in the graph view. This will automatically pause your game so that you can <a id="id378" class="indexterm"></a>further analyze a certain spike in the graph to <a id="id379" class="indexterm"></a>find out exactly which item is causing the performance problem. Click and drag around in the graph view to pause the game and see the effect of using this functionality:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_14.jpg" /></div></li><li><p>Turning our attention now towards the lower half of the <span class="strong"><strong>Profiler</strong></span> window, you will notice that there is a drop-down item available when we have the GPU Block selected. We can expand this to get even more detailed information about the current active profiling session and, in this case, more information about what the camera is currently rendering and how much time it is taking up:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_15.jpg" /></div><p>This gives us a complete look at the inner workings of what Unity is processing in this particular frame. In this case, we can see that our three spheres with our <a id="id380" class="indexterm"></a>optimized shader are taking roughly 0.14 milliseconds to draw to the screen, they are taking up seven drawcalls, and this process is taking 3.1 percent of the GPU's time in every frame. It's <a id="id381" class="indexterm"></a>this type of information we can use to diagnose and solve performance issues with regard to shaders. Let's conduct a test to see the effects of adding one more texture to our shader and blending two diffuse textures together using a <code class="literal">lerp</code> function. You will see the effects in the profiler pretty clearly.</p></li><li><p>Modify the <code class="literal">Properties</code> block of your shader with the following code to give us another texture to use:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_16.jpg" /></div></li><li><p>Then let's feed our texture to <code class="literal">CGPROGRAM</code>:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_17.jpg" /></div></li><li><p>Now it's <a id="id382" class="indexterm"></a>time to update our <code class="literal">surf() </code>function accordingly so that we blend our texture diffuse textures together:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_18.jpg" /></div></li></ol></div><p>Once you save your <a id="id383" class="indexterm"></a>modifications in your shader and return to Unity's editor, we can run our game and see the increase in milliseconds of our new shader. Press play once you have returned to Unity and let's take a look at the results in our <span class="strong"><strong>profiler</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_19.jpg" /></div><p>You can see now that the amount of time to render our Opaque Shaders in this scene is taking <span class="strong"><strong>0.179</strong></span> milliseconds, up from 0.140 milliseconds. By adding another texture and using the <code class="literal">lerp()</code> function, we increased the render time for our spheres. While it's a small change, imagine <a id="id384" class="indexterm"></a>having 20 shaders all working in different ways on different objects.</p><p>Using the information <a id="id385" class="indexterm"></a>given here, you can pinpoint areas that are causing performance decreases more quickly and solve these issues using the techniques from the previous recipe.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec132"></a>How it works…</h3></div></div></div><p>While it's completely out of scope of this book to describe how this tool actually works internally, we can surmise that Unity has given us a way to view the computer's performance while our game is running. Basically, this window is tied very tightly to the CPU and GPU to give us real-time feedback of how much time is being taken for each of our scripts, objects, and render queues. Using this information, we have seen that we can track the efficiency of our shader writing to eliminate problematic areas and code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec133"></a>There's more…</h3></div></div></div><p>It is also possible to profile specifically for mobile platforms. Unity provides us with a couple of extra features when the Android or IOS build target is set in the Build Settings. We can actually get real-time information from our mobile devices while the game is running. This becomes very useful because you are able to profile directly on the device itself instead of <a id="id386" class="indexterm"></a>profiling directly in your editor. To find out more about this process, refer to <a id="id387" class="indexterm"></a>Unity's documentation at the following link:</p><p>
<a class="ulink" href="http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html" target="_blank">http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html</a>
</p></div></div>