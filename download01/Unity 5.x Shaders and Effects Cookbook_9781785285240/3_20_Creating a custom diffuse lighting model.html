<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec25"></a>Creating a custom diffuse lighting model</h2></div></div><hr /></div><p>If you <a id="id158" class="indexterm"></a>are familiar with Unity 4, you may know that the default shader it provided was based on a lighting model called Lambertian reflectance. This <a id="id159" class="indexterm"></a>recipe will show you how it is possible to create a shader with a custom lighting model and explain the mathematics and implementation behind it. The following image shows the same geometry rendered with a Standard Shader (right) and diffuse Lambert one (left):</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_03_01.jpg" /></div><p>Shaders based on the Lambertian reflectance are classified as non-photorealistic; no object in the real world really looks like this. However, Lambert Shaders are still often used in low poly games as they produce a neat contrast between the faces of complex geometries. The lighting model used to calculate the Lambertian reflectance is also very efficient, making it perfect for mobile games.</p><p>Unity has already provided us with a lighting function that we can use for our shaders. It is called the Lambertian lighting model. It is one of the more basic and efficient forms of reflectance, which you can find in a lot of games even today. As it is already built in the Unity Surface Shader language, we thought it is best to start with this first and build on it. You can also find an example in the Unity reference manual, but we will go into more depth with it and explain where the data is coming from and why it is working the way it is. This will help you get a nice grounding in setting up custom lighting models so that we can build on this knowledge in the future recipes in this chapter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec59"></a>Getting ready</h3></div></div></div><p>Let's start by carrying out the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new shader and give it a name.</p></li><li><p>Create a new material, give it a name, and assign the new shader to its shader property.</p></li><li><p>Then, create a sphere object and place it roughly in the center of the scene.</p></li><li><p>Finally, let's create a directional light to cast some light on our object.</p></li></ol></div><p>When your assets <a id="id160" class="indexterm"></a>have been set up in Unity, you should have a scene that resembles the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_03_31.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec60"></a>How to do it…</h3></div></div></div><p>The Lambertian reflectance <a id="id161" class="indexterm"></a>can be achieved with the following changes to the shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Begin by adding the following properties to the shader's <code class="literal">Properties</code> block:</p><div class="informalexample"><pre class="programlisting">_MainTex("Texture", 2D) = "white"</pre></div></li><li><p>Change the <code class="literal">#pragma</code> directive of the shader so that, instead of <code class="literal">Standard</code>, it uses our custom lighting model:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#pragma</strong></span> surface surf SimpleLambert</pre></div></li><li><p>Use a very simple surface function, which just samples the texture according to its UV data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> surf(Input IN, inout SurfaceOutput o) {
  o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;
}</pre></div></li><li><p>Add a function called <code class="literal">LightingSimpleLambert()</code> that will contain the following code for the Lambertian reflectance:</p><div class="informalexample"><pre class="programlisting">half4 LightingSimpleLambert (SurfaceOutput s, half3 lightDir, half atten) {
  half NdotL = dot (s.Normal, lightDir);
  half4 c;
  c.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten * 1);
  c.a = s.Alpha;
  return c;
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec61"></a>How it works…</h3></div></div></div><p>As previously seen in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Creating Your First Shader</em></span>, the <code class="literal">#pragma</code> directive is used to specify which surface function to use. Choosing a different lighting model works in a similar fashion: <code class="literal">SimpleLambert</code> forces Cg to look for a function called <code class="literal">LightingSimpleLambert()</code>. Note <code class="literal">Lighting</code> at the beginning, which is omitted in the directive.</p><p>The lighting function takes three parameters: the <span class="emphasis"><em>surface output</em></span> (which contains the physical properties such as the albedo and transparency), the <span class="emphasis"><em>direction</em></span> the light is coming from, and its <span class="emphasis"><em>attenuation</em></span>.</p><p>According to the <a id="id162" class="indexterm"></a>Lambertian reflectance, the amount of light a <a id="id163" class="indexterm"></a>surface reflects depends on the angle between the incident light and surface normal. If you have played pool billiards, you are surely familiar with this concept; the direction of a ball depends on its incident angle against the wall. If you hit a wall at a 90 degree angle, the ball will come back at you; if you hit it with a very low angle, its direction will be mostly unchanged. The Lambertian model makes the same assumption; if the light hits a triangle with a 90 degree angle, all the light gets reflected back. The lower the angle, the less light is reflected back to you. This concept is shown in the following image:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_03_02.jpg" /></div><p>This simple concept has to be translated into a mathematical form. In vector algebra, the angle between two unit <a id="id164" class="indexterm"></a>vectors can be calculated via an operator called <span class="strong"><strong>dot product</strong></span>. When the dot product is equal to zero, two vectors are orthogonal, which means that they make a 90 degree angle. When it is equal to one (or minus one), they are parallel to each other. Cg has a function called <code class="literal">dot()</code>, which implements the dot product extremely efficiently.</p><p>The following picture shows a light source (sun) shining on a complex surface. <span class="strong"><strong>L</strong></span> indicates the light direction (called <code class="literal">lightDir</code> in the shader) and <span class="strong"><strong>N</strong></span> is the normal to the surface. The <a id="id165" class="indexterm"></a>light is reflected with the same angle that it hits the surface:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_03_03.jpg" /></div><p>The Lambertian <a id="id166" class="indexterm"></a>reflectance simply uses the <code class="literal">NdotL</code> dot product as a multiplicative coefficient for the intensity of light:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_03_17.jpg" /></div><p>When <span class="emphasis"><em>N</em></span> and <span class="emphasis"><em>L</em></span> are parallel, all the light is reflected back to the source, causing the geometry to appear brighter. The <code class="literal">_LightColor0</code> variable contains the color of the light that is calculated.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"></a>Note</h3><p>Prior to Unity 5, the intensity of the lights were different. If you are using an old Diffuse shader based on the Lambertian model, you may notice that <code class="literal">NdotL</code> was multiplied by two:<code class="literal">(NdotL * atten * 2)</code> rather than <code class="literal">(NdotL * atten)</code>. If you are importing a custom shader from Unity 4, you will need to correct this manually. Legacy Shaders, however, have already been designed taking this aspect into account.</p></div><p>When the dot product is negative, the light is coming from the opposite side of the triangle. This is not a problem for opaque geometries as triangles that are not facing the camera frontally are <span class="emphasis"><em>culled</em></span> (discarded) and not rendered.</p><p>This basic Lambert is a great starting point when you are prototyping your shaders as you can get a lot accomplished in terms of writing the core functionality of the shader while not having to worry about the basic lighting functions.</p><p>Unity has provided us with a lighting model that has already taken the task of creating a Lambert lighting for you. If you look at the <code class="literal">UnityCG.cginc</code> file found in your Unity's installation directory under the <code class="literal">Data</code> folder, you will notice that you have Lambert and BlinnPhong <a id="id167" class="indexterm"></a>lighting models available for you to use. The moment <a id="id168" class="indexterm"></a>you compile your shader with <code class="literal">#pragma surface surf Lambert</code>, you are telling the shader to utilize Unity's implementation of the Lambert lighting function in the <code class="literal">UnityCG.cginc</code> file so that we don't have to write that code over and over again. We will explore how the BlinnPhong model works later in this chapter.</p></div></div>