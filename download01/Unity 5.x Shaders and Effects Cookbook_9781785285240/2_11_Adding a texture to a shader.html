<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Adding a texture to a shader</h2></div></div><hr /></div><p>Textures can <a id="id86" class="indexterm"></a>bring our shaders to life very quickly in terms of achieving <a id="id87" class="indexterm"></a>very realistic effects. In order to effectively use textures, we need to understand how a 2D image is mapped to a 3D model. This process is called <a id="id88" class="indexterm"></a>
<span class="strong"><strong>texture mapping</strong></span>, and it requires some work to be done on the shader and 3D model that we want to use. Models, in fact, are made out of triangles; each vertex can store data that shaders can access. One of the most important information stored <a id="id89" class="indexterm"></a>in vertices is the <span class="strong"><strong>UV data</strong></span>. It consists of two coordinates, <span class="emphasis"><em>U</em></span> and <span class="emphasis"><em>V</em></span>, ranging from 0 to 1. They represent the <span class="emphasis"><em>XY</em></span> position of the pixel in the 2D image that will be mapped to the vertices. UV data is present only for vertices; when the inner points of a triangle have to be texture-mapped, the GPU interpolates the closest UV values to find the right pixel in the texture to be used. The following image shows you how a 2D texture is mapped to a triangle from a 3D model:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_02_02.jpg" /></div><p>The UV data is stored in the 3D model and requires a modeling software to be edited. Some models lack the UV component, hence they cannot support texture mapping. The Stanford bunny, for example, was not originally provided with one.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec33"></a>Getting ready</h3></div></div></div><p>For this recipe, you'll <a id="id90" class="indexterm"></a>need a 3D model with UV data and its texture. They <a id="id91" class="indexterm"></a>both need to be imported to Unity before starting. You can do this simply by dragging them to the editor. As the Standard Shader supports texture mapping by default, we'll use this and then explain in detail how it works.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec34"></a>How to do it...</h3></div></div></div><p>Adding a texture to your model using the Standard Shader is incredibly simple, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new Standard Shader called <code class="literal">TexturedShader</code>.</p></li><li><p>Create a new material called <code class="literal">TexturedMaterial</code>.</p></li><li><p>Assign the shader to the material by dragging over it.</p></li><li><p>After selecting the material, drag your texture to the empty rectangle called <span class="strong"><strong>Albedo (RGB)</strong></span>. If you have followed all these steps correctly, your material <span class="strong"><strong>Inspector</strong></span> tab should look like this:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_02_03.jpg" /></div></li></ol></div><p>The Standard Shader knows how to map a 2D image to a 3D model using its UV data.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec35"></a>How it worksâ€¦</h3></div></div></div><p>When the Standard <a id="id92" class="indexterm"></a>Shader is used from the inspector of a material, the <a id="id93" class="indexterm"></a>process behind texture mapping is completely transparent to developers. If we want to understand how it works, it's necessary to take a closer look at <code class="literal">TexturedShader</code>. From the <code class="literal">Properties</code> section, we can see that the <code class="literal">Albedo (RGB)</code> texture is actually referred to in the code as <code class="literal">_MainTex</code>:</p><div class="informalexample"><pre class="programlisting">_MainTex ("Albedo (RGB)", 2D) = "white" {}</pre></div><p>In the <code class="literal">CGPROGRAM</code> section, this texture is defined as <code class="literal">sampler2D</code>, the standard type for 2D textures:</p><div class="informalexample"><pre class="programlisting">sampler2D _MainTex;</pre></div><p>The next line shows a struct called <code class="literal">Input</code>. This is the input parameter for the surface function and contains a packed array called <code class="literal">uv_MainTex</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>struct</strong></span> Input {
  float2 uv_MainTex;
};</pre></div><p>Every time the <code class="literal">surf()</code>surface function is called, the <code class="literal">Input</code> structure will contain the UV of <code class="literal">_MainTex</code> for the specific point of the 3D model that needs to be rendered. The Standard Shader recognizes that the name <code class="literal">uv_MainTex</code> refers to <code class="literal">_MainTex</code> and initializes it automatically. If you are interested in understanding how the UV is actually mapped from a 3D space to a 2D texture, you can check <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Understanding Lighting Models</em></span>.</p><p>Finally, the UV data is used to sample the texture in the first line of the surface function:</p><div class="informalexample"><pre class="programlisting">fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</pre></div><p>This is done using the <code class="literal">tex2D()</code> function of Cg; it takes a texture and UV and returns the color of the pixel at that position.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"></a>Note</h3><p>The <span class="emphasis"><em>U</em></span> and <span class="emphasis"><em>V</em></span> coordinates go from 0 to 1, where (0,0) and (1,1) correspond to two opposite corners. Different implementations associate UV with different corners; if your texture happens to appear reversed, try inverting the V component.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec36"></a>There's more...</h3></div></div></div><p>When you import a <a id="id94" class="indexterm"></a>texture to Unity, you are setting up some of the properties <a id="id95" class="indexterm"></a>that <code class="literal">sampler2D</code> will use. The most important is the <span class="strong"><strong>Filter</strong></span> mode, which determines how colors are interpolated when the texture is sampled. It is very unlikely that the UV data will point exactly to the center of a pixel; in all the other cases, you might want to interpolate between the closest pixels to get a more uniform color. The following is the screenshot of the <span class="strong"><strong>Inspector</strong></span> tab of an example texture:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_02_04.jpg" /></div><p>For most applications, <span class="strong"><strong>Bilinear</strong></span> provides an inexpensive yet effective way to smooth the texture. If you are <a id="id96" class="indexterm"></a>creating a 2D game, however, <span class="strong"><strong>Bilinear</strong></span> might <a id="id97" class="indexterm"></a>produce blurred tiles. In this case, you can use <span class="strong"><strong>Point</strong></span> to remove any interpolation from the texture sampling.</p><p>When a texture is seen from a steep angle, texture sampling is likely to produce visually unpleasant artifacts. You can reduce them by setting <span class="strong"><strong>Aniso Level</strong></span> to a higher value. This is particular useful for floor and ceiling textures, where glitches can break the illusion of continuity.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec37"></a>See also</h3></div></div></div><p>If you would like to <a id="id98" class="indexterm"></a>know more about the inner working of how <a id="id99" class="indexterm"></a>textures are mapped to a 3D surface, you can read the <a id="id100" class="indexterm"></a>information available at <a class="ulink" href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html" target="_blank">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter03.html</a>.</p><p>For a complete list of the options <a id="id101" class="indexterm"></a>available when importing a 2D texture, you can refer to the following website:</p><p>
<a class="ulink" href="http://docs.unity3d.com/Manual/class-TextureImporter.html" target="_blank">http://docs.unity3d.com/Manual/class-TextureImporter.html</a>
</p></div></div>