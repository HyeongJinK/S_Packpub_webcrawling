<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec49"></a>Modifying our shaders for mobile</h2></div></div><hr /></div><p>Now that we have <a id="id388" class="indexterm"></a>seen quite a broad set of techniques to make really optimized shaders, let's take a look at writing a nice, high-quality shader targeted for a mobile device. It is actually quite easy to make a few adjustments to the shaders we have written so that they run faster on a mobile device. This includes elements such as using the <code class="literal">approxview</code> or <code class="literal">halfasview</code> lighting function variables. We can also reduce the amount of textures we need and even apply better compression for the textures we are using. By the end of this recipe, we will have a nicely optimized normal-mapped, Specular shader for use in our mobile games.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec134"></a>Getting ready</h3></div></div></div><p>Before we begin, let's get a fresh new scene and fill it with some objects to apply our Mobile shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene and fill it with a default sphere and single directional light.</p></li><li><p>Create a new material and shader, and assign the shader to the material.</p></li><li><p>Finally, assign the material to our sphere object in our scene.</p></li></ol></div><p>When completed, you should have a scene similar to the one in the following image:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_20.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec135"></a>How to do it…</h3></div></div></div><p>For this recipe, we will write a mobile-friendly shader from scratch and discuss the elements that make it more mobile-friendly:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's first populate our <code class="literal">Properties</code> block with the needed textures. In this case, we are <a id="id389" class="indexterm"></a>going to use a single <code class="literal">Diffuse</code> texture with the gloss map in its alpha channel, normal map, and slider for specular intensity:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_21.jpg" /></div></li><li><p>Our next task is to set up our <code class="literal">#pragma </code>declarations. This will simply turn certain features of the Surface Shader on and off, ultimately making the shader cheaper or more expensive:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_22.jpg" /></div></li><li><p>We then need to make the connection between our <code class="literal">Properties</code> block and <code class="literal">CGPROGRAM</code>. This time, we are going to use the fixed variable type for our specular intensity slider to reduce its memory usage:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_23.jpg" /></div></li><li><p>In order for us to map our textures to the surface of our object, we need to get some UVs. In this case, we are going to get only one set of UVs to keep the amount of data in our shader down to a minimum:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_24.jpg" /></div></li><li><p>The next step is to fill in our lighting function using a few new input variables that <a id="id390" class="indexterm"></a>are available to us using the new <code class="literal">#pragma </code>declarations:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_25.jpg" /></div></li><li><p>Finally, we complete the shader by creating the <code class="literal">surf()</code> function and processing the final color of our surface:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_26.jpg" /></div></li></ol></div><p>When completed with the code portion of this recipe, save your shader and return to the Unity editor to let the shader compile. If no errors occurred, you should see a result similar to the following image:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_27.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec136"></a>How it works…</h3></div></div></div><p>So, let's begin the description of this shader by explaining what it does and doesn't do. First, it excludes the deferred lighting pass. This means that if you created a lighting function that was connected to the deferred renderer's prepass, it wouldn't use that particular lighting function and would look for the default lighting function like the ones that we have been creating thus far in this book.</p><p>This particular shader <a id="id391" class="indexterm"></a>does not support <span class="strong"><strong>Lightmapping</strong></span> by Unity's internal light-mapping <a id="id392" class="indexterm"></a>system. This just keeps the shader from trying to find light maps for the object that the shader is attached to, making the shader more performance friendly because it is not having to perform the lightmapping check.</p><p>We included the <code class="literal">noforwardadd </code>declaration so that we process only per-pixel textures with a single directional light. All other lights are forced to become per-vertex lights and will not be included in any per-pixel operations you might do in the <code class="literal">surf()</code> function.</p><p>Finally, we are using the <code class="literal">halfasview </code>declaration to tell Unity that we aren't going to use the main <code class="literal">viewDir</code> parameter found in a normal lighting function. Instead, we are going to use the half vector as the view direction and process our specular with this. This becomes much faster for the shader to process as it will be done on a per-vertex basis. It isn't completely accurate when it comes to simulating specular in the real world, but visually on a mobile device, it looks just fine and the shader is more optimized.</p><p>Its techniques like these that make a shader more efficient and cleaner, codewise. Always make sure that you are using only the data you need while weighing this against your target hardware and the visual quality that the game requires. In the end, it becomes a cocktail of these <a id="id393" class="indexterm"></a>techniques that ultimately make up your shaders for your games.</p></div></div>