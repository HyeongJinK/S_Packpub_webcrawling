<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec40"></a>Implementing a volumetric explosion</h2></div></div><hr /></div><p>The art of <a id="id302" class="indexterm"></a>game development is a clever trade-off between realism and efficiency. This is particularly true for explosions; they are at the heart of many games, yet the physics behind them is often beyond the computational power of modern machines. Explosions are, essentially, nothing more than very hot balls of gas; hence, the only way to correctly simulate them is by integrating a fluid simulation into your game. As you can imagine, this is infeasible for runtime application, and many games simulate them simply with particles. When an object explodes, it is common to simply instantiate many fire, smoke, and debris particles that, together, can achieve believable results. This approach, unfortunately, is not very realistic and is easy to spot. There is an intermediate technique that can be used to achieve a much more realistic effect: <span class="strong"><strong>volumetric explosions</strong></span>. The <a id="id303" class="indexterm"></a>idea behind this concept is that explosions are not treated any more like a bunch of particles; they are evolving 3D objects, not just flat 2D textures.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec106"></a>Getting ready</h3></div></div></div><p>Start this recipe with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new shader for this effect.</p></li><li><p>Create a new material to host the shader.</p></li><li><p>Attach the material to a sphere. You can create one directly from the editor, navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Sphere</strong></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"></a>Note</h3><p>This recipe <a id="id304" class="indexterm"></a>works well with the standard Unity Sphere, but if you need big explosions, you might need to use a more high-poly sphere. In fact, a vertex function can only modify the vertices of a mesh. All the other points will be interpolated using the positions of the nearby vertices. Fewer vertices mean a lower resolution for your explosions.</p></div></li><li><p>For this recipe, you will also need a ramp texture that has, in a gradient, all the colors your explosions will have. You can create a texture like the following image <a id="id305" class="indexterm"></a>using <span class="strong"><strong>GIMP</strong></span> <a id="id306" class="indexterm"></a>or <span class="strong"><strong>Photoshop</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_05_08.jpg" /></div></li><li><p>Once you have the picture, import it to Unity. Then, from its <span class="strong"><strong>Inspector</strong></span>, make sure that <span class="strong"><strong>Filter Mode</strong></span> is set to <span class="strong"><strong>Bilinear</strong></span> and <span class="strong"><strong>Wrap Mode</strong></span> to <span class="strong"><strong>Clamp</strong></span>. These two settings make sure that the ramp texture is sampled smoothly.</p></li><li><p>Lastly, you will need a noisy texture. You can search on the Internet for freely available <span class="strong"><strong>noise </strong></span>
<a id="id307" class="indexterm"></a>
<span class="strong"><strong>textures</strong></span>. The most commonly used ones are generated <a id="id308" class="indexterm"></a>using <span class="strong"><strong>Perlin noise</strong></span>.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec107"></a>How to do it…</h3></div></div></div><p>This effect works in two steps: a vertex function to change the geometry and surface function to give it the right color. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following properties to the shader:</p><div class="informalexample"><pre class="programlisting">_RampTex("Color Ramp", 2D) = "white" {}
_RampOffset("Ramp offset", Range(-0.5,0.5))= 0

_NoiseTex("Noise tex", 2D) = "gray" {}
_Period("Period", Range(0,1)) = 0.5

_Amount("_Amount", Range(0, 1.0)) = 0.1
_ClipRange("ClipRange", Range(0,1)) = 1</pre></div></li><li><p>Add their relative variables so that the Cg code of the shader can actually access them:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sampler2D</strong></span> _RampTex;
<span class="strong"><strong>half</strong></span> _RampOffset;

<span class="strong"><strong>sampler2D</strong></span> _NoiseTex;
<span class="strong"><strong>float</strong></span> _Period;

<span class="strong"><strong>half</strong></span> _Amount;
<span class="strong"><strong>half</strong></span> _ClipRange;</pre></div></li><li><p>Change <a id="id309" class="indexterm"></a>the <code class="literal">Input</code> structure so that it receives the UV data of the ramp texture:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>struct</strong></span> Input {
  <span class="strong"><strong>float2</strong></span> uv_NoiseTex;
};</pre></div></li><li><p>Add the following vertex function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> vert(<span class="strong"><strong>inout</strong></span> appdata_full v) {
  <span class="strong"><strong>float3</strong></span> disp = tex2Dlod(_NoiseTex, <span class="strong"><strong>float4</strong></span>(v.texcoord.xy,0,0));
  <span class="strong"><strong>float</strong></span> time = sin(_Time[3] *_Period + disp.r*10);
  v.vertex.xyz += v.normal * disp.r * _Amount * time;
}</pre></div></li><li><p>Add the following surface function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> surf(Input IN, <span class="strong"><strong>inout</strong></span> SurfaceOutput o) {
  <span class="strong"><strong>float3</strong></span> noise = tex2D(_NoiseTex, IN.uv_NoiseTex);
  <span class="strong"><strong>float</strong></span> n = saturate(noise.r + _RampOffset);
  clip(_ClipRange - n);
  <span class="strong"><strong>half4</strong></span> c = tex2D(_RampTex, <span class="strong"><strong>float2</strong></span>(n,0.5));
  o.Albedo = c.rgb;
  o.Emission = c.rgb*c.a;
}</pre></div></li><li><p>We specify the vertex function in the <code class="literal">#pragma</code> directive, adding the <code class="literal">nolightmap</code> parameter to prevent Unity from adding realistic lightings to our explosion:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#pragma</strong></span> surface surf Lambert vertex:vert nolightmap</pre></div></li><li><p>The last step is selecting the material, and from its <span class="strong"><strong>Inspector</strong></span>, attaching the two textures in the relative slots. This is an animated material, meaning that it evolves over time. You can watch the material changing in the editor by clicking on <span class="strong"><strong>Animated Materials</strong></span> from the <span class="strong"><strong>Scene</strong></span> window:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_05_09.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec108"></a>How it works…</h3></div></div></div><p>If you are reading this recipe, you should already be familiar with how Surface Shaders and vertex modifiers <a id="id310" class="indexterm"></a>work. The main idea behind this effect is to alter the geometry of the sphere in a seemingly chaotic way, exactly like it happens in a real explosion. The following picture shows you how such an explosion will look inside the editor. You can see that the original mesh has been heavily deformed:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_05_10.jpg" /></div><p>The vertex <a id="id311" class="indexterm"></a>function is a variant of the technique called <span class="strong"><strong>normal extrusion</strong></span> introduced in the <span class="emphasis"><em>Extruding your models</em></span> recipe of this chapter. The difference here is that the amount of the extrusion is determined both by the time and noise texture.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>When you need a random number in Unity, you can rely on the <code class="literal">Random.Range()</code> function. There is no standard way to get random numbers in a shader, so the easiest way is to sample a noise texture.</p></div><p>There is no <a id="id312" class="indexterm"></a>standard way to do this, so take this as an example only:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>float</strong></span> time = sin(_Time[3] *_Period + disp.r*10);</pre></div><p>The built-in <code class="literal">_Time[3]</code> variable is used to get the current time from within the shader, and the red channel of the noise texture <code class="literal">disp.r</code> is used to make sure that each vertex moves independently. The <code class="literal">sin()</code> function makes the vertices go up and down, simulating the chaotic behavior of an explosion. Then, the normal extrusion takes place:</p><div class="informalexample"><pre class="programlisting">v.vertex.xyz += v.normal * disp.r * _Amount * time;</pre></div><p>You should play with these numbers and variables until you find a pattern of movement that you are happy with.</p><p>The last part of the effect is achieved by the surface function. Here, the noise texture is used to sample a random color from the ramp texture. However, there are two more aspects that are worth noticing. The first one is the introduction of <code class="literal">_RampOffset</code>. Its usage forces the explosion to sample colors from the left or right side of the texture. With positive values, the surface of the explosion tends to show more grey tones; exactly what happens when it is dissolving. You can use <code class="literal">_RampOffset</code> to determine how much fire or smoke there should be in your explosion. The second aspect introduced in the surface function is the usage of <code class="literal">clip()</code>. What <code class="literal">clip()</code> does is it clips (removes) pixels from the rendering pipeline. When invoked with a negative value, the current pixel is not drawn. This effect is controlled by <code class="literal">_ClipRange</code>, which determines which pixels of the volumetric explosions are going to be transparent.</p><p>By controlling both <code class="literal">_RampOffset</code> and <code class="literal">_ClipRange</code>, you have full control to determine how the explosion behaves and dissolves.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec109"></a>There's more…</h3></div></div></div><p>The shader presented in this recipe makes a sphere look like an explosion. If you really want to use it, you should couple it with some scripts in order to get the most out of it. The best thing to do is to create an explosion object and make it into a prefab so that you can reuse it every time you need. You can do this by dragging the sphere back into the <span class="strong"><strong>Project</strong></span> window. Once it is done, you can create as many explosions as you want using the <code class="literal">Instantiate()</code> function.</p><p>It is worth noticing, however, that all the objects with the same material share the same look. If you have multiple explosions at the same time, they should not use the same material. When you are instantiating a new explosion, you should also duplicate its material. You can do this easily with this piece of code:</p><div class="informalexample"><pre class="programlisting">GameObject explosion = Instantiate(explosionPrefab) as GameObject;
Renderer renderer = explosion.GetComponent&lt;Renderer&gt;();
Material material = new Material(renderer.sharedMaterial);
renderer.material = material;</pre></div><p>Lastly, if you are going to use this shader in a realistic way, you should attach a script to it that changes its size, <code class="literal">_RampOffset</code>, and <code class="literal">_ClipRange</code> according to the type of explosion that you want to recreate.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec110"></a>See also</h3></div></div></div><p>Much more can be done to make explosions realistic. The approach presented in this recipe only creates an empty shell; inside it, the explosion is actually empty. An easy trick to improve this is to <a id="id313" class="indexterm"></a>create particles inside it. However, you can <a id="id314" class="indexterm"></a>only go that far with this. The short movie, <span class="strong"><strong>The Butterfly Effect</strong></span> (<a class="ulink" href="http://unity3d.com/pages/butterfly" target="_blank">http://unity3d.com/pages/butterfly</a>) created by <span class="strong"><strong>Unity Technologies</strong></span> in <a id="id315" class="indexterm"></a>collaboration with <span class="strong"><strong>Passion Pictures</strong></span> and <span class="strong"><strong>Nvidia</strong></span>, is the <a id="id316" class="indexterm"></a>perfect example. It is based on the same concept of altering the geometry of a sphere, but it renders it with a technique called <span class="strong"><strong>volume ray casting</strong></span>. In a nutshell, it renders the <a id="id317" class="indexterm"></a>geometry as if it's full. You can see an example in the following picture:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_05_11.jpg" /></div><p>If you are <a id="id318" class="indexterm"></a>looking for high-quality explosions, check out <span class="strong"><strong>Pyro </strong></span>
<a id="id319" class="indexterm"></a>
<span class="strong"><strong>Technix</strong></span> (<a class="ulink" href="https://www.assetstore.unity3d.com/en/#!/content/16925" target="_blank">https://www.assetstore.unity3d.com/en/#!/content/16925</a>) on the Asset Store. It includes volumetric explosions and couples them with realistic shockwaves.</p></div></div>