<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec60"></a>Making your shader world modular with CgInclude</h2></div></div><hr /></div><p>Knowing <a id="id479" class="indexterm"></a>about the built-in CgInclude files is <a id="id480" class="indexterm"></a>great, but what if we wanted to build our own CgInclude files to store our own lighting models and helper functions? We can, in fact, create our own CgInclude files, but we need to learn a little more code syntax before we can start using them efficiently in our shader writing pipelines. Let's take a look at the process of creating a new CgInclude file from scratch.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec162"></a>Getting ready</h3></div></div></div><p>Let's walk through the process of generating a new item for this recipe.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Begin by creating a new text file and call it something like <code class="literal">MyCgInclude.txt</code>.</p></li><li><p>Then change its file extension to <code class="literal">.cginc</code>. Windows will give you a warning message saying that the file may become unusable, but it will still work.</p></li><li><p>Import this new <code class="literal">.cginc</code> file to your Unity project and let it compile. If all goes well, you will see that Unity knew to compile it to a CgInclude file.</p></li></ol></div><p>We are now ready to begin creating our own custom CgInclude code. Simply double-click on the CgInclude file that you created in order to open it in MonoDevelop.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec163"></a>How to do it…</h3></div></div></div><p>With our CgInclude file open, we can begin to enter the code that will get it working with our Surface Shaders. The following code will get our CgInclude file ready for use within our Surface Shaders and allow us to continually add more code to it as we develop more shaders:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We begin our CgInclude file with what is called a preprocessor directive. These are statements such as <code class="literal">#pragma</code> and <code class="literal">#include</code>. In this case, we want to define a new set of code that will be executed if our shader includes this file in its compiler directives. Enter the following code at the top of your CgInclude file:</p><div class="informalexample"><pre class="programlisting">#ifndef MY_CG_INCLUDE
#define MY_CG_INCLUDE</pre></div></li><li><p>We always need to make sure that we close <code class="literal">#ifndef</code> or <code class="literal">#ifdef</code> with <code class="literal">#endif</code> to close the definition check, just like an <code class="literal">if</code> statement needs to be closed with two brackets in C#. Enter the following code just after the <code class="literal">#define</code> directive:</p><div class="informalexample"><pre class="programlisting">#endif</pre></div></li><li><p>At this point, we just need to fill in the guts of the CgInclude file. So we finish off our CgInclude file by entering the following code:</p><div class="informalexample"><pre class="programlisting">fixed4 _MyColor;

<span class="strong"><strong>inline</strong></span> fixed4 LightingHalfLamber (SurfaceOutput s, fixed3 lightDir, fixed atten)
{
    fixed diff = max(0, dot(s.Normal, lightDir));
    diff = (diff + 0.5)*0.5;

    fixed c;
    c.rgb = s.Albedo * _LightColor0.rgb * ((diff * _MyColor.rgb) * atten);
    c.a = s.Alpha;
    return c;
}
<span class="strong"><strong>#endif</strong></span>
</pre></div></li><li><p>With this <a id="id481" class="indexterm"></a>completed, you now have <a id="id482" class="indexterm"></a>your very first CgInclude file. With just this little bit of code, we can greatly reduce the amount of code that we have to rewrite, and we can begin to store lighting models that we use all the time here so that we never lose them. Your CgInclude file should look similar to the following code shown:</p><div class="informalexample"><pre class="programlisting">#ifndef MY_CG_INCLUDE
#define MY_CG_INCLUDE

fixed4 _MyColor;

<span class="strong"><strong>inline</strong></span> fixed4 LightingHalfLamber (SurfaceOutput s, fixed3 lightDir, fixed atten)
{
    fixed diff = max(0, dot(s.Normal, lightDir));
    diff = (diff + 0.5)*0.5;

    fixed c;
    c.rgb = s.Albedo * _LightColor0.rgb * ((diff * _MyColor.rgb) * atten);
    c.a = s.Alpha;
    return c;
}
<span class="strong"><strong>#endif</strong></span>
</pre></div></li></ol></div><p>There are a couple more steps that we need to complete before we can fully utilize this CgInclude file. We simply need to tell the current shader we are working with to use this file and its code. To complete the process of creating and using CgInclude files, let's complete the next set of steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>If we turn our attention to our shader, we need to tell our <code class="literal">CGPROGRAM</code> block to include our new CgInclude file so that we can access the code it contains. Modify the directives of our <code class="literal">CGPROGRAM</code> block to include the following code:</p><div class="informalexample"><pre class="programlisting">CGPROGRAM
#include "MyCGInclude.cginc"
#pragma surface surf Lambert</pre></div></li><li><p>Our current <a id="id483" class="indexterm"></a>shader is currently <a id="id484" class="indexterm"></a>using the built-in Lambert lighting model, but we want to use the Half Lambert lighting model that we created in our CgInclude. As we included the code from our CgInclude file, we can use the Half Lambert lighting model with the following code:</p><div class="informalexample"><pre class="programlisting">CGPROGRAM
#include "MyCGInclude.cginc"
#pragma surface surf HalfLambert</pre></div></li><li><p>Finally, we have also declared a custom variable in our CgInclude file to show that we can set up default variables for our shaders to use. To see this in action, enter the following code in the <code class="literal">Properties</code> block of your shader:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Properties</strong></span>
{
    _MainTex ("Base (RGB)", 2D) = "white" {}
    _DesatValue ("Desaturate", Range(0,1)) = 0.5
    _MyColor ("My Color", Color) = (1,1,1,1)
}</pre></div></li><li><p>When we return to Unity, the shader and CgInclude file will compile, and if you do not see any errors, you will notice that in fact we are using our new Half Lambert lighting model and a new color swatch appears in our material's <span class="strong"><strong>Inspector</strong></span>. The following screenshot shows the result of using our CgInclude file:</p></li></ol></div><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_10_09.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec164"></a>How it works…</h3></div></div></div><p>When using shaders, we can include other sets of code using the <code class="literal">#include</code> preprocessor directive. This tells Unity that we want to let the current shader use the code from within the included file in the shader; this is the reason why these files are called CgInclude files. We are including snippets of Cg code using the <code class="literal">#include</code> directive.</p><p>Once we <a id="id485" class="indexterm"></a>declare the <code class="literal">#include</code> directive and <a id="id486" class="indexterm"></a>Unity is able to find the file in the project, Unity will then look for code snippets that have been defined. This is where we start to use the <code class="literal">#ifndef</code> and <code class="literal">#endif</code> directives. When we declare the <code class="literal">#ifndef</code> directive, we are simply saying, <span class="emphasis"><em>if not defined, define something with a name</em></span>. In this recipe's case, we said we wanted to <code class="literal">#define MY_CG_INCLUDE</code>. So if Unity doesn't find a definition called <code class="literal">MY_CG_INCLUDE</code>, it goes and creates it when the CgInclude file is compiled, thereby giving us access to the code that follows. The <code class="literal">#endif</code> method simply says that this is the end of this definition, so stop looking for more code.</p><p>You can now see how powerful this becomes as we can now store all of our lighting models and custom variables in one file and greatly reduce the amount of code that we have to write. The <a id="id487" class="indexterm"></a>real power is when you can begin to <a id="id488" class="indexterm"></a>give your shaders the flexibility by defining multiple states of functions in the CgInclude files.</p></div></div>