<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec29"></a>Creating an Anisotropic Specular type</h2></div></div><hr /></div><p>
<span class="strong"><strong>Anisotropic</strong></span> is a <a id="id192" class="indexterm"></a>type of Specular or reflection that simulates the directionality of grooves in a surface and modifies/stretches the Specular in the perpendicular direction. It is very useful when you want to simulate brushed metals, not a metal with a clear, smooth, and polished surface. Imagine the Specular that you see when you look at the data side of a CD or DVD or the way Specular is shaped at the bottom of a pot or pan. You will notice that if you carefully examine the surface, you will see that there is a direction to the grooves in the surface, usually in the way the metal was brushed. When you apply a Specular to this surface, you get a Specular stretched in the perpendicular direction.</p><p>This recipe will introduce you to the concept of augmenting your Specular highlights to achieve different types of brushed surfaces. In future recipes, we will look at ways in which we can use the concepts of this recipe to achieve other effects such as stretched reflections and hair, but here, you are going to learn the fundamentals of the technique first. We <a id="id193" class="indexterm"></a>will be using this shader as a reference for our own custom Anisotropic Shader:</p><p>
<a class="ulink" href="http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader" target="_blank">http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader</a>
</p><p>The following screenshot shows examples of different types of Specular effects one can achieve using Anisotropic Shaders in Unity:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_03_13.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec73"></a>Getting ready</h3></div></div></div><p>Let's start this <a id="id194" class="indexterm"></a>recipe by creating a shader, its material, and some lights for our scene:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene with some objects and lights so that we can visually debug our shader.</p></li><li><p>Then create a new shader and material, and hook them up to our objects.</p></li><li><p>Lastly, we will need some sort of normal map that will indicate the directionality of our Anisotropic Specular highlight.</p></li></ol></div><p>The following screenshot shows the Anisotropy normal map we will be using for this recipe. It is available from the book's support page at <a class="ulink" href="https://www.packtpub.com/books/content/support" target="_blank">https://www.packtpub.com/books/content/support</a>:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_03_14.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec74"></a>How to do it…</h3></div></div></div><p>To create an <a id="id195" class="indexterm"></a>Anisotropic effect, we need to make the following changes to the shader previously created:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We first need to add the properties that we are going to need for our shader. These will allow a lot of artistic control over the final appearance of the surface:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Properties</strong></span>
{
  _MainTint ("Diffuse Tint", Color) = (1,1,1,1)
  _MainTex ("Base (RGB)", 2D) = "white" {}
  _SpecularColor ("specular Color", Color) = (1,1,1,1)
  _Specular ("Specular Amount", Range(0,1)) = 0.5
  _SpecPower ("Specular Power", Range(0,1)) = 0.5
  _AnisoDir ("Anisotropic Direction", 2D) = "" {}
  _AnisoOffset ("Anisotropic Offset", Range(-1,1)) = -0.2
}</pre></div></li><li><p>We then <a id="id196" class="indexterm"></a>need to make the connection between our <code class="literal">Properties</code> block and our <code class="literal">SubShader{}</code> block so that we can use the data being provided by the <code class="literal">Properties</code> block:</p><div class="informalexample"><pre class="programlisting">sampler2D _MainTex;
sampler2D _AnisoDir;
float4 _MainTint;
float4 _SpecularColor;
float _AnisoOffset;
float _Specular;
float _SpecPower;</pre></div></li><li><p>Now we can create our lighting function that will produce the correct Anisotropic effect on our surface. We will use the following code for this:</p><div class="informalexample"><pre class="programlisting">fixed4 LightingAnisotropic(SurfaceAnisoOutput s, fixed3 lightDir, <span class="strong"><strong>half3</strong></span> viewDir, fixed atten)
{
  fixed3 halfVector = normalize(normalize(lightDir) + normalize(viewDir));
  <span class="strong"><strong>float</strong></span> NdotL = saturate(dot(s.Normal, lightDir));

  fixed HdotA = dot(normalize(s.Normal + s.AnisoDirection), halfVector);
  <span class="strong"><strong>float</strong></span> aniso = max(0, sin(radians((HdotA + _AnisoOffset) * 180)));

  <span class="strong"><strong>float</strong></span> spec = saturate(pow(aniso, s.Gloss * 128) * s.Specular);

  fixed4 c;
  c.rgb = ((s.Albedo * _LightColor0.rgb * NdotL) + (_LightColor0.rgb * _SpecularColor.rgb * spec)) * atten;
  c.a = s.Alpha;
<span class="strong"><strong>  return</strong></span> c;
}</pre></div></li><li><p>In order to use this new lighting function, we need to tell the subshader's <code class="literal">#pragma</code> statement to look for it instead of using one of the built-in lighting functions. We are also telling the shader to target shader model 3.0 so that we can have more space for textures in our program:</p><div class="informalexample"><pre class="programlisting">CGPROGRAM
<span class="strong"><strong>#pragma</strong></span> surface surf Anisotropic
<span class="strong"><strong>#pragma</strong></span> target 3.0</pre></div></li><li><p>We have also given the Anisotropic normal map its own UVs by declaring the following code in the <code class="literal">Input</code> struct. This isn't entirely necessary as we could just use the UVs from the main texture, but this gives us independent control over the tiling of our brushed metal effect so that we can scale it to any size we want:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>struct</strong></span> Input 
{
  float2 uv_MainTex;
  float2 uv_AnisoDir;
};</pre></div></li><li><p>We also need to add the <code class="literal">SurfaceAnisoOutput</code> struct:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>struct</strong></span> SurfaceAnisoOutput
{
  fixed3 Albedo;
  fixed3 Normal;
  fixed3 Emission;
  fixed3 AnisoDirection;
  half Specular;
  fixed Gloss;
  fixed Alpha;
};</pre></div></li><li><p>Finally, we <a id="id197" class="indexterm"></a>need to use the <code class="literal">surf()</code> function to pass the correct data to our lighting function. So, we will get the per-pixel information from our Anisotropic normal map and set our Specular parameters as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> surf(Input IN, <span class="strong"><strong>inout</strong></span> SurfaceAnisoOutput o)
{
  <span class="strong"><strong>half4</strong></span> c = tex2D(_MainTex, IN.uv_MainTex) * _MainTint;
  <span class="strong"><strong>float3</strong></span> anisoTex = UnpackNormal(tex2D(_AnisoDir, IN.uv_AnisoDir));

  o.AnisoDirection = anisoTex;
  o.Specular = _Specular;
  o.Gloss = _SpecPower;
  o.Albedo = c.rgb;
  o.Alpha = c.a;
}</pre></div></li></ol></div><p>The Anisotropic normal map allows us to give the surface direction and helps us disperse the Specular highlight around the surface. The following screenshot demonstrates the result of our Anisotropic Shader:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_03_15.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec75"></a>How it works…</h3></div></div></div><p>Let's break down this shader into its core components and explain why we are getting the effect. We will mostly be covering the custom lighting function here, as the rest of the shader should be pretty self-explanatory at this point.</p><p>We first start by <a id="id198" class="indexterm"></a>declaring our own <code class="literal">SurfaceAnisoOutput</code> struct. We need to do this in order to get the per-pixel information from the Anisotropic normal map, and the only way we can do this in a Surface Shader is to use a <code class="literal">tex2D()</code> function in the <code class="literal">surf()</code> function. The following code shows the custom surface output structure used in our shader:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>struct</strong></span> SurfaceAnisoOutput
{
  fixed3 Albedo;
  fixed3 Normal;
  fixed3 Emission;
  fixed3 AnisoDirection;
  half Specular;
  fixed Gloss;
  fixed Alpha;
};</pre></div><p>We can use the <code class="literal">SurfaceAnisoOutput</code> struct as a way of interacting between the lighting function and surface function. In our case, we are storing the per-pixel texture information in the variable called <code class="literal">anisoTex</code> in our <code class="literal">surf()</code> function and then passing this data to the <code class="literal">SurfaceAnisoOutput</code> struct by storing it in the <code class="literal">AnisoDirection</code> variable. Once we have this, we can use the per-pixel information in the lighting function using <code class="literal">s.AnisoDirection</code>.</p><p>With this data connection set up, we can move on to our actual lighting calculations. This begins by getting the usual out of the way, the half vector, so that we don't have to do the full reflection calculation and diffuse lighting, which is the vertex normal dotted with the light vector or direction. This is done in Cg with the following lines:</p><div class="informalexample"><pre class="programlisting">fixed3 halfVector = normalize(normalize(lightDir) + normalize(viewDir));
float NdotL = saturate(dot(s.Normal, lightDir));</pre></div><p>Then, we start the actual modification to the Specular to get the right look. We first dot the normalized sum of the vertex normal and per-pixel vectors from our Anisotropic normal map with <code class="literal">halfVector</code> calculated in the previous step. This gives us a float value that gives a value of <a id="id199" class="indexterm"></a>
<code class="literal">1</code> as the surface normal, which is modified by the Anisotropic normal map as it becomes parallel with <code class="literal">halfVector</code> and <code class="literal">0</code> as it is perpendicular. Finally, we modify this value with a <code class="literal">sin()</code> function so that we can basically get a darker middle highlight and ultimately a ring effect based off of <code class="literal">halfVector</code>. All the previously mentioned operations are summarized in the following two lines of Cg code:</p><div class="informalexample"><pre class="programlisting">fixed HdotA = dot(normalize(s.Normal + s.AnisoDirection), halfVector);
float aniso = max(0, sin(radians((HdotA + _AnisoOffset) * 180)));</pre></div><p>Finally, we scale the effect of the <code class="literal">aniso</code> value by taking it to a power of <code class="literal">s.Gloss</code>, and then globally decrease its strength by multiplying it by <code class="literal">s.Specular</code>:</p><div class="informalexample"><pre class="programlisting">float spec = saturate(pow(aniso, s.Gloss * 128) * s.Specular);</pre></div><p>This effect is great to create more advanced metal type surfaces, especially the ones that are brushed and seem to have directionality to them. It also works well for hair or any sort of soft surface with directionality to it. The following screenshot shows the result of displaying the final Anisotropic lighting calculation:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_03_16.jpg" /></div></div></div>