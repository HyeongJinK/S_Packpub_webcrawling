<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec47"></a>What is a cheap shader?</h2></div></div><hr /></div><p>When first asked the <a id="id360" class="indexterm"></a>question, what is a cheap shader, it might be a little tough to answer as there are many elements that go into making a more efficient shader. It could be the amount of memory used up by your variables. It could be the amount of textures the shader is using. It could also be that our shader is working fine, but we can actually produce the same visual effect with half the amount of data by reducing the amount of code we are using or data we are creating. We are going to explore a few of these techniques in this recipe and show how they can be combined to make your shader fast and efficient but still produce the high-quality visuals everyone expects from games today, whether on a mobile or PC.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec127"></a>Getting ready</h3></div></div></div><p>In order to get this recipe started, we need to gather a few resources together. So let's perform the following tasks:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene and fill it with a simple sphere object and single directional light.</p></li><li><p>Create a new shader and material and assign the shader to the material.</p></li><li><p>We then need to assign the material we just created to our sphere object in our new scene.</p></li><li><p>Finally, modify the shader so that it uses a diffuse texture and normal map and includes your own custom lighting function. The following image shows the result of modifying our default shader that we created in step 1:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_01.jpg" /></div></li></ol></div><p>You should now <a id="id361" class="indexterm"></a>have a setup similar to the following image. This setup will allow us to take a look at some of the basic concepts that go into optimizing shaders using Surface Shaders in Unity:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_02.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec128"></a>How to do it…</h3></div></div></div><p>We are going to build a simple Diffuse shader to take a look at a few ways in which you can optimize your shaders in general.</p><p>First, we'll optimize <a id="id362" class="indexterm"></a>our variable types so that they use less memory when they <a id="id363" class="indexterm"></a>are processing data:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's begin with the <code class="literal">struct</code> <code class="literal">Input</code> in our shader. Currently, our UVs are being stored in a variable of the <code class="literal">float2</code> type. We need to change this to use <code class="literal">half2</code> instead:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_28.jpg" /></div></li><li><p>We can then move to our lighting function and reduce the variable's memory footprint by changing their types to the following:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_03.jpg" /></div></li><li><p>Finally, we can <a id="id364" class="indexterm"></a>complete this optimization pass by updating the <a id="id365" class="indexterm"></a>variables in our <code class="literal">surf()</code> function:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_04.jpg" /></div><p>Now that we have our variables optimized, we are going to take advantage of a built-in lighting function variable so that we can control how lights are processed by this shader. By doing this, we can greatly reduce the amount of lights the shader processes. Modify the <code class="literal">#pragma</code> statement in your shader with the following code:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_05.jpg" /></div><p>We can optimize this further by sharing UVs between the normal map and diffuse texture. To do this, we simply change the UV lookup in our <code class="literal">UnpackNormal()</code> function to use <code class="literal">_MainTex</code> UVs <a id="id366" class="indexterm"></a>instead of the UVs of <code class="literal">_NormalMap</code>:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_06.jpg" /></div></li><li><p>As we have removed the need for the normal map UVs, we need to make sure that we remove <a id="id367" class="indexterm"></a>the normal map UV code from the <code class="literal">Input</code> struct:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_07.jpg" /></div></li><li><p>Finally, we can further optimize this shader by telling the shader that it only works with certain renderers:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_08.jpg" /></div></li></ol></div><p>The result of our optimization passes show us that we really don't notice a difference in the visual quality, but we have reduced the amount of time it takes for this shader to be drawn to the screen. You will learn about finding out how much time it takes for a shader to render in the next recipe, but the idea to focus on here is that we achieve the same result with less data. So keep this in mind when creating your shaders. The following image shows us the final result of our shader:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_09.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec129"></a>How it works…</h3></div></div></div><p>Now that we have seen the ways in which we can optimize our shaders, let's dive in a bit deeper and really understand why all of these techniques are working and look at a couple of other techniques that you can try for yourself.</p><p>Let's first focus our attention on the size of the data each of our variables is storing when we declare them. If you are familiar with programming, then you will understand that you can declare values or <a id="id368" class="indexterm"></a>variables with different sizes of types. This means that a float <a id="id369" class="indexterm"></a>actually has a maximum size in memory. The following description will describe these variable types in much more detail:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Float</strong></span>: A float is a full 32-bit precision value and is the slowest of the three different types we see here. It also has its corresponding values of <code class="literal">float2</code>, <code class="literal">float3</code>, and <code class="literal">float4</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Half</strong></span>: The half variable type is a reduced 16-bit floating point value and is suitable to store UV values and color values and is much faster than using a float value. It has its corresponding values like the float type, which are <code class="literal">half2</code>, <code class="literal">half3</code>, and <code class="literal">half4</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Fixed</strong></span>: A fixed value is the smallest in size of the three types, but can be used for lighting calculations and colors and has the corresponding values of <code class="literal">fixed2</code>, <code class="literal">fixed3</code>, and <code class="literal">fixed4</code>.</p></li></ul></div><p>Our second phase of optimizing our simple shader was to declare the <code class="literal">noforwardadd</code> value to our <code class="literal">#pragma</code> statement. This is basically a switch that automatically tells Unity that any object with this particular shader receives only per-pixel light from a single directional light. Any other lights that are calculated by this shader will be forced to be processed as per-vertex lights using Spherical Harmonic values produced internally by Unity. This is especially obvious when we place another light in the scene to light our sphere object because our shader is doing a per-pixel operation using the normal map.</p><p>This is great, but what if you wanted to have a bunch of directional lights in the scene and control over which of these lights is used for the main per-pixel light? Well, if you notice, each light has a <span class="strong"><strong>Render Mode</strong></span> drop-down. If you click on this drop-down, you will see a couple of flags that can be set. These are <span class="strong"><strong>Auto</strong></span>, <span class="strong"><strong>Important</strong></span>, and <span class="strong"><strong>Not Important</strong></span>. By selecting a light, you can tell Unity that a light should be considered more as a per-pixel light than a per-vertex light, by setting its render mode to <span class="strong"><strong>Important</strong></span> and vice versa. If you leave a light set to <span class="strong"><strong>Auto</strong></span>, then you will let Unity decide the best course of action.</p><p>Place another light in your scene and remove the texture that is currently in the main texture for our shader. You will notice that the second point light does not react with the normal map, only the <a id="id370" class="indexterm"></a>directional light that we created first. The concept here is that you save on per-pixel operations by just calculating all extra lights as vertex lights, and save performance by just calculating the main directional light as a per-pixel light. The following image visually demonstrates this concept as the point light is not reacting with the normal map:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/5084_08_10.jpg" /></div><p>Finally, we did a bit of cleaning up and simply told the normal map texture to use the main texture's UV values, and we got rid of the line of code that pulled in a separate set of UV values specifically for the normal map. This is always a nice way to simplify your code and clean up any unwanted data.</p><p>We also declared <code class="literal">exclude_pass: prepass</code> in our <code class="literal">#pragma </code>statement so that this shader wouldn't accept any custom lighting from the deferred renderer. This means that we can really use this shader effectively in the forward renderer only, which is set in the main camera's settings.</p><p>By taking a bit of time, you will be amazed at how much a shader can be optimized. You have seen how we can pack grayscale textures into a single RGBA texture as well as use lookup textures to fake lighting. There are many ways in which a shader can be optimized, which is why it is always an ambiguous question to ask in the first place, but knowing these different <a id="id371" class="indexterm"></a>optimization techniques, you can cater your shaders to your game and target platform, ultimately resulting in very streamlined shaders and a nice steady framerate.</p></div></div>