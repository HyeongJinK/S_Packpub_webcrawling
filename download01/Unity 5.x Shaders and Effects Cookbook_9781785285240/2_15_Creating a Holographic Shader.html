<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Creating a Holographic Shader</h2></div></div><hr /></div><p>More <a id="id132" class="indexterm"></a>and more space-themed games are being released every year. An important part of a good sci-fi game is the way futuristic technology is presented and integrated in the gameplay. There's nothing that screams futuristic more than holograms. Despite being present in many flavors, holograms are often represented as semi-transparent, thin projections of an object. This recipe shows you how to create a shader that simulates such effects. Take this as a starting point: you can add noise, animated scanlines, and vibrations to create a truly outstanding holographic effect. The following image shows an example of a holographic effect:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_02_11.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec48"></a>Getting ready</h3></div></div></div><p>As the holographic effects shows only the outlines of an object, we'll call this shader <code class="literal">Silhouette</code>. Attach it to a material and assign it to your 3D model.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec49"></a>How to do it…</h3></div></div></div><p>The following <a id="id133" class="indexterm"></a>changes will modify our existing shader into a holographic one:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following property to the shader:</p><div class="informalexample"><pre class="programlisting">_DotProduct(<span class="strong"><strong>"Rim effect"</strong></span>, Range(-1,1)) = 0.25</pre></div></li><li><p>Add its respective variable to the <code class="literal">CGPROGRAM</code> section:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>float</strong></span> _DotProduct;</pre></div></li><li><p>As this material is transparent, add the following tags:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Tags</strong></span>
{
  <span class="strong"><strong>"Queue"</strong></span> = <span class="strong"><strong>"Transparent"</strong></span>
  <span class="strong"><strong>"IgnoreProjector"</strong></span> = <span class="strong"><strong>"True"</strong></span>
  <span class="strong"><strong>"RenderType"</strong></span> = <span class="strong"><strong>"Transparent"</strong></span>
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>According to the type of object that you will use, you might want its backside to appear. If this is the case, add <code class="literal">Cull Off</code> so that the back of the model won't be removed (<span class="emphasis"><em>culled</em></span>).</p></div></li><li><p>This shader is not trying to simulate a realistic material, so there is no need to use the PBR lighting <a id="id134" class="indexterm"></a>model. The <span class="strong"><strong>Lambertian reflectance</strong></span>, which is very cheap, is used instead. Additionally, we should disable any lighting with <code class="literal">nolighting</code> and signal to Cg that this is a Transparent Shader using <code class="literal">alpha:fade</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#pragma</strong></span> surface surf Lambert alpha:fade nolighting</pre></div></li><li><p>Change the <code class="literal">Input</code> structure so that Unity will fill it with the current view direction and world normal direction:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>struct</strong></span> Input
{
  <span class="strong"><strong>float2</strong></span> uv_MainTex;
  <span class="strong"><strong>float3</strong></span> worldNormal;
  <span class="strong"><strong>float3</strong></span> viewDir;
};</pre></div></li><li><p>Use the following surface function. Remember that as this shader is using the Lambertian reflectance as its lighting function, the name of the surface output <a id="id135" class="indexterm"></a>structure should be changed accordingly to <code class="literal">SurfaeOutput</code> instead of <code class="literal">SurfaceOutputStandard</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> surf(Input IN, <span class="strong"><strong>inout</strong></span> SurfaceOutput o)
{
  <span class="strong"><strong>float4</strong></span> c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
  o.Albedo = c.rgb;

  <span class="strong"><strong>float</strong></span> border = 1 - (abs(dot(IN.viewDir, IN.worldNormal)));
  <span class="strong"><strong>float</strong></span> alpha = (border * (1 - _DotProduct) + _DotProduct);
  o.Alpha = c.a * alpha;
}</pre></div></li></ol></div><p>You can now use the <span class="strong"><strong>Rim effect</strong></span> slider to choose the strength of the holographic effect.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec50"></a>How it works…</h3></div></div></div><p>As mentioned before, this shader works by showing only the silhouette of an object. If we look at the object from another angle, its outline will change. Geometrically speaking, the edges of a model are all those triangles whose <span class="emphasis"><em>normal direction</em></span> is orthogonal (90 degrees) to the current <span class="emphasis"><em>view direction</em></span>. The <code class="literal">Input</code> structure declares these parameters, <code class="literal">worldNormal</code> and <code class="literal">viewDir</code>, respectively.</p><p>The problem of understanding when two vectors are orthogonal can be solved using the <span class="strong"><strong>dot product</strong></span>. It's an <a id="id136" class="indexterm"></a>operator that takes two vectors and returns zero if they are orthogonal. We use <code class="literal">_DotProduct</code> to determine how close to zero the dot product has to be for the triangle to fade completely.</p><p>The second aspect that is used in this shader is the gentle fading between the edge of the model (fully visible) and the angle determined by <code class="literal">_DotProduct</code> (invisible). This linear interpolation is done as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>float</strong></span> alpha = (border * (1 - _DotProduct) + _DotProduct);</pre></div><p>Finally, the original alpha from the texture is multiplied with the newly calculated coefficient to achieve the final look.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec51"></a>There's more…</h3></div></div></div><p>This technique is very simple and relatively inexpensive. Yet, it can be used for a large variety of effects, such as the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The slightly colored atmosphere of a planet in sci-fi games</p></li><li style="list-style-type: disc"><p>The edge of an object that has been selected or is currently under the mouse</p></li><li style="list-style-type: disc"><p>A ghost or specter</p></li><li style="list-style-type: disc"><p>Smoke coming out of an engine</p></li><li style="list-style-type: disc"><p>The shockwave of an explosion</p></li><li style="list-style-type: disc"><p>The bubble shield of a spaceship under attack</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec52"></a>See also</h3></div></div></div><p>The dot product <a id="id137" class="indexterm"></a>plays an important role in the way reflections are calculated. <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Understanding Lighting Models</em></span>, will explain in detail how it works and why it is widely used in so many shaders.</p></div></div>