<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec43"></a>Using grab pass</h2></div></div><hr /></div><p>In the <span class="emphasis"><em>Adding transparency to PBR</em></span> recipe of <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Creating Test Cases and Writing Scenarios for Behavior Driven Development in Symfony</em></span>, we have seen how a material can be made transparent. Even <a id="id342" class="indexterm"></a>if a transparent material can draw over a scene, it cannot change what has been drawn underneath it. This means that those Transparent Shaders cannot create distortions such as the ones typically seen in glass or water. In order to simulate them, we need to introduce another technique called <span class="strong"><strong>grab pass</strong></span>. This allows us to access what has been drawn on screen so far so that a shader can use it (or alter it) with no restrictions. To learn how to use grab passes, we will create a material that grabs what's rendered behind it and draws it again on the screen. It's a shader that, paradoxically, uses several operations to show no changes at all.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec116"></a>Getting ready</h3></div></div></div><p>This recipe requires the following operations:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a shader that we will initialize later.</p></li><li><p>Create a material to host the shader.</p></li><li><p>Attach the material to a flat piece of geometry, such as a quad. Place it in front of some other object so that you cannot see through it. The quad will appear transparent as soon as the shader is complete.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec117"></a>How to do it…</h3></div></div></div><p>To use grab pass, you need to follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Remove the <code class="literal">Properties</code> section; this shader will not use any of them.</p></li><li><p>In the <code class="literal">SubShader</code> section, add grab pass:</p><div class="informalexample"><pre class="programlisting">GrabPass{  }</pre></div></li><li><p>After the grab <a id="id343" class="indexterm"></a>pass, we will need to add this extra pass:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Pass</strong></span> {
    CGPROGRAM
#pragma vertex vert
#pragma fragment frag
#include "UnityCG.cginc"

    sampler2D _GrabTexture;

    <span class="strong"><strong>struct</strong></span> vertInput {
        float4 vertex : POSITION;
    };

    <span class="strong"><strong>struct</strong></span> vertOutput {
        float4 vertex : POSITION;
        float4 uvgrab : TEXCOORD1;
    };

    // Vertex function 
    vertInput vert(vertexInput v) {
        vertexOutput o;
        o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);
        o.uvgrab = ComputeGrabScreenPos(o.vertex);
        return o;
    }

    // Fragment function
    half4 frag(vertexOutput i) : COLOR {
        fixed4 col = tex2Dproj(_GrabTexture, UNITY_PROJ_COORD(i.uvgrab));
        return col + half4(0.5,0,0,0);
    }
<span class="strong"><strong>    ENDCG</strong></span>
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec118"></a>How it works…</h3></div></div></div><p>This recipe not only introduces grab passes but also Vertex and Fragment Shaders; for this reason, we have to analyze the shader in detail.</p><p>So far, all the code has always been placed directly in the <code class="literal">SubShader</code> section. This is because our previous shaders required only a single pass. This time, two passes are required. The first one is the grab pass, which is defined simply by <code class="literal">GrabPass{}</code>. The rest of the code is placed in the second pass, which is contained in a <code class="literal">Pass</code> block.</p><p>The second pass is not structurally different from the shader shown in the first recipe of this chapter; we use the vertex function <code class="literal">vert</code> to get the position of the vertex and then we give it a color in the fragment function <code class="literal">frag</code>. The difference is that <code class="literal">vert</code> calculates another important detail: the UV data for the grab pass. The grab pass automatically creates a texture that can be referred to as follows:</p><div class="informalexample"><pre class="programlisting">sampler2D _GrabTexture;</pre></div><p>In order to sample this texture, we need its UV data. The <code class="literal">ComputeGrabScreenPos</code> function returns data that we <a id="id344" class="indexterm"></a>can use later to sample the grab texture correctly. This is done in the Fragment Shader using the following line:</p><div class="informalexample"><pre class="programlisting">fixed4 col = tex2Dproj(_GrabTexture, UNITY_PROJ_COORD(i.uvgrab));</pre></div><p>This is the standard way in which a texture is grabbed and applied to the screen in its correct position. If everything has been done correctly, this shader will simply clone what has been rendered behind the geometry. We will see in the following recipes how this technique can be used to create materials such as water and glass.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec119"></a>There's more…</h3></div></div></div><p>Every time you use a material with <code class="literal">GrabPass {}</code>, Unity will have to render the screen to a texture. This operation is very expensive and limits the number of grab passes that you can use in a game. Cg offers a slightly different variation:</p><div class="informalexample"><pre class="programlisting">GrabPass {"TextureName"}</pre></div><p>This line not only allows you to give a name to the texture, but it also shares the texture with all the materials that have a grab pass called <code class="literal">TextureName</code>. This means that if you have ten materials, Unity will only do a single grab pass and share the texture to all of them. The main problem of this technique is that it doesn't allow effects that can be stacked. If you are creating a glass <a id="id345" class="indexterm"></a>with this technique, you won't be able to have two glasses one after the other.</p></div></div>