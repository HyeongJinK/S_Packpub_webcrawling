<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec62"></a>Implementing heatmaps with arrays</h2></div></div><hr /></div><p>One <a id="id501" class="indexterm"></a>characteristic that makes shaders hard to master is the <a id="id502" class="indexterm"></a>lack of a proper documentation. Most developers learn shaders by messing up with the code, without having a deep knowledge of what's going on. The problem is amplified by the fact that Cg/HLSL makes a lot of assumptions, some of which are not properly advertised. Unity3D allows C# scripts to communicate with shaders using methods such as SetFloat, SetInt, SetVector, and so on. Unfortunately, Unity3D doesn't have a SetArray method, which led many developers to believe that Cg/HLSL doesn't support arrays either. This is not true. This post will show you how it's possible to pass arrays to shaders. Just remember that GPUs are highly optimized for parallel computations, and using for loops in a shader will dramatically drop its performance.</p><p>For this recipe, we will implement a heatmap, as shown in the following image:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_10_04.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec169"></a>Getting ready</h3></div></div></div><p>The effect in <a id="id503" class="indexterm"></a>this recipe creates a heatmap from a set of <a id="id504" class="indexterm"></a>points. This heatmap can be overlaid on top of another picture, like in the preceding image. The following steps are necessary:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a quad with the texture that you want to use for the heatmap. In this example, a map of London has been used.</p></li><li><p>Create another quad, and place it on top of the previous one. Our heatmap will appear on this quad.</p></li><li><p>Attach a new material and shader to the second quad.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec170"></a>How to do it…</h3></div></div></div><p>This shader is quite different from the ones created before, yet it is relatively short. For this reason, the entire code is provided in the following points:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Copy this <a id="id505" class="indexterm"></a>code to the newly created <a id="id506" class="indexterm"></a>shader:</p><div class="informalexample"><pre class="programlisting">shader " Heatmap" {
    <span class="strong"><strong>Properties</strong></span> {
        _HeatTex ("Texture", 2D) = "white" {}
    }
    Subshader {
        Tags {"Queue"="Transparent"}
        Blend SrcAlpha OneMinusSrcAlpha // Alpha blend

        <span class="strong"><strong>Pass</strong></span> {
            CGPROGRAM
            #pragma vertex vert             
            #pragma fragment frag

            <span class="strong"><strong>struct</strong></span> vertInput {
                float4 pos : POSITION;
            };  

            <span class="strong"><strong>struct</strong></span> vertOutput {
                float4 pos : POSITION;
                fixed3 worldPos : TEXCOORD1;
            };

            vertOutput vert(vertInput input) {
                vertOutput o;
                o.pos = mul(UNITY_MATRIX_MVP, input.pos);
                o.worldPos = mul(_Object2World, input.pos).xyz;
                return o;
            }

            uniform int _Points_Length = 0;
            uniform float3 _Points [20];        // (x, y, z) = position
            uniform float2 _Properties [20];    // x = radius, y = intensity
            
            sampler2D _HeatTex;

            half4 frag(vertOutput output) : COLOR {
                // Loops over all the points
                half h = 0;
                for (int i = 0; i &lt; _Points_Length; i ++)
                {
                    // Calculates the contribution of each point
                    half di = distance(output.worldPos, _Points[i].xyz);

                    half ri = _Properties[i].x;
                    half hi = 1 - saturate(di / ri);

                    h += hi * _Properties[i].y;
                }

                // Converts (0-1) according to the heat texture
                h = saturate(h);
                half4 color = tex2D(_HeatTex, fixed2(h, 0.5));
                return color;
            }
<span class="strong"><strong>            ENDCG</strong></span>
        }
    } 
    Fallback "Diffuse"
}</pre></div></li><li><p>Once you have attached this script to your material, you should provide a ramp texture for <a id="id507" class="indexterm"></a>the heatmap. It's important to <a id="id508" class="indexterm"></a>configure it so that its <span class="strong"><strong>Wrap Mode</strong></span> is set to <span class="strong"><strong>Clamp</strong></span>. The following one has been used for this example:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_10_05.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note28"></a>Note</h3><p>If your heatmap is going to be used as an overlay, then make sure that the ramp texture has an alpha channel and the texture is imported with the option, <span class="strong"><strong>Alpha is Transparency</strong></span>.</p></div></li><li><p>Create a new script called <code class="literal">Heatmaps</code> using the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Heatmap : MonoBehaviour {

    public Vector3[] positions;
    public float[] radiuses;
    public float[] intensities;

    public material material;

    <span class="strong"><strong>void</strong></span> Start ()
    {
        material.SetInt("_Points_Length", positions.Length);
        for (int i = 0; i &lt; positions.Length; i ++)
        {
            material.SetVector("_Points" + i.ToString(), positions[i]);

            Vector2 properties = new Vector2(radiuses[i], intensities[i]);
            material.SetVector("_Properties" + i.ToString(), properties);
        }
    }
}</pre></div></li><li><p>Attach <a id="id509" class="indexterm"></a>the script to an object in your scene, preferably to the quad. Then, drag the material created for this effect to the <a id="id510" class="indexterm"></a>
<code class="literal">material</code> slot of the script. By doing this, the script will be able to access the material and initialize it.</p></li><li><p>Lastly, expand the positions, radiuses, and intensities fields of your script and fill them with the values of your heatmap. Positions indicate the points (in world coordinates) of your heatmaps, radii indicate their size, and intensities indicate how strongly they affect the surrounding area:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_10_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec171"></a>How it works…</h3></div></div></div><p>This shader relies on things that have never been introduced before in this book; the first one is arrays. Cg allows arrays that can be created with the following syntax:</p><div class="informalexample"><pre class="programlisting">uniform float3 _Points [20];    </pre></div><p>Cg doesn't support arrays with an unknown size: you must preallocate all the space that you need beforehand. The preceding line of code creates an array of 20 elements.</p><p>Unity does not <a id="id511" class="indexterm"></a>expose any method to initialize these arrays <a id="id512" class="indexterm"></a>directly. However, single elements are accessible using the name of the array (<code class="literal">_Points</code>) followed by the position, such as <code class="literal">_Points0</code> or <code class="literal">_Points10</code>. This currently works only for certain types of arrays, such as <code class="literal">float3</code> and <code class="literal">float2</code>. The script attached to the quad initializes the shader's arrays, element by element.</p><p>In the fragment function of the shader, there is a similar for loop that, for each pixel of the material, queries all the points to find their contribution to the heatmap:</p><div class="informalexample"><pre class="programlisting">half h = 0;
<span class="strong"><strong>for</strong></span> (int i = 0; i &lt; _Points_Length; i ++)
{
    // Calculates the contribution of each point
    half di = distance(output.worldPos, _Points[i].xyz);

    half ri = _Properties[i].x;
    half hi = 1 - saturate(di / ri);

    h += hi * _Properties[i].y;
}</pre></div><p>The <code class="literal">h</code> variable stores the heat from all the points, given their radii and intensities. It is then used to look up which color to use from the ramp texture.</p><p>The shaders and <a id="id513" class="indexterm"></a>arrays are a winning combination, especially as very few games are using them at their full potential. However, they introduce a <a id="id514" class="indexterm"></a>significance bottleneck as for each pixel, the shader has to loop through all the points.</p></div></div>