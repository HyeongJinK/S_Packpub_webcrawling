<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec38"></a>Extruding your models</h2></div></div><hr /></div><p>One of the biggest <a id="id283" class="indexterm"></a>problems in games is repetitions. Creating new content is a time-consuming task, and when you have to face thousands of enemies, chances are that they will all look the same. A relatively cheap technique to add variations to your models is using a shader that alters its basic geometry. This recipe will show you a technique called <a id="id284" class="indexterm"></a>
<span class="strong"><strong>normal extrusion</strong></span>, which can be used to create a chubbier or skinnier version of a model, as shown in the following picture with the soldier from the Unity camp demo:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_05_05.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec98"></a>Getting ready</h3></div></div></div><p>For this recipe, we need to have access to the shader used by the model that you want to alter. Once you have it, we duplicate it so that we can edit it safely. It can be done as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Find the shader your model is using and once selected, duplicate it by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span>.</p></li><li><p>Duplicate the original material of the model and assign the cloned shader to it.</p></li><li><p>Assign the new material to your model, and start editing it.</p></li></ol></div><p>In order for this effect to <a id="id285" class="indexterm"></a>work, your model should have <span class="strong"><strong>normals</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec99"></a>How to do it…</h3></div></div></div><p>To create this effect, start by modifying the duplicated shader:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's start by adding a property to our shader, which will be used to modulate its extrusion. The range presented here goes from <code class="literal">-1</code> to <code class="literal">+1</code>, but you might have to adjust this according to your own needs:</p><div class="informalexample"><pre class="programlisting">_Amount ("Extrusion Amount", Range(-1,+1)) = 0</pre></div></li><li><p>Couple the <a id="id286" class="indexterm"></a>property with its respective variable:</p><div class="informalexample"><pre class="programlisting">float _Amount;</pre></div></li><li><p>Change the <code class="literal">#pragma</code> directive so that it now uses a vertex modifier. You can do this by adding <code class="literal">vertex:function_name</code> at the end of it. In our case, we have called the function, <code class="literal">vert</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#pragma</strong></span> surface surf Lambert vertex:vert</pre></div></li><li><p>Add the following vertex modifier:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void</strong></span> vert (inout appdata_full v) {
  v.vertex.xyz += v.normal * _Amount;
}</pre></div></li><li><p>The shader is now ready; you can use the <span class="strong"><strong>Extrusion Amount</strong></span> slider in the material's <span class="strong"><strong>Inspector</strong></span> tab to make your model skinnier or chubbier.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec100"></a>How it works…</h3></div></div></div><p>Surface Shaders works in two steps. In all the previous chapters, we only explored its last one: the surface <a id="id287" class="indexterm"></a>function. There is another function that can be used: the <span class="strong"><strong>vertex modifier</strong></span>. It takes the data structure of a vertex (which is usually called <code class="literal">appdata_full</code>) and applies a transformation to it. This gives us the freedom to do virtually everything <a id="id288" class="indexterm"></a>with the geometry of our model. We signal the <span class="strong"><strong>graphics processing unit</strong></span> (<span class="strong"><strong>GPU</strong></span>) that such a function exists by adding <code class="literal">vertex:vert</code> to the <code class="literal">#pragma</code> directive of the Surface Shader. You can refer to <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Fragment Shaders and Grab Passes</em></span>, to learn how vertex modifiers can be defined in a Vertex and Fragment Shader instead.</p><p>One of the most simple, yet effective, techniques that can be used to alter the geometry of a model is called normal extrusion. It works by projecting a vertex along its normal direction. This is done by the following line of code:</p><div class="informalexample"><pre class="programlisting">v.vertex.xyz += v.normal * _Amount;</pre></div><p>The position of a vertex is displaced by <code class="literal">_Amount</code> units toward the vertex normal. If <code class="literal">_Amount</code> gets too high, the results can be quite unpleasant. With smaller values, however, you can add a lot of variations to your models.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec101"></a>There's more…</h3></div></div></div><p>If you have multiple enemies and want each one to have its own <span class="emphasis"><em>weight</em></span>, you have to create a different material for each one of them. This is necessary as materials are normally shared between models and changing one will change all of them. There are several ways in which you can do this; the quickest one is to create a script that automatically does it for you. The following script, once <a id="id289" class="indexterm"></a>attached to an object with a <code class="literal">Renderer</code>, will duplicate its first material and set the <code class="literal">_Amount</code> property automatically:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>using</strong></span> UnityEngine;
<span class="strong"><strong>public class</strong></span> NormalExtruder : MonoBehaviour {

  [Range(-0.0001f, 0.0001f)]
  <span class="strong"><strong>public float</strong></span> amount = 0;

  // Use this for initialization
  <span class="strong"><strong>void</strong></span> Start () {
    Material material = GetComponent&lt;Renderer&gt;().sharedMaterial;
    Material newMaterial = <span class="strong"><strong>new</strong></span> Material(material);
    newMaterial.SetFloat("_Amount", amount);
    GetComponent&lt;Renderer&gt;().material = newMaterial;
  }
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec12"></a>Adding extrusion maps</h4></div></div></div><p>This technique <a id="id290" class="indexterm"></a>can actually be improved even further. We can <a id="id291" class="indexterm"></a>add an extra texture (or use the alpha channel of the main one) to indicate the amount of the extrusion. This allows a much better control over which parts are raised or lowered. The following code shows you how it is possible to achieve such an effect:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sampler2D</strong></span> _ExtrusionTex;
<span class="strong"><strong>void</strong></span> vert(<span class="strong"><strong>inout</strong></span> appdata_full v) {
<span class="strong"><strong>float4</strong></span> tex = tex2Dlod (_ExtrusionTex, <span class="strong"><strong>float4</strong></span>(v.texcoord.xy,0,0));
  <span class="strong"><strong>float</strong></span> extrusion = tex.r * 2 - 1;
  v.vertex.xyz += v.normal * _Amount * extrusion;
}</pre></div><p>The red channel of <code class="literal">_ExtrusionTex</code> is used as a multiplying coefficient for normal extrusion. A value of 0.5 leaves the model unaffected; darker or lighter shades are used to extrude vertices inward or outward, respectively. You should notice that to sample a texture within a vertex modifier, <code class="literal">tex2Dlod</code> should be used instead of <code class="literal">tex2D</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"></a>Note</h3><p>In shaders, color <a id="id292" class="indexterm"></a>channels go from 0 to 1, although sometimes you need to represent negative values as well (such as inward extrusion). When this is the case, treat 0.5 as zero, having smaller values considered as negative and higher values as positive. This is exactly what happens with normals, which are usually encoded in RGB textures. The <code class="literal">UnpackNormal()</code> function is used to map a value in the range (0,1) on the range (-1,+1). Mathematically speaking, this is equivalent to <code class="literal">tex.r * 2 -1</code>.</p></div><p>Extrusion maps are perfect to zombify characters by shrinking the skin to highlight the shape of the bones underneath. The following picture shows you how a <span class="emphasis"><em>healthy</em></span> soldier can be transformed into a corpse using just a shader and extrusion map. Compared to the previous example, you <a id="id293" class="indexterm"></a>can notice how the clothing is unaffected. The shader used in the following picture also darkens the extruded regions to give an even more emaciated look to the soldier:</p><div class="mediaobject"><img src="/graphics/9781785285240/graphics/Image_4850_05_06.jpg" /></div></div></div></div>