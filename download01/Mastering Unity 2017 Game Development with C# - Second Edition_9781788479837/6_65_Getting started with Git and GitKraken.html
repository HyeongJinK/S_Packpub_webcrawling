<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec67"></a>Getting started with Git and GitKraken</h2></div></div><hr /></div><p>Let's start using the Git client, GitKraken, to manage the <span class="emphasis"><em>Dead Keys</em></span> project using version control with Git. By doing this, we'll be able to keep track of every change made to <span class="emphasis"><em>Dead Keys</em></span> from here onward, and we'll also be able to reverse <span>and</span> move forward through the development history, as needed. Before getting started with Git, let's clarify a few technical terms. These <span>are</span> presented in point form in a carefully selected order, as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Git is a software for tracking changes to a group of files and folders. The total collection of tracked files, including Git metadata for storing information about changes, is known as a <span class="strong"><strong>Repository</strong></span> (or <span class="strong"><strong>Repo</strong></span>). This is essentially a <span>folder</span> containing many files.</li><li style="list-style-type: disc">A Repo can be remote (stored on a web server) or local (stored on a local hard drive). Often, both types are involved. As a user downloads the remote version onto their local machine, they are creating a clone.</li><li style="list-style-type: disc">Creating a new Repo from <span>scratch</span> is called <span class="strong"><strong>Initializing</strong></span> a Repo (or <strong class="userinput"><code>Init</code></strong> for short).</li></ul></div><p>When you first start GitKraken, you'll be faced with three main options: <strong class="userinput"><code>Open</code></strong>, <strong class="userinput"><code>Clone</code></strong>, and <strong class="userinput"><code>Init</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/2e18041e-4879-4e37-9043-bea6f01db6fa.png" /></div><p>Getting started with GitKraken</p><p>These three main options (<strong class="userinput"><code>Open</code></strong>, <strong class="userinput"><code>Clone</code></strong>, and <strong class="userinput"><code>Init</code></strong>) have a technical meaning in the world of Git:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Open</code></strong>: This lets you pick a folder on the computer that contains a Local Repo. This contains all your Unity project files (as well as additional Git files for version control).</li><li style="list-style-type: disc"><strong class="userinput"><code>Clone</code></strong>: This lets you specify a Remote Repo to download.</li><li style="list-style-type: disc"><strong class="userinput"><code>Init</code></strong>: This lets you create a new empty Repo. Let's create a new Repo. To do this, click on the <strong class="userinput"><code>Init</code></strong> button:</li></ul></div><div class="mediaobject"><img src="/graphics/9781788479837/graphics/e9909f4d-35e8-4f50-a4b3-4400ed2261f4.png" /></div><p>Creating a new Repo</p><p>After selecting <strong class="userinput"><code>Init</code></strong>, you can choose where the Repo is created. You can create a Local Repo on the computer, or a Repo on <strong class="userinput"><code>GitHub.com</code></strong> or <strong class="userinput"><code>BitBucket.org</code></strong>. These are free, web-based servers for hosting Git Repos. Later, we'll use BitBucket. For now, let's create a Local Repo. To do this, select the <strong class="userinput"><code>Local</code></strong> tab, and enter a <strong class="userinput"><code>New repository path</code></strong> (this references a folder on the computer where the Repo should be created). The folder should be empty:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/739290de-f924-4b88-9dfd-b2ffd6a5b16e.png" /></div><p>Naming and locating the Repo</p><p>Next, we should choose a <strong class="userinput"><code>GitIgnore Template</code></strong>. This is a special text file included in the Git Repo, listing all file and <span>folder</span> types that Git should ignore when tracking. This is important because some files, such as user preference data and UI customizations, should remain local to a specific user. These should not be shared, because each <span>user</span> has their own UI preferences and customizations. The only files we should track are development-relevant files, and any files needed to support those. Thankfully, GitKraken ships with preconfigured GitIgnore files for specific programs that we can use immediately. Click on the <strong class="userinput"><code>.gitignore Template (optional)</code></strong> field, and then choose <strong class="userinput"><code>Unity</code></strong> from the dropdown. This configures the Repo to ignore user-preference data for Unity:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/2a7ac66c-dbc1-4f4c-a6ba-ad674e64f20a.png" /></div><p>Selecting a GitIgnore file</p><p>The GitIgnore file conforms to a specific Git syntax, and it uses wildcard symbols (<code class="literal">*</code>) to specify the different file types and naming conventions to be ignored. The GitIgnore file for Unity is as follows:</p><pre class="programlisting">/[Ll]ibrary/  
/[Tt]emp/  
/[Oo]bj/  
/[Bb]uild/  
  
# Autogenerated VS/MD solution and project files  
*.csproj  
*.unityproj  
*.sln  
*.suo  
*.tmp  
*.user  
*.userprefs  
*.pidb  
*.booproj  
  
# Unity3D generated meta files  
*.pidb.meta  
  
# Unity3D Generated File On Crash Reports  
sysinfo.txt </pre><p>Now, click on the <strong class="userinput"><code>Create Repository</code></strong> button to <span>generate</span> a new Repo and the <span class="emphasis"><em>GitKraken</em></span> interface will display the main Repo details. The Repo is empty to start with, with the exception of the Git metadata files, used internally to track <span>file</span> changes. Excellent! We now have our first Repo:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/45da8f88-69e2-4996-a99c-91a42f24a3c0.png" /></div><p>The Git Repo interfaces</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec67"></a>Commits and branches</h3></div></div></div><p>The Git Repo is a folder-based database of files and changes. A Repo is effectively a chronological sequence of project snapshots. It keeps <span>track</span> of the state of <span>your</span> project over time. A <span class="strong"><strong>Snapshot</strong></span> simply represents the complete state of your project at a specific date and time. When you first create a Repo, it consists of one Branch, called the <span class="strong"><strong>MasterBranch.</strong></span> A Branch represents a single, complete timeline of snapshots. A timeline is a <span>good</span> analogy because changes to the project happen over time, one after another, and each change builds from the ones before it along a continuous line or <span class="emphasis"><em>Branch</em></span>. The GitKraken interface indicates that a Branch (named Master) has been created and is currently active:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/685a4522-b606-49e6-a13f-8fc5de44f8f8.png" /></div><p>The active branch</p><p>The left-hand side column lists all branches in the Repo (there can be multiple branches). The topmost breadcrumb trail indicates the currently active branch. The active branch is simply the branch that tracks all the changes happening to the files. Let's now make our first change to the files by copying and pasting our Dead Keys project into our Git project folder. To do this, you can use Windows Explorer or Mac Finder to transfer the files:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/33a0b9b1-6561-4244-bf2e-fe9d0ba4a30b.png" /></div><p>Copying files into the Git Repo</p><p>After adding the files to the <code class="literal">Project</code> folder, GitKraken detects any changes and updates the interface with a new entry to the master branch. This appears at the top of the <strong class="userinput"><code>Tracked Changes</code></strong> list:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/616c78a6-ac91-4719-b5fc-372ae2eb19bc.png" /></div><p>New changes tracked on the Master Branch</p><p>The tracked changes are not yet part of the Repo. Right now, Git has only detected the changes and displayed them inside the interface. The <span class="emphasis"><em>green number</em></span> added to the list indicates the total number of files to which changes have been detected. In this case, 1,024 new files have been copied into the project folder, and these are all files included in the <span class="emphasis"><em>Dead Keys</em></span> Unity project. For Git to accept these files and add them to the Repo as part of the branch history, we must stage the files. This is about marking all the files that Git should track and maintain as part of the branch. For this initial change, we want to track and add all of the files in the project folder. <span>Select the new, topmost entry in the history list of GitKraken</span>, which represents the outstanding file changes in the project folder, and the <strong class="userinput"><code>Properties</code></strong> panel (on the right) displays more information about the files:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/64eff3a8-acd8-476a-82d8-d73e9cfc35f1.png" /></div><p>Selecting the changes</p><p>Each detected file where a new change has occurred is located by Git in one of two lists: <strong class="userinput"><code>Staged Files</code></strong> or <strong class="userinput"><code>Unstaged Files</code></strong>. All changes begin, by default, in the <strong class="userinput"><code>Unstaged List</code></strong>. This is a list of files where changes have occurred. Git will mostly ignore them until you specify that a specific file should be added to the <strong class="userinput"><code>Staged List</code></strong>. Files added to the Staged list simply remain together, in a collection, until you confirm that Git should acknowledge the changes, and then add them to the activate branch as a Snapshot (called a <span class="strong"><strong>Commit</strong></span>). Let's add all the new changes to the Staged List. To do this, click on the <strong class="userinput"><code>Stage all changes</code></strong> button from the <strong class="userinput"><code>Unstaged Files</code></strong> list:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/d198c2cf-33c8-4d8f-9264-587e1f377e93.png" /></div><p>Staging changes</p><p>This adds all <strong class="userinput"><code>Unstaged Files</code></strong> to the <strong class="userinput"><code>Staged List</code></strong>. By doing this, you are preparing to make a package (<span class="emphasis"><em>Commit</em></span>) to the active branch. Next, we'll need to name the Commit. A Commit represents all the recently changed files to save. This should be a general summative name, describing all the files to be staged. To do this, click on the entry name in the list and then rename it. I've used the name <strong class="userinput"><code>First Commit</code></strong> since it represents the initial stage of our development history:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/17c91b5a-b5f7-45c2-b72d-6f311c38c758.png" /></div><p>Naming the First Commit</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note45"></a>Note</h3><p>The first commit for Git represents the starting state of a project, even if the project is actually half-finished when the first commit is made. Git only allows you to forward and rewind between actual Commits, as we'll see. We <span class="emphasis"><em>cannot </em></span><span class="emphasis"><em>rewind</em></span> to earlier states of the project before the first commit. For this reason, it's a good practice to use Git from the outset of your project.</p></div><p>Now that we've <span>named</span> the commit, let's write a comment for it. This is a user-defined message, which can be anything we want, but it should be descriptive and meaningful. In addition, the message should be written in the <span class="emphasis"><em>Present tense</em></span> to <span>avoid</span> ambiguity about past work that has since changed and future work yet to be implemented. For example, avoid writing <span class="emphasis"><em>Added Path--finding function</em></span>, or <span class="emphasis"><em>Will Add Path--finding function</em></span>. Instead, write <span class="emphasis"><em>Adds Path--finding function</em></span>. This describes what the commit actually does. For the first commit, I'll write <span class="emphasis"><em>Initial State of Unity Project</em></span>; this is our starting point:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/069b17f1-8d87-40f2-8de8-1fa5a1d24a59.png" /></div><p>Commenting on the First Commit</p><p>Now click on <strong class="userinput"><code>Commit</code></strong>, and that's it! We've now created our <strong class="userinput"><code>First Commit</code></strong>, and this is updated in the branch history list. The topmost item in the list represents the latest <span class="emphasis"><em>Commit</em></span>, and this features our custom name and comment:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/b0ade108-10c2-41d6-a585-7798a11b665e.png" /></div><p>Added First Commit</p><p>You can select the commit in the branch history list to reveal more information in the <strong class="userinput"><code>Properties</code></strong> panel. Each Commit has a specific time and date, author, and a commit ID, which uniquely identifies the commit within the Repo:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/f5e5c78e-bac5-43ad-bf46-0eafc27cafe4.png" /></div><p>Viewing Commit Details</p><p>Great work! You've now made your first commit and have <span class="emphasis"><em>immortalized</em></span> the initial state of your project. The Commit represents a snapshot in the project, a saved state. This means we can easily return to this state, anytime later, if we need to.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec68"></a>Forward and backward with Git</h3></div></div></div><p>Let's test a practical case scenario for <span class="emphasis"><em>Dead Keys</em></span> when using Git. If you open the <span>Git</span> project folder in either Windows Explorer or the Mac Finder, the contents will <span>always</span> reflect the latest commit on the active branch:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/1a699ccc-6bb2-4fe3-a6a9-307f45273bc7.png" /></div><p>The Project folder represents the Latest Commit on the Active Branch</p><p>However, consider this, what if we made a mistake by creating the latest commit? What if we don't actually care about the latest commit (perhaps because it contains invalid files) and we want to undo it, restoring our work back to the previous commit? To achieve this, we can use the revert command. Simply right-click on the latest Commit in the branch history and choose <strong class="userinput"><code>Revert Commit</code></strong> from the context menu:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/0fd5ee0b-645b-4929-a30c-67d6bee72804.png" /></div><p>Reverting the latest commit</p><p>GitKraken then asks you <strong class="userinput"><code>Do you want to immediately commit the reverted changes?</code></strong> (to make the previous Commit the latest one); let's choose <strong class="userinput"><code>Yes</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/edb526bf-2918-4859-94f7-c0a42099a547.png" /></div><p>Confirming the revert</p><p>After reverting the latest Commit, Git will <span class="emphasis"><em>undo</em></span> all changes included in it. Git does this, however, not by removing the latest Commit per se, but by creating a new Commit reinstating the first. This highlights an important feature of Git--it never deletes anything! It always adds operations onto previous Commits. Thus, the act of undoing means deleting files or restoring earlier versions from the current state. Consequently, Git always lets you revert backward through the history, restoring any earlier commits that you need:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/7a0269ab-4de1-48fa-a932-bcae6692843e.png" /></div><p>Creating a new reverted commit</p><p>Remember that you can easily revert the reverted commit too! This effectively restores the <strong class="userinput"><code>First Commit</code></strong>, including all the <span class="emphasis"><em>Dead Keys</em></span> files:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/bccfffbc-dd9d-4ea6-aed6-3221c40643b6.png" /></div><p>Restoring the Dead Keys project files</p><p>Excellent! We can now make Commits and revert the latest Commit. Next, we'll jump into Unity and configure it for use with GitKraken, and Git more generally.</p></div></div>