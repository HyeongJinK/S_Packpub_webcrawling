<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec51"></a>Planning the zombie Artificial Intelligence</h2></div></div><hr /></div><p>The zombie character needs intelligence, that is, the ability to take appropriate actions and responses in front of the player. Specifically, the <span>zombie</span> should balance actions between idling, chasing, and attacking at appropriate times; to achieve this, we'll need <span class="strong"><strong>Artificial Intelligence</strong></span>. This essentially involves coding functionality to <span>help</span> the computer make good decisions under specific conditions where multiple outcomes are possible. AI (for video games) is not, however, about coding an inward consciousness or phenomenology, and it's not about replicating the workings of the human mind. Rather, it's about deciding how NPCs behave, and creating the illusion or appearance of intelligence to enhance the experience and <span>realism</span> for the player. For the zombie, we'll code AI using <span class="strong"><strong>Finite State Machines</strong></span>.</p><p>The FSM is essentially a decision-making structure. The simplest example of an FSM is a traffic light. This exists in only one of three possible states at any one time: red, amber, or green. The active color indicates what nearby traffic may legitimately do (for example, red means stop, and green means go). The FSM, conceptually, begins from the assumption that anything, from a traffic light to a zombie, has a finite number of behaviors or modes, and that only one of these may apply to the agent at any one time. The decision-making structure and logic, which determines the active state, is the FSM. When we think about a zombie character in the level, we may identify fourÂ possible states, which are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Idle</strong></span>: In this state, the <span>agent</span> is standing still, playing an Idle animation on loop. In this mode, the agent neither wanders nor attacks, but they have the potential to move into action; the potential to <span class="emphasis"><em>come alive</em></span>. Idle is a constant state of standby. It is also the initial or default state for all NPCs in <span class="emphasis"><em>Dead Keys</em></span>. The default state can be different for your game:</li></ul></div><div class="mediaobject"><img src="/graphics/9781788479837/graphics/5bd65660-0311-4b13-a698-6075e2a58b48.png" /></div><p>Idle state</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Chase</strong></span>: If, and when, an <span>agent</span> sees the player character, and when the player is also beyond the attack range, the agent enters Chase mode. In this mode, the agent continually moves toward the player using the navmesh, intending to get closer for an attack:</li></ul></div><div class="mediaobject"><img src="/graphics/9781788479837/graphics/4e84ca13-fb57-4951-aa8d-f42e17054451.png" /></div><p>Chase state</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Attack</strong></span>: After chasing the player, an <span>agent</span> may enter the attack range, that is, a measured distance or radius from the player character inside which an enemy agent can successfully attack and inflict damage. On entering the attack range, the enemy will repeatedly launch attacks. If the enemy leaves the attack range (for example, if the player runs away), the enemy will revert to Chase mode:</li></ul></div><div class="mediaobject"><img src="/graphics/9781788479837/graphics/99f191de-4efa-4534-88e5-796528cc75ac.png" /></div><p>Attack state</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Death</strong></span>: If the agent health falls to <span>zero</span> or below, it will die. In this state, the agent does nothing but play a death animation, fall to the floor, and become inactive. The Death state is, in many respects, a dead-end state--once entered, it has no route to any other state:</li></ul></div><div class="mediaobject"><img src="/graphics/9781788479837/graphics/c1a67cdd-0fe6-4ad8-8e90-4c8f70615357.png" /></div><p>Death state</p><p>Based on these <span>four</span> states, we can start coding an enemy class (<code class="literal">AIEnemy.cs</code>) and FSM, as follows:</p><pre class="programlisting">//------------------------------------ 
using UnityEngine; 
using System.Collections; 
using UnityEngine.EventSystems; 
using UnityEngine.Events; 
using UnityEngine.UI; 
//------------------------------------ 
public class AIEnemy : MonoBehaviour 
{ 
    //------------------------------------ 
    public enum AISTATE {IDLE = 0, CHASE = 1, ATTACK = 2, DEAD=3}; 
    [SerializeField] 
    private AISTATE mActiveState = AISTATE.IDLE; 
} </pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec53"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span>The</span><code class="literal">AIEnemy</code> class encapsulates all <span>enemy</span> behaviors, controlled by an FSM</li><li style="list-style-type: disc">To start coding an FSM, all possible states are encoded into an enumeration: Idle, Chase, Attack, and Dead</li><li style="list-style-type: disc">The <code class="literal">mActiveState</code> variable represents the currently active state right now, within the FSM</li></ul></div></div></div>