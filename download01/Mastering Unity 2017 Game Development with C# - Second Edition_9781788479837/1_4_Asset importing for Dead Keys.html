<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>Asset importing for Dead Keys</h2></div></div><hr /></div><p>The last section explored some general tips on preparing assets for Unity, with optimal performance in mind. These tips are general insofar as <span>they</span> apply to almost all asset types in almost all cases, including <span class="emphasis"><em>Dead Keys</em></span>. Now, let's focus on creating our project, <span class="emphasis"><em>DK</em></span>, a first-person zombie-typer game. This game relies on many assets, from meshes and textures to animation and sound. Here, we'll import and configure many core assets, considering optimization issues and asset-related subjects. We don't need to import all assets right now; we can, and often will, import later during development, integrating them into our existing asset library. This section assumes that you've already created a new Unity project. From here on, we can begin our work.</p><p>To prepare, let's create a basic folder structure in the <strong class="userinput"><code>Project</code></strong> panel to contain all imported assets in a systematic and organized way. The names I've used are self-descriptive and optional. The named folders are <code class="literal">animation</code>, <code class="literal">audio</code>, <code class="literal">audiomixers</code>, <code class="literal">Materials</code>, <code class="literal">meshes</code>, <code class="literal">music</code>, <code class="literal">prefabs</code>, <code class="literal">Resources</code>, <code class="literal">scenes</code>, <code class="literal">scripts</code>, and <code class="literal">textures</code>; feel free to add more, or change the names, if it suits your purposes:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/4ed22734-cdbf-4cdd-a827-bac0072a9536.png" /></div><p>Organizing the Project folder</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec20"></a>Importing textures</h3></div></div></div><p>The <code class="literal">textures</code> folder will contain all <span>textures</span> to be <span>used</span> by the project. Most importantly, this includes textures for the NPC zombie characters (hands, arms, legs, and so on) and the modular environment set. In <span class="emphasis"><em>Dead Keys</em></span>, the environment will be a dark industrial interior, full of dark and moody corridors and cross-sections. This environment will really be composed of many smaller, modular pieces (such as corner sections and straight sections) that are fitted together, used and reused, like building blocks, to form larger environment complexes. Each of the pieces in the modular set maps in UV space to the same texture (a Texture Atlas), which means that the entire environment is actually mapped completely by one texture. Let's quickly take a look at that texture:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/d246655e-9e2f-48ed-9c7a-d2c8ab839efc.png" /></div><p>Environment Atlas Texture</p><p>All textures for the project are included in the book companion files, in the <code class="literal">ProjectAssets/Textures</code> folder. These should be imported into a Unity project simply by dragging and dropping them together into the <strong class="userinput"><code>Project</code></strong> panel. Using this method, you can import multiple texture files as a single batch, as follows:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/c5d50599-91a9-44b0-9700-0b0e753ecb97.png" /></div><p>Importing textures into the project</p><p>By default, Unity incorrectly configures Normal Map textures as regular textures. It doesn't distinguish the texture type based on the image content. Consequently, after importing Normal Maps, you should configure each one properly. Select the <strong class="userinput"><code>Normal map</code></strong> from the <strong class="userinput"><code>Project</code></strong> panel, and choose <strong class="userinput"><code>Normal map</code></strong> from the <strong class="userinput"><code>Texture Type</code></strong> dropdown in the object <strong class="userinput"><code>Inspector</code></strong>; afterward, click on <strong class="userinput"><code>Apply</code></strong> to accept the change:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/a5e02d60-9391-482d-b71a-58bbfc9700c4.png" /></div><p>Importing and configuring Normal maps</p><p>Since every mesh in the modular environment sets maps to the same texture space (corners, straight sections, turns, and so on), we'll need to make some minor tweaks to the Atlas Texture settings for best results. First, select the Atlas Texture in the <strong class="userinput"><code>Project</code></strong> panel (<code class="literal">DiffuseComposite.png</code>) and expand the <strong class="userinput"><code>Advanced Group</code></strong> from the <strong class="userinput"><code>Inspector</code></strong> object; this offers us greater control over texture settings:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/0f24933d-f1e6-44da-897d-0f1f19e44676.png" /></div><p>Accessing advanced texture properties</p><p>To minimize any texture seams, breaks, and artifacts in the environment texture wherever two mesh pieces meet in the scene, change the texture <strong class="userinput"><code>Wrap Mode</code></strong> from <strong class="userinput"><code>Repeat</code></strong> to <strong class="userinput"><code>Clamp</code></strong>. <strong class="userinput"><code>Clamp</code></strong> mode ensures that edge pixels of a UV island are stretched continuously across the mesh, as opposed to repeated, if needed. This is a useful technique for reducing any seams or artifacts for meshes that map to a Texture Atlas.</p><p>In addition, remove the check mark from the <strong class="userinput"><code>Generate Mip Maps</code></strong> option. When activated, this useful optimization shows progressively lower-quality textures for a mesh as it moves further from the camera. This helps optimize the render performance at runtime. However, for Texture Atlases, this can be problematic, as Unity's texture resizing causes artifacts and seams at the edges of UV islands wherever two mesh modules meet. This produces <span>pixel</span> bleeding and distortions in the textures.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note7"></a>Note</h3><p>If you want to use Mip Maps with Atlas Textures without the risk of artifacts, you can pregenerate your own Mip Map levels, that is, produce lower-quality textures that are calibrated specifically to work with your modular meshes. This may require manual testing and retesting until you arrive at textures that work for you. You can generate your own Mip Map levels for Unity by exporting a DDS texture from Photoshop. The DDS format lets you specify custom Mip Map levels directly in the image file. You can download the DDS plugin for Photosho<span>p online</span> at: <a class="ulink" href="https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop" target="_blank">https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop</a>.</p></div><div class="mediaobject"><img src="/graphics/9781788479837/graphics/57075ef0-12e4-4bde-a775-3423868cacb8.png" /></div><p>Optimizing Atlas Textures</p><p>Finally, specify the maximum valid power-2 size for the Atlas Texture, which is <strong class="userinput"><code>4096</code></strong>. The <strong class="userinput"><code>Format</code></strong> can be <strong class="userinput"><code>Automatic Compressed</code></strong>. This will choose the best available compression method for the desktop platform; then, click on <strong class="userinput"><code>Apply</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/e50facc2-6c1c-4b3d-9777-48ee1dc01c68.png" /></div><p>Applying changes to the Texture Atlas</p><p>In this chapter, we'll put aside most of the UI concerns. However, all GUI textures should be imported as the <strong class="userinput"><code>Sprite (2D and UI)</code></strong> texture type, with <strong class="userinput"><code>Generate Mip Maps</code></strong> disabled. For UI textures, it's not necessary to follow the power-2 size rule (that is, pixel sizes of 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, <strong class="userinput"><code>2048</code></strong>, 4096, and so on):</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/5875577d-e54a-47f3-9a28-e721e38a37bf.png" /></div><p>Importing UI textures</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec21"></a>Importing meshes</h3></div></div></div><p>Ideally, you should import textures before meshes, as we've done here. This is because, on mesh import, Unity automatically creates materials and searches the project for all associated textures. On finding suitable textures, it assigns <span>them</span> to the materials before displaying the results on the mesh, even in the <strong class="userinput"><code>Project</code></strong> panel thumbnail previews. This makes for a smoother and easier experience. When you're ready to import meshes, just drag and drop them into the <strong class="userinput"><code>Project</code></strong> panel to the designated <code class="literal">meshes</code> folder. By doing this, Unity imports all <span>meshes</span> as a single batch. This project relies heavily on meshes--both animated character meshes for the NPC zombies and static environment meshes for the modular environment--as well as prop meshes and any meshes that you would want to include for your own creative flourish. These files (except your own meshes) are included in the book's companion files:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/5b5aa0cc-9bc5-4905-8de5-33d0fc04fd70.png" /></div><p>Importing meshes (both environment and character meshes)</p><p>Now, let's configure the modular environment meshes. Select all meshes for the environment, including <code class="literal">section_Corner</code>, <code class="literal">section_Cross</code>, <code class="literal">section_Curve</code>, <code class="literal">section_End</code>, <code class="literal">section_Straight</code>, and <code class="literal">section_T</code>. With the environment meshes selected, adjust the following settings:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Set the mesh <strong class="userinput"><code>Scale Factor</code></strong> to <code class="literal">1</code>, creating a 1:1 ratio between the model, as it was made in the modeling software, to how the model appears in Unity.</li><li style="list-style-type: disc">Disable <strong class="userinput"><code>Import BlendShapes</code></strong>; the environment meshes contain no blended shapes to import, and you can streamline to the import and re-import process by disabling the unnecessary options.
</li><li style="list-style-type: disc">Disable <strong class="userinput"><code>Generate Colliders</code></strong>; in many cases, we'd have enabled this setting. However, <span class="emphasis"><em>Dead Keys</em></span> is a first-person shooter with a fixed AI-controlled camera, as opposed to free roam movement. This leaves the player with no possibility of walking through walls or passing through floors.</li><li style="list-style-type: disc">Enable <strong class="userinput"><code>Generate Lightmap UVs</code></strong>, which generates a second UV channel. Unity automatically unwraps your meshes and guarantees no UV island overlap. You can further tweak light map UV generation using the <strong class="userinput"><code>Hard Angle</code></strong>, <strong class="userinput"><code>Pack Margin</code></strong>, <strong class="userinput"><code>Angle Error</code></strong>, and <strong class="userinput"><code>Area Error</code></strong> settings. However, the default settings work well for most purposes. The <strong class="userinput"><code>Pack Margin</code></strong> can, and perhaps should, be increased if your light map resolution is low, as we'll see in the next chapter. The angle and error settings should sometimes be increased or decreased to better accommodate light maps for organic and curved surfaces:</li></ul></div><div class="mediaobject"><img src="/graphics/9781788479837/graphics/e60bece8-888b-404f-8bb5-e9cbeebacdde.png" /></div><p>Configuring environment meshes</p><p>In addition to configuring the primary mesh properties, as we've seen, let's also switch to the <strong class="userinput"><code>Rig</code></strong> and <strong class="userinput"><code>Animations</code></strong> tab. From the <strong class="userinput"><code>Rig</code></strong> tab, specify <strong class="userinput"><code>None</code></strong> for the <strong class="userinput"><code>Animation Type</code></strong> field, as the meshes don't contain animation data:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/29abc0c5-6570-4292-9163-636bd7fd1565.png" /></div><p>Setting the Rig type for environment meshes</p><p>Next, switch to the <strong class="userinput"><code>Animations</code></strong> tab. From here, remove the check mark from <strong class="userinput"><code>Import Animation</code></strong>. The environment meshes have no animations to import; then, click on <strong class="userinput"><code>Apply</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/edd525c0-71cc-4bd2-9cd8-1cced938ab9f.png" /></div><p>Disabling Import Animation</p><p>Of course, <span class="emphasis"><em>Dead Keys</em></span> is about completing typing exercises to destroy zombies. The zombie character for our project is based on the public domain zombie character, available from <span class="emphasis"><em>Blend Swap</em></span> at: <a class="ulink" href="http://www.blendswap.com/blends/view/76443" target="_blank">http://www.blendswap.com/blends/view/76443</a>. This character has been rigged and configured in Blender for easy import to Unity. Let's configure this character now. Select the Zombie mesh in the <strong class="userinput"><code>Project</code></strong> panel and from the object <strong class="userinput"><code>Inspector</code></strong>, adjust the following settings:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Set the mesh <strong class="userinput"><code>Scale Factor</code></strong> to <code class="literal">1</code> to retain its original size.</li><li style="list-style-type: disc">Enable <strong class="userinput"><code>Import BlendShapes</code></strong> to allow custom vertex animation.</li><li style="list-style-type: disc">Disable <strong class="userinput"><code>Generate Colliders</code></strong>, as collision detection is not needed.</li><li style="list-style-type: disc">Enable <strong class="userinput"><code>Swap UVs</code></strong> if the texture doesn't look correct on the zombie model from the preview panel. If an object has two or more UV channels (and they sometimes do), Unity occasionally selects the wrong channel by default:</li></ul></div><div class="mediaobject"><img src="/graphics/9781788479837/graphics/4e4ddea4-eccb-4c1b-ad4c-0a386dba668b.png" /></div><p>Configuring a zombie NPC</p><p>Switch to the <strong class="userinput"><code>Animations</code></strong> tab and disable the <strong class="userinput"><code>Import Animation</code></strong> checkbox. The character mesh should, and will, be animated--performing actions such as walking and attacking animations. However, the character mesh file itself contains no animation data. All character animations will be applied to the mesh from other files:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/0ad12667-10f2-41d0-a1fd-68a1aae522b3.png" /></div><p>Disable Import Animation for the zombie NPC</p><p>That's great! Now, let's configure the character rig for Mecanim. This is about optimizing the underlying skeleton to allow the model to be animated. To do this, select the <strong class="userinput"><code>Rig</code></strong> tab from the <strong class="userinput"><code>Inspector</code></strong> object. For the <strong class="userinput"><code>Animation Type</code></strong>, choose <strong class="userinput"><code>Humanoid</code></strong>; and for <strong class="userinput"><code>Avatar Definition</code></strong>, choose <strong class="userinput"><code>Create From This Model</code></strong>. The Humanoid animation type instructs Unity to see the mesh as a standard bipedal human--a character with a head, torso, two arms, and two legs. This generic structure (as defined in the avatar) is mapped to the mesh <span>bones</span> and allows <span class="strong"><strong>Animation Retargeting</strong></span>. Animation Retargeting is the ability to use and reuse character animations from other files and other models on any humanoid:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/c0e96c8b-2120-493b-9e62-0bbe1695c9f2.png" /></div><p>Configuring the zombie rig</p><p>After clicking on the <strong class="userinput"><code>Apply</code></strong> button <span>for</span> the zombie character, a check mark icon appears next to the <strong class="userinput"><code>Configure...</code></strong> button. For some character meshes, an X icon may appear instead. A check mark signifies that Unity has scanned through all <span>bones</span> in the mesh and successfully identified a humanoid rig, which can be mapped easily to the avatar. An X icon signifies a problem, which can be either minor or major. A minor case is where a humanoid character rig is imported, but differs in subtle and important ways from what Unity expects. This scenario is often fixed manually in Unity, using the Rig Configuration Window (available by clicking on <strong class="userinput"><code>Configure...</code></strong>). In contrast, the problem can be major; for example, the imported mesh may not be humanoid at all, or else it differs so dramatically from anything expected that a radical change and overhaul must be made to the character from within the content creation software:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/a0426dd1-1241-459f-807c-215480c79d87.png" /></div><p>Character rig successfully configured</p><p>Even when your character rig is imported successfully, you should test it inside the <span class="strong"><strong>Rig Configuration Editor</strong></span>. This acts as a <span class="emphasis"><em>sanity check</em></span> and confirms that your rig is working as intended. To do this, click on the <strong class="userinput"><code>Configure...</code></strong> button from the <strong class="userinput"><code>Rig</code></strong> tab in the object <strong class="userinput"><code>Inspector</code></strong>; this displays the Rig Configuration Editor:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/6aa718a7-4f40-43a7-bc28-1bc8ae45cc9c.png" /></div><p>Using the Rig Configuration Editor to examine, test, and repair a skeleton avatar mapping</p><p>From the Rig Configuration Editor, you can see how imported bones map to the humanoid avatar definition. Bones highlighted in green are already mapped to the Avatar, as shown in the <strong class="userinput"><code>Inspector</code></strong> object, that is, imported bones turn green when Unity, after analysis, finds a match for them in the Avatar. The Avatar is simply a map or chart defined by Unity, namely, a collection of predetermined bones. The aim of the Rig Configuration Editor is to simply map the bones from the mesh to the avatar, allowing the mesh to be animated by any kind of humanoid animation.</p><p>For the zombie character, all bones will be successfully automapped to the avatar. You can change this mapping, however, by simply dragging and dropping specific bones from the Hierarchy panel to the bone slots in the <strong class="userinput"><code>Inspector</code></strong> object:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/fce21d05-7805-4b71-bae2-57ad1444f8df.png" /></div><p>Defining avatar mappings</p><p>Now, let's stress test our character mesh, checking its bone and avatar mapping and ensuring that the character deforms as intended. To do this, switch to the <strong class="userinput"><code>Muscles &amp; Settings</code></strong> tab from the <strong class="userinput"><code>Inspector</code></strong> object. When you do this, the character's pose changes immediately inside the viewport, which means it is ready for testing:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/17e51dc5-df1a-4fb0-ae7b-82ebbf6d6a44.png" /></div><p>Testing bone mappings</p><p>From here, use the character pose sliders in the <strong class="userinput"><code>Inspector</code></strong> object to push the character into extreme poses, previewing its posture in the viewport. The idea is to preview how the character deforms and responds to extremes. The reason such testing is necessary at all is that although bipedal humanoids share a common skeletal structure; they differ widely in body types and heights--some being short and small, and some being large and tall:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/c4b9e319-d63a-426b-ad13-9d562b6ea7d3.png" /></div><p>Testing extreme poses</p><p>If you feel your character breaks, intersects, or distorts in extreme poses, you can configure the mesh deformation limits, specifying a minimum and maximum range. To do this, first expand the <strong class="userinput"><code>Per-Muscle Settings</code></strong> group for the limbs or bones that are problematic, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/292b4838-a9ec-4669-bc92-4f66f9a99973.png" /></div><p>Defining pose extremes</p><p>Then, you can drag and resize the minimum and maximum thumb-sliders to define the minimum and maximum deformation extents for that limb, and for all limbs where needed. These settings constrain the movement and rotation of limbs, preventing them from being pushed beyond their intended limits during animation. The best way to use this tool is to begin with your character in an extreme pose that causes a visible break, and then to refine the <strong class="userinput"><code>Per-Muscle Settings</code></strong> until the mesh is repaired:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/8221133e-f03b-490f-a419-eb1788a1138a.png" /></div><p>Correcting pose breaks</p><p>When you're done making changes to the <span>rig</span> and pose, remember to click on the <strong class="userinput"><code>Apply</code></strong> or <strong class="userinput"><code>Done</code></strong> button from the <strong class="userinput"><code>Inspector</code></strong> object. The <strong class="userinput"><code>Done</code></strong> button <span>simply</span> applies the changes and then closes the Rig Configuration Editor:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/bb774d9f-5910-4250-b75b-9c491fd9f427.png" /></div><p>Applying rig changes</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec22"></a>Importing animations</h3></div></div></div><p>The <span class="emphasis"><em>Dead Keys</em></span> game features character animations for the zombies, namely walk, fight, and idle. These are included as FBX files. They can be imported into the <code class="literal">Animations</code> folder. The animations themselves are not intended for or <span>targeted</span> toward the zombies, but Mecanim's Humanoid Retargeting lets us reuse almost any character animations on any humanoid model. Let's now configure the animations. Select each animation <span>and</span> switch to the <strong class="userinput"><code>Rig</code></strong> tab. Choose <strong class="userinput"><code>Humanoid</code></strong> for the <strong class="userinput"><code>Animation Type</code></strong>, and leave the <strong class="userinput"><code>Avatar Definition</code></strong> at <strong class="userinput"><code>Create From This Model</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/489aea50-2d44-42a4-a2e3-f415e37a462d.png" /></div><p>Specifying a Humanoid animation type for animations</p><p>Now, move to the <strong class="userinput"><code>Animations</code></strong> tab. Enable the <strong class="userinput"><code>Loop Time</code></strong> checkbox to enable animation looping for the clip. Then, click on <strong class="userinput"><code>Apply</code></strong>. We'll have good cause to return to the animation settings in the later chapters, for further refinement, as we'll see:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/94ee0c29-60bb-40e1-9b42-703d4de33212.png" /></div><p>Enabling animation Loop Time for repeating animation clips</p><p>Now, let's explore a common problem with loopable walk animations that have root motion encoded. Root motion refers to the highest-level of transformation applied to an animated model. Most bone-based animation applies to lower-level bones in the bone hierarchy (such as arms, legs, and head), and this animation is always measured as relative to the topmost parent.</p><p>However, when the root bone is animated, it affects a character's position and orientation in world space. This is known as root motion. One problem that sometimes occurs with imported, loopable walk animations is a small deviation or offset from the neutral starting point in its root motion. This causes a mesh to drift away from its starting orientation over time, especially when the animation is played on a loop. To see this issue in action, select the walk animation for the zombie character, and from the object <strong class="userinput"><code>Inspector</code></strong>, preview the animation carefully. As you do this, align your camera view in the preview window in front of the humanoid character and see how, gradually, the character's walk deviates slowly from the center line on which he begins. This shows that, over time, the character continually drifts. This problem will not just manifest in the preview window, but in-game too:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/9af720c2-9dfe-42ee-96ed-11a3c662c538.png" /></div><p>Previewing walk cycle issues</p><p>This problem occurs as a result of walk-cycle inaccuracies in root motion. By previewing the <strong class="userinput"><code>Average Velocity</code></strong> field in the object <strong class="userinput"><code>Inspector</code></strong>, you'll see that the X motion field is a non-zero value, meaning that offset occurs to the mesh in X. This explains the cumulative deviation in the walk, as the animation is repeated:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/3c681c24-78b6-4756-970e-a05cd88bcc50.png" /></div><p>Exploring root motion problems</p><p>To fix this problem, enable the <strong class="userinput"><code>Bake Into Pose</code></strong> checkbox for the <strong class="userinput"><code>Root Transform Rotation</code></strong> section. This lets you override the <strong class="userinput"><code>Average Velocity</code></strong> field. Then, adjust the <strong class="userinput"><code>Offset</code></strong> field to compensate for the value of <strong class="userinput"><code>Average Velocity</code></strong>. The idea is to <span>adjust</span><strong class="userinput"><code>Offset</code></strong> until the <span>value</span> of <strong class="userinput"><code>Average Velocity</code></strong> is reset to <code class="literal">0</code>, indicating no offsetting. Then, click on <strong class="userinput"><code>Apply</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/7ee56efb-3ff2-4bb4-baaa-16333d22c5ad.png" /></div><p>Correcting root motion</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec23"></a>Importing audio</h3></div></div></div><p>Let's import game audio--specifically, the music track. This should be dragged and dropped into the <code class="literal">music</code> folder (the music track <code class="literal">narrow_corridors_short.ogg</code> is included in the book's companion files). Music is an important <span>audio</span> asset that greatly impacts loading times, especially on mobile devices and legacy hardware. Music tracks <span>often</span> exceed 1 minute in duration, and they encode a lot of data. Consequently, additional configuration is usually needed for music tracks to prevent them from burdening your games:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/eab8d12b-cbf3-4d61-9fda-505858c0f536.png" /></div><p>Importing audio files</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note8"></a>Note</h3><p>Ideally, music should be in a WAV format to prevent lossy compression when ported to other platforms. If WAV is not possible, then OGG is another valuable alternative. For more information on audio import settings, refer to the online Unity documentation at: <a class="ulink" href="http://docs.unity3d.com/Manual/AudioFiles.html" target="_blank">http://docs.unity3d.com/Manual/AudioFiles.html</a>.</p></div><p>Now, select the imported music <span>track</span> in the <strong class="userinput"><code>Project</code></strong> panel. Disable the <strong class="userinput"><code>Preload Audio Data</code></strong> checkbox, and then change the <strong class="userinput"><code>Load Type</code></strong> to <code class="literal">Streaming</code>. This optimizes the music loading process. It means that the music track will be loaded in segments during playback, as opposed to entirely in memory from the start of the level, and it will continually load, segment by segment. This prevents longer initial loading times:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/0d08759d-3757-40b6-a065-659a466656b5.png" /></div><p>Configuring music for streaming</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec24"></a>Configuring materials</h3></div></div></div><p>As a final step, let's configure mesh materials <span>for</span> the modular environment. By default, these are created and configured automatically by Unity on importing your meshes to the <strong class="userinput"><code>Project</code></strong> panel. They'll usually be added to a <code class="literal">materials</code> subfolder alongside your mesh. From here, drag and drop your materials to the higher-level <code class="literal">materials</code> folder in the project, organizing your materials together. Don't worry about moving your <span>materials</span> around for organization purposes, Unity will keep track of any references and links to objects:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/2e24c327-31f1-4498-b13e-758722eebd51.png" /></div><p>Configuring materials</p><p>By default, the <strong class="userinput"><code>DiffuseBase</code></strong> material for the modular environment is configured as a standard shader material, with some degree of glossiness. This makes the environment look shinier and smoother than it should be. In addition, the material lacks a <strong class="userinput"><code>Normal Map</code></strong> and Ambient Occlusion map. To configure the material, select the <strong class="userinput"><code>DiffuseBase</code></strong> material, and set the <strong class="userinput"><code>Shader</code></strong> type to <strong class="userinput"><code>Standard (Specular setup)</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/d84c092d-69ac-4c7e-8852-1a633660aff5.png" /></div><p>Changing Shader type</p><p>Next, assign the <strong class="userinput"><code>DiffuseBase</code></strong> texture to the <strong class="userinput"><code>Albedo</code></strong> slot (the main diffuse texture), and complete the <strong class="userinput"><code>Normal Map</code></strong> and <strong class="userinput"><code>Ambient Occlusion</code></strong> fields by assigning the appropriate textures, as found in the <code class="literal">textures</code> folder:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/13761551-4909-4ead-8098-4940b8016ef9.png" /></div><p>Completing the environment material</p></div></div>