<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec42"></a>The Typer object</h2></div></div><hr /></div><p>The <code class="literal">WordList</code> class supports the import and tokenization of a dictionary, generating an array of words on a line-by-line basis. The <code class="literal">GetRandomWord</code> function returns a randomly selected word from the dictionary, and the <code class="literal">CompareWord</code> function determines whether a typed word matches the chosen one entirely, partially, or not at all. Having now created this class, we begin work on the <code class="literal">Typer</code> class, which actually accepts typed input <span>from</span> the keyboard, processes that input, and displays UI complements for player feedback. Let's start by creating an object hierarchy. Create a new, empty object at the scene origin to act as the topmost node for <code class="literal">Typer</code>. Name the object <code class="literal">Typer</code> and then create a <code class="literal">Canvas</code> object as a child. The canvas contains all objects for the associated UI:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/ad16ca91-9174-490d-a825-cfd47e17bafa.png" /></div><p>Creating a Typer object</p><p>As with previous canvas components, we'll configure it to support multiple resolutions with a scaling technique. Set the <strong class="userinput"><code>UI Scale Mode</code></strong> to <strong class="userinput"><code>Scale With Screen Size</code></strong> and specify a <strong class="userinput"><code>Reference Resolution</code></strong> of <code class="literal">1920</code> x <code class="literal">1080</code>. The rationale for this is covered in depth in Chapter 3, <span class="emphasis"><em>Player Controls - Movement</em></span>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/7d9cc68f-b995-4777-9cd0-c6199e42634f.png" /></div><p>Configuring the Canvas Scaler for multiple resolutions</p><p>The canvas is necessary for showing UI elements as the <span>player</span> types on the keyboard during zombie combat. Specifically, as a new letter is typed, it should appear in the center of the screen as UI text and then zoom inward into the scene (away from the camera), as though it were a projectile being thrown at an oncoming zombie. To achieve this, start by creating a new <code class="literal">Text</code> object as a child of the <code class="literal">Canvas</code> object:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/c8a9bdb9-3adb-49b5-86a4-93841ce0a325.png" /></div><p>Creating a Text object as a child of the Typer's Canvas Scaler</p><p>Position the text in the screens center, previewing your results in the game tab, and then use stretch anchoring to align the left, right, top, and bottom text borders to the screen edges. In addition, from the Text component in the object <strong class="userinput"><code>Inspector</code></strong>, set the text horizontal alignment to the center of the screen and text vertical alignment to the center of the screen. This ensures <span>that</span> the text is always positioned at the center of the screen:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/6b6696d1-350f-4de5-b927-9675158864ef.png" /></div><p>Aligning text to the screen center</p><p>The text will be an animated UI element to <span>express</span> motion and impact, and attack whenever the gamer presses keys on the keyboard. Specifically, the text will zoom inward, growing smaller as it moves toward the center of the screen, replicating the effect of being thrown into the world toward attacking zombies. To start creating the animation, select the text object, and open the <strong class="userinput"><code>Animation</code></strong> window by choosing <strong class="userinput"><code>Window</code></strong> | <strong class="userinput"><code>Animation</code></strong> from the application menu. Two channels should be animated, namely <strong class="userinput"><code>Scale</code></strong> (for changing text size) and <strong class="userinput"><code>Color</code></strong> (for fading the alpha). Add these two channels by clicking on the <strong class="userinput"><code>Add Property</code></strong> button:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/8368ab15-9199-4eaa-937b-f7ee11db5893.png" /></div><p>Creating animation channels for Scale and Color</p><p>Use the first key frame (<span class="emphasis"><em>Frame 0</em></span>) to reset all text properties back to their defaults each time it plays. Specifically, set <strong class="userinput"><code>Text : Scale</code></strong> to <code class="literal">2</code> (a scale that fills the screen), and set <strong class="userinput"><code>Text : Color</code></strong> to an alpha of <code class="literal">0</code>, making the text invisible. Using the first key <span>frame</span> to reset object properties can be an effective strategy, especially for animations that play repeatedly or regularly, but not on a loop.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note32"></a>Note</h3><p>Keep the animation timeline between 0 to 1 second for the text attack animation. This means we can rescale the duration up or down as needed, while retaining control over total duration; hence, <span class="emphasis"><em>1 x t = t</em></span>, <span class="emphasis"><em>2 x t</em></span> = <span class="emphasis"><em>2t</em></span>, and so on.</p></div><div class="mediaobject"><img src="/graphics/9781788479837/graphics/5292a13c-7afa-4d49-9dca-0aba2f13706e.png" /></div><p>Setting text Scale and Color for the starting frame</p><p>For the second key frame (that is, <span class="emphasis"><em>Frame 1</em></span>), change <strong class="userinput"><code>Text : Color</code></strong> to <strong class="userinput"><code>Alpha</code></strong><code class="literal">1</code>, making the text visible. It doesn't matter what the text object actually says in the view port at design time, because the text will change programmatically <span>based</span> on keyboard input:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/1169c84d-9928-4124-aaa0-8c50a29602e9.png" /></div><p>Showing the text for an attack animation</p><p>Before inserting intervening frames, add the last frame to the timeline. It's good practice to <span class="emphasis"><em>block in</em></span> an animation, first by creating core key frames at the beginning, middle, and end. These define the main structure of motion. Then, later, refine those frames by adding intervening ones describing the changes between them. In our case, the last frame should shrink the text to a <strong class="userinput"><code>Scale</code></strong> of <code class="literal">0.2</code>, and reset the color Alpha back to <code class="literal">0</code>. This creates the effect of text being thrown into the scene, before disappearing, or fading, as it moves further from us:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/9475cb28-e402-4582-b169-c6af4f321b8c.png" /></div><p>Defining the last key frame</p><p>Right now, with only the start and end <span>frames</span> defined, text transparency fades to Alpha <code class="literal">0</code> from start to end. To keep the text visible and clearer for longer, we'll need an extra frame between the start and end to retain text visibility. Move to <code class="literal">0.33</code> in the timeline, and insert a color frame, keeping the Alpha at <code class="literal">255</code> (or 1 in normalized values). This holds text color between times <code class="literal">0</code>-<code class="literal">0.33</code>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/9551cc25-e270-4687-b027-73bfd908ea6f.png" /></div><p>Holding text color between time 0-0.33</p><p>Remember to disable animation looping for the clip. The animation will probably play frequently, but not on a loop. Select the clip from the <strong class="userinput"><code>Project</code></strong> panel and disable the <strong class="userinput"><code>Loop Time</code></strong> checkbox:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/2de7e3f4-7069-4673-a1f9-d8f17ea5ec65.png" /></div><p>Disable animation looping</p><p>This completes the text animation itself. It's pretty simple, but despite this simplicity, its importance in-game cannot be understated for usability reasons. It will serve several important design functions. Firstly, it offers feedback (confirming that a key was pressed), secondly, it educates by asserting the primary game mechanic (text typing as an aggressive and combative act), and, thirdly, it expresses the <span class="emphasis"><em>direction of action</em></span> (text moving away from the viewer) as an action that damages enemies in front of us. Thus, wrapped up in a simple UI animation, without reliance on text instructions, we educate the player on how to play and on <span>the</span> importance of their actions.</p><p>Now, let's configure the associated animator graph that, by default, always plays the first animation clip at level startup. Open the graph editor and create a new trigger parameter called <strong class="userinput"><code>ThrowText</code></strong>. This parameter will be invoked whenever text is typed in combat:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/6c7f485f-1c64-47f7-ba6d-b113f58a80fa.png" /></div><p>Creating a ThrowText trigger parameter</p><p>Next, create an empty node as the starting, default node for the graph by simply right-clicking and selecting <strong class="userinput"><code>Create State</code></strong> | <strong class="userinput"><code>Empty</code></strong> from the context menu. Then, right-click on the node and select <strong class="userinput"><code>Set as Layer Default State</code></strong>. Connect the empty node to the <strong class="userinput"><code>ThrowTextAnim</code></strong> animation, and use the <strong class="userinput"><code>ThrowText</code></strong> trigger as a condition:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/1f4b3d0c-0cd5-42e6-a996-de0acf37e76d.png" /></div><p>Connecting the starting node to Throw Text by a trigger condition</p><p>Don't forget to add a backward transition from the animation node to the idle node. Simply create a transition without a condition and enable <strong class="userinput"><code>Has Exit Time</code></strong>. This ensures that animation flow returns to the idle node after the text animation is complete. You may also need to select the animation node and change its speed to match your needs. I've set my speed to five:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/1686c951-a535-4712-bdc6-6197f634b7c9.png" /></div><p>Creating a two-way node connection</p><p>Voila! We've now created a text-throw animation and configured this alongside an animator graph with a trigger. The next step is to link the animation to code that accepts user input.</p></div>