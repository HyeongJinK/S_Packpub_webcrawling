<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec41"></a>Matching words</h2></div></div><hr /></div><p>Determining whether two words <span>match</span> is an important function for <span class="emphasis"><em>Dead Keys</em></span>. When a player enters a word during combat, we must ascertain several features of that word compared to the chosen one from the word list:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Complete word matches</strong></span>: A complete word <span>match</span> occurs when the player fully and correctly types the selected word, letter for letter. This results in a zombie being killed and is a measure of progress in the scene. Detecting complete word matches is, therefore, important for progressing gameplay.</li><li style="list-style-type: disc"><span class="strong"><strong>Failed matches</strong></span>: A failed <span>word</span> match occurs when the player's most recent keypress fails to match any selected words (there can be multiple zombies) and therefore invalidates any partial matches there may have been up to that point. When a failed match occurs, the player's input is reset, and they must retype the word from the first letter.</li><li style="list-style-type: disc"><span class="strong"><strong>Partial word matches</strong></span>: A partial match occurs <span>when</span> the player is on their way to entering and completing a word but has yet to type every letter. Some letters will have been entered correctly, but there are additional letters outstanding to make a complete match. Detecting partial matches is important for two main reasons: it helps us identify which zombie the player is targeting, as each zombie represents a different word, and it lets us update the UI with appropriate feedback, indicating how much of the selected word has been matched so far, through color coded text or interface elements.</li></ul></div><p>The <code class="literal">CompareWords</code> function should be added to the <code class="literal">WordList</code> class. Its return value indicates which of the three mentioned matches is true:</p><pre class="programlisting">    //------------------------------------
    //Compares two strings and returns the extent of a match
     //EG: s1="hello" and s2="helicopter" the result = "hel"
    public static string CompareWords(string s1, string s2)
    {
        //Build resulting string
        string Result = string.Empty;

        //Get shortest length
        int ShortestLength = Mathf.Min(s1.Length, s2.Length);

        //Check for string match
        for (int i = 0; i &lt; ShortestLength; i++)
        {
             if (s1 [i] != s2 [i])
             return Result;

             Result += s1[i];
        }

        //Output result
        return Result;
     }
     //------------------------------------</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec47"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">CompareWords</code> function accepts <span>two</span> string arguments for comparison.</li><li style="list-style-type: disc">The comparison proceeds by comparing letters for the length of the shortest string.</li><li style="list-style-type: disc">The returned value is a string whose contents reflect the extent of a match. An empty string results in <span class="emphasis"><em>no match</em></span>, and either partial or complete strings are returned for partial or complete matches. Thus, the <code class="literal">hel</code> and <code class="literal">hello</code> strings return <code class="literal">hel</code>, and the <code class="literal">door</code> and <code class="literal">don't</code> strings return <code class="literal">do</code>. Thus, the function returns a new string defining a letter-by-letter match from the first letter onward.</li></ul></div><p>That's it! We've created a <code class="literal">WordList</code> class. Let's see the full source code for that:</p><pre class="programlisting">//------------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
//------------------------------------
public class WordList : MonoBehaviour
{
    //------------------------------------
   //Text asset featuring word list
   public TextAsset FileWordList = null;
   public string[] Words;

   //Members for Singleton
   public static WordList ThisInstance
   {
       get
       {
            //Get or create singleton instance
            if (m_WL == null)
             {
                GameObject GO = new GameObject ("WordList");
                ThisInstance = GO.AddComponent&lt;WordList&gt; ();
                }

                return m_WL;
           }
           set
           {    
            //If not null then we already have instance
            if (m_WL != null)
            {
                //If different, then remove duplicate immediately
                if(m_WL.GetInstanceID() != value.GetInstanceID())
                    DestroyImmediate (value.gameObject);

                return;
            }
           //If new, then create new singleton instance
           m_WL = value;
           DontDestroyOnLoad (m_WL.gameObject);
        }
     }
     private static WordList m_WL = null;
     //------------------------------------
     // Use this for initialization
     void Awake ()
     {
         //Set singleton instance
         ThisInstance = this;

         //Now load word list, if available
         if (FileWordList == null)
             FileWordList = (TextAsset) Resources.Load("WordList");

        Words = FileWordList.text.Split (new[] {"\r\n" }, System.StringSplitOptions.None);

    }
    //------------------------------------
    //Returns a random word from the word list
    public string GetRandomWord()
    {
         return Words[Random.Range(0, Words.Length)].ToLower();
     }
     //------------------------------------
     //Compares two strings and returns the extent of a match
    //EG: s1="hello" and s2="helicopter" the result = "hel"
    public static string CompareWords(string s1, string s2)
    {
        //Build resulting string
        string Result = string.Empty;

        //Get shortest length
        int ShortestLength = Mathf.Min(s1.Length, s2.Length);

        //Check for string match
        for (int i = 0; i &lt; ShortestLength; i++)
        {
             if (s1 [i] != s2 [i])
                 return Result;

                 Result += s1[i];
        }

        //Output result
        return Result;
     }
     //------------------------------------
}
//------------------------------------</pre><p>Most classes in Unity must be added to game objects as components. This often requires us to create empty objects in the scene and then drag and drop our scripts onto them from the Project panel. However, we don't need to do this for <code class="literal">WordList</code>, because its Singleton functionality automatically instantiates a new instance, if one is not already instantiated, whenever it's referenced anywhere in the script through the <code class="literal">ThisInstance</code> C# property.</p></div></div>