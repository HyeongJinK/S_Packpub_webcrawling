<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec47"></a>Bonus items</h2></div></div><hr /></div><p>Now, let's focus on a distinct and extensible feature, namely bonuses or rewards. Reward systems and positive feedback are important properties for <span>games</span> wherever the player repeatedly encounters time-critical challenges. When provided judiciously and appropriately, rewards reinforce the player's successes, making them feel good, and encouraging them to play on. It's important not to over or under-reward. By under-rewarding, you make the game seem too difficult or boring, and by over-rewarding, you remove the challenge and desensitize the player to rewards completely.</p><p>Rewards take many forms, from Steam achievements, certificates, and badges, to power-ups and extra items. For more information on player motivation and in-game achievements, check out the book <span class="emphasis"><em>Gamification with Unity 5.x</em></span>, <span class="emphasis"><em>Packt</em></span> (<a class="ulink" href="https://www.packtpub.com/game-development/gamification-unity-5x" target="_blank">https://www.packtpub.com/game-development/gamification-unity-5x</a>). In <span class="emphasis"><em>Dead Keys</em></span>, we'll reward the player with collectible badges. These are issued based on typing time, that is, when the player types and completes a word successfully, while also beating a minimum <span class="emphasis"><em>letters per minute record</em></span>, they'll be rewarded with an achievement badge. These will appear horizontally at the bottom of the screen and accumulate through the level as the player collects rewards. The reward asset is included in the book companion files and should be imported into the project (if you've not already imported it) as a 2D sprite texture:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/71c8492c-4ab9-46b8-8f35-773075ca538c.png" /></div><p>Importing a rewards badge icon</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p>Remember that the <strong class="userinput"><code>Generate <strong class="userinput"><code>M</code></strong></code></strong><strong class="userinput"><code>ip Maps</code></strong> option should be disabled for 2D sprites, which appear in the UI. Mip mapping reduces texture quality as it moves further from the camera. We neither need nor want such quality reduction in this case.</p></div><p>The UI needs for the bonus objects are distinct from the other UI elements we've been working on. The bonus objects accumulate over time, appearing one by one, in a row at the bottom of the screen as they're collected. To achieve this, we'll make some bonus objects in the editor, and the game will simply hide and show these objects as needed. However, we still want a clean and easy mechanism for arranging the bonus objects in a row, as opposed to relying on manual alignment for each one. To get started, create a canvas object, configured to <span class="emphasis"><em>Stretch with Screen Size</em></span>. Then, add an image object as a child, configured to display the bonus sprite:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/5182e0db-37c3-4218-b4a8-a5c932f6d86c.png" /></div><p>Creating an initial bonus object</p><p>Now, we can create more bonus objects by duplicating the existing ones and repositioning them wherever they're needed. However, this grows tedious quickly, especially when creating many objects. Instead, we can use a <strong class="userinput"><code>Horizontal Layout Group</code></strong>, which forces Unity to automatically align and position horizontal elements. Let's see how this works. Select the parent canvas object, and then choose <strong class="userinput"><code>Component</code></strong> | <strong class="userinput"><code>Layout</code></strong> | <strong class="userinput"><code>Horizontal Layout Group</code></strong> to add a <strong class="userinput"><code>Horizontal Layout Group</code></strong> component to the object. Doing this may change the appearance, size, or layout of the bonus graphic:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/228f8d9d-a2dd-453d-ac0a-214c0ed279af.png" /></div><p>Adding a Horizontal Layout Group</p><p>After adding a <strong class="userinput"><code>Horizontal Layout</code></strong><strong class="userinput"><code>Group</code></strong> to the <span>canvas</span> object, you can duplicate the bonus objects to add more. When you do this, all new instances are automatically aligned side by side in a row because of the <strong class="userinput"><code>Horizontal Layout Group</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/9fc286c1-1af8-4ef4-8f8b-762a2bb6ea84.png" /></div><p>Duplicating bonus objects, aligning them in a row via the Horizontal Layout Group</p><p>The relative spacing between elements can be controlled by the <strong class="userinput"><code>Horizontal Layout Group</code></strong>. Simply increase or decrease the spacing field from the object <strong class="userinput"><code>Inspector</code></strong>. In my case, the bonus icons appear with too much pixel spacing between them. We can reduce the spacing by setting the spacing field to a negative value:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/37b23df3-590e-42d3-bdf4-fd1abc76c3b6.png" /></div><p>Changing the pixel spacing between UI elements</p><p>By default, the <strong class="userinput"><code>Horizontal Layout Group</code></strong> overrides the width and height settings for each element, working to accommodate the total number of elements in a row. This can often be problematic when you want specific sizes, or different sizes for each element. You can control this, however, by adding a <strong class="userinput"><code>Layout Element</code></strong> component to each element in the row. To do this, select each bonus object and choose <strong class="userinput"><code>Component</code></strong> | <strong class="userinput"><code>Layout</code></strong> | <strong class="userinput"><code>Layout Element</code></strong> from the application menu. This adds a <strong class="userinput"><code>Layout Element</code></strong> component to each object:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/14c9fe1b-60cc-492a-8ac1-1e55688f4095.png" /></div><p>Adding a Layout Element to a bonus object, controlling the size of each element</p><p>Next, use the minimum and preferred size fields to control the size of the bonus object. For <span class="emphasis"><em>Dead Keys</em></span>, the bonus object is 256x265 pixels. The minimum field specifies the smallest size an element can possibly be in any circumstances and Unity will never shrink an element smaller than that size, even if more elements are added to the row <span>and</span> cannot fit on screen. The preferred field, instead, specifies the ideal size for an element whenever that size is possible; otherwise, the element may be resized to smaller dimensions if it's necessary to make room for more elements:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/c6bf1eb7-acd3-45f1-8f59-96a319abbc5c.png" /></div><p>Configuring a Layout Element within a group</p><p>Now, label all the bonus objects with a <strong class="userinput"><code>BonusObject</code></strong> tag (create this tag, if necessary). This is important for helping Unity quickly identify bonus objects in code at scene startup, as these should be hidden until a bonus is achieved:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/3be27f46-8b97-4bdd-9db6-7cca4638d065.png" /></div><p>Tagging bonus objects</p><p>Next, create a <code class="literal">UIBonus.cs</code> script file and assign this to the canvas parent object. This script hides all bonus objects at level startup and determines whether a bonus object should be hidden. Comments are included after the following code sample:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
public class UIBonus : MonoBehaviour  
{ 
    public GameObject[] BonusObjects; 
 
    // Use this for initialization 
    void Awake ()  
    { 
        BonusObjects = GameObject.FindGameObjectsWithTag ("BonusObject"); 
    } 
     
    // Update is called once per frame 
    void Update () 
    { 
        ///Set bonus level 
        //Hide/Show all bonus objects 
        for (int i = 0; i &lt; BonusObjects.Length; i++)  
        { 
            if (i &lt; GameManager.ThisInstance.BonusLevel) 
                BonusObjects [i].SetActive (true); 
            else 
                BonusObjects [i].SetActive (false); 
        } 
    } 
} </pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec52"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">BonusObjects</code> array references all <span>scene</span> objects tagged as <code class="literal">BonusObject</code>. This will refer to one or more objects.</li><li style="list-style-type: disc">The <code class="literal">GameManager</code> class, which is an overarching class that persists across scenes, maintains the <code class="literal">BonusLevel</code> variable. This is an integer determining how many bonus objects have been collected, if any.</li><li style="list-style-type: disc">The <code class="literal">Update</code> function cycles through all bonus objects, and enables them depending on the size of <code class="literal">BonusLevel</code>. This makes sense because, as additional bonus levels are reached, more bonus objects should become visible.
</li><li style="list-style-type: disc">The order of bonus objects in the array is irrelevant as the <strong class="userinput"><code>Horizontal Layout Group</code></strong> automatically resizes and reorders only active objects. Thus, as bonus objects become active, they'll be added and resized as needed within the <strong class="userinput"><code>Layout</code></strong> group.</li></ul></div><p>Excellent work! We've now coded a bonus system from which specific bonus objects may be unlocked using the <code class="literal">BonusLevel</code> integer variable. This is good, but still we don't have the functionality to actually collect a bonus in game, even though the framework is now in place. To achieve this, we'll need a zombie to destroy.</p></div></div>