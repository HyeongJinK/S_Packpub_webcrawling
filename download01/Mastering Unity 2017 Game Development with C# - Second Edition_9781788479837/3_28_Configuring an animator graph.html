<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec33"></a>Configuring an animator graph</h2></div></div><hr /></div><p>The animation clip defines an animation in <span>terms</span> of key frames, graphs, and states. This includes all camera animations created so far. Specifically, an animation clip defines the content of an animation. However, the animation clip doesn't define when it should play during gameplay. To control playback, an Animator component and animator controller is needed for the navigator object. Unity creates these assets automatically when you create your first animation clip. Additionally, Unity configures the assets and attaches them to the selected object so that it always plays the first animation when the level begins. However, this is not the behavior we actually want. We can easily tweak the generated assets to behave differently, to play when instructed, for example. However, let's start this process from scratch, deleting all the autogenerated assets (the Animator component and animator controller). This is not essential, but doing this demonstrates how an animator is configured manually. To remove all autogenerated assets for animation, select the navigator object and remove the Animator component from the object <strong class="userinput"><code>Inspector</code></strong>. Click on the cog icon and choose <strong class="userinput"><code>Remove Component</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/6d3db19e-6d71-49dc-98ed-2ded74e519fb.png" /></div><p>Removing the autogenerated Animator component</p><p>Next, find the generated animator controller <span>asset</span> in the <strong class="userinput"><code>Project</code></strong> panel and delete it. This removes all autogenerated assets for animation, allowing us to begin again from a clean slate:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/537f25f8-c358-4a3e-a8bb-97b1ea9bc33f.png" /></div><p>Removing animator controllers</p><p>To start again, create a new animator controller named <code class="literal">animControl_Navigator</code>, by right-clicking on the <strong class="userinput"><code>Project</code></strong> panel and choosing <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>Animator</code></strong><strong class="userinput"><code>Controller</code></strong> from the context menu:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/96bf99d5-8c02-4268-902b-b0d1d18006c3.png" /></div><p>Creating an Animator Controller</p><p>You now need to add an Animator component to the camera (or rather, to the <strong class="userinput"><code>Navigator</code></strong>, which is a top-level object), and then drag and drop the newly created <strong class="userinput"><code>Animator Controller</code></strong> asset into the Controller field of the Animator component. This assigns an <strong class="userinput"><code>Animato</code></strong><strong class="userinput"><code><strong class="userinput"><code>r</code></strong> Controller</code></strong> to the Animator component:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/d14547a1-83d2-43b2-af18-1edda2cf145e.png" /></div><p>Assigning an Animator Controller</p><p>Ensure that <strong class="userinput"><code>Apply Root Motion</code></strong> is not enabled <span>and</span> that <strong class="userinput"><code>Update Mode</code></strong> is <strong class="userinput"><code>Normal</code></strong> and <strong class="userinput"><code>Culling Mode</code></strong> is <strong class="userinput"><code>Always Animate</code></strong>. The <strong class="userinput"><code>C<strong class="userinput"><code>ul</code></strong></code></strong><strong class="userinput"><code>ling Mode</code></strong> field, when set to <strong class="userinput"><code>Cull Completely</code></strong>, effectively links animation playback to the visibility of the object's mesh renderer. This can enhance performance, as animations only play when the mesh is actually visible. However, this, of course, doesn't apply to the camera object, which has no mesh renderer component. To configure the animator controller for animation playback, double-click on it inside the Project panel. This opens the controller by default in the <strong class="userinput"><code>Animator</code></strong> window. This offers visual scripting control over high-level animation playback. By default, the node graph features two autocreated nodes, specifically, <strong class="userinput"><code>Any State</code></strong> and <strong class="userinput"><code>Entry</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/00ddd0fc-94ed-4ead-9e6e-ff71f6269692.png" /></div><p>Accessing the animator graph</p><p>The <strong class="userinput"><code>Entry</code></strong> node is fired once; for the first time, the Animator component is enabled on an active object. This is an example of a State Machine- that is, at level start-up the <strong class="userinput"><code>Entry</code></strong> node (or state) becomes activated. Now, unless the object is deactivated in the editor, through script, or the Animator component is disabled, the <strong class="userinput"><code>Entry</code></strong> node will fire normally on level startup. The <strong class="userinput"><code>Entry</code></strong> node is, therefore, useful to connect to any other nodes, or states, that must execute as the level begins. For the camera object, however, we don't need an animation played; but we do need the camera to simply remain as it is until further notice. To achieve this, we'll create an empty node, which simply leaves the camera unchanged and remains this way in a loop (idle state), that is, it holds graph execution at that node and remains there until a condition causes the state to change. Right-click inside the graph and choose <strong class="userinput"><code>Create State</code></strong> | <strong class="userinput"><code>Empty</code></strong> from the context menu. This adds a new empty node to the graph:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/1a3fc2e4-4b3b-4ef4-96b3-371ec4a711be.png" /></div><p>Creating a new animator state for the camera</p><p>By default, the first added node becomes the default node <span>and</span> is highlighted in orange. The default node is always connected to the <strong class="userinput"><code>Entry</code></strong> node. Select the newly created node by clicking on it and rename it to <code class="literal">Idle</code>. The <strong class="userinput"><code>Motion</code></strong> field should specify <strong class="userinput"><code>None (Motion)</code></strong>. This represents the animation clip that should play when the node is activated. When this field is set to <strong class="userinput"><code>None (Motion)</code></strong>, no animation clips play, and the camera object will be left as is, unchanged from its starting state. Remove the check mark from the <strong class="userinput"><code>Write Defaults</code></strong> checkbox too (which resets the object's state to its default settings when the animation clip completes playback):</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/bf991c12-66a6-4cb0-afc0-f16058514ed1.png" /></div><p>Setting properties for the Idle state</p><p>The <strong class="userinput"><code>Idle</code></strong> node represents the camera when it's neither animated nor moving through a path in the scene. It should always be active whenever the camera is motionless. This will usually be because the player is fighting zombies by matching words. Thus, the Idle node is the first and neutral state in a <span class="strong"><strong>Finite State Machine</strong></span> (<span class="strong"><strong>FSM</strong></span>). We'll cover more about FSMs later in this chapter, and later in this book. This means that all other <span>nodes</span> will, in some way, be connected to the <strong class="userinput"><code>Idle</code></strong> node, as the camera changes from being in motion to being motionless. To start building the graph, drag and drop all camera animation clips from the Project panel into the animator graph, where they will be automatically added as new nodes:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/b4c76838-762e-449b-ab5f-8333de44210e.png" /></div><p>Adding animation nodes to the animator graph</p><p>Once added, rename each clip appropriately and connect them in a sequence (or chain) to the <strong class="userinput"><code>Idle</code></strong> state. As the movement of the camera in <span class="emphasis"><em>Dead Keys</em></span> is linear (moving from point to point), the graph nodes can be connected one after another in an unbroken sequence. Specifically, the camera stops, the player attacks, and then the camera moves to the <span>next</span> destination, and so on. Although the potential exists for branching paths, the first level has only one possible route that may be taken. To create connections between nodes, simply right-click on the first node and choose <strong class="userinput"><code>Make Transition</code></strong> from the context menu. Then, select the destination node to establish the connection:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/755f3a42-8c84-42a4-a273-2e64dca9d1d6.png" /></div><p>Mapping the camera path as a linear sequence of nodes</p><p>The linear sequence is made between the nodes, but the transitions themselves need configuring. A transition determines when one state should change to another. By default, all transitions are unconditional; they simply allow the first state to move to the second when playback is complete. Now, let's configure some conditions for each transition. Start by creating an <strong class="userinput"><code>Int</code></strong> parameter, called <code class="literal">NavState</code>. The values of this variable will reflect the states of the camera (0 = starting state, 1 = travel to next location, 2 = travel to next location, and so on). To create the parameter, click on the + icon from the <strong class="userinput"><code>Parameters</code></strong> list, and choose <strong class="userinput"><code>Int</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/dbc2de1d-4ec5-4ab7-8a47-919321031720.png" /></div><p>Creating an Int parameter in the animator graph</p><p>The Int parameter should have the default value of 0. If not, it can be specified in the <strong class="userinput"><code>Parameters</code></strong> list. Now, select each transition in turn (the arrow connecting the nodes), and set the condition from the object <strong class="userinput"><code>Inspector</code></strong> using the equals operation. Specifically, to transition from <strong class="userinput"><code>Idle</code></strong> to <strong class="userinput"><code>Move_01</code></strong>, the <code class="literal">NavState</code> parameter should be equal to <code class="literal">1</code>; a value of 2 transitions between <strong class="userinput"><code>Move_01</code></strong> and <strong class="userinput"><code>Move_02</code></strong>, and so on. Using an Int parameter in this way <span>gives</span> us the ability to transition between any number of nodes:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/976c2a12-fda7-41ae-956a-018f9dee1447.png" /></div><p>Specifying transition conditions</p><p>Each transition features a <strong class="userinput"><code>Has Exit Time</code></strong> boolean field. When enabled, as it is by default, the full length of the animation always plays when the node is activated, and the state can only change after the animation completes, or more accurately, the settings roll-out specifies an exit time field, defining animation duration in normalized time (between 0-1). When <strong class="userinput"><code>Has Exit Time</code></strong> is enabled, the state can only exit or change after the specified exit time elapses. In our case, <strong class="userinput"><code>Has Exit Time</code></strong> should be disabled, as there are some conditions (such as <span class="emphasis"><em>death</em></span>) that can potentially interrupt an animation at any time and must be allowed to do so:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/4c0a7942-4a6f-47fa-b348-d96c262c5392.png" /></div><p>Disabling exit time</p><p>Finally, you'll probably want to tweak the <strong class="userinput"><code>Speed</code></strong><span>value</span> for each node. This determines how fast or slow the animation plays back. This value is expressed, again, in normalized time. Thus, a value of 1 means default (since <span class="emphasis"><em>time x 1 = time</em></span>), 2 means double speed (since <span class="emphasis"><em>time x 2 = 2 time</em></span>), 0.5 means half speed (since <span class="emphasis"><em>time x 0.5 = time/2</em></span>), and so on. For my animations, I've specified a value of <span class="emphasis"><em>0.15</em></span>. I arrived at this value by trial and error, that is, by repeatedly playing back the animation at different speeds to observe the result:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/7a29a6a5-ec35-4aff-9306-9a59b1b3bca3.png" /></div><p>Configuring animation speed by trial and error</p><p>Excellent! The animator graph is now fully configured for camera navigation. The nodes should be set up in a linear sequence, allowing the camera to move forward on its path as the <code class="literal">NavState</code><strong class="userinput"><code>Int</code></strong> parameter is updated. Right now, nothing actually changes this parameter; this explains why the camera won't move or change as the level begins. We'll need to access the <code class="literal">NavState</code> and its value from script to gain control over camera movement.</p></div>