<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Level lighting - Preparation</h2></div></div><hr /></div><p>Reaching this far, you've now made a complete <span>scene</span> in terms of meshes representing the first level, composed of modular environment pieces (corridor sections). Presently, the level features no lighting, navigation meshes, music or audio, and Occlusion Data, but we'll add these soon. Let's start with lighting. In Unity, there are three main lighting types or systems, which exist on a spectrum:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Baked lighting</strong></span></li><li style="list-style-type: disc"><span class="strong"><strong>Real-time lighting</strong></span></li><li style="list-style-type: disc"><span class="strong"><strong>Precomputed global illumination</strong></span></li></ul></div><p>These are discussed in furtherÂ detail here.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec30"></a>Baked lighting</h3></div></div></div><p>Baked lighting is the optimal lighting method, but it can only be used under specific circumstances. With <span>baked</span> lighting, all lighting data (highlights, shadows, and so on) are precalculated and saved to a texture (lightmap). The lightmap is then applied to <span>scene</span> geometry using a second UV channel (Lightmap UVs) on top of their standard materials, using multiplicative blending. This makes geometry appear illuminated by scene lights. This approach is ideal for achieving high levels of realism while maintaining excellent runtime performance, because it saves Unity from having to calculate lighting at runtime. However, lightmapping only works properly for static objects (objects that never move), such as walls, floors, ceilings, and architecture:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/ed25c783-02ef-477d-8865-e6edceed3008.png" /></div><p>A lighmap texture for the scene</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec31"></a>Dynamic lighting</h3></div></div></div><p>Dynamic lighting is the opposite of <span>baked</span> lighting. With <span>baked</span> lighting, all lighting information is precalculated, that is, calculated ahead of runtime. Dynamic lighting, however, is calculated at runtime. This means that Unity accepts all lights affecting an object as input, the object itself, and its surrounding objects, and then produces the best lighting approximation it can. The upside of dynamic lighting is that it changes and updates in real time as objects transform in the scene. The downside is computational expense (it's expensive) and realism, as quality sacrifices are made to produce lighting effects in real time. In short, you never want to use dynamic lighting unless you absolutely have to! Thankfully, Unity offers us some tools (<span class="strong"><strong>Light Probes</strong></span>) for semi-baking lighting data, reducing the impact of dynamic lighting:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/f9b49d6a-ded2-42b8-a929-0420f0c3c8db.png" /></div><p>Dynamic lighting</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec32"></a>Precomputed global illumination</h3></div></div></div><p>The problem with <span>baked</span> lighting is its static and unchanging nature. After a lightmap is baked, it cannot be changed without rebaking. In contrast, the problem with dynamic lighting is its performance-intensive nature. Light calculated in real time demands a lot of resources and processing time. Since Unity 5, Unity <span>offers</span> a middle-way solution known as precomputed <span class="strong"><strong>global illumination</strong></span> (<span class="strong"><strong>GI</strong></span>). This system lets you recompute (bake) significant lighting data about how light bounces around in <span>the</span> scene, and yet retain the ability to change scene lights at runtime. In short, with precomputed GI you can move lights and change their color and intensity at runtime, and all lighting changes take effect in the scene soon after. However, precomputed GI is restricted only to static objects (non-moving objects). Objects that move must still be illuminated using either dynamic lighting, or a semi-dynamic form, such as Light Probes (as we'll see):</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/2373dc25-9302-43fb-9cfe-8a6495333f17.png" /></div><p>Precomputed global illumination</p><p>The three aforementioned lighting systems are not mutually exclusive; they can be used to varying degrees with each other. However, for <span class="emphasis"><em>Dead Keys</em></span>, we'll stick to baked lighting for the environment (since the environment never moves), and semi-dynamic lighting (Light Probes) for animated objects, such as NPCs.</p></div></div>