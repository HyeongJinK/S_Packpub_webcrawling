<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec24"></a>Occlusion Culling</h2></div></div><hr /></div><p>Unity imposes no official limits on <span>the</span> size of your scene, and there's no established convention or industry-standard making recommendations about scene size. This is a decision largely in your hands, but there will certainly be a limit in a practical sense. The complexity of meshes, materials, and special effects combined with the number of meshes and their spread determines just how computationally expensive a scene is when presented to a camera with a specific frustum and field of view. Unity tries to make scene rendering easier on <span>the</span> computer by applying <span class="strong"><strong>Frustum Culling</strong></span> automatically, that is, it silently deactivates (culls) objects outside the viewing volume (frustum) of the camera. As objects leave the frustum, Unity ceases to render them, and as they enter the volume, Unity starts rendering them. This optimization works well in many cases, for objects that clearly enter and leave the Frustum:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/2d176b60-be62-4227-a213-9e73f0ff81fe.png" /></div><p>Camera frustum defines the limits of what can be seen</p><p>Using Frustum Culling, it becomes possible to create large scenes with many meshes, without worrying about whether the camera will be burdened by unmanageable render workloads. However, despite this, it's important to emphasize that the camera frustum is a volume, which follows the camera, and defines the region inside which all objects can potentially be visible. This means that only objects within the frustum can possibly be seen, but not all objects in the frustum are necessarily seen.</p><p>For example, if a camera moves close to a wall, the objects beyond it may technically come into the frustum, but they will not, in fact, be seen by the camera, because they will be occluded by the wall. Even so, Unity continues to process and render all frustum objects, even though it actually wastes time in doing so, because it doesn't check their visibility after entering the frustum. This can be problematic because even objects within the frustum can still hinder render performance, if they're high-poly and detailed. However, in identifying the problem, we see a new window of opportunity for optimization, which Unity supports. Specifically, we can use Occlusion Culling. This lets Unity make further culling decisions about whether objects within the Frustum should be rendered, based on their visibility. To get started with Occlusion Culling, create a new empty object by navigating to <strong class="userinput"><code>GameObject</code></strong> | <strong class="userinput"><code>Create Empty</code></strong> from the application menu:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/be6d4744-9059-4691-bfe7-1f919e6a84e7.png" /></div><p>Creating a new empty in preparation for Occlusion Culling</p><p>After creating a new empty object, rename it to <code class="literal">OcclusionArea</code>, and then position it to the world origin (<code class="literal">0</code>,<code class="literal">0</code>,<code class="literal">0</code>). This step is not essential, but it makes for a cleaner workflow:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/333d6c3b-f645-421f-bc3a-990b2cd28ba3.png" /></div><p>Resetting the Occlusion Area to the world origin</p><p>Next, select the empty and navigate to <strong class="userinput"><code>Component</code></strong> | <strong class="userinput"><code>Rendering</code></strong> | <strong class="userinput"><code>Occlusion Area</code></strong> from the application menu. This adds an <strong class="userinput"><code>Occlusion Area</code></strong> component, which will contain all Occlusion Data for the scene. It defines how objects <span>relate</span> to each other, making it quicker for cameras to determine whether any object in the frustum is visible:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/4547ceee-047e-434a-b493-e80e86dffe1d.png" /></div><p>Adding an Occlusion Area component in preparation for Occlusion Culling</p><p>By adding an <strong class="userinput"><code>Occlusion Area</code></strong> component to the empty, you can use the <strong class="userinput"><code>Size</code></strong><strong class="userinput"><code>X</code></strong>, <strong class="userinput"><code>Y</code></strong>, and <strong class="userinput"><code>Z</code></strong> fields to resize a boundary volume around the scene. The idea is to resize the volume to fully encompass either the entire scene or the area in which Occlusion Culling applies if it's not the entire scene. Ideally, the volume should be sized tightly around the scene, leaving little empty space at the fringes. You may also need to adjust the <strong class="userinput"><code>Center</code></strong> field to size the volume better. You can resize the volume through typeins, via the object <strong class="userinput"><code>Inspector</code></strong>, or you can interactively resize with the mouse from the viewport by clicking on and dragging the gizmo handles:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/d29dca0a-dcfc-4763-a213-4f8adf2d7112.png" /></div><p>Sizing the Occlusion Culling volume</p><p>After creating an <code class="literal">OcclusionArea</code>, defining an area with densely populated meshes, open the <strong class="userinput"><code>Occlusion Culling</code></strong> window by navigating to <strong class="userinput"><code>Window</code></strong> | <strong class="userinput"><code>Occlusion Culling</code></strong> from the application menu. This displays a free-floating window, which can be docked into the object <strong class="userinput"><code>Inspector</code></strong>. This window is used for baking Occlusion Data based on all active Occlusion Areas in the scene:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/f128706b-eed7-4a6e-b3ac-a72a81f3054f.png" /></div><p>Accessing the Occlusion Culling Bake Features</p><p>From the <strong class="userinput"><code>Occlusion Culling</code></strong> window, the default <span>settings</span> can often be left as is for scenes using real-world scales. Simply click on the <strong class="userinput"><code>Bake</code></strong> button, and Occlusion Data is generated. The bake time varies, depending on the scene and its contents, but it is usually less than a minute. Once completed, the scene is surrounded by gizmo boxes representing spatial divisions that are integral to the culling algorithm:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/d662fa70-d0ab-41c5-b1b2-22bdc416621b.png" /></div><p>Baking Occlusion Data</p><p>You can preview the effects of Occlusion Culling and its implications for specific cameras by switching to the <strong class="userinput"><code>Visualization</code></strong> tab in the <strong class="userinput"><code>Occlusion</code></strong><strong class="userinput"><code>Culling</code></strong> window, and then selecting a perspective camera in the scene. When you do this, the viewport rendering changes, showing only the meshes visible to the camera given its position, field of view, and frustum. The preview updates in real time as the camera moves. This is helpful for showing how Occlusion Culling works from any camera and perspective, and the extent to which it's optimized for your scene and cameras:</p><div class="mediaobject"><img src="/graphics/9781788479837/graphics/082abd35-3419-4ffb-b764-d8c54e4ffd53.png" /></div><p>Previewing Occlusion Data</p><p>Excellent! Occlusion Culling is now successfully configured for the scene. Next, we just need to add a camera to the scene for the player character.</p></div>