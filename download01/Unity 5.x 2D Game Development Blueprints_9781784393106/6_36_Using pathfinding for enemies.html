<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec36"></a>Using pathfinding for enemies</h2></div></div><hr /></div><p>Since our scene is AI ready, we can start adding AI characters in order to test what we have done so far.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec19"></a>Shaping our soldier</h3></div></div></div><p>First, drag the sprite of the enemy character into the scene. For instance, you can use <code class="literal">roguelikeChar_transparent 1_21</code>, which resembles a soldier figure and can be found in the <code class="literal">RPG Pack/Characters/Spritesheet/roguelikeChar_transparent 1</code> folder. You can see it in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_011.jpg" /></div><p>
</p><p>This is the sprite that we will use in this chapter. Once we are in the scene, rename the <code class="literal">gameObject</code> to <code class="literal">Soldier</code>, and set its position to (<code class="literal">-0.4,2.25,0</code>) and its scale to (<code class="literal">3,3,3</code>).</p><p>Then, add a circle collider and a rigid body to our soldier by setting the same variable values that we already set in our <code class="literal">player</code> object. The only difference is that we need to set the rigid body's <code class="literal">IsKinematic</code> value to true, since we will be moving the character by a script that doesn't require any input from the player, unlike the player <code class="literal">gameObject</code>. You can see the final settings in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/B03647_06_12.jpg" /></div><p>
</p><p>Every brave soldier needs a weapon. Therefore, let's make a copy of the weapon and the shield objects inside the <code class="literal">player</code> object and parent these copies to our soldier. Then, be sure to reset the position of the two objects to (<code class="literal">0,0,0</code>), because they probably still hold their old positions.</p><p>You can change the weapon and armor sprites to better suit our soldier, as you can see in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_013.jpg" /></div><p>
</p><p>In order to start using the paths created on the grid by the pathfinding tool, we need to attach the <code class="literal">Seeker</code> component to our soldier. Click on <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Pathfinding</strong></span> | <span class="strong"><strong>Seeker</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec20"></a>Giving intelligence to the soldier</h3></div></div></div><p>Now that our soldier is prepared to navigate through the scene using the grid graph, we have to implement a new script to control its behavior. In particular, we want the soldier to chase the player. When the soldier is too close to the player, then the soldier stops.</p><p>Let's create a new C# script and name it <code class="literal">EnemyAI</code> under the folder <code class="literal">Scripts</code>. Then, attach the script to the soldier object. Open the script in the editor.</p><p>The first thing to do is to add the following line at the beginning of the script:</p><pre class="programlisting">using Pathfinding; &#13;
</pre><p>This allows us to use the <code class="literal">Pathfinding</code> package that we have imported.</p><p>Then, we need to create some variables; first of all, our target. This variable contains the <code class="literal">Transform</code> that the enemy is chasing; in our case, the player. Therefore, we can write:</p><pre class="programlisting">  // The target to follow or chase &#13;
  public Transform target; &#13;
</pre><p>The next four variables are needed to describe the behavior of our soldier. In particular, one determines the speed of the character, another one how often the soldier should update its path. The third describes how close he or she needs to be a waypoint before changing direction; and finally, how far the character should be from the player to chase him or her. These variables are written in the following code:</p><pre class="programlisting">  // Character's movement speed &#13;
  public float speed = 85; &#13;
  // How often the path is updated every second &#13;
  public float updateRate = 2; &#13;
  // Required distance to be reached before continuing the path &#13;
  public float nextWaypointDistance = 0.3f; &#13;
  // Required distance to the target before stopping &#13;
  public float endDistance = 0.8f; &#13;
</pre><p>Now, we need some variables to handle the internal logic. One variable is a flag to check whether the path has come to an end. Another one stores the path itself. We need a couple of variables to reference the soldier components to the <code class="literal">RigidBody</code> and the <code class="literal">Seeker</code>, respectively. Finally, we need to add an index to iterate on the path. Thus, we can add the following variables:</p><pre class="programlisting">  // Flag to check if the path has ended &#13;
  public bool pathEnded = false; &#13;
  // The calculated path &#13;
  public Path path; &#13;
  // Character's RigidBody component &#13;
  Rigidbody2D charRigidBody2D; &#13;
  // Character's Seeker component &#13;
  Seeker seeker; &#13;
  // Current waypoint &#13;
  int curWaypointIndex=0; &#13;
</pre><p>The next step is to assign these references in the <code class="literal">Start()</code> function, and start a coroutine, which we are going to implement soon:</p><pre class="programlisting">  void Start () { &#13;
    // Assign the required components &#13;
    seeker=GetComponent&lt;Seeker&gt;(); &#13;
    charRigidBody2D=GetComponent&lt;Rigidbody2D&gt;(); &#13;
    // Start the path &#13;
    StartCoroutine(UpdatePath()); &#13;
  } &#13;
</pre><p>Then, in the <code class="literal">Update()</code> function, we need to make our character move. First, we need to check whether the path is completed; if not, we move the character accordingly, as written in the following code:</p><pre class="programlisting">  void Update () { &#13;
    if(path==null) return; &#13;
    // On reaching the end of the path &#13;
    if(curWaypointIndex==path.vectorPath.Count) &#13;
    { &#13;
      if(pathEnded) return; &#13;
      charRigidBody2D.velocity=Vector3.zero; &#13;
      pathEnded=true; &#13;
    } &#13;
    else &#13;
    { &#13;
      // If we approached the end distance &#13;
      if(Vector3.Distance(transform.position,target.position) &#13;
         &lt;endDistance) &#13;
      { &#13;
        // Finish the path &#13;
        curWaypointIndex=path.vectorPath.Count; &#13;
      } &#13;
      else &#13;
      { &#13;
        // Move towards the current waypoint &#13;
        pathEnded=false; &#13;
        float dist=Vector3.Distance(transform.position,path.vectorPath[curWaypointIndex]); &#13;
        Vector3 dir=(path.vectorPath[curWaypointIndex]-transform.position).normalized; &#13;
        charRigidBody2D.velocity=dir*speed*Time.fixedDeltaTime; &#13;
        if(dist&lt;nextWaypointDistance) curWaypointIndex++; &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>In the coroutine we started in the <code class="literal">Start()</code> function, we need to update the path at the rate specified in our variables. We can compute a new path by using the <code class="literal">Seeker</code> component. Therefore, we can write:</p><pre class="programlisting">  // Update the path then wait before updating again &#13;
  IEnumerator UpdatePath () { &#13;
    if(Vector3.Distance(transform.position,target.position)&gt;endDistance) &#13;
    { &#13;
      seeker.StartPath(transform.position,target.position,OnPathComplete); &#13;
    } &#13;
    yield return new WaitForSeconds(1/updateRate); &#13;
    StartCoroutine(UpdatePath()); &#13;
  } &#13;
</pre><p>Lastly, we have a function named <code class="literal">OnPathCompleted()</code>, which is called when the path has been computed. Here, we just assign the path computed to the path variable of our script, so to make the character move along this new path. Of course, don't forget to reset the index as well:</p><pre class="programlisting">  void OnPathComplete (Path p) { &#13;
    if(p.error) &#13;
    { &#13;
      // Report error &#13;
      print (p.error); &#13;
    } &#13;
    else &#13;
    { &#13;
      // Assign to the new calculated path &#13;
      path=p; &#13;
      curWaypointIndex=0; &#13;
    } &#13;
  } &#13;
</pre><p>Save the changes and head back to the scene. If you haven't yet, attach the <code class="literal">EnemyAI</code> script that we just created to the soldier object. Then assign the player object to the target variable inside our script, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_014.jpg" /></div><p>
</p><p>As for the other variables, it's better to leave their default values. However, feel free to change them if needed. Now, save the scene and click play to see what we have accomplished so far:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_015.jpg" /></div><p>
</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec21"></a>Final notes</h3></div></div></div><p>As you can see, right after playing the scene, the soldier moves towards our player until he is close enough and then stops. You can also watch the console for details on the path generated from the <code class="literal">Pathfinder</code> class, as shown in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_016.jpg" /></div><p>
</p><p>Additionally, if you have enabled gizmos, in the <span class="strong"><strong>Scene</strong></span> view, you should be able to see green lines generated by the pathfinder class to indicate the path to the target object, as shown in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_017.jpg" /></div><p>
</p><p>You can use this feature to understand how pathfinding works by moving the player object across the scene and looking at the gizmos indicating the generated path.</p><p>What you will also notice is that the soldier will move around all obstacles in the scene until it arrives at the <code class="literal">player</code> object:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_018.jpg" /></div><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>If you are passionate or just want to learn more about AI in games, you can regularly check the following website, where you will also find advanced pathfinding techniques, which are still developing in the academic environment: <a class="ulink" href="http://francescosapio.com" target="_blank">francescosapio.com</a>.</p></div></div></div>