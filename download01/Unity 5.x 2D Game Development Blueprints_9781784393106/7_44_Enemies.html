<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec43"></a>Enemies</h2></div></div><hr /></div><p>In this section, we will learn how to create the enemies for our Tower Defense game.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec26"></a>Creating the enemy prefab</h3></div></div></div><p>Since we will see how the game manager will spawn a lot of enemies later, in <a class="link" href="#" linkend="ch09"><span class="emphasis"><em>Chapter 9</em></span></a>, <span class="emphasis"><em>Finishing the Game</em></span>, we need to create a prefab to store all the data for one enemy, including its graphics, components, and scripts.</p><p>By right-clicking on the <span class="strong"><strong>Hierarchy</strong></span> panel, we can select <span class="strong"><strong>2D Object/Sprite</strong></span> in order to create a new <code class="literal">Sprite</code>. Of course, we need to assign the graphic and adjust its dimensions to fit our game environment. In this case, we can chose the <code class="literal">slime_red</code> as our enemy. Like the previous components, towers and bullets, it also needs to be scaled. In this case, we can set the whole scale vector to <code class="literal">0.8</code>. Furthermore, we should set the value of the <span class="emphasis"><em>Z</em></span>-axis, for the position, to <code class="literal">-1</code>. Once we have done this, it should look like this:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_07_012.jpg" /></div><p>
</p><p>In order to be detected by the towers, our enemy should have the <code class="literal">enemy</code> tag. Since we have already created this tag in the bullet section, it can easily be assigned to our enemy. As usual, it's always a good practice to rename the <code class="literal">GameObject</code> as <code class="literal">Enemy</code>. The <span class="strong"><strong>Inspector</strong></span> should look like the following:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_07_013.jpg" /></div><p>
</p><p>Then, we need to add a <span class="strong"><strong>Box Collider 2D</strong></span> by clicking on <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Physics 2D</strong></span> | <span class="strong"><strong>Box Collider 2D</strong></span> and setting the size variable to get the box to fit our enemy as closely as possible. In the case of our graphic, this is done automatically, since the slime is almost a rectangle. In the end, we should see something like the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_07_014.jpg" /></div><p>
</p><p>However, we should always consider other kinds of colliders if we want to achieve more precise behaviors. For instance, by using an <code class="literal">Edge</code> collider (you can find this by clicking on <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Physics 2D</strong></span> | <span class="strong"><strong>Edge Collider 2D</strong></span>), we can achieve something like this:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_07_015.jpg" /></div><p>
</p><p>In addition, besides deciding on the type of collider that we have chosen, we need to set <span class="strong"><strong>Is Trigger</strong></span> to true, since we are going to use this collider as a trigger to detect bullets (there's more information about this in the next section).</p><p>Next, we can create a new <span class="strong"><strong>Prefab</strong></span> by right-clicking on the <span class="strong"><strong>Project</strong></span> panel and then <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Prefab</strong></span>. Finally, drag the enemy inside it and erase it from the scene.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec27"></a>Scripting the enemies</h3></div></div></div><p>Now it's time to script our enemy. Let's create a new script by right-clicking on the <span class="strong"><strong>Project</strong></span> panel and then selecting <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>C# Script</strong></span> (or also directly on the enemy prefab) and renaming it <code class="literal">EnemyScript</code>. Finally, double-click on the file to open it.</p><p>In order to make the slime alive, we need to create a script that it is able to make the enemy do the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Move along the designed path on the map</p></li><li style="list-style-type: disc"><p>Damage the player's fortress if he reaches the end (we will see this in <span class="emphasis"><em><a class="link" href="#" linkend="ch09">Chapter 9</a></em></span>, <span class="emphasis"><em>Finishing the Tower Defense Game</em></span>)</p></li><li style="list-style-type: disc"><p>Detect whether a bullet from the player's towers hit him</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec2"></a>Moving along the designed path</h4></div></div></div><p>To achieve this behavior, we are going to use a technique called <span class="emphasis"><em>waypoints</em></span>. This is very useful if the enemy has to follow a set of designed paths, as in this case. In contrast to the previous chapter, where we needed an online pathfinding algorithm to decide where the enemy should move next, here, since the path is fixed, the waypoints technique is both easier to implement and also faster from a computational point of view.</p><p>In its basic implementation, the waypoint technique consists of storing all the key <span class="emphasis"><em>waypoints</em></span> of the path, and makes the enemy move along them.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Tip</h3><p>In more complex implementations, waypoints can be connected in different ways and these connections can also be created automatically by letting the waypoints <span class="emphasis"><em>find</em></span> each other. Furthermore, they can also contain other information, such as which is the closest waypoint to the player. Here, the enemy can <span class="emphasis"><em>ask</em></span> the waypoints where to head toward in order to find the player without running a complete pathfinding algorithm on the map itself.</p></div><p>We need to create four variables. The first is to specify the speed of this particular enemy, and two are needed to store, respectively, the path to follow and an internal counter to know which piece of the path the enemy is traversing. The last variable is just a constant threshold to detect whether an enemy has reached a waypoint. It is needed only for numerical robustness, since the distance from the waypoint will never be exactly zero.</p><p>Therefore, let's start to add the following variables:</p><pre class="programlisting">  public float speed = 1f; &#13;
  private Vector3[] waypoints; &#13;
  private int counter = 0; &#13;
  private const float changeDist = 0.001f; &#13;
</pre><p>Now, in the <code class="literal">Update()</code> function, we should implement this movement. The first thing to do is to check whether the counter has reached the last waypoint, which means that the enemy has reached the player's fortress and we should apply damage to it. But, since we will see how to create the game manager for this game in the last chapter, for now we can just destroy the enemy with the following lines:</p><pre class="programlisting">    if(counter==waypoints.Length){ &#13;
      Destroy(gameObject); &#13;
      return; &#13;
    } &#13;
</pre><p>Then, we need to calculate the distance to the next waypoint where the enemy is heading. If the distance is less than the <code class="literal">changeDist</code> variable, we need to update the counter, which means changing the waypoint. Otherwise, just move the enemy closer to the next waypoint according to its speed:</p><pre class="programlisting">else{ &#13;
      float dist = Vector3.Distance(transform.position, waypoints[counter]); &#13;
      if(dist &lt; changeDist){ &#13;
        counter++; &#13;
      }else{   &#13;
        float step = speed * Time.deltaTime; &#13;
        transform.position = Vector3.MoveTowards(transform.position, waypoints[counter], step); &#13;
      } &#13;
    } &#13;
</pre><p>We have used the <code class="literal">Vector3.MoveTowards()</code> function that allows us to move a <code class="literal">GameObject</code> toward another one, specifying a step. More information about this can be found in the official documentation on Unity. Here is the link:</p><p>
<a class="ulink" href="http://docs.unity3d.com/ScriptReference/Vector3.MoveTowards.html" target="_blank">http://docs.unity3d.com/ScriptReference/Vector3.MoveTowards.html</a>.</p><p>Now we have finished implementing the movement of our little slimes; however, we still need to set the waypoints. We will do this in the last chapter of this book.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec3"></a>Detecting towers' bullets</h4></div></div></div><p>While our enemy is trying to head toward the player's fortress to destroy it, at the same time he is being shot with bullets by the towers. Therefore, in some way, we have to detect when a bullet hits our enemy. In order to do this, we can use the collision system already implemented in Unity. In this case, we should use the 2DCollision since our game is in 2D. In particular, we are going to implement an OnTriggerEnter2D() function. More can be found here: <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter2D.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerEnter2D.html</a>.</p><p>First, we need to check whether the object that hit the enemy is really a bullet. This can be done by checking whether the bullet has the <code class="literal">Bullet</code> tag. If so, we destroy both the enemy and the bullet in the following way:</p><pre class="programlisting">  void OnTriggerEnter2D(Collider2D other) { &#13;
    if(other.tag == "Bullet"){ &#13;
      Destroy(other.gameObject); &#13;
      Destroy(gameObject); &#13;
    } &#13;
  } &#13;
</pre><p>As a result, every time a bullet hits the enemy, both will be destroyed.</p><p>Finally, we have finished scripting our enemy. Now, save the script and attach it to the enemy prefab.</p></div></div></div>