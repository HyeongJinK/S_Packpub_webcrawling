<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec23"></a>Adding enemies</h2></div></div><hr /></div><p>To make our level more exciting, we need to add some enemies to the level. We can use the sprites under <span class="strong"><strong>Platformer Pack</strong></span> | <span class="strong"><strong>Enemies</strong></span> and start by creating the snail enemy.</p><p>Just like how we animated our player, we will do almost the same for the enemies; drag and drop both <code class="literal">snailWalk1</code> and <code class="literal">snailWalk2</code> into the scene to create the animation. Then, rename the object to <code class="literal">Enemy1</code>, scale the object to <code class="literal">(-3,3,3)</code>, so that it fits the dimensions of our game level, and then place it on the first platform of the level. Finally, add a box collider that fully encloses the sprite and a rigid body with its <span class="strong"><strong>FixedAngle</strong></span> variable set to <code class="literal">true</code>. As a result, the <span class="strong"><strong>Inspector</strong></span> should look like the following:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_04_035.jpg" /></div><p>
</p><p>Before going forward with the enemies and their code, we first need to create some obstacles to place in their way. In fact, our enemies will change direction every time they collide with an obstacle.</p><p>We can achieve this by dragging <code class="literal">boxAlt</code> from the <span class="strong"><strong>Project</strong></span> panel under <span class="strong"><strong>Platformer Pack</strong></span> | <span class="strong"><strong>Tiles</strong></span> inside the scene. Then, change the tag to <code class="literal">Obstacle</code> and add a collider to the object with the <span class="strong"><strong>IsTrigger</strong></span> variable set to <code class="literal">true</code>. Also, name the object <code class="literal">ObstacleUp_1</code> and duplicate it. The duplicated object should be <code class="literal">ObstacleUp_2</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Tip</h3><p>To quickly reuse obstacles, you can create and use prefabs too.</p></div><p>Finally, parent them to <span class="strong"><strong>Scene</strong></span> | <span class="strong"><strong>Floors</strong></span> and place them along the path of our snail enemy, as shown in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_04_037.jpg" /></div><p>
</p><p>Now, we need to script the behavior of the enemy. So, let's create a new C# script and name it <code class="literal">EnemyScript</code> inside the folder <code class="literal">Scripts</code>. Then, attach the script to the <code class="literal">snail</code> object. Double-click on the script to open it.</p><p>We first need to add some variables to store the speed of the enemy, its velocity vector, and scale:</p><pre class="programlisting">  public float speed = 1; &#13;
  Vector2 curVelocity; &#13;
  Vector3 curScale; &#13;
</pre><p>In the <code class="literal">Start()</code> function, we need to initialize its velocity in the rigid body:</p><pre class="programlisting">  void Start () { &#13;
    //Set initial direction and speed &#13;
    GetComponent&lt;Rigidbody2D&gt;().velocity = new Vector2(-1 * speed, 0); &#13;
  } &#13;
</pre><p>In the <code class="literal">Update()</code> function, instead, we need to check if the enemy stops, and make it resume its walking:</p><pre class="programlisting">    void Update() { &#13;
        //get the current velocity &#13;
        curVelocity = GetComponent&lt;Rigidbody2D&gt;().velocity; &#13;
        //Resume walking if the enemy stops &#13;
        if (curVelocity.x == 0) { &#13;
            transform.position = new Vector2(transform.position.x, transform.position.y + 0.01f); &#13;
            GetComponent&lt;Rigidbody2D&gt;().velocity = new Vector2(curScale.x &gt; 0 ? -1 : 1 * speed, 0); &#13;
        } &#13;
    } &#13;
</pre><p>Then, we need to create the <code class="literal">OnTriggerEnter2D()</code> function to detect if the enemy touched an obstacle, so it needs to change direction, or if the player killed it by jumping on it:</p><pre class="programlisting">    void OnTriggerEnter2D(Collider2D c) { &#13;
        if (c.tag == "Obstacle") { &#13;
            GetComponent&lt;Rigidbody2D&gt;().velocity = new Vector2(-1 * curVelocity.x, 0); &#13;
            curScale = transform.localScale; &#13;
            curScale.x *= -1; &#13;
            transform.localScale = curScale; &#13;
        } &#13;
        else if (c.name == "GroundCheck") { &#13;
            print("Killed By Jump!"); &#13;
            Destroy(gameObject); &#13;
        } &#13;
    } &#13;
</pre><p>Similarly, we need to do it if the enemy collides with a collider, and again, we need to check if it is an obstacle or the player. However, in this case, the player's collider is not <code class="literal">GroundCheck</code>, therefore, in this case, it is the enemy that subtracts a life to the player before they die:</p><pre class="programlisting">    void OnCollisionEnter2D(Collision2D c) { &#13;
        if (c.collider.tag == "Obstacle") { &#13;
            GetComponent&lt;Rigidbody2D&gt;().velocity = new Vector2(-1 * curVelocity.x, 0); &#13;
            curScale = transform.localScale; &#13;
            curScale.x *= -1; &#13;
            transform.localScale = curScale; &#13;
        } &#13;
        else if (c.collider.tag == "Player") { &#13;
            c.transform.GetComponent&lt;GameHandler&gt;().SubtractHealth(); &#13;
            Destroy(gameObject); &#13;
        } &#13;
    } &#13;
</pre><p>Save the changes and head back to the scene. In the <code class="literal">GroundCheck</code> object under <code class="literal">Player</code>, add a collider and set its <span class="strong"><strong>IsTrigger</strong></span> variable to <code class="literal">true</code>. Then, center it directly under the player, as shown in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_04_038.jpg" /></div><p>
</p><p>In this way, we can detect if the player has jumped on the enemy and killed it, or if they touched it and have been hurt.</p><p>We can finally test the scene and see what we have accomplished so far:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_04_039.jpg" /></div><p>
</p><p>As you can see, a lot of features have been added to the game, which is great! However, we still need to add another couple of enemies. Since the enemy logic is the same for all of them, we can choose different enemies, instead of always using the snail. Some good options could be the fly, the fish, or the slime.</p><p>After we have added three more enemies into the scene, we must add some obstacles at the end of their path in order to keep them in place, just like we did with the snail. Therefore, we can add five obstacles on the ground. However, instead of using them as triggers, we can leave them as normal colliders. As a result, the player will be able to properly interact with them:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_04_040.jpg" /></div><p>
</p><p>Let's see what we accomplished so far in this chapter. Don't forget to save the scene before every test!</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/3647_04_44.jpg" /></div><p>
</p><p>Here, in the preceding image, the game is running.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/3647_04_45.jpg" /></div><p>
</p><p>The preceding image is when the player has reached the end and won.</p></div>