<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec35"></a>AStar Algorithm in Unity</h2></div></div><hr /></div><p>The AStar Algorithm is famous for being one of the most reliable pathfinding algorithms out there. It is mainly used to find a proper traversable path between two points, as shown in the preceding figure.</p><p>We won't be diving into the specifics of the AStar Algorithm, but we will use it in our game to plan the paths of AI characters.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec17"></a>A tool for Unity</h3></div></div></div><p>Luckily, a great tool to make the process of implementing AStar in Unity already exists, and it is also freely available. It can be downloaded here: <a class="ulink" href="http://arongranberg.com/astar/download" target="_blank">http://arongranberg.com/astar/download</a>. I suggest downloading the latest stable release and avoid any beta version for any bugs that it may have, as shown in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_002.jpg" /></div><p>
</p><p>After extracting the downloaded archive, double-click on the package in order to import the necessary files inside Unity. The following screen should appear, and then click on <span class="strong"><strong>Import</strong></span>:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_003.jpg" /></div><p>
</p><p>Afterwards, a new folder will be created, named <code class="literal">AstarPathfindingProject</code>, containing all of the files we are going to use for the pathfinding.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"></a>Note</h3><p>If you feel like learning more about this tool, there is very good documentation at the following link: <a class="ulink" href="http://arongranberg.com/astar/docs" target="_blank">http://arongranberg.com/astar/docs</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec18"></a>Setting up the tool</h3></div></div></div><p>Now, in order to start using this tool in our game, we need to create an empty game object called <code class="literal">AStar</code> and add the <code class="literal">Pathfinder</code> component. This can be achieved by clicking on <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Pathfinding</strong></span> | <span class="strong"><strong>Pathfinder</strong></span>.</p><p>The <code class="literal">AStar</code> object should look like this in the <span class="strong"><strong>Inspector</strong></span> window:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_004.jpg" /></div><p>
</p><p>One of the first steps in pathfinding is marking <span class="emphasis"><em>path ways</em></span> and any obstacles in the scene, so that the AI character will know where it's okay to move and where it's not. In order to accomplish this, we need to create a grid graph.</p><p>To create a grid graph, first navigate to the scene view and return to 3D mode. Next, click on <span class="strong"><strong>Graphs</strong></span> under the <span class="strong"><strong>Astar Path</strong></span> component and choose <span class="strong"><strong>Grid Graph</strong></span>, as shown in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_005.jpg" /></div><p>
</p><p>As you can see, a grid has been generated with nodes covering it. These nodes will be used to mark objects that will interfere with the player path and to generate paths around them. However, first we need to rotate the grid since it's on the wrong axis:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_006.jpg" /></div><p>
</p><p>As shown in the preceding screenshot, inside the <span class="strong"><strong>Inspector</strong></span>, we should change the grid graph's rotation around the <span class="emphasis"><em>X</em></span>-axis to <code class="literal">-90</code>, since they describe the same rotation. Then, click on <span class="strong"><strong>Scan</strong></span> at the bottom of the component. This, is the final result in our <span class="strong"><strong>Scene</strong></span> view:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_007.jpg" /></div><p>
</p><p>In fact, you will find that the graph is now aligned properly with our scene. Now, let's get a better look at our graph properties in the following screenshot, followed by an explanation of each parameter and which values to set for our scene:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/B03647_06_8.jpg" /></div><p>
</p><p>In the preceding screenshot, the parameter are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Width</strong></span>: The number of nodes defining the grid's width. We can set it to <code class="literal">65</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Depth</strong></span>: The number of nodes defining the grid's height. Set it to <code class="literal">65</code> as well.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Center</strong></span>: The center point of the grid, which should be set at (<code class="literal">10,-5,0</code>).</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Rotation</strong></span>: Defines the rotation of the grid, which we already set to (<code class="literal">270,0,0</code>).</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Connections</strong></span>: Number of connections between each node and its neighbor nodes. Leave this value at <code class="literal">8</code>, so that the AI character can also move diagonally.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Max Climb</strong></span>: Determines the ability of the character to climb certain objects. However, since our game is in 2D, we do not need it. So, change the value to 0 and the <span class="strong"><strong>Climb Axis</strong></span> to <code class="literal">Z</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Use 2D Physics</strong></span>: A flag to determine whether the components should use the 2D physics or not. Of course, set it to true.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Collider type</strong></span>: Defines which kind of collision should be used. Since we are in 2D mode, the <code class="literal">Ray</code> collider will be sufficient.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Mask</strong></span>: Determines which kind of object should be taken into account. Change it to <span class="strong"><strong>Everything</strong></span>, which means that any object with proper colliders attached to it will be treated as an obstacle.</p></li></ul></div><p>After you have made all the above changes, click on <span class="strong"><strong>Scan</strong></span> and don't forget to save the scene. At the end, the component should look like the one in the following image:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/B03647_06_9.jpg" /></div><p>
</p><p>You can double-check with the previous image to make sure that all the values are properly set:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781784393106/graphics/image_06_010.jpg" /></div><p>
</p><p>Now, if you look closely at the grid, you should be able to see that the nodes are surrounding the obstacles in the scene by marking them for the path, which is exactly what we wanted.</p></div></div>