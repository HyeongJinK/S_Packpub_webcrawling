<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec15"></a>Under the hood</h2></div></div><hr /></div><p>When we added <code class="literal">UI Root</code> at the beginning of the chapter, it created both <code class="literal">UIRoot</code> and <code class="literal">Camera</code> GameObjects.</p><p>Now that<a id="id115" class="indexterm"></a> we have a sprite and a label within our scene, we can properly understand what the purposes of these two mysterious GameObjects are.</p><p>Select our <code class="literal">UI Root</code> GameObject in the <span class="strong"><strong>Hierarchy</strong></span> view. You can see that the <code class="literal">UIRoot</code> and <code class="literal">UIPanel</code> components <a id="id116" class="indexterm"></a>are attached to it. Let's see what <code class="literal">UIRoot</code>'s purpose is.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec25"></a>UIRoot</h3></div></div></div><p>The <code class="literal">UIRoot</code> component scales widgets down to keep them at a manageable size inside the scene view. It also handles the <a id="id117" class="indexterm"></a>different <span class="strong"><strong>scaling styles</strong></span>.</p><p>Your <span class="strong"><strong>Game</strong></span> view's aspect ratio might be set to <span class="strong"><strong>Free Aspect</strong></span> or another value. For us to have the same results during the explanations to come, set it to <span class="strong"><strong>16:9</strong></span>, like this:</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_01_26.jpg" /></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Display your <span class="strong"><strong>Game</strong></span> view.</p></li><li><p>Click on the<a id="id118" class="indexterm"></a> current aspect ratio (<span class="strong"><strong>1</strong></span>), which is <span class="strong"><strong>Free Aspect</strong></span> here.</p></li></ol></div><p>Select the <span class="strong"><strong>16:9</strong></span> (<span class="strong"><strong>2</strong></span>) aspect ratio. Ok. Now that we have a 16:9 aspect ratio for our <span class="strong"><strong>Game</strong></span> view, we can continue.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec07"></a>Scaling styles</h4></div></div></div><p>Select our <code class="literal">UI Root</code> GameObject in the <span class="strong"><strong>Hierarchy</strong></span> view. The first parameter of its attached <code class="literal">UIRoot</code> component<a id="id119" class="indexterm"></a> is <span class="strong"><strong>Scaling Style</strong></span>. It defines how your UI reacts<a id="id120" class="indexterm"></a> when the screen resolution is changed. There are three different scaling styles available:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>
<code class="literal">Flexible</code>: The UI is in pixels and remains pixel-perfect. A 300 x 300-pixel image always takes 300 x <a id="id121" class="indexterm"></a>300 pixels onscreen regardless<a id="id122" class="indexterm"></a> of the resolution. No stretching or scaling occurs.</p></li><li><p>
<code class="literal">Constrained</code>: The UI is not pixel-perfect. An image taking 30 percent of the screen will always take 30 <a id="id123" class="indexterm"></a>percent of the <a id="id124" class="indexterm"></a>screen, regardless of the resolution. The UI is scaled up or down to fit the screen's height, width, or both, depending on the parameters you choose.</p></li><li><p>
<code class="literal">ConstrainedOnMobiles</code>: This is<a id="id125" class="indexterm"></a> the <code class="literal">Flexible</code> mode on the desktop and <code class="literal">Constrained</code> mode everywhere<a id="id126" class="indexterm"></a> else.</p></li></ol></div><p>The <code class="literal">UIRoot</code> component has different parameters depending on the selected <span class="strong"><strong>Scaling Style</strong></span>. Let's start with the<a id="id127" class="indexterm"></a> default <code class="literal">Flexible</code> scaling style.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec01"></a>Flexible</h5></div></div></div><p>This mode ensures that your<a id="id128" class="indexterm"></a> UI elements remain at the same size in<a id="id129" class="indexterm"></a> pixels (pixel-perfect) regardless of the resolution or <a id="id130" class="indexterm"></a>
<span class="strong"><strong>Dots Per Inch</strong></span> (<span class="strong"><strong>DPI</strong></span>). Here's an illustration of that:</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_01_27.jpg" /></div><p>The 320 x 240 widget shown in the preceding figure (<span class="strong"><strong>W1</strong></span>) appears small on a 1920 x 1080 screen (<span class="strong"><strong>S1</strong></span>) and large on a 640 x 480 screen (<span class="strong"><strong>S2</strong></span>) because it's in <code class="literal">Flexible</code> (pixel-perfect) mode.</p><p>With the preceding illustration, if your screen is smaller than 320 x 240, your widget is not entirely visible. That's where the other parameters shown in the following screenshot come in:</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_01_28.jpg" /></div><p>The parameters are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>
<span class="strong"><strong>Minimum Height</strong></span>: This is an important parameter to keep our UI from being cropped on small<a id="id131" class="indexterm"></a> screens. When the screen's height is below this value, your UI is scaled down to fit. It will then be as if <span class="strong"><strong>Scaling Style</strong></span> was set to <code class="literal">Constrained</code> with <code class="literal">Content Height</code> set to the screen's height.</p></li><li><p>
<span class="strong"><strong>Maximum Height</strong></span>: This is similar to <span class="strong"><strong>Minimum Height</strong></span>, but for the screen's maximum height. When the screen's height is above this value, your UI is scaled up to fit.</p></li><li><p>
<span class="strong"><strong>Shrink Portrait UI</strong></span>: If your game or app can change orientation (landscape or portrait), check this option—the UI will be scaled down to fit the screen.</p></li><li><p>
<span class="strong"><strong>Adjust by DPI</strong></span>: Enabling this option will make your pixel-perfect UI take the screen's DPI into account. In practice, NGUI will believe that these two screen configurations are identical:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Resolution: 1280 x 720—200 DPI</p></li><li style="list-style-type: disc"><p>Resolution: 1920 x 1080—400 DPI</p></li></ul></div></li></ol></div><p>Here's a practical example to illustrate the pixel-perfect <code class="literal">Flexible</code> behavior:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select our <code class="literal">Sprite</code> GameObject.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Change its <span class="strong"><strong>Size</strong></span> to 425 x 240</p></li></ul></div></li><li><p>Select our <code class="literal">UI Root</code> GameObject.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Set the attached <span class="strong"><strong>Minimum Height</strong></span> parameter of <code class="literal">UIRoot</code> to <code class="literal">240</code>
</p></li></ul></div></li></ol></div><p>Now, resize your <span class="strong"><strong>Game</strong></span> view window to a larger screen: when it's more than 240 pixels high, the sprite's always displayed at 320 x 240 pixels. It's pixel-perfect and crisp.</p><p>Resize the <span class="strong"><strong>Game</strong></span> view to a small size: when it's less than 240 pixels high, the UI is scaled down to avoid it being cropped. That's the purpose of the <span class="strong"><strong>Minimum Height</strong></span> parameter.</p><p>The same principle applies to <code class="literal">MaximumHeight</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec02"></a>Constrained</h5></div></div></div><p>The <span class="strong"><strong>Constrained</strong></span> scaling style is the opposite of pixel-perfect: you set <span class="strong"><strong>Content Width</strong></span> and <span class="strong"><strong>Content Height </strong></span>for the virtual <a id="id132" class="indexterm"></a>screen, and your UI will rescale itself up or down to fit.</p><p>In practice, it means<a id="id133" class="indexterm"></a> that a widget taking 100 percent of the screen will always take 100 percent of the screen regardless of the resolution. Let's try it now. The following screenshot shows the <span class="strong"><strong>Constrained</strong></span> scaling style:</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_01_29.jpg" /></div><p>Select our <code class="literal">UI Root</code> GameObject in the <span class="strong"><strong>Hierarchy</strong></span> view. For its attached <span class="strong"><strong>UIRoot</strong></span>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Set <span class="strong"><strong>Scaling Style</strong></span> (<span class="strong"><strong>1</strong></span>) to <span class="strong"><strong>Constrained</strong></span>.</p></li><li><p>Change <span class="strong"><strong>Content Width (2)</strong></span> to <span class="strong"><strong>320</strong></span>.</p></li><li><p>Set <span class="strong"><strong>CContent Height (3)</strong></span> to <span class="strong"><strong>240</strong></span>.</p></li><li><p>Check the <span class="strong"><strong>Fit</strong></span> option for <span class="strong"><strong>Content Height</strong></span>.</p></li></ol></div><p>Our screen is now always considered as having a height of 240, which is our sprite's height; it is now taking all the screen.</p><p>Resize the <span class="strong"><strong>Game</strong></span> view to a large view. You'll see that, at all screen sizes and resolutions, our sprite always takes 100 percent of the screen's height (and width, if it's a 16:9 resolution). That's the <span class="strong"><strong>Constrained</strong></span> mode: the UI is scaled proportionally to the screen's height based on the referenced <span class="strong"><strong>Content Height</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec03"></a>ConstrainedOnMobiles</h5></div></div></div><p>By setting your <a id="id134" class="indexterm"></a>scaling style to <span class="strong"><strong>ConstrainedOnMobiles</strong></span>, your <a id="id135" class="indexterm"></a>UI will be <code class="literal">Flexible</code> (pixel-perfect) on desktop and <code class="literal">Constrained</code> everywhere else.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec08"></a>Configuration</h4></div></div></div><p>For the purpose of this book, we'll set up a simple configuration that will enable us to have the same result on all screens. We'll set our scaling style to <span class="strong"><strong>Constrained</strong></span>, with <span class="strong"><strong>Content Height</strong></span> of 1080.</p><p>This configuration ensures our UI looks beautiful on 1920 x 1080 screens; it is scaled up or down on higher or lower resolutions and still look great.</p><p>Select our <a id="id136" class="indexterm"></a>
<code class="literal">UI Root</code> GameObject in the <span class="strong"><strong>Hierarchy</strong></span> view. For its attached <code class="literal">UIRoot</code> component, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Set <span class="strong"><strong>Scaling Style</strong></span> to <span class="strong"><strong>Constrained</strong></span>.</p></li><li><p>Change <span class="strong"><strong>Content Width</strong></span> to <code class="literal">1920</code>.</p></li><li><p>Set <span class="strong"><strong>Content Height</strong></span> to <code class="literal">1080</code>.</p></li><li><p>Check the <span class="strong"><strong>Fit</strong></span> option for <span class="strong"><strong>Content Height</strong></span>.</p></li></ol></div><p>The 1920 x 1080 resolution has a 16:9 aspect ratio. We'll make sure we only authorize this aspect ratio to avoid having cropped screen sides. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span>.</p></li><li><p>In the <span class="strong"><strong>Player Settings</strong></span> (Inspector view), click on <span class="strong"><strong>Resolution and Presentation</strong></span>.</p></li><li><p>Click on <span class="strong"><strong>Supported Aspect Ratios</strong></span> (the last one, at the bottom).</p></li><li><p>Uncheck all aspect ratios, except the <span class="strong"><strong>16:9</strong></span>.</p></li></ol></div><p>Now that we have understood and configured our <code class="literal">UIRoot</code>, let's talk about <code class="literal">UIPanel</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec26"></a>UIPanel</h3></div></div></div><p>Select our <code class="literal">UI Root</code> GameObject. Below the <code class="literal">UIRoot</code> component, you'll find <code class="literal">UIPanel</code>.</p><p>
<code class="literal">UIPanel</code> acts like a widget <a id="id137" class="indexterm"></a>container—it creates the geometry. All child widgets will be rendered by this panel in one single draw call, if they all use the same atlas.</p><p>You might have more than one panel if you want to separate your UI, but keep in mind that a new panel equals a supplementary draw call.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>Wherever <code class="literal">UIPanel</code> is attached, a kinematic <code class="literal">Rigidbody</code> is also automatically added; don't worry, it's an optimization trick from NGUI.</p></div><p>The <span class="strong"><strong>UIPanel</strong></span> component<a id="id138" class="indexterm"></a> has three basic parameters:</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_01_30.jpg" /></div><p>These parameters<a id="id139" class="indexterm"></a> are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>
<span class="strong"><strong>Alpha</strong></span>: This the panel's global alpha value. It affects all child widgets and panels.</p></li><li><p>
<span class="strong"><strong>Depth</strong></span>: This is used to display an entire panel (and its child widgets) in front or behind another. It works in the same way as the other widgets' <span class="strong"><strong>Depth</strong></span> parameter.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p>Keep in mind that panel depth takes precedence over widget depth. In order to understand this clearly, consider the following situation:</p><p>
<code class="literal">PanelA</code> has a <span class="strong"><strong>Depth</strong></span> of <code class="literal">0</code> and holds <code class="literal">WidgetA</code> with a <span class="strong"><strong>Depth</strong></span> of 10. <code class="literal">PanelB</code> has a <span class="strong"><strong>Depth</strong></span> of <code class="literal">1</code> and holds <code class="literal">WidgetB</code> with a <span class="strong"><strong>Depth</strong></span> of <code class="literal">0</code>.</p><p>In the previous situation, even though <code class="literal">WidgetA</code> has a higher <span class="strong"><strong>Depth</strong></span> value, it will be displayed behind <code class="literal">WidgetB</code> because <code class="literal">PanelB</code> has a higher <span class="strong"><strong>Depth</strong></span> value than <code class="literal">PanelA</code>.</p></div></li><li><p>
<span class="strong"><strong>Clipping</strong></span>: Clipping consists in displaying only part of the panel using a mask that can be either a rectangle or a texture. Choose one of the four available clipping options:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">None</code>: No clipping occurs—the entire panel is visible.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Texture Mask</code>: You can select a texture to use as a mask to clip the panel. The <code class="literal">Offset</code> and <code class="literal">Center</code> parameters are available to adjust the texture's position, and the <code class="literal">Size</code> parameter lets you define a width and height for the texture mask.</p></li><li style="list-style-type: disc"><p>
<code class="literal">SoftClip</code>: Four new parameters appear to customize a clipping rectangle. Content outside this rectangle is not displayed. The <code class="literal">Softness</code> parameter is an area that smoothly fades out its contents.</p></li><li style="list-style-type: disc"><p>
<code class="literal">ConstrainButDon'tClip</code>: You can define a clipping rectangle, but no clipping occurs. Can be useful if you need to delimit an area without<a id="id140" class="indexterm"></a> hiding its contents.</p></li></ul></div></li></ol></div><p>You can set the <span class="strong"><strong>Clipping</strong></span> to <span class="strong"><strong>None</strong></span> and leave default values. We'll talk about the advanced parameters when we need them. Now, let's talk about the camera.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec27"></a>The camera system</h3></div></div></div><p>Select our <code class="literal">UI Root</code> |<code class="literal">Camera</code> GameObject. You can<a id="id141" class="indexterm"></a> see that it has both a Unity orthographic <code class="literal">Camera</code> and a <code class="literal">UICamera</code> component.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec09"></a>Orthographic Camera</h4></div></div></div><p>The orthographic (2D) <code class="literal">Camera</code> is<a id="id142" class="indexterm"></a> used to view our widgets and<a id="id143" class="indexterm"></a> render them over the <code class="literal">Main Camera</code> (3D) used to render the actual scene.</p><p>This is achieved by<a id="id144" class="indexterm"></a> setting the <span class="strong"><strong>rendering depth</strong></span> of <code class="literal">Main Camera</code> to <code class="literal">-1</code>, while the camera used to render NGUI widgets has a depth of <code class="literal">0</code> with the <span class="strong"><strong>Clear Flags</strong></span> parameter set to <span class="strong"><strong>Depth Only</strong></span>.</p><p>All these steps were executed automatically on the creation of a new 2D UI. Hence, we can see the widgets we created, rendered over  <code class="literal">Main Camera</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"></a>Note</h3><p>Here, we're talking about camera rendering depth, not NGUI widget <span class="strong"><strong>Depth</strong></span> value. The camera's depth defines its rendering order. The camera with the highest depth will be rendered over the others.</p></div><p>The <span class="strong"><strong>culling mask</strong></span>
<a id="id145" class="indexterm"></a> of the orthographic camera must be set to only display our 2D UI layer. Let's create one right now.</p><p>Click on the button to change our GameObject's <span class="strong"><strong>Layer</strong></span> (<span class="strong"><strong>1</strong></span>), and select <span class="strong"><strong>Add Layer...</strong></span> (<span class="strong"><strong>2</strong></span>). This is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_01_31.jpg" /></div><p>The Inspector <a id="id146" class="indexterm"></a>view now displays the <span class="strong"><strong>Layer</strong></span> menu. Next to <span class="strong"><strong>User Layer 8</strong></span>, type in our new layer's name: <code class="literal">2DUI</code>.</p><p>Now, reselect our <code class="literal">UI Root</code> GameObject in the <code class="literal">Hierarchy</code> view. In the Inspector view, you can notice that our <code class="literal">UIRoot</code> component and all its children are on the <code class="literal">2DUI</code> layer, and the <span class="strong"><strong>Culling Mask</strong></span> parameter of <code class="literal">Camera</code> is set to <span class="strong"><strong>2DUI</strong></span> only.</p><p>Now that we have our separate layer to hold our 2DUI, let's see what <code class="literal">UICamera</code> is.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec10"></a>UICamera</h4></div></div></div><p>We'll now explain<a id="id147" class="indexterm"></a> the purpose of <code class="literal">UICamera</code>, review its parameters, and <a id="id148" class="indexterm"></a>configure it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec04"></a>Purpose</h5></div></div></div><p>This component sends out messages<a id="id149" class="indexterm"></a> concerning events triggered on UI elements viewed by the camera it's attached to. For example, events such as <code class="literal">OnClick()</code>and <code class="literal">OnHover()</code>can be triggered on a button when the player clicks or hovers it.</p><p>You might have multiple cameras if needed. Here's an example with three different cameras:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>3D perspective<a id="id150" class="indexterm"></a> main camera that renders the game. Layer: Default.</p></li><li><p>Orthographic camera for in-game 2D UI elements. Layer: 2DUI.</p></li><li><p>Separate 3D perspective camera used for 3D menus. Layer: 3DUI.</p></li></ol></div><p>The afore mentioned cameras used for UI (cameras 2 and 3) need the <code class="literal">UICamera</code> component to interact with UI elements. The component can be added to the game's main camera (camera 1) if you want your 3D in-game objects to receive NGUI events too—they must have a <code class="literal">Collider</code> component attached to them.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>The in-game objects you wish to also receive NGUI events require <code class="literal">Collider</code> because these events are triggered by raycasts. Therefore, if the object has no <code class="literal">Collider</code> attached to it, the raycast will simply go through it.</p></div><p>Ok, now that we know the purpose of <code class="literal">UICamera</code>, we can review its parameters.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec05"></a>Parameters</h5></div></div></div><p>These are the 11<a id="id151" class="indexterm"></a> parameters of <span class="strong"><strong>UICamera</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_01_32.jpg" /></div><p>Let's see what the above<a id="id152" class="indexterm"></a> parameters correspond to:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>
<span class="strong"><strong>Event Type</strong></span>: Select which event type this camera will send. Types that concern the <code class="literal">UI</code> sort events depending on their <span class="strong"><strong>Depth</strong></span> value, whereas in <code class="literal">World</code> types events are sorted depending on their distance from the <code class="literal">Camera</code> component:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">3D World</code>: This is used to interact with 3D-world GameObjects. Select it if this is your 3D game's main camera.</p></li><li style="list-style-type: disc"><p>
<code class="literal">3D UI</code>: Option used for interaction with 3D user interfaces.</p></li><li style="list-style-type: disc"><p>
<code class="literal">2D World</code>: Select this option if this is your 2D game's main camera.</p></li><li style="list-style-type: disc"><p>
<code class="literal">2DUI</code>: This is used for interacting with the 2D UI.</p></li></ul></div></li><li><p>
<span class="strong"><strong>Event Mask</strong></span>: Select the layer on which the event raycast is triggered. For example, setting it to <span class="strong"><strong>Everything</strong></span> will result in all objects with <code class="literal">Colliders</code> receiving these events.</p></li><li><p>
<span class="strong"><strong>Events go to…</strong></span>: Here, you can select whether the objects you wish to receive events require either  <code class="literal">Colliders</code> or <code class="literal">Rigidbodies</code>.</p></li><li><p>
<span class="strong"><strong>Debug</strong></span>: This enables or disables debug mode. This option is useful when you have unwanted <a id="id153" class="indexterm"></a>behavior. When enabled, the currently hovered object is displayed in the top-left corner of the screen.</p></li><li><p>
<span class="strong"><strong>Allow Multi Touch</strong></span>: This enables or disables simultaneous touches. This is mandatory if you want to use pinch-to-zoom or other such gestures on mobile platforms.</p></li><li><p>
<span class="strong"><strong>Sticky Tooltip</strong></span>: This enables or disables the sticky tooltip option:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">Enabled</code>: The tooltip disappears when the mouse moves out of the widget's collider</p></li><li style="list-style-type: disc"><p>
<code class="literal">Disabled</code>: The tooltip disappears as soon as the mouse moves</p></li></ul></div></li><li><p>
<span class="strong"><strong>Tooltip Delay</strong></span>: This defines the required stationary time in seconds before the widget's tooltip is displayed.</p></li><li><p>
<span class="strong"><strong>Raycast Range</strong></span>: A raycast is an invisible ray that is cast from one point towards a specific direction and is stopped if it encounters another object. The <code class="literal">UICamera</code> uses raycasts from the mouse or touch position towards the forward direction of <code class="literal">Camera</code> to detect collisions and handle events. You might set the range of this raycast if you need to limit the interaction to a certain range. The default <span class="strong"><strong>-1</strong></span> value implies that the raycast's range will be as far as <code class="literal">Camera</code> can see, defined by its <span class="strong"><strong>Far Clipping Plane</strong></span> parameter.</p></li><li><p>
<span class="strong"><strong>Event Sources</strong></span>: You can specify which events this camera listens to:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Mouse</strong></span>: This is used for mouse movements: left/right/middle click, and scroll wheel</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Touch</strong></span>: This is used for touch-enabled devices</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Keyboard</strong></span>: This enables keyboard input. It uses the <code class="literal">OnKey()</code> event</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Controller</strong></span>: This enables support for joysticks or game controllers</p></li></ul></div></li><li><p>
<span class="strong"><strong>Thresholds</strong></span>: These values come in handy when you want to specify the minimum values before a particular event is triggered:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Mouse Drag</strong></span>: When a mouse button is pressed (the <code class="literal">OnPress()</code>event is triggered), this value determines how far in pixels the mouse must move before it is considered a drag, and sends <code class="literal">OnDrag()</code>events to the dragged object</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Mouse Click</strong></span>: When<a id="id154" class="indexterm"></a> a mouse button is pressed (the <code class="literal">OnPress()</code>event is triggered), this value determines how far in pixels the mouse can travel before the button release has no effect (the <code class="literal">OnClick()</code>event is not triggered)</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Touch Drag</strong></span>: This is the same as <span class="strong"><strong>Mouse Drag</strong></span>, but for touch-based devices</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Touch Tap</strong></span>: This is the same as <span class="strong"><strong>Mouse Click</strong></span>, but for touch-based devices</p></li></ul></div></li><li><p>
<span class="strong"><strong>Axes and Keys</strong></span>: These parameters let you assign Unity input axes and keys to NGUI's input system.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Horizontal</strong></span>: This is the input axis for horizontal movement (the left and right key events)</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Vertical</strong></span>: This is the input axis for vertical movement (the up and down key events)</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Scroll</strong></span>: This is the input axis for scrolling</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Submit 1</strong></span>: This is the primary keycode for validation</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Submit 2</strong></span>: This is the secondary keycode for validation</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Cancel 1</strong></span>: This is the primary keycode for cancel</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Cancel 2</strong></span>: This is the secondary keycode for cancel</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>You can edit Unity input axes at any time by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Input</strong></span>.</p></div></li></ol></div><p>Now that we have reviewed the parameters of <code class="literal">UICamera</code>, we can configure it for our project.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch01lvl4sec06"></a>Configuration</h5></div></div></div><p>We will now configure our <code class="literal">UICamera</code> component for this specific camera so that it suits our project and our future UI. Select<a id="id155" class="indexterm"></a> our <code class="literal">UI Root</code> | <code class="literal">Camera</code> GameObject, and then:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Set the <span class="strong"><strong>Event Type</strong></span> parameter to <span class="strong"><strong>3DUI</strong></span> because this camera will be used for both 2D and 3D UI interactions.</p></li><li><p>Set the <span class="strong"><strong>Event Mask</strong></span> to the <span class="strong"><strong>2DUI</strong></span> layer only since our UI will reside on it.</p></li><li><p>Set <span class="strong"><strong>Events go to...</strong></span> to the <span class="strong"><strong>Colliders</strong></span> value because our widgets will have <code class="literal">Colliders</code> attached to them.</p></li></ol></div><p>Good. We are now ready to create more interactive user interface elements.</p></div></div></div></div>