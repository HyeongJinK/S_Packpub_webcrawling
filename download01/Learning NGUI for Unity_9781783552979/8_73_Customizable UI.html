<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec72"></a>Customizable UI</h2></div></div><hr /></div><p>A very interesting feature that we <a id="id886" class="indexterm"></a>will add to our game is the possibility for the players to choose where their in-game UI elements are displayed. This ensures a much greater flexibility of the user interface.</p><p>The player can simply touch and hold their finger on any in-game UI element, and the game pauses and the touched element becomes draggable. The game resumes as soon as the player has dropped its UI element at their required location.</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_08_08.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec135"></a>Draggable UI elements</h3></div></div></div><p>We will use the <code class="literal">UIDrag Object</code> component along with <code class="literal">Box Colliders</code> to make our UI elements draggable. These colliders<a id="id887" class="indexterm"></a> will be attached to the<a id="id888" class="indexterm"></a> widgets' sprites so that their <span class="strong"><strong>Collider auto-adjust to match</strong></span> option becomes available.</p><p>First, we have to add box colliders on our UI elements:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select our <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>Score</strong></span> | <span class="strong"><strong>Background</strong></span> GameObject:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In the <span class="strong"><strong>Inspector</strong></span> panel, click on the <span class="strong"><strong>Add Component</strong></span> button.</p></li><li style="list-style-type: disc"><p>Type <code class="literal">box</code> to search for components with that name.</p></li><li style="list-style-type: disc"><p>Select <span class="strong"><strong>Box Collider</strong></span> and hit your keyboard's <span class="emphasis"><em>Enter</em></span> key.</p></li></ul></div></li><li><p>Select both <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>Score</strong></span> | <span class="strong"><strong>Background</strong></span> and <span class="strong"><strong>TopButtons</strong></span> | <span class="strong"><strong>Pause</strong></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In the <span class="strong"><strong>Inspector</strong></span> panel, click on the <span class="strong"><strong>Add Component</strong></span> button</p></li><li style="list-style-type: disc"><p>Type <code class="literal">obj</code> to search for components with that name</p></li><li style="list-style-type: disc"><p>Select <span class="strong"><strong>Drag Object </strong></span>and hit your keyboard's <span class="emphasis"><em>Enter</em></span> key</p></li></ul></div></li></ol></div><p>Follow these steps to <a id="id889" class="indexterm"></a>configure their drag targets individually:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select our <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>Score</strong></span> | <span class="strong"><strong>Background</strong></span> GameObject:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Drag <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>Score</strong></span> in the <span class="strong"><strong>Target</strong></span> field of <code class="literal">UIDrag</code> object</p></li></ul></div></li><li><p>Select our <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>TopButtons</strong></span> | <span class="strong"><strong>Pause</strong></span> GameObject:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Drag <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>TopButtons</strong></span> | <span class="strong"><strong>Pause</strong></span> (itself) in the <span class="strong"><strong>Target</strong></span> field of <code class="literal">UIDrag</code> object</p></li></ul></div></li></ol></div><p>Now, we can configure<a id="id890" class="indexterm"></a> these components. Select both <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>Score</strong></span> | <span class="strong"><strong>Background</strong></span> and <span class="strong"><strong>TopButtons</strong></span> | <span class="strong"><strong>Pause</strong></span> GameObjects:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Check the <code class="literal">UISprites</code> <span class="strong"><strong>Collider auto-adjust to match</strong></span> option.</p></li><li><p>Check the <span class="strong"><strong>Is Trigger</strong></span> option of the box collider.</p></li><li><p>Set <span class="strong"><strong>Movement</strong></span> of <code class="literal">UIDrag</code> object to {<code class="literal">1</code>, <code class="literal">1</code>, <code class="literal">1</code>}.</p></li><li><p>Set <span class="strong"><strong>Drag Effect</strong></span> of <code class="literal">UIDrag</code> object to <span class="strong"><strong>None</strong></span>.</p></li></ol></div><p>Ok. Now, both the UI elements are draggable around the screen. We must make sure that they aren't draggable at start, and become draggable after the player holds his finger on them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec136"></a>Activating drag</h3></div></div></div><p>We will create a new <code class="literal">CustomizableUIElement</code> component, which will be attached to all draggable user interface<a id="id891" class="indexterm"></a> widgets. It will make sure <a id="id892" class="indexterm"></a>they aren't draggable at start and handle the touch-and-hold process. After that, we'll have to do a few modifications on the <code class="literal">GameManager</code> component to make sure that the hold process handles draggable UI elements.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec88"></a>The CustomizableUIElement component</h4></div></div></div><p>Follow these steps to <a id="id893" class="indexterm"></a>create the <a id="id894" class="indexterm"></a>new <code class="literal">CustomizableUIElement</code> component:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select both <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>Score</strong></span> | <span class="strong"><strong>Background</strong></span> and <span class="strong"><strong>TopButtons</strong></span> | <span class="strong"><strong>Pause</strong></span>.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, click on the <span class="strong"><strong>Add Component</strong></span> button.</p></li><li><p>Type in <code class="literal">CustomizableUIElement</code> and hit the <span class="emphasis"><em>Enter</em></span> key.</p></li><li><p>Make sure <span class="strong"><strong>Language</strong></span> is set to <span class="strong"><strong>CSharp</strong></span> and hit <span class="emphasis"><em>Enter</em></span> again.</p></li></ol></div><p>Open our new <code class="literal">CustomizableUIElement.cs</code> script and declare this global variable:</p><div class="informalexample"><pre class="programlisting">// We'll need the widget's UIDragObject
<span class="strong"><strong>private UIDragObject dragObject;</strong></span>
</pre></div><p>Now, replace the <a id="id895" class="indexterm"></a>default <code class="literal">Start()</code> method <a id="id896" class="indexterm"></a>with this one to retrieve <code class="literal">UIDragObject</code> and disable it when the game begins:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>private void Start()</strong></span>
{
  // Retrieve the widget's UIDragObject
<span class="strong"><strong>  dragObject = GetComponent&lt;UIDragObject&gt;();</strong></span>
  // Make sure the widget isn't draggable
<span class="strong"><strong>  SetDraggable(false);</strong></span>
}</pre></div><p>OK. In the preceding code, we call the <code class="literal">SetDraggable()</code> method to make the widget not draggable by default. Add the following <code class="literal">SetDraggable()</code> method before we continue:</p><div class="informalexample"><pre class="programlisting">// Sets the widget draggable or not
<span class="strong"><strong>public void SetDraggable(bool draggable)</strong></span>
{
  // If draggable and hovered object is still this one
<span class="strong"><strong>  if(draggable &amp;&amp; UICamera.hoveredObject == gameObject)</strong></span>
  {
    // Disable the UIDragObject's movement
<span class="strong"><strong>    dragObject.dragMovement = Vector3.one;</strong></span>
    // Make the widget transparent
<span class="strong"><strong>    TweenAlpha.Begin(gameObject, 0.2f, 0.4f);</strong></span>
    // Make the widget slightly bigger
<span class="strong"><strong>    TweenScale.Begin(gameObject, 0.2f, Vector3.one * 1.15f);</strong></span>
    // Pause the game
<span class="strong"><strong>    GameManager.Instance.SetPause(true);</strong></span>
  }
  // If it's now not draggable
  else
  {
    // Re-enable the UIDragObject's movement
<span class="strong"><strong>    dragObject.dragMovement = Vector3.zero;</strong></span>
    // Reset the widget's alpha value
<span class="strong"><strong>    TweenAlpha.Begin(gameObject, 0.2f, 1f);</strong></span>
    // Reset the widget's original size
<span class="strong"><strong>    TweenScale.Begin(gameObject, 0.2f, Vector3.one);</strong></span>
    // Cancel the hold feedback if there is one
<span class="strong"><strong>    GameManager.Instance.CancelHoldFeedback();</strong></span>
    // Unpause the game
<span class="strong"><strong>    GameManager.Instance.SetPause(false);</strong></span>
  }
}</pre></div><p>Good. Now, we must<a id="id897" class="indexterm"></a> implement the <code class="literal">OnPress()</code> event to make sure that the hold-feedback process starts when the UI element is pressed<a id="id898" class="indexterm"></a> and cancelled on release:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>void OnPress(bool pressed)</strong></span>
{
  // If widget has just been pressed, show hold feedback
  if(pressed)
  {
    // Parameters to pass to the Coroutine
<span class="strong"><strong>    object[] parameters = new object[2]{transform, 0.35f};</strong></span>
    // Cancel hold feedback if there is one
<span class="strong"><strong>    GameManager.Instance.CancelHoldFeedback();</strong></span>
    // Start the HoldFeedback routine
  <span class="strong"><strong>  GameManager.Instance.StartCoroutine("HoldFeedbackRoutine", parameters);</strong></span>
  }
  // If widget has just been released
  else
  {
    // Make sure the widget isn't draggable
<span class="strong"><strong>    SetDraggable(false);</strong></span>
  }
}</pre></div><p>In the preceding <code class="literal">OnPress()</code> method, we start <code class="literal">HoldFeedbackRoutine()</code> with the clicked widget and a hold duration of 0.35 seconds as parameters.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec89"></a>The GameManager component</h4></div></div></div><p>We have a small modification<a id="id899" class="indexterm"></a> to apply to the <code class="literal">GameManager</code> component's <code class="literal">HoldFeedbackRoutine()</code> coroutine. Indeed, for now, we have configured it to call to show the elemental switch UI when the hold action is completed. We must now<a id="id900" class="indexterm"></a> add a few lines to handle draggable UI elements.</p><p>Open the <code class="literal">GameManager.cs</code> script and add this variable declaration within the <code class="literal">HoldFeedbackRoutine()</code> coroutine, just below the <code class="literal">float delay = 0.2f;</code> declaration:</p><div class="informalexample"><pre class="programlisting">// Retrieve concerned object's CustomizableUIElement
<span class="strong"><strong>CustomizableUIElement customizableElement =</strong></span>
<span class="strong"><strong>  concernedObject.GetComponent&lt;CustomizableUIElement&gt;();</strong></span>
</pre></div><p>Now, at the end of the same coroutine, add the following <code class="literal">else if</code> condition to handle customizable UI elements, just below the closing bracket of the <code class="literal">if(powerSourc</code>
<code class="literal">e != null)</code> statement:</p><div class="informalexample"><pre class="programlisting">// If it's a customizable UI element
<span class="strong"><strong>else if(customizableElement != null)</strong></span>
{
  // Make it draggable
<span class="strong"><strong>  customizableElement.SetDraggable(true);</strong></span>
}</pre></div><p>Save all the scripts. Build <a id="id901" class="indexterm"></a>and run the game on your device. You can notice that the process works, and the score counter and pause button can now be dragged after a long touch.</p><p>Surprisingly, the <code class="literal">HoldFeedback</code> sprite doesn't appear over the concerned widget but at the bottom of the screen, as follows:</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_08_09.jpg" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec137"></a>Why is this happening?</h3></div></div></div><p>The <code class="literal">FollowObject</code> component attached to our <code class="literal">HoldFeedback</code> sprite has the <code class="literal">GameCamera</code> component set as <code class="literal">mainCamera</code>. With that configuration, the hold feedback icon follows the power sources correctly since they are 3D environment objects viewed by <code class="literal">GameCamera</code>.</p><p>Unfortunately, our 3D UI widgets aren't viewed by the <code class="literal">GameCamera</code> component but by <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>Camera</strong></span>.</p><p>In order to have the <code class="literal">HoldFeedback</code> sprite<a id="id902" class="indexterm"></a> follow in-game 3D widgets, we need to set through code its <code class="literal">FollowObject</code> component's <code class="literal">mainCamera</code> parameter to <span class="strong"><strong>InGame3DUI</strong></span> | <span class="strong"><strong>Camera</strong></span>.</p><p>Add these two <code class="literal">Camera</code> declarations as global variables of <code class="literal">GameManager.cs</code>:</p><div class="informalexample"><pre class="programlisting">// Game Main Camera
<span class="strong"><strong>Camera gameMainCamera;</strong></span>
// 3D UI Camera
<span class="strong"><strong>Camera inGame3DUICamera;</strong></span>
</pre></div><p>OK. Initialize the preceding variables by adding these two lines in the <code class="literal">Start()</code> method:</p><div class="informalexample"><pre class="programlisting">// Retrieve the game's Main Camera
<span class="strong"><strong>gameMainCamera = Camera.main;</strong></span>
// Retrieve the 3D UI Camera
<span class="strong"><strong>inGame3DUICamera = NGUITools.FindCameraForLayer(10);</strong></span>
</pre></div><p>Now, let's create a<a id="id903" class="indexterm"></a> new <code class="literal">HoldFollowsEnvironment()</code> method to switch the <code class="literal">mainCamera</code> parameter between <code class="literal">gameMainCamer</code>
<code class="literal">a</code> and <code class="literal">inGame3DUICamera</code>:</p><div class="informalexample"><pre class="programlisting">// HoldFeedback either follows env 3D object or 3D UI
<span class="strong"><strong>public void HoldFollowsEnvironment(bool follows3DObject)</strong></span>
{
  // If HoldFeedback must follow a 3D env object
  if(follows3DObject)
  {
    // Set the FollowObject's camera to the env cam
<span class="strong"><strong>    holdFeedbackFollowObject.mainCamera = gameMainCamera;</strong></span>
  }
  // If it must follow a 3D UI widget
  else
  {
    // Set the FollowObject's camera to the 3DUI cam
<span class="strong"><strong>    holdFeedbackFollowObject.mainCamera = inGame3DUICamera;</strong></span>
  }
}</pre></div><p>Good. We can now request to switch between these cameras when necessary. Open the <code class="literal">PowerSource.cs</code> script and add this line within the <code class="literal">OnPress()</code> method, just above the <code class="literal">GameManager.Instance.StartCoroutine("HoldFeedbackRoutine", p</code>
<code class="literal">arameters)</code> instruction:</p><div class="informalexample"><pre class="programlisting">// Set the HoldFeedback to follow 3D Object
<span class="strong"><strong>GameManager.Instance.HoldFollowsEnvironment(true);</strong></span>
</pre></div><p>Now, open <code class="literal">CustomizableUIElement.cs</code> and add this line within the <code class="literal">OnPress()</code> method just below the <code class="literal">GameManager.Instance.CancelHold</code>
<code class="literal">Feedback()</code> instruction:</p><div class="informalexample"><pre class="programlisting">// Set the HoldFeedback to follow a 3D UI widget
<span class="strong"><strong>GameManager.Instance.HoldFollowsEnvironment(false);</strong></span>
</pre></div><p>Save all the scripts and return to Unity. Then, build and run the game on your mobile device.</p><p>We've corrected the problem: the hold feedback icon is now correctly displayed above the power sources and 3D widgets when the player holds their finger on them:</p><div class="mediaobject"><img src="/graphics/9781783552979/graphics/2979OT_08_10.jpg" /></div><p>Great. The player can now <a id="id904" class="indexterm"></a>move their in-game UI widgets around and place them where they want. Now, we can discuss a great way to test your game easily.</p></div></div>