<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec30"></a>Writing the character code and connecting the PlayerInput class to it</h2></div></div><hr /></div><p>The last <a id="id125" class="indexterm"></a>stage of the character is its code class. The code class will <a id="id126" class="indexterm"></a>receive input from the PlayerInput <a id="id127" class="indexterm"></a>class we wrote earlier, so the character can be controlled through the input and filter out the type of GameObjects that collided with from the parent of that collider type.</p><p>Perform the following steps:</p><p>To start with, navigate to the <code class="literal">Assets/Scripts</code> folder and right-click on it. Select <span class="strong"><strong>Create</strong></span> and then <span class="strong"><strong>C# Script</strong></span>. Name it <code class="literal">Character</code>.</p><p>Next, we need to give our <code class="literal">PlayerInput</code> class a reference to our character. To perform this, navigate to the <code class="literal">Assets/Scripts</code> folder and double-click on the <code class="literal">PlayerInput.cs</code> file to open it.</p><p>At the top of the <a id="id128" class="indexterm"></a>class, under the <code class="literal">SimpleTouch</code> struct, add the following code:</p><div class="informalexample"><pre class="programlisting">    public Character GameCharacter;</pre></div><p>We also need to tie the function that will call <code class="literal">GameCharacter</code> when <code class="literal">PlayerInput</code> gets a new one. At the <a id="id129" class="indexterm"></a>bottom of the <code class="literal">CalculateTouchInput</code> <a id="id130" class="indexterm"></a>function, add the following code:</p><div class="informalexample"><pre class="programlisting">        if (GameCharacter != null)
        {
          if (!GameCharacter.isDead)
          {
            GameCharacter.RecieveInput(touchDistance, touchDirection);
          }
        }</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec22"></a>Character attributes</h3></div></div></div><p>At the top of <a id="id131" class="indexterm"></a>the <code class="literal">Character</code> class, we need to add the bool value that will be used to know whether a character is jumping or not and if a character is dead or alive; we need an int value to know how many coins a character has and if a character should be fading out. The <code class="literal">isJumping</code> bool will be used in the code that we will write to know when the character jumps from the <code class="literal">SimpleTouch</code> type of <code class="literal">PlayerInput</code>. Finally, we will store references to <code class="literal">GameCharacterSprite</code> and <code class="literal">CharacterRigidBody</code> so that we can use them through the use of this class. Add the following code before the <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">    [System.NonSerialized]
    public bool isJumping;

    [System.NonSerialized]
    public bool isDead;

    [System.NonSerialized]
    public int CoinCount;

    [System.NonSerialized]
    public Vector3 RestartLocation;

    private bool isFadeOut;

    SpriteRenderer GameCharacterSprite;

    Rigidbody2D CharacterRigidBody;

    Animator CharacterAnimator;</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip19"></a>Tip</h3><p><code class="literal">[Sytem.NonSerialized]</code> is a way to declare a public variable and have Unity ignore it when it populates the exposed component variables. It means that <code class="literal">isJumping</code> won't show up in the component list of variables in the editor. It will also prevent this variable from being serialized. Serialization is the process of converting an object to a stream of bytes so that it can be transmitted into memory.</p></div><p>To explain more, let's <a id="id132" class="indexterm"></a>understand the following terms:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">isJumping</code>: This is the bool value to let both the class and the animator know if the character is jumping. <span class="emphasis"><em>True</em></span> is jumping, whereas <span class="emphasis"><em>false</em></span> is not jumping.</p></li><li style="list-style-type: disc"><p><code class="literal">isDead</code>: This is a bool value that does exactly what the <code class="literal">isJumping</code> bool does only to check whether the player is dead or not. Again, <span class="emphasis"><em>true</em></span> is dead, whereas <span class="emphasis"><em>false</em></span> is not dead.</p></li><li style="list-style-type: disc"><p><code class="literal">CoinCount</code>: This specifies how many coins the player has collected. Later on, we will store this value so it doesn't reset every time the player restarts the game.</p></li><li style="list-style-type: disc"><p><code class="literal">RestartLocation</code>: This denotes the <code class="literal">Vector3</code> location that we can use to reset the character to after they have died.</p></li><li style="list-style-type: disc"><p><code class="literal">IsFadeOut</code>: This is a bool that transitions the character from an opaque state to a translucent state. <span class="emphasis"><em>True</em></span> is fading to translucent, whereas <span class="emphasis"><em>false</em></span> is fading to opaque.</p></li><li style="list-style-type: disc"><p><code class="literal">GameCharacterSprite</code>, <code class="literal">CharacterRigidBody</code>, and <code class="literal">CharacterAnimator</code>: These are references that we can keep, so we don't have to keep getting them. <code class="literal">GameCharacterSprite</code> is the sprite sheet, <code class="literal">CharacterRigidBody</code> is Rigidbody 2D for the character, and <code class="literal">CharacterAnimator</code> is the animation tree for the character.</p></li></ul></div><p>To set some of these values, we can use the <code class="literal">Start</code> function. Add the following code in the <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">  // Use this for initialization
  void Start ()
  {
    RestartLocation = gameObject.transform.position;
    GameCharacterSprite = gameObject.GetComponent&lt;SpriteRenderer&gt;( );
    CharacterRigidBody = gameObject.GetComponent&lt;Rigidbody2D&gt;( );
    CharacterAnimator = gameObject.GetComponent&lt;Animator&gt;( );
  }</pre></div><p>This allows you to <a id="id133" class="indexterm"></a>use all of these references in the other code for this class without having to use the <code class="literal">GetComponent</code> function again and again.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>PlayerInput</h3></div></div></div><p>Now, we know that we <a id="id134" class="indexterm"></a>have to have a couple things for character to be functional. Character needs to take the <code class="literal">SimpleInput</code> struct data from <code class="literal">PlayerInput</code> so that it knows how to move, and the character needs a function to know when it has collided with another GameObject that has a collider.</p><p>Under the <code class="literal">Update</code> function in the <code class="literal">Character</code> class, add the following functions:</p><div class="informalexample"><pre class="programlisting">    // Get input data from PlayerInput
    public void RecieveInput(float Distance, Vector2 Direction)
    {
      if (CharacterRigidBody != null &amp;&amp; CharacterAnimator != null )
      {
        Direction.x = 0.0f;
        if (Direction.y &gt; 0.0f &amp;&amp; !isJumping)
        {
          CharacterRigidBody.AddForce(Direction * Mathf.Clamp(Distance, 0, 200));

          CharacterAnimator.SetBool("Jump", true);
          isJumping = true;
        }
        else if ( Direction.y &lt; 0.0f )
        {
          CharacterRigidBody.AddForce(Direction * Mathf.Clamp(Distance, 0, 250));
        }
      }
    }

    // When the character collides with another GameObject
    void OnCollisionEnter2D(Collision2D Col)
    {
      if (CharacterAnimator != null)
      {
        CharacterAnimator.SetBool("Jump", false);
        isJumping = false;
      }
    }</pre></div><p>The <code class="literal">RecieveInput</code> function takes the parameters, the distance of the player's swipe, and the direction of the player's swipe. We need the distance in order to know how "hard" the player swiped on the screen, and we need the direction to know whether the player swiped up or down.</p><p>When we receive this data from <code class="literal">PlayerInput</code>, we then need to get ready to use it. To begin, we need a reference to the <span class="strong"><strong>Character</strong></span> GameObject's Rigidbody 2D component. To have this, we will use <code class="literal">gameObject.GetComponent&lt;Rigidbody2D&gt;( )</code> and store it in a local variable named <code class="literal">characterRigidBody</code>.</p><p>We will also need a reference to the animator on character that holds the controller. The controller holds the <code class="literal">Jump</code> variable, which we will set when the character jumps.</p><p>We then check to make sure that <code class="literal">characterRigidBody</code> is something by checking that it is <span class="emphasis"><em>not</em></span> null; null meaning empty. We also perform the same for <code class="literal">characterAnimator</code>.</p><p>If we have a reference in <a id="id135" class="indexterm"></a>
<code class="literal">characterRigidBody</code> to GameObject's Rigidbody 2D, we start by making sure that the <span class="strong"><strong>X</strong></span> axis in <span class="strong"><strong>Swipe</strong></span> is set to <code class="literal">0</code>. This means that the direction will only be up and down, so the player can't jump forward or backward.</p><p>We then check whether the <span class="strong"><strong>Y</strong></span> axis on the <span class="strong"><strong>Direction</strong></span> parameter is more than <code class="literal">0.0</code>, meaning the player swiped up if the character is not already jumping. If this is <code class="literal">true</code>, we will add a force to the <code class="literal">Rigidbody2D</code> character.</p><p><code class="literal">AddForce</code> takes two arguments: the direction the force needs to be and how much force to apply to Rigidbody 2D. For us, the direction has already been given and altered. The force amount is calculated using <code class="literal">Mathf.Clamp( )</code>.</p><p><code class="literal">Mathf.Clamp( )</code> is a way to make sure that the force value is within bounds. If we let the distance decide how much force is added to the character always, the character would go shooting off into space if the player swiped the entire screen of their device. So, we will use the clamp function to check whether the swipe distance is less than 200 and use this value. If the swipe distance is more than 200, clamp it down to 200.</p><p>After <code class="literal">Rigidbody2D</code> character has a force, we want to update the controller so that it knows to switch to the jumping animation. We do this by setting the <code class="literal">Jump</code> bool value to true with the stored reference set earlier in the function and check to make sure that it exists.</p><p>As the character needs to know whether it is jumping, we will set <code class="literal">isJumping</code> to <code class="literal">true</code> here as well. This way if the player tries to swipe while character is already jumping, the condition we have will fail. Also, there will be no force added in the positive <span class="strong"><strong>Y</strong></span> axis. If we didn't have this check, the player would be able to swipe continuously. Also, the character would continue to jump higher and higher.</p><p>If the first condition that checks whether the direction of the swipe is in positive Y and if character is <span class="emphasis"><em>not</em></span> jumping fails, we check whether the direction of the swipe is in negative Y. The reason we don't check <code class="literal">isJumping</code> here is because it doesn't matter if we swipe down if the player is or isn't currently jumping. If Character is already on the ground, it can't go farther down, and if the character is jumping, a force downwards will make it fall to the ground faster, which is intended in design.</p><p>The <code class="literal">OnCollisionEnter2D</code> function is a Unity function designed to manage what happens when colliders collide.</p><p><code class="literal">OnCollisionEnter2D</code> takes a single parameter: the collider that was collided with. For the moment, the only thing we know is that the character can collide with the temporary floor we have on the scene. As <a id="id136" class="indexterm"></a>a result, we can assume that the only thing to do here is to stop the player from jumping. We start by having the reference back to the character's <span class="strong"><strong>Animator</strong></span> component and check whether it exists. If it does, we will set the <code class="literal">Jump</code> bool value to <code class="literal">false</code>; to set that the player is no longer jumping, we will also set the <code class="literal">isJumping</code> class variable to <code class="literal">false</code>, so if the player was to swipe upwards again, the <code class="literal">AddForce</code> function gets a call. Also, the character will jump.</p><p>We will compare the type of GameObject with the one that is being collided with so that we can decide what to do with the colliding GameObject as well as what to do with the <span class="strong"><strong>Character</strong></span> GameObject.</p><p>If you play the game now, you should see the character transition from jumping and not jumping; this is based on the player input of swiping upwards to jump and the character stopping the jump by hitting the temporary floor</p><p>In addition, we will check to make sure that <code class="literal">GameCharacter</code> isn't null (it exists); we also  make sure that it is not dead and then we will call <code class="literal">GameCharacter.RecieveInput( )</code>, which will send <code class="literal">touchDistance</code> and <code class="literal">touchDirection</code> to the <code class="literal">Character</code> class, which allows you to control the character based on them.</p><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Save this <code class="literal">PlayerInput</code> file and navigate back to Unity, which should compile the code now.</p></li><li><p>After the code is compiled, right-click on <span class="strong"><strong>Hierarchy</strong></span> and select <span class="strong"><strong>Create Empty</strong></span>.</p></li><li><p>Name this new GameObject as <code class="literal">Player Input</code>.</p></li><li><p>With the <span class="strong"><strong>PlayerInput</strong></span> GameObject chosen, select <span class="strong"><strong>Add Componen</strong></span>t from the <span class="strong"><strong>Inspector</strong></span> window.</p></li><li><p>Search for <span class="strong"><strong>PlayerInput</strong></span> and select <span class="strong"><strong>PlayerInput</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_03_12.jpg" /></div></li><li><p>Next, select the <span class="strong"><strong>Character</strong></span> GameObject.</p></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> window, select <span class="strong"><strong>Add Component.</strong></span> Then, search for <span class="strong"><strong>Character</strong></span> and select <span class="strong"><strong>Character</strong></span>.</p></li><li><p>Now, select the <a id="id137" class="indexterm"></a>
<span class="strong"><strong>PlayerInput</strong></span> GameObject and then left-click on the <span class="strong"><strong>Character</strong></span> GameObject and drag the object onto the <span class="strong"><strong>Character</strong></span> field of the <span class="strong"><strong>PlayerInput</strong></span> component:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_03_13.jpg" /></div></li></ol></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip20"></a>Tip</h3><p>If you are like me and have <span class="strong"><strong>Swipe Time</strong></span> and <span class="strong"><strong>Swipe Distance</strong></span> set to <code class="literal">0</code>, the settings from the <code class="literal">PlayerInput</code> chapter are <span class="strong"><strong>Swipe Time</strong></span> = <code class="literal">0.08</code> and <span class="strong"><strong>SwipeDistance</strong></span> = <code class="literal">25</code>.</p></div><p>This will give the <span class="strong"><strong>PlayerInput</strong></span> component of the <span class="strong"><strong>PlayerInput</strong></span> GameObject a reference to the <span class="strong"><strong>Character</strong></span> GameObject. This also allows you to use <span class="strong"><strong>PlayerInput</strong></span> to "communicate" with <span class="strong"><strong>Character</strong></span> or to be more direct, send the <code class="literal">SimpleTouch</code> struct data of the current touch input from the user to a function of <span class="strong"><strong>Character</strong></span> so that <span class="strong"><strong>Character</strong></span> knows what it should do.</p><p>Next double-click on the <code class="literal">Character.cs</code> class to open it. Like the <code class="literal">PlayerInput</code> class, you will see the generated code from Unity; this includes the <code class="literal">Start</code> and <code class="literal">Update</code> functions and the two <code class="literal">Using</code> declarations as well.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>The KillCharacter function</h3></div></div></div><p>Now, we need to <a id="id138" class="indexterm"></a>write a function to kill the character. This will be used when the character collides with an obstacle.</p><p>Under the <code class="literal">OnCollisionEnter2D</code> function, add the following code:</p><div class="informalexample"><pre class="programlisting">    // Kills the character
    public void KillCharacter()
    {
      if (!isDead)
      {
        if (CharacterRigidBody != null)
        {
          CharacterRigidBody.AddForce(new Vector2(Random.Range(-1, 1), 1) * 512);
          isDead = true;
          isFadeOut = true;
        }
      }
    }</pre></div><p>This function is designed to make sure that the character's Rigidbody 2D component exists—by making sure it is <span class="emphasis"><em>not</em></span> null—add a force to it in a random direction between the negative <span class="emphasis"><em>one</em></span> and the positive <span class="emphasis"><em>one</em></span> on the <span class="strong"><strong>X</strong></span> axis and the positive <span class="emphasis"><em>one</em></span> on the <span class="strong"><strong>Y</strong></span> axis. This means that a force will be added, which will throw the character upwards with the force of the random direct multiplied by 512. We can also set the character as dead, so it won't be able to pick up anything.</p><p>To avoid having the character go floating off into space, let's use the <code class="literal">isFadeOut</code> variable to fade the character if it is true. This way the player will see the character fade to transparent before it escapes the screen.</p><p>In the <code class="literal">Update</code> function of the character C# class, add the following code:</p><div class="informalexample"><pre class="programlisting">  // Update is called once per frame
  void Update () 
  {
    if (isFadeOut)
    {
      if (GameCharacterSprite != null)
      {
        float currentAlpha = GameCharacterSprite.color.a;
        currentAlpha -= 0.0085f;

        if (currentAlpha &lt; 0.01f)
        {
          currentAlpha = 0.0f;
        }

        Color newColorAlpha = new Color(1.0f, 1.0f, 1.0f, currentAlpha);
        GameCharacterSprite.color = newColorAlpha;
      }
    }
  }</pre></div><p>Let's start by checking whether the <code class="literal">isFadeOut</code> bool value is <code class="literal">true</code>. If so, we can continue to set the alpha of <code class="literal">SpriteRenderer</code>. To set the alpha or fade out the <span class="strong"><strong>Character</strong></span> sprite, we will need a reference to its <code class="literal">SpriteRenderer</code> component. We can have this by using the <code class="literal">gameObject.GetComponent</code> function. When we have this, we can make sure it exists by verifying that it is <span class="emphasis"><em>not</em></span> null. We will then set a float variable to the current value of the <code class="literal">SpriteRenderer</code> reference and then subtract a small amount from this.</p><p>We will then check <a id="id139" class="indexterm"></a>
<code class="literal">currentAlpha</code> of the sprite to check whether it is less than <code class="literal">0.01</code>. If it is, we set <code class="literal">currentAlpha</code> to <code class="literal">0</code>. Also, we will create a new <code class="literal">Color</code> variable and set the alpha channel to the <code class="literal">currentAlpha</code> value.</p><p>Finally, we will set the reference to the <code class="literal">SpriteRenderer.color</code> value to the updated alpha value.</p><p>Then, we will need a function that will reset the character back to running. This will be used later on when we create a reset button in the UI. Write the following function under <code class="literal">KillCharacter</code>:</p><div class="informalexample"><pre class="programlisting">      // Revives the character
      public void ReviveCharacter()
      {
        Color resetColorAlpha = new Color( 1.0f, 1.0f, 1.0f, 1.0f );

        gameObject.transform.position = RestartLocation;
        isDead = false;
        isFadeOut = false;

        if (GameCharacterSprite != null)
        {
          GameCharacterSprite.color = resetColorAlpha;
        }
      }</pre></div><p>To revive the character is quite easy. We can create a new world location at the <code class="literal">0X</code>, <code class="literal">0Y</code>, and <code class="literal">0Z</code> location (the center of the world) and set the <span class="strong"><strong>Character</strong></span> GameObject to that location.</p><p>We also need to reset the <code class="literal">SpriteRenderer.color.a</code> (alpha) value back to default. To do this, we need to get a reference of <code class="literal">SpriteRenderer</code> and make sure that it exists by making sure that it is <span class="emphasis"><em>not</em></span> null.</p><p>If it exists, we set the color value of <code class="literal">SpriteRenderer</code> to the <code class="literal">resetColorAlpha</code> value, which is <code class="literal">1.0f</code> red, <code class="literal">1.0f</code> green, <code class="literal">1.0f</code> blue, and <code class="literal">1.0f</code> alpha by default.</p><p>We will then set <a id="id140" class="indexterm"></a>
<code class="literal">isDead</code> to <code class="literal">false</code>, meaning that the character is alive, and set <code class="literal">isFadeOut</code> to <code class="literal">false</code> so that the character does not fade out anymore.</p></div></div>