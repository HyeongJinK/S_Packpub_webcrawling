<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec15"></a>Creating the Input GameObject</h2></div></div><hr /></div><p>Save the <a id="id82" class="indexterm"></a>document and then maximize or select Unity. This will force the editor to compile the code that we have just written.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>On the left-hand side of the editor in the <span class="strong"><strong>Hierarchy</strong></span> tab, right-click and select <span class="strong"><strong>Create Empty</strong></span>. This will add a blank GameObject to the scene.</p></li><li><p>Right-click on the GameObject that we just created and select <span class="strong"><strong>Rename</strong></span>. Name it <code class="literal">Input</code>.</p></li><li><p>While still having the <code class="literal">Input</code> GameObject selected, look to the right-hand side of the screen in <span class="strong"><strong>Inspector</strong></span> and click on <span class="strong"><strong>Add Component</strong></span>.</p></li><li><p>When the search <a id="id83" class="indexterm"></a>window pops up, enter the first half of what you called your input class. For example, when I enter <code class="literal">player</code>, my <span class="strong"><strong>Player Input</strong></span> class will appear in the list:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/4063_02_02.jpg" /></div></li><li><p>Click on your input class to add it to the <code class="literal">Input</code> GameObject. If everything goes according to plan, you will see the component added and <span class="strong"><strong>SwipeTime</strong></span> and <span class="strong"><strong>SwipeDistance</strong></span> both set to <code class="literal">0</code>. Alternatively, you can add the <code class="literal">Input</code> component to <a id="id84" class="indexterm"></a>GameObject by left-clicking, holding, and dragging it onto GameObject in the <span class="strong"><strong>Hierarchy</strong></span> tab from the <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Scripts</strong></span> folder.</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/4063_02_03.jpg" /></div></li><li><p>For now, set <span class="strong"><strong>Swipe Time</strong></span> to <code class="literal">0.08</code> and <span class="strong"><strong>Swipe Distance</strong></span> to <code class="literal">25</code>.</p></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec20"></a>Calculating the TouchInput function</h3></div></div></div><p>We can now <a id="id85" class="indexterm"></a>create the function (also called a method) to take in the touch information so that we can check it. To start, enter the following code under the last two variables:</p><div class="informalexample"><pre class="programlisting">private void CalculateTouchInput(SimpleTouch CurrentTouch)
{
}</pre></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">void</code>: This a keyword used to identify the function as something that will not return a value. As this function is designed to take in data and manage it within its own <span class="strong"><strong>scope</strong></span>, we don't need it to return any data back.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip11"></a>Tip</h3><p>Scope is the range of code that the brackets will manage. In this case, the brackets of <code class="literal">CalculateTouchInput</code> will manage detecting specific types of touch input. Variables such as <code class="literal">ActiveTouch</code> and <code class="literal">DeviceTouch</code> are what is called Global Scope. This means that the entire class can read and manipulate them, whereas something such as <code class="literal">SimpleTouch CurrentTouch</code> are only seen and manipulated in <code class="literal">CalculateTouchInput</code>.</p></div></li><li style="list-style-type: disc"><p><code class="literal">CalculateTouchInput</code>: This is the name of our function. This can be anything you <a id="id86" class="indexterm"></a>want, although the naming function should be done in a way that gives some clue as to what it will do. In our case, it will check the input data and calculate what to do with it.</p></li><li style="list-style-type: disc"><p><code class="literal">(SimpleTouch CurrentTouch)</code>: This portion of the function is what is called an argument or parameter. It is a way to send data to this function so that it can be used or altered.</p></li></ul></div><p>Next, we will use <code class="literal">CalculateTouchInput</code> to detect what type of touch is being sent to the function based on the data of <code class="literal">CurrentTouch</code>.</p><p>Add the following code in the <code class="literal">CalculateTouchInput</code> function:</p><div class="informalexample"><pre class="programlisting">private void CalculateTouchInput(SimpleTouch CurrentTouch)
{
  Vector2 touchDirection  = 
  (CurrentTouch.CurrentTouchLocation - 
  CurrentTouch.StartTouchLocation).normalized;

  float touchDistance = 
  (CurrentTouch.StartTouchLocation - 
  CurrentTouch.CurrentTouchLocation).magnitude;

  TimeSpan timeGap = System.DateTime.Now - CurrentTouch.StartTime;

  double touchTimeSpan = timeGap.TotalSeconds;

  string touchType = 
  ( touchDistance &gt; SwipeDistance &amp;&amp; touchTimeSpan &gt; SwipeTime )
  ? "Swipe" : "Tap";

  print( touchType );
}</pre></div><p>As mentioned before, we will need a few things to tell what type of input we are calculating.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">touchDirection</code>: This is the value of the current location of the touch <span class="emphasis"><em>minus</em></span> the start location of the touch.</p></li><li style="list-style-type: disc"><p><code class="literal">normalized</code>: This converts the vector, which can have very large numbers, to a vector that has a magnitude of oneâ€”or all the values in the vector are no more than 1.0 or less than -1.0. For example, for <code class="literal">touchDirection</code>, we need the direction in which the player swiped. To do this, we subtract the current location from the <a id="id87" class="indexterm"></a>start location of the touch. This vector value still holds the same direction between both the points; however, now the values of X and Y are normalized to <code class="literal">0.0</code> and <code class="literal">1.0</code>, respectively.</p><p>Let's look at it like this. If you were to have a vector with the Y value of <code class="literal">1.0</code> and the X value of <code class="literal">0.0</code>, you know that the direction of the vector is vertical and going upwards in the direction of Y. Now, if you have another vector with the Y value of <code class="literal">0.8</code> and the X value of <code class="literal">0.2</code>, you can still see that the direction is moving upwards in the direction of Y, but it is also slightly moving towards positive X. As we have the start and current location (or when this is calculated, the end location as <code class="literal">CalculateTouchInput</code> is being called when the user lets go of a tap), we can subtract them from each other and get the direction between them. When we normalize this value, we will still have the same direction; only the vector member values are within -1 and 1 instead of something much larger, which is what we'd have if we didn't normalize the vector.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip12"></a>Tip</h3><p>This example is set to <code class="literal">Vector2</code>, although the same is represented in Vector3, but with the added value of z.</p></div></li><li style="list-style-type: disc"><p><code class="literal">touchDistance</code>: This is the total<span class="strong"><strong> magnitude </strong></span>of the start and current touch locations. Unlike what was mentioned before in <code class="literal">touchDirection</code>, this magnitude represents the entire length value between the two vector points. For example, say you have a screen resolution of <span class="emphasis"><em>400*400</em></span>. If the user taps at <span class="emphasis"><em>0,0</em></span> and drags their finger to <span class="emphasis"><em>0,200</em></span>, the magnitude of this swipe will be <code class="literal">200</code> because the total value of this swipe is <span class="emphasis"><em>0 + 0</em></span> for X and <span class="emphasis"><em>0 + 200</em></span> for Y.</p></li><li style="list-style-type: disc"><p><code class="literal">timeGap</code>: One of the factors that decide, the difference between a swipe and a tap is the length in time the users finger was on the screen. We can have this value by first storing when the tap started and then subtracting it from the current time on the device.</p></li><li style="list-style-type: disc"><p><code class="literal">touchTimeSpan</code>: As the <code class="literal">TimeSpan</code> struct is compatible with <code class="literal">System.DateTime.now</code>, we will be able to subtract one from the other. <code class="literal">TimeSpan</code> then allows you to convert this time difference directly to seconds, which is what we do to get <code class="literal">touchTimeSpan</code>. Once we have this, we know exactly how long the user had their finger on the screen. Coupled with <code class="literal">touchDistance</code>, we can decipher the type of touch.</p></li><li style="list-style-type: disc"><p><code class="literal">touchType</code>: We will be able to tell you what type of touch is calculated by making sure that <a id="id88" class="indexterm"></a>
<code class="literal">touchTimeSpan</code> is greater than <span class="strong"><strong>SwipeTime</strong></span> and <span class="strong"><strong>touchDistance</strong></span> is greater than <span class="strong"><strong>SwipeDistance</strong></span>. If this comparison is <code class="literal">true</code>, we will assign <span class="strong"><strong>touchType</strong></span> as <span class="strong"><strong>Swipe</strong></span>. If it is set to <code class="literal">false</code>, we will set it to <span class="strong"><strong>Tap</strong></span>.</p></li><li style="list-style-type: disc"><p><code class="literal">print(touchType)</code>: This function allows you to print text to the console window in the Unity editor. Print is a handy way to display some debug information in the editor so that you can see the value of something directly.</p></li></ul></div><p>Alternatively, you can also use <code class="literal">Debug.Log( )</code> to display the values in the console log.</p></div></div>