<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec35"></a>The prefab creation</h2></div></div><hr /></div><p>In order to <a id="id195" class="indexterm"></a>create a prefab, you must first have a collection of GameObjects that you want to keep together as one prefab.</p><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Navigate to the <code class="literal">Assets</code> folder. Right-click on it and select <span class="strong"><strong>Create</strong></span> and then <span class="strong"><strong>Folder</strong></span>. Name this <code class="literal">Prefabs</code>.</p></li><li><p>Select the <span class="strong"><strong>Axe</strong></span> GameObject in <span class="strong"><strong>Hierarchy</strong></span>. This is the one we created in the last chapter. Click on it and drag it onto the <code class="literal">Prefabs</code> folder.</p></li></ol></div><p>This will create an <span class="strong"><strong>Axe</strong></span> prefab that we can use in the future that holds everything the current <span class="strong"><strong>Axe</strong></span> GameObject does.</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_04.jpg" /></div><p>Anytime in the future, when we want to create an axe, we will have a complete file that holds everything we know as axe.</p><p>This is essentially all it takes to create prefabs. These are an incredibly simple and useful aspect of creating games with Unity.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec30"></a>Coin prefabs</h3></div></div></div><p>Let's create a <a id="id196" class="indexterm"></a>couple of different varieties of coins, so when we use them in our level, we will have a more efficient system. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start by creating a new empty GameObject in the <span class="strong"><strong>Hierarchy</strong></span> tab and name it <code class="literal">CoinPattern_00</code>.</p></li><li><p>Set the location of this <span class="strong"><strong>CoinPattern_00</strong></span> GameObject to <code class="literal">0X</code>, <code class="literal">0Y</code>, and <code class="literal">0Z</code> in the world.</p><p>Now, move the existing coin in the scene. Name it <code class="literal">Pickup_Coin_0</code> so that it becomes a child of the <span class="strong"><strong>CoinPattern_00</strong></span> GameObject. Center this coin to <code class="literal">0X</code>, <code class="literal">0Y</code>, and <code class="literal">0Z</code>. This location is referenced by its parent, so it is a local position and not a world one. The <span class="strong"><strong>CoinPattern_00</strong></span> GameObject has the world location and the <code class="literal">Coin</code> child is relative to its position.</p></li><li><p>Select the<code class="literal"> Coin</code> child and click on <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span> to duplicate it. Do this a few times and <a id="id197" class="indexterm"></a>lay out the coins in an arch, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_05.jpg" /></div></li><li><p>With the <span class="strong"><strong>CoinPattern_00</strong></span> GameObject selected, click on it and drag it onto the <code class="literal">Assets/Prefabs</code> folder.</p></li></ol></div><p>Once the prefab is created for <span class="strong"><strong>CoinPattern_00</strong></span>, you can drag a prefab onto the scene and see the power of prefabs. As the prefab stores all the references you created, when they are put into the scene, the prefab is exactly the same as the <span class="strong"><strong>CoinPattern_00</strong></span> GameObject, which we created earlier.</p><p>Follow the same steps to create a couple of different <span class="strong"><strong>CoinPattern</strong></span> GameObjects and make sure to create prefabs for all of them. I made three <span class="strong"><strong>CoinPattern</strong></span> GameObjects and turned them into a prefab.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Tip</h3><p>If you want to alter a prefab, enter it in the scene and make your changes. When you are done with your changes, click on the parent GameObject and then drag it onto the existing prefab you want to edit. There is also an option in the <span class="strong"><strong>Inspector</strong></span> window that says <span class="strong"><strong>Apply</strong></span>. If you click on this, the prefab will be updated to the current settings in the <span class="strong"><strong>Scene</strong></span> window.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec31"></a>Level piece prefabs</h3></div></div></div><p>The last <a id="id198" class="indexterm"></a>step of our prefab setup is to create the level pieces. These will be the pieces we put together with some code to create a "random" level. As the <a id="id199" class="indexterm"></a>level pieces will be moving under the player, simulating the player moving, we will have to move these level prefab pieces around in the world and introduce coin and obstacles around them, so the player has a somewhat different experience as the game is running.</p><p>To start with, use our <span class="strong"><strong>Sprite Tiler</strong></span> tool to create some tiled GameObjects. I suggest adding some slopes by taking the floor sprites, duplicating them and then rotating them. Here is an example:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_06.jpg" /></div><p>This is a grid GameObject created with the <span class="strong"><strong>Sprite Tiler</strong></span> tool with an additional row copied to the top and a couple more single grid objects duplicated and rotated. Use your imagination and create at least <span class="emphasis"><em>three</em></span> of these. When you create these, make sure to keep the <code class="literal">Y</code> grid amount the same for the beginning and ending of all pieces. I will use <span class="emphasis"><em>five</em></span> for a <code class="literal">Y</code> setting, as seen in the preceding image.</p><p>When you are done, take each of the root GameObjects that were created and create prefabs for each of them. Remember to make them unique prefabs with single root GameObjects because we will use each grid individually.</p><p>In addition, we will need a starting level piece. This will be the level piece that always starts the game. It will <a id="id200" class="indexterm"></a>give the player a longer amount of time to get situated with the game and will give us a starting point to begin moving and attaching the other level pieces together. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the <span class="strong"><strong>Sprite Tiler</strong></span> tool and name the <span class="strong"><strong>Tile Level Object Name</strong></span> as <code class="literal">StartingLevelPiece</code>.</p></li><li><p>Then, select <span class="strong"><strong>X</strong></span> as <span class="strong"><strong>3</strong></span>.</p></li><li><p>Now, select <span class="strong"><strong>Y</strong></span> as <span class="strong"><strong>5</strong></span>.</p></li><li><p>For the <span class="strong"><strong>Sprite Ground File</strong></span>, use <code class="literal">Floor_03</code>.</p></li><li><p>Then, for the <span class="strong"><strong>Sprite Dirt File</strong></span>, use <code class="literal">Floor_02</code>.</p></li><li><p>Click <a id="id201" class="indexterm"></a>on <span class="strong"><strong>Create Tiled</strong></span>.</p></li><li><p>Finally, left-click and drag the resulting <span class="strong"><strong>StartingLevelPiece</strong></span> GameObject onto the <code class="literal">Assets/Prefabs</code> folder to create its prefab.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec32"></a>Further setup of the level pieces</h3></div></div></div><p>At this <a id="id202" class="indexterm"></a>point, you should have a collection of <span class="strong"><strong>CoinPattern</strong></span>, <span class="strong"><strong>LevelPieces</strong></span>, and <span class="strong"><strong>Axe</strong></span> GameObject(s) prefabs in the <code class="literal">Prefabs</code> folder. This is <a id="id203" class="indexterm"></a>the list I have:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_07.jpg" /></div><p>The level pieces will need two extra GameObjects so that we know where they all begin and end. This way, we will be able to place them together by putting the beginning of the next piece at the end of the previous one.</p><p>Make sure that any of the level pieces in the <span class="strong"><strong>Hierarchy</strong></span> tab are saved as a prefab and delete them from the <span class="strong"><strong>Hierarchy</strong></span> tab. When the scene is clear of level pieces, take <span class="strong"><strong>StartingLevelPiece</strong></span> and put it in the scene with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select <span class="strong"><strong>StartingLevelPiece</strong></span> and position its location at <code class="literal">0</code>, <code class="literal">0</code>, and <code class="literal">0</code> in the world with the <span class="strong"><strong>Inspector</strong></span> window under <span class="strong"><strong>Transform</strong></span>.</p></li><li><p>Open the <span class="strong"><strong>StartingLevelPiece</strong></span> GameObject in <span class="strong"><strong>Hierarchy</strong></span> by clicking on the small gray arrow on the left-hand side.</p></li><li><p>Select the children GameObjects and then position them so that the pivot of the <span class="strong"><strong>LevelPiece</strong></span> parent GameObject is at the <span class="emphasis"><em>bottom-left</em></span> of the selected children, as shown in the following image:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_08.jpg" /></div></li><li><p>Right-click on <span class="strong"><strong>Hierarchy</strong></span>, select <span class="strong"><strong>Create Empty</strong></span>, and name it <code class="literal">EndLocation</code>.</p></li><li><p>Now, move the <span class="strong"><strong>EndLocation</strong></span> GameObject in the <span class="emphasis"><em>bottom-right</em></span> corner of <span class="strong"><strong>StartingLevelPiece</strong></span>.</p></li><li><p>Take the <span class="strong"><strong>EndLocation</strong></span> GameObjects and drag it onto the <span class="strong"><strong>StartingLevelPiece</strong></span> GameObject so that it becomes its child.</p></li><li><p>Select the <span class="strong"><strong>StartingLevelPiece</strong></span> GameObject and then click and drag it onto the existing prefab in the <code class="literal">Assets/Prefabs</code> folder. This will overwrite the current version of the prefab with the updated one.</p></li><li><p>If you <a id="id204" class="indexterm"></a>click and drag the <span class="strong"><strong>StartingLevelPiece</strong></span> prefab from the <code class="literal">Assets/Prefabs</code> folder and place it on the <span class="strong"><strong>Scene</strong></span> window, you should see <span class="strong"><strong>EndLocation</strong></span> as a child of it in <span class="strong"><strong>Hierarchy</strong></span> and <a id="id205" class="indexterm"></a>positioned in the <span class="emphasis"><em>bottom-right</em></span> corner of the sprite children, as shown in the following image:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_09.jpg" /></div></li></ol></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Tip</h3><p>When you place the pivot point and <code class="literal">EndLocation</code>, it is okay to have a few pixels of the sprites overlap; I even recommend it. If these locations are outside the pixels of the sprites, there will be small gaps when the pieces are put together, which isn't a huge deal, although noticeable.</p></div><p>This will give us a position we know as the root object position, which when we change it in code will move the rest of the children in a way we can rely on. The <span class="strong"><strong>EndLocation</strong></span> GameObject also gives us a reliable position to connect another <span class="strong"><strong>LevelPiece</strong></span> to it without needing to have any offsets.</p><p>Repeat these <a id="id206" class="indexterm"></a>steps for the rest of the <span class="strong"><strong>LevelPiece</strong></span> GameObjects. Make sure that the root GameObject is placed in the <span class="emphasis"><em>bottom-left</em></span> corner of the <a id="id207" class="indexterm"></a>GameObject, and the <span class="strong"><strong>EndLocation</strong></span> is placed in the <span class="emphasis"><em>bottom-right</em></span> corner of the GameObject.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec33"></a>The level piece code</h3></div></div></div><p>In order to <a id="id208" class="indexterm"></a>keep track of all the <span class="strong"><strong>LevelPieces</strong></span>, we need a small script that stores their initial location. Right-click on the <code class="literal">Assets/Scripts</code> folder and select <span class="strong"><strong>Create</strong></span>. Then, click on <span class="strong"><strong>C# Script</strong></span> and name it <code class="literal">LevelPiece</code>.</p><p>Double-click on the <a id="id209" class="indexterm"></a>
<code class="literal">LevelPiece</code> file to open it and make sure that it looks similar to the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class LevelPiece : MonoBehaviour 
{
  // The initial location of this level piece
  private Vector3 InitialLocation;

  // Use this for initialization
  void Awake () 
  {
    InitialLocation = transform.position;
  }

  // Get the initial location of this
  // LevelPiece
  public Vector3 GetInitialLocation()
  {
    return InitialLocation;
  }
}</pre></div><p>This is a very simple class that is designed to keep track of where the <span class="strong"><strong>LevelPiece</strong></span> starts. This will be used to reset the <span class="strong"><strong>LevelPiece</strong></span> after it has been used so that it can be used again.</p><p><code class="literal">InitialLocation</code> is a <code class="literal">Vector3</code> struct that gets assigned during the <code class="literal">Start</code> function. <code class="literal">Awake</code> is called as soon as the class is initialized or as soon as the game starts running because the class will exist on the <span class="strong"><strong>LevelPieces</strong></span>, which will be in the world when the game starts.</p><p>We don't need the <code class="literal">Update</code> function, which is why it was removed from the class.</p><p><code class="literal">GetInitialLocation</code> is a function that we can use from the next C# class that we will write so that it can manage the <span class="strong"><strong>LevelPiece</strong></span> GameObject(s) by getting that location and moving the <span class="strong"><strong>LevelPiece</strong></span> to it after we have used it.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip27"></a>Tip</h3><a id="id210" class="indexterm"></a><a id="id211" class="indexterm"></a><p>The difference between Awake and Start is that Awake gets called before the Update or Start function is called. Then, Start gets called following Awake, but still before the first Update call. This means the order of functions getting called when the class is created is Awake-&gt;Start-&gt;Update. As the next class we will use will immediately start its Update function, we need to make sure that InitialLocation of LevelPiece is assigned before its location gets moved.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec34"></a>The level piece manager code</h3></div></div></div><p>We now <a id="id212" class="indexterm"></a>have everything we need to begin piecing the <span class="strong"><strong>LevelPieces</strong></span> together with code.</p><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Right-click <a id="id213" class="indexterm"></a>on the <code class="literal">Assets/Scripts</code> folder and select <span class="strong"><strong>Create</strong></span>. Then, select <span class="strong"><strong>C# Script</strong></span>. Name it <code class="literal">LevelPieceManager</code>.</p></li><li><p>In order to know when we need to attach another level piece, we must first have a <code class="literal">Vector3</code> position to check against. In <span class="strong"><strong>Hierarchy</strong></span>, right-click and select <span class="strong"><strong>Create Empty</strong></span>. Name this <code class="literal">LevelPieceManager</code>.</p></li><li><p>Now, select the <span class="strong"><strong>X</strong></span> location as <code class="literal">LevelPieceManager</code> and the <span class="strong"><strong>Inspector</strong></span> | <span class="strong"><strong>Transform</strong></span> window as <code class="literal">-7.75</code>. This will offset <code class="literal">LevelPieceManager</code> so that when the game starts, the character will have a longer flat path to run along before reaching the first attached <span class="strong"><strong>LevelPiece</strong></span>.</p></li><li><p>Then, select <span class="strong"><strong>LevelPieceManager</strong></span>, and in <span class="strong"><strong>Inspector</strong></span>, click on <span class="strong"><strong>Add Component</strong></span>. Search for <code class="literal">LevelPieceManager</code> and select <span class="strong"><strong>LevelPieceManager</strong></span>.</p></li><li><p>Finally, double-click on the <code class="literal">LevelPieceManager</code> script file in the <code class="literal">Assets/Scripts</code> folder, open it, and add the following code to it:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class LevelPieceManager : MonoBehaviour
{
  // Starting level piece 
  public LevelPiece StartingLevelPiece;

  // Level pieces to rotate 
  public LevelPiece[] LevelPieces;

  // How quickly the level pieces move
  public float LevelPiecesMoveRate;

  // The currently active Level Piece
  private LevelPiece[] ActiveLevelPieces;

  // Use this for initialization
  void Start()
  {
  }

  // Update is called once per frame
  void Update()
  {
  }
}</pre></div></li></ol></div><p><code class="literal">LevelPieceManager</code> is a class that will connect all the <code class="literal">LevelPieces</code> together and move them across the screen, simulating that the player is running forward. This is a design decision on my end. Although Unity does have what you can call a "scene size limit", my decision here is to try to keep the organization of the scene to a smaller area, hopefully giving you a more relaxed scene to work in.</p><p>The current code <a id="id214" class="indexterm"></a>is explained here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">StartingLevelPiece</code>: This is the initial <span class="strong"><strong>LevelPiece</strong></span> GameObject. It is a flat portion to get the <a id="id215" class="indexterm"></a>game started without having to worry about placing anything as soon as the game starts.</p></li><li style="list-style-type: disc"><p><code class="literal">LevelPieces</code>: This is an array that will hold the other <code class="literal">LevelPiece</code> prefabs we created. It is the list that will be used to assign a new piece to the actively moving pieces when another piece has reached a point where it is no longer needed, that is, when it is out of view of the player.</p></li><li style="list-style-type: disc"><p><code class="literal">LevelPiecesMoveRate</code>: This is the speed at which the <span class="strong"><strong>LevelPiece</strong></span> GameObjects will be moving across the screen.</p></li><li style="list-style-type: disc"><p><code class="literal">ActiveLevelPieces</code>: This is a list of <span class="strong"><strong>LevelPiece</strong></span> GameObjects that will move across the screen. It is set to private to prevent any other class from accessing and/or changing it.</p></li></ul></div><p>Next, we want to add the code for the <code class="literal">Start</code> function. Add the following code to the <code class="literal">LevelPieceManager</code> class:</p><div class="informalexample"><pre class="programlisting">  // Use this for initialization
  void Start( ) 
  {
    ActiveLevelPieces = new LevelPiece[2];
    ActiveLevelPieces[0] = StartingLevelPiece;
    ActiveLevelPieces[1] = GetRandomLevelPiece();

    ActiveLevelPieces[1].transform.position = StartingLevelPiece.gameObject.transform.FindChild("EndLocation").position;
  }</pre></div><p>The <code class="literal">Start</code> function is called as soon as this class is active in the scene, just after <code class="literal">Awake</code> and just before <code class="literal">Update</code>, giving us room to assign some values before anything else happens in this class.</p><p>To begin with, we will create an array of <span class="emphasis"><em>two</em></span> <code class="literal">LevelPiece</code> classes and assign it to <code class="literal">ActiveLevelPieces</code>.</p><p>Then, we will give the first element in the <code class="literal">ActiveLevelPiece</code> array the value of <code class="literal">StartingLevelPiece</code> because it is the first <span class="strong"><strong>LevelPiece</strong></span> we want to use.</p><p>We will then get a "random" <span class="strong"><strong>LevelPiece</strong></span> from the <code class="literal">GetRandomLevelPiece</code> function, which we will write <a id="id216" class="indexterm"></a>soon; it is going to cycle through the array of <code class="literal">LevelPieces</code> from the scene. Make sure that the one we want to use isn't currently active.</p><p>After we have the random <span class="strong"><strong>LevelPiece</strong></span>, we have to assign its location to the <span class="strong"><strong>EndLocation</strong></span> of the <span class="strong"><strong>StartingLevelPiece</strong></span>. This is done by using the <code class="literal">transform.FindChild</code> function. This function will look for the name of the <span class="strong"><strong>Transform</strong></span> child, which in our case is <span class="strong"><strong>EndLocation</strong></span>. When we <a id="id217" class="indexterm"></a>have this, we can use the transform position of <span class="strong"><strong>EndLocation</strong></span> and assign the random <code class="literal">LevelPiece</code> position to it.</p><p>Earlier, I mentioned why the <code class="literal">LevelPiece</code> class uses <code class="literal">Awake</code> instead of <code class="literal">Start</code>. In the case of <code class="literal">LevelPieceManager</code>, we want to make sure that the <code class="literal">LevelPiece</code> class is done with all its assignments before <code class="literal">LevelPieceManager</code> begins to do anything, which will happen because the <code class="literal">Awake</code> function of <span class="strong"><strong>LevelPiece</strong></span> will be called before the <code class="literal">Start</code> function of <code class="literal">LevelPieceManager</code>, giving us the order of <code class="literal">LevelPiece Awake</code>, <code class="literal">LevelPieceManager Start</code>, <code class="literal">LevelPieceManager Update</code>.</p><p>Next, we want to write the <code class="literal">Update</code> function for <code class="literal">LevelPieceManager</code>. Add the following code:</p><div class="informalexample"><pre class="programlisting">  // Update is called once per frame
  void Update ( )
  {
    for (int i = 0; i &lt; ActiveLevelPieces.Length; i++)
    {
      Vector3 newLocation = ActiveLevelPieces[ i ].transform.position;
      newLocation.x -= LevelPiecesMoveRate * Time.deltaTime;

      ActiveLevelPieces[ i ].transform.position = newLocation;

      if (ActiveLevelPieces[ i ].transform.position.x &lt; transform.position.x)
      {
        if (ActiveLevelPieces[ i ] == StartingLevelPiece)
        {
          ActiveLevelPieces[ i ].gameObject.SetActive( false );
        }

        ActiveLevelPieces[ i ].transform.position = ActiveLevelPieces[ i ].GetInitialLocation( );
        ActiveLevelPieces[ i ] = GetRandomLevelPiece( );
        ActiveLevelPieces[ i ].transform.position = FindOtherLevelPiece( ActiveLevelPieces[ i ] ).gameObject.transform.FindChild( "EndLocation" ).position;
      }
    }
  }</pre></div><p>As mentioned before, the <code class="literal">Update</code> function is called for every frame that is rendered. This means that if your game is running at <span class="emphasis"><em>thirty</em></span> frames per second, the Update function gets called <span class="emphasis"><em>thirty</em></span> times a second as well.</p><p>As we will always have <span class="emphasis"><em>two</em></span> <code class="literal">ActiveLevelPieces</code> and want them to move together, we will use a <code class="literal">for</code> loop <a id="id218" class="indexterm"></a>that will loop through these <code class="literal">ActiveLevelPieces</code>, which if you recall is <span class="emphasis"><em>two</em></span>.</p><p>For each one of these <a id="id219" class="indexterm"></a>
<code class="literal">ActiveLevelPieces</code>, we first want to get their location, which we named <code class="literal">newLocation</code>.</p><p>We then want to change the <code class="literal">location.x</code> value of this <code class="literal">newLocation</code> by <code class="literal">LevelPieceMoveRate</code> multiplied by the <code class="literal">Time.deltaTime</code> value, which is the time it took to render the last frame to this frame.</p><p>When we have <code class="literal">newLocation</code> assigned, we then want to update the location of the current <code class="literal">ActiveLevelPiece</code> element to the <code class="literal">newLocation Vector3</code> value, which will move the <code class="literal">ActiveLevelPiece</code> element.</p><p>We then want to check whether the <code class="literal">ActiveLevelPiece</code> element has passed the bounds of the <span class="strong"><strong>LevelPieceManager</strong></span> GameObject <code class="literal">position.x</code> value. If it has, we check whether the <code class="literal">ActiveLevelPiece</code> element is <code class="literal">StartingLevelPiece</code>. If it is, we know that we don't want to use it again, so we will use the <code class="literal">SetActive</code> function to hide it by saying that it is <span class="emphasis"><em>not</em></span> active anymore.</p><p>As the <code class="literal">ActiveLevelPiece</code> element has reached the point where it no longer needs to be used, we will reset its location to its <code class="literal">InitialLocation</code> with the <code class="literal">GetInitialLocation</code> function written in the <code class="literal">LevelPiece</code> class.</p><p>After it has been reset, we will use the <code class="literal">GetRandomLevelPiece</code> function so that we can begin to use an available LevelPiece. As mentioned before, this function returns a <span class="strong"><strong>LevelPiece</strong></span> that is currently not being used.</p><p>After we have our next <span class="strong"><strong>LevelPiece</strong></span>, we then want to set its location to the <code class="literal">EndLocation</code> of the <span class="emphasis"><em>other</em></span> <code class="literal">ActiveLevelPiece</code>, which is done with a function named <code class="literal">FindOtherLevelPiece</code>, in which we pass the current <code class="literal">ActiveLevelPiece</code> to compare against the rest of them, making sure that we don't accidentally return the <code class="literal">ActiveLevelPiece</code> that needs replacement.</p><p>Let's simplify what is going on here. We are taking a location of GameObject and offsetting it a small amount and then assigning the GameObject position to the new offset location. If this offset location is outside the bounds of what we have set, we can replace it with a new GameObject that begins the cycle all over again.</p><p>Next, we need the <a id="id220" class="indexterm"></a>
<code class="literal">FindOtherLevelPiece</code> <a id="id221" class="indexterm"></a>function. Add the following function under <code class="literal">Update</code>:</p><div class="informalexample"><pre class="programlisting">    // Get the other LevelPiece
    // from the LevelPieces
    // Array
    private LevelPiece FindOtherLevelPiece(LevelPiece CurrentLevelPiece)
    {
      for (int i = 0; i &lt; ActiveLevelPieces.Length; i++)
      {
        if (ActiveLevelPieces[ i ] != CurrentLevelPiece)
        {
          return ActiveLevelPieces[ i ];
        }
      }
      return null;
    }</pre></div><p>This function is simple. We check the value of <code class="literal">CurrentLevelPiece</code> against the array elements of <code class="literal">ActiveLevelPieces</code>. As soon as we find that the <code class="literal">ActiveLevelPieces</code> array element is <span class="emphasis"><em>not</em></span> equal to <code class="literal">CurrentLevelPiece</code>, we will return it. This means that we found the other <code class="literal">ActiveLevelPieces</code> array element (as there are only <span class="emphasis"><em>two</em></span>). Also, it doesn't match the <code class="literal">CurrentLevelPiece</code> argument.</p><p>Next, we need to write the <code class="literal">GetRandomLevelPiece</code> function. Add the following function under <a id="id222" class="indexterm"></a>
<code class="literal">FindOtherLevelPiece</code>:</p><div class="informalexample"><pre class="programlisting">    // Get random level piece
    // from LevelPieces Array
    private LevelPiece GetRandomLevelPiece()
    {
      LevelPiece returnPiece = null;
      while (returnPiece == null)
      {
        for (int i = 0; i &lt; LevelPieces.Length; i++)
        {
          if ( !isActivePiece( LevelPieces[ i ] ) )
          {
            returnPiece = LevelPieces[ i ];
          }
        }
      }
      return returnPiece;
    }</pre></div><p>As mentioned before, the <code class="literal">while</code> loop will continue to loop until the condition is no longer <code class="literal">true</code>. In our case, we want to make sure that the loop stops when <code class="literal">returnPiece</code> has a value or is <span class="emphasis"><em>not</em></span> equal to null.</p><p>For this, let's first create a <code class="literal">for</code> loop that loops through <code class="literal">LevelPieces</code>. These are the <span class="strong"><strong>LevelPiece</strong></span> prefab GameObjects in our scene. We then check whether the <code class="literal">LevelPieces</code> array element is <span class="emphasis"><em>not</em></span> active by passing it to a function called <code class="literal">isActivePiece</code> and then checking whether this function returns <code class="literal">false</code>.</p><p>When we have the <code class="literal">LevelPieces</code> array element that is <span class="emphasis"><em>not</em></span> being used, we can assign its <code class="literal">returnPiece</code> to that <code class="literal">LevelPieces</code> array element. Once this is done, the <code class="literal">while</code> loop condition will become <code class="literal">false</code> and then the next line after the <code class="literal">while</code> loop returns the <code class="literal">returnPiece</code> found.</p><p>Simply put, we will look at all the <code class="literal">LevelPieces</code> and return the first one that is <span class="emphasis"><em>not</em></span> being used.</p><p>The last function we need <a id="id223" class="indexterm"></a>to write is the <code class="literal">isAlreadyActive</code> function. This will return <span class="emphasis"><em>true</em></span> if the piece is active and <span class="emphasis"><em>false</em></span> if it is not active. Under the <code class="literal">GetRandomLevelPiece</code> function, add the <code class="literal">isActivePiece</code> function:</p><div class="informalexample"><pre class="programlisting">    // Check if LevelPiece
    // is already used.
    private bool isActivePiece(LevelPiece Piece)
    {
      for (int i = 0; i &lt; ActiveLevelPieces.Length; i++)
      {
        if (Piece == ActiveLevelPieces[ i ])
        {
          return true;
        }
      }
      return false;
    }</pre></div><p>Similar to the <code class="literal">FindOtherLevelPiece</code> function, we loop through the <code class="literal">ActiveLevelPieces</code> array and check whether the <code class="literal">Piece</code> argument is passed. If any of the <code class="literal">ActiveLevelPieces</code> array elements match the <code class="literal">Piece</code> argument being passed, the function will <a id="id224" class="indexterm"></a>return <span class="emphasis"><em>true</em></span> because the condition is <span class="emphasis"><em>true</em></span>. If the function loops through the entire <code class="literal">ActiveLevelPieces</code> array and the <code class="literal">Piece</code> argument doesn't match any of them, the function will return <span class="emphasis"><em>false</em></span> because the condition in the <code class="literal">for</code> loop was never <span class="emphasis"><em>true</em></span>.</p><p>This is the <a id="id225" class="indexterm"></a>
<code class="literal">LevelPieceManager</code> class. If you save and open/tab back over to Unity and then compile, you can set up the <span class="strong"><strong>LevelPieceManager</strong></span> settings.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec35"></a>Setting up the LevelPieceManager GameObject</h3></div></div></div><p>If not <a id="id226" class="indexterm"></a>already created, right-click on the <span class="strong"><strong>Hierarchy</strong></span> tab and select <span class="strong"><strong>Create Empty</strong></span>. Rename this GameObject as <code class="literal">LevelPieceManager</code>.</p><p>With the <span class="strong"><strong>LevelPieceManager</strong></span> GameObject selected, click on<span class="strong"><strong> Add Component</strong></span> in the <span class="strong"><strong>Inspector</strong></span> window.</p><p>Search for <a id="id227" class="indexterm"></a>
<span class="strong"><strong>LevelPieceManager</strong></span> and select <span class="strong"><strong>LevelPieceManager</strong></span> to add the component.</p><p>With the <span class="strong"><strong>LevelPieceManager</strong></span> GameObject still selected, change its <span class="strong"><strong>X</strong></span> position to <span class="strong"><strong>-7.75</strong></span> using the <span class="strong"><strong>Inspector</strong></span> | <span class="strong"><strong>Transform</strong></span> window. The <span class="strong"><strong>Y</strong></span> and <span class="strong"><strong>Z</strong></span> locations don't matter, although you can set them both to <span class="emphasis"><em>zero</em></span> if you want to keep things organized.</p><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Take each of the <span class="strong"><strong>LevelPiece</strong></span> prefabs and drag them onto the scene outside the view of the camera, except for <span class="strong"><strong>StartingLevelPiece</strong></span>. Move the <span class="strong"><strong>StartingLevelPiece</strong></span> position to <code class="literal">0X</code>, <code class="literal">0Y</code>, and <code class="literal">0Z</code> by selecting it from <span class="strong"><strong>Hierarchy</strong></span> and using the <span class="strong"><strong>Inspector</strong></span> | <span class="strong"><strong>Transform</strong></span> settings.</p></li><li><p>Select the <span class="strong"><strong>LevelPieceManager</strong></span> GameObject from <span class="strong"><strong>Hierarchy</strong></span>.</p></li><li><p>Then, left-click and drag <span class="strong"><strong>StartingLevelPiece</strong></span> from <span class="strong"><strong>Hierarchy</strong></span> onto the <span class="strong"><strong>Starting Level Piece</strong></span> slot in the <span class="strong"><strong>LevelPieceManager</strong></span> GameObject.</p></li><li><p>Now, change the <span class="strong"><strong>Level Pieces</strong></span> array amount from <span class="emphasis"><em>zero</em></span> to <span class="emphasis"><em>three</em></span>.</p></li><li><p>Then, take each of the <span class="strong"><strong>LevelPiece</strong></span> prefab GameObjects, <span class="emphasis"><em>not</em></span> including <span class="strong"><strong>StartingLevelPiece</strong></span>, and put each of them in a slot of the <code class="literal">LevelPieces</code> of the <span class="strong"><strong>LevelPieceManager</strong></span> GameObject.</p></li><li><p>Finally, change <span class="strong"><strong>Level Piece Move Rate</strong></span> from <code class="literal">0</code> to <code class="literal">1.35</code>:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_11.jpg" /></div></li></ol></div><p>If you play the <a id="id228" class="indexterm"></a>game now, you should see <code class="literal">LevelPieces</code> moving and connecting to each other, simulating that the player character is moving. You will also see that at times, the player character is getting pushed backwards by the slope of <code class="literal">LevelPieces</code>. To fix this, open the <code class="literal">Character</code> script <a id="id229" class="indexterm"></a>from the <code class="literal">Assets/Scripts</code> folder.</p><p>In the <code class="literal">Update</code> function, before the condition that checks <code class="literal">isFadeOut</code>, add the following code:</p><div class="informalexample"><pre class="programlisting">    // Update is called once per frame
    void Update () 
    {
      Vector3 lockXPosition = transform.position;
      lockXPosition.x = 2.25f;
      transform.position = lockXPosition;

      if (isFadeOut)
      {</pre></div><p>If you play the game now, you will see that the character is locked in the <span class="strong"><strong>X</strong></span> position of <code class="literal">2.5</code>, meaning that the slopes won't affect it anymore.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec36"></a>Adding coins and obstacles to LevelPieces</h3></div></div></div><p>The <a id="id230" class="indexterm"></a>next step is to add coins and obstacles <a id="id231" class="indexterm"></a>to our <span class="strong"><strong>LevelPiece</strong></span> prefabs. As <a id="id232" class="indexterm"></a>our <code class="literal">LevelPieceManager</code> can handle more than <span class="emphasis"><em>three</em></span> <a id="id233" class="indexterm"></a>
<span class="strong"><strong>LevelPiece</strong></span> prefabs, you can create duplicates to have different coin and obstacle layouts. Alternatively, you can keep it simple and only use the current <span class="emphasis"><em>three</em></span> <span class="strong"><strong>LevelPiece</strong></span> prefabs.</p><p>Drag and drop the <span class="strong"><strong>Coin</strong></span> and <span class="strong"><strong>Obstacle</strong></span> prefabs onto the scene and position them around the <span class="strong"><strong>LevelPiece</strong></span> prefabs. For each of the <span class="strong"><strong>LevelPiece</strong></span> prefabs, create as many obstacles or coins as you want, and after they are placed, make sure to drag them onto the <span class="strong"><strong>LevelPiece</strong></span> GameObject, making the obstacles and coins children of <span class="strong"><strong>LevelPiece</strong></span>. When you are done, you should <a id="id234" class="indexterm"></a>have something similar to the <a id="id235" class="indexterm"></a>following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_12.jpg" /></div><p>If your <span class="strong"><strong>Axe</strong></span> <a id="id236" class="indexterm"></a>obstacle is rendering behind <a id="id237" class="indexterm"></a>
<span class="strong"><strong>LevelPiece</strong></span>, left-click on the 2D button at the top of the <span class="strong"><strong>Scene</strong></span> window.</p><p>You can use the following controls to navigate the scene:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Alt + left click</strong></span>: This control can be used to rotate around the center of the scene</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Alt + middle mouse down</strong></span>: This control can be used to move the camera around</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Middle mouse wheel forward</strong></span>: This control can be used to zoom in the camera</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Middle mouse wheel backward</strong></span>: This control can be used to zoom out the camera</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>F</strong></span>: With the selected GameObject, the camera positions itself in front of the selected GameObject</p></li></ul></div><p>Select the <span class="strong"><strong>Axe</strong></span> <a id="id238" class="indexterm"></a>GameObject that needs to be <a id="id239" class="indexterm"></a>moved and use the move gizmo to <a id="id240" class="indexterm"></a>move it in front of <span class="strong"><strong>LevelPiece</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_13.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip28"></a>Tip</h3><p>The <span class="strong"><strong>Z</strong></span> position of GameObjects does not affect the game. You can position them in any order <a id="id241" class="indexterm"></a>to make them render <a id="id242" class="indexterm"></a>correctly in the scene. You can <a id="id243" class="indexterm"></a>move anything forward or backward to <a id="id244" class="indexterm"></a>make the sprites look correct.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec37"></a>Managing coins and obstacles with the LevelPiece code</h3></div></div></div><p>In the <code class="literal">Assets/Scripts</code> folder, double-click on the <code class="literal">LevelPiece.cs</code> file to open it. Add the following <a id="id245" class="indexterm"></a>code at the top of the class:</p><div class="informalexample"><pre class="programlisting">    // Coin children
    public Coin[] Coins;</pre></div><p>Save the <code class="literal">LevelPiece.cs</code> file and tab back or open Unity to let the code compile. Start by selecting <a id="id246" class="indexterm"></a>one of the <span class="strong"><strong>LevelPiece</strong></span> <a id="id247" class="indexterm"></a>GameObjects in <span class="strong"><strong>Hierarchy</strong></span>, and in the <a id="id248" class="indexterm"></a>top-right corner of the <span class="strong"><strong>Inspector</strong></span> window, click on the small lock; it should change from an open lock to a closed lock. Once it has, you can select all the coins from <span class="strong"><strong>Hierarchy</strong></span> for the specific <span class="strong"><strong>LevelPiece</strong></span> GameObject and drag them onto the <span class="strong"><strong>LevelPiece</strong></span> component in the <span class="strong"><strong>Inspector</strong></span> window; it will automatically fill and assign the <span class="strong"><strong>Coins</strong></span> array, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_14.jpg" /></div><p>Do this for all the coins in all the <span class="strong"><strong>LevelPiece</strong></span> GameObjects. Also, make sure to match them to the correct <code class="literal">Coins</code> array. Remember that the lock will keep the <span class="strong"><strong>LevelPiece</strong></span> GameObject <a id="id249" class="indexterm"></a>selected until you unlock <a id="id250" class="indexterm"></a>it by clicking on the <a id="id251" class="indexterm"></a>lock again. You will have to do this for <a id="id252" class="indexterm"></a>each <span class="strong"><strong>LevelPiece</strong></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec05"></a>Resetting coins</h4></div></div></div><p>In the <code class="literal">Assets/Scripts</code> folder, open the <code class="literal">Coin.cs</code> class. We will change how the coin is being used here. Earlier, we were destroying it after the player collided with it. We do not want this now <a id="id253" class="indexterm"></a>because this was only useful for testing purposes. We now want the coin to be in the scene always and managed in a way where it can be reactivated when <span class="strong"><strong>LevelPiece</strong></span> becomes active.</p><p>In the <code class="literal">OnTriggerEnter2D</code> function, remove the following line:</p><div class="informalexample"><pre class="programlisting">Destroy( gameObject );</pre></div><p>Then, replace it with the following code:</p><div class="informalexample"><pre class="programlisting">ActivateCoin( false );</pre></div><p>Now, we need to write the <code class="literal">ActivateCoin</code> function. Add the following code under <code class="literal">OntriggerEnter2D</code>:</p><div class="informalexample"><pre class="programlisting">    // Activates or deactivates
    // coin
    public void ActivateCoin(bool bActivate)
    {
      SpriteRenderer renderer;
      BoxCollider2D collider;

      renderer = gameObject.GetComponent&lt;SpriteRenderer&gt;( );
      collider = gameObject.GetComponent&lt;BoxCollider2D&gt;( );

      collider.enabled = bActivate;
      renderer.enabled = bActivate;
    }</pre></div><p>We first have the <span class="strong"><strong>SpriteRenderer</strong></span> and <span class="strong"><strong>Box Collider 2D</strong></span> components for the coin and then set them to the value of <code class="literal">bActivate</code>. This means that if the character collects the coin, the bActivate value will be false. This is because we don't want it activated after being collected, which will set enabled to false for both the collider and the renderer. Whereas, if we reset the game, we can call this same function but set bActivate to true. This will turn enabled to true for both the collider and renderer, making it so that the character can collect it again.</p><p>Furthermore, this function allows you to control the coin after it has been used so that it can be used again by setting the <span class="strong"><strong>Box Collider 2D</strong></span> and <span class="strong"><strong>SpriteRenderer</strong></span> components to enabled or not enabled. By setting these two components to not enabled, they won't react to the player character anymore, but if we set them to enabled, the player can again interact with them. This <a id="id254" class="indexterm"></a>is good for us because we need to enable them every time <span class="strong"><strong>LevelPiece</strong></span> gets used, although it has been used before.</p><p>Save this <code class="literal">Coin.cs</code> file.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec06"></a>Resetting the coin in LevelPiece</h4></div></div></div><p>In the <code class="literal">Assets/Scripts</code> folder, open the <code class="literal">LevelPiece</code> class. At the bottom of the class, add the <a id="id255" class="indexterm"></a>following function:</p><div class="informalexample"><pre class="programlisting">    // Resets all children
    // coins
    public void ResetAllChildrenCoins()
    {
      for (int i = 0; i &lt; Coins.Length; i++)
      {
        Coins[ i ].ActivateCoin( true );
      }
    }</pre></div><p>This does exactly as the function describes. It loops through all the coins that we added from the <span class="strong"><strong>Hierarchy</strong></span> tab to the <code class="literal">LevelPiece</code> script component and calls the <code class="literal">ActivateCoin</code> function we wrote early, setting the enabled bool value to <code class="literal">true</code>. This is what we will pass in <code class="literal">ActivateCoin</code>.</p><p>Then, we need to call the <code class="literal">ResetAllChildrenCoins</code> function from <code class="literal">LevelPieceManager</code>, when it decides that it needs a new <span class="strong"><strong>LevelPiece</strong></span>. In the <code class="literal">Assets/Scripts</code> folder, open the <code class="literal">LevelPieceManager</code> code file.</p><p>Change the <code class="literal">Update</code> function as follows:</p><div class="informalexample"><pre class="programlisting">  // Update is called once per frame
  void Update ( )
  {
    for (int i = 0; i &lt; ActiveLevelPieces.Length; i++)
    {
      Vector3 newLocation = ActiveLevelPieces[ i ].transform.position;
      newLocation.x -= LevelPiecesMoveRate * Time.deltaTime;

      ActiveLevelPieces[ i ].transform.position = newLocation;

      if (ActiveLevelPieces[ i ].transform.position.x &lt; transform.position.x)
      {
        if (ActiveLevelPieces[ i ] == StartingLevelPiece)
        {
          ActiveLevelPieces[ i ].gameObject.SetActive( false );
        }

        ActiveLevelPieces[ i ].transform.position = ActiveLevelPieces[ i ].GetInitialLocation( );
        ActiveLevelPieces[ i ] = GetRandomLevelPiece( );
        ActiveLevelPieces[ i ].transform.position = FindOtherLevelPiece( ActiveLevelPieces[ i ] ).gameObject.transform.FindChild( "EndLocation" ).position;
        ActiveLevelPieces[ i ].ResetAllChildrenCoins( );
      }
    }
  }</pre></div><p>The only change here is the last line. When we have a new <code class="literal">ActiveLevelPiece</code> and when we update its location, we call <code class="literal">ResetAllChildrenCoins</code> for the <code class="literal">ActiveLevelPiece</code> so that the <code class="literal">ActiveLevelPiece</code> is fully playable again as all the coins are back to being able to be collected.</p><p>Save the <a id="id256" class="indexterm"></a>
<code class="literal">LevelPieceManager.cs</code> file and go back to <a id="id257" class="indexterm"></a>Unity. After the code has compiled, you should see your entire gameplay going, including all the <code class="literal">LevelPieces</code> moving, connecting, and resetting.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip29"></a>Tip</h3><p>Make sure to save all of your Unity files and the scene.</p></div></div></div></div>