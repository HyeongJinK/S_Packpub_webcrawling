<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec34"></a>Making the sprite tile editor tool</h2></div></div><hr /></div><p>The Unity engine is <a id="id154" class="indexterm"></a>incredibly flexible for all the aspects of game development, including creating custom editor tools to help fast track the more tedious aspects of development. In our case, it will be beneficial to have a tool that creates a root GameObject that will then create children GameObjects in a grid. The grid will be spaced out by the size of the sprite component that each of the children GameObject is using.</p><p>For example, if you were to place say <span class="emphasis"><em>24</em></span> GameObjects one at a time, it could take some time to make sure that all are snapped correctly together. With our tool, we will be able to select the <code class="literal">X</code> value and the <code class="literal">Y</code> value for the grid, the sprite that represents the ground, and the sprite that represents the dirt below the ground. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To begin with, navigate to the <code class="literal">Assets</code> folder. Right-click on this folder and select <span class="strong"><strong>Create</strong></span> and then <span class="strong"><strong>New</strong></span> <span class="strong"><strong>Folder</strong></span>. Name this folder <code class="literal">Level</code>.</p></li><li><p>Right-click on the new <code class="literal">Level</code> folder and select <span class="strong"><strong>Import New Assetâ€¦</strong></span>.</p></li><li><p>In the files for this book, navigate to the folder named <code class="literal">Art</code> and then <code class="literal">ChapterFour_Floor</code>. Import all the four floor files: <code class="literal">Floor_00</code>, <code class="literal">Floor_01</code>, <code class="literal">Floor_02</code>, and <code class="literal">Floor_03</code>. We will use these files to create our game-level pieces.</p></li><li><p>Right-click on the <code class="literal">Script</code> folder, select <span class="strong"><strong>Create</strong></span> and then <span class="strong"><strong>C# Script</strong></span>. Name the script <code class="literal">SpriteTiler</code>.</p></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec25"></a>The SpriteTiler C# class</h3></div></div></div><p>Double-click <a id="id155" class="indexterm"></a>on the <code class="literal">SpriteTiler</code> C# file to open it. Change <a id="id156" class="indexterm"></a>the file so that it looks similar to the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using UnityEditor;
using System.Collections;

public class SpriteTiler : EditorWindow
{
}</pre></div><p>The big changes from the normally generated code file, is the addition to <code class="literal">using UnityEditor</code>, changing the inherited class to <code class="literal">EditorWindow</code>, and removing the <code class="literal">Start( )</code> and <code class="literal">Update( )</code> functions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec26"></a>Global variables</h3></div></div></div><p>We now want to <a id="id157" class="indexterm"></a>add the global variables <a id="id158" class="indexterm"></a>for this class. Add the following code in the class block:</p><div class="informalexample"><pre class="programlisting">    // Grid settings to make tiled by
    public float GridXSlider = 1;
    public float GridYSlider = 1;

    // Sprites for both the ground and dirt
    public Sprite TileGroundSprite;
    public Sprite TileDirtSprite;

    // Name of the GameObject that holds our tiled Objects
    public string TileSpriteRootGameObjectName = "Tiled Object";</pre></div><p>The <code class="literal">GridXSlider</code> and <code class="literal">GridYSlider</code> values will be used to generate our grid, <code class="literal">X</code> being left to right and <code class="literal">Y</code> being top down. For example, if you had <code class="literal">X</code> set to <span class="emphasis"><em>five</em></span> and <code class="literal">Y</code> set to <span class="emphasis"><em>three</em></span>, the grid would generate columns of <span class="emphasis"><em>five</em></span> elements and rows of <span class="emphasis"><em>three</em></span> elements or <span class="emphasis"><em>five</em></span> sprites long and <span class="emphasis"><em>three</em></span> sprites down.</p><p>The <code class="literal">TileGroundSprite</code> and <code class="literal">TileDirtSprite</code> sprite files will make up the ground and dirt levels.</p><p><code class="literal">TileSpriteRootGameObjectName</code> is the GameObject name that will hold the GameObjects children that <a id="id159" class="indexterm"></a>have the Sprite components. This <a id="id160" class="indexterm"></a>is editable by you so that you can choose the name of the GameObject that gets created to avoid having the default <span class="emphasis"><em>new GameObject</em></span> for each one made.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec27"></a>The MenuItem creation</h3></div></div></div><p>Next, we need <a id="id161" class="indexterm"></a>to create the <code class="literal">MenuItem</code> function. This will <a id="id162" class="indexterm"></a>represent the <span class="strong"><strong>Editor</strong></span> selection drop-down list so that we can use our tool. Add the following function to the <code class="literal">SpriteTiler</code> class under the global variables:</p><div class="informalexample"><pre class="programlisting">    // Menu option to bring up Sprite Tiler window
    [MenuItem("RushRunner/Sprite Tile")]
    public static void OpenSpriteTileWindow()
    {
      EditorWindow.GetWindow&lt; SpriteTiler &gt; ( true, "Sprite Tiler" );
    }</pre></div><p>As this class extends <code class="literal">EditorWindow</code>, and the preceding function is declared as <code class="literal">MenuItem</code>, it will create a dropdown in the <span class="strong"><strong>Editor</strong></span> named <span class="strong"><strong>RushRunner</strong></span>. This will hold a selection called <span class="strong"><strong>Sprite Tile</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_01.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Tip</h3><p>You can name the dropdown and selection anything you like by changing the string that is passed into <code class="literal">MenuItem</code>, such as "MyEditorTool / Editor Tool Name".</p></div><p>If you save the <a id="id163" class="indexterm"></a>
<code class="literal">SpRiteTiler.cs</code> file and go back to Unity and <a id="id164" class="indexterm"></a>allow the engine to compile, you will be able to click on the <span class="strong"><strong>Sprite Tile</strong></span> button under <span class="strong"><strong>RushRunner</strong></span>. This will create an editor window named <span class="strong"><strong>Sprite Tiler</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec28"></a>The OnGUI function</h3></div></div></div><p>Next, we need to <a id="id165" class="indexterm"></a>add the function that will be used to draw all the window GUI elements or the fields that we will use to get the settings to make the grid. Under our <code class="literal">OpenSpriteTileWindow</code> function, add the following code:</p><div class="informalexample"><pre class="programlisting">    // Called to render GUI frames and elements
    void OnGUI()
    {
    }</pre></div><p><code class="literal">OnGUI</code> is the function that will draw our GUI elements to the window. This allows you to manipulate these GUI elements so that we have values to use when we create the GameObject grid and its children GameObjects with sprite components.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec01"></a>The GUILayout and OnGUI setup</h4></div></div></div><p>To begin <a id="id166" class="indexterm"></a>with the <code class="literal">OnGUI</code> function, we want to add the GUI <a id="id167" class="indexterm"></a>elements to the window. In the <code class="literal">OnGUI</code> function, add <a id="id168" class="indexterm"></a>the <a id="id169" class="indexterm"></a>following code:</p><div class="informalexample"><pre class="programlisting">        // Setting for GameObject name that holds our tiled Objects
        GUILayout.Label("Tile Level Object Name", EditorStyles.boldLabel);
        TileSpriteRootGameObjectName = GUILayout.TextField( TileSpriteRootGameObjectName, 25 );

        // Slider for X grid value (left to right)
        GUILayout.Label("X: " + GridXSlider, EditorStyles.boldLabel);
        GridXSlider = GUILayout.HorizontalScrollbar( GridXSlider, 1.0f, 0.0f, 30.0f );
        GridXSlider = (int)GridXSlider;

        // Slider for Y grid value(up to down)
        GUILayout.Label("Y: " + GridYSlider, EditorStyles.boldLabel);
        GridYSlider = GUILayout.HorizontalScrollbar(GridYSlider, 1.0f, 0.0f, 30.0f);
        GridYSlider = (int)GridYSlider;

        // File chose to be our Ground Sprite
        GUILayout.Label("Sprite Ground File", EditorStyles.boldLabel);
        TileGroundSprite = EditorGUILayout.ObjectField(TileGroundSprite, typeof(Sprite), true) as Sprite;

        // File chose to be our Dirt Sprite
        GUILayout.Label("Sprite Dirt File", EditorStyles.boldLabel);
        TileDirtSprite = EditorGUILayout.ObjectField(TileDirtSprite, typeof(Sprite), true) as Sprite;</pre></div><p><code class="literal">GUILayout.Label</code> is a function that creates a text label in the window we are using. Its first use is to let the user know that the next setting is for <span class="strong"><strong>Tile Level Object Name</strong></span>: the name of the root GameObject that will hold children GameObjects with sprite components. By <a id="id170" class="indexterm"></a>default, this is set to <span class="strong"><strong>Tiled Object</strong></span>, although we allow the user to change it.</p><p>In order to allow the <a id="id171" class="indexterm"></a>user to change it, we need to give them a <code class="literal">TextField</code> parameter <a id="id172" class="indexterm"></a>to input a new string. We do this by saying that <code class="literal">TileSpriteRootGameObjectName</code> is equal to the <code class="literal">GUILayout.TextField</code> setting. As this is used in <code class="literal">OnGUI</code>, anything the user inputs will change the value of <code class="literal">TileSpriteRootGameObjectName</code>. We will use this later when the user wants to create the GameObject.</p><p>We then need to create <a id="id173" class="indexterm"></a>two <code class="literal">HorizontalSlider</code> GUI elements so that we can get values from them that represent the <code class="literal">X</code> and <code class="literal">Y</code> values of the grid. Similar to <code class="literal">TextField</code>, we can start each of the <code class="literal">HorizontalSlider</code> elements with <code class="literal">GUILayout.Label</code>. This describes what the slider is for. We will then assign the <code class="literal">GridXSlider</code> and <code class="literal">GridYSlider</code> values to what the <code class="literal">HorizontalSlider</code> is set to, which is <span class="emphasis"><em>one</em></span> by default.</p><p>As the user adjusts the sliders, the <code class="literal">GridXSlider</code> and <code class="literal">GridYSlider</code> values will change so that when the user clicks on a button to create the GameObject, we will have a reference to the values that they want to use for the grid.</p><p>After <code class="literal">HorizontalSliders</code>, we want to have <code class="literal">ObjectFields</code> so that the user can search for and assign sprite <a id="id174" class="indexterm"></a>files that will represent the ground <a id="id175" class="indexterm"></a>and dirt of the grid. The user then uses <code class="literal">EditorGUILayout.ObjectField</code> to select a sprite reference from the <code class="literal">Asset</code> folder. As we assigned <code class="literal">ObjectField</code> to only accept sprites, that is all that the user will see when they want to input one. As we want this <code class="literal">ObjectField</code> to be for sprites, we will set the type of object to <code class="literal">typeof( Sprite )</code> and then cast the result that is assigned to <code class="literal">TileGroundSprite</code> or <code class="literal">TileDirtSprite</code> to the sprite by using <code class="literal">as Sprite</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec29"></a>The OnGUI create tiled button</h3></div></div></div><p>In order to <a id="id176" class="indexterm"></a>know when the user wants to create the <a id="id177" class="indexterm"></a>root GameObject and its grid of children GameObjects, we will need a button. Add the following code under the last GUI elements:</p><div class="informalexample"><pre class="programlisting">    // If butt "Create Tiled" is clicked
    if (GUILayout.Button("Create Tiled"))
    {
      // If the Grid settings are both zero, 
      // send notification to user
      if (GridXSlider == 0 &amp;&amp; GridYSlider == 0)
      {
        ShowNotification(new GUIContent("Must have either X or Y grid set to a value greater than 0"));
        return;
      }

      // if Dirt and Ground Sprite exist
      if (TileDirtSprite != null &amp;&amp; TileGroundSprite !=null)
      {
        // If the Sprites sizes don't match,
        // send notification to user
        if (TileDirtSprite.bounds.size.x != TileGroundSprite.bounds.size.x || TileDirtSprite.bounds.size.y != TileGroundSprite.bounds.size.y)
        {
          ShowNotification(new GUIContent("Both Sprites must be of matching size."));
          return;
        }

        // Create GameObject and tiled 
        // Objects with user settings
        CreateSpriteTiledGameObject(GridXSlider, GridYSlider, TileGroundSprite, TileDirtSprite, TileSpriteRootGameObjectName);
      }
      else
      {
        // If either Dirt or Ground Sprite don't exist,
        // send notification to user
        ShowNotification( new GUIContent( "Must have Dirt and Ground Sprite selected." ) );
        return;
      }
    }</pre></div><p>The first condition we have set is the <code class="literal">GUILayout.Button( "Create Tiled" )</code> function. The <code class="literal">Button</code> function will return true as soon as it is clicked on, but it will still render to the window if <code class="literal">false</code>. This means that although the button is not active, it'll still be seen by the user.</p><p>As some settings will create a scenario that is not ideal for the concept of our <code class="literal">SpriteTiler</code> function, we first want to make sure that the settings are in line with what we have designed the tool to perform.</p><p>We will first check whether <code class="literal">GridXSlider</code> and <code class="literal">GridYSlider</code> are set to <span class="emphasis"><em>zero</em></span>. If both of these values are set to <span class="emphasis"><em>zero</em></span>, the grid won't create anything, and as the concept of the tool is to create a grid of children sprites, we will tell the user that they must have a selection above <span class="emphasis"><em>zero</em></span> for either <code class="literal">GridXSlider</code> or <code class="literal">GridYSlider</code>.</p><p>We then check <a id="id178" class="indexterm"></a>whether <code class="literal">TileDirtSprite</code> and <code class="literal">TileGroundSprite</code> have a value. If either of these values are <span class="emphasis"><em>null</em></span>, the settings are not <a id="id179" class="indexterm"></a>complete. This results in you telling the user that dirt and ground sprites need a selection.</p><p>If the user has set dirt and ground sprites to something, but their sizing is not the same, such as one being 32 x 32 and the other being 64 x 64, we will tell the user that both the sprites need to be of the same size. If we didn't check for this, the grid wouldn't align correctly, creating negative results and making the tool not function as we want it to.</p><p>If the user settings are in order, we will call the <code class="literal">CreateSpriteTiledGameObject</code> function and pass <code class="literal">GridXSlider</code>, <code class="literal">GridYSlider</code>, <code class="literal">TileGroundSprite</code>, <code class="literal">TileDirtSprite</code>, and <code class="literal">TileSpriteRootGameObjectName</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec02"></a>The CreateSpriteTiledGameObject function</h4></div></div></div><p>This <a id="id180" class="indexterm"></a>function is designed to <a id="id181" class="indexterm"></a>take the user settings and create the grid from them. Add the following function under the <code class="literal">OnGUI</code> function:</p><div class="informalexample"><pre class="programlisting">// Create GameObject and tiled children based on user settings
public static void CreateSpriteTiledGameObject(float GridXSlider, float GridYSlider, Sprite SpriteGroundFile, Sprite SpriteDirtFile, string RootObjectName)
{
  // Store size of Sprite
  float spriteX = SpriteGroundFile.bounds.size.x;
  float spriteY = SpriteGroundFile.bounds.size.y;

  // Create the root GameObject which will hold children that tile
  GameObject rootObject = new GameObject( );

  // Set position in world to 0,0,0
  rootObject.transform.position = new Vector3( 0.0f, 0.0f, 0.0f );

  // Name it based on user settings
  rootObject.name = RootObjectName;

  // Create starting values for while loop
  int currentObjectCount = 0;
  int currentColumn = 0;
  int currentRow = 0;
  Vector3 currentLocation = new Vector3( 0.0f, 0.0f, 0.0f );

  // Continue loop until all rows 
  // and columns have been filled
  while (currentRow &lt; GridYSlider)
  {
    // Create a child GameObject, set its parent to root, 
    // name it, and offset its location based on current location
    GameObject gridObject = new GameObject( );
    gridObject.transform.SetParent( rootObject.transform );
    gridObject.name = RootObjectName + "_" + currentObjectCount;
    gridObject.transform.position = currentLocation;

    // Give child gridObject a SpriteRenderer and set sprite on CurrentRow
    SpriteRenderer gridRenderer = gridObject.AddComponent&lt;SpriteRenderer&gt;( );
    gridRenderer.sprite = ( currentRow == 0 ) ? SpriteGroundFile : SpriteDirtFile;

    // Give the gridObject a BoxCollider
    gridObject.AddComponent&lt;BoxCollider2D&gt;();

    // Offset currentLocation for next gridObject to use
    currentLocation.x += spriteX;

    // Increment current column by one
    currentColumn++;

    // If the current column is greater than the X slider
    if (currentColumn &gt;= GridXSlider)
    {
      // Reset column, increment row, reset x location
      // and offset y location downwards
      currentColumn = 0;
      currentRow++;
      currentLocation.x = 0;
      currentLocation.y -= spriteY;
    }

    // Add to currentObjectCount for naming of 
    // gridObject children.
    currentObjectCount++;
  }
}</pre></div><p>To start with, we must first have the <code class="literal">X</code> and <code class="literal">Y</code> sizes of the sprite we want to create so that we can offset the location of the children GameObjects that were created. As we originally checked to make sure that both sprites are of the same size, it doesn't matter which sprite object we get the size from. In our case, we will use <code class="literal">SpriteGroundFile</code>.</p><p>We will then move the <code class="literal">rootObject</code> position to <code class="literal">0X</code>, <code class="literal">0Y</code>, and <code class="literal">0Z</code> so that it is in the center of our scene. This can be set to anything you like, although when <code class="literal">rootObject</code> and its children get created, it is easier to find it at the center of the scene world.</p><p>After it has been <a id="id182" class="indexterm"></a>moved, we can <a id="id183" class="indexterm"></a>set its name to the setting that the user had entered or <span class="strong"><strong>Tiled Object</strong></span> (the default).</p><p>Once we have <code class="literal">rootObject</code> set up, we can create its children GameObjects. To start this cycle, we will need a few variables to reference and change:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">currentObjectCount</code>: This specifies the total number of children that will be created. This increments for each one created.</p></li><li style="list-style-type: disc"><p><code class="literal">currentColumn</code>: This denotes the current column we are on in the row.</p></li><li style="list-style-type: disc"><p><code class="literal">currentRow</code>: This specifies the current row we are on.</p></li><li style="list-style-type: disc"><p><code class="literal">currentLocation</code>: This denotes the current location that the children GameObject will use and sets its position too. This is changed after each new child is created based on the <code class="literal">X</code> or <code class="literal">Y</code> setting of the sprite size.</p></li></ul></div><p>Now that we have our <code class="literal">rootObject</code> and the variables we need to create the children, we can use a <code class="literal">while</code> loop. A <code class="literal">while</code> loop is a loop that will continue until its condition fails. In our case, we will check whether <code class="literal">currentRow</code> is less than the <code class="literal">GridYSlider</code> value. As soon as <code class="literal">currentRow</code> is equal to or greater than <code class="literal">GridYSlider</code>, the loop will stop because the condition failed.</p><p>The reason we will look at <code class="literal">currentRow</code> is that for each column created, we can reset its value to <span class="emphasis"><em>zero</em></span> and increment <code class="literal">currentRow</code> by <span class="emphasis"><em>one</em></span>. This means that each row will hold as many columns as were set by the <code class="literal">GridXSlider</code> value, and we know that the grid is complete when <code class="literal">currentRow</code> is equal to or greater than <code class="literal">GridYSlider</code>.</p><p>For example, if we had a grid setting of <code class="literal">3X</code> and <code class="literal">3Y</code>, the first row will hold <span class="emphasis"><em>three</em></span> columns. When the first row is done, the row changes to <span class="emphasis"><em>two</em></span> and adds three more columns. In the last row, it completes <span class="emphasis"><em>three</em></span> more columns and then the <code class="literal">while</code> condition fails because the row value is equal to <code class="literal">GridYSlider</code>.</p><p>In each loop of the <code class="literal">while</code> loop, we start by creating <code class="literal">gridObject</code>. We set this grid object's parent to that of <code class="literal">rootObject</code>, set its name to <code class="literal">RootObjectName</code>, and concatenate an underscore, followed by <code class="literal">currentObjectCount</code> and then set the <code class="literal">gridObject</code> position to the <code class="literal">currentLocation</code> value, which will change based on the size of the sprite and the column/row.</p><p>We will then add a <code class="literal">SpriteRenderer</code> component to <code class="literal">gridObject</code> and assign a sprite to it. We will change the sprite based on whether <code class="literal">currentRow</code> is equal to <span class="emphasis"><em>zero</em></span> or not. If it is, in the first row, we will set the sprite to <code class="literal">SpriteGroundFile</code>. If <code class="literal">currentRow</code> is not equal to <span class="emphasis"><em>zero</em></span>, we will set the sprite to <code class="literal">SpriteDirtFile</code>.</p><p>The <span class="strong"><strong>ternary operator</strong></span> is a sort of shorthand for <code class="literal">if else</code>. If the condition is <code class="literal">true</code>, we will set the <a id="id184" class="indexterm"></a>value to what is behind the <a id="id185" class="indexterm"></a>
<span class="emphasis"><em>question mark</em></span>. If the condition is <code class="literal">false</code>, we will set the value based on what's behind the <span class="emphasis"><em>colon</em></span>. The <span class="emphasis"><em>question mark</em></span> represents if, whereas the <span class="emphasis"><em>colon</em></span> represents <code class="literal">else</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Tip</h3><p>The ternary operator is as follows:</p><div class="informalexample"><pre class="programlisting">Value = ( condition == true ) ? ifTrue : elseNotTrue;</pre></div></div><p>Once we have the sprite assigned to the <code class="literal">SpriteRenderer</code> component of <code class="literal">gridObject</code>, we can assign a <span class="strong"><strong>Box Collider 2D</strong></span> component, and the <span class="strong"><strong>Box Collider 2D</strong></span> component will make itself the same size as the sprite. If we were to add the <span class="strong"><strong>Box Collider 2D</strong></span> component to <code class="literal">SpriteRenderer</code>, it would be the default size of 1,1,1, which would be too big.</p><p>We will then offset <code class="literal">currentLocation</code> by the <code class="literal">spriteX</code> size, so the next <code class="literal">gridObject</code> will offset the size of the <code class="literal">spriteX</code> size.</p><p>The <code class="literal">currentColumn</code> parameter is incremented by <span class="emphasis"><em>one</em></span>, and we then check whether <code class="literal">currentColumn</code> is greater than or equal to the <code class="literal">GridXSlider</code> value. If it is, we know that we need to start the next row.</p><p>To do this, we reset <code class="literal">currentColumn</code> to <span class="emphasis"><em>zero</em></span>, increment <code class="literal">currentRow</code> by <span class="emphasis"><em>one</em></span>, set the <code class="literal">currentLocation.x</code> value to <span class="emphasis"><em>zero</em></span>, and offset <code class="literal">currentLocation.y</code> by a negative <code class="literal">spriteY</code> size. This not only results in an offset location down, but also resets the <code class="literal">X</code> value to zero, making it possible for the columns to be created again; just down from the size of <code class="literal">spriteY</code>.</p><p>Finally, we <a id="id186" class="indexterm"></a>increment <a id="id187" class="indexterm"></a>
<code class="literal">currentObjectCount</code> by<span class="emphasis"><em> one</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec03"></a>Testing the SpriteTiler file</h4></div></div></div><p>Make sure to <a id="id188" class="indexterm"></a>save the <code class="literal">SpriteTiler.cs</code> file and then go back to Unity and allow it to compile.</p><p>When it does, you <a id="id189" class="indexterm"></a>should continue to see the <span class="strong"><strong>RushRunner</strong></span> drop-down selection on the top editor bar. Click on it and then on its child: <span class="strong"><strong>Sprite Tile</strong></span>. This should open the <span class="strong"><strong>Sprite Tiler</strong></span> window with all of our settings:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_02.jpg" /></div><p>The <span class="strong"><strong>Sprite Tiler</strong></span> window now allows you to input the settings so that you can begin to create GameObjects, which hold a grid of children GameObjects, which in turn hold a sprite component of what is set within the <span class="strong"><strong>Sprite Tiler</strong></span> window.</p><p>To begin, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To test <span class="strong"><strong>Sprite Tiler</strong></span>, you can keep the default <span class="strong"><strong>Tile Level Object Name</strong></span>.</p></li><li><p>Now, change <span class="strong"><strong>X</strong></span> to a bigger value.</p></li><li><p>Then, change <span class="strong"><strong>Y</strong></span> to a bigger value.</p></li><li><p>Now, click on the small circle to the right of <span class="strong"><strong>Sprite Ground File</strong></span> and add <code class="literal">Floor_00</code>.</p></li><li><p>Then, click on the small circle to the right of <span class="strong"><strong>Sprite Dirt File</strong></span> and add <code class="literal">Floor_01</code>.</p></li><li><p>Finally, click on <span class="strong"><strong>Create Tiled</strong></span>.</p></li></ol></div><p>I chose <span class="strong"><strong>X</strong></span> = <code class="literal">6</code>, <span class="strong"><strong>Y</strong></span> = <code class="literal">8</code>, and <a id="id190" class="indexterm"></a>the grid looks similar to the <a id="id191" class="indexterm"></a>following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784399801/graphics/B04063_04_03.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"></a>Tip</h3><p>If you want to test a bigger grid, choose <code class="literal">Floor_03</code> as the ground sprite and <code class="literal">Floor_02</code> as the dirt sprite. These images are bigger; however, because they are of the same size, you <a id="id192" class="indexterm"></a>can use them as <code class="literal">Floor_00</code> and <code class="literal">Floor_01</code>. They will make a bigger floor in the <code class="literal">X</code> axis because they are much wider.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec04"></a>Sprite Tiler wrap-up</h4></div></div></div><p>This editor tool <a id="id193" class="indexterm"></a>allows you to create GameObjects that hold <a id="id194" class="indexterm"></a>child GameObjects that have <code class="literal">SpriteRenderers</code> on them. This sort of method can be extended and modified to create more complex shapes and use different types of sprite images to create them. For now, this allows you to create the basic structure of our game-level pieces with much less effort than if we didn't have this tool to assist us.</p><p>Extending Unity's <code class="literal">EditorWindow</code> allows you and your team to create an assortment of custom tools that can handle any sort of efficiency or workflow problem specific to the type of game you will create.</p></div></div></div>