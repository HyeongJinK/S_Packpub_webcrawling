<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec56"></a>Player controller</h2></div></div><hr /></div><p>The <code class="literal">PlayerController</code> in this instance is slightly different from that in <span class="emphasis"><em>Angel Cakes</em></span>. However, we can use what we learned in the previous project to create this new player controller.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec77"></a>Requirements of the player controller</h3></div></div></div><p>Let's start by defining the requirements for this player controller.</p><p>First of all, we would like to lock the movement to only left and right; we don't want the player going up and down. Of course, this is the choice we made when we designed the game earlier in the chapter. Another consideration is that the left and right movements are limited; the player cannot go off screen. In <span class="emphasis"><em>Angel Cakes</em></span> we have solved this problem by placing walls, so we delegated to the physics system the fact that the player cannot go beyond certain boundaries. In space, there are no walls, and even if we could place invisible ones, for the sake of learning something new, we will see how to limit the movement through the script.</p><p>Differently from <span class="emphasis"><em>Angel Cakes</em></span>, the player here can shoot. In particular, the player can shoot straight from the player's location. In our implementation, this means that the player controller has to instantiate a bullet. However, we also need to limit this process, since we don't want the player to shoot billions of projectiles per second, but rather have a reload time before shooting the next bullet. As such, the player controller is also responsible for making this check.</p><p>Lastly, the spaceship can take damage, so we need to show the animation of the explosion where the enemy's bullet has hit the player. Again, the player controller has to deal with it. Actually, not only should it show the explosion, but it should also play a sound and decrease the number of lives by one. However, for these two things, we need to wait until <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Getting Serious About Gameplay</em></span>, in which we will implement the UI, but it was worth mentioning it here since we are designing our player controller.</p><p>Now that we understand the requirements for our player controller, let's implement it. If you remember in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Let's Make Some Prefabs</em></span>, we saw the script piece by piece. Here, to change the approach, we will see all its functionalities one by one.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec78"></a>Creating the script</h3></div></div></div><p>As we did in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Let's Make Some Prefabs</em></span>, we need to create a <strong class="userinput"><code>Player Controller (Script)</code></strong>. Inside the <code class="literal">Script</code> folder, right-click and then <strong class="userinput"><code>Create</code></strong> | <strong class="userinput"><code>C# Script</code></strong>. We name it <code class="literal">PlayerController</code>. Now the script can be used as a component, meaning that it can be attached to a game object:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/d5f21c4b-773e-411f-9225-b5b4fb89d018.png" /></div><p>We can then open the <strong class="userinput"><code>Script</code></strong> by double-clicking on it. For those who didn't follow the previous project, here is a short recap. This is the code you should see:</p><pre class="programlisting">using System.Collections; 
using System.Collections.Generic; 
using UnityEngine; 
 
public class PlayerController : MonoBehaviour { 
 
   // Use this for initialization 
   void Start () { 
          
   } 
    
   // Update is called once per frame 
   void Update () { 
          
   } 
} </pre><p>At the beginning, there are three lines that allow us to use libraries. Then, there is the class definition, in this case, named <code class="literal">PlayerController</code>. Inside it, there are two functions: <code class="literal">Start()</code> and <code class="literal">Update()</code>. The first is called every time this script starts, whereas the second is called at every frame.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec79"></a>Moving the player</h3></div></div></div><p>The first feature to implement is the most vital one: moving the player.</p><p>Let's start by copying and pasting the code from <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Let's Make Some Prefabs</em></span>. In fact, we need to enforce both <span class="strong"><strong>collider</strong></span> and <span class="strong"><strong>rigidbody</strong></span> components, since we will use them to move the character (and also to detect collisions with bullets or enemies). Then, we actually need to move the character. You can refer to <a class="link" href="#" linkend="ch03">Chapter 3</a>,<span class="emphasis"><em> Let's Make Some Prefabs</em></span>, for a detailed explanation, but we are going to use, once again, the following equation:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/026739c1-78d9-479a-aeac-3a11daae8a25.png" /></div><p>The only difference is that we don't need to move the player along the y-axis, so the code within the <code class="literal">FixedUpdate()</code> function becomes <span>shorter than one line</span>. Also, we need to substitute the <code class="literal">y</code> variable in the last line of the function with <code class="literal">transform.position.y</code>.</p><p>The final code should look like the following:</p><pre class="programlisting">using System.Collections; 
using System.Collections.Generic; 
using UnityEngine; 
 
[RequireComponent(typeof(Rigidbody2D))] 
[RequireComponent(typeof(Collider2D))] 
public class PlayerController : MonoBehaviour { 
 
    public float speed = 10.0f; 
    private Rigidbody2D rigidBody; 
 
    // Use this for initialization 
    void Start() { 
        rigidBody = GetComponent&lt;Rigidbody2D&gt;(); 
    } 
 
    void FixedUpdate() { 
        //Get the new position of our character 
        var x = transform.position.x + Input.GetAxis("Horizontal") * Time.deltaTime * speed; 
 
        //Set the position of our character through the RigidBody2D component (since we are using physics) 
        rigidBody.MovePosition(new Vector2(x, transform.position.y)); 
    } 
} </pre><p>So far so good, the player is able to move left and right. However, the spaceships movement is unlimited along the x-axis. Therefore, <span>we will need to use a wall to contain the player's movement. To begin we will need to </span>add a variable. We assume that the main camera is centered (as in any 2D default scene). Thus, if the player is on <code class="literal">x=0</code>, then the spaceship is in the middle of the left and right sides of the screen. As a result, we are able to use just one variable to limit the motion both left and right symmetrically. We can add to our code the <code class="literal">boundX</code> variable, make it public (so designers can tweak it), and assign an initial value:</p><pre class="programlisting">    public float boundX = 10.0f; </pre><p>Now, within the <code class="literal">FixedUpdate()</code> function, we need to use a math function to clamp the <code class="literal">x</code> value in case it becomes bigger than <code class="literal">boundX</code> or smaller than negative <code class="literal">boundX</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note30"></a>Note</h3><p>A clamp function is a function that takes as input three parameters: a <code class="literal">value</code>, a <code class="literal">min</code>, and a <code class="literal">max</code>. If the <code class="literal">value</code> is in between the <code class="literal">min</code> and the <code class="literal">max</code>, the function returns (gives back) the <code class="literal">value</code> itself. Otherwise, the function returns <code class="literal">max</code> if the <code class="literal">value</code> is bigger than <code class="literal">max</code>; similarly, the function returns <code class="literal">min</code> if the value is less than <code class="literal">min</code>.</p></div><p>In the Unity Math Library, such a function is already implemented, so let's use it <span>between getting the new</span><code class="literal">x</code> value and assign the new position to the <span class="strong"><strong>rigidbody</strong></span>, like the following:</p><pre class="programlisting">    void FixedUpdate() { 
        //Get the new position of our character 
        var x = transform.position.x + Input.GetAxis("Horizontal") * Time.deltaTime * speed; 
<span class="strong"><strong>        //Clamp along x-value according to boundX variable 
        x = Mathf.Clamp(x, -boundX, boundX);</strong></span> 
        //Set the position of our character throught the RigidBody2D component (since we are using physics) 
        rigidBody.MovePosition(new Vector2(x, transform.position.y)); 
    } </pre><p>Save the script and test it to see if it works before moving on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec80"></a>It's time to shoot</h3></div></div></div><p>The next step is to give the player the ability to shoot. In doing so, the player controller creates a <code class="literal">bulletPrefab</code>. We don't have a <code class="literal">bulletprefab</code> yet, but we will create it later in the chapter. However, we can create a variable to hold the prefab, so it can be changed later on in the <strong class="userinput"><code>Inspector</code></strong>, as the following:</p><pre class="programlisting">    public GameObject bulletPrefab; </pre><p>Now, in the <code class="literal">FixedUpdate()</code> function, after all the lines we already have, we need to instantiate the bullet every time the player shoots. In this case, we are going to check whether the player presses the <strong class="userinput"><code>Fire1</code></strong> button or the <span class="emphasis"><em>E</em></span> key. If so, we just instantiate the bullet prefab at the same position as the spaceship and without any rotation applied, which is expressed through the admittedly fancy <code class="literal">Quaternion.Identity</code> argument (you can find out more about quaternions in Unity at the following links: <a class="ulink" href="https://unity3d.com/learn/tutorials/topics/scripting/quaternions" target="_blank">https://unity3d.com/learn/tutorials/topics/scripting/quaternions</a> and <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Quaternion.html" target="_blank">https://docs.unity3d.com/ScriptReference/Quaternion.html</a>:</p><pre class="programlisting">    void FixedUpdate() { 
        // [...] 
<span class="strong"><strong>        //Check if the player has fired 
        if (Input.GetKeyDown(KeyCode.E) || Input.GetButtonDown("Fire")) { 
                //Create the bullet 
                Instantiate(bulletPrefab, transform.position, Quaternion.identity); 
        }</strong></span> 
    } </pre><p>This works just fine, but it can be improved. As we anticipated, right now the player can repeatedly press the <span class="emphasis"><em>E</em></span> key and can shoot many bullets. We want in some way to limit this process. In order to achieve this, we need to write a bit more code.</p><p>First, we need two variables to store the reload time, which is how often the player can shoot, and the last time the player has shot, which is a private variable to check if the reload time has expired:</p><pre class="programlisting">    public float reloadTime = 1.0f; 
    private float lastTimeShot = 0f; </pre><p>We have to change the code in the <code class="literal">FixedUpdate()</code> to reflect this change. <span>So, inside the <span class="strong"><strong><code class="literal">if statement</code>,</strong></span> it checks if the player has shot</span>, and we can nest another <code class="literal">if</code> to check whether the player can shoot or if it is too early (the reload time hasn't expired yet). We can do this by calculating with a subtraction how much time has passed since the last time the player shot and compare it with the reload time. If this results as greater than the reload time, then we need to update the last time the player shot and actually created the bullet. In the end, the code looks like the following:</p><pre class="programlisting">    void FixedUpdate() { 
        // [...] 
        //Check if the player has fired 
        if(Input.GetKeyDown(KeyCode.E) || Input.GetButtonDown("Fire")) { 
<span class="strong"><strong>            //Check if the player can shoot since last time the spaceship has fired 
            if(Time.time - lastTimeShot &gt; reloadTime) { 
                //Set the current time as the last time the spaceship has fired 
                lastTimeShot = Time.time;</strong></span> 
 
                //Create the bullet 
                Instantiate(bulletPrefab, transform.position, Quaternion.identity); 
            <span class="strong"><strong>}</strong></span> 
        } 
    } </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec81"></a>That explosion was bad</h3></div></div></div><p>In <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Freeze! Creating an Intergalactic Shooter</em></span>, we created an explosion prefab. This will come in handy now, when we need to make our spaceship explode every time it takes damage.</p><p>If you remember from the <span class="emphasis"><em>Angel Cakes</em></span> collecting system, when the player comes into contact with a cake, it is collected. This was done using a special Unity function named <code class="literal">OnTriggerEnter2D</code>, which detects when the player enters the collider of the cake. Here, we are going to do something similar, but to learn something new, we will implement the explosion in this way: when the enemy bullet hits the player, it's the script of the bullet that makes this check (while in <span class="emphasis"><em>Angel Cakes</em></span> the cake was detecting this), but then it will communicate this to the player controller, which will create an explosion (and eventually decrease the number of lives).</p><p>Thus, in order to make the player controller communicate with the future bullet script, we need to create a public function named <code class="literal">Hit()</code>, which will be called by the future bullet script. What do we need from this function? At the current stage, we just need to instantiate the explosion. This can be done very easily with just a few lines of code.</p><p>First of all, add a variable that holds the explosion prefab, so we are able to instantiate it in the <code class="literal">Hit()</code> function:</p><pre class="programlisting">    public GameObject explosionPrefab; </pre><p>Then, let's write the <code class="literal">Hit()</code> function with a line of code that creates an explosion based on the <code class="literal">explosionPrefab</code> variable at the same coordinates of where the spaceship of the player has been hit. This means that the coordinates are passed from the bullet script as a parameter of the function:</p><pre class="programlisting">    public void Hit(Vector3 hitCoordinates) { 
        //Create an explosion on the coordinates of the hit. 
        Instantiate(explosionPrefab, hitCoordinates, Quaternion.identity); 
    } </pre><p>Save the script, and as a result, the spaceship is able to take damage, or at least show that it has been hit. We will deal with proper damage in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em><span>Getting Serious About Gameplay</span></em></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec39"></a>Testing the explosion</h4></div></div></div><p>If you don't want to wait to implement the bullet script to test this function, you can add in the <code class="literal">FixedUpdate()</code> so that every time the player presses the key <span class="emphasis"><em>T</em></span>, the <code class="literal">Hit()</code> function is called. Thus, by following a similar process to shooting bullets, we can add the following lines to the function:</p><pre class="programlisting">        //DEBUG CODE: simulates the Hit() function when the player presses the T key 
        if (Input.GetKeyDown(KeyCode.T)) { 
            Hit(transform.position); 
        } </pre><p>And this is how it looks in the game:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/41555e94-ffb8-4324-8662-9fd520d7bc07.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip31"></a>Note</h3><p>The background you see in the image is a demo image of the package. As a pro tip, you can use the demo image as an example image of the level you are going to build. If you place it underneath, you can have a good sense of whether the explosion is working in the future environment or not and adjust it without waiting for the environment to be built. In our case, we might want to scale down the explosion a bit, and maybe save this scaled down into the prefab. Of course, if you like big explosions, you can leave it as it was before. Also, feel free to change the color if you want. </p></div><p>However, remember to remove these lines (the debug code) once you have finished testing it. Alternatively, you can also comment out the code or surround the debug code with a <code class="literal">debugEnabled</code> if statement. However, if the testing code is temporary, erasing it will lead to fewer troubles later on.</p></div></div></div>