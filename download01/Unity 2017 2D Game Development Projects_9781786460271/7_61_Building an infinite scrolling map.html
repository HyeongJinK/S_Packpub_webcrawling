<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec63"></a>Building an infinite scrolling map</h2></div></div><hr /></div><p>So far, we have the main functionalities of the game running. This section will explore how to create the map in which our shoot takes place. Here, we will implement the main parts, such as making the map perform infinite scrolling or making a satellite rotating around a planet. However, implementing other elements and polishing the game are left as exercises in the next section.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec94"></a>Repeating the background</h3></div></div></div><p>In an infinite scrolling game, we need a background that repeats continuously. Of course, adding variation to the background (or many layers of background, called parallax) improves the visual appeal greatly. However, usually, there is a basic tileable background that repeats at the very end.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>Parallax scrolling means having two or more layers that move at different speeds to achieve a sense of depth. Usually, layers farther away from the game camera move slower than layers near it.</p></div><p>The concept is that the image scrolls downward followed by another identical image. Since destroying and creating game objects aren't cheap functions from a computational point of view, it's good practice to use just a couple of image game object instances (instead of many that are created at the top and destroyed at the bottom). Both images scroll, then as soon as one goes off-screen, both are repositioned to their initial position. As a result, you create the illusion that the background repeats indefinitely.</p><p>From an operative point of view, we have two images: one that occupies the whole screen, and the other one just above. They will scroll down, and as soon as the second image fills the whole screen, both images are repositioned. We will create a single script that we will attach to both the images. This is an easy approach, but we need to remind the designers that they should share the same speed, otherwise they won't scroll seamlessly. Even if it is good practice to enforce this by code, for simplicity's sake we will delegate the responsibility of matching the two speeds to the designers.</p><p>Drag and drop the background image of the package, and then duplicate it. Place one in such a way that it fills the screen completely, and the other one just above, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/a45cd8de-8181-4854-8841-08072165ed92.png" /></div><p>Now, create a C# script and name it <code class="literal">RepeatingBackground</code>. Attach the script to both the images, and open it.</p><p>As usual, we can define the speed as a public variable, so it can be easily set by designers:</p><pre class="programlisting">    public float speed = 1.3f; </pre><p>Next, we need to use a couple of private variables to store the initial position and the offset, which is the y-length of the image, so we can write:</p><pre class="programlisting">    private Vector3 initialPos; 
    private float offset; </pre><p>Then, we need to initialize these two variables at the <code class="literal">Start()</code> function. For the initial position, it is easy; for the offset, we have to retrieve the <code class="literal">SpriteRenderer</code> and extract the height, which can be found by retrieving the y-length from the size of the bounds:</p><pre class="programlisting">   void Start () { 
        //Store the initial position 
        initialPos = transform.position; 
 
        //Store the y-length of the Sprite 
        offset = GetComponent&lt;SpriteRenderer&gt;().bounds.size.y; 
    } </pre><p>In the <code class="literal">Update()</code> function, we need to move the image downward. Why not use the <code class="literal">FixedUpdate()</code> function instead? For the first time with code, we need to move something in the <code class="literal">Update()</code> function because we don't have a <span class="strong"><strong>rigidbody</strong></span> since the object/image doesn't have to interact (it's just a background, after all). As a result, not only can we use the <code class="literal">Update()</code> function, but we can move it by using its transform directly. Thus, let's write:</p><pre class="programlisting">    void Update () { 
<span class="strong"><strong>        //Scroll the background 
        transform.position += new Vector3(0, -Time.deltaTime, 0);</strong></span> 
   } </pre><p>Lastly, after the object has passed the offset, it has to be repositioned. Hence, we can check whether the absolute value of the difference between the current <code class="literal">y</code> position and the original one (which is a measure of the distance it has moved from the initial position, or in other terms the offset) is greater than the offset variable. If so, set the position for the initial one:</p><pre class="programlisting">    void Update () { 
        //Scroll the background 
        transform.position += new Vector3(0, -Time.deltaTime, 0); 
 
<span class="strong"><strong>        //Check if the scrolling has passed the offset, if so, reposition the image 
        if(Mathf.Abs(transform.position.y - initialPos.y) &gt; offset) { 
            //Reposition the image 
            transform.position = initialPos; 
        }</strong></span> 
   } </pre><p>Save the script, and remember to assign the same speed to both your background images. As a result, if you hit play, we have the background repeating indefinitely.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec95"></a>Falling stars and planets</h3></div></div></div><p>Aside from the background, other "decorations" might fall from the sky, such as planets, satellites, or stars. In this section, we are going to implement a quick script that makes an object fall. Again, we are going to use the <code class="literal">Update()</code> function to move, instead of the <code class="literal">FixedUpdate()</code>, for the same reasons of the repeating background.</p><p>Create a new script and name it <code class="literal">FallingScript</code>. Open it, and add the <code class="literal">speed</code> variable as usual:</p><pre class="programlisting">    public float speed = 1.3f; </pre><p>Then, since we don't want the object falling indefinitely, as we did for <code class="literal">BulletController</code> in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>No One Is Alone Forever</em></span>, we need a variable to store the time before the auto-destruction:</p><pre class="programlisting">    public float timeBeforeDestruction = 10.0f; </pre><p>In the <code class="literal">Start()</code> function, we need to trigger the countdown for the auto-destruction, like we did for <code class="literal">BulletController</code>:</p><pre class="programlisting">    void Start () { 
        //Destroy the falling object after timeBeforeDestruction 
        Destroy(gameObject, timeBeforeDestruction); 
    } </pre><p>Then, in the <code class="literal">Update()</code> function, we can just move the object downwards, as follows:</p><pre class="programlisting">   void Update () { 
        //Move the object downwards 
        transform.position += new Vector3(0, -speed * Time.deltaTime, 0); 
    } </pre><p>Save the script, and attach it to any object you want to make fall (of course, remember to create a prefab first and to place the ordering layer, or the z coordinate, in such a way that the object is still rendered below spaceships, enemies, and bullets).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec96"></a>Rotating satellites</h3></div></div></div><p>If you have noticed, in our package we have some planets with some circles around them. Even if the whole planet can be driven by <code class="literal">FallingScript</code>, we can create satellites as children of the planet, rotating around it. So, create a prefab for the planet with the circle, and attach <code class="literal">FallingScript</code>. Then, as a child (or children if you want more than one) attach satellites to the <code class="literal">RotatingSatellite</code> script we are going to create. As a result, we will have a planet with satellites orbiting around, as shown in the following image:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/a5d8813d-fadd-4689-9614-2252ab7d5e87.png" /></div><p>Now, let's create the aforementioned script (<code class="literal">RotatingSatellite</code>), and open it. Once again, we need the <code class="literal">speed</code> variable:</p><pre class="programlisting">    public float speed = 3f; </pre><p>Then, we need a variable to store the radius of the orbit. By adjusting this value, designers are able to tweak how far the satellite orbits around it (or adjusting to the circle's radiuses):</p><pre class="programlisting">    public float radius = 1f; </pre><p>For the motion, we just need to follow a circular path. <span>If you are familiar </span>with trigonometry, this is just having a cosine on the <code class="literal">x</code> and the sine on the <code class="literal">y</code>; as arguments of these trigonometry functions, we need the time scaled by the speed. Then, it's just a matter of assigning the variables to the new position. Of course, the position needs to be in local space, since we are assigning the new position with respect to the planet:</p><pre class="programlisting">   void Update () { 
        //Calculate the new x and y of the circular motion 
        var x = radius * Mathf.Cos(speed * Time.time); 
        var y = radius * Mathf.Sin(speed * Time.time); 
 
        //Assign the new position to the object transform 
        transform.localPosition =  new Vector3(x, y, 0f); 
   } </pre><p>Save the script, and enjoy satellites orbiting around your planets.</p></div></div>