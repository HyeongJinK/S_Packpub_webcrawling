<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec57"></a>Enemy controller</h2></div></div><hr /></div><p>In this section, we will explore how to create the enemy controller.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec82"></a>Requirements of the enemy controller</h3></div></div></div><p>First of all, we need to move the enemy independently of the player input. As per our design, we want the enemy to continuously move left and right, but also slowly move down. Therefore, we can split the different movements between the two axes. For the x-axis, we can use a sine function to fluctuate (oscillate) between left and right continuously. For the y-axis, instead, we can have the usual movement, just much slower. For instance, the enemy spaceship can do two or three times left-right before it has moved down along the y-axis, a length similar to its dimension.</p><p>Another consideration is concerning when the enemy should shoot. In big games, there are complicated AI algorithms to perform a decision-making process. However, here we want to show how it's possible to create a challenging AI with just a few lines of code. So, in this case, we let the enemy shoot randomly, for instance, every one to three seconds. Later in the chapter, we will see a variation, where the enemy shoots when it is above the player.</p><p>Besides all of this, we have pretty much all the functionalities of the player controller, so the enemy spaceship moves, moving the <span class="strong"><strong>rigidbody </strong></span>and implementing a <code class="literal">Hit()</code> function to take damage.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec83"></a>Creating the enemy controller</h3></div></div></div><p>Create a new C# script and call it <code class="literal">EnemyController</code>. Since this controller shares many functionalities in common with the player controller, it's better to copy the player controller and modify it. So, copy the whole body of the player controller onto the enemy controller. Don't forget that the name of the class should remain <code class="literal">EnemyController</code>, and this is very important; otherwise, we will have compilation errors.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec84"></a>New variables for the enemy controller</h3></div></div></div><p>Since the enemy is now controlled by the computer, we need to script a behavior, like the one we described in the requirements section. Therefore, we need new variables and we need to change some of the old ones.</p><p>First of all, we need two different speeds. In fact, the enemies not only move left and right, but they are also coming down slowly. So, let's substitute the speed variable with the following two:</p><pre class="programlisting">    public float speedX = 10.0f; 
    public float speedY = -1.0f; </pre><p>It's not a mistake that the speed along y is negative. The enemy is moving down, so with a negative speed, the enemy will move downwards.</p><p>Now, we need to add a couple of other variables. As we have seen in the requirements, the enemy shoots randomly <span class="emphasis"><em>between</em></span> an interval of time, for instance between <code class="literal">1</code> and <code class="literal">3</code>. To define this interval, we need a variable to specify the minimum, and another one to specify the maximum. We can already initialize them to their default values of respectively <code class="literal">1</code> and <code class="literal">3</code>:</p><pre class="programlisting">    public float minShootingTime = 1f; 
    public float maxShootingTime = 3f; </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec85"></a>Modifying the movement</h3></div></div></div><p>Whereas the player controls the movement of the spaceship, the enemy controller has to do this autonomously.</p><p>Since the enemy moves in the two directions in two different ways, we need to implement both the movements. Along <code class="literal">y</code> is easy, since we are going to implement once more the usual equation of the motion, which is:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/387a07df-eea2-464a-9eba-866655730347.png" /></div><p>Moreover, we don't need to take care of the input of the player, so along <code class="literal">y</code> the code within the <code class="literal">FixedUpdate()</code> function becomes:</p><pre class="programlisting">        var y = transform.position.y + Time.deltaTime * speedY; </pre><p>However, when it comes to the x-axis, we have to implement something different. The enemy will keep moving left and right. In order to achieve such behavior, we can use the mathematical sine function. As a result, the equation we are going to implement is the following:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/0088ac1c-5bfb-4d9d-b393-5409c83563f2.png" /></div><p>Where <span class="emphasis"><em>A</em></span> is the amplitude of the movement. In our case, we can delegate the amplitude to the <code class="literal">boundX</code> variable that we have from the player controller. Later, by setting the same value of this variable for enemies and player, we can ensure that both have the same limits along the x-axis. In terms of code, the equation is translated with the following line:</p><pre class="programlisting">        var x = boundX * Mathf.Sin(Time.deltaTime * speedX); </pre><p>Lastly, we need to remove to clamp, since the sinus (by varying only between <code class="literal">-1</code> to <code class="literal">1</code>) will ensure we won't have any value greater than <code class="literal">boundX</code> or smaller than negative <code class="literal">boundX</code>.</p><p>The full code for the movement in the <code class="literal">FixedUpdate()</code> function is the following:</p><pre class="programlisting">    void FixedUpdate() { 
        //Get the new position of our Enemy. On X, move left and right; on Y slowly get down. 
        var x = boundX * Mathf.Sin(Time.deltaTime * speedX); 
        var y = transform.position.y + Time.deltaTime * speedY; 
 
        //Set the position of our character through the RigidBody2D component (since we are using physics) 
        rigidBody.MovePosition(new Vector2(x, y)); 
 
        // [...] 
    } </pre><p>Now, it's time to jump onto making our enemy deadly, by making it shoot bullets.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec86"></a>Shooting deadly bullets</h3></div></div></div><p>Just as, for the player controller, we don't have the bullet prefab yet, but we do have a variable where the bullet prefab will be stored. This is great, but so far our code makes the enemy shoot at the same time as the player; instead, we would like the enemy to be autonomous. In order to achieve this, we need to change the code. The simplest implementation is that the enemy shoots a bullet after a random amount of time, for instance varying from one to three seconds. These two values are stored in the <code class="literal">minShootingTime</code> and <code class="literal">maxShootingTime</code> variables.</p><p>Thus, let's remove the check of the input of the player, but keep the check on the reload time. Then, inside the if statements, we need to also reset the reload time to a random value between <code class="literal">minShootingTime</code> and <code class="literal">maxShootingTime</code>. We can do this with a built-in class of Unity called <code class="literal">Random</code>, which does exactly this with the <code class="literal">Range()</code> function. As a result, the enemy will shoot every time the reload time has expired, and the reload time changes every time it shoots. The code now looks like the following:</p><pre class="programlisting">    void FixedUpdate() { 
        // [...] 
        // Fire as soon as the reload time is expired 
        if(Time.time - lastTimeShot &gt; reloadTime) { 
            //Set the current time as the last time the spaceship has fired 
            lastTimeShot = Time.time; 
 
<span class="strong"><strong>            //Set a random reload time 
            reloadTime = Random.Range(minShootingTime, maxShootingTime);</strong></span> 
 
            //Create the bullet 
            Instantiate(bulletPrefab, transform.position, Quaternion.identity); 
        } 
    } </pre><p>And with this said, congratulations. You have now finished implementing the enemy controller, at least for this chapter; in the next one, we will change it slightly.</p></div></div>