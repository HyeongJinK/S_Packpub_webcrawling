<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec66"></a>Spawning system</h2></div></div><hr /></div><p>If we place an enemy and the player against each other, the fight is interesting. But, after the player has defeated the enemies, the game becomes infinitely boring. As such, you should create a spawning system that allows you to generate waves of enemies. Also, the spawning system should be able to generate power-ups and background decoration at random. This is, in general, is not an easy task. As a result, here we will implement a simple spawning system and explore the concept of coroutines. However, I suggest you read <span class="emphasis"><em>Chapter 7, Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay Programming</em></span>, of <span class="emphasis"><em>Getting Started with Unity 5.x 2D Game Development</em></span> (<a class="ulink" href="https://www.packtpub.com/game-development/getting-started-unity-5x-2d-game-development" target="_blank">https://www.packtpub.com/game-development/getting-started-unity-5x-2d-game-development</a>). In particular, the section titled <span class="emphasis"><em>Panda invasion - spawning pandas</em></span>, which explains coroutines in more detail, and how to create a good and simple spawning system.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec97"></a>Coroutines</h3></div></div></div><p>Coroutines are a special structure in Unity that allows functions to be interrupted and continued in other frames of the game. In the case of our spawning system, we don't want to spawn all the enemies or decorations at the same time, but a little at a time. This, over time, can be controlled with coroutines. You can learn more and see some examples in the official documentation at <a class="ulink" href="https://docs.unity3d.com/Manual/Coroutines.html" target="_blank">https://docs.unity3d.com/Manual/Coroutines.html.</a></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec98"></a>Creating spawning points</h3></div></div></div><p>The basic idea behind a spawning system is that there are special points in which things are spawned. In scrolling games, such as this one, the spawning points are just beyond the visible part of the screen, so the player doesn't see the enemy or the decoration popping out of nowhere.</p><p>In Unity, the best things we can use to represent these points are just empty game objects, which we can place just above the camera, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/e195927c-d576-4d8a-9620-f37ca6b4f6b2.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p>Usually, it's hard to see empty game objects, because you need to select them. However, if you click on the icon next to their name in the <strong class="userinput"><code>Inspector</code></strong>, you can choose a label color. As a result, their name appears on the <strong class="userinput"><code>Scene</code></strong> view, and it is easy to identify them. The preceding screenshot shows exactly this process. Also, from there, you can deduce the name. </p></div><p>As you can see, we have created three spawning points for enemies just above the border of our camera and five spawning points for our decorations that are further away. Because they might be big objects and we want them to appear out of nowhere, you should check that in those points, the object is not visible on the camera.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip36"></a>Note</h3><p>As a pro-tip, you can move the pivot point of such big objects so that when they are in those positions, they are not visible. As a result, you will be able to use closer spawning points; if not, use the same of the enemies if you wish. </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec99"></a>Scripting the spawning system</h3></div></div></div><p>Now that we have our points, it's time to create a script to handle the spawning. In this case, we will spawn random enemies after a random amount of time. Same for the decorations, but they will be on a different coroutine.</p><p>Create the script and name it <code class="literal">SpawningSystem</code>. First of all, we need two arrays to store the two different spawning points. We can store them as transforms so that we can easily retrieve their position. Of course, these should be set manually from the <strong class="userinput"><code>Inspector</code></strong> by designers, since this might depend on the different levels you want to implement:</p><pre class="programlisting">    public Transform[] enemiesSpawningPoints; 
    public Transform[] decorationSpawningPoints; </pre><p>Then, we need two arrays for storing all the prefabs that we would like to randomly spawn. This goes both for decorations and enemies:</p><pre class="programlisting">    public GameObject[] enemies; 
    public GameObject[] decorations; </pre><p>Then, we need to implement the two coroutines; they are very similar (which, if you want, to challenge yourself, you can transform the coroutines by adding parameters). Let's start with the enemies one. First, we need a loop that spawns a random enemy in a random spawning point. Then, we need to set a random timer before spawning again:</p><pre class="programlisting">    IEnumerator SpawnEnemies() { 
        //Forever... 
        while (true) { 
            //...spawn a random enemy in a random location 
            Instantiate(enemies[Random.Range(0, enemies.Length)],enemiesSpawningPoints[Random.Range(0, 
            enemiesSpawningPoints.Length)].position, Quaternion.identity); 
 
            //Set a random ammount of time between 8 and 16 seconds before to spawn another enemy 
            yield return new WaitForSeconds(Random.Range(8, 16)); 
        } 
    } </pre><p>It's similar with the decorations, but with decorations rather than enemies:</p><pre class="programlisting">IEnumerator SpawnDecorations() {
    //Forever...
    while (true) {
        //...spawn a random decoration in a random location
        Instantiate(decorations[Random.Range(0, decorations.Length)],                 
        decorationSpawningPoints[Random.Range(0, decorationSpawningPoints.Length)].position, 
        Quaternion.identity);
        //Set a random amout of time between 4 and 9 before to spawn another enemy
        yield return new WaitForSeconds(Random.Range(4, 9));
    }
}</pre><p>Lastly, we need to start these two coroutines at the <code class="literal">Start()</code> function, so you can write:</p><pre class="programlisting">void Start () {
    //Start the two coroutines
    StartCoroutine(SpawnEnemies());
    StartCoroutine(SpawnDecorations());
}</pre><p>Save the script, create a new game object named <code class="literal">SpawningSystem</code>, and attach this script to it. Set all the variables in the <strong class="userinput"><code>Inspector</code></strong>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/f5363c0e-0f18-4f52-816f-29ceb00f48ec.png" /></div><p>Of course, this is not the best solution for a spawning system, but at least you can get your feet wet with coroutines. Once again, you are free to experiment to improve on what this book teaches you because that is where the real improvement happens.</p></div></div>