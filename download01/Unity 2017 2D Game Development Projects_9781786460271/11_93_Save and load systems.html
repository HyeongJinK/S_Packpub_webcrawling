<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec91"></a>Save and load systems</h2></div></div><hr /></div><p>What is a game if it doesn’t have a save and load system? It would be a nightmare... well, for some.</p><p>It is essential that in games which require you to progress through levels that gradually increase in difficulty, you have an option to save—unless, of course, you're a masochist and/or enjoy putting your players through the perils of permadeath and starting over. Then, by all means, skip this section.</p><p>There are different reasons, and consequently, ways with which you can implement a save option for players. For example, your game may allow a player to save any time and anywhere. Games like <span class="emphasis"><em>Tomb Raider II</em></span> and <span class="emphasis"><em>Abe's Oddysee</em></span> offer such approaches to saving. Typically, this option is provided via the pause menu, and the player is allocated a set number of slots that they can use to save. Alternatively, you may also have checkpoints that automatically save at specific locations, such as before and/or after an important event during gameplay. Games like <span class="emphasis"><em>Army of Two</em></span> offer this to players. Other options can include specific locations or save points that a player can save, which are like checkpoints, located at specific points that a player will reach within the environment during gameplay. Games like <span class="emphasis"><em>Final Fantasy X</em></span> offer this, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/914007a1-c819-47bd-8677-136022c134e7.png" /></div><p>Save Orb is located on the right-hand side of the screenshot taken during gameplay of Final Fantasy X</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec108"></a>Creating a save/load system in Unity</h3></div></div></div><p>There are different ways to save and load your game in Unity. For instance, you can encode your data into a file, and this gives you maximum freedom. In fact, you can allow players to save on your server, encrypt the file, and decide exactly how this file is structured. However, for beginners, this might not be the easiest approach, since Unity already offers a basic save system called <span class="strong"><strong>PlayerPrefs</strong></span>. This system is great because it supports all the platforms, meaning you won't have to change code depending on which platform (Computer, Android, and more) you are going to ship in. Also, the system is very intuitive. With this said, let's dive into it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec48"></a>PlayerPrefs</h4></div></div></div><p>PlayerPrefs, as the name suggests, has been created with the purpose to save and store the player's preferences. In fact, this data is not sensitive, meaning that if the player can change those externally from the game, it’s not a big deal. As a result, PlayerPrefs is very simple, and it works with a key-value system. However, often it is used to store game data as well, due to its simplicity and the built-in support in Unity. Although you can extend their functionalities with some plugins that you find in the Asset Store (for example, in order to encrypt the data), I suggest using a custom save/load system if you are planning to ship the game.</p><p>PlayerPrefs is useful also to debug functionalities when the save/load system is under construction, or just to store (as they are meant to be) your player preferences.</p><p>How do they work in practice? You can imagine that each PlayerPrefs is a pair containing a key, which has to be unique across all the PlayerPrefs, and a value. While the key is always a string, the value can be of different types. In particular, the basic types that Unity supports are:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Integers (<code class="literal">int</code>)</li><li style="list-style-type: disc">Decimal numbers (<code class="literal">float</code>)</li><li style="list-style-type: disc">Strings (<code class="literal">string</code>)</li></ul></div><p>However, these types can be extended with wrappers around these basic types. For instance, a Vector3 can be stored as three PlayerPrefs, one for each axis. The wrapper then creates three keys by appending to the passed key a suffix indicating the axis. In any case, we will stick to these basic types, which are more than enough for what we need. Here are some examples of possible key-value pairs, and in brackets, the type of the value:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">&lt;Score, 10&gt;</code> (<code class="literal">int</code>)</li><li style="list-style-type: disc"><code class="literal">&lt;Time, 12,5&gt;</code> (<code class="literal">float</code>)</li><li style="list-style-type: disc"><code class="literal">&lt;PlayerName, "John"&gt;</code> (<code class="literal">string</code>)</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec49"></a>PlayerPrefs functions</h4></div></div></div><p>From a code point of view, there are functions that allow us to interact with the system. They are all within the <code class="literal">PlayerPrefs</code> class, and they are static functions, so you don't need to instantiate a <code class="literal">PlayerPref</code> object. Rather, in your code, type PlayerPrefs followed by the name of the function you want to call: <code class="literal">PlayerPrefs.NameOfTheFunction()</code>. Obviously, the previous function doesn’t exist, but it was an example of a function call.</p><p>Since these functions are not so many, let's see them all. The following three functions (one for each value type) set the pair <code class="literal">&lt;key, value&gt;</code>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">void SetInt(string key, int value)</code>: Stores (or overrides, in case it already exists) an integer value type associated with the key</li><li style="list-style-type: disc"><code class="literal">void SetFloat(string key, float value)</code>: Stores (or overrides, in case it already exists) a decimal number value type associated with the key</li><li style="list-style-type: disc"><code class="literal">void SetString(string key, string value)</code>: Stores (or overrides, in case it already exists) a string value type associated with the key</li></ul></div><p>Similar to the preceding three functions, we have the three twin functions that instead of storing, retrieve the values based on the key. Keep in mind that if the key doesn't exist, they return the default value of the type:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">int GetInt(string key)</code>: Retrieves (if it exists) the integer value associated with the key passed as a parameter</li><li style="list-style-type: disc"><code class="literal">float GetFloat(string key)</code>: Retrieves (if it exists) the decimal number value associated with the key passed as a parameter</li><li style="list-style-type: disc"><code class="literal">string GetString(string key)</code>: Retrieves (if it exists) the string value associated with the key passed as a parameter</li></ul></div><p>Since we have said that the value might not exist, we have a function to check whether a specific key has an association within a pair:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">bool HasKey(string key)</code>: Returns a Boolean, indicating whether the key passed as the parameter exists or not</li></ul></div><p>Finally, here are a couple of functions to delete the pairs of values:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">void DeleteKey(string key)</code>: Deletes (if it exists) the pair with the key specified as the parameter</li><li style="list-style-type: disc"><code class="literal">void DeleteAll()</code>: Erases all the <code class="literal">&lt;key, value&gt;</code> pairs, thus erasing all the saved data</li></ul></div><p>There is also a special function that forces the saving of memory. In fact, when we use a set, the save happens only within the context of the application/game, thus improving performance. Although when you close the game, Unity flushes everything in memory and thus saves. However, sometimes you want to force this process to happen before the game is closed (maybe after have saved important data, for example). This can be done with the following function:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">void Save()</code>: Saves all the <code class="literal">&lt;key, value&gt;</code> pairs into the permanent memory</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec50"></a>Variables to save in RETROformer</h4></div></div></div><p>When you think about a save/load system, you want to save the variables that describe the player's progress or the game world state. In general, this might not be an easy step.</p><p>In the case of RETROformer, let's list what we would like to store to <span class="emphasis"><em>save</em></span> the game. First of all, we may want to store the level (in case we have implemented more than one level), as well as the player's location in the world. Moreover, we want to save the score, and the time elapsed since the game started. This last piece of information is useful for players to understand how long they have been playing the game. Here is an example of saved games that contain the time elapsed (taken from <span class="emphasis"><em>Horizon Zero Dawn</em></span> for PS4):</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/a5644ca3-6ee2-4fc6-b386-c778381e2054.jpg" /></div><p>So, let's recap the variables we want to store for our game, and associate to each one of them a type:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Level</strong></span>: We can store the level either as a string or as an integer. For simplicity's sake, we will go for the integer.</li><li style="list-style-type: disc"><span class="strong"><strong>Position</strong></span>: We cannot store this as a single PlayerPref, thus we will need two <code class="literal">&lt;key, value&gt;</code> pairs, one for each axis, both of type float.</li><li style="list-style-type: disc"><span class="strong"><strong>Time Elapsed</strong></span> so far: Clearly, this is a float type.</li><li style="list-style-type: disc"><span class="strong"><strong>Score</strong></span>: This depends on how you implement the score. If you followed the scoring system made for the other two projects, then the score will be an integer type.</li><li style="list-style-type: disc"><span class="strong"><strong>Player's name</strong></span>: This is a string, so we can showcase the use of this type as well.</li></ul></div><p>Finally, we need to assign a unique key to each of these values, and then we will be ready to go. For the association, let's have a look to the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>What</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Key</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Value Type</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Last level the player has played</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Level</p></td><td style="border-bottom: 0.5pt solid ; "><p>Integer</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Last position of the player along the x-axis</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PositionX</p></td><td style="border-bottom: 0.5pt solid ; "><p>Float</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Last position of the player along the y-axis</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PositionY</p></td><td style="border-bottom: 0.5pt solid ; "><p>Float</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Time elapsed since the beginning of the game</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Time</p></td><td style="border-bottom: 0.5pt solid ; "><p>Float</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The score that the player has reached</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Score</p></td><td style="border-bottom: 0.5pt solid ; "><p>Integer</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>The player's name</p></td><td style="border-right: 0.5pt solid ; "><p>PlayerName</p></td><td style=""><p>String</p></td></tr></tbody></table></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec109"></a>Building the save/load system for our game</h3></div></div></div><p>In order to integrate the save/load system, we need to create a static class that will take care of saving and loading for us. Here, we need to take an important decision: whether this class will retrieve the information that it requires to save (such as level, score, and so on), or whether we pass them as parameters and rely on other scripts to do that.</p><p>In our case, we have a simple game so we can choose either. As a rule of thumb, you want to decouple the save system as much as possible. However, you should still have a central script that manages to do the saving, such as the <span class="strong"><strong>GameManager</strong></span>, which is responsible for retrieving all the data needed for saving. Thus, we will go in passing as parameters the data to our save/load script, even if the system we are going to build is not generic but specific to our game. In particular, we will create a struct within the save/load script, which will hold the data to save. As a result, it will be easier to pass data as well as return it back, and you will have a chance to learn something new.</p><p>Furthermore, since we want our save/load system to support different save slots, we can add in front of any key (a prefix) the name of the slot in which the player wants to save. If you let the player decide the slot name, then you should also include the name of the slot in the save data. Otherwise, if the player can choose between just a finite set of slots, such as three, then the GameManager can handle this information based on which slot the player has clicked on the UI. Of course, this part will be left as an exercise since this chapter will focus only on the save/load system. However, later in the chapter, some suggestions are given to enhance the gameplay of this last game. Lastly, some hits are provided on where to use this system.</p><p>Let’s start by creating a new C# Script and name it <code class="literal">SaveLoadSystem</code>, and you can remove the inheritance from MonoBehaviour and set is as static class since it will contain only static methods. First of all, we need to create the <code class="literal">struct</code>, so below the last <code class="literal">}</code>, we need to add the following struct:</p><pre class="programlisting">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public static class SaveLoadSystem {
                //[...]
}

public struct SavingData {

    public int level;
    public float positionX, positionY;
    public int score;
    public float timeElapsed;
    public string playerName;

}</pre><p>A <code class="literal">struct</code> is not much different than a class in C#, and this struct doesn't have any methods, just the data fields we have seen in the previous table.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>Although it's good practice to have a class and a struct per file, here, due to the very simple structure and the dependency with the main class of the file, we chose to keep it within the same file. </p></div><p>Now, we can start writing our script. In particular, we need two functions: one to save and another one to load. Let's start with the first one.</p><p>The <code class="literal">Save()</code> function will receive a <code class="literal">SavingData</code> structure as a parameter, as well as the string denoting the save slot. The function goes through all the data in the structure, builds new keys based on the save slot string, and sets all the data within PlayerPrefs. At the end, it calls the <code class="literal">Save()</code> function to actually save all the data on the permanent memory (for example, the hard drive):</p><pre class="programlisting">public static void Save(string slotKey, SavingData data) {
        //Save into PlayerPrefs for each data item within the SavingData structure
        PlayerPrefs.SetInt(slotKey + "_level", data.level);
        PlayerPrefs.SetFloat(slotKey + "_positionX", data.positionX);
        PlayerPrefs.SetFloat(slotKey + "_positionY", data.positionY);
        PlayerPrefs.SetInt(slotKey + "_score", data.score);
        PlayerPrefs.SetFloat(slotKey + "_time", data.timeElapsed);
        PlayerPrefs.SetString(slotKey + "_playerName", data.playerName);

        //Save into permanent memory
        PlayerPrefs.Save();
    }</pre><p>On the other hand, we have the <code class="literal">Load()</code> function, which gives back a <code class="literal">SavingData</code> structure and takes as input the save slot key. As a result, the function is able to query the <code class="literal">PlayerPrefs</code> with the get-functions and store all the data within a newly created <code class="literal">SavingData</code> structure. At the end, it just returns the structure:</p><pre class="programlisting">public static SavingData Load(string slotKey) {
        //Create a new SavingData structure
        SavingData data = new SavingData();

        //Load from memory each item to fill up the data structure
        data.level = PlayerPrefs.GetInt(slotKey + "_level");
        data.positionX = PlayerPrefs.GetFloat(slotKey + "_positionX");
        data.positionY = PlayerPrefs.GetFloat(slotKey + "_positionY");
        data.score = PlayerPrefs.GetInt(slotKey + "_score");
        data.timeElapsed = PlayerPrefs.GetFloat(slotKey + "_time");
        data.playerName = PlayerPrefs.GetString(slotKey + "_playerName");

        //return the data structure
        return data;
    }</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec110"></a>Refining the save and load system</h3></div></div></div><p>If you want to be more sophisticated with your save and load system, then you will need three more functions.</p><p>The first one checks whether a save slot is available in the memory or not. Although you can implement this functionality within the load function (for example, returning null), for the sake of simplicity, we will create a separate function that returns a Boolean indicating whether the slot is available or not. This is useful when you need to show to the player which slots are empty or which ones are taken. The function is really simple, it just needs to check whether the key passed as a parameter exists. We can do this by checking only one of the data, which we have prefixed with the key.. In fact, if we do things right, we should have incomplete saving slots in which just partial information is available. Thus, here is the function:</p><pre class="programlisting">   public static bool HasSlot(string slotKey) {
        //Check whether the slotkey exist
        return PlayerPrefs.HasKey(slotKey + "_level");
    }</pre><p>Another useful function deletes a specific save slot. This can be done by taking in input the key and erasing all the items related to that slot. Here, you need to be sure to erase them all, especially if you don't want to have a problem with the function <code class="literal">HasSlot()</code>:</p><pre class="programlisting">   public static void DeleteSlot(string slotKey) {
        //Delete the whole slot, item by item
        PlayerPrefs.DeleteKey(slotKey + "_level");
        PlayerPrefs.DeleteKey(slotKey + "_positionX");
        PlayerPrefs.DeleteKey(slotKey + "_positionY");
        PlayerPrefs.DeleteKey(slotKey + "_score");
        PlayerPrefs.DeleteKey(slotKey + "_time");
        PlayerPrefs.DeleteKey(slotKey + "_playerName");
    }</pre><p>Finally, a function that clears all the slots might be useful. In this case, the only things you save with PlayerPrefs are the slots. Therefore, we can easily use <code class="literal">DeleteAll()</code>, as we are about to do. Otherwise, you need a loop that calls the <code class="literal">DeleteSlot()</code> function on each one of the slots. In our case, the function is just a wrapper for the <code class="literal">DeleteAll()</code> function:</p><pre class="programlisting">   public static void DeleteAllSlots() {
        //Delete all the PlayerPrefs
        PlayerPrefs.DeleteAll();
    }</pre><p>Save the script and congratulate yourself, since now you have a working save and load system.</p></div></div>