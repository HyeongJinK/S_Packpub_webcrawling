<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec60"></a>Exercises</h2></div></div><hr /></div><p>We are halfway through the project, but it's time to improve our skills. Now, you will have learned the basics of creating a simple AI in Unity. I encourage you to experiment with the AI. Here, there is a series of exercises you can do before moving on to the next chapter. I invite you to try to do at least the first two:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">We have seen how to create just one enemy and one kind of bullet. You are free to experiment with the values (such as <code class="literal">speed</code>, <code class="literal">minShootingTime</code>, <code class="literal">maxShootingTime</code> or <code class="literal">shootingSensitivity</code>) and create a different prefab for each one of them. In the next chapter, we will see how to create the single prefabs of the controllers of this chapter. However, you can get a head start and try to do them now. The package offers different spaceships with different colors, so just have fun experimenting.</li><li style="list-style-type: disc">The two enemies we have created are great, and by customizing variables we are able to create quite a variety of enemies. However, you are free to experiment in creating a more complex enemy, maybe a boss. Write down on paper how your boss should behave, where it moves (maybe it can go up and down), how and when it shoots (maybe she/he shoots from two different parts of the big spaceship, making it more challenging for the player). Don't forget to give a nice graphic to your boss and share your results with us.</li><li style="list-style-type: disc">The bullet detects the <code class="literal">PlayerController</code> and the <code class="literal">EnemyController</code>. However, it doesn't take into consideration that there might be other kinds of objects and/or controllers. In fact, we have <code class="literal">EnemyController2</code>, and in the next chapter you might implement code for asteroids, planets, and so on, that can explode when hit. Try to fix this problem on your own by figuring out a solution that could work. It doesn't have to be complicated, you can try to do the different casting to the different classes to call the <code class="literal">Hit()</code> function.</li><li style="list-style-type: disc">If you are in the mood for a challenge and know a bit about interfaces in C#, then we can implement the previous exercise in a much smarter way. Create an interface called <code class="literal">CanExplode</code>, in which we have the definition of just one function: <code class="literal">Hit()</code>. Then, for each controller we have created in this chapter (such as <code class="literal">PlayerController</code>, <code class="literal">EnemyController</code>, and <code class="literal">EnemyController2</code>) and any other class that needs to explode on impact, we will need to implement such an interface. This allows you to have just a few lines of code in the <code class="literal">BulletScript</code> at the price of just implementing an interface.
</li><li style="list-style-type: disc">If your thirst for a challenge isn't quenched after the previous exercise, you can notice that all the controllers share a good portion of the code in common. If you know about inheritance in C#, you can create a master <code class="literal">Controller</code> class, from which all the other controllers derive. There, implement all the code that they share in common, and leave in the specific class just the code required to distinguish that class from the others.</li></ul></div></div>