<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec32"></a>Assembling the Angel</h2></div></div><hr /></div><p>First, we need to create a new Sprite, and assign as Graphics "ACSpriteEvo1." We can rename the new Game Object as <code class="literal">Player</code>.</p><p>Then, we need to attach a collider to our Player character. This is a component, which allows the character to have a physical shape. Since we want our character to have a circular shape, we need to attach a <code class="literal">CircleCollider2D</code>. In the scene view, you should see a green circle around our character, and the default one should be good to go. In case you would like to tweak the dimensions of the green circle to encapsulate your character in a different way, you are free to change the <strong class="userinput"><code>Radius</code></strong> setting, along with the <strong class="userinput"><code>Offset</code></strong> one, if you need to translate the circle from the pivot point.</p><p>Another component we need is <code class="literal">Rigidbody</code>, which is a component that tells Unity that this object is subject to the Physics engine. Since we are building a 2D game, we need to use <code class="literal">RigidBody2D</code>. Once placed on the character, we need to make two important changes, which are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We need to disable gravity, since our game is top-down, and therefore there is no gravity. To do so, you need to set the <strong class="userinput"><code>Gravity Scale</code></strong> to zero.</li><li>We don't want our character to rotate due to collisions, so we need to freeze rotation in the z-axis. There is a checkbox under the constraints drop-down. Here is a screenshot of how the component should look in the end:</li></ol></div><div class="mediaobject"><img src="/graphics/9781786460271/graphics/99ff1ea9-b6e4-4dc9-ab09-8c61da7786e4.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec35"></a>Tagging the player</h3></div></div></div><p>Later, we will start implementing the collecting system, but first we need to distinguish the <strong class="userinput"><code>Player</code></strong> from other objects. One way to do it is to assign a <strong class="userinput"><code>Tag</code></strong>. When you install Unity, it comes preloaded with a set of default tags. However, if you want to add your own (custom) tags, you can do it by navigating to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Tags and Layers</code></strong>, like in the following menu:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/7a56b07e-23f4-453e-a065-0dc8285fba12.png" /></div><p>In our specific case, we can select the <strong class="userinput"><code>Player</code></strong>, and just beneath the name we can set <strong class="userinput"><code>Player</code></strong> as a tag, which is a default tag, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/c95b39fd-b811-42bc-af12-a39270752a91.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec36"></a>Creating the Script</h3></div></div></div><p>Now, we are good to go to start writing some scripts. This is the first script of this book, and since it's a book with examples, we will jump straight into one, and learn how to code by deconstructing what we are doing. Don't be scared if it is not clear to you at the beginning, because it might be hard if it's the first time you see the code. Don't give up; being able to code is worth the effort.</p><p>To create a Script, we need to create a new folder, called <code class="literal">Scripts</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/57058a5e-9bbc-41a7-8c4a-2f0502c1e4fa.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Inside the folder, right-click and then <strong class="userinput"><code><span class="strong"><strong>Create|</strong></span></code></strong><strong class="userinput"><code>C# Script (Alternatively using the top-menu Assets|Create|C# Script )</code></strong></li><li>Rename the script to <code class="literal">PlayerController</code><span class="emphasis"><em><span class="strong"><strong> </strong></span></em></span>so we will always know later what the script is supposed to do</li><li>The script can be used as a component, meaning that it can be attached to a <span>GameObject</span></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"></a>Note</h3><p>As we have seen in the previous chapter, not all the scripts are components. For instance, Editor scripts are not components, and in general, every script that does not derive from <span class="strong"><strong>MonoBehavior</strong></span> is not a component.</p></div><p>So, let's drag it onto our character GameObject, and it will appear in the <strong class="userinput"><code>Inspector</code></strong>, like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/8e448248-0dc0-4108-aac2-85ec2b9aad7f.png" /></div><p>If you double-click the <strong class="userinput"><code>Script</code></strong> component, an editor will open depending on your preferences in the settings. The default is MonoDevelop, but also Visual Studio (<a class="ulink" href="http://www.visualstudio.com" target="_blank">www.visualstudio.com</a>) is excellent.</p><p>Once opened, this is how the script looks:</p><pre class="programlisting">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerController : MonoBehaviour {

  // Use this for initialization
  void Start () {

  }

  // Update is called once per frame
  void Update () {

  }
}</pre><p>At the beginning, there are three lines that allow us to use libraries. At this stage, we won't touch them.</p><p>Then, there is the class definition, in this case, named <code class="literal">PlayerController</code>. Inside it, there are two functions: <code class="literal">Start()</code> and <code class="literal">Update()</code>. The first is called every time this script starts, whereas the second is called at every frame. You can explore the whole execution order of the different functions and scripts by following this link: <a class="ulink" href="https://docs.unity3d.com/Manual/ExecutionOrder.html" target="_blank">https://docs.unity3d.com/Manual/ExecutionOrder.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec37"></a>Enforcing components</h3></div></div></div><p>Since we need to use this script along with the collider and the <code class="literal">RigidBody</code> we have attached before on our player, we need to enforce this by saying that every time we use this script, the object on which this script is attached must have a collider and a <code class="literal">RigidBody</code>. As a result, we won't wrongly use this script without those components.</p><p>We can achieve this by adding two lines of code above the class definition, as highlighted here:</p><pre class="programlisting">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

<span class="strong"><strong>[RequireComponent(typeof(Rigidbody2D))]</strong></span>
<span class="strong"><strong>[RequireComponent(typeof(CircleCollider2D))]</strong></span>
public class PlayerController : MonoBehaviour {
  //[…]
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"></a>Note</h3><p>If you want to do a more general script, you can have Collider2D instead of CircleCollider2D. As a result, you will be able to use any collider, but then you need to remember which one is the right collider for the character you want to use.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec38"></a>Exposing variables in the inspector</h3></div></div></div><p>When in Unity, we attach components to our GameObject, there are some parameters (or variables) that designers can adjust. We would like to adjust the speed of our character from the <strong class="userinput"><code>Inspector</code></strong>. In this case, we will use a float, so decimal values can also be used.
The easiest way to expose a variable in the <strong class="userinput"><code>Inspector</code></strong> (there are other ways, but for now we won't see them) is to declare a variable public. Optionally, you can assign a value, which will be the default one in the Inspector. So just inside the class, we can add the following highlighted line:</p><pre class="programlisting">//[…]
public class PlayerController : MonoBehaviour {

<span class="strong"><strong>    public float speed = 10.0f;</strong></span>

   //[…]
}</pre><p>As a result, if we go back in Unity, and see our character, we will see that now the speed is exposed in the <strong class="userinput"><code>Inspector</code></strong>, as shown here:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/86db1f63-098a-4108-ba48-c64cb564ef7b.png" /></div><p>We get a reference to the <code class="literal">Rigidbody</code>, so we can use it to move the character. Sometimes during the execution of the script, we need to reference some other components that are attached to the object. The <code class="literal">Start()</code> function is a perfect place for this purpose. In fact, now, we need to retrieve the Rigidbody component. To do so, let's declare a variable, this time private since we don't need to expose it to the <strong class="userinput"><code>Inspector</code></strong>, as shown here:</p><pre class="programlisting">//[…]
public class PlayerController : MonoBehaviour {

    public float speed = 10.0f;

    private Rigidbody2D rigidBody;

   //[…]
}</pre><p>Next, we need to assign the <code class="literal">rigidbody</code> of the character within the variable. So, inside the <code class="literal">Start()</code> function we can use the <code class="literal">GetComponent()</code> function to retrieve the <code class="literal">RigidBody2D</code> instance that is attached to the same game object this script is attached to, in the following way:</p><pre class="programlisting">void Start() {
<span class="strong"><strong>        rigidBody = GetComponent&lt;Rigidbody2D&gt;();</strong></span>
    }</pre><p>Please note that we don't do any check of the validity of <code class="literal">Rigidbody</code> (if it exists), because at the beginning of the script we have enforced that <code class="literal">Rigidbody</code> must exist to use this script. As a result, we can avoid checking the validity of the variable (null-check), since we know <code class="literal">Rigidbody</code> will always exist.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec39"></a>From the player input to a new position in the world</h3></div></div></div><p>Every time the player presses a key on the keyboard, or use the thumbstick on a controller, we need to retrieve this input. Then, we need to elaborate it so that we can calculate the next position of our character after a frame.</p><p>Since it's a calculation we need to do for every frame, it's reasonable to do it in the <code class="literal">Update()</code> function. However, since we are going to use physics, we need to use a similar function, called <code class="literal">FixedUpdate()</code>. So, let's rename Update to <code class="literal">FixedUpdate()</code>, as the following:</p><pre class="programlisting">void FixedUpdate () {

    }</pre><p>To retrieve the player input, we can use the default key mapping in Unity.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>In case you would like to change this mapping, you can do it by clicking the top bar and then <strong class="userinput"><code>Edit</code></strong><span class="strong"><strong> | </strong></span><strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Input</code></strong>.</p></div><p>In particular, we can use the <code class="literal">Input.GetAxis()</code> function, and using as a parameter a string with the name of the axis. In our case, we have the <span class="emphasis"><em>Horizontal </em></span>and the <span class="emphasis"><em>Vertical</em></span> axis. These are values that range from -1 to 1 depending on how tilted the thumbstick is (or, in the case of a keyboard, they can just be -1, 0, and 1). Thus, we need to multiply these values by the speed variable, and then multiply it by the <code class="literal">Time.deltaTime</code>, which is the time since the last frame. Finally, we need to add the current position of the character with transform.position and the corresponding axis. It sounds complicated, but it's not once the code is written down. For those of you who are familiar with equations, this is what we will be using:</p><div class="mediaobject"><img src="/graphics/9781786460271/graphics/f4560d36-e4fd-47f9-9a64-bed9523aa026.png" /></div><p>So, finally here is the code, in which we do the same operation once for the x-axis and again for the y-axis, and store values within variables:</p><pre class="programlisting">  void FixedUpdate () {
        //Get the new position of our character
        var x = transform.position.x + Input.GetAxis("Horizontal") * Time.deltaTime * speed;
        var y = transform.position.y + Input.GetAxis("Vertical") * Time.deltaTime * speed;
    }</pre></div></div>