<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec44"></a>Improving the AI using breadcrumbing</h2></div></div><hr /></div><p>In this <a id="id517" class="indexterm"></a>section, we will improve the AI for the <a id="id518" class="indexterm"></a>enemies by implementing an effective, yet simple, technique called breadcrumbing. At present, while the enemies follow the player when he/she is in sight, they may stop progressing toward the player when they lose sight of the player. To add more realism, we will design an improved AI behavior whereby enemies are able to go back to their initial location after losing sight of the player, or follow the player, despite not seeing him/her. To do so, we ensure that the zombie is dropping crumbs while progressing toward the player, and that it then follows the breadcrumbs to find its way back to its initial position when it has lost sight of the player.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec16"></a>Allowing enemies to throw and follow their own breadcrumbs</h3></div></div></div><p>First, <a id="id519" class="indexterm"></a>let's modify <a id="id520" class="indexterm"></a>the script <code class="literal">controlZombie</code><a id="id521" class="indexterm"></a>, and add the following lines at the start of the script:</p><div class="informalexample"><pre class="programlisting">public var breadCrumb:GameObject;
private var timeForNextCrumb:float;
private var currentTime:float;
private var breadCrumbs = new Array();
private var breadCrumbIndex:int;</pre></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In line 1 of the previous code, we create a placeholder for the breadcrumb that will be dropped by the zombie</p></li><li style="list-style-type: disc"><p>In lines 2-3 of the previous code, these variables will be employed to determine the next time a breadcrumb will be dropped</p></li><li style="list-style-type: disc"><p>In line 4 of the previous code, this variable represents an array of all the breadcrumbs dropped for this zombie</p></li><li style="list-style-type: disc"><p>In line 5 of the previous code, this variable represents the current index for the breadcrumbs dropped</p></li></ul></div><p>Add the following line <a id="id522" class="indexterm"></a>of code to the function <code class="literal">Start</code> to initialize the variable <code class="literal">breadCrumbIndex</code>:</p><div class="informalexample"><pre class="programlisting">breadCrumbIndex = 0;</pre></div><p>In the function <code class="literal">Update</code><a id="id523" class="indexterm"></a>, identify the <code class="literal">switch</code> case section related to the state <code class="literal">WalkForward</code><a id="id524" class="indexterm"></a> and add the following lines of code within:</p><div class="informalexample"><pre class="programlisting">anim.SetBool("canSeePlayerWhileWalking",true);
if (Time.time &gt; timeForNextCrumb)
{
  breadCrumbIndex++;
  timeForNextCrumb = Time.time+.5;
  breadCrumbs[breadCrumbIndex] = transform.position;
  var b:GameObject  = GameObject.Instantiate(breadCrumb,transform.position, transform.rotation);
  b.name = "breadcrumb_"+ name+"_"+breadCrumbIndex;
}
if (Physics.Raycast (Vector3(transform.position.x, transform.position.y+.5, transform.position.z), transform.forward, hit, 40) &amp;&amp; hit.collider.gameObject.tag != "Player") anim.SetBool("canSeePlayerWhileWalking",false);</pre></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In<a id="id525" class="indexterm"></a> statement 1 of the previous code, we set the variable <code class="literal">canSeePlayerWhileWalking</code> to <code class="literal">true</code>.</p></li><li style="list-style-type: disc"><p>In<a id="id526" class="indexterm"></a> statement 2 of the previous code, we check whether we have reached the time to throw another breadcrumb.</p></li><li style="list-style-type: disc"><p>In statement 4 of the previous code, <code class="literal">breadCrumbIndex</code> is incremented by 1.</p></li><li style="list-style-type: disc"><p>Statement 5 of the previous code indicates the next time to throw a crumb (that is, <code class="literal">timeForNextCrumb</code>) is set to the current time, plus 500 milliseconds. Effectively, we will drop a breadcrumb every 500 milliseconds.</p></li><li style="list-style-type: disc"><p>In statement 6 of the previous code, the position of the new breadcrumb is saved (it is the same as the position of the zombie).</p></li><li style="list-style-type: disc"><p>In statement 7 of the previous code, we instantiate a new object (that is, a breadcrumb prefab that we will create in the next section) at this position.</p></li><li style="list-style-type: disc"><p>In Statement 8 of the previous code, the breadcrumb is given a name that will make it easier to identify it later on. The name includes the name of the zombie as well as an index (the name of the zombie <code class="literal">GameObject</code> is part of its properties <a id="id527" class="indexterm"></a>and is therefore accessible through any script attached to this <code class="literal">GameObject</code>). This will be useful since all zombies will use this breadcrumbing feature, and we need to make sure that each of them follows their own breadcrumb (that is, in other words, their breadcrumb if uniquely identifiable).</p></li><li style="list-style-type: disc"><p>Line 10 of the previous code shows how if the zombie loses sight of the player, the parameter <code class="literal">canSeePlayerWhileWalking</code><a id="id528" class="indexterm"></a> is set to <code class="literal">false</code>.</p></li></ul></div><p>For this script to be effective, we will need to create a breadcrumb prefab and assign it to the variable <a id="id529" class="indexterm"></a>
<code class="literal">breadCrumb</code> within the script. First, let's create a breadCrumb prefab:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new empty object by selecting <span class="strong"><strong>Game Object</strong></span> | <span class="strong"><strong>Create Empty</strong></span>.</p></li><li><p>Rename this object <code class="literal">breadCrumb</code><a id="id530" class="indexterm"></a> and set its position to (x=0, y=0, z=0).</p></li><li><p>Select the folder <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>chapter</strong></span> 6 and click once on this folder.</p></li><li><p>Create a new prefab; from <a id="id531" class="indexterm"></a>the <span class="strong"><strong>Project</strong></span> window, select: <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Prefab</strong></span>.</p></li><li><p>Rename this prefab <code class="literal">breadCrumb</code>.</p></li><li><p>Drag-and-drop the object labeled <code class="literal">breadCrumb</code> from the <span class="strong"><strong>Hierarchy</strong></span> window to this prefab.</p></li><li><p>Select the object <code class="literal">zombie_hires</code><a id="id532" class="indexterm"></a> in <span class="strong"><strong>Hierarchy</strong></span> and drag-and-drop the new prefab <code class="literal">breadCrumb</code> to the <code class="literal">breadCrumb</code> variable for <a id="id533" class="indexterm"></a>the script <code class="literal">controlZombie</code>, as described on the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695848/graphics/5848_06_1.jpg" /></div></li><li><p>Now that our breadCrumb prefab has been created, we can delete the <code class="literal">breadCrumb</code> object<a id="id534" class="indexterm"></a> from the <span class="strong"><strong>Hierarchy</strong></span> window.</p></li><li><p>Test the game, walk past the idle zombie and check that, after it starts walking, new breadcrumbs are created with a label that starts with <code class="literal">breadcrumb_zombe_hires</code>.</p></li></ol></div><p>Next, we need to create a state and the associated transition for the zombie to start following its own breadcrumbs.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Open the <span class="strong"><strong>Animator</strong></span> window<a id="id535" class="indexterm"></a>, create a new state (right-click within the window and select <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Empty</strong></span>), and rename this state <code class="literal">FollowBreadCrumbs</code>.</p></li><li><p>Drag-and-drop the animation <code class="literal">WalkForward</code> by selecting <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>chapter5</strong></span> | <span class="strong"><strong>chapter5_pack</strong></span> (the animation is within the prefab <code class="literal">Zombie@walkForward</code> and symbolized by a gray box with a white triangle) to the <code class="literal">Motion</code> property<a id="id536" class="indexterm"></a> of the state <code class="literal">FollowBreadCrumbs</code>.</p></li><li><p>Within this <a id="id537" class="indexterm"></a>window, we will create two Boolean parameters labeled <code class="literal">canSeePlayerWhileWalking</code><a id="id538" class="indexterm"></a> and <code class="literal">backToSquare1</code> as illustrated in the following <a id="id539" class="indexterm"></a>screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695848/graphics/5848_06_2.jpg" /></div></li><li><p>Create<a id="id540" class="indexterm"></a> a transition from the state <span class="strong"><strong>WalkForward</strong></span><a id="id541" class="indexterm"></a> to the state <span class="strong"><strong>FollowBreadCrumbs</strong></span>.</p></li><li><p>Select the transition between these two states and set the transition condition to <code class="literal">canSeePlayerWhileWalking = false</code>. This way, if the zombie is walking toward the player but loses sight of the player, it will start its way back to its initial position.</p></li><li><p>Create <a id="id542" class="indexterm"></a>a transition from the state <span class="strong"><strong>FollowBreadCrumbs</strong></span> to the state <span class="strong"><strong>Idle</strong></span>.</p></li><li><p>Select the transition between these two states and set the transition condition to <code class="literal">backToSquare1 = true</code>. This way, when the zombie has reached its first breadcrumb (initial position), it will transition back to the <span class="strong"><strong>Idle</strong></span> state.</p></li></ol></div><p>Next, we are going to code the breadcrumbing behavior. Add the following lines at the start of the script <code class="literal">controlZombie</code>:</p><div class="informalexample"><pre class="programlisting">Public var FollowBreadCrumbsState:int = Animator.StringToHash("Base Layer.FollowBreadCrumbs");
Public var detectedPlayersClosestCrumb:boolean = false;</pre></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In statement 1 of the previous code, the variable <code class="literal">FollowBreadCrumbsState</code> will be used to monitor the state <code class="literal">FollowBreadCrumbs</code> that <a id="id543" class="indexterm"></a>we have created in the previous section</p></li><li style="list-style-type: disc"><p>In statement 2 of the previous code, the variable is used to initialize the first breadcrumb to be followed by the zombie</p></li></ul></div><p>Add the following <a id="id544" class="indexterm"></a>code to the function <code class="literal">Update</code>:</p><div class="informalexample"><pre class="programlisting">case FollowBreadCrumbsState:
  if (breadCrumbIndex &gt;0)
  {
    anim.SetBool("backtoSquare1", false);
    var breadCrumbToFind: GameObject =      GameObject.Find("breadcrumb_"+gameObject.name+"_"+breadCrumbIndex);
    transform.LookAt(breadCrumbToFind.transform);
    var distanceToBreadCrumb:float = Vector3.Distance(gameObject.transform.position,GameObject.Find("breadcrumb_"+gameObject.name+"_"+breadCrumbIndex).transform.position);
    if ( distanceToBreadCrumb &lt; 1.0f) 
    {
       Destroy(GameObject.Find("breadcrumb_"+ name+"_"+breadCrumbIndex));
       breadCrumbIndex--;
    }
  }
  else { anim.SetBool("walking",false);anim.SetBool("backToSquare1",true); }
  break;</pre></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In statement 2 of the previous code, we check whether any breadcrumbs have been thrown yet.</p></li><li style="list-style-type: disc"><p>In statement 6 of the previous code, we describe how the zombie looks at the last breadcrumb.</p></li><li style="list-style-type: disc"><p>In statement 7 <a id="id545" class="indexterm"></a>of the previous code, we determine the distance between the zombie and the next breadcrumb.</p></li><li style="list-style-type: disc"><p>In <a id="id546" class="indexterm"></a>statements 8-11 of the previous code, we determine if the zombie is within one meter from the next breadcrumb; then it is destroyed and the zombie will walk toward the subsequent breadcrumb.</p></li><li style="list-style-type: disc"><p>Statement 10 of the previous code shows how the nearby breadcrumb is destroyed <a id="id547" class="indexterm"></a>and the variable <code class="literal">breadCrumbIndex</code> is decreased.</p></li><li style="list-style-type: disc"><p>Statement 14 of the previous code determines if the zombie has reached the first breadcrumb; it has reached its initial position and can transition back to the state <code class="literal">Idle</code>. We also set the variable <code class="literal">walking</code> to false so that the zombie stays <a id="id548" class="indexterm"></a>in the <code class="literal">Idle</code> state.</p></li></ul></div><p>Save the script and test it by moving the player around the maze, and either firing at or walking in front of the zombie. Once the zombie starts following the player, move to a location where it cannot see the player, and using the <span class="strong"><strong>Scene</strong></span> view, check<a id="id549" class="indexterm"></a> that the zombie walks <a id="id550" class="indexterm"></a>back to its initial<a id="id551" class="indexterm"></a> position.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec17"></a>Allowing enemies to follow the player's breadcrumbs</h3></div></div></div><p>It would also be great to improve this behavior by adding the ability for the zombie to follow the player. In the next section, we will create a new state (and associated transitions) called <code class="literal">FollowPlayersBreadCrumbs</code>. In this state, we need to detect the closest <a id="id552" class="indexterm"></a>breadcrumb dropped by the player, detect the index of this breadcrumb, and start moving the zombie along the path defined by the breadcrumbs from the closest onward. For example, if the <a id="id553" class="indexterm"></a>player has dropped 20 breadcrumbs, and the closest breadcrumb from the zombie<a id="id554" class="indexterm"></a> is the tenth breadcrumb, then the zombie will walk toward the tenth breadcrumb, then the eleventh breadcrumb, and so on, until it reaches the last breadcrumb dropped by the player.</p><p>First, let's add the ability for the player to drop breadcrumbs. Create a new folder labeled <code class="literal">Scripts</code> by selecting <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>chapter6</strong></span> and select it; create a new script and rename it <code class="literal">playerBreadCrumb</code> (this script should now be in <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>chapter6</strong></span> | <span class="strong"><strong>Scripts</strong></span>), add this script to the <span class="strong"><strong>First Person Controller</strong></span>, and add the following lines of code to the script:</p><div class="informalexample"><pre class="programlisting">var breadCrumb:GameObject;
var timeForNextCrumb:float;
public var currentTime:float;
public var breadCrumbs = new Array();
public var index:int;
function Start () 
{
  timeForNextCrumb = Time.time;
  index = 0;
}
function Update () 
{
  if (Time.time &gt; timeForNextCrumb)
  {
    timeForNextCrumb = Time.time+.5;
    breadCrumbs[index] = gameObject.transform.position;
    var b:GameObject  = GameObject.Instantiate(breadCrumb,transform.position, transform.rotation);
    b.name = "breadcrumb_player_"+index;
    index++;
  }
}</pre></div><p>The previous code is similar to the one created for the zombie, with the exception that the name of the breadcrumb dropped by the player will be different. Breadcrumbs will be dropped every 500 milliseconds and each of them will have a unique name. Every time a breadcrumb is dropped, the corresponding index is incremented by 1.</p><p>Next, let's create the corresponding new state for the zombie:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Select and open (double-click) the animation <code class="literal">zombieController</code> by selecting the folder <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>chapter5</strong></span>.</p></li><li><p>Open<a id="id555" class="indexterm"></a> the <span class="strong"><strong>Animator</strong></span> window, create a<a id="id556" class="indexterm"></a> new state, and rename this state <code class="literal">FollowPlayersBreadCrumbs</code>.</p></li><li><p>Add the animation <code class="literal">WalkForward</code> to the <code class="literal">Motion</code> attribute of this state as we have done for the state <code class="literal">FollowBreadCrumbs</code>.</p></li><li><p>Add an additional Boolean parameter labeled <code class="literal">canFollowPlayersCrumbs</code> as illustrated <a id="id557" class="indexterm"></a>in the following screenshot. This variable will be used to determine <a id="id558" class="indexterm"></a>the behavior of the zombie that could either follow its own breadcrumbs after losing sight of the player, or follow the player's breadcrumbs. This occurrence would add some challenge and uncertainty to our game as the player would not know what type of zombie he/she will encounter as well as its level of intelligence.</p><div class="mediaobject"><img src="/graphics/9781849695848/graphics/5848_06_3.jpg" /></div></li><li><p>Create <a id="id559" class="indexterm"></a>a transition from the state <code class="literal">WalkForward</code> to <a id="id560" class="indexterm"></a>the state <code class="literal">FollowPlayersBreadCrumbs</code>.</p></li><li><p>Set the transition conditions to <span class="strong"><strong>canSeePlayerWhileWalking = false</strong></span> and <span class="strong"><strong>canFollowPlayersCrumbs = true</strong></span> (you can click on the <span class="strong"><strong>+</strong></span> button to include the second condition).</p></li><li><p>Create a transition from the state <code class="literal">FollowPlayersBreadCrumbs</code> to the state <code class="literal">Idle</code>.</p></li><li><p>Set the transition condition to <span class="strong"><strong>backToSquare1 = true</strong></span>.</p></li><li><p>Create a transition from the state <code class="literal">FollowPlayersBreadCrumbs</code> to the state <code class="literal">Attack</code> and set <a id="id561" class="indexterm"></a>the transition condition to <span class="strong"><strong>withinReach = true</strong></span>.</p></li></ol></div><p>Since we want to differentiate between two types of zombies that can or cannot follow the player's breadcrumbs, we will also need to amend the transitions created previously between the states <code class="literal">WalkForward</code> and <code class="literal">FollowBreadCrumbs</code>: click on the transition between the states <code class="literal">WalkForward</code> and <code class="literal">FollowBreadCrumbs</code>, and add the condition <span class="strong"><strong>canFollowPlayersCrumb = false</strong></span>, as illustrated in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695848/graphics/5848_06_4.jpg" /></div><p>After adding these two new states and associated transitions, the animation <code class="literal">zombieController</code> in the <span class="strong"><strong>Animator</strong></span> window should look like the following screenshot (new states and transitions are highlighted with circles):</p><div class="mediaobject"><img src="/graphics/9781849695848/graphics/5848OT_06_5.jpg" /></div><p>Next, let's modify our script <code class="literal">controlZombie</code> to manage and trigger the state <code class="literal">FollowPlayersBreadCrumbs</code> by adding<a id="id562" class="indexterm"></a> the following code at the start of the script:</p><div class="informalexample"><pre class="programlisting">public var FollowPlayersBreadCrumbsState:int = Animator.StringToHash("Base Layer.FollowPlayersBreadCrumbs");
public var playerBreadCrumbsIndex:int = 0;
public var canFollowPlayersCrumbs:boolean;</pre></div><p>In the<a id="id563" class="indexterm"></a> previous code, we create a variable to monitor the state <code class="literal">FollowPlayersBreadCrumbs</code>, an index for the breadcrumbs dropped by the player, and a variable that will be used to determine if the zombie to which this script is attached can actually follow <a id="id564" class="indexterm"></a>the player's breadcrumbs. Add the following function to the script:</p><div class="informalexample"><pre class="programlisting">function setCharacterType(canFollow:boolean)
{
  anim = GetComponent("Animator");
  canFollowPlayersCrumbs = canFollow;
  anim.SetBool("canFollowPlayersCrumbs",canFollowPlayersCrumbs);
}</pre></div><p>This function will define whether this enemy will be able to follow the player's breadcrumbs.</p><p>Add the <a id="id565" class="indexterm"></a>following line in the <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">setCharacterType (canFollowPlayerCrumbs);</pre></div><p>Next, we can create the code that handles the state <code class="literal">FollowPlayersbreadCrumbs</code>.</p><p>Add the following code line at the start of the script:</p><div class="informalexample"><pre class="programlisting">private var player:GameObject;</pre></div><p>Add the following code line in the <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">player = GameObject.FindWithTag("Player");</pre></div><p>Add the following code to the <code class="literal">Update</code> function<a id="id566" class="indexterm"></a>, within the <code class="literal">switch</code> structure:</p><div class="informalexample"><pre class="programlisting">case FollowPlayersBreadCrumbsState:
anim.SetBool("backtoSquare1", false);
  if (!detectedPlayersClosestCrumb)
  {
    var closest:float = 200.0f;
    var indexOfClosest:int;â€©    var maxIndex:int = player.GetComponent(playerBreadCrumb).index;
    for (var i:int = 0; i &lt; maxIndex; i++)
    {
      var objectToFind:GameObject = GameObject.Find("breadcrumb"+"_player_"+i);
      distance = Vector3.Distance(transform.position, objectToFind.transform.position);
      if (distance &lt; closest)
  {
         indexOfClosest = i; closest = distance;
  }
    }  
    playerBreadCrumbsIndex = indexOfClosest;
    detectedPlayersClosestCrumb = true;
  }</pre></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Statement 1 of the previous code shows that the next lines will apply when the zombie is in the state <code class="literal">FollowPlayersBreadCrumbs</code>.</p></li><li style="list-style-type: disc"><p>Statement 3 <a id="id567" class="indexterm"></a>shows that if the closest breadcrumb has not been defined or detected yet, then we will do so.</p></li><li style="list-style-type: disc"><p>In <a id="id568" class="indexterm"></a>statement 4 of the previous code, we create an array that will include all of the breadcrumbs generated by this zombie.</p></li><li style="list-style-type: disc"><p>Statement 5 of the previous code explains that the variable <code class="literal">closest</code> is used to <a id="id569" class="indexterm"></a>determine the distance of the closest breadcrumb. It is set to 200 initially, so that any breadcrumb originally included in the array would be the closest.</p></li><li style="list-style-type: disc"><p>In statement 6 of the previous code, the index of the closest breadcrumb is defined.</p></li><li style="list-style-type: disc"><p>In statement 7 of the previous code, we access the number of breadcrumbs dropped by the player.</p></li><li style="list-style-type: disc"><p>In statements 8-15 of the previous code, we loop through all breadcrumbs dropped by the player and identify the closest.</p></li><li style="list-style-type: disc"><p>Statement 17 of the previous code explains that once we have defined the closest breadcrumb, its <a id="id570" class="indexterm"></a>index is used and saved in the variable <code class="literal">indexOfClosest</code>.</p></li><li style="list-style-type: disc"><p>Statement 18 of the previous code explains that since we have identified the closest<a id="id571" class="indexterm"></a> breadcrumb, the corresponding variable, <code class="literal">detectedPlayersClosestBreadCrumb</code> is set to <code class="literal">true</code>.</p></li></ul></div><p>Add <a id="id572" class="indexterm"></a>the following <a id="id573" class="indexterm"></a>lines of codes following the last line we have just typed:</p><div class="informalexample"><pre class="programlisting">else
{
transform.LookAt(GameObject.Find("breadcrumb_player_"+playerBreadCrumbsIndex).transform);
  distanceToBreadCrumb = Vector3.Distance(gameObject.transform.position, GameObject.Find("breadcrumb_player_"+playerBreadCrumbsIndex).transform.position);
  if ( distanceToBreadCrumb&lt; 1.5f)
    {
  playerBreadCrumbsIndex++;
    }
  }
break;</pre></div><p>The previous code is similar to the one created for the zombie in the state <code class="literal">FollowBreadCrumb</code>. The <a id="id574" class="indexterm"></a>zombie looks at and walks toward the next breadcrumb. Finally, remember that we also have a different type of enemy, the patrollers with a dedicated animation <code class="literal">controlPatroller</code>. Because the prefab that we have created based on this animation is also linked to the script <code class="literal">controlZombie</code>, it will start throwing breadcrumbs as soon as it sees the player and will start walking toward him/her. However, we still haven't implemented a solution that ensures that it goes back to its initial path if the player is not in sight anymore. We could do this by modifying the corresponding animation and adding a few additional lines to the script <code class="literal">controlZombie</code>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Locate and select the animation <code class="literal">zombiePatrolController</code> by selecting folder <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>chapter5</strong></span>.</p></li><li><p>Open the <span class="strong"><strong>Animator</strong></span> window (<span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Animator</strong></span>); we should see the states created<a id="id575" class="indexterm"></a> previously for this animation. Create a new state and label it <code class="literal">FollowBreadCrumbs</code>.</p></li><li><p>Locate<a id="id576" class="indexterm"></a> the animation <code class="literal">WalkForward</code> and drop it to the <code class="literal">Motion</code> attribute of the state <code class="literal">FollowBreadCrumbs</code>.</p></li><li><p>Create<a id="id577" class="indexterm"></a> two <a id="id578" class="indexterm"></a>new Boolean parameters, <code class="literal">canSeePlayerWhileWalking</code> and <code class="literal">backToSquare1</code>.</p></li><li><p>Create a transition from the state <span class="strong"><strong>WalkForward</strong></span> to the state <span class="strong"><strong>FollowBreadCrumbs</strong></span> and set the transition condition to <span class="strong"><strong>canSeePlayerWhileWalking = false</strong></span>.</p></li><li><p>Create a transition from the state <span class="strong"><strong>FollowBreadCrumb</strong></span> to the state <span class="strong"><strong>Patrol</strong></span> and set the transition condition to <span class="strong"><strong>backToSquare1 = true</strong></span>.</p></li></ol></div><p>After <a id="id579" class="indexterm"></a>these modifications, the animator should look like the following screenshot (the new state and corresponding<a id="id580" class="indexterm"></a> transitions have been highlighted by circles):</p><div class="mediaobject"><img src="/graphics/9781849695848/graphics/5848OT_06_6.jpg" /></div><p>Next, we will need to modify the script <code class="literal">controlZombie</code> to manage and trigger these states.</p><p>Open the script <code class="literal">controlZombie</code>, and <a id="id581" class="indexterm"></a>add the following line at the start of the code that handles the state <code class="literal">Patrol</code> as highlighted in the following code example:</p><div class="informalexample"><pre class="programlisting">case PatrolState:
<span class="strong"><strong>anim.SetBool("backToSquare1",false);</strong></span>
</pre></div><p>Finally, we need to add a breadCrumb prefab to the object <code class="literal">patroller</code> so that it can instantiate breadcrumbs overtime. Select the object <code class="literal">patroller</code> and drag-and-drop the prefab breadCrumb from <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>chapter6</strong></span> to the variable (<span class="strong"><strong>placeholder</strong></span>) breadCrumb located in the <span class="strong"><strong>Inspector</strong></span> for the function <code class="literal">controlZombie</code>, within the object <code class="literal">patroller</code>. Play the <a id="id582" class="indexterm"></a>scene, and check that after firing at the patroller, it follows you; move to a location where it can't see you, and check in the <span class="strong"><strong>Scene</strong></span> view that it follows its own breadcrumbs<a id="id583" class="indexterm"></a> and<a id="id584" class="indexterm"></a> resumes the patrol where it had been stopped.</p></div></div>