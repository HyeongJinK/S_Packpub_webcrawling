<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec39"></a>Adding basic AI to enemies</h2></div></div><hr /></div><p>In the previous section, we have managed to set transitions for the animations and the state of<a id="id410" class="indexterm"></a> the zombie from <span class="strong"><strong>Idle</strong></span> to <span class="strong"><strong>walking</strong></span>. To add some challenge <a id="id411" class="indexterm"></a>to the game, we will equip this enemy with some AI and create a script that changes the state of the enemy from <span class="strong"><strong>Idle</strong></span> to <span class="strong"><strong>WalkForward</strong></span> whenever it sees the player. First, let's allocate the predefined-tag player to <span class="strong"><strong>First Person Controller</strong></span>: select <span class="strong"><strong>First Person Controller</strong></span> from the <span class="strong"><strong>Hierarchy</strong></span> window<a id="id412" class="indexterm"></a>, and in the <span class="strong"><strong>Inspector</strong></span> window<a id="id413" class="indexterm"></a>, click on the drop-down menu to the right of the label <span class="strong"><strong>Tag</strong></span> and select the tag <span class="strong"><strong>Player</strong></span>.</p><p>Then, we can start creating a script that will set the direction of the zombie toward the player. Create a folder labeled <code class="literal">Scripts</code> inside the folder <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>chapter5</strong></span>, create a new script, rename it <code class="literal">controlZombie</code>, and add the following code to the start of the script:</p><div class="informalexample"><pre class="programlisting">public var walking:boolean = false;
public var anim:Animator;
public var  currentBaseState:AnimatorStateInfo;	
public var walkForwardState:int = Animator.StringToHash("Base Layer.WalkForward");
public var idleState:int = Animator.StringToHash("Base Layer.Idle");
private var playerTransform:Transform;
private var hit:RaycastHit;</pre></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In statement 1 of the previous code, a Boolean value is created. It is linked to the<a id="id414" class="indexterm"></a> parameter used for the animation in the <span class="strong"><strong>Animator</strong></span> window.</p></li><li style="list-style-type: disc"><p>In statement 2 of the previous code, we define an <span class="strong"><strong>Animator</strong></span> object that will<a id="id415" class="indexterm"></a> be used to manage the animator component of the zombie character.</p></li><li style="list-style-type: disc"><p>In statement 3 of the previous code, we create an <code class="literal">AnimatorStateInfo</code> variable<a id="id416" class="indexterm"></a> that will be used to determine the current state of the animation (for example, <span class="strong"><strong>Idle</strong></span> or <span class="strong"><strong>WalkForward</strong></span>).</p></li><li style="list-style-type: disc"><p>In statement 4 of the previous code, we create a variable, <code class="literal">walkForwardState</code><a id="id417" class="indexterm"></a>, that will represent the state <code class="literal">WalkForward</code> previously defined in the <span class="strong"><strong>Animator</strong></span> window. We use the method <code class="literal">Animator.StringToHash</code> to convert this state initially from a string<a id="id418" class="indexterm"></a> to an integer that can then be used to monitor the active state.</p></li><li style="list-style-type: disc"><p>In statement 5 of the previous code, similar to the previous comments, a variable is created for the state <code class="literal">Idle</code>.</p></li><li style="list-style-type: disc"><p>In statement 6 of the previous code, we create a variable that will be used to detect the position of the player.</p></li><li style="list-style-type: disc"><p>In <a id="id419" class="indexterm"></a>statement 7 of the previous code, we create a ray that will be employed later on to detect the player.</p></li></ul></div><p>Next, let's <a id="id420" class="indexterm"></a>add the following function to the script:</p><div class="informalexample"><pre class="programlisting">function Start ()
{
  anim = GetComponent(Animator);
  playerTransform = GameObject.FindWithTag("Player").transform;
}</pre></div><p>In line 3 of the previous code, we initialize the variable <code class="literal">anim</code> with the <code class="literal">Animator</code> component<a id="id421" class="indexterm"></a> linked<a id="id422" class="indexterm"></a> to this <code class="literal">GameObject</code>.</p><p>We can then add the following lines of code:</p><div class="informalexample"><pre class="programlisting">function Update ()
{
  currentBaseState = anim.GetCurrentAnimatorStateInfo(0);
  gameObject.transform.LookAt(playerTransform);
}</pre></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In line 3 of the previous code, we determine the current state for our animation.</p></li><li style="list-style-type: disc"><p>In line 4 of the previous code, the transform component of the current game object is oriented so that it is looking at the <span class="strong"><strong>First Person Controller</strong></span>. Therefore, when the zombie is walking, it will follow the player.</p></li></ul></div><p>Save this script, and drag-and-drop it to the character labeled <code class="literal">zombie_hires</code> in the <span class="strong"><strong>Hierarchy</strong></span> window.</p><p>As we have seen previously, we will need to manage several states through our script, including the states <span class="strong"><strong>Idle</strong></span><a id="id423" class="indexterm"></a> and <span class="strong"><strong>WalkForward</strong></span>. Let's add the following code<a id="id424" class="indexterm"></a> in<a id="id425" class="indexterm"></a> the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">switch (currentBaseState.nameHash)
{
case idleState:
break;

case walkForwardState:
break;

default:
break;
}</pre></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In line 1 of the previous code, depending on the current state, we will switch to a different set of instructions</p></li><li style="list-style-type: disc"><p>All code related to the state <code class="literal">Idle</code> will be included within lines 3-4 of the previous code</p></li><li style="list-style-type: disc"><p>All code related to the state <code class="literal">WalkForward</code> will be included within lines 6-7</p></li></ul></div><p>If we play the scene, we may notice that the zombie rotates around the x and z axes when near the player; its y position also changes over time. To correct this issue, let's add the following <a id="id426" class="indexterm"></a>code at the end of the function <code class="literal">Update</code>:</p><div class="informalexample"><pre class="programlisting">transform.position.y = -0.5;
transform.rotation.x = 0.0;
transform.rotation.z = 0.0;</pre></div><p>We now need to detect whether the zombie can see the player, or detect its presence within <a id="id427" class="indexterm"></a>a radius of two meters (that is, the zombie would hear the <a id="id428" class="indexterm"></a>player if he/she is within two meters). This can be achieved using two techniques: by calculating the distance between the zombie and the player, and by casting a ray from the zombie and detecting whether the player is in front of the zombie. If this is the case, the zombie will start walking toward the player. We need to calculate the distance between the player and the zombie by adding the following code <a id="id429" class="indexterm"></a>to the script, <code class="literal">controlZombie</code>, at the start of the function <code class="literal">Update</code>, <a id="id430" class="indexterm"></a>before the <code class="literal">switch</code> statement:</p><div class="informalexample"><pre class="programlisting">var distance:float = Vector3.Distance(transform.position, playerTransform.position);</pre></div><p>In the previous code, we create a variable labeled <code class="literal">distance</code> and initialize it with the distance between the player and the zombie. This is achieved using the built-in function <code class="literal">Vector3.Distance</code>.</p><p>Now that the distance is calculated (and updated in every frame), we can implement the code that will serve to detect whether the player is near or in front of the zombie.</p><p>Open the script entitled <code class="literal">controlZombie</code>, and add the following lines to the function <code class="literal">Update</code><a id="id431" class="indexterm"></a> within the block of instructions for the <code class="literal">Idle</code> state, so that it looks as follows:</p><div class="informalexample"><pre class="programlisting">case idleState:
<span class="strong"><strong>  if ((Physics.Raycast (Vector3(transform.position.x,transform.position.y+.5,transform.position.z), transform.forward, hit,40) &amp;&amp; hit.collider.gameObject.tag == "Player") || distance &lt;2.0f)</strong></span>
<span class="strong"><strong> {</strong></span>
<span class="strong"><strong>    anim.SetBool("walking",true);</strong></span>
<span class="strong"><strong> }</strong></span>
break;</pre></div><p>In the previous lines of code, a ray or ray cast is created. It is casted forward from the zombie,<a id="id432" class="indexterm"></a> 0.5 meters above the ground and over 40 meters. Thanks to the variable <code class="literal">hit</code>, we read the tag of the object that is colliding with our ray and check whether this object is the<a id="id433" class="indexterm"></a> player. If this is the case, the parameter <code class="literal">walking</code><a id="id434" class="indexterm"></a> is set to <code class="literal">true</code>. Effectively, this should trigger<a id="id435" class="indexterm"></a> a transition to the state <code class="literal">walking</code>, as we have defined previously, so that the zombie starts walking toward the player.</p><p>Initially, our code was written so that the zombie rotated around to face the player, even in the <code class="literal">Idle</code> state<a id="id436" class="indexterm"></a> (using the built-in function <code class="literal">LookAt</code>). However, we need to modify this feature so that the zombie only turns around to face the player while it is following the player, otherwise, the player will always be in sight and the zombie will always see him/her, even in the <code class="literal">Idle</code> state. We can achieve this by deleting the code highlighted in the following code snippet (from the start of the function <code class="literal">Update</code>), and adding <a id="id437" class="indexterm"></a>it to the code for the state <code class="literal">WalkForward</code>:</p><div class="informalexample"><pre class="programlisting">case walkForwardState:
<span class="strong"><strong>  transform.LookAt(playerTransform);</strong></span>
<span class="strong"><strong>  break;</strong></span>
</pre></div><p>In the previous lines, we checked whether the zombie is walking forward, and if this is the case, the zombie will rotate in order to look at and follow the player. Test our code by playing the scene and either moving within two meters of the zombie or in front of the zombie.</p></div>