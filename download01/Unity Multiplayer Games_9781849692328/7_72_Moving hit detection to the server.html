<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec73"></a>Moving hit detection to the server</h2></div></div><hr /></div><p>Our first order<a id="id313" class="indexterm"></a> of business is to move the raycast function to the server.</p><p>We have a readymade solution for this—we can simply mark our <code class="literal">Fire</code> function as an RPC, and instead of calling it directly, we broadcast an RPC instead.</p><p>First, we'll modify our Fire function as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[RPC]</strong></span>
void Fire()
{
  <span class="strong"><strong>// this code should never execute on any machine other than the server/host</strong></span>
<span class="strong"><strong>  if( !Network.isServer )</strong></span>
<span class="strong"><strong>    return;</strong></span>

  RaycastHit hit;
  if( Physics.Raycast( transform.position, transform.forward, out hit, 100f, HitLayers ) )
  {
    // let a script on the object handle taking damage
    hit.collider.SendMessage( "TakeDamage", Damage, SendMessageOptions.DontRequireReceiver );
  }
}</pre></div><p>We'll then send an RPC to call the Fire function rather than directly calling it:</p><div class="informalexample"><pre class="programlisting">void Update()
{
  if( networkView.isMine &amp;&amp; Input.GetMouseButtonDown( 0 ) )
  {
    // if we're the server, just directly call the function
    // remember, server cannot use RPCMode.Server, the RPC is simply dropped. So we have to directly call method instead
    if( Network.isServer ) Fire();
    else networkView.RPC( "Fire" RPCMode.Server );
  }
}</pre></div><p>And finally, <a id="id314" class="indexterm"></a>we need to modify <code class="literal">Damage</code> to accommodate our new changes. Note that clients do not send damage to the server anymore, so we'll modify our RPC to work in the reverse—rather than clients sending to the server, the server now sends to clients.</p><p>The changes are pretty big, so it's best to simply rewrite the component altogether:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Damage : MonoBehaviour
{
  public float Health = 100f;

  void TakeDamage( float damage )
  {
    // this code should only ever execute on the server
    if( !Network.isServer )
      return;

    // if you plan on calling TakeDamage multiple times per frame (for example, Shotgun-type weapons can easily result in this), this part is important – it checks if the entity already died earlier in the frame, to ensure the death code isn't triggered more than once.
    if( Health &lt;= 0 ) return;

    // subtract damage from health
    Health -= damage;

    // check if player died
    if( Health &lt;= 0 )
    {
      // clamp to zero just in case – it looks weird when a player has negative health.
      Health = 0;

      // kick player out of the game when they die
      Network.CloseConnection( networkView.owner, true );
    }

    // notify clients of new health value
    networkView.RPC( "setHealth" RPCMode.Others, Health ); 
  }

  [RPC]
  void setHealth( float health )
  {
    Health = health;
  }
}</pre></div><p>Note that we<a id="id315" class="indexterm"></a> simply send the entire health value to the clients now, rather than just the change in health. This ensures clients never have incorrect health values.</p><p>Now our hit detection is fully server authoritative, meaning players cannot cheat the system as they could before. However, this still presents the issue of target leading, as it takes time for the fire message to reach the server and in this time the target for a shot likely has moved on.</p></div>