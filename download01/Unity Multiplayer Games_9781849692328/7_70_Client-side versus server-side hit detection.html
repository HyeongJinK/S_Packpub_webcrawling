<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec71"></a>Client-side versus server-side hit detection</h2></div></div><hr /></div><p>Let's take a<a id="id302" class="indexterm"></a> look at what our client-side and server-side hit detection might look like. For client-side hit detection, you perform the hit detection on the client and directly generate a damage message to send to the server. For instance:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class WeaponScript : MonoBehaviour
{
  public float Damage = 10f;
  public LayerMask HitLayers;

  public void Fire()
  {
    RaycastHit hit;
    if( Physics.Raycast( transform.position, transform.forward, out hit, 100f, HitLayers ) )
    {
      // a script on the object could handle this by generating an RPC, for example
      hit.collider.SendMessage( "TakeDamage", Damage, SendMessageOptions.DontRequireReceiver );
    } 
  }
}</pre></div><p>It's very short, simple, and incredibly easy to understand. However, it's also incredibly open to hacking. Players can easily spoof the damage message to send damage messages to whoever they wish, and they can also easily modify the damage amount to any amount. To solve this, we need the server to figure out by itself who the player hits, and how much damage to deal.</p><p>Let's take a look at what naive server-side hit detection might look like:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class WeaponScript : MonoBehaviour
{
  public float Damage = 10f;
  public LayerMask HitLayers;
  
  public void Fire()
  {
    // tell the server to perform hit detection
    networkView.RPC( "serverDoFire", RPCMode.Server );
  }

  [RPC]
  public void serverDoFire()
  {
    RaycastHit hit;
    if( Physics.Raycast( transform.position, transform.forward, out hit, 100f, HitLayers ) )
    {
      // a script on the object could handle this by generating an RPC, for example
      hit.collider.SendMessage( "TakeDamage", Damage, SendMessageOptions.DontRequireReceiver );
    }
  }
}</pre></div><p>It's nearly the exact same code, the main difference is that we moved the hit detection into an RPC and <a id="id303" class="indexterm"></a>when we fire the weapon, this RPC is executed on the server. This makes things much more difficult to hack, as players can only tell the server they fired their weapon and the server handles the rest—hit detection, damage, and death.</p><p>This does have the side effect of requiring target leading, which gets worse when latency increases.</p><p>For instance, let's say we have player A running toward and shooting at player B. This is what the client and server see (approximately):</p><div class="mediaobject"><img src="/graphics/9781849692328/graphics/2328OT_07_01.jpg" /></div><p>At this point, player A sends a fire message to the server. Let's say in an extreme case this message takes a <a id="id304" class="indexterm"></a>full second to reach the server (of course, it's rarely ever more than a fraction of a second, but the effects can still be quite noticeable). By the time the message reaches the server, this might be what the server sees:</p><div class="mediaobject"><img src="/graphics/9781849692328/graphics/2328OT_07_02.jpg" /></div><p>If the server performed hitscan now, it would completely miss player B, and even though this is a perfectly explainable situation, it may frustrate player A and even cause them to quit playing, or accuse player B of hacking, and so on.</p><p>We can modify our hitscan function to make calls to a hypothetical rewinding function:</p><div class="informalexample"><pre class="programlisting">[RPC]
public void serverDoFire( NetworkMessageInfo info )
{
  // how long ago was this message sent?
  double timeDiff = Network.time – info.timestamp;
  // rewind network entities
  EntityRewinder.Rewind( timeDiff );

  //perform hitscan
  RaycastHit hit;
  if( Physics.Raycast( transform.position, transform.forward, out hit, 100f, HitLayers ) )
  {
    // a script on the object could handle this by generating an RPC, for example
    hit.collider.SendMessage( "TakeDamage", Damage, SendMessageOptions.DontRequireReceiver );
  }

  // restore network entities
  EntityRewinder.Restore();
}</pre></div><p>So, we calculate how long ago, in seconds, the message was sent from the client. We then rewind every entity <a id="id305" class="indexterm"></a>to where they were at the time the message was sent. Then, we perform the hitscan. Finally, we restore every entity back to the current state. This way, the player does not have to lead their targets, and overall the game will feel much more natural as a result.</p></div>