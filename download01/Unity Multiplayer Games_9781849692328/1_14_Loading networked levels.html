<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec21"></a>Loading networked levels</h2></div></div><hr /></div><p>There are a<a id="id46" class="indexterm"></a> few tricks to loading networked levels in the Unity game engine. If you just use <code class="literal">Application.LoadLevel</code>, you'll encounter a number of issues; specifically you may find that a client connecting to the game won't see any objects that were instantiated via <code class="literal">Network.Instantiate</code>. The reason for this is because the level loading process doesn't happen instantlyâ€”it actually takes two frames to complete. This occurs after the list of networked objects was received, so the load process will delete them.</p><p>Note that <code class="literal">Application.LoadLevel</code> is purely client side. Unity imposes no limitations on which level a client or server loads in a networked game. In fact, it's entirely possible that you might have different levels within a networked session, and this is what <code class="literal">Network.SetLevelPrefix</code> is for. Each of these levels is assigned some kind of "ID" that uniquely identifies the level. Before loading the level you would use <code class="literal">Network.SetLevelPrefix</code>. This essentially separates players into channels, so all players with level prefix 0 are separate from players with level prefix 1, for example.</p><p>Note that if your game needs all clients to load the same level, you'll have to ensure this yourself. If a client has a different level loaded than the host, without setting the level prefix to something different than the host, the client might see some odd situations, such as players floating or sunk into the ground (a player could be standing on a bridge in one level, and a different level at the same position might have a building; so the player would appear to be clipped into the building).</p><p>The correct <a id="id47" class="indexterm"></a>way to load levels in a networked game, is to first disable the network queue, load the level, wait two frames, and then re-enable the network queue. This means any incoming messages will not be processed, and will instead be buffered until the new level has completely finished loading.</p><p>Let's write a simple network level loader that will handle all of these for us. It's designed as a singleton so we don't need one present in the scene (one will automatically be created):</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class NetworkLevelLoader : MonoBehavior
  {
  // implements singleton-style behavior
  public static NetworkLevelLoader Instance
  {
    get
    {
      // no instance yet? Create a new one
      if( instance == null )
      {
        GameObject go = new GameObject( "_networkLevelLoader" );
        // hide it to avoid cluttering up the hieararchy
        go.hideFlags = HideFlags.HideInHierarchy;
        instance = go.AddComponent&lt;NetworkLevelLoader&gt;();

        // don't destroy it when a new scene loads
        GameObject.DontDestroyOnLoad( go );
      }
      return instance;
    }
  }
  private static NetworkLevelLoader instance;

  public void LoadLevel( string levelName, int prefix = 0 )
  {
    StopAllCoroutines();
    StartCoroutine( doLoadLevel( levelName, prefix ) );
  }

  // do the work of pausing the network queue, loading the level, waiting, and then unpausing
  IEnumerator doLoadLevel( string name, int prefix )
  {
    Network.SetSendingEnabled( 0, false );
    Network.isMessageQueueRunning = false;

    Network.SetLevelPrefix( prefix );
    Application.LoadLevel( name );
    yield return null;
    yield return null;

    Network.isMessageQueueRunning = true;
    Network.SetSendingEnabled( 0, true );
  }
}</pre></div><p>You can now <a id="id48" class="indexterm"></a>replace any calls to <code class="literal">Application.LoadLevel</code> with <code class="literal">NetworkLevelLoader.Instance.LoadLevel</code>. For example, the server might call an RPC which loads the level via the helper class we just wrote, as a buffered RPC so that all clients connecting will automatically load the level.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note06"></a>Note</h3><p>If your server needs to change level during the connection, for example, in many FPS games players can vote on a new map at the end of a round, things get a bit more complicated. The server should first delete all networked objects belonging to players, remove RPCs from all players (via Network.RemoveRPCs), and then call the load-level RPC.</p></div></div>