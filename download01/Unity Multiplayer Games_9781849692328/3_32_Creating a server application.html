<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec37"></a>Creating a server application</h2></div></div><hr /></div><p>Let's create <a id="id123" class="indexterm"></a>a new server application. Upon <a id="id124" class="indexterm"></a>receiving any message, it will simply get an echo, a confirmation that it has received the message (an acknowledgement).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"></a>Creating a class library</h3></div></div></div><p>Create <a id="id125" class="indexterm"></a>a new class library project called <code class="literal">PhotonAckServer</code>. I have put mine in the <code class="literal">src-server</code> directory.</p><p>Now, we'll add three references to our project. These can be found in the <span class="strong"><strong>libs</strong></span> directory of the Photon Server:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">ExitGamesLibs.dll</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">Photon.SocketServer.dll</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">PhotonHostRuntimeInterfaces.dll</code>
</p></li></ul></div><p>With these added, create a new <code class="literal">PhotonAckServer</code> class. This will inherit from <code class="literal">ApplicationBase</code>, code for the same is as follows:</p><div class="informalexample"><pre class="programlisting">using Photon.SocketServer;

public class PhotonAckServer : ApplicationBase
{
  protected override PeerBase CreatePeer( InitRequest initRequest )
  {
  }

  protected override void Setup()
  {
  }

  protected override void TearDown()
  {
  }
}</pre></div><p>And we'll also create a new <code class="literal">PhotonAckPeer</code> class as follows:</p><div class="informalexample"><pre class="programlisting">using Photon.SocketServer;
using PhotonHostRuntimeInterfaces;

class PhotonAckPeer : PeerBase
{
  public PhotonAckPeer( IRpcProtocol protocol, IPhotonPeer unmanagedPeer )
    : base( protocol, unmanagedPeer )
  {
  }

  protected override void OnDisconnect( DisconnectReason reasonCode, string reasonDetail )
  {
  }

  protected override void OnOperationRequest( OperationRequest operationRequest, SendParameters sendParameters )
  {
  }
  }
}</pre></div><p>And modify<a id="id126" class="indexterm"></a> our <code class="literal">PhotonAckServer</code> to return the <code class="literal">PhotonAckPeer</code> we just created:</p><div class="informalexample"><pre class="programlisting">using Photon.SocketServer;

public class PhotonAckServer : ApplicationBase
{
  protected override PeerBase CreatePeer( InitRequest initRequest )
  {
    <span class="strong"><strong>return new PhotonAckPeer( initRequest.Protocol, </strong></span>      <span class="strong"><strong>initRequest.PhotonPeer );</strong></span>
  }

  protected override void Setup()
  {
  }

  protected override void TearDown()
  {
  }
}</pre></div><p>So, what did we just do here? We have created a class library (which compiles down to a DLL). This is known as a server application. It is in charge of handling all server-side logic in Photon. It compiles to a DLL, which is referenced by the actual Photon Server EXE.</p><p>This setup involves at least two classes, an <code class="literal">Application</code> and a <code class="literal">Peer</code>. The <code class="literal">Application</code> class isn't much more than glue code, creating and returning a new instance of our <code class="literal">Peer</code> class (it can also handle startup and shutdown if need be) when requested.</p><p>The <code class="literal">Peer</code> class essentially wraps a specific client (when a client connects, the <code class="literal">Application</code> class will create and return a new peer for that client). It can handle messages coming from the client (known as operation requests), and can send messages back to the client (either as responses to operation requests, or as events, which don't need to be in response to anything).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec26"></a>Responding to operation requests</h3></div></div></div><p>So, let's<a id="id127" class="indexterm"></a> send our "ack" as a response. First, we'll create an <code class="literal">enum</code> variable of values, which map to response codes using following code:</p><div class="informalexample"><pre class="programlisting">public enum PhotonAckResponseTypes : byte
{
  Ack = 0
}</pre></div><p>Right now there is only one entry, but we can easily add more responsive codes by adding the <code class="literal">enum</code> variable values (the point of using an <code class="literal">enum</code> variable value is for organization and more readable code)</p><p>Now, in our <code class="literal">PhotonAckPeer</code>, let's modify our <code class="literal">OnOperationRequest</code> function to return an <code class="literal">ack</code> response.</p><div class="informalexample"><pre class="programlisting">using Photon.SocketServer;
using PhotonHostRuntimeInterfaces;
using System.Collections.Generic;

class PhotonAckPeer : PeerBase
{
  public PhotonAckPeer( IRpcProtocol protocol, IPhotonPeer unmanagedPeer )
    : base( protocol, unmanagedPeer )
  {
  }
  protected override void OnDisconnect( DisconnectReason reasonCode, string reasonDetail )
  {
    
  }

  protected override void OnOperationRequest( OperationRequest operationRequest, SendParameters sendParameters )
  {
    <span class="strong"><strong>// send an "ack" back to the client</strong></span>
    <span class="strong"><strong>OperationResponse response = new OperationResponse( </strong></span>      <span class="strong"><strong>(byte)PhotonAckResponseTypes.Ack );</strong></span>
    <span class="strong"><strong>this.SendOperationResponse( response, sendParameters );</strong></span>
  }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"></a>Deploying the server code</h3></div></div></div><p>Although <a id="id128" class="indexterm"></a>this is a very simple example, we've now got a fully functional server application. To build this, first ensure that the built server DLL is placed under your project's directory under <span class="strong"><strong>bin</strong></span> (this is required by the Photon Server application), now start to build the project.</p><p>Copy the bin folder you just built to the deploy folder under <code class="literal">deploy/PhotonAckServer/</code>. Now ,we'll need to edit the Photon Server configuration to ensure that it knows about our new application. The configuration file is located at <code class="literal">deploy/bin_win32/PhotonServer.config</code>. You should see a section titled <code class="literal">Applications</code>. Add the following entry:</p><div class="informalexample"><pre class="programlisting">&lt;Application
  Name="PhotonAckServer"
  BaseDirectory="PhotonAckServer"
  Assembly="PhotonAckServer"
  Type="PhotonAckServer"&gt;
&lt;/Application&gt;</pre></div><p>Now, our server is ready to handle clients. Let's make a client in Unity, which will send and receive messages from Photon.</p></div></div>