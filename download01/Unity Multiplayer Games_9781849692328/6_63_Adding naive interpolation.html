<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec65"></a>Adding naive interpolation</h2></div></div><hr /></div><p>First, let's add<a id="id287" class="indexterm"></a> the simplest form of entity interpolation. We'll simply store the position of the object received over the network, and in Update we simply lerp to the new position. This is the interpolation we used in the first chapter when creating the Pong clone.</p><p>First, we'll create a temporary variable to hold values received over the network.</p><div class="informalexample"><pre class="programlisting">private Vector3 lastReceivedPosition;</pre></div><p>We'll initialize this to the current position in Start.</p><div class="informalexample"><pre class="programlisting">void Start()
{
  lastReceivedPosition = transform.position;
}</pre></div><p>In our OnSerializeNetworkView function, we'll store our received value in this variable, rather than directly assigning transform position.</p><div class="informalexample"><pre class="programlisting">void OnSerializeNetworkView( BitStream stream, NetworkMessageInfo info )
{
  Vector3 position = Vector3.zero;
  if( stream.isWriting )
  {
    position = transform.position;
    stream.Serialize( ref position );
  }
  else
  {
    stream.Serialize( ref position );
    <span class="strong"><strong>lastReceivedPosition = position;</strong></span>
  }
}</pre></div><p>And finally, we'll use the Lerp function to interpolate towards the received value.</p><div class="informalexample"><pre class="programlisting">void Update()
{
  if( !networkView.isMine )
  {
    transform.position = Vector3.Lerp( transform.position, lastReceivedPosition, Time.deltaTime * 10f );
  }
}</pre></div><p>Now, the movement <a id="id288" class="indexterm"></a>of remote players will be significantly less jerky. However, this method has a number of problems. Using Lerp in this fashion tends to produce what is referred to as "ease-out" behavior: the object initially moves quickly towards the target, slowing down as it approaches until it comes to a stop at the target point (<code class="literal">Time.deltaTime</code> yields a good base value, which we can multiply by some arbitrary factor to speed up or slow down the interpolation).</p><p>This works based on essentially a percentage of the remaining distanceâ€”as the distance is shorter, the same percentage of that distance becomes a smaller value (which results in the interpolation slowing down as it approaches the target). This is one of the easiest forms of interpolation, as it involves zero bookkeeping or temporary variables.</p><p>However, it can lead to a very "mushy" feel, especially in a game where players have a high degree of control over their character. We could increase the interpolation speed, but this takes fine-tuning so as to strike a balance between the aforementioned "mushy" feel, and interpolation which is too fast and leads to jerkiness.</p><p>What we need is a way to closely replicate the original movement of the player object in a way that looks natural and doesn't need fine tuning to get right. We'll borrow some ideas from the aforementioned source game engine to interpolate our entities.</p></div>