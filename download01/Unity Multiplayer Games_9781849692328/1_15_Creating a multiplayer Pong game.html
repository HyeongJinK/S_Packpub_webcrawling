<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec22"></a>Creating a multiplayer Pong game</h2></div></div><hr /></div><p>Now that we've<a id="id49" class="indexterm"></a> covered the basics of using Unity Networking, we're going to apply them to creating a multiplayer Pong clone.</p><p>The game will play pretty much as standard Pong. Players can choose their name, and then view a list of open servers (full rooms will not be shown). Players can also host their own game.</p><p>Once in a game, players bounce a ball back and forth until it hits the opponent's side. Players get one point for this, and the ball will reset and continue bouncing. When a player hits 10 points, the winner is called, the scores are reset, and the game continues. While in a match with no other players, the server will inform the user to wait. If a player leaves, the match is reset (if the host leaves, the other player is automatically disconnected).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec08"></a>Preparing the Field</h3></div></div></div><p>First, <a id="id50" class="indexterm"></a>create a cube (by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Other</strong></span> | <span class="strong"><strong>Cube</strong></span>) and scale it to 1 x 1 x 4. Name it <code class="literal">Paddle</code> and set the <span class="strong"><strong>Tag</strong></span> to <span class="strong"><strong>Player</strong></span>. Check the <span class="strong"><strong>Is Trigger</strong></span> box on the collider.</p><div class="mediaobject"><img src="/graphics/9781849692328/graphics/2328OT_01_03.jpg" /></div><p>Our ball will detect when it hits the trigger zone on the player paddle, and reverse direction. We use triggers because we don't necessarily want to simulate the ball realistically with the Unity physics engine (we get far less control over the ball's physics, and it may not behave exactly as we would like).</p><p>We will also line our playing field in trigger boxes. For these you can duplicate the paddle four times and <a id="id51" class="indexterm"></a>form a large rectangle outlining the playing field. The actual size doesn't matter so much, as long as the ball has room to move around. We will add two more tags for these boundaries: <span class="strong"><strong>Boundary</strong></span> and <span class="strong"><strong>Goal</strong></span>. The two boxes on the top and bottom of the field are tagged as <span class="strong"><strong>Boundary</strong></span>, the two boxes on the left and right are tagged as <span class="strong"><strong>Goal</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781849692328/graphics/2328OT_01_04.jpg" /></div><p>When the ball hits a trigger tagged Boundary, it reverses its velocity along the z axis. When the ball hits a trigger tagged Player, it reverses its velocity along the x axis. And when a ball hits a trigger tagged Goal, the corresponding player gets a point and the ball resets.</p><p>Let's finish up the playing field before writing our code:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Firstly, set the camera to <span class="strong"><strong>Orthographic</strong></span> and position it at (<code class="literal">0</code>, <code class="literal">10</code>, <code class="literal">0</code>). Rotate it 90 degrees along the x axis until it points straight down, and change its <span class="strong"><strong>Orthographic Size</strong></span> to a value large enough to frame the playing field (in my case, I set it to 15). Set the camera's background color to black.</p></li><li><p>Create a<a id="id52" class="indexterm"></a> directional light that points straight down. This will illuminate the paddles and ball to make them pure white.</p></li><li><p>Finally, duplicate the player paddle and move it to the other half of the field.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec09"></a>The Ball script</h3></div></div></div><p>Now we're<a id="id53" class="indexterm"></a> going to create the Ball script. We'll add the multiplayer code later, for now this is offline only:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Ball : MonoBehavior
{
  // the speed the ball starts with
  public float StartSpeed = 5f;

  // the maximum speed of the ball
  public float MaxSpeed = 20f;

  // how much faster the ball gets with each bounce
  public float SpeedIncrease = 0.25f;

  // the current speed of the ball
  private float currentSpeed;

  // the current direction of travel
  private Vector2 currentDir;

  // whether or not the ball is resetting
  private bool resetting = false;

  void Start()
  {
    // initialize starting speed
    currentSpeed = StartSpeed;

    // initialize direction
    currentDir = Random.insideUnitCircle.normalized;
  }

  void Update()
  {
    // don't move the ball if it's resetting
    if( resetting )
      return;

    // move the ball in the current direction
    Vector2 moveDir = currentDir * currentSpeed * Time.deltaTime;
    transform.Translate( new Vector3( moveDir.x, 0f, moveDir.y ) );
  }

  void OnTriggerEnter( Collider other )
  {
    if( other.tag == "Boundary" )
    {
      // vertical boundary, reverse Y direction
      currentDir.y *= -1;
    }
    else if( other.tag == "Player" )
    {
      // player paddle, reverse X direction
      currentDir.x *= -1;
    }
    else if( other.tag == "Goal" )
    {
      // reset the ball
      StartCoroutine( resetBall() );
      // inform goal of the score
      other.SendMessage( "GetPoint", SendMessageOptions.DontRequireReceiver );
    }

    // increase speed
    currentSpeed += SpeedIncrease;
    
    // clamp speed to maximum
    currentSpeed = Mathf.Clamp( currentSpeed, StartSpeed, MaxSpeed );
  }

  IEnumerator resetBall()
  {
    // reset position, speed, and direction
    resetting = true;
    transform.position = Vector3.zero;
    
    currentDir = Vector3.zero;
    currentSpeed = 0f;
    // wait for 3 seconds before starting the round
    yield return new WaitForSeconds( 3f );

Start();

    resetting = false;
  }
}</pre></div><p>To create the ball, as before we'll create a cube. It will have the default scale of 1 x 1 x 1. Set the position<a id="id54" class="indexterm"></a> to origin (<code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">0</code>). Add a rigidbody component to the cube, untick the <span class="strong"><strong>Use Gravity</strong></span> checkbox, and tick the <span class="strong"><strong>Is Kinematic</strong></span> checkbox. The <code class="literal">Rigidbody</code> component is used to let our ball get the <code class="literal">OnTriggerEnter</code> events. <span class="strong"><strong>Is Kinematic</strong></span> is enabled because we're controlling the ball ourselves, rather than using Unity's physics engine.</p><p>Add the new <span class="strong"><strong>Ball</strong></span> component that we just created and test the game. It should look something like this:</p><div class="mediaobject"><img src="/graphics/9781849692328/graphics/2328OT_01_06.jpg" /></div><p>You should see the ball bouncing around the field. If it hits either side, it will move back to the center of the<a id="id55" class="indexterm"></a> field, pause for 3 seconds, and then begin moving again. This should happen fairly quickly, because the paddles aren't usable yet (the ball will often bounce right past them).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>The Paddle script</h3></div></div></div><p>Let's add <a id="id56" class="indexterm"></a>player control to the mix. Note that at the moment player paddles will both move in tandem, with the same controls. This is OK, later we'll disable the player input based on whether or not the network view belongs to the local client (this is what the <code class="literal">AcceptsInput</code> field is for):</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Paddle : MonoBehavior
{
  // how fast the paddle can move
  public float MoveSpeed = 10f;

  // how far up and down the paddle can move
  public float MoveRange = 10f;

  // whether this paddle can accept player input
  public bool AcceptsInput = true;

  void Update()
  {
    // does not accept input, abort
    if( !AcceptsInput )
      return;

    //get user input
    float input = Input.GetAxis( "Vertical" );
    
    // move paddle
    Vector3 pos = transform.position;
    pos.z += input * MoveSpeed * Time.deltaTime;

    // clamp paddle position
    pos.z = Mathf.Clamp( pos.z, -MoveRange, MoveRange );

    // set position
    transform.position = pos;
  }
}</pre></div><p>You can now<a id="id57" class="indexterm"></a> move the paddles up and down, and bounce the ball back and forth. The ball will slowly pick up speed as it bounces, until it hits either of the goals. When that happens, the round resets.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"></a>Keeping score</h3></div></div></div><p>What <a id="id58" class="indexterm"></a>we're going to do now is create a scorekeeper. The scorekeeper will keep track of both players' scores, and will later keep track of other things, such as whether we're waiting for another player to join:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Scorekeeper : MonoBehavior
{
  // the maximum score a player can reach
  public int ScoreLimit = 10;

  // Player 1's score
  private int p1Score = 0;

  // Player 2's score
  private int p2Score = 0;

  // give the appropriate player a point
  public void AddScore( int player )
  {
    // player 1
    if( player == 1 )
    {
      p1Score++;
    }
    // player 2
    else if( player == 2 )
    {
      p2Score++;
    }

    // check if either player reached the score limit
    if( p1Score &gt;= ScoreLimit || p2Score &gt;= ScoreLimit )
    {
      // player 1 has a better score than player 2
      if( p1score &gt; p2score )
        Debug.Log( "Player 1 wins" );
      // player 2 has a better score than player 1
      if( p2score &gt; p1score )
        Debug.Log( "Player 2 wins" );
      // both players have the same score - tie
      else
        Debug.Log( "Players are tied" );

      // reset scores and start over
      p1Score = 0;
      p2Score = 0;
    }
  }
}</pre></div><p>Now our scorekeeper can keep score for each player, let's make the goals and add points with a Goal script. It's <a id="id59" class="indexterm"></a>a very simple script, which reacts to the GetPoint message sent from the ball upon collision to give the other player a point:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Goal : MonoBehavior
{
  // the player who gets a point for this goal, 1 or 2
  public int Player = 1;

  // the Scorekeeper
  public Scorekeeper scorekeeper;

  public void GetPoint()
  {
    // when the ball collides with this goal, give the player a point
    scorekeeper.AddScore( Player );
  }
}</pre></div><p>Attach this script to <a id="id60" class="indexterm"></a>both goals. For player 1's goal, set the <span class="strong"><strong>Player</strong></span> to <code class="literal">2</code> (player 2 gets a point when the ball lands in player 1's goal), for player 2's goal, set the <span class="strong"><strong>Player</strong></span> to <code class="literal">1</code> (player 1 gets a point when the ball lands in player 2's goal).</p><p>The game is almost completely functional now (aside from multiplayer). One problem is that we can't tell that points are being given until the game ends, so let's add a score display.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec12"></a>Displaying the score to the player</h3></div></div></div><p>Create two 3D Text objects<a id="id61" class="indexterm"></a> as children of the scorekeeper. Name them <code class="literal">p1Score</code> and <code class="literal">P2Score</code>, and position them on each side of the field:</p><div class="mediaobject"><img src="/graphics/9781849692328/graphics/2328OT_01_05.jpg" /></div><p>Let's make<a id="id62" class="indexterm"></a> the scorekeeper display the player scores:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Scorekeeper : MonoBehavior
{
  // the maximum score a player can reach
  public int ScoreLimit = 10;

<span class="strong"><strong>  // the display test for player 1's score</strong></span>
<span class="strong"><strong>  public TextMesh Player1ScoreDisplay;</strong></span>

<span class="strong"><strong>  // the display text for player 2's score</strong></span>
<span class="strong"><strong>  public TextMesh Player2ScoreDisplay;</strong></span>

  // Player 1's score
  private int p1Score = 0;

  // Player 2's score
  private int p2Score = 0;

  // give the appropriate player a point
  public void AddScore( int player )
  {
    // player 1
    if( player == 1 )
    {
      p1Score++;
    }
    // player 2
    else if( player == 2 )
    {
      p2Score++;
    }

    // check if either player reached the score limit
    if( p1Score &gt;= ScoreLimit || p2Score &gt;= ScoreLimit )
    {
      // player 1 has a better score than player 2
      if( p1Score &gt; p2Score )
        Debug.Log( "Player 1 wins" );
      // player 2 has a better score than player 1
      if( p2Score &gt; p1Score )
        Debug.Log( "Player 2 wins" );
      // both players have the same score - tie
      else
        Debug.Log( "Players are tied" );

      // reset scores and start over
      p1Score = 0;
      p2Score = 0;
    }

<span class="strong"><strong>    // display each player's score</strong></span>
<span class="strong"><strong>    Player1ScoreDisplay.text = p1Score.ToString();</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>   Player2ScoreDisplay.text = p2Score.ToString();</strong></span>
  }
}</pre></div><p>The score is<a id="id63" class="indexterm"></a> now displayed properly when a player gets a point. Be sure to give it a test run—the ball should bounce around the field, and you should be able to deflect the ball with the paddle. If the ball hits player 1's goal, player 2 should get 1 point, and vice versa. If one player gets 10 points, both scores should reset to zero, the ball should move back to the center of the screen, and the game should restart.</p><p>With the most<a id="id64" class="indexterm"></a> important gameplay elements complete, we can start working on multiplayer networking.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec13"></a>Networking the game</h3></div></div></div><p>For<a id="id65" class="indexterm"></a> testing purposes, let's launch a network game as soon as the level is launched:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class RequireNetwork : MonoBehavior
{
  void Awake()
  {
    if( Network.peerType == NetworkPeerType.Disconnected )
      Network.InitializeServer( 1, 25005, true );
  }
}</pre></div><p>If we start this level without hosting a server first, it will automatically do so for us in ensuring that the networked code still works.</p><p>Now we can start converting our code to work in multiplayer.</p><p>Let's start by networking the paddle code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Paddle : MonoBehavior
{
  // how fast the paddle can move
  public float MoveSpeed = 10f;

  // how far up and down the paddle can move
  public float MoveRange = 10f;

  // whether this paddle can accept player input
  public bool AcceptsInput = true;
<span class="strong"><strong>  // the position read from the network</strong></span>
<span class="strong"><strong>  // used for interpolation</strong></span>
<span class="strong"><strong>  private Vector3 readNetworkPos;</strong></span>

<span class="strong"><strong>  void Start()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    // if this is our paddle, it accepts input</strong></span>
<span class="strong"><strong>    // otherwise, if it is someone else's paddle, it does not</strong></span>
<span class="strong"><strong>    AcceptsInput = networkView.isMine;</strong></span>
<span class="strong"><strong>  }</strong></span>

  void Update()
  {
<span class="strong"><strong>    // does not accept input, interpolate network pos</strong></span>
<span class="strong"><strong>    if( !AcceptsInput )</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      transform.position = Vector3.Lerp( transform.position, readNetworkPos, 10f * Time.deltaTime );</strong></span>

<span class="strong"><strong>      // don't use player input</strong></span>
<span class="strong"><strong>      return;</strong></span>
<span class="strong"><strong>    }</strong></span>

    //get user input
    float input = Input.GetAxis( "Vertical" );
    
    // move paddle
    Vector3 pos = transform.position;
    pos.z += input * MoveSpeed * Time.deltaTime;

    // clamp paddle position
    pos.z = Mathf.Clamp( pos.z, -MoveRange, MoveRange );

    // set position
    transform.position = pos;
  }

<span class="strong"><strong>  void OnSerializeNetworkView( BitStream stream )</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    // writing information, push current paddle position</strong></span>
<span class="strong"><strong>    if( stream.isWriting )</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      Vector3 pos = transform.position;</strong></span>
<span class="strong"><strong>      stream.Serialize( ref pos );</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    // reading information, read paddle position</strong></span>
<span class="strong"><strong>    else</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      Vector3 pos = Vector3.zero;</strong></span>
<span class="strong"><strong>      stream.Serialize( ref pos );</strong></span>
<span class="strong"><strong>      readNetworkPos = pos;</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The paddle will detect whether it is owned by the local player or not. If not, it will not accept player input, instead it will interpolate its position to the last read position value over the network.</p><p>By default,<a id="id66" class="indexterm"></a> network views will serialize the attached transform. This is OK for testing, but should not be used for production. Without any interpolation, the movement will appear very laggy and jerky, as positions are sent a fixed number of times per second (15 by default in Unity Networking) in order to save on bandwidth, so snapping to the position 15 times per second will look jerky. In order to solve this, rather than instantly snapping to the new position we smoothly interpolate towards it. In this case, we use the frame delta multiplied by a number (larger is faster, smaller is slower), which produces an easing motion; the object starts quickly approaching the target value, slowing down as it gets closer.</p><p>When serializing, it either reads the position and stores it, or it sends the current transform position, depending on whether the stream is for reading or for writing.</p><p>Now, add a <span class="strong"><strong>Network View</strong></span> to one of your paddles, drag the panel component attached to the <span class="strong"><strong>Paddle</strong></span> into the <span class="strong"><strong>Observed</strong></span> slot, and make it a prefab by dragging it into your <span class="strong"><strong>Project</strong></span> pane.</p><p>Next, delete the paddles in the scene, and create two empty game objects where the paddles used to be positioned. These will be the starting points for each paddle when spawned.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec14"></a>Spawning paddles</h3></div></div></div><p>Next, let's<a id="id67" class="indexterm"></a> make the scorekeeper spawn these paddles. The scorekeeper, upon a player connecting, will send an RPC to them to spawn a paddle:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Scorekeeper : MonoBehavior
{
  // the maximum score a player can reach
  public int ScoreLimit = 10;

<span class="strong"><strong>  // the start points for each player paddle</strong></span>
<span class="strong"><strong>  public Transform SpawnP1;</strong></span>
<span class="strong"><strong>  public Transform SpawnP2;</strong></span>

<span class="strong"><strong>  // the paddle prefab</strong></span>
<span class="strong"><strong>  public GameObject paddlePrefab;</strong></span>

  // the display test for player 1's score
  public TextMesh Player1ScoreDisplay;

  // the display text for player 2's score
  public TextMesh Player2ScoreDisplay;

  // Player 1's score
  private int p1Score = 0;

  // Player 2's score
  private int p2Score = 0;

<span class="strong"><strong>  void Start()</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    if( Network.isServer )</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      // server doesn't trigger OnPlayerConnected, manually spawn</strong></span>
<span class="strong"><strong>      Network.Instantiate( paddlePrefab, SpawnP1.position, Quaternion.identity, 0 );</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>void OnPlayerConnected( NetworkPlayer player )</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    // when a player joins, tell them to spawn</strong></span>
<span class="strong"><strong>    networkView.RPC( "net_DoSpawn", player, SpawnP2.position );</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  [RPC]</strong></span>
<span class="strong"><strong>  void net_DoSpawn( Vector3 position )</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    // spawn the player paddle</strong></span>
<span class="strong"><strong>    Network.Instantiate( paddlePrefab, position, Quaternion.identity, 0 );</strong></span>
<span class="strong"><strong>  }</strong></span>

  // give the appropriate player a point
  public void AddScore( int player )
  {
    // player 1
    if( player == 1 )
    {
      p1Score++;
    }
    // player 2
    else if( player == 2 )
    {
      p2Score++;
    }

    // check if either player reached the score limit
    if( p1Score &gt;= ScoreLimit || p2Score &gt;= ScoreLimit )
    {
      // player 1 has a better score than player 2
      if( p1Score &gt; p2Score )
        Debug.Log( "Player 1 wins" );
      // player 2 has a better score than player 1
      if( p2Score &gt; p1Score )
        Debug.Log( "Player 2 wins" );
      // both players have the same score - tie
      else
        Debug.Log( "Players are tied" );

      // reset scores and start over
      p1Score = 0;
      p2Score = 0;
    }

    // display each player's score
    Player1ScoreDisplay.text = p1Score.ToString();
    Player2ScoreDisplay.text = p2Score.ToString();
  }
}</pre></div><p>At the moment, <a id="id68" class="indexterm"></a>when you start the game, one paddle spawns for player 1, but player 2 is missing (there's nobody else playing). However, the ball eventually flies off toward player 2's side, and gives player 1 a free point.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec15"></a>The networked ball</h3></div></div></div><p>Let's keep the <a id="id69" class="indexterm"></a>ball frozen in place when there's nobody to play against, or if we aren't the server. We're also going to add networked movement to our ball:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Ball : MonoBehavior
{
  // the speed the ball starts with
  public float StartSpeed = 5f;

  // the maximum speed of the ball
  public float MaxSpeed = 20f;

  // how much faster the ball gets with each bounce
  public float SpeedIncrease = 0.25f;

  // the current speed of the ball
  private float currentSpeed;

  // the current direction of travel
  private Vector2 currentDir;

  // whether or not the ball is resetting
  private bool resetting = false;

  void Start()
  {
    // initialize starting speed
    currentSpeed = StartSpeed;

    // initialize direction
    currentDir = Random.insideUnitCircle.normalized;
  }

  void Update()
  {
    // don't move the ball if it's resetting
    if( resetting )
      return;

<span class="strong"><strong>    // don't move the ball if there's nobody to play with</strong></span>
<span class="strong"><strong>    if( Network.connections.Length == 0 )</strong></span>
<span class="strong"><strong>      return;</strong></span>

    // move the ball in the current direction
    Vector2 moveDir = currentDir * currentSpeed * Time.deltaTime;
    transform.Translate( new Vector3( moveDir.x, 0f, moveDir.y ) );
  }

  void OnTriggerEnter( Collider other )
  {
    // bounce off the top and bottom walls
    if( other.tag == "Boundary" )
    {
      // vertical boundary, reverse Y direction
      currentDir.y *= -1;
    }
    // bounce off the player paddle
    else if( other.tag == "Player" )
    {
      // player paddle, reverse X direction
      currentDir.x *= -1;
    }
    // if we hit a goal, and we are the server, give the appropriate player a point
    else if( other.tag == "Goal" &amp;&amp; Network.isServer )
    {
      // reset the ball
      StartCoroutine( resetBall() );
      // inform goal of the score
      other.SendMessage( "GetPoint", SendMessageOptions.DontRequireReceiver );
    }

    // increase speed
    currentSpeed += SpeedIncrease;
    
    // clamp speed to maximum
    currentSpeed = Mathf.Clamp( currentSpeed, StartSpeed, MaxSpeed );
  }
  IEnumerator resetBall()
  {
    // reset position, speed, and direction
    resetting = true;
    transform.position = Vector3.zero;

    currentDir = Vector3.zero;
    currentSpeed = 0f;

    // wait for 3 seconds before starting the round
    yield return new WaitForSeconds( 3f );

    Start();

    resetting = false;
  }

<span class="strong"><strong>  void OnSerializeNetworkView( BitStream stream )</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    //write position, direction, and speed to network</strong></span>
<span class="strong"><strong>    if( stream.isWriting )</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      Vector3 pos = transform.position;  </strong></span>
<span class="strong"><strong>      Vector3 dir = currentDir;</strong></span>
<span class="strong"><strong>      float speed = currentSpeed;</strong></span>
<span class="strong"><strong>      stream.Serialize( ref pos );</strong></span>
<span class="strong"><strong>      stream.Serialize( ref dir );</strong></span>
<span class="strong"><strong>      stream.Serialize( ref speed );</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    // read position, direction, and speed from network</strong></span>
<span class="strong"><strong>    else</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      Vector3 pos = Vector3.zero;</strong></span>
<span class="strong"><strong>      Vector3 dir = Vector3.zero;</strong></span>
<span class="strong"><strong>      float speed = 0f;</strong></span>
<span class="strong"><strong>      stream.Serialize( ref pos );</strong></span>
<span class="strong"><strong>      stream.Serialize( ref dir );</strong></span>
<span class="strong"><strong>      stream.Serialize( ref speed );</strong></span>
<span class="strong"><strong>      transform.position = pos;</strong></span>
<span class="strong"><strong>      currentDir = dir;</strong></span>
<span class="strong"><strong>      currentSpeed = speed;  </strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The ball will stay <a id="id70" class="indexterm"></a>put if there's nobody to play against, and if someone we're playing against leaves, the ball will reset to the middle of the field. The ball will also work correctly on multiple machines at once (it is simulated on the server, and position/velocity is relayed to clients). Add NetworkView to the ball and have it observe the Ball component.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec16"></a>Networked scorekeeping</h3></div></div></div><p>There is one final piece<a id="id71" class="indexterm"></a> of the puzzle that is keeping score. We're going to convert our <code class="literal">AddScore</code> function to use an RPC, and if a player leaves we will also reset the scores:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Scorekeeper : MonoBehavior
{
  // the maximum score a player can reach
  public int ScoreLimit = 10;

  // the start points for each player paddle
  public Transform SpawnP1;
  public Transform SpawnP2;

  // the paddle prefab
  public GameObject paddlePrefab;

  // the display test for player 1's score
  public TextMesh Player1ScoreDisplay;

  // the display text for player 2's score
  public TextMesh Player2ScoreDisplay;

  // Player 1's score
  private int p1Score = 0;

  // Player 2's score
  private int p2Score = 0;

  void Start()
  {
    if( Network.isServer )
    {
      // server doesn't trigger OnPlayerConnected, manually spawn
      Network.Instantiate( paddlePrefab, SpawnP1.position, Quaternion.identity, 0 );

<span class="strong"><strong>      // nobody has joined yet, display "Waiting..." for player 2</strong></span>
<span class="strong"><strong>      Player2ScoreDisplay.text = "Waiting...";</strong></span>
    }
  }

void OnPlayerConnected( NetworkPlayer player )
  {
    // when a player joins, tell them to spawn
    networkView.RPC( "net_DoSpawn", player, SpawnP2.position );

<span class="strong"><strong>    // change player 2's score display from "waiting..." to "0"</strong></span>
<span class="strong"><strong>    Player2ScoreDisplay.text = "0";</strong></span>
  }

<span class="strong"><strong>  void OnPlayerDisconnected( NetworkPlayer player )</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    // player 2 left, reset scores</strong></span>
<span class="strong"><strong>    p1Score = 0;</strong></span>
<span class="strong"><strong>    p2Score = 0;</strong></span>

<span class="strong"><strong>    // display each player's scores</strong></span>
<span class="strong"><strong>    // display "Waiting..." for player 2</strong></span>
<span class="strong"><strong>    Player1ScoreDisplay.text = p1Score.ToString();</strong></span>
<span class="strong"><strong>    Player2ScoreDisplay.text = "Waiting...";</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  void OnDisconnectedFromServer( NetworkDisconnection cause )</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    // go back to the main menu</strong></span>
<span class="strong"><strong>    Application.LoadLevel( "Menu" );</strong></span>
<span class="strong"><strong>  }</strong></span>

  [RPC]
  void net_DoSpawn( Vector3 position )
  {
    // spawn the player paddle
    Network.Instantiate( paddlePrefab, position, Quaternion.identity, 0 );
  }
<span class="strong"><strong>  // call an RPC to give the player a point</strong></span>
<span class="strong"><strong>  public void AddScore( int player )</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    networkView.RPC( "net_AddScore", RPCMode.All, player );</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  // give the appropriate player a point</strong></span>
<span class="strong"><strong>  [RPC]</strong></span>
<span class="strong"><strong>  public void net_AddScore( int player )</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    // player 1</strong></span>
<span class="strong"><strong>    if( player == 1 )</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      p1Score++;</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    // player 2</strong></span>
<span class="strong"><strong>    else if( player == 2 )</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      p2Score++;</strong></span>
<span class="strong"><strong>    }</strong></span>

<span class="strong"><strong>    // check if either player reached the score limit</strong></span>
<span class="strong"><strong>    if( p1Score &gt;= ScoreLimit || p2Score &gt;= ScoreLimit )</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>      // player 1 has a better score than player 2</strong></span>
<span class="strong"><strong>      if( p1Score &gt; p2Score )</strong></span>
<span class="strong"><strong>        Debug.Log( "Player 1 wins" );</strong></span>
<span class="strong"><strong>      // player 2 has a better score than player 1</strong></span>
<span class="strong"><strong>      if( p2Score &gt; p1Score )</strong></span>
<span class="strong"><strong>        Debug.Log( "Player 2 wins" );</strong></span>
<span class="strong"><strong>      // both players have the same score - tie</strong></span>
<span class="strong"><strong>      else</strong></span>
<span class="strong"><strong>        Debug.Log( "Players are tied" );</strong></span>

<span class="strong"><strong>      // reset scores and start over</strong></span>
<span class="strong"><strong>      p1Score = 0;</strong></span>
<span class="strong"><strong>      p2Score = 0;</strong></span>
<span class="strong"><strong>    }</strong></span>

<span class="strong"><strong>    // display each player's score</strong></span>
<span class="strong"><strong>    Player1ScoreDisplay.text = p1Score.ToString();</strong></span>
<span class="strong"><strong>    Player2ScoreDisplay.text = p2Score.ToString();</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Our game is fully <a id="id72" class="indexterm"></a>networked at this point. The only problem is that we do not yet have a way to connect to the game. Let's write a simple direct connect dialog which allows players to enter an IP address to join.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note07"></a>Note</h3><p>With direct IP connect, note that NAT punch-through is not possible. When you use the Master Server, you can pass either HostData or GUID of a host which will perform NAT punch-through.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec17"></a>The Connect screen</h3></div></div></div><p>The following script shows the player IP and Port entry fields, and the <span class="strong"><strong>Connect</strong></span> and <span class="strong"><strong>Host</strong></span> buttons. The player can directly connect to an IP and Port, or start a server on the given Port. By using direct connect<a id="id73" class="indexterm"></a> we don't need to rely on a master server, as  players directly connect to games via IP. If you wanted to, you could easily create a lobby screen for this instead of using direct connect (allowing players to browse a list of running servers instead of manually typing IP address). To keep things simpler, we'll omit the lobby screen in this example:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ConnectToGame : MonoBehavior
{
  private string ip = "";
  private int port = 25005;

  void OnGUI()
  {
    // let the user enter IP address
    GUILayout.Label( "IP Address" );
    ip = GUILayout.TextField( ip, GUILayout.Width( 200f ) );

    // let the user enter port number
    // port is an integer, so only numbers are allowed
    GUILayout.Label( "Port" );
    string port_str = GUILayout.TextField( port.ToString(), GUILayout.Width( 100f ) );
    int port_num = port;
    if( int.TryParse( port_str, out port_num ) )
      port = port_num;
    // connect to the IP and port
    if( GUILayout.Button( "Connect", GUILayout.Width( 100f ) ) )
    {
      Network.Connect( ip, port );
    }

    // host a server on the given port, only allow 1 incoming connection (one other player)
    if( GUILayout.Button( "Host", GUILayout.Width( 100f ) ) )
    {
      Network.InitializeServer( 1, port, true );
    }
  }

  void OnConnectedToServer()
  {
    Debug.Log( "Connected to server" );
    // this is the NetworkLevelLoader we wrote earlier in the chapter – pauses the network, loads the level, waits for the level to finish, and then unpauses the network
    NetworkLevelLoader.Instance.LoadLevel( "Game" );
  }

  void OnServerInitialized()
  {
    Debug.Log( "Server initialized" );
    NetworkLevelLoader.Instance.LoadLevel( "Game" );
  }
}</pre></div><p>With this, we now have a complete, fully functional multiplayer Pong game. Players can host games, as well as join them if they know the IP.</p><p>When in a game <a id="id74" class="indexterm"></a>as the host, the game will wait for another player to show up before starting the game. If the other player leaves, the game will reset and wait again. As a player, if the host leaves it goes back to the main menu.</p></div></div>