<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec62"></a>The client-side prediction</h2></div></div><hr /></div><p>If a game <a id="id278" class="indexterm"></a>employs server-authoritative physics, it usually also needs to employ client-side prediction of player-controlled objects in order to hide the effects of lag. However, this is a more difficult problem than it appears at the outset.</p><p>Let's say the server periodically broadcasts the state of all objects. If a player is predicting their own object (and sending inputs to the server), what happens when the player receives a server update? Usually, especially when moving, they snap backward to where they were a moment ago in a motion deemed "rubber-banding". This is because there is always a lag between the client and server.</p><div class="mediaobject"><img src="/graphics/9781849692328/graphics/2328OT_06_01.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Client sends input to server and begins moving (resulting in picture 2).</p></li><li style="list-style-type: disc"><p>Server<a id="id279" class="indexterm"></a> receives message and starts moving player (resulting in picture 3).</p></li><li style="list-style-type: disc"><p>Server sends current position to client (snapping client back to the old position as shown by the dotted circle). The way Source engine and other games handle this involves a fair bit of bookkeeping, but in essence it isn't so hard.</p></li></ul></div><p>Firstly, the client sends input to the server. The client begins applying this input, and additionally saves the input to a buffer. The message it sends to the server also contains the result of the input, such as position.</p><p>When the server <a id="id280" class="indexterm"></a>receives the input, it applies the input to the player object, and then compares the result with what the client sent as the result. If the client computes the wrong result (for instance, the position sent by the client is too far off the server position), the server sends a message to the client telling the client what is the real result.</p><p>When the client receives this correction, it will have been sent some time ago, so the client needs to figure out what the current state is. To do this, it rewinds back to that point, and uses the inputs it stored to replay up to the current state. Essentially, you can think of this as "changing the past"—we're trying to simulate the effects of going back in time and changing the result of a calculation.</p><p>One of the most important things to remember about client-side prediction is that, it requires the predicted code to be entirely deterministic—given the same input, it needs to have the same output. Your client and server not only need to run the exact same code with the exact same inputs, you also often need to ensure this code is run in the exact same order (for example, if your client gathers input then updates, while your server updates then gathers input, you'll have plenty of problems).</p></div>