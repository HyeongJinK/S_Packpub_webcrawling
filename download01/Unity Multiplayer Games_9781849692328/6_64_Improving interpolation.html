<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec66"></a>Improving interpolation</h2></div></div><hr /></div><p>Here's how our<a id="id289" class="indexterm"></a> new interpolation will work, inspired by the methods employed in the Source game engine:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>As we receive network states, we buffer them up</p></li><li style="list-style-type: disc"><p>Each network state is timestamped with network time</p></li><li style="list-style-type: disc"><p>We subtract a value from time to find a time in the past (in source, this value is <span class="emphasis"><em>0.1</em></span> by default—so entities are always shown one tenth of a second in the past)</p></li><li style="list-style-type: disc"><p>We find the two states on either side of this time value, and interpolate between them</p></li><li style="list-style-type: disc"><p>Let's get started</p></li></ul></div><p>First, we need some kind of <code class="literal">struct</code> to store a snapshot of the network state:</p><div class="informalexample"><pre class="programlisting">// a snapshot of values received over the network
private struct networkState
{
  public Vector3 Position;
  public double Timestamp;
  
  public networkState( Vector3 pos, double time )
  {
    this.Position = pos;
    this.Timestamp = time;
  }
}</pre></div><p>We'll keep a buffer <a id="id290" class="indexterm"></a>of these to interpolate in between. Note our use of arrays for this purpose. We use a statically sized array for better performance (if we used a <code class="literal">List</code>, internally the <code class="literal">List</code> allocates new arrays whenever it needs to resize, which can trigger garbage collection). This also gives us a strict upper limit on the number of states which can be stored.</p><p>When we need to store a new state, we shift the entire array to the right (that is, the element at index <code class="literal">0</code> is moved to <code class="literal">1</code>, <code class="literal">1</code> is moved to <code class="literal">2</code>, and so on). The element at index <code class="literal">19</code> has nowhere to go, and is therefore deleted. We then insert the newest state at index <code class="literal">0</code>:</p><div class="informalexample"><pre class="programlisting">// we'll keep a buffer of 20 network states
networkState[] stateBuffer = new networkState[ 20 ];
int stateCount = 0; // how many states have been recorded</pre></div><p>And finally, we'll expose how far back interpolation goes as an inspector field for easy tweaking. By default, it's one tenth of a second:</p><div class="informalexample"><pre class="programlisting">// how far back to rewind interpolation?
public float InterpolationBackTime = 0.1f;</pre></div><p>We'll create a utility function for buffering a state received over the network. This will first shift the array to the right, as mentioned previously, before storing the newest state at <code class="literal">0</code>. It will then increase the count of states recorded, up to a maximum of <code class="literal">20</code> (the length of our buffer). We'll do this by setting <code class="literal">stateCount</code> to the smaller value, either the current state count plus one, or the maximum number of states.</p><div class="informalexample"><pre class="programlisting">// save new state to buffer
void bufferState( networkState state )
{
  // shift buffer contents to accommodate new state
  for( int i = stateBuffer.Length – 1; i &gt; 0; i-- )
  {
    stateBuffer[ i ] = stateBuffer[ i – 1 ];
  }

  // save state to slot 0
  stateBuffer[ 0 ] = state;

  // increment state count
  stateCount = Mathf.Min( stateCount + 1, stateBuffer.Length );
}</pre></div><p>Next, we'll <a id="id291" class="indexterm"></a>modify the <code class="literal">OnSerializeNetworkView</code> function to buffer states received over the network.</p><div class="informalexample"><pre class="programlisting">void OnSerializeNetworkView( BitStream stream, NetworkMessageInfo info )
{
  Vector3 position = Vector3.zero;
  if( stream.isWriting )
  {
    position = transform.position;
    stream.Serialize( ref position );
  }
  else
  {
    stream.Serialize( ref position );
<span class="strong"><strong>    bufferState( new networkState( position, info.timestamp ) );</strong></span>
  }
}</pre></div><p>And finally, we'll perform the interpolation. This involves subtracting <code class="literal">InterpolationBackTime</code> from <code class="literal">Network.time</code>, which essentially yields a time value in the past, finding the two states on either side of this time, and interpolating between them based on the time. If we don't have enough states to interpolate between, we simply do nothing—this will result in the occasional hitch or pause, but can't really be avoided and is present in nearly every multiplayer game.</p><div class="informalexample"><pre class="programlisting">void Update()
{
  if( networkView.isMine ) return; // don't run interpolation on the local object
  if( stateCount == 0 ) return; // no states to interpolate

  double currentTime = Network.time;
  double interpolationTime = currentTime - InterpolationBackTime;

  // the latest packet is newer than interpolation time - we have enough packets to interpolate
  if( stateBuffer[ 0 ].Timestamp &gt; interpolationTime )
  {
    for( int i = 0; i &lt; stateCount; i++ )
    {
      // find the closest state that matches network time, or use oldest state
      if( stateBuffer[ i ].Timestamp &lt;= interpolationTime || i == stateCount - 1 )
      {
        // the state closest to network time
        networkState lhs = stateBuffer[ i ];

        // the state one slot newer
        networkState rhs = stateBuffer[ Mathf.Max( i - 1, 0 ) ];

        // use time between lhs and rhs to interpolate
        double length = rhs.Timestamp - lhs.Timestamp;
        float t = 0f;
        if( length &gt; 0.0001 )
        {
          t = (float)( ( interpolationTime - lhs.Timestamp ) / length );
        }

        transform.position = Vector3.Lerp( lhs.Position, rhs.Position, t );
        break;
      }
    }
  }
}</pre></div><p>If you test our <a id="id292" class="indexterm"></a>demo game with this new method of interpolation, remote player objects should move very smoothly, completely natural (past 10 states per second it can closely reproduce player movement even in a fast-paced shooter), and with no jitter whatsoever. But, we still have a big problem—players have a lot of control over their player object. Because players have such control over their own avatar, there are a variety of well-known cheating methods in the hacker community. One such cheat is called "noclipping", named after a developer command in the source game engine, which disables all collisions for the player object and allowed them to fly about the map like a ghost. Another exploit, called N-stepping (for "ninja stepping") or alternatively lag-stepping involves temporarily disconnecting your internet, moving, and then reconnecting. This results in teleporting, as the player doesn't send any move updates for some amount of time until the Internet is reconnected (at which point, the player has moved some distance away). This can easily circumvent speed hack detection, as generally speed hack heuristics must deal with lagging players and can't tell the difference between N-stepping and honest lag.</p><p>The way we solve all of these problems is by employing server authoritative movement.</p></div>