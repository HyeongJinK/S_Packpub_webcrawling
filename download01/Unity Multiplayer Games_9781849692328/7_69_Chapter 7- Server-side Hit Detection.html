<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch07"></a>Chapter 7. Server-side Hit Detection</h2></div></div></div><p>There are many multiplayer games which involve shooting at their core, and there will be plenty more to come. These games all need some way to keep in sync who's shooting at who, and who gets hurt and dies. There are a number of ways to solve this problem.</p><p>The most obvious solution is simply to have player clients send a damage message. If the player hits someone, send a damage message to the server. The server deals damage to the appropriate player. There is a huge, glaring flaw in this design: players can, and will, cheat the game. It's truly staggering how many client-side hacking programs there are available—programs that send messages to the server, programs that directly modify variables on the client, and so on. A player could easily specify any player to be damaged, and any amount of damage to deal. It gets even worse if the client handles damage messages instead of the server, as the client can also make themselves invincible with almost no effort at all.</p><p>Clearly, we cannot trust the client at all, or our game will quickly become infested with cheaters and hackers. Clearly, the solution is to have the server handle all of this—it handles damage and health, it does its own hit detection, and so on. The client almost has no part in the server's work, aside from sending input to the server (just as in the last chapter, we'll have the client send input to the server—in this case, the state of the fire button).</p><p>There is one problem with this method, and in fact many games have this problem. When the player sends the <code class="literal">button down</code> message to the server, it may take some time for the message to reach the server. By the time it does, the target the player was looking at has moved—in some cases, out of the line of fire. This is why many games require you to lead your target if they are moving. </p><p>To solve this, we're going to implement <span class="strong"><strong>entity rewinding</strong></span>
<a id="id301" class="indexterm"></a>
<span class="strong"><strong>.</strong></span> Entity rewinding involves storing every network state of an entity—this may seem familiar to you, as we did something very similar in the last chapter. When a player tries to fire their weapon, the server actually rewinds the network state of every entity based on that player's ping, performs the raycast, and then restores the network state of every entity. Essentially, the server goes back in time to figure out where each entity was when the player sent the message (before it reached the server). This allows players to aim at their intended target without any sort of leading.</p></div>