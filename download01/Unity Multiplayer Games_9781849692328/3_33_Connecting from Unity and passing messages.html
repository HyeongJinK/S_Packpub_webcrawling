<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec38"></a>Connecting from Unity and passing messages</h2></div></div><hr /></div><p>Connecting to a<a id="id129" class="indexterm"></a> Photon Server from Unity is very simple. You just need to specify the IP, port, and application which you want to use (in this case, we will specify <code class="literal">PhotonAckServer</code> as the application). Each application defined in the Photon Server configuration will run alongside each otherâ€”this lets you run a number of different server types such as master servers and game servers on a single physical machine.</p><p>Let's create a script to connect to Photon, service the connection ten times per second, and sends a test message to the server (which responds with an acknowledgement message).</p><p>First, we'll start with this:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using ExitGames.Client.Photon;

public class PhotonAckClient : MonoBehaviour, IPhotonPeerListener
{
}</pre></div><p>We'll add some variables to the top of the script:</p><div class="informalexample"><pre class="programlisting">public PhotonPeer peer;
private bool connected = false;</pre></div><p>In Start, <a id="id130" class="indexterm"></a>we'll connect to the server and kick off a co-routine, which services the connection:</p><div class="informalexample"><pre class="programlisting">public void Start()
{
  // connect to Photon server
  peer = new PhotonPeer( this, ConnectionProtocol.Udp );
  peer.Connect( "127.0.0.1:5055", "PhotonAckServer" );
  
  StartCoroutine( doService() );
}</pre></div><p>Our service co-routine calls service and then delays for 0.1 seconds, in a while loop:</p><div class="informalexample"><pre class="programlisting">IEnumerator doService()
{
  while( true )
  {
    peer.Service();
    yield return new WaitForSeconds( 0.1f );
  }
}</pre></div><p>We'll also implement some methods required by the <code class="literal">IPhotonPeerListener</code> interface:</p><div class="informalexample"><pre class="programlisting">#region IPhotonPeerListener Members

public void DebugReturn( DebugLevel level, string message )
{
  // log message to console
  Debug.Log( message );
}

public void OnEvent( EventData eventData )
{
  //server raised an event
  Debug.Log( "Received event - type: " + eventData.Code.ToString() );
}

public void OnOperationResponse( OperationResponse operationResponse )
{
  //server sent operation response
  Debug.Log( "Received op response - type: " + operationResponse.OperationCode.ToString() );
}

public void OnStatusChanged( StatusCode statusCode )
{
  // connected to Photon server
  if( statusCode == StatusCode.Connect )
  {
    connected = true;
  }

  // log status change
  Debug.Log( "Status change: " + statusCode.ToString() );
}

#endregion</pre></div><p>Finally, <a id="id131" class="indexterm"></a>we'll display a GUI with a button that sends a test message to the server using the following code:</p><div class="informalexample"><pre class="programlisting">void OnGUI()
{
  GUILayout.Label( "Connected: " + connected.ToString() );

  if( connected )
  {
    if( GUILayout.Button( "Send Operation Request" ) )
    {
      // send a message to the server
      peer.OpCustom( 0, new System.Collections.Generic.Dictionary&lt;byte, object&gt;(), true );
    }
  }
}</pre></div><p>So, what exactly does this script accomplish?</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>It creates a new <code class="literal">PhotonPeer</code> class, which represents a connection to the Photon Server instance. It passes itself to the constructor, which causes the <code class="literal">PhotonPeer</code> class to call the <code class="literal">IPhotonPeerListener</code> methods that our class implements. It also specifies to use UDP for communication. This lets you specify which messages are reliable, and which are unreliable.</p></li><li style="list-style-type: disc"><p>It calls the service method of our <code class="literal">PhotonPeer</code> ten times per second. This causes the <code class="literal">PhotonPeer</code> class to process incoming messages and send outgoing messages. In a twitch-based game, this should be called more often to reduce lag (twenty times per second should suffice).</p></li><li style="list-style-type: disc"><p>It displays the connection status in OnGUI. If connected, it also shows a button, which will cause a test message to be sent to the server (via the <code class="literal">OpCustom</code> method of the <code class="literal">PhotonPeer</code> class, which sends an operation request to the server).</p></li><li style="list-style-type: disc"><p>It <a id="id132" class="indexterm"></a>implements the <code class="literal">DebugReturn</code>, <code class="literal">OnEvent</code>, and <code class="literal">OnOperationResponse</code> methods to log the values to the console.</p></li><li style="list-style-type: disc"><p>It implements the <code class="literal">OnStatusChange</code> method to detect when the PhotonPeer class has successfully established a connection.</p></li></ul></div><p>This is really all that is needed for basic communication with a Photon Server. You can handle connection/disconnection with <code class="literal">OnStatusChange</code>, send messages to the server with the <code class="literal">OpCustom</code> method, and receive messages with <code class="literal">OnOperationResponse</code> and <code class="literal">OnEvent</code>.</p></div>