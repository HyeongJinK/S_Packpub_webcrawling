<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec75"></a>Implementing waypoints – the second/dynamic way</h2></div></div><hr /></div><p>In this section, we will explore a second way to implement the waypoint system of our game. Of course, the outcome will be the same, but this approach offers many other advantages. First of all, it's easier for designers to collocate, change, move, and replace waypoints within the map itself. Second, it allows a great flexibility in behaviors, which can be implemented in such a way to make it easier for designers to use the script created. We will exploit some of the potentiality of this system later in the last chapter of the book.</p><p>Nonetheless, this approach does suffer from some drawbacks, as with every choice in life. In particular, the complexity of the system increases. Moreover, it uses a different game object for each one of the waypoints, and this is critical if the number of waypoints is really high.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note97"></a>Note</h3><p>To overcome this last problem of having different game objects for each of the waypoints, we have many possibilities, but making each one of them work is a challenge and at the same time, easy for designers to use. In fact, waypoints can still be stored as a list, not as positions this time, but rather of the <code class="literal">waypoint</code> class, and at the same time expose functionalities to allow designers to edit and place them within the <span class="strong"><strong>Scene</strong></span> view. This is left as a challenge in the <span class="emphasis"><em>Homework</em></span> section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec82"></a>Implementing waypoints as separate entities</h3></div></div></div><p>So far, we have seen a simple implementation of the waypoints. Now, we will implement them again, but this time as separate entities. As such, in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>What Is beyond the Cake?</em></span>, we will explore how to unlock the potential of waypoints in a game. In fact, at the end of this section, the effect on our game will be the same; however, we will change the script in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>What Is beyond the Cake?</em></span>, by implementing more features.</p><p>First of all, we need to erase the <code class="literal">waypoints</code> variable from the <code class="literal">GameManagerScript</code> (but don't erase the script, even if it is empty, because we will use it; for the same reasons, don't erase the <code class="literal">gameManager</code> variable from the <code class="literal">PandaScript</code>).</p><p>Now, we need to create a new script, which will be the actual waypoint. As such, we can rename it as <code class="literal">Waypoint</code>.</p><p>We need a variable of the same class to store the next waypoint. In this way, each waypoint will be able to point/reference towards another waypoint. The goal is to build a chain which the Pandas will follow. Since the variable is private but we still need to have access to it in the <span class="strong"><strong>Inspector</strong></span>, we need to add the serializable property. So, we can add the following to our script:</p><pre class="programlisting">
<span class="emphasis"><em>//Private variable to store the next waypoint in the chain &#13;
//It is serializable, so it can be set in the Inspector</em></span> &#13;
[SerializeField] &#13;
private Waypoint nextWaypoint; &#13;
</pre><p>Now, from the waypoint, a Panda would like to retrieve its position and the next waypoint to follow, once the current one is reached. To achieve this, we can expose two functions from our <code class="literal">Waypoint</code> script.</p><p>The <code class="literal">GetPosition()</code> function will return a <code class="literal">Vector3</code> with the position of the waypoint, which (in this specific implementation) is stored in the Transform of the waypoint. The code is the following:</p><pre class="programlisting">
<span class="emphasis"><em>//Function to retrieve the position of the waypoint</em></span> &#13;
public Vector3 GetPosition() { &#13;
  return transform.position; &#13;
} &#13;
</pre><p>The <code class="literal">GetNextWaypoint()</code> function, instead, will return just the next waypoint (at least for the moment), stored in the <code class="literal">nextWaypoint</code> variable. In fact, the <code class="literal">nextWaypoint</code> variable is private, and so Pandas need a function to retrieve it. Therefore, we can just write the following:</p><pre class="programlisting">
<span class="emphasis"><em>//Function to retrieve the next waypoint in the chain</em></span> &#13;
public Waypoint GetNextWaypoint() { &#13;
  return nextWaypoint; &#13;
} &#13;
</pre><p>We have finished with this script for now, so we can save it.</p><p>The next step is to create a Prefab for our waypoints. Create an empty GameObject and attach the <code class="literal">Waypoint</code> script. Then, in the <span class="strong"><strong>Project</strong></span> panel, create a Prefab called <code class="literal">WaypointPrefab</code> and drag and drop the empty GameObject you have created. Finally, erase the empty GameObject from the scene, since now we have our Prefab.</p><p>Drag and drop as many Prefabs as the number of waypoints you have identified; in our example, there are 11. For your convenience, I suggest you rename them in a progressive order, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_05.jpg" /></div><p>Now, we need to link them to each other. In particular, <code class="literal">waypoint1</code> will be linked to <code class="literal">waypoint2</code>, which will be linked to <code class="literal">waypoint3</code>, and so on. For instance, <code class="literal">waypoint4</code> should look linked in the <span class="strong"><strong>Inspector</strong></span> as follows:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_06.jpg" /></div><p>The only exception is in the last waypoint, which has nothing in the <code class="literal">nextWaypoint</code> variable, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_07.jpg" /></div><p>Finally, we need to place them at the coordinates we have identified in the <span class="emphasis"><em>Getting the waypoint coordinates</em></span> section. To quickly recognize them, I recommend that you add a Gizmo icon. As the name suggests, a Gizmo is an icon that will be shown in the Scene view to quickly and easily recognize specific objects, but won't be visible once the game is built. Recently, Unity added also the possibility to see them within the <span class="strong"><strong>Game</strong></span> view.</p><p>The easiest way to insert a Gizmo is by clicking the cube-shaped icon next to the name of the GameObject, highlighted in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_08.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note98"></a>Note</h3><p>The same holds for Prefabs, but their icon is a blue cube.</p></div><p>Once you have clicked on this icon, a menu appears as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_09.jpg" /></div><p>By selecting one of the ellipse-shaped icons, you will place a label to the object with its name in it. We will choose one of these for our waypoints. If you click on the circle-shaped or crystal-shaped icons, the Gizmo will look like a circle or a crystal, without any text. If you click the <span class="strong"><strong>Other…</strong></span> button, you can use your own graphics.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note99"></a>Note</h3><p>A more complex way to insert Gizmos is through scripting. In fact, there is a special function called <code class="literal">OnDrawGizmos()</code> which is called by Unity when rendering Gizmos is enabled. Within this function, you are able to use any of the functions listed at <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Gizmos.html" target="_blank">https://docs.unity3d.com/ScriptReference/Gizmos.html</a>, which allow you to draw shapes on the screen. This is a very powerful tool, because it can enhance tremendously the usability of your scripts. For instance, in our specific case of waypoints, we could draw the path that Pandas will follow. This is left as an exercise in the <span class="emphasis"><em>Homework</em></span> section.</p></div><p>In our case, we can select one of the ellipse-shaped icon for all the waypoints. As a result, we are able to see them in the <span class="strong"><strong>Scene</strong></span> view (even if they don't have any explicit rendering component and thus they won't be visible in any way in the final game) and quickly place them.</p><p>At the end, your <span class="strong"><strong>Scene</strong></span> view should look like the following:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_10.jpg" /></div><p>Now, we need to specify to the game, which one of these waypoints is the first of the chain. As such, we can store this information within the <code class="literal">Game Manager</code>. So, let's add the following variable to the <code class="literal">GameManagerScript</code>:</p><pre class="programlisting">
<span class="emphasis"><em>//The first waypoint of the chain</em></span> &#13;
public Waypoint firstWaypoint; &#13;
</pre><p>Finally, after having saved the script, set the variable in the <span class="strong"><strong>Inspector</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_11.jpg" /></div><p>In conclusion, we have created a chain of waypoints, which is exactly what we need for our game. However, we still need to define how the Pandas get to them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec83"></a>Moving along the designed path – dynamic</h3></div></div></div><p>The next step is to slightly modify the <code class="literal">PandaScript</code> to take care of this new waypoint system. So, let's open the script again.</p><p>First, we need to substitute the integer variable, <code class="literal">currentWaypointNumber</code>, with a proper waypoint variable, as shown here:</p><pre class="programlisting">
<span class="emphasis"><em>//Private reference to the current waypoint</em></span> &#13;
private Waypoint currentWaypoint; &#13;
</pre><p>Then, we need to initialize this new variable; we can do it in the <code class="literal">Start()</code> function, by retrieving the first waypoint from the <code class="literal">Game Manager</code>, as shown here:</p><pre class="programlisting">
<span class="emphasis"><em>//Get the first waypoint from the Game Manager</em></span> &#13;
currentWaypoint = gameManager.firstWaypoint; &#13;
</pre><p>Then, in the first check of the <code class="literal">FixedUpdate()</code> function, we need to check if the variable itself is null (which means that the Panda has reached the cake, because the last waypoint will return a null pointer). Here is the code, with the modified parts highlighted:</p><pre class="programlisting">if (<span class="strong"><strong>currentWaypoint == null</strong></span>) { &#13;
  animator.SetTrigger(AnimEatTriggerHash); &#13;
  Destroy(this); &#13;
  return; &#13;
} &#13;
</pre><p>Going on in the <code class="literal">FixedUpdate()</code> function, we need to change how the distance is calculated, by using the <code class="literal">GetPosition()</code> function of our waypoint in the following way:</p><pre class="programlisting">float dist = Vector2.Distance(transform.position,&#13;
  <span class="strong"><strong>currentWaypoint.GetPosition()</strong></span>); &#13;
</pre><p>Finally, we need to change the last <code class="literal">if</code> statement of the <code class="literal">FixedUpdate()</code> function to get the next waypoint when the previous one is reached. We also need to decide which parameter we should give to our <code class="literal">MoveTowards()</code> function. Again, the modified parts are highlighted:</p><pre class="programlisting">if(dist &lt;= changeDist) { &#13;
  <span class="strong"><strong>currentWaypoint = currentWaypoint.GetNextWaypoint();</strong></span> &#13;
}else { &#13;
  MoveTowards(<span class="strong"><strong>currentWaypoint.GetPosition()</strong></span>); &#13;
} &#13;
</pre><p>Save the script. We have finished this second way of implementing waypoints. <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>What Is beyond the Cake?</em></span>, will suggest some ways to take advantage of this structure to implement more complex behaviors.</p></div></div>