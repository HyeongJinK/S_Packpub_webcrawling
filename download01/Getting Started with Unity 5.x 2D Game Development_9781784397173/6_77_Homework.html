<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec77"></a>Homework</h2></div></div><hr /></div><p>In this chapter, we gained an overview of AI in games. However, we focused only on navigation, and in particular, implementing the waypoint system for our game. But you can still improve it, and this section proposes some exercises to achieve that. Therefore, before the next chapter, I invite you to do the following exercises to develop your skills even more:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p><span class="strong"><strong>Becoming an AI designer and programmer</strong></span>: Think of five games that you play, and select a part of that game that contains NPCs such as the enemies or even the boss. Now, write down a list of behaviors that each of them have. Now, remove some behaviors, or even add some and think about how it would alter the experience. Does it improve it, or does it change the atmosphere entirely? Could you make a relatively realistic behavior into intelligent, yet not realistic, by changing some of the behaviors, and vice versa? By doing this, you will begin to understand the importance that some behaviors play in not only providing life to your characters, but in also giving emotions to the player.</p></li><li><p><span class="strong"><strong>Waypoints as colliders</strong></span>: From the previous chapter, we learnt how to use colliders and detect collisions. In particular, we saw how the sprinkles collided with Pandas to trigger actions (in this case, to shoot down the Panda). However, the same principle can be applied here as well. Instead, to use the <code class="literal">changeDist</code> constant and check the distance from the Panda to the waypoint, we can use the <code class="literal">OnTriggerEnter2D()</code>Â function again to check when a Panda has reached a waypoint. Implement the changing of waypoints in this way, regardless of whether you are using the first or second implementation. Little hint: you probably need to set a new tag (remember how to set a tag from <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Baking Cupcake Towers</em></span>?) for the waypoints, and add colliders on them too.</p></li><li><p><span class="strong"><strong>Waypoints that auto-reach themselves</strong></span>: In more complex waypoint systems, you shouldn't manually create the chain (even though the solution becomes hard to scale when the map becomes bigger). As such, try to design and implement a system where the waypoints auto-connect themselves once placed.</p></li><li><p><span class="strong"><strong>Create a Gizmo path displayer</strong></span>: Back in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Baking Cupcake Towers</em></span>, we saw how it was possible to use some Gizmo functions to draw useful stuff on the scene. Use those functions, and in particular <code class="literal">Gizmos.DrawLine()</code>, to show the chain of waypoints on the <span class="strong"><strong>Scene</strong></span> view.</p><p>And finally, there is a challenge for you:</p></li><li><p><span class="strong"><strong>Easy waypoint</strong></span>: In the second implementation, we use a different game object for each one of the waypoints. Design and implement a system that is as easy as the one implemented in this chapter for designers (so they can drag around the waypoints in the <span class="strong"><strong>Scene</strong></span> view, and possibly see the chain from the previous exercise), but at the same time is efficient, since it won't use game objects for waypoints (but rather an array stored somewhere).</p></li></ol></div></div>