<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec88"></a>Techniques we learnt in this chapter</h2></div></div><hr /></div><p>If you have reached this point of the chapter and book, it means that your game is completed. Let's recap what we have learnt in terms of techniques, instead of topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Inheritance</strong></span>: We have implemented our trading system by using inheritance, and this gave us the possibility to explore it. In particular, we learnt a bit more about:
</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Abstract classes and methods</strong></span>: So that their full implementation is left to child classes</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Protected variables</strong></span>: Which can be seen by some scripts but not all of them</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>UI handlers</strong></span>: Can be automatically linked to have an interaction with the UI without settings events in the <span class="strong"><strong>Inspector</strong></span></p></li></ul></div></li><li style="list-style-type: disc"><p><span class="strong"><strong>Interaction between mouse and camera</strong></span>: To implement the placing script, we needed to transform the mouse coordinates into game coordinates.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Enabling/disabling scripts</strong></span>: To implement functionalities, always in the placing script, we learnt how it is possible to disable and enable scripts to trigger functionalities when they are needed.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Storing information</strong></span>: Within the <code class="literal">Game Manager</code>, we learnt how other scripts can have access to them. Throughout all the chapters we have done this, and in different ways. In particular, we used public functions on the <code class="literal">Game Manager</code> that have been called by the other scripts. As a result, the <span class="strong"><strong>Game Manager</strong></span> became a hub to exchange data between the different parts of the game.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Using static functions</strong></span>: To assign generic variables again, in the trading system, we have implemented a static function to set the active tower. As a result, any script can have access to that function without the need to get a reference to the specific trading class instance (moreover the parent class is abstract so it doesn't have instances). This could have been done without many problems, because the variable assigned was already static and shared among all the instances of the trading classes.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Implementing coroutines</strong></span>: To handle events that last over time<span class="emphasis"><em>Â </em></span>in implementing the spawning system, we have used coroutines. These are special functions which have the possibility to be interrupted and continue in other frames of the game. This is the most powerful tool we have seen in this chapter, although it requires a bit more practice than other tools to master it, but it is definitely worth it.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Using UI events</strong></span>: To implement the functions, in our main menu, we have implemented functions within a script to be triggered by the <code class="literal">OnClick()</code> event of the buttons. In this way, you avoid using UI handlers. The advantages of this method is that you can place all the functions within a single script and have a specific instance of that script to trigger (in case the script can be instantiated). On the other hand the disadvantage is that a lot of manual work for linking the events in the <span class="strong"><strong>Inspector</strong></span> is required. UI handlers, on the contrary, have advantages and disadvantages flipped. As such, UI handlers are suitable for big scripts with many functions implemented in that which require a bit of interaction with the UI. For small functions, instead, it is better to have them all in a single script that creates a different script for each one of them. In any case, the best solution depends on the situation and which one is your goal.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Using colliders to identify zones</strong></span>: We used the physics engine to detect if the mouse is hovering over certain zones when placing cupcake towers is allowed. Moreover, we used a collider on the cupcake towers to detect a click on it (so as to be selected) and to avoid placing other cupcake towers on top of others. These are just one of the many ways to use the Physics engine for non-physics related calculations.</p></li></ul></div><p>I hope you have learnt a lot in this chapter, and that you have grasped the basic concepts of each of the different techniques we have used. To improve both the game and your skills, I invite you do the exercises in the following section.</p></div>