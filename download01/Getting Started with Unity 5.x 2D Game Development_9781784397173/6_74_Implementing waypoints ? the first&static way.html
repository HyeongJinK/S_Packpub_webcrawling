<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec74"></a>Implementing waypoints – the first/static way</h2></div></div><hr /></div><p>Now that we have all the waypoint coordinates, we can implement them. In this section, we will explore the first way to implement them. The main advantage of this method is the simplicity of the implementation and the possibility to learn more about static variables and iterating over waypoints.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec80"></a>Implementing waypoints in the Game Manager</h3></div></div></div><p>In this first implementation of waypoints, they won't be separate entities in the game, but rather a collection of positions in a specific order. All the enemies will consult this list, and based on which waypoint they are currently at, take the next one in the list.</p><p>Of course, this method has some limitations such as we won't be able to implement custom features in the waypoints, as we will see in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>What Is beyond the Cake?</em></span>. However, it is simpler to implement, and it gives us the opportunity to explore how to use static variables.</p><p>First of all, we need to create another script, and call it <code class="literal">GameManagerScript</code>. We will implement more functionality in this script in the next chapter. But at the moment, it is needed to store the waypoints. In fact, for now, we just need to add an array of positions, so you can write the following in the script:</p><pre class="programlisting">
<span class="emphasis"><em>//public waypoint list as an array of positions</em></span> &#13;
public Vector3[] waypoints; &#13;
</pre><p>It is a <code class="literal">Vector3</code> array, which basically just stores a set of positions in a specific order. Save the code, and create an empty GameObject in the <span class="strong"><strong>Scene</strong></span>, which you can rename <code class="literal">Game Manager</code>. Attach the script on it, and in the <span class="strong"><strong>Inspector</strong></span> you should see something like the following:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_02.jpg" /></div><p>We need to set the number of elements of our array with the number of waypoints we have found, in this case 11. Therefore, our <span class="strong"><strong>Inspector</strong></span> looks like the following:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_03.jpg" /></div><p>Finally, we can fill all those values with our waypoint positions. But what about the <span class="emphasis"><em>z</em></span>-axis? Since we don't want the Pandas to change their <span class="emphasis"><em>z</em></span>-axis, we can just set its value to the same <span class="emphasis"><em>z</em></span>-axis value of our <code class="literal">PandaPrefab</code>, which is <code class="literal">-1</code>. At the end, we should have something like this:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_06_04.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note95"></a>Note</h3><p>The reader may wonder if it was worthwhile using <code class="literal">Vector2</code> instead of <code class="literal">Vector3</code>. The answer is: it's your choice. Nothing prevents you from using <code class="literal">Vector2</code> and forgetting about <code class="literal">Vector3</code>. But, since we have made the choice to handle the depth of our game with z-buffering, I personally prefer to have direct control over the <span class="emphasis"><em>z</em></span>-axis as well, so be sure to achieve the intended behavior.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec81"></a>Moving along the designed path – static</h3></div></div></div><p>Next, we need to give an opportunity for the enemies to have access to the waypoints stored in the <code class="literal">GameManagerScript</code>. Therefore, we need to get a reference it. There are many ways to do so, but for learning's sake, we will use a static variable (so as to unravel the use of such variables). In fact, all the Pandas share the same game manager, and it's a waste of computational resources if every time a Panda is created, it needs to search for the <code class="literal">Game Manager</code>. A static variable is a value which is shared among all the instances of the <code class="literal">PandaScript</code>. Of course, we need to be careful not to assign this variable many times.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note96"></a>Note</h3><p>Remember that static variables are persistent over different scenes/levels. Therefore, if you are planning to release a game with more than one level, most likely you will need to reset this variable when the level is changed. We will explore this better in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>What Is beyond the Cake?</em></span>.</p></div><p>Open the <code class="literal">PandaScript</code>, and let's add the static variable to store the reference to the <code class="literal">Game Manager</code>:</p><pre class="programlisting">
<span class="emphasis"><em>//Private static variable to store the Game Manager</em></span> &#13;
private static GameManagerScript gameManager; &#13;
</pre><p>At the beginning of the <code class="literal">Start()</code> function we need to check if another instance (another Panda) has already been assigned this variable. If not, we will assign it by finding its reference in the scene, even though there will only be one game manager in the scene at the time. As a result, this Panda will actually initialize the variable. As such, all the other instances of Pandas that will be created will have a reference to the <code class="literal">Game Manager</code> ready, and thanks to this check, we are sure that we are assigning it only once:</p><pre class="programlisting">
<span class="emphasis"><em>//If the reference to the Game Manager is missing, the script gets it</em></span> &#13;
if(gameManager == null) { &#13;
  gameManager = FindObjectOfType&lt;GameManagerScript&gt;(); &#13;
} &#13;
</pre><p>Now, we have to make the Panda move. But first, we need a variable to store the current waypoint that the Panda is heading towards:</p><pre class="programlisting">
<span class="emphasis"><em>//Private counter for the waypoints</em></span> &#13;
private int currentWaypointNumber; &#13;
</pre><p>Then, we need a constant to establish a threshold after which the waypoint is considered as having been reached. In fact, there are numerical instabilities, and we cannot check directly if the distance from the waypoint is actually zero, only a value very close to it. As you can see, the value assigned to this constant is very low:</p><pre class="programlisting">
<span class="emphasis"><em>//Private constant under which a waypoint is considered reached</em></span> &#13;
private const float changeDist = 0.001f; &#13;
</pre><p>Finally, we need to implement the mechanism under which the Panda heads towards the right waypoint, and changes direction to the next one when the previous is reached. Since the <code class="literal">MoveTowards()</code> function we will use to move the Panda deals with physics, we need to implement this whole mechanism of the waypoints within the <code class="literal">FixedUpdate()</code> function, as we learnt from <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>The Secret Ingredient Is a Dash of Physics</em></span>. So, we can start writing the following:</p><pre class="programlisting">void FixedUpdate() { &#13;
  <span class="emphasis"><em>//Add here the rest of the code of this section</em></span> &#13;
} &#13;
</pre><p>In particular, we need to do three things within the <code class="literal">FixedUpdate()</code> function. The first one is to check if the Panda has reached the end of the waypoint list, which means it is in front of the delicious player's cake. If so, we need to trigger the eat animation in the same fashion we triggered the others in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>No Longer Alone – Sweet-Toothed Pandas Strike</em></span>. Then, we need to remove this script from the Panda. In fact, the <code class="literal">State Machine Behaviour</code> script we wrote in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>No Longer Alone – Sweet-Toothed Pandas Strike</em></span>, will take care of removing the Panda from the scene. Finally, we return so that the rest of the function is not executed:</p><pre class="programlisting">
<span class="emphasis"><em>//if the Panda has reached the cake, then it will eat it, by triggering&#13;
  the right animation,</em></span>
<span class="emphasis"><em>//and remove this script, since the State Machine Behaviour will take&#13;
  care of removing the Panda</em></span> &#13;
if (currentWaypointNumber == gameManager.waypoints.Length) { &#13;
  animator.SetTrigger(AnimEatTriggerHash); &#13;
  Destroy(this); &#13;
  return; &#13;
} &#13;
</pre><p>The second thing, in case the Panda is not at the last waypoint yet, is to calculate the distance between the current Panda's position, through its Transform, and the waypoint it is heading towards. This value is stored within a local variable <code class="literal">dist</code>:</p><pre class="programlisting">
<span class="emphasis"><em>//Calculate the distance between the Panda and the waypoint that the&#13;
  Panda is moving towards</em></span> &#13;
float dist = Vector2.Distance(transform.position,&#13;
  gameManager.waypoints[currentWaypointNumber]); &#13;
</pre><p>The last thing is to check if the Panda is close enough to the waypoint. Enough means below the constant threshold stored in the <code class="literal">changeDist</code>. If so, we just increase the counter of the waypoints so that at the next iteration, the Panda will head to the next waypoint. Otherwise, we just use the <code class="literal">MoveTowards()</code> function implemented in the previous chapter to move the Panda towards the waypoint:</p><pre class="programlisting">
<span class="emphasis"><em>//If the waypoint is considered reached because below the threshold of&#13;
  the constant changeDist</em></span>
<span class="emphasis"><em>//the counter of waypoints is increased, otherwise the Panda moves&#13;
  towards the waypoint</em></span> &#13;
if(dist &lt;= changeDist) { &#13;
  currentWaypointNumber++; &#13;
}else { &#13;
  MoveTowards(gameManager.waypoints[currentWaypointNumber]); &#13;
} &#13;
</pre><p>We can save our script and test it out. By placing a Panda in the scene somewhere near the first waypoint and pressing play, we will see it moving along the path.</p></div></div>