<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec64"></a>Other things about Physics</h2></div></div><hr /></div><p>As with other chapters, this is an optional section with some deeper insights into the topic covered in the chapter. So, feel free to skip this section if you are not interested, and jump directly onto the next section. Otherwise, just grab some more coffee and keep reading.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec72"></a>The Simulate setting on rigidbodies</h3></div></div></div><p>This aim of this section is to explain the difference between enabling and disabling physical components on a rigidbody and enabling and disabling the <span class="strong"><strong>Simulate</strong></span> settings on top of the rigidbody component.</p><p>Every time that a physical component is either added, enabled, removed, or disabled, the internal memory of the Physics engine is updated (respectively to add or remove the component from the memory). When the <span class="strong"><strong>Simulate</strong></span> setting is disabled, the Physics engine just stops to perform calculations on it - it doesn't erase the object from the memory. As a result, when <span class="strong"><strong>Simulate</strong></span> is checked back, the Physics engine has already all the objects/components in the memory and it doesn't' need to create them from scratch, thus leading to a performance improvement.</p><p>Of course, if you need to remove a rigidbody permanently from the scene, then just erase the component, because if you just uncheck <span class="strong"><strong>Simulate</strong></span>, the component will still be in memory, leading to a poor memory management.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec73"></a>Physics Raycaster 2D component</h3></div></div></div><p>Back in Chapter 3, <span class="emphasis"><em>Communicating with the Player – the User Interface</em></span>, we have seen the Unity UI system, and in the optional section there were the different components of a canvas. One of them was the <span class="strong"><strong>Graphical Raycaster</strong></span>, which is able to detect the input of the user on the screen. This component checks if the player actually went over a slider or clicked a button, and then triggers events by exchanging messages with the event system.</p><p>If we have physics objects and we want to exchange events about them in a similar way the <span class="strong"><strong>Graphical Raycaster</strong></span> does for the UI, we can use a Physics Raycaster 2D component on a camera to handle such events.</p><p>Once this component is added, you can implement different interfaces in the scripts of your physics objects. As a result, the functions that they will implement will be automatically called when the corresponding event is triggered.</p><p>For instance, an event could be that a joint breaks, and you may want to run some code when this happens. Moreover, some information will be provided to the functions; in the case of the joint, the amount of force that broke the joint is passed as a parameter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec74"></a>The other Physics settings</h3></div></div></div><p>Here you can find the other Physics settings:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Velocity Iterations</strong></span>: The number of iterations that are made to determine the velocity of a physical body during an update. The higher is the number, the more accurate the simulation will be. The drawback is computational cost. The default value is <code class="literal">8</code>.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Position Iterations</strong></span>: The number of iteration made to determine the position of a physical body during an update. The higher is the number, the more accurate the simulation will be. The drawback is computational cost. The default value is <code class="literal">3</code>.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Velocity Threshold</strong></span>: Collisions with a relative velocity lower than this value are treated as inelastic collisions, which means that the colliding bodies will not bounce off each other.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Max Linear Correction</strong></span>: The maximum linear position correction used when solving constraints. It can have any value between <code class="literal">0.0001</code> to <code class="literal">1000000</code>. It helps to prevent overshooting.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Max Angular Correction</strong></span>: The maximum angular correction used when solving constraints. It can have any value between <code class="literal">0.0001</code> to <code class="literal">1000000</code>. It helps to prevent overshooting.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Max Translation Speed</strong></span>: This is the maximum (translation) speed that a body in your game could have. This value is the upper limit, which means that every object that tries to reach faster velocities, will be cap to this value.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Max Rotation Speed</strong></span>: This is the maximum (rotation) speed that a body in your game could have. The same reasoning as before applies, just with rotations instead of translations.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Min Penetration For Penalty</strong></span>: The minimum contact penetration radius allowed before any separation impulse force is applied.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Baumgarte Scale</strong></span>: This is a scale factor that determines how fast collision overlaps are resolved (see the information box).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Baumgarte Time Of Impact Scale</strong></span>: A scale factor that determines how fast time-of-impact overlaps are resolved (see the information box).</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note87"></a>Note</h3><p>Baumgarte's constraint stabilization method (sometimes just abbreviated to Baumgarte's method) is an algorithm for resolving certain collision constraints, such as with joints, invented by J. Baumgarte in 1972. It is fast enough so that it can be used in real-time applications such as video games or robotics. The trick consists of taking advantage of some derived analytic forms of differential equations that are solved numerically. This allows you to run the algorithm not only faster than its predecessors but also with a higher degree of accuracy.</p><p>The <span class="strong"><strong>Baumgarte Scale</strong></span> is the important parameter for the algorithm, which represents the correction ratio to apply. A common value, which is often given as default, is <code class="literal">0.2</code> and it is also the default value that Unity uses.</p><p>The higher the value, the more your joints will go wild. On the other hand, the lower the value, the less your joints will do, and it can cause sponginess.</p></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Queries Hit Trigger</strong></span>: This is a toggle that if true allows raycasts to hit also trigger volumes. By default, it is true, but can be unchecked in case you don't want raycasting to hit trigger volumes, but just colliders. When to uncheck this box really depends on the design of your game, and what you have in mind to program it.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_058.jpg" /><div class="caption"><p>When Queries Hit Trigger is set to false (upper part of diagram<span class="emphasis"><em>)</em></span>, trigger volumes won't be detected by raycasting. On the contrary, when Queries Hit Trigger is set to true (lower part of diagram), also trigger volumes will be detected by raycasting and returned as a hit.</p></div></div></li><li style="list-style-type: disc"><p><span class="strong"><strong>Queries Start In Collider</strong></span>: This is a toggle that, if true, allows raycasts that start within a collider to what hit that collider. By default, it is true, but can be unchecked if many of your raycasts start within a collider and you don't want them to be returned as hits. Again, when to uncheck this box really depends on the design of your game, and also you have in mind to program it.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_059.jpg" /><div class="caption"><p>When Queries Start In Collider is set to false (upper part of diagram) and the the source of the raycast is within a collider, this one won't be returned as a hit. On the contrary, when Queries Start In Collider is set to true (lower part of diagram), also the collider in which there is the source of the raycast is returned as a hit.</p></div></div></li><li style="list-style-type: disc"><p><span class="strong"><strong>Change Stops Playback</strong></span>: This is a toggle that, if true, stops reporting collision callbacks immediately if any of the GameObjects involved in the collision are deleted or moved. By default, it is false.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Gizmos</strong></span>: (The description of this foldout is in the next section.)</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec67"></a>Gizmos for colliders</h4></div></div></div><p>This section describes the previous menu item, <span class="strong"><strong>Gizmos</strong></span>, in the <span class="strong"><strong>Physics 2D</strong></span> settings.</p><p><span class="strong"><strong>Gizmos</strong></span> is a foldout that shows you extra options about the visualizations of colliders within the editor. These options are really useful in debugging. This is how it appears in the <span class="strong"><strong>Inspector</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_060.jpg" /></div><p>Here is an explanation of the options displayed and their usage:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Always Show Colliders</strong></span>: By default, you are able to see a collider only when a game object (or one of its children) contains such a collider. If you enable this option, you will always be able to see colliders (whenever <span class="strong"><strong>Gizmos</strong></span> are visible).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Show Collider Sleep</strong></span>: When enabled, it allows you to see a collider even when it is in sleep mode within the Physics engine</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Collider Awake Color</strong></span>: This specifies the color that awake (no-sleeping) colliders should have when shown. By default, it is a light green with the alpha channel (opacity) set to <code class="literal">192</code>.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Collider Sleep Color</strong></span>: This specifies the color that sleeping colliders should have when shown. By default, it is the same light green as when the collider is awake, but with the alpha channel (opacity) set to <code class="literal">92</code>.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Show Collider Contacts</strong></span>: When enabled, this allows you to see the contacts point of the colliders when they collide. They are shown as arrows (as shown in the next diagram).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Contact Arrow Scale</strong></span>: This value allows you to scale down the arrow showed by the contact points of the collider. By default, its value is <code class="literal">0.2</code> (as shown in the next diagram).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Collider Contact Color</strong></span>: This specifies the color of such arrows representing the contact points of the collider. By default, it is set to light purple (as shown in the next diagram):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_061.jpg" /></div><p>On the left there are two colliders that are overlapping with each other. In the middle, the colliders are updated by the Physics engine to simulate the collisions (since they cannot overlap). Also shown are the points of contact between the two arrows. On the right, there is the same diagram that is in the middle, but with the <span class="strong"><strong>Contact Arrow Scale</strong></span> set to <code class="literal">0.6</code> instead of <code class="literal">0.2</code>, and as a result the arrows are bigger.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Show Collider AABB</strong></span>: When enabled, this allows you to see the <span class="strong"><strong>Axis-Aligned Bounding Box</strong></span> (<span class="strong"><strong>AABB</strong></span>) of the collider. As the name suggests, it is a box that fully contains the collider, and it is aligned with the axis of the world frame. For example, the bounding box of a polygonal collider is the following (on the left):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_062.jpg" /></div></li></ul></div><p>On the left is the polygonal collider with its AABB; on the right is the same diagram as the previous one, but showing its AABB.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Collider AABB Color</strong></span>: This specifies the color of the AABB of the collider, when shown</p></li></ul></div></div></div></div>