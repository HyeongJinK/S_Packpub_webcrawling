<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec56"></a>The Unity Physics engine</h2></div></div><hr /></div><p>Unity has a Physics engine integrated into it, which is able to handle both kinematic and dynamic types of rigid bodies as well as other physical entities such as clothes. It is divided into two parts: 2D Physics and 3D Physics. It's important to understand that although they can coexist together in the same scene, they are two separate entities; they cannot communicate between themselves. Physical objects under 2D Physics will not interact with physical objects under 3D Physics.</p><p>In this section, we will explore most of the 2D Physics engine of Unity. Although we will not use all the components presented here, it's important to master them all to become a better Unity developer.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec57"></a>Understanding Physics in Unity</h3></div></div></div><p>In Chapter 2, <span class="emphasis"><em>Cooking Cupcake Towers, </em></span>we learnt about script ordering and how it is executed. The first question we may wonder is when does the Physics engine occur when a frame is rendered? The answer is not straightforward, because the Physics engine runs multiple times during a frame render. In any case, except particular cases (such as the application has paused or particular game objects are enabled/disabled in that frame), the Physics engine runs after the initialization (so all the <code class="literal">Awake()</code>, <code class="literal">Start()</code>, and <code class="literal">OnEnable()</code> functions) and before to gather inputs from the player and update the game logic.</p><p>As a result, when we do a physics calculation (we will see these later in the chapter), we need to use the <code class="literal">FixedUpdate()</code> function, which is called more than once per frame, and all the times just before the Physics engine performs its calculation. As such, if we need to retrieve the time, we cannot use <code class="literal">Time.deltaTime</code>; instead we need to use <code class="literal">Time.fixedDeltaTime</code>.</p><p>Another question we may wonder is when it is appropriate to use the Physics engine of Unity. In theory, you don't need to use it, because you can program from scratch all the collisions and/or physic behaviours. In practice, it solves many common problems with minimum coding and it is indeed useful. These problems are not necessarily physics problems. In fact, some of them include certain game mechanics that may enhance the quality of your game when using a physics approach (such as the movement of the character). Others include gathering information from the environment for scripting other behaviours (such as a script that needs to know how many targets there are within a zone).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec58"></a>Physics settings in Unity</h3></div></div></div><p>First of all, the Physics engine of Unity has some general settings, which should be taken into account. They define global physical properties of your game, such as the value of gravity, what will collide with what, and how accurate the Physics simulation should be.</p><p>You can have access to the Physics settings in Unity by navigating through <span class="strong"><strong>Edit | Project Settings | Physics 2D</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_008.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note62"></a>Note</h3><p>Similarly, you can have access to the 3D Physics setting by navigating through <span class="strong"><strong>Edit | Project Settings | Physics</strong></span>.</p></div><p>The following screen will appear in the <span class="strong"><strong>Inspector</strong></span> view (the most important parameters are highlighted, which we will see in detail in this section):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_009.jpg" /></div><p>As you can see, there are many options you can tweak. Most of the time, especially for simple games (like the one we are building), the default settings will be more than fine. But Unity offers you the chance to adapt them to your game.</p><p>Most of them deal with how accurate the Unity Physics engine is. Therefore, there is a trade-off between accuracy and efficiency, since more accurate means more expensive from a computational point of view.</p><p>Let's go through the main ones in detail (if you are interested in learning also about the others, see the optional, <span class="emphasis"><em>Other things about Physics</em></span> section later in the chapter):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Gravity</strong></span>: The vector that defines the gravity acceleration. By default, it is a negative value only along the <span class="emphasis"><em>y-</em></span>axis. In particular, the absolute value of 9.81 corresponds to the one on the Earth, if we let the Unity units be meters.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Default Material</strong></span>: The physical material used by all the colliders and rigidbodies that don't have one set (we will see more about physical materials later on).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Time To Sleep</strong></span>: The time, expressed in seconds, that needs to pass before a Rigidbody 2D goes to sleep, which means that it is not updated anymore by the Physics engine (we will see more about rigidbodies and their sleeping later on).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Linear Sleep Tolerance</strong></span>: This is the linear speed below which the rigidbody after <span class="strong"><strong>Time to Sleep</strong></span> goes to sleep. Imagine you have many objects in your game that drag is slowing down, and now they are so slow that the player can barely perceive their motion. As such, it's a waste of computational resources to keep them updated in the Physics engine. Therefore, this variable puts a limit to the lowest velocity an object can have before it goes to sleep (no more updates from the Physics engine). The lower this value, the more accurate the simulation will be, but it will also be more expensive if many objects are moving at velocities above that one.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Angular Sleep Tolerance</strong></span>: The angular speed below which the rigidbody after <span class="strong"><strong>Time to Sleep</strong></span> goes to sleep. Imagine the same situation as before, but instead the body is rotating really slowly. The same reasoning applies: the lower the value, the more accurate the simulation, but usually it is more expensive.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Layer Collision Matrix</strong></span>: This determines which kinds of objects collide with others. By default, everything is checked, but you may want to make two particular kinds of objects not collide among them. Objects are discriminated based on the physical layer they are in. If you remember, we talked about layers and tags in Chapter 1, <span class="emphasis"><em>A Flat World in Unity</em></span>. So, through the layer menu, you can create new layers, and in the <span class="strong"><strong>Inspector</strong></span>, you can assign a layer to a particular game object. To make things easier, the <span class="strong"><strong>Layer Collision Matrix</strong></span> is presented in this screenshot:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_010.jpg" /></div><p>For our game, we can leave all the default values since they are more than fine for what we need.</p></div></div>