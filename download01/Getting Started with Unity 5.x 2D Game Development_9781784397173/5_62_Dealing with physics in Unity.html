<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec63"></a>Dealing with physics in Unity</h2></div></div><hr /></div><p>So far, everything went smooth and we learned about all the single components of the Physics engine of Unity. However, when it comes to building your own game, dealing with physics might be a little bit tricky. In fact, just some wrong values on some forces and the whole scene can quickly mess up. The best way to solve this is by trial and error. The more you experiment, the more you will become practical with the Physics engine, and you will develop an intuition on how to balance all the values in your game. As a result, you will be able to make your scene act as described in the game design document (or almost).</p><p>Dealing with physics isn't just about placing the different components, but also about how to program them. We have already seen some useful functions to apply on a rigidbody as well as some events when two colliders hit each other. But there is more. First of all, it's important to understand that all the variables we have seen of all the components (such as rigidbodies, colliders, joints, and effectors) can be assigned dynamically at runtime with a script. You just need to get a reference to that component, and then you will be able to change its internal parameters.</p><p>One more thing that can come in handy is the possibility to query the Physics engine through some functions in order to gather some information about the surroundings. These are static functions of the <code class="literal">Physics2D</code> class, and so they can be called with the following fragment of code:</p><pre class="programlisting">Physics2D.NameOfTheFunction(); &#13;
</pre><p>Of course, you need to substitute <code class="literal">NameOfTheFunction</code> with the function. The <code class="literal">Physics2D</code> class exposes many of these, but let's explore just the main ones:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">OverlapCircleAll(Vector2 point, float radius, [<span class="emphasis"><em>optional parameters]</em></span>)</code>: This returns the arrays of <code class="literal">Collider2D</code> which are all within the circle specified by the <code class="literal">radius</code> and <code class="literal">point</code> (the center of the circle) variables. In other words, it detects all the colliders that are within the specified circle. From the collider, it is possible to retrieve the game object itself as well. Our cupcake towers will use this function to detect how many enemies there are around. Furthermore, other optional parameters of the function are available to specify a mask of layers and the min and max values for the depth (<span class="emphasis"><em>z</em></span>-axis) in which the function should search.</p></li><li style="list-style-type: disc"><p><code class="literal">OverlapCircle(Vector2 point, float radius, [<span class="emphasis"><em>optional parameters]</em></span>)</code>: The same function as before, but instead of returning the full array, it returns the first occurrence. It is useful when you just need to detect whether something is present within the circle.</p></li><li style="list-style-type: disc"><p><code class="literal">RaycastAll(Vector2 origin, Vector2 direction, [<span class="emphasis"><em>optional parameters]</em></span>)</code>: This shoots a ray from an <code class="literal">origin</code> towards a <code class="literal">direction</code>, and returns all the different colliders that the ray hits within an array of <code class="literal">RayCastHit2D</code> (see later), which is a class that specifies all the details of the hit, including the collider. This function is useful when you need to verify if something is present somewhere in the space. Furthermore, other optional parameter can specify the maximum distance that the ray can reach, a mask of layers, and the min and max values for the depth (<span class="emphasis"><em>z</em></span>-axis).</p></li><li style="list-style-type: disc"><p><code class="literal">Raycast(Vector2 origin, Vector2 direction, [<span class="emphasis"><em>optional parameters]</em></span>)</code>: The same function as the previous one, but instead of returning the full array, it returns only the first hit.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note86"></a>Note</h3><p>You can find all the functions of the <code class="literal">Physics2D</code> class in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Physics2D.html" target="_blank">https://docs.unity3d.com/ScriptReference/Physics2D.html</a>.</p></div><p>About the <code class="literal">RayCastHit2D</code> class, here is the list of information that we can retrieve:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">centroid</code>: The centroid of the primitive used to perform the cast</p></li><li style="list-style-type: disc"><p><code class="literal">collider</code>: The collider hit by the ray</p></li><li style="list-style-type: disc"><p><code class="literal">distance</code>: The distance from the origin of the ray to the impact point</p></li><li style="list-style-type: disc"><p><code class="literal">fraction</code>: The fraction of the distance along the ray that the hit occurred</p></li><li style="list-style-type: disc"><p><code class="literal">normal</code>: The normal vector of the surface hit by the ray</p></li><li style="list-style-type: disc"><p><code class="literal">point</code>: The point in the world space where the ray hit the collider's surface</p></li><li style="list-style-type: disc"><p><code class="literal">rigidbody</code>: The <code class="literal">Rigidbody2D</code> attached to the object that was hit</p></li><li style="list-style-type: disc"><p><code class="literal">transform</code>: The Transform of the object that was hit</p></li></ul></div><p>In conclusion, querying the Physics engine is a common practice to gather information, and we will do it with our <span class="emphasis"><em>Tower </em></span>Defense game.</p></div>