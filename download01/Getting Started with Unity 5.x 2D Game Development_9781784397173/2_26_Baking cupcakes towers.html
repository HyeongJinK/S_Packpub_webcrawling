<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec30"></a>Baking cupcakes towers</h2></div></div><hr /></div><p>In this section, we will see how to create our towers. This is not an easy task, but by doing this we will acquire a lot of scripting skills.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>What a cupcake tower does</h3></div></div></div><p>First of all, it's useful to write down what we want to achieve and define what exactly a cupcake tower is supposed to do.</p><p>The best way is to write down a list, to have clear idea of what we are trying to achieve:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A cupcake tower is able to detect pandas within a certain range.</p></li><li style="list-style-type: disc"><p>A cupcake tower shoots a different kind of projectile according to its typology against the pandas within a certain range. Furthermore, within this range, it uses a policy to decide which panda to shoot.</p></li><li style="list-style-type: disc"><p>There is a reload time before the cupcake tower is able to shoot again.</p></li><li style="list-style-type: disc"><p>The cupcake tower can be upgraded (to a bigger cupcake!), increasing its stats and therefore changing its appearance.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec18"></a>Scripting the cupcake tower</h3></div></div></div><p>As we have seen in the previous section, there are many things to implement. Let's start by creating a new script and naming it <code class="literal">CupcakeTowerScript</code>. As we already mentioned for the projectile script, in this chapter, we implement the main logic, but of course there is always space to improve, as we will see later in the book.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec8"></a>Shooting to the pandas</h4></div></div></div><p>Even if we don't have enemies yet, we can already start to program the behavior of the cupcake towers to shoot to the enemies. In this section, we will learn a bit about using physics to detect objects within a range. However, we will see colliders in more detail in <a class="link" href="#" linkend="ch04">Chapter 5</a>, <span class="emphasis"><em>No Longer Alone - Sweet-Toothed Pandas Strike</em></span>.</p><p>Let's start by defining four variables. The first three are public, so we can set them in the Inspector. The last one is private, since we only need it to check how much time has elapsed. In particular, the first three variables store the parameters of our tower. There are the projectile Prefab, its range, and its reload time. We can write the following:</p><pre class="programlisting">public float rangeRadius;  <span class="emphasis"><em>//Maximum distance that the Cupcake Tower&#13;
  can shoot</em></span> &#13;
public float reloadTime;   <span class="emphasis"><em>//Time before the Cupcake Tower is able to&#13;
  shoot again</em></span> &#13;
public GameObject projectilePrefab; <span class="emphasis"><em>//Projectile type that is fired&#13;
  from the Cupcake Tower</em></span> &#13;
private float elapsedTime; <span class="emphasis"><em>//Time elapsed from the last time the&#13;
  Cupcake Tower has shot</em></span>
</pre><p>Now, in the <code class="literal">Update()</code> function we need to check if enough time has elapsed in order to shoot. This can be easily done by using an if statement. In any case, at the end, the time elapsed should be increased:</p><pre class="programlisting">void Update () { &#13;
  if (elapsedTime &gt;= reloadTime) { &#13;
    <span class="emphasis"><em>//Rest of the code</em></span> &#13;
  } &#13;
  elapsedTime += Time.deltaTime; &#13;
} &#13;
</pre><p>Within the <code class="literal">if</code> statement, we need to reset the elapsed time, so as to be able to shoot the next time. Then, we need to check whether there are some game objects within its range or not:</p><pre class="programlisting">if (elapsedTime &gt;= reloadTime) { &#13;
 <span class="emphasis"><em> //Reset elapsed Time</em></span> &#13;
  elapsedTime = 0; &#13;
<span class="emphasis"><em>  //Find all the gameObjects with a collider within the range of the&#13;
    Cupcake Tower</em></span> &#13;
  Collider2D[] hitColliders =&#13;
    Physics2D.OverlapCircleAll(transform.position, rangeRadius); &#13;
 <span class="emphasis"><em> //Check if there is at least one gameObject found</em></span>&#13;
  if (hitColliders.Length != 0) { &#13;
   <span class="emphasis"><em> //Rest of the code</em></span> &#13;
  } &#13;
} &#13;
</pre><p>If there are enemies within range, we need to decide a policy about which enemy the tower should be targeted. There are different ways to do this and different strategies that the tower itself could choose. Here, we are going to implement one where the nearest enemy to the tower will be the one targeted. Different policies and strategies will be discussed in the last chapter of this book.</p><p>To implement this policy, we need to loop all all the game objects that we have found in range, check if they actually are enemies, and using distances, pick the nearest one. To achieve this, write the following code inside the previous if statement:</p><pre class="programlisting"> if (hitColliders.Length != 0) { &#13;
  <span class="emphasis"><em> //Loop over all the gameObjects to identify the closest to the&#13;
     Cupcake Tower </em></span>&#13;
   float min = int.MaxValue; &#13;
   int index = -1; &#13;
 &#13;
   for (int i = 0; i &lt; hitColliders.Length; i++) { &#13;
     if (hitColliders[i].tag == "Enemy") { &#13;
       float distance =&#13;
         Vector2.Distance(hitColliders[i].transform.position,&#13;
           transform.position); &#13;
       if (distance &lt; min) { &#13;
         index = i; &#13;
         min = distance; &#13;
       } &#13;
     } &#13;
   } &#13;
   if (index == -1) &#13;
   return; &#13;
   <span class="emphasis"><em>//Rest of the code</em></span> &#13;
 } &#13;
</pre><p>Once we find the target, we need to get the direction that the tower will throw the projectile. So, let's write this:</p><pre class="programlisting">
<span class="emphasis"><em>//Get the direction of the target </em></span> &#13;
Transform target = hitColliders[index].transform; &#13;
Vector2 direction = (target.position - transform.position).normalized; &#13;
</pre><p>Finally, we need to instantiate a new projectile, and assign to it the direction of the enemy, as follows:</p><pre class="programlisting">
<span class="emphasis"><em>//Create the Projectile</em></span> &#13;
GameObject projectile = GameObject.Instantiate(projectilePrefab,&#13;
  transform.position, Quaternion.identity) as GameObject; &#13;
projectile.GetComponent&lt;ProjectileScript&gt;().direction = direction; &#13;
</pre><p>Instantiating GameObjects is usually slow, and it should be avoided. However, for learning purposes, we can live with that. In the last chapter, we will see some optimization technique to get rid of this instantiation. And that is it for shooting the enemies.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec9"></a>Upgrading the cupcake tower, making it even tastier</h4></div></div></div><p>In order to create a function to upgrade the tower, we first need to define a variable to store the actual level of the tower:</p><pre class="programlisting">public int upgradeLevel; <span class="emphasis"><em> //Level of the Cupcake Tower</em></span>
</pre><p>Then, we need an array with all the Sprites for the different upgrades, like this:</p><pre class="programlisting">public Sprite[] upgradeSprites; <span class="emphasis"><em>//Different sprites for the different&#13;
  levels of the Cupcake Tower</em></span>
</pre><p>A third variable is required to check when the cupcake tower is upgradable, so we can add:</p><pre class="programlisting">
<span class="emphasis"><em>//Boolean to check if the tower is upgradable</em></span> &#13;
public bool isUpgradable = true; &#13;
</pre><p>Finally, we can create our upgrade function. The first thing to do is to check if the tower is actually upgradable and then increase its level. Then, we can check (based on how many different graphics we have), if the tower has reached its maximum level, and in that case is preventing the player from upgrading it anymore, by assigning the false value to the <code class="literal">isUpgradable</code> variable. After that, we need to upgrade the graphics, and increase the stats. Feel free to tweak these values as you prefer. However, don't forget to assign the new Sprite. In the end, you should have something like the following:</p><pre class="programlisting">public void Upgrade() { &#13;
 <span class="emphasis"><em> //Check if the tower is upgradable</em></span> &#13;
  if (!isUpgradable) { &#13;
    return; &#13;
  } &#13;
 &#13;
  <span class="emphasis"><em>//Increase the level of the tower</em></span> &#13;
  upgradeLevel++; &#13;
 &#13;
 <span class="emphasis"><em> //Check if the tower has reached its last level</em></span> &#13;
  if(upgradeLevel &lt; upgradeSprites.Length) { &#13;
    isUpgradable = false; &#13;
  } &#13;
 &#13;
 <span class="emphasis"><em> //Increase the stats of the tower</em></span> &#13;
  rangeRadius += 1f; &#13;
  reloadTime -= 0.5f; &#13;
 &#13;
 <span class="emphasis"><em> //Change graphics of the tower</em></span> &#13;
  GetComponent&lt;SpriteRenderer&gt;().sprite = upgradeSprites[upgradeLevel]; &#13;
} &#13;
</pre><p>Save the script, and for now, we are done with it. We will need to modify this function later in the book, but for now, let's create a Prefab for our cupcake.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"></a>A pre-baked cupcake tower through Prefabs</h3></div></div></div><p>As we have done with the sprinkles, we need to do something similar for the cupcake tower. In the <code class="literal">Prefabs</code> folder in the <span class="strong"><strong>Project</strong></span>Â panel, create a new Prefab by right-clicking and then navigating to <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Prefab</strong></span>. Name it <code class="literal">SprinklesCupcakeTower</code>.</p><p>Now, drag and drop <code class="literal">Sprinkles_Cupcake_Tower_0</code> from the <code class="literal">Graphics/towers</code> folder (within the <code class="literal">cupcake_tower_sheet-01</code> file) in the <span class="strong"><strong>Scene</strong></span> View. Attach <code class="literal">CupcakeTowerScript</code> to the object by navigating to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Script</strong></span> | <code class="literal">CupcakeTowerScript</code>. The <span class="strong"><strong>Inspector</strong></span> should look like the following:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_02_030.jpg" /></div><p>We need to assign <code class="literal">Pink_Sprinkle_Projectile_Prefab</code> to the <span class="strong"><strong>Projectile Prefab</strong></span> variable. Then, we need to assign the different Sprites for the upgrades. In particular, we can use <code class="literal">Sprinkles_Cupcake_Tower_*</code> (replacing the <code class="literal">*</code> with the level of the cupcake tower) from the same sheet as earlier. Don't worry too much about the other parameters of the tower, such as the range radius or the reload time, since we will see how to balance the game later on. At the end, this is what we should see:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_02_031.jpg" /></div><p>The last step is to drag this game object inside the Prefab. As a result, our cupcake tower is ready.</p></div></div>