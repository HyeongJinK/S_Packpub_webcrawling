<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec37"></a>User interface system</h2></div></div><hr /></div><p>Now that we have acquired a basic knowledge about how to design UIs, it's time to learn how Unity handles all of this. From Unity 4.6, it is possible to use a dedicated UI system called UI. The goal of this section is understand how it works.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note19"></a>Note</h3><p>It is worth mentioning that, before version 4.6, Unity used an old system called GUI. Recently, Unity developer didn't completely dismiss the system, but slightly changed it and renamed it <span class="strong"><strong>IMGUI</strong></span>, which stands for <span class="strong"><strong>Immediate Mode GUI</strong></span>. As we can see in the official documentation, it is not intended to be used in game, but rather for programmers to quickly debug. Moreover, it is also used to create windows or a custom Inspector when Unity is extended through scripts, a topic that is definitely out of the scope of this introductory book. However, if you are interested in learning more, I invite you to read the official documentation: <a class="ulink" href="https://docs.unity3d.com/Manual/ExtendingTheEditor.html" target="_blank">https://docs.unity3d.com/Manual/ExtendingTheEditor.html</a> Also, follow this video tutorial: <a class="ulink" href="https://unity3d.com/learn/tutorials/topics/interface-essentials/building-custom-inspector?playlist=17090" target="_blank">https://unity3d.com/learn/tutorials/topics/interface-essentials/building-custom-inspector?playlist=17090</a>.</p></div><p>However, you might find this section a little bit encyclopedic. In fact, you can use this section as a quick reference to the UI elements you need. Therefore, feel free to skip part of it, if you already have a certain knowledge about Unity UIs.</p><p>Moreover, this section is structured in such a way that the fundamental things are at the beginning, and progressively deals with more complicated topics, up to arrive out of the scope of this book. In fact, we you have reached this level, where it is really just matter of fine tuning, or achieving a really specific effect, this section will give you a general idea of how it works, so to have a ground from which to further extend your knowledge, especially with the official documentation.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>Canvas</h3></div></div></div><p>If you are wondering what a Canvas is, let's begin with some background information. From the Merriam -Webster dictionary, a canvas is considered to be the following:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A firm closely woven cloth usually of linen, hemp, or cotton used for clothing and formerly much used for tents and sails."</em></span></p></blockquote></div><p>But probably the definition that is closer to what Unity means is this, also from the Merriam-Webster dictionary:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A piece of cloth backed or framed as a surface for a painting; also: the painting on such a surface."</em></span></p></blockquote></div><p>In computer graphics, a canvas is something slightly different, and we can see its definition on Wikipedia:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"In computer science and visualization, a canvas is a container that holds various drawing elements (lines, shapes, text, frames containing other elements, etc.). It takes its name from the canvas used in visual arts. It is sometimes called a scene graph because it arranges the logical representation of a user interface or graphical scene. Some implementations also define the spatial representation and allow the user to interact with the elements via a graphical user interface."</em></span></p></blockquote></div><p>In Unity, a Canvas is an important component of the UI system. Since the UI is internally rendered by Unity in a different way than the rest of the scene, we need to specify which elements within our scene belong to the UI. In particular, all the UI elements should be children of a Canvas, which is a Game Object with a Canvas component attached on it. We can create a Canvas by right-clicking on the <span class="strong"><strong>Hierarchy</strong></span> panel and then navigate to <span class="strong"><strong>UI | Canvas</strong></span>.</p><p>As a result, two objects will be created in our scene, as we can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_003.jpg" /></div><p>However, at the moment let's just focus on the Canvas, leaving the <span class="strong"><strong>EventSystem</strong></span> for later.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note20"></a>Note</h3><p>Creating a new UI element, such as an image, for instance by right-clicking on the <span class="strong"><strong>Hierarchy</strong></span> and then <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Image</strong></span>, automatically creates a Canvas (and an EventSystem as well), if there isn't already a <span class="strong"><strong>Canvas</strong></span> in the scene. The UI element is created as a child of this Canvas.</p></div><p>The Canvas is represented in the scene as a white rectangular. This helps us to edit the UI without switching back and forth from the Game View.</p><p>If the <span class="strong"><strong>Scene</strong></span> view is not set in 2D, for instance we are working in on a 3D game, the Canvas appears distorted, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_004.jpg" /></div><p>Since UI will be rendered orthographically, a rule of thumb of working with UIs is to switch the Scene View to 2D (as we learnt in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>A Flat World in Unity</em></span>), to have something like the following:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_005.jpg" /></div><p>If we select the Canvas, we should be able to see the following in the <span class="strong"><strong>Inspector</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_006.jpg" /></div><p>The main setting is the <span class="strong"><strong>Render Mode</strong></span>, which allows us to specify how we intend to use our UI. Let's take a closer look at these options.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec10"></a>Screen space – Overlay</h4></div></div></div><p>This render mode is the most used. In fact, it places UI elements on the screen by rendering them on top of the scene, as in many games. This means that UI elements are rendered perfectly orthographically.</p><p>Furthermore, if the screen changes resolution or is resized, the Canvas will change size to automatically fit the new ratio.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec11"></a>Screen space – Camera</h4></div></div></div><p>This render mode, instead, is linked to a specific Camera where the UI will be render on top of it. This means that the Canvas is placed at a given distance in front of the selected Camera. As a result, the UI elements will be affected by all the camera parameters and effects. This includes the perspective distortion, if the <span class="strong"><strong>Camera</strong></span> is set to <span class="strong"><strong>Perspective</strong></span>, which is regulated by the <span class="strong"><strong>Camera Field of View</strong></span> parameter.</p><p>Like previously, the Canvas may change size based on the resolution of the screen as well as the camera frustum.</p><p>If you are wondering what the camera frustum is, keep reading this info box. When you select a camera, you will see a trunked pyramid (if the camera is in perspective mode, otherwise it has a Parallelepiped as shape), like the one in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_007.jpg" /></div><p>This is the camera frustum, and everything that is inside it will be rendered by the camera. The plane that is closer to the camera is called <span class="strong"><strong>near clipping plane</strong></span>, whereas the far one is called the <span class="strong"><strong>far clipping plane</strong></span>.
Understanding why a perspective camera has this shape is not hard, but it's out of the scope of this book. However, in the documentation, you can find two interesting pages that talk about this. They are easy to understand, and as for your convenience, here are the links: <a class="ulink" href="https://docs.unity3d.com/Manual/UnderstandingFrustum.html" target="_blank">https://docs.unity3d.com/Manual/UnderstandingFrustum.html</a> and <a class="ulink" href="https://docs.unity3d.com/Manual/FrustumSizeAtDistance.html" target="_blank">https://docs.unity3d.com/Manual/FrustumSizeAtDistance.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec12"></a>World space</h4></div></div></div><p>This render mode will make the Canvas behave like any other game object in the scene. This means that the Canvas has a precise position in the world (from here the name, since it is placed in the world space). As a result, the UI can be occluded by other objects in the scene. Its dimensions are set manually using the Rect Transform component (see some paragraphs ahead). This mode is useful for UIs that are meant to be a part of the world. As we have discussed previously, this is also known as a <span class="strong"><strong>diegetic interface</strong></span>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>Draw order of UI elements</h3></div></div></div><p>As we will see in the next paragraphs, UI elements will be images or text that is rendered on the screen. However, what happens when two of these components overlap? There is an order, so that the UI elements in the Canvas are drawn in the same order they appear in the hierarchy. This means that the first child is drawn first, the second child next, and so on. Therefore, when two UI elements overlap, the later one, in the Hierarchy, will appear on top of the earlier one.</p><p>To change which element appear on top of other elements, it's just matter of reordering the elements in the <span class="strong"><strong>Hierarchy</strong></span> by dragging them.</p><p>To better understand this, look at the following screenshot, which represents two different situations with two images. For your convenience, the respective <span class="strong"><strong>Hierarchy</strong></span> panel has been superimposed next to the images.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_008.jpg" /><div class="caption"><p>The Lemon Cupcake is rendered on top of the chocolate one because the Lemon Cupcake is the last child of the Canvas</p></div></div><p>The order can also be controlled from scripting by using these methods on the Transform component:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>SetAsFirstSibling()</strong></span>: Place the game object as the first child of its parent. As a result, it will be rendered for first (with respect to its siblings), and therefore sent to the back (all other UI elements will be on top of it).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>SetAsLastSibling()</strong></span>: Place the game object as the last child of its parent. As a result, it will be rendered last (with respect to its siblings), and therefore brought to the front (all other UI elements will be behind it).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>SetSiblingIndex()</strong></span>: Place the game object to a specific index, allowing to decide at which point of the rendering hierarchy this game object will be.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"></a>Visual components</h3></div></div></div><p>The Unity UI comes with different premade components to build our UI. The most commonly used are the visual components, which allow rendering custom content on the screen.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec13"></a>The Image component</h4></div></div></div><p>The Image component, as the name suggests, allows us to render an image on the screen. In fact, we need to specify a <span class="strong"><strong>Source Image</strong></span>, which is the image we want to render. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_03_09.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note21"></a>Note</h3><p>As for Sprites, the image assets we intend to use for the UI in our project must be set to Sprite (2D and UI), as <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>A Flat World in Unity</em></span> explained.</p></div><p>Then, we can adjust the color, which is a multiplier of the Sprite, as well as assign a material, if we need to.</p><p>Once a <span class="strong"><strong>Source Image</strong></span> has been set, we can define how the Sprite will appear by selecting the <span class="strong"><strong>Image Type</strong></span>. The options are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Simple</strong></span>: just scales the image or Sprite equally.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Sliced</strong></span>: if the Sprite has been 9-sliced (as <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>A Flat World in Unity</em></span> explained), the nine different parts of the image will be scaled differently.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Tiled</strong></span>: this is similar to the previous one, but the central part of the 9-slicing is tiled instead of stretched.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Filled</strong></span>: this is similar to Simple, but allows us to show part of the image as it would be filled. This is controlled by parameters such as the Origin of the Filling, as well as the method and the amount. We will use this feature later in the chapter, and we will find out that is really useful for creating bars in video games:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_03_10.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"></a>Note</h3><p>Some advanced bars, such as the health bar in Kingdom Hearts style, can be found in the book pointed out previously: <span class="emphasis"><em>Unity UI Cookbook</em></span>, <span class="emphasis"><em>Packt publishing</em></span> towards the end of <span class="emphasis"><em>Chapter 2</em></span>, <span class="emphasis"><em>Implementing Counters and Health Bars</em></span>.</p></div><p>Furthermore, when the image is <span class="strong"><strong>Simple</strong></span> or <span class="strong"><strong>Filled</strong></span>, the button <span class="strong"><strong>Set Native Size</strong></span> is visible. It just restores the original size of the image. This is really useful when you assign a new <span class="strong"><strong>Source Image</strong></span>, and you can restore the original ratio by using this button as well, before scaling to the right size for your UI.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec14"></a>The Text component</h4></div></div></div><p>The Text component, as the name suggests, allows us to render any text on the screen. Sometimes, in some books, it is referred to as label, since usually it is used to give a label to other UI components. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_011.jpg" /></div><p>It contains a text area, which can be extended using the Rect Tool (see the next paragraph). Within the component, you can find all the basic <span class="strong"><strong>Text</strong></span> transformations, such as setting the font, the font style, and the font size. Furthermore, it is possible to enable or disable the rich text capability, which is enabled by default.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"></a>Note</h3><p>If you a wondering what rich text capability is, keep reading this info box.</p><p>Rich text capability allows us to place some HTML tags within the text to change only specific part of the text. In non-technical terms, you can change the color of a single word or change its font style to italic. For instance, you can have something like <span class="emphasis"><em>This book is really amazing</em></span> in the <span class="strong"><strong>Text</strong></span> area, but in the text component, it is written as <code class="literal">This book &lt;b&gt;is really&lt;/b&gt; amazing</code>.</p><p>Since they are HTML tags, they must be placed at the beginning, specifying the settings, and at the end of the part of text where you want to apply the change.</p><p>These are the main tags supported from unity:</p><p><code class="literal">&lt;b&gt;The text between these tags will be in bold&lt;/b&gt;</code></p><p><code class="literal">&lt;i&gt;The text between these tags will be in italic&lt;/i&gt;</code></p><p><code class="literal">&lt;size=50&gt;The text between these tags will have a size of 50, and you can change the number to any number&lt;/size&gt;</code></p><p><code class="literal">&lt;color= #rrggbbaa&gt;This text between these tags will be colored with the hex color specified at the beginning&lt;/color&gt;</code></p><p>If you don't know what a hex color is, it is just a hex number (therefore, it contains also some letters) that represents a color; you can learn more about them on the Wikipedia page here: <a class="ulink" href="https://en.wikipedia.org/wiki/Web_colors" target="_blank">https://en.wikipedia.org/wiki/Web_colors</a>.</p><p>However, keep in mind that you don't need to know all the detailed theory behind the Wikipedia page to use these colors. In fact, there are plenty of online color pickers that give you the hex number of a specific color. Then, you just need to copy and paste the code into your text in Unity. Furthermore, you don't need necessarily to use the hex code for the color, but there are some presets in Unity. In fact, you can just use This <code class="literal">&lt;color=red&gt;word&lt;/color&gt;</code> is red to make the word red, without specifying the whole hex code. The list of all these color shortcuts can be found by following the link at the end of this info box. Alternative, you could also select hex colors from online tools, such as: <a class="ulink" href="http://www.w3schools.com/colors/colors_picker.asp" target="_blank">http://www.w3schools.com/colors/colors_picker.asp</a> or <a class="ulink" href="http://htmlcolorcodes.com" target="_blank">http://htmlcolorcodes.com</a>.</p><p>There are a couple of special tags, material and quad, which have a really specific use. If you want to learn more, follow the link at the end of this info box.</p><p>Another cool feature of these tags is that you can nest them! This means you can use more than one at the same time. For instance, you can have part of the text that is blue, bold, and italic. However, they must be closed in reverse order, otherwise they won't work.</p><p>If you want to learn more, follow this link: <a class="ulink" href="https://docs.unity3d.com/Manual/StyledText.html" target="_blank">https://docs.unity3d.com/Manual/StyledText.html</a>.</p></div><p>In addition, you can find options to change the alignment of the text as well as for vertical and horizontal overflow, which means to control what happens when the text is larger than the text area. The <span class="strong"><strong>Best Fit</strong></span> option rescales the text to fit the available space of the text area.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec26"></a>Basic transformations</h3></div></div></div><p>We have seen some basic UI elements, but how can we place and manipulate them? We will learn various different forms of implementing transformations in the next sections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec15"></a>The Rect Tool</h4></div></div></div><p>Since UI elements are similar to Sprites (both are 2D), the best way to quickly manipulate them is by using the Rect Tool.</p><p>A fast recap, you can find the Rect Tool in the top-left corner of the Unity Editor, and it is the last one on the right, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_012.jpg" /></div><p>A border around our Sprite or UI elements should appear. As a result, we can transform it in the following ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If we click and drag within the rectangle, we can move the object, as in the following picture (for learning purposes, a tasty cupcake has been used in an Image component):</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_013.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If we click on the blue dot in the middle, which is the pivot point, we can change its position (in this book we will not change any pivot points, since we won't need this):</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_014.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If we click and drag an edge we can scale along that direction, as we can see here:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_015.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If we click and drag a corner, instead, we can scale freely along both directions. Furthermore, if you press <span class="strong"><strong>Shift</strong></span> while dragging, the scale will be uniform, which means it will increase in size by the same quantity on both axes by keeping the ratio of the object constant:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_016.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Finally, if we place the cursor next to a corner that is, outside of the rectangle, a little rotation icon appears. By clicking and dragging it is possible to rotate the object around its pivot point:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_017.jpg" /></div><p>And this is all for the Rect Tool.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec16"></a>The Rect Transform</h4></div></div></div><p>There is a major difference in how Unity handles Sprites and UI elements. In fact, Sprites have the usual Transform component, to indicate position, rotation, and Scale. UI elements, instead, have a Rect Transform (the 2D layout counterpart), which is much more complex and store more information. In fact, the Transform represents a single point in the space, whereas the Rect Transform represent a rectangle in which a UI element can be placed. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_018.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"></a>Tip</h3><p>Unity performs all the calculations of the positions of the different Rect Transform at the end of the frame to ensure having up-to-date values with respect to the rest of the frame. As a result, these values of the Rect Transform might not be correct when you use the <code class="literal">Start()</code> function. To overcome this problem, you can force the update of the canvas by calling the <code class="literal">Canvas.ForceUpdateCanvases()</code> function.</p></div><p>Furthermore, if the parent of a Rect Transform is also a Rect Transform, the child Rect Transform can also specify how it should be positioned and sized relative to the parent rectangle. This hierarchical structure is what makes Rect Transform so powerful, especially when you need to design for multiple resolutions.</p><p>Other than scaling, a Rect Transform can be resized. They are similar operations, but the difference lies that resizing leaves invariant the local scale, and change the height and the width. As a result, font sizes, borders on sliced images, and so on, won't be affected from resizing, whereas they are in the case of scaling.</p><p>Similar to 2D Sprites, the Rect transform applies scaling, rotation, and resizing by the pivot point of the UI element. However, it is possible to change it directly inside the Scene View, by dragging it (the little blue circle) within the UI element.</p><p>One of the most import concepts about this component is the Anchors, which allow us to specify the relation of the UI element with respect to the Canvas and its parent. They are displayed as four small triangular handles in the Scene View. The information related to these anchors is shown in the Rect Transform component in the Inspector.</p><p>Unfortunately, there is no a simple way to explain Anchors without seeing the effects in motion, such as in a video or in an animated gif. Since this is a book, it cannot contain such animated media, which would clarify the concept immediately to you. Therefore, instead of losing time in a complicated explanation of anchors, which may not be fully understandable, I invite you to visit the official documentation here, in the anchors section: <a class="ulink" href="https://docs.unity3d.com/Manual/UIBasicLayout.html" target="_blank">https://docs.unity3d.com/Manual/UIBasicLayout.html</a>. Don't worry, I'll still be here when you come back from the webpage.</p><p>If you have read the webpages, other than seeing the animated gif, you also have seen the Anchor presets, which are shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_019.jpg" /></div><p>These are useful shortcuts to quickly correctly anchor UI elements. Of course, I invite you to manually change this configuration in your game, when needed.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"></a>Layout components</h3></div></div></div><p>In the previous section we saw how it is possible to place UI elements in the screen. However, sometimes, it's really useful to automatically place them in the screen within a certain criteria, especially when the number of UI elements is not known a priori, and changes at runtime. This can be manually scripted, but Unity comes with a series of layout components that helps with basic layout placement.</p><p>The auto-layout system is composed of two different kinds of elements: layout elements and layout controllers. To understand the former, note that every game object that has a Rect Transform, and eventually other components, is a layout element. These types have certain knowledge about what size they should be of, but they do not control it directly. Layout controllers, instead, are components that control sizes and also positions of one or more layout elements. They can control their own layout element or child Layout Elements of the game object to which they are attached.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Tip</h3><p>Layout controllers change the Rect transforms in such a way that it's hard to restore the previous status. Therefore, before to even add a layout controllers and/or modify one, be sure to be in Play mode in order to make changes without causing any unwanted layout change to your UI. Once you are happy with the changes, stop Play mode, and insert the values that you have found that fit your needs.</p></div><p>The layout controllers are divided into Fitters and layout groups.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec17"></a>Fitters</h4></div></div></div><p>The Fitters only control the size of its own layout element. When resizing UI elements, keep in mind that it happens around the pivot point, as we discussed in the previous section. Therefore, you can use it also to align UI elements. For instance, if the pivot is in the center, the element will scale equally in all the directions, whereas if it is placed in a corner, such as the top-left, the element will scale down and to the right. All other positions will give different weighs along the four directions where the element will scale.</p><p>With this said, let's take a look at the Fitters controllers:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Content Size Fitter</strong></span>: controls the size of its own layout element. The size is determined by the minimum or preferred sizes provided by layout element components on the Game Object. Such layout elements can be Image or Text components, layout groups, or a Layout Element component:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_020.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Aspect Ratio Fitter</strong></span>: can adjust the height to fit the width or vice versa, or it can make the element fit inside its parent or envelope its parent. The Aspect Ratio Fitter does not take layout information into account, such as minimum size and preferred size:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_021.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec18"></a>Layout groups</h4></div></div></div><p>The layout groups, instead, control the layout elements of their children, and not their own. They are used to orderly place the UI elements. They have different options to control the spacing between the children and define the preferred heights and/or widths. Other options include the possibility to force the expansion of the children so to fit the space available or to decide what happens when they are bigger than the space available. They are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Vertical Layout Group</strong></span>: allows us to stack the children along a vertical axis, and place them on top of each other:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_022.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Horizontal Layout Group</strong></span>: allows us to stack the children along a horizontal axis, and place them next to each other:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_023.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Grid Layout Group</strong></span>: this allows us to stack the children in a grid, both vertically and horizontally:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_024.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec19"></a>The layout element component</h4></div></div></div><p>There is one more component, which is the <span class="strong"><strong>Layout Element</strong></span> component. As the name suggests, it is not a controller, but rather allows us to change the layout element settings from the Rect Transform. In fact, when placed on a layout element, it allows us to override the settings, such as min, preferred, and flexible both for height and width. Furthermore, it has a flag to ignore the controllers. So, imagine having a label inside a grid layout component, you don't want the label to be stacked in the grid along all the other elements, but rather on the top, defining what the grid is about. In this case, ignoring the controller is useful to place the label outside the grid, and yet be a children of the grid, so to move it as a unique block, without replacing the label every time.</p><p>Here is a picture of what this component looks like:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_025.jpg" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec28"></a>Interaction components</h3></div></div></div><p>Unity UI comes with more powerful premade components than the one seen in the visual components section. In fact, there are many components with which the user can interact. These interaction can be mouse or touch/tap events as well as keyboard or controller events.</p><p>However, this components are not visible on their own, and must be combined with one or more visual components in order to work correctly.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec20"></a>The selectable base class</h4></div></div></div><p>Before seeing how the single interaction components work, we need to understand some basic settings shared among all of them. In particular, these settings derive from the Selectable base class, which has transition and navigation options.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec0"></a>Interactable option</h5></div></div></div><p>This is just a flag that determines if an interaction component is enable for interaction or not. When checked, the interaction component will be in the <span class="strong"><strong>Disable</strong></span> state (see the next section).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec1"></a>Transition options</h5></div></div></div><p>Usually, interaction components needs to send some feedback to the player, so he or she can understand if the action has been performed.</p><p>In this implementation of Unity, there are four states in which an interaction component could be. They are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Normal</strong></span>: the interaction component is untouched</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Highlighted</strong></span>: when the pointer is on the interaction component, but a click (or a touch/tap in the case of touch-screens) hasn't been performed yet</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Pressed</strong></span>: when the click (or touch/tap) is happening on the interaction component</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Disable</strong></span>: when the interaction component is not interactable</p></li></ul></div><p>They transitions and the specifications of these states can happen in four different ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>None</strong></span>: The interaction component doesn't change state. This is really useful when we want to implement the kind of interaction with the component in a custom way:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_026.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Color Tint</strong></span>: this option is selected by default and defines a color tint for each of the preceding states. Furthermore, it contains a <span class="strong"><strong>Fade Duration</strong></span> to regulate how fast the component should change from one color to another, and a <span class="strong"><strong>Color Multiplier</strong></span>. As a result, the interaction component will smoothly change color for each of the four states:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_027.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Sprite Swap</strong></span>: Usually, the interaction components have also an Image component attached to them, which defines the basic graphics. In this transition mode, instead of changing color, there is a different Sprite for each one of the four states. This is useful when you have custom graphics for each one of the states:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_028.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Animation</strong></span>: This is the most versatile transition mode, since it allows you to have a custom animation for each one of the states (we will talk more about animations in the upcoming chapters):</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_029.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec2"></a>Navigation options</h5></div></div></div><p>The navigation options determine how the player can navigate through the UI elements during play mode. These are the different options available:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>None</strong></span>: No keyboard navigation. This is useful when you want to implement your own navigation system within the game. Furthermore, the interaction component that is set in this mode will not receive focus from clicking (or tapping) on it.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Horizontal</strong></span>: navigates horizontally.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Vertical</strong></span>: navigates vertically.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Automatic</strong></span>: Unity will try to guess which is the right navigation based on the positions of the UI elements.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Explicit</strong></span>: In this mode, you can specify the next UI element to select for each arrow key. This allows fine navigation control:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_030.jpg" /></div><p>Furthermore, the <span class="strong"><strong>Visualize</strong></span> button allows to visualize the navigation scheme within the <span class="strong"><strong>Scene View</strong></span>. An example of this visualization is presented in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_031.jpg" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec21"></a>Button</h4></div></div></div><p>This is the classical interaction component that can be found in any game. It contains only one event, <code class="literal">OnClick()</code>, which is triggered when the button is clicked/tapped. Of course, you can link any action to the event. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_032.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"></a>Note</h3><p>Keep in mind that if the pointer is moved away from the button before the click/tap is released, the action doesn't take place. You can find an exercise on this in the <span class="emphasis"><em>Homework</em></span> section.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec22"></a>Toggle and Toggle Group</h4></div></div></div><p>The Toggle component allows the player to turn off and on an option. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_033.jpg" /></div><p>As the button, the toggle has a single event <code class="literal">OnValueChanged()</code>, which is called every time that the toggle changes its state; the value of the new state is passed as a Boolean parameter within the event data (see next paragraph). This component works well with another component, called Toggle Group, which controls whether there is only one option among a group of toggles to be turned on, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_034.jpg" /></div><p>You can set up a toggle group by just add it to the <span class="strong"><strong>Group</strong></span> property of all the toggles you wish in to be in the group. This is, for instance, really useful for mutually exclusive choices, such as character or class selection. Other common use is tuning the game settings, such as game speed, difficulty, or color scheme. Of course, you can use more than one toggle group per time within your scenes; however, a toggle can only belong to one group.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec23"></a>Slider</h4></div></div></div><p>As the name suggests, a slider is a bar with a handle along it, which can slide from the beginning, which is considered the <span class="strong"><strong>Min Value</strong></span>, to the end, which is considered the <span class="strong"><strong>Max Value</strong></span>. All the values in between are in proportion to the position of the handle along the bar. By default, the handle increases its value from left to right, but by tweaking the <span class="strong"><strong>Direction</strong></span> property, it's possible to change in other directions, so not only from right to left but also along the vertical axis. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_035.jpg" /></div><p>The slider has a single event, <code class="literal">OnValueChanged()</code>, which is triggered when the handle is dragged, and the new value of the slider is passed as a float to the triggered action.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec24"></a>Scrollbar</h4></div></div></div><p>This component is very similar to a slider, since it has a handle along a bar, and the minimum value is always 0.0 and the maximum is 1.0. All the values in between represents the different percentage of where the handle will be. Again, the scrollbar can be orientated by tweaking the <span class="strong"><strong>Direction</strong></span> property. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_036.jpg" /></div><p>The difference between this and the slider is the possibility to stretch the handle of the scrollbar depending on some content, such as text areas. When the text increases, the handle becomes smaller to slide among more content, which represents the amount of scrolling available. On the other hand, when the content is not large, the handle increases its dimensions to completely fill the bar and not allow scrolling.</p><p>The scrollbar has a single event, called <code class="literal">OnValueChanged()</code>, and it works exactly the same way as the homonymous event on the slider.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec25"></a>Dropdown</h4></div></div></div><p>The <span class="strong"><strong>Dropdown</strong></span> is a relatively new component in the Unity UI, since it has been released/implemented since Unity 5.2. This component allows the player to select among a list of options. The component shows the current selected option only, and when the player clicks/taps on it, the full list appears. Once another item from the list is selected, the list closes and the new item is picked. Furthermore, the player can close the list without changing the item if he or she clicks somewhere else outside the component. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_037.jpg" /></div><p>Using the dropdown in the inspector is quite intuitive, even if you need to get used to the template in the hierarchy if you want to change its appearance. Unfortunately, we don't have time to go into detail about how this component works, but I'm sure you can easily understand it by visiting the official documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/script-Dropdown.html" target="_blank">https://docs.unity3d.com/Manual/script-Dropdown.html</a>.</p><p>In any case, we won't use this component for our game, but in the <span class="emphasis"><em>Homework</em></span> section you can challenge yourself to understand this component better.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec26"></a>Input Field</h4></div></div></div><p>The <span class="strong"><strong>Input Field</strong></span> component allows the player to type text in the game, specifically within a text area. Of course, you need to use it in conjunction with a Text component, and/or other visual elements. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_038.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note27"></a>Note</h3><p>The <span class="strong"><strong>Input Field</strong></span> can be added also to an already existing <span class="strong"><strong>Text</strong></span> component to make it editable. In order to do so, select the <span class="strong"><strong>Text</strong></span> component in the <span class="strong"><strong>Hierarchy</strong></span> panel and navigate to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Input Field</strong></span> in the <span class="strong"><strong>Inspector</strong></span>. Then, drag the <span class="strong"><strong>Text</strong></span> component (also the game object itself will work) inside the <span class="strong"><strong>Text</strong></span> component variable of the <span class="strong"><strong>Input Field</strong></span>. Furthermore, you may want to add a placeholder as well. As such, I suggest that you create an <span class="strong"><strong>Input Field</strong></span> and study how it works with its original structure, and then add existing text areas.</p></div><p>When the player is typing, the <span class="strong"><strong>Text</strong></span> property of the <span class="strong"><strong>Text</strong></span> component will change, and it can be retrieved from the script.</p><p>Moreover, the <span class="strong"><strong>Input Field</strong></span> has different options to define the kind of characters that are allowed, whether they should be masked (for instance, if it is a password or a pin), whether there is a limit to the number, or whether multi-line editing is allowed. You can learn more about these additional features in the official documentation: <a class="ulink" href="https://docs.unity3d.com/Manual/script-InputField.html" target="_blank">https://docs.unity3d.com/Manual/script-InputField.html</a>.</p><p>The <span class="strong"><strong>Input Field</strong></span> component has two events: <code class="literal">OnValueChanged()</code>, which is triggered every time the player types something, and <code class="literal">OnEndEdit()</code>, which is triggered only when the player has stopped typing. In both the cases, the whole text in the <span class="strong"><strong>Text</strong></span> component is passed to the action function through a string parameter.</p><p>Keep in mind that <span class="strong"><strong>Rich Text</strong></span> is turned off by default. You can enable it, but it is not well supported for the <span class="strong"><strong>Input Field</strong></span> because the navigation in the text includes markup, whereas the visual doesn't. As a result, it is really confusing for whoever is going to type there. Usually, you don't need <span class="strong"><strong>Rich Text</strong></span> capability for editable texts; therefore, as a rule of thumb, just keep <span class="strong"><strong>Rich Text</strong></span> turned off.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec27"></a>Scroll Rect</h4></div></div></div><p>This component is used when your content is larger than the area it should occupy. Scroll Rect allows us to make a content scrollable inside a rectangle, and display all the content in a relatively small area. Usually, this component is used with the <span class="strong"><strong>Mask</strong></span> component; in this way all the content outside the rectangle will not be visible, and you will have achieved a scroll view. An example of this can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_039.jpg" /></div><p>Furthermore, you can assign scrollbars (both on the horizontal and the vertical axes) to easily scroll through the content. You can find more options to tweak in the component, and if you really want to understand them, I invite you to consult the official documentation: <a class="ulink" href="https://docs.unity3d.com/Manual/script-ScrollRect.html" target="_blank">https://docs.unity3d.com/Manual/script-ScrollRect.html</a>.</p><p>Finally, the Scroll Rect has only one event, <code class="literal">OnValueChanged()</code>, which is triggered when the position of the Scroll Rect is changed, signifying that the player scrolled.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec29"></a>More about UI rendering</h3></div></div></div><p>We have seen a lot about UI, yet it's not everything. This section presents some relative advanced topics in the UI of Unity. Feel free to skip this section, or read without focus to completely understand what's written, You can always come back here later.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec28"></a>The canvas renderer</h4></div></div></div><p>The careful reader has noticed that in all the UI elements there is always attached a Canvas Renderer, such as the one in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_040.jpg" /></div><p>What is this component that doesn't allow us to change any options? It allows Unity to know that that specific UI element should be rendered in a Canvas. In very particular cases, when an UI element is built from scratch, we need to manually add this component. However, if you are not planning to build custom UI elements from scratch, but just using the ones that Unity provides (which are more than enough to build really complex UIs), you can forget about this component. In fact, it is automatically created every time we create an UI element.</p><p>Even if the <span class="strong"><strong>Canvas Renderer</strong></span> doesn't have any options in the inspector, it has some properties that can be accessed through script. For such functions and variables, you can find details here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/CanvasRenderer.html" target="_blank">https://docs.unity3d.com/ScriptReference/CanvasRenderer.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec29"></a>More visual components</h4></div></div></div><p>We have analyzed the main visual components; however, there are more visual components, which are used rarely in special situations:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_041.jpg" /></div><p>The most common is the <span class="strong"><strong>Mask</strong></span> component. It is used to create a scroll view in conjunction with the <span class="strong"><strong>Scroll Rect</strong></span>. It forces the children to have the shape of the parent. However, it doesn't support alpha channels. This means that part of the children will be either visible or not, without having any kind of opacity specified in the mask.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note28"></a>Note</h3><p>If you are interested in knowing why the alpha channel is not supported, we need to mention implementation of Mask beneath Unity.</p><p>When you program with a GPU, you are constrained to use certain buffers to render things. Modern GPUs have a buffer called Stencil Buffer, used together with the <span class="strong"><strong>Color Buffer</strong></span> and the <span class="strong"><strong>Depth Buffer</strong></span>, which can only assume integer values and work on a pixel base. Usually, it is used to avoid rendering certain parts of the screen, and improve performance overall, and this is the case with Unity. Advanced uses of this may include changing it dynamically based on the Depth Buffer. However, Unity just uses this buffer to not render the part of the screen not covered by the mask, in particular, assigning the value of 1 to the pixel that should be rendered.</p><p>Furthermore, Unity allows nested masks, in particular, using the AND (<code class="literal">&amp;</code>) operation on them. As a result, a pixel will be rendered if and only if it is within all the nested masks. You can easily imagine this by overlapping different paper masks to a drawing, which is visible only in the parts that all the paper masks overlap.</p></div><p>Recently, Unity has introduced also another kind of Mask, <span class="strong"><strong>Rect Mask 2D</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_042.jpg" /></div><p>It has some limitations with respect of the previous mask component, such as the fact that it only works in a 2D environment and with coplanar elements (non-coplanar is still possible, but the component might not work as it should). However, this approach brings some advantages, such as not needing to use the Stencil Buffer (see the preceding info box) with consequent performance improvements since there are no extra draw calls.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_043.jpg" /></div><p>Another very special visual component is the <span class="strong"><strong>Raw Image</strong></span>. It has some limitations with respect to the <span class="strong"><strong>Image</strong></span> component, but has other features. In fact, the <span class="strong"><strong>Raw Image</strong></span> doesn't have the option to animate an image. However, it works directly with bytes, as the name suggests. As a result, it is able to display not only Sprites as the image, but also textures. To understand why this is useful, imagine that a texture is just an array of bytes, and as such, they can change at runtime. This means that you may download a texture from a URL during runtime, and show it on within a <span class="strong"><strong>Raw Image</strong></span>. Other uses might be the use of <span class="strong"><strong>Render Textures</strong></span> (from Unity 5.x, they are also available in the personal edition, and not only in the Pro version), and stream what another camera in the game world is seeing. This might be used, for instance, to quickly create a minimap in the game. You can find this process described in detail in the last chapter of the <span class="emphasis"><em>Unity UI Cookbook</em></span> suggested at the beginning of this chapter. One more thing about raw images: they have a <span class="strong"><strong>UV Rect</strong></span> option. This means you can scale and zoom the image/texture they have as you like, without changing the texture itself.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec30"></a>UI effect components</h4></div></div></div><p>In addition to the visual components and the interaction ones, Unity has special classes of components called effect components. In some books, and in the documentation itself, you might find them as a subclass of the visual components.</p><p>These components are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Shadow</strong></span>: This allows us to add a shadow effect to an image or text component. It must be attached to the same game object of the text or image component. Its options change the distance of the shadow and the color. Furthermore, in the case of an image, a Boolean controls if the component in creating the shadow should use also the alpha channel of image:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_044.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Outline</strong></span>: This works similarly to the shadow component, but instead of a shadow, it adds an outline. The control options are the same as the shadow component:</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_045.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Position as UV1</strong></span>: When this is on an Image component, Unity passes the canvas position through to the first UV channel. This means that if you have a custom shader, you can use this to create refraction or an UV offset sampling.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec31"></a>UI and lights</h4></div></div></div><p>In addition to all that we have discovered about UI, you can use lights on the UI. They are used to make them feel more realistic, especially when the UI is place within the 3D world, or when it has a kind of perspective. However, keep in mind that adding a light might decrease performance.</p><p>If the UI is in a 3D world, you may want it to be affected by the world lights, but if it has a perspective, such as in the case of the <span class="strong"><strong>Screen Space - Camera</strong></span> of the Canvas, you may want it to just be affected by certain lights. As such, you need to create some layers to filter which lights will affect the UI.</p><p>However, it is not so simple as placing a light in the scene to make a UI component affected by light, since you need a material that responds to light. In this case, Unity provides specific shaders for UIs. In any case, this is out of the scope of the book, since it deals more with 3D game development, rather than 2D. But if you are interested in knowing more, in the <span class="emphasis"><em>Unity UI cookbook</em></span>, in <span class="emphasis"><em>Chapter 2</em></span>, <span class="emphasis"><em>Creating Panels for Menus</em></span>, you'll find a recipe that deals with lights in the UI. That is a good start to play with lights within the UI.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec32"></a>The canvas components</h4></div></div></div><p>At the beginning of the chapter, we talked about the Canvas, and its main property about the <span class="strong"><strong>Render Mode</strong></span>. However, if we look at the Canvas in the Inspector, we can see that it actually has three different components, which usually are used all together to make a Canvas. For your convenience, the following screenshot shows them in the Inspector:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_046.jpg" /></div><p>Let's take a general look at their functionalities:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Canvas</strong></span>: This is main component, which actually create the canvas, so Unity knows that everything inside it should be rendered as UI.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Canvas Scaler</strong></span>: This controls the overall scale and pixel density of UI elements within the Canvas. This scaling affects everything on the Canvas, including font sizes and image borders. There's more information in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/script-CanvasScaler.html" target="_blank">https://docs.unity3d.com/Manual/script-CanvasScaler.html</a>.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Graphic Raycaster</strong></span>: This component belongs to the event system and allows us to detect mouse or touch events with respect to graphics. For more information about this component, you can look at the official documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/script-GraphicRaycaster.html" target="_blank">https://docs.unity3d.com/Manual/script-GraphicRaycaster.html</a>.</p></li></ul></div><p>If you are going to face this topic, I suggest that you study the whole Event System framework that Unity provides (see the next section).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec33"></a>Canvas group</h4></div></div></div><p>In addition to the UI components we already have seen, there is another one called <span class="strong"><strong>Canvas Group</strong></span>. It allows us to define a group, or if you prefer, a subset of the UI elements within a Canvas. This is what it looks like in the Inspector:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_047.jpg" /></div><p>Furthermore, it provides some general functions to apply to all the elements belonging to the group. These may include alpha, if, for instance, you want to smoothly make part of the interface appear or disappear, or if it is interactable (or disabled).</p><p>Another common use for <span class="strong"><strong>Canvas Group</strong></span> is to not block mouse events in certain areas of the UI, which means the player can click on a button that lies under an Image belonging to a <span class="strong"><strong>Canvas Group</strong></span> with the <span class="strong"><strong>Blocks Raycast</strong></span>s property set to false.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec30"></a>Event system</h3></div></div></div><p>As we pointed out in the <span class="emphasis"><em>Canvas</em></span> section, every time we create a Canvas in new scene, an even system is also created. In fact, game objects contain a series of components that allow us to exchange messages between different parts of your game. In the case of the UI, the messages that are exchanged are the inputs from the user and the UI itself. Without this event system, the interaction components will not work. This is what the event system looks like in the <span class="strong"><strong>Inspector</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_03_048.jpg" /></div><p>As you can see, it is divided into modules (this might change with respect to the platform your game is addressed; there's more about this in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Through a Sea of Sprinkles – Navigation in Artificial Intelligence</em></span>). The basic functionalities exposed here allow you, for instance, to define which ones are the main interaction buttons/events (in the case of a standalone game).</p><p>However, for our purposes, we don't need to extensively know how the Even System works, how to change its settings, or how to set up a custom message. For that, I suggest you read the official documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/EventSystem.html" target="_blank">https://docs.unity3d.com/Manual/EventSystem.html</a>.</p><p>As far as we're concerned, we just leave the default settings, and every time we use the event system in our scripts, we will just use its basic functionalities, and will be explained when we encounter them.</p><p>With this said, we have covered a lot about UI, especially if you have been reading this whole section in one go. If so, I suggest you to take a little break before moving on to the next sections, which will guide us through practically using the UI interface in our game.</p></div></div>