<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec82"></a>Trading cupcake towers</h2></div></div><hr /></div><p>In this section, we will see how to allow the player to trade towers. In particular, the player can either buy, sell, or upgrade a cupcake tower. Since these three actions have something in common, we will implement them by using <span class="strong"><strong>inheritance</strong></span>. If you remember, we talked a bit about it in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Baking Cupcake Towers</em></span>, but now we have the possibility of seeing it in action. As a result, along the way we will have a better understanding of abstract methods and static variables, since we will use them again.</p><p>In any case, each one of these trading actions that the player can perform are implemented separately. This is the structure we will implement:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_07_01.jpg" /></div><p>Each of the child scripts can be attached to a UI element, and that will be transformed into a button to perform that specific action. Let's start with the parent class.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec88"></a>The trading parent class</h3></div></div></div><p>Let's start to create a general class named <code class="literal">TradeCupcakeTower</code>, and open it with your favorite code editor.</p><p>Buying, selling, and upgrading require the user to click on their icon in the user interface (we will create the UI in the scene for the trading actions after we have scripted the whole trading system first), and so we need to provide a way to detect the click (or the tap in case of a mobile application) of the player. As we have talked about it in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Communicating with the Player – the User Interface</em></span>, we can use a handler. Thus, we need to add the following library at the beginning of our script:</p><pre class="programlisting">using UnityEngine.EventSystems; &#13;
</pre><p>Now, in the definition of the class, we can add the click handler. Moreover, since this will be an abstract class, we need to specify it in the following way:</p><pre class="programlisting">public abstract class TradeCupcakeTowers : MonoBehaviour,&#13;
  IPointerClickHandler { &#13;
</pre><p>When trading, we want to check the player's sugar level (which is the currency of our game). As a result, we need to have a reference to the Sugar Meter, which is also shared among all the trading classes. Thus, we can make the variable protected and static:</p><pre class="programlisting">
<span class="emphasis"><em>// Variable to store the Sugar Meter</em></span> &#13;
protected static SugarMeterScript sugarMeter; &#13;
</pre><p>Similar to what we did in the last chapter when we had to get the reference to the game manager for all the Pandas (since also, in that case the variable was static), we need to get the reference to the Sugar Meter only once. As such, in the <code class="literal">Start()</code> function we can write:</p><pre class="programlisting">void Start () { &#13;
  <span class="emphasis"><em>//If the reference to the Sugar Meter is missing, the script gets it</em></span> &#13;
  if (sugarMeter == null) { &#13;
    sugarMeter = FindObjectOfType&lt;SugarMeterScript&gt;(); &#13;
  }      &#13;
} &#13;
</pre><p>When the player sells or upgrades a tower, the trading system should know which tower the player is referring to (how the player selects a tower is left for later in <span class="emphasis"><em>Selecting the towers</em></span> section). Therefore, again we can use a protected and static variable shared across all the trading operation classes:</p><pre class="programlisting">
<span class="emphasis"><em>//Variable to store the current selected tower by the player</em></span> &#13;
protected static CupcakeTowerScript currentActiveTower; &#13;
</pre><p>Then, we need a function to set the selection (the current active tower), and it needs to be static, so it can be easily set by other scripts (as we will see later). The function just assigns the tower passed as a parameter to the static variable:</p><pre class="programlisting">
<span class="emphasis"><em>// Static function that allows other scripts to assign the new/current&#13;
  selected tower</em></span> &#13;
public static void setActiveTower(CupcakeTowerScript cupcakeTower) { &#13;
  currentActiveTower = cupcakeTower; &#13;
} &#13;
</pre><p>Finally, we need to implement the interface for handling the click. However, the sequence of actions that should be performed depends on if the player is either buying, selling, or upgrading. Therefore, we can leave the implementation to the child classes, and leave this as an abstract function (refer to <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Baking Cupcake Towers</em></span>, on how abstract and virtual methods work) as shown here:</p><pre class="programlisting">
<span class="emphasis"><em>// Abstract function triggered when one of the trading buttons is&#13;
  pressed, however the &#13;
// implementation is specific for each trade operation.</em></span> &#13;
public abstract void OnPointerClick(PointerEventData eventData); &#13;
</pre><p>We can save the script, and as a result our parent class is ready. Now, before we implement its children for specific trading actions that the player can perform, we need to modify the <code class="literal">CupcakeTowerScript</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec89"></a>Modifying the CupcakeTowerScript</h3></div></div></div><p>Back in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Baking Cupcake Towers</em></span>, we implemented many functionalities for our cupcake towers. However, there is more work to do on their script. In particular, we need to add some variables to store their prices and costs.</p><p>Let's start by adding the following self-explanatory variables, which we may want to set into the <span class="strong"><strong>Inspector</strong></span> later:</p><pre class="programlisting">
<span class="emphasis"><em>// How much this tower costs when it is bought    </em></span> &#13;
public int initialCost; &#13;
 &#13;
<span class="emphasis"><em>// How much this tower costs when it is upgraded</em></span> &#13;
public int upgradingCost; &#13;
 &#13;
<span class="emphasis"><em>// How much this tower is valuable if sold</em></span> &#13;
public int sellingValue; &#13;
</pre><p>Every time we upgrade the cupcake tower, we want to raise both the <code class="literal">sellingValue,</code> because an upgraded tower is more valuable, and the <code class="literal">UpgradingCost</code>, because upgrading to higher levels requires more sugar. So, we can add the following lines of code in the <code class="literal">Upgrade()</code> function (the values may depend on your very specific balance of the game, but the next chapter will go into more detail on this and how to handle costs of towers in a dynamic way):</p><pre class="programlisting">
<span class="emphasis"><em>//Increase the value of the tower;</em></span> &#13;
sellingValue += 5; &#13;
 &#13;
//Increase the upgrading cost &#13;
upgradingCost += 10; &#13;
</pre><p>Save the script, and go into your cupcake tower prefabs and change the values of these three, new variables in the <span class="strong"><strong>Inspector</strong></span> (again, feel free to use the values you prefer). Here is an example:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_07_02.jpg" /></div><p>Now, we are ready to implement the trading actions, starting with buying.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec90"></a>Buying cupcake towers</h3></div></div></div><p>In this section, we will implement the script that handles the buying action. Let's start by creating a new script and name it TradeCupcakeTowers_Buying and open it.</p><p>First of all, we still need to import the event systems library from the Unity engine:</p><pre class="programlisting">using UnityEngine.EventSystems; &#13;
</pre><p>In the class declaration, we need to specify that we are going to extend the <code class="literal">TradeCupcakeTowers</code> class, instead of <code class="literal">MonoBehaviour</code>, in the following way:</p><pre class="programlisting">public class TradeCupcakeTowers_Buying : TradeCupcakeTowers { &#13;
</pre><p>If you look at the design of our user interface back in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Communicating with the Player – the User Interface</em></span>, we have three different kinds of towers that the player can buy. Each one of the buttons, once clicked, will instantiate a different tower. Therefore, we need to specify which cupcake tower prefab this instance of the script is referring to. Of course, its values should be set in the <span class="strong"><strong>Inspector</strong></span> (we will see this later). So, let's add the following variable:</p><pre class="programlisting">
<span class="emphasis"><em>/* Public variable to identify which tower this script is selling. &#13;
 * Ideally, you could have many instances of this script selling&#13;
   different &#13;
 * Cupcake towers, and the tower is specified in the Inspector */</em></span> &#13;
public GameObject cupcakeTowerPrefab; &#13;
</pre><p>Then, we need to implement the abstract function inherited from its parent, to handle what happens when the player clicks on its icon. As such, we need to use the <code class="literal">override</code> property, and declare the method in the following way:</p><pre class="programlisting">public override void OnPointerClick(PointerEventData eventData) { &#13;
 <span class="emphasis"><em> //Rest of the code</em></span> &#13;
} &#13;
</pre><p>Now, the first thing to do when the player clicks is to retrieve the price of the cupcake tower that the player wants to buy:</p><pre class="programlisting">
<span class="emphasis"><em>//Retrieve from the prefab which is its initial cost</em></span> &#13;
int price = cupcakeTowerPrefab.GetComponent&lt;CupcakeTowerScript&#13;
  ().initialCost; &#13;
</pre><p>Next, we need to check if the player has enough sugar, by using the shared static variable, <code class="literal">sugarMeter</code>. If the player has enough sugar, then a new cupcake tower is instantiated (we will see how the player places the tower later in the chapter) and it is assigned as the active tower among the trading classes:</p><pre class="programlisting">
<span class="emphasis"><em>// Check if the player can afford to buy the tower</em></span> &#13;
if (price &lt;= sugarMeter.getSugarAmount()) { &#13;
 <span class="emphasis"><em> //Payment succeeds, and the cost is removed from the player's sugar</em></span> &#13;
  sugarMeter.ChangeSugar(-price); &#13;
 <span class="emphasis"><em> //A new cupcake tower is created</em></span> &#13;
  GameObject newTower = Instantiate(cupcakeTowerPrefab); &#13;
 <span class="emphasis"><em> //The new cupcake tower is also assigned as the current selection</em></span> &#13;
  currentActiveTower = newTower.GetComponent&lt;CupcakeTowerScript&gt;(); &#13;
} &#13;
</pre><p>Save the script, and the buy functionality is implemented. Let's see how the player can sell the cupcake towers to get some sugar back.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec91"></a>Selling cupcake towers</h3></div></div></div><p>In this section, we will implement the script that handles the selling action. Create a new script and name it <code class="literal">TradeCupcakeTowers_Selling</code>, then open it.</p><p>Once again, we still need to import the event systems library from the Unity engine:</p><pre class="programlisting">using UnityEngine.EventSystems; &#13;
</pre><p>As we did for the <code class="literal">TradeCupcakeTowers_Buying</code>, we need to inherit from the <code class="literal">TradeCupcakeTowers</code> class in the following way:</p><pre class="programlisting">public class TradeCupcakeTowers_Selling : TradeCupcakeTowers { &#13;
</pre><p>Then, we need to implement the abstract function, to handle what happens when the player clicks on the selling icon. Again, we need to use the <code class="literal">override</code> property, like the following:</p><pre class="programlisting">public override void OnPointerClick(PointerEventData eventData) { &#13;
  <span class="emphasis"><em>//Rest of code</em></span> &#13;
} &#13;
</pre><p>Since selling is an action that the player is always able to perform, we don't need to do any checks (except if there is an active tower), but rather retrieve the value of the cupcake tower and add that amount to the player's savings. Then, remove the cupcake tower from the scene:</p><pre class="programlisting">
<span class="emphasis"><em>//Check if there is a tower selected before to proceed</em></span> &#13;
if (currentActiveTower == null) &#13;
  return; &#13;
 &#13;
<span class="emphasis"><em>//Add to the player's sugar the value of the tower</em></span> &#13;
sugarMeter.ChangeSugar(currentActiveTower.sellingValue); &#13;
<span class="emphasis"><em>//Remove the cupcake tower from the scene</em></span> &#13;
Destroy(currentActiveTower); &#13;
</pre><p>Finally, we can save the script. As a result, the selling functionality is also implemented. Only the upgrading one is left.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec92"></a>Upgrading cupcakes towers</h3></div></div></div><p>Here we get to create the upgrading button. Create a script and name it <code class="literal">TradeCupcakeTowers_Upgrading</code>, then open it.</p><p>Once again, we still need to import the event systems library from the Unity engine:</p><pre class="programlisting">using UnityEngine.EventSystems; &#13;
</pre><p>As we did for the other trading classes, we need to inherit from the <code class="literal">TradeCupcakeTowers</code> class in the following way:</p><pre class="programlisting">public class TradeCupcakeTowers_Upgrading : TradeCupcakeTowers { &#13;
</pre><p>Then, we need to implement the abstract function, to handle what happens when the player clicks on the upgrading button. Once more, we need to use the <code class="literal">override</code> property, like the following:</p><pre class="programlisting">public override void OnPointerClick(PointerEventData eventData) { &#13;
 <span class="emphasis"><em> //Rest of the code</em></span> &#13;
} &#13;
</pre><p>Similar to what we did with the buying button, we need to check if the player can afford to upgrade the tower, and if the tower is actually upgradable (we had a Boolean flag for that, set back in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Baking Cupcake Towers</em></span>). If so, the cost of the upgrade is subtracted from the player's sugar, and the tower is finally upgraded:</p><pre class="programlisting">
<span class="emphasis"><em>//Check if the player can afford to upgrade the tower</em></span> &#13;
if(currentActiveTower.isUpgradable &amp;&amp; currentActiveTower.upgradingCost&#13;
  &lt;=sugarMeter.getSugarAmount()) { &#13;
 <span class="emphasis"><em> //The payment is executed and the sugar removed from the player</em></span> &#13;
  sugarMeter.ChangeSugar(-currentActiveTower.upgradingCost); &#13;
<span class="emphasis"><em>  //The tower is upgraded</em></span> &#13;
  currentActiveTower.Upgrade(); &#13;
} &#13;
</pre><p>Save this script, and as a result we have completed all the trading functionalities. However, they are not present in the scene, so let's add them to our interface.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec93"></a>Adding the trading options to the user interface</h3></div></div></div><p>Now that we have the scripts to implement all the different trading buttons, we need to actually place them within our scene/level.</p><p>Therefore, let's start to create three UI images, and attach to each one of them, the <code class="literal">TradeCupcakeTowers_Buying</code> script. As their <span class="strong"><strong>Source Image</strong></span>, you can select the icons we have in our graphical package for the three different kind of towers we have. In case you didn't implement them all, that's alright, just remove the buttons you don't need. If on the contrary, you have implemented more with your own graphics, feel free to add more of these buttons. Then, after you have properly scaled the buttons, place them within our interface as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_07_03.jpg" /></div><p>Then, in the <span class="strong"><strong>Inspector</strong></span>, we need to assign their respective <span class="strong"><strong>Cupcake Tower Prefab</strong></span>. Here is just one of the three buttons, shown as an example for you:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_07_04.jpg" /></div><p>Very well, now the player can buy towers! What about selling and upgrading them?</p><p>Let's create another two UI images, and attach respectively, the <code class="literal">TradeCupcakeTowers_Selling</code> and <code class="literal">TradeCupcakeTowers_Upgrading</code> scripts to them. Then, use the icons for selling and upgrading you can find in our graphical package as <span class="strong"><strong>Source Image</strong></span>. Scale the buttons properly, and place them within our interface as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_07_05.jpg" /></div><p>We don't have any variables to assign in the <span class="strong"><strong>Inspector</strong></span>, so we can consider our trading system ready! Although to make it work properly, we still need to have a way to place our towers and a way to select the towers. These will be explored in the next sections.</p></div></div>