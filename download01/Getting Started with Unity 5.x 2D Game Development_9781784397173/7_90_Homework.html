<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec89"></a>Homework</h2></div></div><hr /></div><p>In this chapter, we have covered many techniques on how to exchange information between different parts of our game, and learnt a bit about gameplay programming. Here there are some exercises to improve your skills and become a better game developer:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p><span class="strong"><strong>Sweet capital</strong></span>: When the the game begins, Pandas start coming and the player should buy some cupcake tower to defend his/her cake. But, at the very beginning, the player doesn't have any sugar to buy towers, nor he/she can kill some Pandas to get some sugar. Thus, add an initial sugar amount variable in the <code class="literal">Game Manager</code> (so that it can be set from the Inspector), and set this quantity in the <code class="literal">Sugar Meter</code> within the <code class="literal">Start()</code> function. As a result, the player will be immediately ready to fight Pandas.</p></li><li><p><span class="strong"><strong>The calm before the storm</strong></span>: At this stage, when the game starts, the Pandas immediately come to eat the player's delicious cake. However, the player should have the time to buy and place some cupcake towers at the beginning, with the capital set from the previous exercise. In the <code class="literal">wavesSpawner()</code> coroutine, set a timer before each wave to give the player the time to assess. Then, expose the right variables in the <span class="strong"><strong>Inspector</strong></span>, so as to tweak the timer depending on the level. Consider, as a variant, that you can increase or decrease such a timer between waves.</p></li><li><p><span class="strong"><strong>Wave bonus (Part I)</strong></span>: If you are planning to increase the number of Pandas spawned significantly between waves, then you should consider rewarding the player with some sugar once the wave is completed. Modify the <code class="literal">wavesSpawner()</code> coroutine to include a sweet bonus for the player. Then, expose the right variables in the Inspector to tweak the bonus for each level.</p></li><li><p><span class="strong"><strong>Wave bonus (Part II)</strong></span>: After have done the previous exercise, make an array of bonuses, where its dimension changes according to the number of waves. Then, at the end of each wave, assign the right bonus to the player, so as to have the possibility to tweak the bonus not only for each level, but also for each wave.</p></li><li><p><span class="strong"><strong>Singleton pattern (Part I)</strong></span>: In our game, there are some scripts that should have a single instance at the time, such as the <code class="literal">Game manager</code>, the <code class="literal">Health Bar</code>, or the <code class="literal">Sugar Meter</code>. As such, it's best practice to make them unique, since some of our scripts rely on the implicit (but not granted) fact that there is only one instance of such classes. Therefore, you should implement a pattern called <span class="strong"><strong>singleton</strong></span>. You can definitely search on the Internet how to implement it, but try to come up with your own personal solution. Many online implementations rely on a static variable to retrieve the single instance of the class. Since our script will find these classes with the <code class="literal">FindObjectOfType()</code> function, you can try to explore other ways. So, try to give your solution to the problem and implement it for the <code class="literal">GameMangerScript</code>, the <code class="literal">HealthBarScript</code>, and the <code class="literal">SugarMeterScript</code>.</p></li><li><p><span class="strong"><strong>Singleton pattern (Part II)</strong></span>: After Part I, you should have implemented the singleton pattern in your way. Now, look at the following two links: <a class="ulink" href="http://wiki.unity3d.com/index.php/Singleton" target="_blank">http://wiki.unity3d.com/index.php/Singleton</a> and <a class="ulink" href="https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager" target="_blank">https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager</a>, since both implement the singleton pattern. Compare those to the ones you came up with, and highlight for each approach, the advantages and the disadvantages. Which approach do you think would work better in our game? Does the approach differ for the <code class="literal">Game Manager</code>, the <code class="literal">Health Bar</code>, or the <code class="literal">Sugar Meter</code>? Implement the singleton pattern you consider worthwhile for our tower defense game.</p></li><li><p><span class="strong"><strong>Improving the allowed areas (Part I)</strong></span>: We have seen how it is possible to use colliders to check if the mouse is hovering over allowed areas, so that the placing script knows if it is a suitable place or not when it needs to release the cupcake towers. But what happens in the <code class="literal">Game Manager</code>? Even if there is no tower to place, it stills checks for allowed areas and updates its internal state. Think about a solution in which the <code class="literal">Game Manager</code> checks if the mouse is hovering over allowed areas only when the placing scripts asks for it. As a result, your new solution should improve the performance of the <code class="literal">Game Manager</code>.</p></li><li><p><span class="strong"><strong>Improving the allowed areas (Part II)</strong></span>: This exercise is independent from part I. In the allowed areas system, we have considered only the mouse. What about if you want to export the game on a mobile platform, such as on an Android device? In this situation, should the allowed area system be completely redesign or changed? As such, design and implement a system which is suitable for as many platforms as possible.</p></li><li><p><span class="strong"><strong>Improving the allowed areas (Part III)</strong></span>: This exercise is independent from Parts I and II. The system of allowed areas we came up with is not really easy to use for a multi-level game (something that, most likely, you have), since you cannot place colliders in the <code class="literal">Game Manager Prefab</code> as they depend on the particular level. Can you think of an easier solution for level designers to tell the <code class="literal">Game Manager</code> which areas are allowed, level by level? Once you have designed such a system, implement it in our tower defense game.</p></li><li><p><span class="strong"><strong>Improving the allowed areas (Part IV)</strong></span>: Consider all the solutions you have found for the different problems faced in Parts I, II, and III. Try to merge them together into an ultimate solution for the allowed areas. The goal is to create a system which is efficient (from a computational point of view), easy-to-use (for game and level designers), and multi-platform (so as to deploy the game on more than one platform) at the same time.</p></li><li><p><span class="strong"><strong>Feedback to the player (Part I)</strong></span>: This is a series of exercises all independent of each other, and they aim to improve the feedback that the game provides to the player, which is of vital importance for a game to be appealing. When the player trades, he/she sells, buys, or upgrades towers, but there is no feedback that the operation was a success. Therefore, you need to implement some visual feedback. Consider the following as smaller exercises:
</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>When sugar is detracted or added to the <code class="literal">Sugar Meter</code>, add an animation so that a big number appears on the <code class="literal">Sugar Meter</code> showing the quantity that changed. Moreover, consider changing the color of this number based on the amount, and whether it is added or subtracted.</p></li><li style="list-style-type: disc"><p>When the sugar is detracted or added to the <code class="literal">Sugar Meter</code>, add an animation to show the numbers of the <code class="literal">Sugar Meter</code> changing, instead of suddenly changing the number displayed.</p></li><li style="list-style-type: disc"><p>When a tower is upgraded, consider placing an animation that plays on the tower. Same for when the tower is sold or placed (after have bought it).</p></li></ul></div></li><li><p><span class="strong"><strong>Feedback to the player (Part II)</strong></span>: This is a series of exercises all independent of each other, and they aim to improve the feedback that the game provides to the player, which is of vital importance for a game to be appealing.When the player trades, he/she sells, buys, or upgrades towers, but there is no feedback about what the operations are going to do/change, such as: which one is the price of buying a tower? Therefore, you need to implement some visual feedback. Consider the following as smaller exercises:
</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>When the player hovers over one of the trading buttons, make the price (or the value in case of the selling button) appear somewhere (which needs to be decided carefully, since it impacts the design we did in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Communicating with the Player – the User Interface</em></span>), so the player can read it before, to perform the action.</p></li><li style="list-style-type: disc"><p>When no tower is selected, both the selling and the upgrading buttons shouldn't be displayed as active. Change this, to display a disable button when the <code class="literal">currentActiveTower</code> variable is null.</p></li></ul></div></li><li><p><span class="strong"><strong>Implementing a setting menu (Part I)</strong></span>: In this chapter, we left this as an exercise, so let's see what we need to do. The first thing to decide is what settings the player can change and how (a toggle? A slider? A drop-down menu?). In particular, you should have at least an audio toggle, and a quality settings drop-down menu, plus any options you would like to include. Then, make a complete design of the UI. Finally, in Unity create a new scene (or screen, whichever you prefer) and implement the settings screen by using UI elements.</p></li><li><p><span class="strong"><strong>Implementing a setting menu (Part II)</strong></span>: In Part I, we did the design and implemented it within Unity. Now, we need to implement the functionalities (except the audio for now, which is left for the next chapter). So, create a script, and similar to what we did with the main menu, implement all the functionalities there, and link them to the UI elements through the use of events in the <span class="strong"><strong>Inspector</strong></span>. To modify the quality settings and the audio settings, search the official documentation on how to do it (this is part of the exercise). Moreover, keep in mind that the next chapter might give you some other ideas of the kind of settings to implement.</p></li><li><p><span class="strong"><strong>Magic numbers (Part I)</strong></span>: We already have encountered magic numbers in the previous chapters. They are numbers that appear within a script and without an explanation, and good practice says that it is better to avoid them as much as possible. Also in this chapter, we have left many of them; let's try to remove them. The first magic number is the number <span class="emphasis"><em>7</em></span> from the placing script when we create a new vector for the position of our tower. This number depends on the position of the camera and where the tower should be placed along the <span class="emphasis"><em>z</em></span>-axis. As such, add some lines of code to calculate this number in a dynamic way (so if we decide to change the camera position or the <span class="emphasis"><em>z</em></span>-depth of the towers, we can do it without changing the script, as a bonus, you will have the possibility of also having different kinds of towers on different z-depth layers, which can be useful to you in the same way). In particular, you need to subtract the <span class="emphasis"><em>z</em></span>-axis of the tower from the <span class="emphasis"><em>z</em></span>-axis of the camera.</p></li><li><p><span class="strong"><strong>Magic numbers (Part II)</strong></span> : We have also left some magic numbers in the <code class="literal">Upgrade()</code> function of the <code class="literal">CupcakeTowerScript</code>. Create variables that can be set in the <span class="strong"><strong>Inspector</strong></span>, to remove any magic numbers that are left (such as increasing the selling value or the upgrade cost).</p></li></ol></div></div>