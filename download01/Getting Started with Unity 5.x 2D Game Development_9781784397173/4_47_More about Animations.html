<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec49"></a>More about Animations</h2></div></div><hr /></div><p>We have seen a lot about the Animation workflow in Unity, yet a lot has been left out. This section presents some relatively advanced topics of the Animation workflow in Unity, and they are not needed to develop our Tower Defense Game. In fact, some of these applies only on 3D, but I feel that it's worthwhile to mention them to have a rough, but complete picture of the whole workflow for Animations in Unity. Therefore, feel free to skip this section, or read without focus to understand completely what's written. You can always come back here later, maybe when you've finished the book, for a deeper look to its content.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note51"></a>Note</h3><p>All the following sections are not intended to explain in detail how to use these tools in Unity, but rather to be aware of their existence and functionalities so as to learn them later on when you are a bit more practical with Unity.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec43"></a>Avatars</h3></div></div></div><p>In the case of 3D characters, and especially for humanoids, you need to <span class="emphasis"><em>rig</em></span> your character, which means to match all bones of the 3D model into a Unity Avatar. If the model is well done and optimized for Unity, this process can be automatized; otherwise it needs to be done by hand, as shown in this picture:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_056.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note52"></a>Note</h3><p>In the scene view, there is your 3D model, from which you can drag and drop the parts of his/her/its body in the avatar.</p></div><p>In this way, Unity stores additional information about the 3D model. It stores not only the matching bones, but also muscles. The main reason is that by doing it in this way it is possible to perform retargeting, which means using the same animations for different character. Suppose you have a beautiful walking animation, and you want to apply it to all your characters. But some of them are tall. Others are fat or full of muscles. The Avatar stores this additional information to overcome the problem and adapt the walking animation to each character.</p><p>Furthermore, Unity also allows masking, which means to discard part of the Animation clip data and uses specific parts only. For instance, imagine you have a beautiful walking animation and an animation of someone drinking a glass of water. Suppose you want to make your character to drink a glass of water while he or she keeps walking. By masking the drinking animation, we are able to crop it just onto the upper body part. As a result, we can leave the walking animation playing on the legs, while the drinking one is playing on the upper body of the character.</p><p>If you imagine a complex game, where the characters can do many things while walking (such as shoot, reload or talk) this functionality is really helpful. Keep in mind that masking can be done to different levels. For instance, you can merge more than two animations together with respect to different body parts, as well as sub-masking. The possibilities are endless!</p><p>That's why Unity offers also a more detailed mapping when required, for instance, for the head or the hands, as the next picture shows, where we can see the mapping for the left hand:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_057.jpg" /></div><p>All of this is really powerful when used in combination with sub-state machines, state-behaviors and Layers in the Animator.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec49"></a>Sub-state machines</h4></div></div></div><p>Previously, we have seen that the Animator is a finite state machine with different states, each one of them as an animation clip. But in actual fact, not all of the states are animation clips. Some of them can be something else, such as sub-state machines. This means, that a state can contain another whole finite state machine!</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_058.jpg" /><div class="caption"><p>A sub-state machine appears into the upper level like a state, though with a slightly different shape. In fact, transitions can both start or end on a sub-state machine like any other state.</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note53"></a>Note</h3><p>You can recognize a sub-state machine since the shape around the name is slightly different.</p></div><p>In this scenario, the exit state/node becomes important, because it allows us to finish/exit from the sub-state machine and continue in the next state. Of course, also a sub-machine can be interrupted if set to do so when some conditions are met. Needless to say, being able to nest animation machines is indeed a very powerful tool to build very complex Animators.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec50"></a>The hierarchical location menu</h4></div></div></div><p>As we have seen, states can contain sub-states and trees and these structures can be nested repeatedly. When drilling down into sub-states, the hierarchy of parent states and the current state can be viewed on the top bar (highlighted in the following picture):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_059.jpg" /></div><p>Clicking on the parent states allows you to jump back up to parent states or go straight back to the base layer of the state machine.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec44"></a>Layers in the Animator</h3></div></div></div><p>Now, if we want to create, view, or edit layers within our Animator Controller, we need to make sure that the left-hand pane is set to Layers view, like this image:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_060.jpg" /></div><p>This allows you to have multiple layers of animation within a single animation controller. All these layers are then able to run at the same time, where each layer is controlled by a separate state machine. This process is commonly used when, for instance, you have a separate layer playing upper-body animations over a base layer that controls the general movement animations for a character (to use in combination with Avatar Masks).</p><p>To begin, click on the plus icon to add a layer. On the other hand, to delete a layer, select the layer and press the <span class="emphasis"><em>Delete</em></span> key.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec45"></a>Blending trees</h3></div></div></div><p>Besides Animation clips and sub-state machines, a state in the Animator can be also a blending tree. A common process to apply between different frames of an animation is to blend two or more similar motions, so that it feels like one fluid animation. For example, walking and running animations may require that key frames are blended between one another according to the character's speed. Ideally, you want the player to be slower if they are walking and faster if they are running. In some cases, the speed of how fast a player runs can also be increased again with game elements such as items (speed boosts). Another typical example is to lean the character left or right while they are turning to achieve a more realist behaviors. This can be obtained with blend trees, which are able to <span class="emphasis"><em>blend</em></span> animation clips.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_061.jpg" /><div class="caption"><p>An example of a very common blending tree; Here the walking animation is split in three animation clips, so the character can lean to the left or right as he/she turns during the walk</p></div></div><p>In fact, they use linear interpolation, which can be controlled by some weights and parameters. Unity supports both 1D and 2D interpolation for blending trees.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_062.jpg" /><div class="caption"><p>2D interpolation of Blending trees. Numbers and animation clips are placed at random, the aim of the figure it's showing the 2D interpolation in the upper part, where the diamond shapes are the different animation clips and the circle shape is the 2D value that controls the blending among the clips.</p></div></div><p>We won't go further into blending trees, but keep in mind that they can be used to blend more animations together in real time to achieve incredibly real behaviors and smoother animations.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec46"></a>Animator Override Controller</h3></div></div></div><p>Imagine that you have just created a beautiful Animation State Machine, full of layers and transitions, since it is super detailed. Your character has states that allows her to cast a spell, to grab a coffee or to swing a sword. However, now, you need to consider that also a Goblin can do that. And even the Ogre of your second level as well as the elf that your protagonist has to fight later on in your game. Should you create again a very similar Animation Machine for each one of them, but just changing the Animation clips? And what if later on you decide to slightly change the controller, do you have to slightly change all of them? Thank God, Unity offers an easier way, called the <span class="strong"><strong>Animator Override Controller</strong></span>.</p><p>You can create an <span class="strong"><strong>Animator Override Controller</strong></span> by right-clicking on the project panel and navigate to <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Animator Override Controller</strong></span>. It will be an asset as the others Animator controllers. However, you cannot open it in the <span class="strong"><strong>Animator</strong></span> window. If you select it in the <span class="strong"><strong>Inspector</strong></span>, you will see that you can link a normal Animator controller to it, as shown in this screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_063.jpg" /></div><p>Just for the sake of learning, we drag and drop the only controller that we have in our project, the panda controller. As a result, all the Animator states we used will appear in a list, and we can assign a different animation clip from the original controller.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_064.jpg" /></div><p>In this way, you don't need to replicate the Animator controller but just assign new animation clips. Once the Animator controller changes, all the <span class="strong"><strong>Animator Override Controllers</strong></span> will change accordingly, updating all the characters in your game that use that controller. Not bad, isn't it?</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec51"></a>Culling Mode in the Animator component</h4></div></div></div><p>For a moment now, picture a beautiful animation of a shiny coin. It is so beautiful that you decide to include many coins in your game. As a result, it might be computationally heavy to make rotate thousands of coins if then the player can see just three on his or her screen.</p><p>Consider, instead, this other case. The player just turned a switch that triggers a really heavy and slow door. So, while the door is opening, the player explores a bit the environment. When he or she comes back, the player would expect that the animation of the door is complete and so the door is open. This means that the animation of the door should run also when it is not visible, whereas the coin is not needed to be animated in any moment, for instance when it is off screen.</p><p>To optimize this issue, Unity offers an option in the Animator component, the <span class="strong"><strong>Culling Mode</strong></span>. This allows us to specify when the object should animate. The possible values are the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Always Animate</strong></span>: The most expensive, although realistic, solution. As the name suggests, the object is always animated, so in the case of the door also, when it is off screen, it will keep opening.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Cull Update Transforms</strong></span>: This is a mid-solution; it disables only some parts, such as Retargeting and IK, to improve performance, but still has a certain degree of realism when needed, without paying too much in computational cost.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Cull Completely</strong></span>: This is the cheapest from a computational point of view, since the object stops being animated completely when it is off screen.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec52"></a>Root motion</h4></div></div></div><p>Some animations, in theory, should displace the character, such as walking but not drinking a glass of water. So in order to fix this issue in Unity, you can either move the character with a script, as we did in our case, or use root motion. As the name suggests, this allows the animation itself to move the root of the character (or object or creature) achieving a more realistic motion in space.</p><p>However, it is not straightforward and has some drawbacks. For instance, it is more expensive from a computational point of view, and as such, many characters with root motions on low-end devices could be prohibitive. Furthermore, it requires different tweaks, especially if the animation is not really well done.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec53"></a>Inverse Kinematic</h4></div></div></div><p>Inverse Kinematic is something relatively new in video games. It allows you to have a target into the animation, and sometimes compute in real time an animation that suits the target. For instance, imagine a character who just wants to rest his or her hands on the wall. The Inverse Kinematic should allow you to control the animation to place the hand on the wall, regardless of whether the wall is 1 centimeter further or closer.</p><p>Usually animations use what is called Direct Kinematic (or Forward Kinematic). Based on the position and rotation of the joints, it is possible to determine the position of each part of the skeleton. So imagine having an arm, and based on the positions and rotations of your shoulder, elbow, and wrist, you can determine the position and rotation of your hand. In fact, these techniques come from robotic research.</p><p>The inverse problem, known as Inverse Kinematic, is to determine the positions and rotations of your shoulder, elbow, and wrist starting from the position and rotation of your hand. However, this problem is not uniquely determined, since it might have infinite solutions. Therefore, solving this problem wasn't straightforward. In any case, different techniques (which in the case of robotics may involve inverting the Jacobian matrix) were developed to solve this problem.</p><p>The problem with having different solutions is that some of them may lead to very unusual poses. Following again the example of the arm, a solution that, in order to rest the hand to the wall, brings the elbow up to the eye is not really believable (see the next image, on the left). Whereas this might be a relative problem if applied to robotics, in animation this is indeed a big problem, because we want our characters to be believable.</p><p>So, other techniques have been developed to solve the problem, and the study of social behaviors (for humanoid characters) have been conducted to understand why some poses are more realistic than others. For instance, the pose in the preceding picture is tiring; nobody will ever rest his hand on the wall in such way. In fact, this also deals with physics, since our brain tries to control our body in such a way to spend as less energy as possible. This results in an unconscious behavior that we recognize in other people, and our videogame characters need it as well.</p><p>Unity implements some of these techniques, and Mecanim supports some kind of Inverse Kinematic for humanoid characters, given that they have a correct configured avatar. However, we don't want to dig any deeper in this. I just leave the most curious reader with the link to the Official Documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/InverseKinematics.html" target="_blank">https://docs.unity3d.com/Manual/InverseKinematics.html</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note54"></a>Note</h3><p>Another example where Inverse Kinematic is studied and used is for virtual presence in virtual reality. The recent Oculus Touch allows you to have your hands within the Rift Headset, but not your elbow and/or shoulder. While implementing inverse kinematic-even taking into account the believability and the less energy pose-the software is yet not able to precisely map your arm positions in space, because you will feel awkward. However, in multiplayer games, you can see other people in the virtual world but not in reality (or feel their bodies like they do), and therefore Inverse Kinematic can be applied. Although it won't give the exact position of the elbows of the other players in the game, it is close enough to be believable. A game that uses this mechanism is for instance Dead and Buried. As you can see from the next picture, you can see only your hands, but of the other players, you can see their whole bodies.</p></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_04_64.jpg" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec47"></a>Animator component information box</h3></div></div></div><p>As we already mentioned before, the Animator component has an information box at the bottom, which may contain some useful data. Here is a picture of the information box again, for your reference:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_066.jpg" /></div><p>Besides the <span class="strong"><strong>Clip Count</strong></span> that we already have seen, here is a briefly list of the other information:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Pos</strong></span>, <span class="strong"><strong>Rot</strong></span>, and <span class="strong"><strong>Scale</strong></span>: These indicate the total number of curves used respectively for the position, rotation and scale. The animation window, the one we didn't see in detail, allows you to create such curves.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Muscles</strong></span>: The number of muscles used in the Animator in case of Humanoid characters.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Generic</strong></span>: The number of numeric curves used by the Animator to animate other properties.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>PPtr</strong></span>: The total count of sprite animation curves; it is useful when we work in 2D.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Curves Count</strong></span>: The total combined number of animation curves.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Constant</strong></span>: The number of animation curves that are optimized as constant values. Unity selects this automatically if your animation files contain curves with unchanging values.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Dense</strong></span>: The number of animation curves that are optimized using the <span class="emphasis"><em>dense</em></span> method of storing data (discrete values, which are interpolated between linearly). This method uses less significantly less memory than the <span class="emphasis"><em>stream</em></span> method.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Stream</strong></span>: The number of animation curves using the <span class="emphasis"><em>stream</em></span> method of storing data (values with time and tangent data for curved interpolation). This data occupies significantly more memory than the <span class="emphasis"><em>dense</em></span> method.</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec54"></a>Legacy animation</h4></div></div></div><p>A simpler animation system was used by Unity prior to the introduction of Mecanim (in year 2012, with Unity 4.0). Given that some time has passed since then, backward compatibility is still available. As a result, it is still possible to continue working on older projects without having to update Mecanim or worrying about other issues arising from the software.</p><p>Some people find the Legacy animation system useful for fast prototyping and/or testing animation clips, especially when the object has only one animation clip. This is because it was based on the Animation component (picture given next), and it should not be confused with the Animator component that we have seen before in the chapter.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_067.jpg" /></div><p>You can find out more about the Legacy animation system here in the official documentation: <a class="ulink" href="https://docs.unity3d.com/Manual/Animations.html" target="_blank">https://docs.unity3d.com/Manual/Animations.html</a>.</p><p>So, unless you have a specific need for it, you can completely ignore the Legacy Animation system, but it was worthwhile to mention it so that you don't get confused in case you found the Animation component and didn't know what it was.</p><p>In saying that, and while the legacy animation is still available, it is not recommended that you use it for new projects with Unity.</p></div></div></div>