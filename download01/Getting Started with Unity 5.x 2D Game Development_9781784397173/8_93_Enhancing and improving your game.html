<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec91"></a>Enhancing and improving your game</h2></div></div><hr /></div><p>The aim of this section is to give you an idea of the potentiality of your game and a direction to work toward. After all, if you have reached this far, you will also be able to walk by yourself, and so I won't explain everything in detail.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec107"></a>Improving cupcake towers</h3></div></div></div><p>Here we will focus on how we can improve our cupcake towers by exploring some ideas and new directions, such as shooting policies or a special kind of sprinkles.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec70"></a>Shooting policies</h4></div></div></div><p>Back in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Baking Cupcake Towers</em></span>, we implemented the first cupcake tower that shot the Panda closest to the tower. However, this is not the only policy that you can pick. Actually, you can also allow the player to pick one that suits better for his/her strategy.</p><p>These policies may include:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Shoot the weaker/stronger Panda</p></li><li style="list-style-type: disc"><p>Shoot the Panda with less/more health</p></li><li style="list-style-type: disc"><p>Shoot the furthest Panda within the range</p></li><li style="list-style-type: disc"><p>Shoot the first/last Panda that enters in the range</p></li></ul></div><p>Feel free to add more and implement your own.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip108"></a>Tip</h3><p><span class="strong"><strong>How to implement these</strong></span>:</p><p>In <code class="literal">CupcakeTowerScript</code>, we loop over all the Pandas (actually colliders, but we filter them by tag). We have found and calculated the distance from each one of them. Some concepts can be applied with the preceding list. In the case of the furthest Panda, this is immediate, because instead of having the <code class="literal">min</code> variable, you can have a <code class="literal">max</code> variable. The same holds true for weaker/stronger and with less/more health Pandas, in which you still need to have a <code class="literal">min</code> or <code class="literal">max</code> variable, but instead of the distance, you take some properties from the <code class="literal">PandaScript</code>. The case in which we are searching the first or last Panda that has entered the range is a bit trickier. In fact, you need to have a data structure for the Pandas that enters and exits from the range, and then retrieve the Panda to shoot from this structure.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec71"></a>Special sprinkles</h4></div></div></div><p>In our game, all of the sprinkles just have a damage and a speed, which can be set by the Cupcake towers that shoots them. However, you can have more types of sprinkles, and some of them can have special effects.</p><p>Some examples of these effects might be the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Freeze</strong></span>: A probability to slow down the enemy for a limited period of time.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Poison</strong></span>: A probability to poison the Panda; that will decrease its health over time (usually within a short period of time).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Explosive</strong></span>: They don't damage only the Panda that they hit, but also surrounding Pandas.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Critical hit</strong></span>: A probability that the sprinkle could kill the Panda regardless of its remaining life. But for instance, it is not applicable for bosses, which in a critical hit just receive double the damage.</p></li></ul></div><p>Feel free to add your own.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip109"></a>Tip</h3><p><span class="strong"><strong>How to implement these</strong></span>:</p><p>You can create special sprinkle classes that derive from the <code class="literal">ProjectileScript</code> class by using inheritance. This derivative class can contain additional data about their effects. In <code class="literal">PandaScript</code>, you can retrieve in the <code class="literal">OnTriggerEnter2D()</code> function which kind of sprinkle hit the Panda, so as to retrieve its information and apply an effect to the Panda.</p><p>In the case of the explosive effect, the Panda that was hit should use the <code class="literal">Physics2D.OverlapCircleAll()</code> function (as in <code class="literal">CupcakeTowerScript</code>) to find nearby Pandas.</p></div><p>Moreover, you can animate them so that they have nice and smooth animation. Even just a rotation animation could be awesome to see.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec72"></a>Aging and pricing model</h4></div></div></div><p>Who said that a tower cannot get old? Given that a Cupcake tower is shooting at Pandas continually from its creation, it might be subjected to usury. As such, its performance may decrease over time and also its value if the player tries to sell it.</p><p>You can add another trading option to repair a cupcake tower and get it back to work as it should.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip110"></a>Tip</h3><p><span class="strong"><strong>How to implement this</strong></span>:</p><p>You can implement a coroutine within <code class="literal">CupcakeTowerScript</code> that after a fixed amount of time, it ages the tower, by lowering its stats, eventually until it stops to work. If you also want to implement a repair functionality, you need to store the original values of the tower somewhere in order to restore them after the repairing option.</p></div><p>Besides aging, what about the various prices and costs that change over time dynamically? Ideally, you would like to create a real pricing model for that (which takes a lot of design efforts), but it would be greatly appreciated once it works. In fact, it's something to take into consideration when you balance your game.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip111"></a>Tip</h3><p><span class="strong"><strong>How to implement this</strong></span>:</p><p>Again, you can create a coroutine within <code class="literal">CupcakeTowerScript</code> that, based on the current state of the tower (and potentially of the game), changes its costs. As a result, when the trading system fetches these values, they are updated based on your model price.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec108"></a>Improving the user interface</h3></div></div></div><p>Also, the user interface of our game can be improved, for instance, a notification indicating to the player how many waves he/she has still to defeat. Adding this kind of information can be extremely useful. The next step is then to determine, where?. This is another design choice that should be taken into account, because it might affect the balance we reached when we designed the current UI back in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Communicating with the Player – the User Interface</em></span>.</p><p>So a good exercise would be to iterate the design of the whole interface of the game by taking into account as many things as possible (including showing the prices and costs in the trading system; there was an exercise on this in the previous chapter).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note112"></a>Note</h3><p>A really good book on how to design user interfaces is <span class="emphasis"><em>Designing with the Mind in Mind</em></span> by Jeff Johnson, but this is just one of many, so be sure to check out other more specific books about UI in video games.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec109"></a>Improving levels</h3></div></div></div><p>Here we will focus on things we can do to improve our levels. As for the cupcake towers in the previous section, we will explore new ideas and directions, such as including more levels, enemies, and paths to follow.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec73"></a>Multilevel</h4></div></div></div><p>Of course, your game must contain more than one level! We have implemented only one level, but you should definitely expand your game to more than one.</p><p>At this stage, you are able to create your own map and level. But here are a few hints and considerations that you might find useful:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Remember that static variables are persistent. Therefore, they need to be reassigned with the correct values when you change the scene.</p></li><li style="list-style-type: disc"><p>You can make some objects persistent between scenes by using the <code class="literal">DontDestroyOnLoad()</code> function (useful when you need to implement music; we will see this in <span class="emphasis"><em>Audio</em></span> section).</p></li><li style="list-style-type: disc"><p>You have to take designing choices, such as: is the sugar collected by the player preserved among levels? And his/her health?</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec74"></a>Large maps</h4></div></div></div><p>We can implement very large maps in the game, so large that they cannot be displayed all at once on the screen. In this way, we need to implement a way that the user can move the camera so as to move the level (or you can also implement that the camera is fixed, and all the rest moves).</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip113"></a>Tip</h3><p><span class="strong"><strong>How to implement this</strong></span>:</p><p>Attached to the camera, you can create a script, which detects when the player drags the mouse, so as to move the camera in the opposite direction (left drag, camera moves right).</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec75"></a>Many paths</h4></div></div></div><p>Nothing prevents us from creating a map where the path for the Pandas at a certain point splits or merges with other paths. We can even have more spawning points, or more than one way of access to the cake.</p><p>All of this can be taken care of by our waypoint system. In fact, the Pandas call the <code class="literal">GetNextWaypoint()</code> function, which can return any waypoint in the map.</p><p>As such, you can create many different waypoints that inherit from the parent class of waypoint. In the case of a split, you can randomly choose where to send the Panda. Here is a fragment of code to give you an example when the path splits in two:</p><pre class="programlisting">[SerializeField] &#13;
private Waypoint waypoint1, waypoint2; &#13;
 &#13;
public override Waypoint GetNextWaypoint() { &#13;
  if(Random.Range(0,2) == 0) { &#13;
    return waypoint1; &#13;
  }else { &#13;
    return waypoint2; &#13;
  } &#13;
} &#13;
</pre><p>But you can really implement whatever you have in mind as far as you reason in terms of waypoints! You can also make <code class="literal">GetNextWaypoint()</code> accept some parameter, such as the Panda itself, and based on the Panda also decide on which waypoint to send the Panda! Basically the possibilities are many, and the structure to have waypoints as single entities allows us to do this kind of stuff.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec76"></a>Many Pandas</h4></div></div></div><p>We cannot limit ourselves to just one type of Panda! We can make green, red, and purple Pandas too! Each one of them can have different stats. For instance, some are really slow, have a lot of health, and do eat a lot of cake. Others are really fast, have low health, and eat just a moderate bite of the player's cake when they reach it.</p><p>You might even think about giving them different abilities, and again you can use the concept of inheritance to implement other Panda classes that derive from the <code class="literal">PandaScript</code>. However, remember to keep in mind that you also need to change the spawning system!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec77"></a>Multiphase bosses</h4></div></div></div><p>Among the different kinds of Pandas, you can add at the end of the level a boss to defeat a giant Panda with a crown on its head:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_08_001.jpg" /></div><p>The different phases of the boss can be structured with a finite state machine, and the different transitions triggered by the amount of its health or how close it is to the player's cake. It might also have the possibility to get really angry and go off the track to eat a cupcake tower!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec78"></a>A better spawning system</h4></div></div></div><p>Since we added so many different kinds of Pandas, we need to restructure our spawning system. Ideally you want to find a solution easier for designers to show in the <span class="strong"><strong>Inspector</strong></span> an array with the different waves, and for each wave how many enemies of one kind and how many enemies of another kind, like this image:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_08_002.jpg" /></div><p>You may be wondering whether this can really be done in the Unity Inspector. The answer is yes; in fact, the Unity Editor can be extended (we will see later in this chapter).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec79"></a>Switching difficulty at runtime</h4></div></div></div><p>Another great way to adapt the game to a large audience might be to switch the difficulty of the game at runtime, based on the player's performance. In fact, you may want to keep players who seek challenges engaged by increasing the level of difficulty if they are progressing relatively easily through the game, or help players that are struggling.</p><p>There are different ways to do it. The simplest one includes if-chains, based on the player's score to increase or decrease the difficulty; whereas the most complex ones include adaptive learning algorithms.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip114"></a>Tip</h3><p><span class="strong"><strong>How to implement this</strong></span>:</p><p>Whichever your way is, the first thing to do is to link your entire game to a difficulty parameter, maybe within the <code class="literal">Game Manager</code>. Whenever, this parameter is changed, all the parts of the game dependent on it change (refer the <span class="emphasis"><em>More about communication between scripts</em></span> section). Then on a separate script, you can implement your adaptive algorithm, which, fed with the different states of the game, can determine whether to increase or decrease the difficulty.</p></div></div></div></div>