<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec48"></a>Animations</h2></div></div><hr /></div><p>Life and all of its creatures are dynamic. We move, and our movements, even the subtlest of ones, express emotions. If we were to remove such things, even the tiniest smile, life would become dull and static. Animation effects can range from the simplest of things such as a flag waving to a dragon flying. Just look around you, inside and outside; something will be moving or will move from time to time. Even stones move, albeit with wind, something knocking them, or someone skipping them across water.</p><p>Unity has a complex animation system, also known as <span class="strong"><strong>Mecanim</strong></span>, which requires time to get used to. It includes different components. Some of these are specifically for 3D animations; others can be used for both 2D and 3D. Usually, animating in 3D is harder than in 2D since it requires tweaking of many parameters, and therefore much more practice is needed to master it. If you are interested in learning more about 3D animation in Unity, I suggest that you to read a specific book about it.</p><p>In this book, we will focus on animating only in 2D. As such, our workflow becomes simple enough that it can be explained within this chapter. In particular, we will go through the following workflow:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Creating some files called animation clips, to store our animations. We will do this starting from animation Sprite Sheets.</p></li><li style="list-style-type: disc"><p>Building a finite-state machine to control the flow of the animations.</p></li><li style="list-style-type: disc"><p>Writing a script to control the finite-state machine triggers.</p></li></ul></div><p>Specifically, in this section, we will see how to animate our terrible sweet-tooth pandas. In our graphic package, we can find the animation Sprite Sheets of the panda under the <code class="literal">Graphic/Enemies</code> folder. Of course, all the Sprite Sheets should already be sliced, as we have seen back in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>A Flat World in Unity</em></span> and if you are using your own graphics, it is better if all the single sprites have the same dimensions. But before we go any further in exploring Mecanim, let's go through some background information about animation in the next two sections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec35"></a>A historical overview</h3></div></div></div><p>The term <span class="emphasis"><em>animation</em></span> derives from the Latin word <span class="emphasis"><em>animates</em></span>, which is the past participle of the verb <span class="emphasis"><em>animare</em></span>; that means <span class="emphasis"><em>give breath to</em></span>. The verb derives from the word <span class="emphasis"><em>anima</em></span>, which means <span class="emphasis"><em>life, breath</em></span>, originating from the Greek word <span class="emphasis"><em>anemos</em></span>, literally <span class="emphasis"><em>wind</em></span>, which in turn descend from the Sanskrit word <span class="emphasis"><em>aniti</em></span>, meaning <span class="emphasis"><em>breathes</em></span>. It was only during the 1742 that the verb <span class="emphasis"><em>to animate</em></span> was used for the first time with the sense of <span class="emphasis"><em>give life to</em></span>.</p><p>Modern animations are based on the concept of motion. Therefore, it's worthwhile to mention that the first studies of motion were conducted by the Greek Philosopher <span class="emphasis"><em>Ζήνων ὁ Ἐλεάτης</em></span> (known in English as <span class="emphasis"><em>Zeno of Elea</em></span>) during the 4th century B.C. We can read about many of his ideas in works by another Greek philosopher: <span class="emphasis"><em>Ἀριστοτέλης</em></span> (known in English as <span class="emphasis"><em>Aristotle</em></span>). Zeno is famous for conceiving many paradoxes about motion, exploring the problem to prove the inexistence of motion. One of these paradoxes is the arrow paradox (also known as <span class="strong"><strong>Fletcher's paradox</strong></span>). We can read a little bit about this from Aristotle's book Physics IV, as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"If everything when it occupies an equal space is at rest, and if that which is in locomotion is always occupying such a space at any moment, the flying arrow is therefore motionless."</em></span></p></blockquote></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_002.jpg" /><div class="caption"><p>The Zeno's Fletcher's paradox described by Aristotle. You don't see the arrow moving towards the target, but just moments in which the arrow is static, albeit in different positions. Therefore, motion is an illusion.</p></div></div><p>As we can see from the preceding picture, the paradox claims the motionlessness of the arrow, since in each instant the arrow is in a very particular position in space and it is static in that instant. Besides the many philosophical implications and solutions to the paradox, it's interesting to note that the same concept applies nowadays for animation. Animations in movies and video games (to name a few) are just a series of static frames, which, in a rapid succession, give the illusion of motion.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec36"></a>Animations in video games</h3></div></div></div><p>Animations help to bring our creations to life. They make the living more vibrant and the dead even creepier! The development of animation has come a long way since the pixel art graphics to what can only be described as an uncanny valley of movement. In some cases, the animations are so life like that for a moment we forget that we're in an alternate reality.</p><p>Now, let's go back to the start of game animation. Space Invaders, Donkey Kong, and Tempest. If you have ever experienced one of these games, then you will know what I mean when a lot can be conveyed by very simple animation, whether it is translating side to side with Space Invaders, jumping to dodge barrels in Donkey Kong, or rotating in Tempest. However, as time progressed, so too did the animation techniques that we have become all too familiar with. With the introduction of 3D games and consequently characters, we have seen animations enter another dimension... literally. But despite their polygonal bodies and ridged movements, such as the following image of Lara Croft (though not so much nowadays), animations allow us to simply interact with a game.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_003.jpg" /><div class="caption"><p>Taken from the gameplay of Lara Croft in Tomb Raider I</p></div></div><p>One good philosophy behind including animation is to think of animations as a way of communicating with your audience. Sometimes, emotions such as love, excitement, and hate are great ways to communicate feelings, just like body movements such as running, jumping, and attacking are good ways to indicate a state that the player is currently experiencing. However, animation doesn't just include the player; objects such as trees, and animals, and those who are not playing, or NPC, also interact and move about the game space, sometimes just as any controlled player would. Some of the most prolific examples of the use of animation with NPCs are in <span class="strong"><strong>Role Playing Games</strong></span> (<span class="strong"><strong>RPGs</strong></span>).</p><p>Many characters that you interact with develop a feeling about you. For example, if you constantly answer them with an abrupt response, they are likely to display facial expressions of despise, or shock like the next image. Where, on the other hand, if you're warm, friendly, and offer a helping hand, then their facial expressions are likely to be more welcoming.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_04_04.jpg" /><div class="caption"><p>Shepard, clearly not laughing at a joke (Mass Effect series)</p></div></div><p>Timing is everything, so when it comes to animations, make sure that they happen when they are supposed to. Pressing <span class="emphasis"><em>
<span class="strong"><strong>X</strong></span>
</em></span> to jump and the jump happening only 3 seconds later is not going to end well, for your game or the player. It is not enough to just animate a character or an object, but you've to add them up to create an immersive environment. The importance of being immersed within a game is vital if you want your player to come back for more. If you have clunky animation that causes frustration, chances are that the player won't be persistent, unless perhaps the story is extremely intriguing. Even the trees in most games animate, even with subtle swaying or leaves flickering with the wind. In this way, it's better than having giant poles of static wood sticking out from the ground.</p><p>Another thing to consider when it comes to animation is the frame rate and, in turn, the hardware. You may have a wonderful animation sequence, such as the epic cut scene like the fight in Crisis Core: Final Fantasy VII between Sephiroth, Genesis, and Angeal (as shown in the following image); another example is the gameplay while you're killing enemies in Battlefield 4. But if there were a delay, well, it would have been pretty much nothing! When creating games for Unity, it is very important to consider this, especially when you are targeting mobile devices. While many mobile devices have the ability to play some resource-heavy media, not all do. Therefore, if your ultimate device won't be able to keep up, your intense efforts are likely to go in vain, unless of course you find another device to target. This is mostly the case with 3D games on mobile devices, and you can find out more here in the official Unity documentation: <a class="ulink" href="https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html" target="_blank">https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html</a>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip34"></a>Tip</h3><p>I recommend that you visit the preceding link once you've finished the chapter so as to have a better understanding of the animation system in Unity.</p></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_04_05.jpg" /><div class="caption"><p>Gameplay screenshot of Genesis and Sephiroth fighting in Crisis Core: Final Fantasy VII</p></div></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip35"></a>Tip</h3><p>Check out this site for some great tips for using animation in mobile games: <a class="ulink" href="http://www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging" target="_blank">www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging</a>.</p></div><p>Now that we have an overview of animations in video games, let's head back to Unity to discover what it handles with animations, starting with the general workflow.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec37"></a>Workflow for animations</h3></div></div></div><p>Now that we have understood why animations are so important for video games, let's give them a closer look. Unity's animation system is based on the concept of animation clips; we will explore this in more detail in the next section. As the name suggests, they are just clips containing data for a single animation (with a few exceptions).</p><p>Animation clips are organized into a structure that is similar to a flowchart system, where different nodes are connected to others (like the next screenshot). This system is called an Animator Controller and it acts as a state machine. It keeps track of which clip should currently be played and determines when the animations should change or blend together.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_006.jpg" /></div><p>A very simple Animator Controller might only contain a small amount of clips. For example, one clip may be an object breaking, the other a fan rotating. On the other hand, a more advanced Animator Controller is likely to contain a lot more animations, for instance, all actions related to the main character, such as running, walking, idling, dying, and so on. In addition, animations may blend between multiple clips in order to look more fluid-like and less robotic, unless of course that is your intention!</p><p>Unity's animation system also has many special features, especially when using humanoid characters. These features allow you to retarget human-like or humanoid animations from any source, such as motion capture, the Unity asset store, or software such as Maya or Blender, and then apply them to your own character model. In addition to applying these animations, you are also able to adjust muscle definitions on characters. These special features are enabled by Unity's Avatar system, where humanoid characters are mapped to a common internal format (we won't see this in detail, but you can learn more in the optional section at the end of the chapter).</p><p>Ultimately, the animation clips, the Animator Controller, and the Avatar, are brought together on a gameObject via the Animator Component. This component references an Animator Controller and (if required) the Avatar for the model in question. The Animator Controller in turn contains the references to the animation clips it uses.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec38"></a>Animations clips and the Animator component</h3></div></div></div><p>At the heart of Unity's animation system, there are Animation Clips. These components contain information that relate to an object's animation, such as whether or not they need to change their translation (position), their rotation, and so on, as the animation takes place. Animation clips can be 2D or 3D and are often made in programs such as 3D Studio Max, Flash, Maya, Blender, and even Photoshop. In addition to using software, animations can be created manually, such as rigging a 3D character (giving it a skeleton to move) or creating movement-by-movement sprites where each movement is drawn out. Remember the old Disney cartoons? Well they used similar processes to bring us some of our most beloved memories. However, if your game requires something that isn't too complex such as opening and closing doors, you are able to do this in Unity. Unity offers a tool known as the the Animation window (more about this later in the chapter).</p><p>In the case of 2D, these animation clips can contain an arbitrary sequence of sprites, like single frames in a movie, and change them over time so to give the illusion of motion. Usually, in 2D game development, sprite sheets are used for these purposes (like we anticipated in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>A Flat World in Unity</em></span>). As such, our graphic package contains these animation sprite sheets as well.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_007.jpg" /></div><p>Another useful way to think about Animation clips is to pretend that they are actions, such as pick up an object, walk, or jump.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>In most advanced cases, Animation clips can contain part of an action that can be blended or merged with other animation clips.</p></div><p>For our pandas, we have the following animations:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Walk</strong></span>: When our panda will move along the path</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Die</strong></span>: When the player's cupcake towers will take the panda down</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Hit</strong></span>: When the player's cupcake towers will hit the panda</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Eat</strong></span>: When the panda reaches the end of the level and eats a slice of the player's cake</p></li></ul></div><p>As such, we need to create four different animation clips, one for each of these.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec34"></a>Creating Animation clips with a controller</h4></div></div></div><p>The method explained in this section is a rapid way to start to create the first Animation clip, starting from a sprite sheet, and as a side effect, a controller will be created. However, we will deal with it later in the chapter.</p><p>First of all, create an empty game object in the scene, and rename it to <code class="literal">Panda</code> (or if you prefer, <code class="literal">Sweet-Tooth_Panda</code>). Eventually, you'll want to store it, once finished working on it, inside a prefab.</p><p>Now in the project panel, if we select <code class="literal">animation_panda_sprite_sheet</code> and expand it, we will have something like this:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_008.jpg" /></div><p>All the single Sprites/frames of the animation should be the same size. By ensuring this in the beginning, it allows you to avoid many headaches later on. Therefore, if the Sprite Sheet is well done, it should be sliced without difficultly with the <span class="strong"><strong>Grid By Cell Count</strong></span> mode in the Sprite Editor, as we did in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>A Flat World in Unity</em></span>. In our package, our Sprite Sheet is already good to go with each Sprite distributed evenly, but if you're using your own graphic and the Sprite Sheet doesn't have all the frames of the same size, you might want to modify it within a graphics program (such as Photoshop or Gimp) so that the sprites are distributed accordingly.</p><p>This is the final result in the Sprite Editor:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_009.jpg" /></div><p>However, if you move the slider at the bottom part of the project panel (as we learned in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>A Flat World in Unity</em></span>), you are able to see all the single sprites, as the following image shows:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_010.jpg" /></div><p>Select all the Sprites that belong to the animations of the walking Panda, and drag them onto the <span class="strong"><strong>Panda</strong></span> game object we have created before:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_011.jpg" /><div class="caption"><p>In our case, we have 11 sprites for the Walking animation, then 5 sprites for the Hit animation, 10 for the Die animation, and finally 16 for the Eat animation</p></div></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip37"></a>Tip</h3><p>It may happen that the last Sprite is equal to the first one. Depending on the case, you might not want it because it is likely to cause a disruption in the animation, such as a delay in a walking sequence. In that case, you can just select all the sprites but the last one.</p></div><p>Unity will ask you where to save the animation clip and under which name. We can name it <code class="literal">Panda_Walk_Animation</code> and save it in our <code class="literal">Animation</code> folder. If you don't have it, you can create it under the <code class="literal">Asset</code> folder. In this way, as we discussed in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>A Flat World in Unity</em></span>, we keep our project clean and tidy.</p><p>When we select the <code class="literal">Panda</code> object, we can notice that in the Inspector two components have been added. One is a <span class="strong"><strong>Sprite Renderer</strong></span>, which we have already discussed in previous chapters. The other is an <span class="strong"><strong>Animator</strong></span> component. Let's see it in detail in the next section.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_012.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p>If you navigate in the <span class="strong"><strong>Animation</strong></span> folder, other than the animation file we have just created, you will also find an Animator controller called <code class="literal">Panda</code> (or <code class="literal">Sweet-Tooth_Panda</code>, since the name is taken from the Game Object). For our purposes, it's better to rename it as something that describes it better, such as <code class="literal">PandaAnimatorController</code>. We will learn more about this later in the chapter.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec35"></a>The Animator component</h4></div></div></div><p>The main function of the Animator component is to hold a reference to an Animator Controller, which defines how our animation clips should be played. Furthermore, it controls when and how to blend and/or transition between them. We will explore the controller in the next sections.</p><p>The Animator component has some parameters that can adjusted. Let's see the main ones:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Controller</strong></span>: This is the reference to the Animator Controller, and it's the most important variable. If not set, the Animator component can't work. In the previous picture, the controller is set to <code class="literal">Panda</code> (or <code class="literal">PandaAnimatorController</code> if you have renamed it), which is a controller we just created.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Avatar</strong></span>: A parameter only for 3D Humanoid characters, so you can ignore it (however, if you are interested in learning more, check out the <span class="emphasis"><em>More about Animations</em></span> section later in the chapter).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Apply Root Motion</strong></span>: You can ignore this too (however, if you are interested in the learning more, check out the <span class="emphasis"><em>More about Animations</em></span> section).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Update Mode</strong></span>: Specifies when the Animator is updated and which timescale it should use. The <span class="strong"><strong>Normal</strong></span> mode updates the controller in sync with the update calls, and the Animator's speed matches the current timescale. If the timescale is slowed, animations will slow down to match. The <span class="strong"><strong>Animate Physics</strong></span> mode instead updates the Animator in sync with the <span class="strong"><strong>FixedUpdate</strong></span> calls, which are used by the Physic engine. This is useful when the object you are animating has a physical interaction, for instance, if a character needs to push or pull a rigid body (more about Physics in the next chapter). Finally, the <span class="strong"><strong>Unscaled Time</strong></span> mode updates the Animator in sync with the Update calls, like the <span class="strong"><strong>Normal</strong></span> mode, but the current timescale is ignored and it always plays at 100% of its speed. For instance, this mode is useful when you pause the game but you still want to animate part of the UI or the pause menu itself.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Culling Mode</strong></span>: Specifies the culling mode for animations (more on this in the <span class="emphasis"><em>More about Animations</em></span> section later in the chapter).</p></li></ul></div><p>Furthermore, at the bottom of the Animator component, there is an information box with some useful information about the Animator controller we are using. For now, the only information that is relevant is <span class="strong"><strong>Clip Count</strong></span>, which tells you how many animation clips are used by the controller. You can find out more about this information box in the <span class="emphasis"><em>More about Animations</em></span> section.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_013.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec36"></a>Creating the other animation clips</h4></div></div></div><p>Now, we need to create the remaining animation clips respectively for when the pandas die, eat or get hit. This time, we want to do it without generating the controller. We have two choices. In the first, we still keep dragging and dropping the other groups of Sprites onto the <span class="strong"><strong>Panda</strong></span> game object as we did previously. As a result, Unity will still ask to give a name and a location for the animation clip, but it won't generate another controller. This is the fastest way. However, there is another one. It involves the <span class="strong"><strong>Animation</strong></span> window, but for the sake of learning we will use this second method to create the remaining Animation clips.</p><p>To do so, open the <span class="strong"><strong>Animation</strong></span> windows (click on the top bar menu on <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Animation</strong></span> or use the shortcut <span class="emphasis"><em>Ctrl</em></span> + <span class="strong"><strong>6</strong></span>). Then, select your <span class="strong"><strong>Panda</strong></span> from the <span class="strong"><strong>Hierarchy</strong></span> panel. You should see something like this:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_014.jpg" /></div><p>The <span class="strong"><strong>Animation</strong></span> window allows you to create animations within Unity. It uses interpolation techniques between key frames to compute the position and rotation (along with other parameters) between each frame. It also supports a recording functionality as well as a curve editor. In 2D game development, this is not much used if animation Sprite Sheets are available, like our case (unless you need to fine-tune the animation). Yet, this is an important tool that avoids the need for third-party programs to create your animations. Also, it is useful for prototyping animations. Unfortunately, we don't have enough room in this chapter to talk in detail about the <span class="strong"><strong>Animation</strong></span> window, but you can read more about it in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html" target="_blank">https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html</a>.</p><p>In our case, however, we will use it just to create and save animation clips starting from our Sprites. As we can notice from the preceding picture, there is already the Walk animation created in the last section. To create a new animation clip, click on <span class="strong"><strong>Panda_Walk_Animation</strong></span> and a drop-down menu like the following should appear:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_015.jpg" /></div><p>Click on <span class="strong"><strong>Create New Clip...</strong></span> and Unity will ask you where to save this new file and its name. We can name it <code class="literal">Panda_Die_Animation</code> and save it within the <code class="literal">Animations</code> folder. As a result, the <span class="strong"><strong>Animation</strong></span> window should now be cleared, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_016.jpg" /></div><p>Now, we can select the Sprites of the die animation, and drag and drop them within the window. Thus, the Sprite animation is loaded within the animation file, as we can see from the Animation window:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_017.jpg" /></div><p>We need to repeat the process to create the Hit and Eat animations. At the end, you should have the following files in the <code class="literal">Animations</code> folder:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_018.jpg" /></div><p>One more thing. If you click on one of them, in the <span class="strong"><strong>Inspector</strong></span>, you can see some options about whether the animation can be played in loop and how, along with an information box with some the amount of certain kind of data for the animation, such as how many muscles (but this is for 3D animation, and we won't use this information).</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_019.jpg" /></div><p>Not all our animations are supposed to be played in loop. In fact, all but the walk animations are not supposed to loop. Therefore, for them, just uncheck the <span class="strong"><strong>Loop Time</strong></span> variable in the <span class="strong"><strong>Inspector</strong></span>, like this:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_020.jpg" /></div><p>So far so good. Before you proceed, I advise you to create a new prefab in the <code class="literal">Prefab</code> folder, called <code class="literal">PandaPrefab</code>, and drag your <span class="strong"><strong>Panda</strong></span> there.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec39"></a>The Animator</h3></div></div></div><p>Imagine all of the different types of actions that you perform throughout the day-from the moment you wake up, to making coffee, having a shower, and getting ready for work. Each of these would have a different animation. The same goes for characters. In most games, characters or other animated objects (animals, trees, and so on) have a range of animations. Just like our example before, each animation will correspond to a different moment during gameplay. For example, when a character is just standing and being idle, they aren't doing much, but it is likely that they are still breathing. In some games, if characters remain idle for an extended period of time, other animation sequences are then triggered, such as impatient foot tapping or something completely unexpected. In first-person shooters, objects within the game environment may have the ability to be affected by things such as bullets or force (such as running hard into a wall), and as a result, they might break, crack, open, or even close. Mecanim uses a visual layout system similar to a flowchart to represent a state machine and enable you to control and sequence the animation clips that you want to use on your character or object. We will discuss this in more detail later.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec37"></a>The Animator window</h4></div></div></div><p>The Animator window allows you to create, view, and modify Animator Controller assets within Unity.</p><p>Now that we have all our animation files, we need to embed them within the Animator Controller in a meaningful way. If you double-click on <code class="literal">PandaAnimatorController</code>, the <span class="strong"><strong>Animator</strong></span> window opens, and you should have a screen similar to the following one:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_021.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p>In case you don't see your panda animations within rectangles, like the preceding image, it is probably because you have created the animation clips without having the animation window linked to a controller. That is not a problem; you just need to select the animation clips you want in the controller and drag them into the <span class="strong"><strong>Animator</strong></span> window, and they will be added.</p></div><p>The <span class="strong"><strong>Animator</strong></span> window is divided into two sections. The main section with the dark gray grid is the layout area. You can use this area to create, arrange, and connect states in your Animator Controller.</p><p>You can right-click on the grid to create a new state node. Using the middle mouse button or <span class="emphasis"><em>
<span class="strong"><strong>Alt</strong></span>
</em></span>/Option, drag to pan the view around. Click to select state nodes, so as to edit them in the <span class="strong"><strong>Inspector</strong></span>, and click and drag state nodes to rearrange the layout of your state machine, like this:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_022.jpg" /></div><p>In this way, our state machine will be clearer and tidy for what we are going to do. The second section of the <span class="strong"><strong>Animator</strong></span> window is the left-hand pane, which can be switched between the <span class="strong"><strong>Parameters</strong></span> tab and <span class="strong"><strong>Layers</strong></span> tab (if you want to learn more about layers, you can read the optional section of this chapter, <span class="strong"><strong>Layers</strong></span> in the <span class="strong"><strong>Animator</strong></span>, inside the <span class="emphasis"><em>More about Animations</em></span> section). The <span class="strong"><strong>Parameters</strong></span> tab allows you to create, view, and edit the Animator Controller parameters. These are variables that you define, which will then act as inputs into the state machine. We will see them in detail soon.</p><p>Also, toggling the eye icon on or off (highlighted in the next image to easily locate it) will show or hide the <span class="strong"><strong>Parameters</strong></span> and <span class="strong"><strong>Layers</strong></span> side pane, allowing you more room to see and edit your state machine.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_023.jpg" /></div><p>Furthermore, if we enable the lock icon (as in the next image) in the top-right corner, we are able to keep the <span class="strong"><strong>Animator</strong></span> window focused on the current state machine. If the lock icon is disabled, clicking on a new Animator asset or a Game Object with an Animator component will switch the <span class="strong"><strong>Animator</strong></span> window. As a result, we are then able to show that item's state machine. The benefit of locking the window is that it allows us to keep the <span class="strong"><strong>Animator</strong></span> window from showing the same state machine, regardless of what assets or Game Objects are selected.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_024.jpg" /></div><p>The last useful toggle (located just below the lock icon) is <span class="strong"><strong>Auto Live Link</strong></span>, which allows us to see the machine in action at runtime. For your convenience, it is highlighted in the following image, but we will talk more about it when we need to test the machine we are building up:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_025.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec38"></a>The Animator state machine</h4></div></div></div><p>As we already have mentioned, the Animator controller is a flowchart system; specifically it is a kind of finite-state machine. But what is a finite-state machine? From Wikipedia, we can read:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), or simply a state machine, is a mathematical model of computation used to design both computer programs and sequential logic circuits. It is conceived as an abstract machine that can be in one of a finite number of states. The machine is in only one state at a time; the state it is in at any given time is called the current state. It can change from one state to another when initiated by a triggering event or condition; this is called a transition. A particular FSM is defined by a list of its states, its initial state, and the triggering condition for each transition."</em></span></p></blockquote></div><p>In our specific cases, the states will be the animations. So, saying that our Animator is a specific state means that the Game Object with that Animator controller is playing that specific animation. If it is not completely clear right now, it will be a while before we explain the different parts.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"></a>Note</h3><p>We will explore finite-state machines a bit more in detail later in the book, when we deal with Artificial Intelligence.</p></div><p>Unity generated an Animator controller for us when we created the first Animation clip. But if you need to manually create it, here's how to do it. From the <span class="strong"><strong>Project</strong></span> panel (possibly within a meaningful folder, such as <code class="literal">Animations</code>), right-click and select <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Animator Controller</strong></span>. Once renamed, double-click on it to open it in the <span class="strong"><strong>Animator</strong></span> window. Contrary to the automatically generated controller, which already contains all the states of our Panda animation, here there are no such states. In fact, we need to manually import them. In the case of our Pandas, we just need to select the animations file that we have created before from the <span class="strong"><strong>Project</strong></span> panel and drag them into the grid of the <span class="strong"><strong>Animator</strong></span> window. If you remember, we stored them inside the <code class="literal">Animations</code> folder. Always remember that you can move any state just by dragging it. This is useful, because you can reorganize states so as to have a visual order and improve the readability of your work.</p><p>Now, it's time to dig deeper and see how to actually build an animation machine for our pandas. If you created a new Animator controller, discard it, and let's take the one we had before.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec39"></a>The Animator states</h4></div></div></div><p>Animations bring characters to life, and therefore Animation states provide the foundations for the Animation State Machine within Unity. Each state contains an individual animation sequence (or blend tree), such as running, walking, climbing, jumping, and so on. All these animation sequences will then be triggered and subsequently played when the character is in that respective state. When an event in the game triggers a state transition, such as the player jumps over a ledge while running, the character will be left in a new state whose animation sequence will then take over.</p><p>When you select a state in the Animator Controller, you will see the properties for that state in the inspector, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_026.jpg" /></div><p>These properties and their functions are listed here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Name</strong></span>: Is just how the state will be referred in the Animator, and it is also the name showed on top of the state. If it is automatically generated from an animation, as a default, it will have the same name of the animation clip. In fact, our four panda states have the same names as their respectively animation clips.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Tag</strong></span>: Just another way to identify a state or a set of them. It is useful when you need to control animation machines from a script. For our purposes, we can leave it in blank.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Motion</strong></span>: This is the animation clip assigned to this state, for example, one of the animation clips that we have created before, such as <code class="literal">Panda_Walk_Animation</code> or <code class="literal">Panda_Die_Animation</code> (actually, it can also be a blending tree; see the optional section <span class="emphasis"><em>More about animations</em></span> later in the chapter).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Speed</strong></span>: The default speed of the animation. For example, the default speed of an animation may be too slow, such as a running animation, and therefore, the speed needs to be increased. By changing the value of <span class="strong"><strong>Speed</strong></span>, the animation is able to player faster.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Multiplier</strong></span>: A number that is multiplied by <span class="strong"><strong>Speed</strong></span> to increase it or decrease it. Next to it, there is the parameter checkbox. This allows us to transform this number into an animator parameter (please also note that the multiplier cannot have an independent value, but just be linked to a float parameter). In this way, we can control the speed of some animations, without touching the <span class="strong"><strong>Speed</strong></span> settings (given that all of them are linked to the same parameter).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Mirror</strong></span>: Should the state be mirrored, which means if the animation clip should be played like in a mirror, exchanging left with right and vice versa. This is only applicable to 3D humanoid animations, and therefore we won't deal with it. Note that can be transformed into a parameter Boolean.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Cycle Offset</strong></span>: Determines if the animation loop should start to a different point, and the value indicates the offset from the beginning of the animation. Also this acts as a <span class="strong"><strong>Multiplier</strong></span> and can be set to be a parameter.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Foot IK</strong></span>: Should <span class="strong"><strong>Foot IK</strong></span> be respected for this state? This is applicable to 3D humanoid animations, so we won't deal with it.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Write Defaults</strong></span>: This decides whether or not AnimatorStates writes back the default values for properties that are not animated by its motion. By default, it is set to true, but unchecking it means that the non-animated properties of a state will keep the value they had previously.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Transitions</strong></span>: The list of transitions originating from this state. It is equivalent to identify under which conditions this state changes into another one. We will see transitions in detail in a couple of sections.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Add Behaviour</strong></span>: For the description of this button see the optional section <span class="emphasis"><em>More about Animations</em></span> later in the chapter.</p></li></ul></div><p>The default state, displayed in brown, is the state that the machine will be in when it is first activated. If you want, you are able to change the default state of the state machine by right-clicking on another state and selecting <span class="strong"><strong>Set As Layer Default State</strong></span> from the context menu.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_027.jpg" /></div><p>In our case, the default state is the <span class="strong"><strong>Panda_Walk_Animation</strong></span> state, so be sure that it is selected as the default state. In addition, to add a new state, right-click on an empty space in the <span class="strong"><strong>Animator Controller</strong></span> window and navigate to <span class="strong"><strong>Create State</strong></span> | <span class="strong"><strong>Empty</strong></span> from the context menu. Another way to create a state, as we have already pointed out, is to drag an animation into the <span class="strong"><strong>Animator Controller</strong></span> window, and as a result, you will create a state containing that animation.</p><p>As far as our panda's animation states are concerned, we don't have particular needs or settings to tweak. After all, what we are building is a relatively simple finite state machine compared to big, complex 3D animation machines. But, if at any moment you feel that one of the four animations that we have is too fast or too slow, just select it and change its speed. In that case, you can do it at the end, when we finish the state machine, so as to have better and complete vision of the panda animation as a whole, and tweak these values to improve it. For instance, I slowed down the walking, hit, and eat animation to 25%, which means a speed of 0.25, whereas for the die animation, I used 0.2. Usually you find these values by trial and error.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"></a>Note</h3><p>Note that you can only drag Mecanim animations into the controller; non-Mecanim animations will be rejected. Moreover, states do not necessarily contain single animation clips. In fact, they could also contain Blend Trees. You can read more about them in the optional section, <span class="emphasis"><em>More about Animations</em></span>, later in the chapter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch04lvl4sec3"></a>Special states</h5></div></div></div><p>An animator machine also has some special states, which are presented in this image:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_028.jpg" /></div><p><span class="strong"><strong>Any State</strong></span> is a special state that is always present. <span class="strong"><strong>Any State</strong></span> implies that it cannot be the end point of a transition. For example, jumping to <span class="emphasis"><em>any state</em></span> cannot be used as a way to pick a random state to enter the next. <span class="strong"><strong>Any State</strong></span> exists for the situation where you want to go to a specific state regardless of which state you are currently in. This is a simpler way of adding the same outward transition to all states in your machine. <span class="strong"><strong>Entry</strong></span> and <span class="strong"><strong>Exit</strong></span> are states that determine the beginning and the end of the Animation State Machine.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note42"></a>Note</h3><p>There are other special states to handle sub-machines. For more information, check out the <span class="emphasis"><em>More about Animation</em></span> section later on in the chapter.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec40"></a>The animator parameters</h4></div></div></div><p>As we already introduced before, on the left-hand side of the <span class="strong"><strong>Animator</strong></span> window, there are two tabs: <span class="strong"><strong>Layers</strong></span>, which we won't deal with here (but I remind you that you can read the optional <span class="emphasis"><em>Layers in the Animator</em></span> section), and <span class="strong"><strong>Parameters</strong></span>, which we will learn in this section.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_029.jpg" /></div><p>Animation <span class="strong"><strong>Parameters</strong></span> are variables that are defined within an <span class="strong"><strong>Animator Controller</strong></span>. These parameters can be accessed and their values assigned from scripts. As a result, scripts can control or affect the flow of the state machine. For example, a script can set a parameter that indicates how fast an animation should be played, such as running or walking; these can be the same animation, just played at different speed. In a more sophisticated behavior, the same parameter can be a condition to switch between a proper walking animation and a running one, based on the player's input.</p><p>To add a parameter, click on the small + button, as highlighted in this picture:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_030.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note43"></a>Note</h3><p>However, if you want to delete a parameter, select the parameter in the lists and press the <span class="emphasis"><em>Delete</em></span> key.</p></div><p>A drop-down menu appears, asking which kind of parameter we want to add:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_031.jpg" /></div><p>They can be of four basic types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Int</code>: An integer (whole number)</p></li><li style="list-style-type: disc"><p><code class="literal">Float</code>: A number with a decimal part</p></li><li style="list-style-type: disc"><p><code class="literal">Bool</code>: A true or false value (represented by a checkbox)</p></li><li style="list-style-type: disc"><p><code class="literal">Trigger</code>: A Boolean parameter that is reset by the controller when consumed by a transition (represented by a circle button)</p></li></ul></div><p>Parameters can be assigned values from a script using functions in the <code class="literal">Animator</code> class, specifically with the following self-explanatory functions: <code class="literal">SetFloat()</code>, <code class="literal">SetInt()</code>, <code class="literal">SetBool()</code>, <code class="literal">SetTrigger()</code>, and <code class="literal">ResetTrigger()</code>.</p><p>As we have already seen, parameters can be linked to transition conditions or even to state variables (such as the speed multiplier), and then be controlled by scripts. To give an example, imagine the heroine of your game is riding a horse. A script can change a float parameter, which is linked to the speed multiplier of the galloping horse animation, based on how much the player spurs the horse. As a result, the animation of the horse will change in real time, based on the player input (if the player is controlling your heroine), and the horse will move faster.</p><p>However, for our Tower Defense game, we just need triggers, in particular, three: one for when the panda is hit, another one when it reaches the end and eats the cake, and the last one when it dies under sprinkles hit. We can respectively name them <code class="literal">HitTrigger</code>, <code class="literal">EatTrigger</code>, and <code class="literal">DieTrigger</code>. At the end, you should see the following:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_032.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>Of course, this is not the only way to implement this system. Refer to the <span class="emphasis"><em>State machine behaviours</em></span> section later to learn how to use behaviours within a state so that in the <span class="emphasis"><em>Homework</em></span> section you can test yourself with this new technique in order to implement this kind of behaviours in a different way.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec41"></a>The animator transitions</h4></div></div></div><p>Transitions allow us to change from one state of the Finite State Machine into another one. They can be triggered when certain conditions are met. As the name suggests, they handle how the current state transits into the destination state and how these two should be merged to have a smooth transition.</p><p>They are represented as mono-directional arrows between two states. To create a new transition between two state, right-click from the state where the transition should start (in our case, <code class="literal">Panda_Walk_Animation</code>) and select <span class="strong"><strong>Make Transition</strong></span>, as shown in this screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_033.jpg" /></div><p>Then click on another state to make the transition between them. In this example, we are doing a transition from <code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Hit_Animation</code>, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_034.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec42"></a>Transition settings</h4></div></div></div><p>If you click on the arrow, you can see the transition settings/properties in the <span class="strong"><strong>Inspector</strong></span>, like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_035.jpg" /></div><p>If you wish, you can assign a name to the transition, by typing it in the field shown next (you need to press <span class="emphasis"><em>Enter</em></span> to confirm your choice):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_036.jpg" /></div><p>As a result, its name will be shown in the state that contains that transition (for instance, in our example, within the <code class="literal">Panda_Walk_Animation</code> state):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_037.jpg" /></div><p>Renaming transition is your choice. Someone prefers to give proper names, someone else references to it as initial and final state, which is the default name. However, if you decide to rename them, remember to give meaningful names; it doesn't matter if they are long.</p><p>Let's cover in detail each of these settings so as to have a better understanding of what they mean. Keep in mind that some of them refer to certain conditions, which we will explore soon.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Has Exit Time</strong></span>: If this is set to true, the transition can only happen at the time specified in the <span class="strong"><strong>Exit Time</strong></span> variable.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Exit Time</strong></span>: If <span class="strong"><strong>Has Exit Time</strong></span> is enabled, this value represents the exact time for the transition to take effect. This is represented in normalized time (percentage value); so, for example, an exit time of 0.65 means that on the first frame where 65% of the animation has played, the <span class="strong"><strong>Exit Time</strong></span> condition will be true. On the next frame, the condition will be false. For looped animations, transitions with exit times smaller than 1 will be evaluated on every loop, so you can use this to time your transition with the proper timing in the animation, for every loop. Transitions with exit times greater than 1 will be evaluated only once, so they can be used to exit at a specific time-after a fixed number of loops. For example, a transition with an exit time of 4.5 will be evaluated once, after four and a half loops.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Fixed Duration</strong></span>: If enabled, the transition time is interpreted in seconds; otherwise, it is interpreted in a percentage between 0 and 1 (normalized time), such as 0.5, which would represent 50%.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Transition Duration</strong></span>: This is the duration of the transition. This will also determine the length between the two blue markers in the Transition Graph (see the next section).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Transition Offset</strong></span>: This is the offset of the time where the animation (in the destination state that is transitioned to) begins to play. For example, a value of 0.4 would mean the target state will begin playing at 40% of the way through its own timeline.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Interrupt Source</strong></span>: This allows you to control the circumstances that allow a transition to interrupt the current one. In particular, you can select five different modes:
</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>None</strong></span> won't allow anything to interrupt the transition.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Current State</strong></span> allows only transitions, within the current state, to interrupt the transition.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Next State</strong></span> allows the transition to be interrupted by other transitions, but only if those are within the destination state. Therefore, if the destination state has a transition that is ready to fire, it will interrupt this one and will be triggered.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Current State then Next State</strong></span> allows the transition to be interrupted by transitions from either the current or the destination state. However, if the conditions of a transition becomes true on both the current state and the destination one, then the former will take the priority. For example, if two transitions are ready to fire but one is on the current state and another one on the destination one, the first transition will be triggered and will interrupt the current playing transition.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Next State then Current State</strong></span> still allows the transition to be interrupted by either transitions of the current or destination state. But in contrast to <span class="strong"><strong>Current State then Next State</strong></span>, if the condition of a transition becomes true on both the current state and the destination one, then the latter will take priority.</p></li></ul></div></li><li style="list-style-type: disc"><p><span class="strong"><strong>Ordered Interruption</strong></span>: This determines whether the current transition can be interrupted by other transitions independently of their order.</p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip45"></a>Tip</h3><p>Now that you can make transitions, remember to rearrange often your finite state machine so as to improve readability. You should always place the states in such a way that all the transitions are nicely visible, and ideally they shouldn't cross each other much.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec43"></a>Transition graph</h4></div></div></div><p>Unity also provides a useful way to tweak these properties (listed just now) in a visual way, through the transition graph, which is located just below the settings of the previous section.</p><p>The transition settings can be adjusted either manually by entering numbers into the fields that we saw before, or by using the transition diagram, which will modify the values when the visual elements are manipulated.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_038.jpg" /><div class="caption"><p>The Transition Graph with a clear timeline; we can tweak how the transition will happen in a visual way</p></div></div><p>In the preceding diagram, you can do one of the following things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Change the duration of the transition by dragging the <span class="emphasis"><em>out</em></span> marker.</p></li><li style="list-style-type: disc"><p>Change the duration of the transition and the exit time by dragging the <span class="emphasis"><em>in</em></span> marker.</p></li><li style="list-style-type: disc"><p>Adjust the transition offset by dragging the animation clips shown in the bottom part of the graph.</p></li><li style="list-style-type: disc"><p>Preview the transition by dragging the playback marker and navigate frame by frame to adjust how the animation clips blend together. The preview window is located at the bottom of the inspector.</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_039.jpg" /><div class="caption"><p>This is the preview window, where you can rotate, scale and play animations, as well as display their pivot point (or center of mass in the case of 3D models) and change the time scale to which you want to play the preview</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note46"></a>Note</h3><p>If the transition involves a blending tree as one of the two states (or both), the blend tree parameters will also appear in the transition graph. You can find a bit more about blending trees in the <span class="emphasis"><em>More about Animations</em></span> section later in the chapter.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec44"></a>Transition conditions</h4></div></div></div><p>So far we have seen many settings for our transitions, but when are they actually triggered? That's why, at the bottom of the settings, there are the transition conditions. You can see them here:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_040.jpg" /></div><p>To add a condition, press the <span class="strong"><strong>+</strong></span> button. To remove, select one of them and click on the <span class="strong"><strong>-</strong></span> button. Besides, you can reorder them by dragging their left handle. However, the order doesn't affect the logic behind the transition (just the implementation of it, and maybe the readability of your project).</p><p>These conditions can be checked against the parameters. For <code class="literal">int</code> and <code class="literal">float</code> parameters, we can check them against a fixed number. So if the value in the parameter is <span class="strong"><strong>Greater</strong></span> or <span class="strong"><strong>Less</strong></span> than the fixed number. For <code class="literal">int</code> parameters, we can also check whether they are <span class="strong"><strong>Equals</strong></span> or <span class="strong"><strong>NotEqual</strong></span> compared to the fixed number. Bools, instead, can be checked to find out whether they are true or false. Finally, triggers cannot be checked against something, but the condition checks whether they fire.</p><p>Here is an example of conditions using all of the four kinds of parameters:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_041.jpg" /></div><p>Please note that the transition is executed/performed only if all the conditions are verified in that moment. A transition without conditions is triggered at the time specified in <span class="strong"><strong>Exit Time</strong></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>If <span class="strong"><strong>Has Exit Time</strong></span> is not checked and the transition has no condition as well, then the transition is ignored by Unity. So it is as if the transition didn't exist.</p></div><p>Now that we have learned how to set a transition, we will explore some useful functionalities to test them in the next section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec45"></a>Testing transitions</h4></div></div></div><p>There are two useful functionalities to know about if you need to test the transitions. The first one is <span class="strong"><strong>Solo</strong></span> and second is <span class="strong"><strong>Mute</strong></span>. If you select a transition, you can see them at the top of the <span class="strong"><strong>Inspector</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_042.jpg" /></div><p>However, I suggest you to set <span class="strong"><strong>Solo</strong></span> and <span class="strong"><strong>Mute</strong></span> in another way. In fact, if we select a state, we can find in the <span class="strong"><strong>Inspector</strong></span> all the transitions from that state with the <span class="strong"><strong>Solo</strong></span> and <span class="strong"><strong>Mute</strong></span> functionalities. As a result, we will have a handy view, since we can look at and set all the transitions from that state in one go, shown as follows (all the transitions in this picture will be made in the next section):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_043.jpg" /></div><p>When the <span class="strong"><strong>Mute</strong></span> checkbox is selected, that specific transition will be ignored completely. Whereas, when the <span class="strong"><strong>Solo</strong></span> checkbox is selected, all the other transitions will be considered muted. Furthermore, in the <span class="strong"><strong>Animator</strong></span> window, it is possible to see <span class="strong"><strong>Mute</strong></span> transitions in red, whereas <span class="strong"><strong>Solo</strong></span> transitions are in green:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_044.jpg" /><div class="caption"><p>An example of Solo and Mute transitions</p></div></div><p>If you have the hard copy of this book (so without colors), the transition that goes from <code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Hit_Animation</code> is a <span class="strong"><strong>Mute</strong></span> transition, so the arrow is red. Both the transitions from <code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Die_Animation</code> and <code class="literal">Panda_Eat_Animation</code> are <span class="strong"><strong>Solo</strong></span> transitions, and the arrow is green. The remaining one is neither a <span class="strong"><strong>Mute</strong></span> nor <span class="strong"><strong>Solo</strong></span> transition, and therefore it is white. However, this is just an example; feel free to test in the best way that suits you.</p><p>Moreover, from the official documentation we can read a rule of thumb about <span class="strong"><strong>Solo</strong></span> and <span class="strong"><strong>Mute</strong></span> functionalities:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"The basic rule of thumb is that if one Solo is ticked, the rest of the transitions from that state will be muted. If both Solo and Mute are ticked, then Mute takes precedence."</em></span></p></blockquote></div><p>Finally, it's worthy to keep in mind that at the time I'm writing this sentence, there is a known issue (always from the official documentation):</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"The controller graph currently doesn't always reflect the internal mute states of the engine."</em></span></p></blockquote></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec40"></a>The panda's Animation State Machine</h3></div></div></div><p>Now that we learnt a bit more about how to use Mecanim system, we will do what we started-have a complete controller for the animations of our pandas. This is how the controller should look once finished:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_045.jpg" /></div><p>As you can see, there are four transitions, and we've got only one. But we still need to properly set all of them. Therefore, create and complete the transitions in the following way:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Hit_Animation</code>: When the panda is walking and a sprinkle hits it, the panda will play the Hit animation. Therefore, let's add <code class="literal">HitTrigger</code> as a condition and uncheck <span class="strong"><strong>Has Set Time</strong></span> to trigger the transition at any moment during the walk loop. Furthermore, to make the transition instantaneous, let's set <span class="strong"><strong>Transition Duration</strong></span> to zero to make it start playing the Hit animation from the first frame set <span class="strong"><strong>Transition Offset</strong></span> to zero.</p></li><li style="list-style-type: disc"><p><code class="literal">Panda_Hit_Animation</code> to <code class="literal">Panda_Walk_Animation</code>: After the panda has been hit, he will then keep walking again towards the player's cake. As a result, we need to recover the panda from the <code class="literal">Panda_Hit_Animation</code> state as soon as the animation finishes. So, let's set <span class="strong"><strong>Has Exit Time</strong></span> to true and <span class="strong"><strong>Transition Duration</strong></span> and <span class="strong"><strong>Transition Offset</strong></span> to zero, since we want the transition to be instantaneous.</p></li><li style="list-style-type: disc"><p><code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Eat_Animation</code>: When the panda finally arrives to the player's cake, the panda will eat so much of it that he will explode! Therefore, the transition needs to be triggered with <code class="literal">EatTrigger</code>, so add it to the conditions and uncheck <span class="strong"><strong>Has Exit Time</strong></span>. Moreover, as all the transitions of the panda should be immediate, set both <span class="strong"><strong>Transition Duration</strong></span> and <span class="strong"><strong>Transition Offset</strong></span> to zero.</p></li><li style="list-style-type: disc"><p><code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Die_Animation</code>: Being under fire by sprinkles is tough for our panda. If it cannot hold anymore, it will die, leaving the player's cake untouched. This is a transition triggered by <code class="literal">DieTrigger</code>, which we need to add to the conditions. Again, for the same reasons as before, uncheck <span class="strong"><strong>Has Exit Time</strong></span> and set both <span class="strong"><strong>Transition Duration</strong></span> and <span class="strong"><strong>Transition Offset</strong></span> to zero.</p></li><li style="list-style-type: disc"><p><code class="literal">Panda_Die_Animation</code> to <code class="literal">Exit</code>: Once the panda is dead, we want to get rid of it. Going in the <code class="literal">Exit</code> state, actually (since we don't have any sub-machines), will make the controller start again from the enter state/node. However, we will see how to destroy the panda before this happens. It doesn't matter if this animation goes in any other state, but choosing exit makes more sense, and so it helps in the readability of your controller. Once more, we want the transition to be instantaneous, so we set both <span class="strong"><strong>Transition Duration</strong></span> and <span class="strong"><strong>Transition Offset</strong></span> to zero; but we want to trigger this transition as soon as the animation finishes, which means having <span class="strong"><strong>Has Exit Time</strong></span> set to true.</p></li><li style="list-style-type: disc"><p><code class="literal">Panda_Eat_Animation</code> to <code class="literal">Exit</code>: The same reasons we said for the previous transition hold for this too. The panda will eat so much cake that it will explode, and again the panda will be removed from the scene. Check <span class="strong"><strong>Has Exit Time</strong></span> and set <span class="strong"><strong>Transition Duration</strong></span> and <span class="strong"><strong>Transition Offset</strong></span> to zero.</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec46"></a>Testing the panda's Animation State Machine</h4></div></div></div><p>Before we move on to the next section, we should check whether what we have done so far works. However, the whole system will be completed only when we finish the game. Therefore, we need to find a smart and fast way to test the controller.</p><p>The easiest way is to create a new scene and drag and drop the panda Prefab into it. Then, build an UI interface with three buttons. Change their text so that you will have <code class="literal">Trigger Die Animation</code>, <code class="literal">Trigger Hit Animation</code>, and <code class="literal">Trigger Eat Animation</code>, as shown in this screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_046.jpg" /></div><p>As we learnt in the previous chapter, the buttons have the <span class="strong"><strong>On Click ()</strong></span> event, which allows us to call some functions when the button is pressed. However, we didn't have chance to use this functionality. In fact, we will work more on UI events in the next chapter.</p><p>For now, you can select all the three buttons, and click on the small <span class="strong"><strong>+</strong></span> button in the bottom-right corner of the <span class="strong"><strong>On Click ()</strong></span> event. We can see this in the following image:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_047.jpg" /></div><p>A new event appears, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_048.jpg" /></div><p>Drag the panda from the <span class="strong"><strong>Hierarchy</strong></span> panel, into the object variable, so that you will have the following:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_049.jpg" /></div><p>From the drop-down menu, navigate to <span class="strong"><strong>Animator</strong></span> | <span class="strong"><strong>Set Trigger (string)</strong></span>. In this way, we can set the triggers of our Animator. So at the end, you should have this:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_050.jpg" /></div><p>Now, select each button separately, and assign to each one of them the respective trigger. For instance, in the <span class="strong"><strong>Trigger Die Animation</strong></span> button, you should write <code class="literal">DieTrigger</code>, as shown in this picture:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_051.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note48"></a>Note</h3><p>Using the <code class="literal">Set Trigger (string)</code> function is not the best option, since it involves the use of strings. But for testing purposes, it's more than fine. In the next section, when we build a script that controls the Animator, we will see how to use hashes to refer to Animator parameters as numbers, and improve efficiency.</p></div><p>As a result, each one of those buttons now acts as a trigger for our panda. Therefore, we can press <span class="strong"><strong>Play</strong></span>, and finally see our panda walking. Then, by clicking on the buttons, we can trigger the transitions in the Animator and see the panda changing state/animation. As a result, we can test if the transitions work well or not. Feel free to tweak any parameters you want, such as the speed of an animation or the transition graph of one of the transitions to suit your needs.</p><p>Do you remember the <span class="strong"><strong>Auto live link</strong></span> toggle when we talked about the <span class="strong"><strong>Animator</strong></span> window? Once you are in <span class="strong"><strong>Play</strong></span> mode, that is the right moment to activate it. As a result, you will be able to have a visual representation on your <span class="strong"><strong>Animator</strong></span> window of the state of your machine.</p><p>For instance, in the following screenshot, the walk loop is performed and it also shows a bar with the progress of the animation. This can help you a lot to tweak the Animator controller.</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_052.jpg" /></div><p>Now, once you are happy with your changes and you have applied them, save the scene if you want, but come back to our main scene. Then, we are ready to create a script, or two, for our pandas.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec41"></a>Scripting Animations</h3></div></div></div><p>Finally, we've got all the animations for our pandas and a controller that changes them based on some triggers. However, so far nothing will ever set a trigger of the Animator (except our UI test buttons in the other scene). Therefore, we need to create the script for the panda, which will not only include the behaviour of the panda, but it will also trigger the right animations. In the next section, we will learn how to tweak the parameters of an Animator within a script. But before we get there, let me to introduce you a very powerful tool: State Machine Behaviours!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec42"></a>State machine behaviours</h3></div></div></div><p>Each state of the animation machines can contain one or more behaviours. These are scripts that extend the <code class="literal">StateMachineBehaviour</code> class, which include the following functions/events, with self-explanatory names regarding when they are called/triggered: <code class="literal">OnStateEnter()</code>, <code class="literal">OnStateExit()</code>, <code class="literal">OnStateIK()</code>, <code class="literal">OnStateMove()</code>, and <code class="literal">OnStateUpdate()</code>.</p><p>In particular, you need to override these functions from the mother class, and they take as input three parameters. The first is the Animator itself, the second is an <code class="literal">AnimatorStateInfo</code> that stores information about the current state, and finally we have an integer that represents the layer. In our case, since we won't use any other layer than the base one, it will be always zero. They have the following signature (take <code class="literal">OnStateEnter()</code> for example):</p><pre class="programlisting">override public void OnStateEnter(Animator Animator, AnimatorStateInfo stateInfo, int layerIndex) &#13;
</pre><p>As a result, we can control everything within a state. In fact, State Machine Behaviours are a very powerful tool. Once you have created a script that extends the <code class="literal">StateMachineBehaviour</code> class, select the state where you want to add it. Then, click on the <span class="strong"><strong>Add Behaviour</strong></span> button at the bottom of the <span class="strong"><strong>Inspector</strong></span>, like this:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_053.jpg" /></div><p>If your class contains variables, they are shown in the <span class="strong"><strong>Inspector</strong></span> as for any other script, and they can be configured for that specific state. Here is a State Machine Behaviour that contains some variables and how they are displayed:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_054.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note49"></a>Note</h3><p>Be careful when using static variables, because they are shared among all the instances of the State Machine Behaviour among all the controllers! In fact, it's good practice to not use static variables in this context.</p></div><p>Now, imagine that the hero of your game that has the ability to carry and hold different weapons. In this case, with a machine behaviour, you can check which weapon the character is holding, and if it matches with the legendary fire sword, add a fire particle effect when our hero slashes an enemy. Another example could be where some characters share the same animation machine, since they are really similar, but some of them can glide after a jump. As such, you'd want to check this and, in some way, modify some parameters of your animation machines.</p><p>To put simply, the only limit is your imagination (and computational power), and you can enhance your animation machine. Of course, all that you can achieve with State Machine Behaviour can be done in other ways, but they offer a simple and quite intuitive way to do it. It doesn't take much to get used and learn how to deal with this tool.</p><p>Now that we know what a State Machine Behaviours is, let's make one for our panda!</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec47"></a>The destroy behaviour</h4></div></div></div><p>When our panda is killed either by a terrible rain of sprinkles or by eating too much cake, in some way we need to make the panda disappear from the scene. However, we need to do it, after that the death animation is played, and eventually also after we have updated the gameplay (which we will see later in the book).</p><p>That's why we have created two extra transitions from the <span class="strong"><strong>Die</strong></span> and <span class="strong"><strong>Eat</strong></span> animations into the <span class="strong"><strong>Exit</strong></span> state. These transitions will be executed once the respective animation has finished playing. Moreover, these animations are triggered by us in a separate script (see the next section), so before the panda dies, we have a chance to update the gameplay, such as the amount of sugar or health of the player.</p><p>A State Machine Behaviour allows us to have this level of control, that is to destroy the panda when it finishes to play that particular animation. Therefore, we can create a new script and call it something meaningful, such as <code class="literal">StateMachineBehaviour_DestroyOnExit</code>. Now, double-click on the script to open it.</p><p>First of all, we need to extend <code class="literal">StateMachineBehaviour</code> and not <code class="literal">MonoBehaviour</code>. We can just replace the latter with the former. Since the script doesn't extend <code class="literal">MonoBehaviour</code> anymore, we can also remove the <code class="literal">Start()</code> and <code class="literal">Update()</code> functions. At the end, we should come up with the following:</p><pre class="programlisting">using System.Collections; &#13;
using System.Collections.Generic; &#13;
using UnityEngine; &#13;
 &#13;
public class StateMachineBehaviour_DestroyOnExit : StateMachineBehaviour { &#13;
 &#13;
} &#13;
</pre><p>Next, we need to override one of the aforementioned functions of a State Machine Behaviour. In particular we want to override the <code class="literal">OnExit()</code> function. So every time the state changes to another (which in the case of the <span class="strong"><strong>Die</strong></span> and <span class="strong"><strong>Eat</strong></span> states means immediately after their animations are played), the panda will be destroyed. We can do this easily, since one of the parameters of the function is the Animator itself, and from it, we can retrieve the gameObject to which the Animator is attached and destroy it. Therefore, we can just add this function:</p><pre class="programlisting">    override public void OnStateExit(Animator Animator, AnimatorStateInfo stateInfo, int layerIndex) { &#13;
       <span class="emphasis"><em> //Destroy the gameobject where the Animator is attached to</em></span> &#13;
        Destroy(Animator.gameObject); &#13;
    } &#13;
</pre><p>Save the script, and select the <span class="strong"><strong>Die</strong></span> and <span class="strong"><strong>Eat</strong></span> states. From there, click on <span class="strong"><strong>Add Behaviour</strong></span> and select <code class="literal">StateMachineBehaviour_DestroyOnExit</code>.</p><p>Once you have done all of this, we are done! Now, every time the <span class="strong"><strong>Die</strong></span> or <span class="strong"><strong>Eat</strong></span> animations are played, on their completion, the panda will be destroyed. The next step is to see how to actually trigger the states within the controller.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec48"></a>The panda script</h4></div></div></div><p>We need to create a new script, and this time let it be derived from <code class="literal">MonoBehaviour</code>. We can call it <code class="literal">PandaScript</code>. Then, we can start to create some variables inside it. Let's start with a public variable to keep track of the panda's life and another one for its speed:</p><pre class="programlisting">
<span class="emphasis"><em>    //Public variables that express the characteristic of the Panda</em></span> &#13;
    public float speed;     //The movement speed &#13;
    public float health;    //The amount of health &#13;
</pre><p>Then, we need a variable to store the reference to the Animator. So, we can use this variable when we need to trigger an animation in the Animator:</p><pre class="programlisting">
<span class="emphasis"><em>    //Private variable to store the Animator for handling animations</em></span> &#13;
    private Animator Animator; &#13;
</pre><p>As we learned in the <span class="emphasis"><em>Animator Parameter</em></span> section, there are different methods to set parameters within the Animator. However, there are two versions of them: one refers to the parameter with an ID or Hash, the other one as a string. The latter is for sure the most intuitive, but since it relies on string processing, it's a bit slower than the first one. As such, whenever this is possible, it's better to use a hash (see the information box) to refer to a specific parameter within the Animator. Therefore, we can store these hashes inside some variable, so to fast use them.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note50"></a>Note</h3><p>In computer science when we need to map data of an arbitrary size onto data of a fixed size, we use a <code class="literal">Hash</code> function. The result of this function is called <span class="emphasis"><em>hash values</em></span>, <span class="emphasis"><em>hash codes</em></span>, <span class="emphasis"><em>digests</em></span>, or simply <span class="emphasis"><em>hashes</em></span>. The main uses of these <code class="literal">Hash</code> functions are in cryptography and digital security. Whenever you digitally sign a document, behind the scenes there is a <code class="literal">Hash</code> function somewhere too. However, they are also used in other contexts, such as to optimize, as in the case of Unity.</p></div><p>In our very specific case, we have a set of parameters, which need an integer ID so that they can be referred to quickly in the Animator. A <code class="literal">Hash</code> function is applied from the name of the parameter, which is a string, and so potentially with infinite combinations, since a string can be long arbitrary, onto a finite set of the Integers which may be expressed with a single <code class="literal">int</code> variable (so only up to two billion, one hundred and forty-seven million, four hundred and eighty-three thousand, six hundred and forty-seven). So every time in your video game use an <code class="literal">int</code> variable for storing money or lives, like we did in the last chapter, <code class="literal">2,147,483,647</code> is the maximum amount. Usually for video games, this limit is more than fine for any integer parameters you may want, although it is possible to overcome it if needed with special data structures. As a result, from the name of the parameter of the Animator, we can have a number with which we can refer to the parameter.</p><p>These hashes are Animator independent, since they are based only on the name of the parameter itself. So they can be calculated or retrieved from the static function <code class="literal">Animator.StringToHash()</code>, which takes as input the name of the parameter and returns as output it's numerical representation to use in an Animator.</p><p>In our specific case, we have the three triggers, and we can store their hashes in the following variables:</p><pre class="programlisting">
<span class="emphasis"><em>//Hash representations of the Triggers of the Animator controller of the Panda</em></span> &#13;
private int AnimDieTriggerHash = Animator.StringToHash("DieTrigger"); &#13;
private int AnimHitTriggerHash = Animator.StringToHash("HitTrigger"); &#13;
private int AnimEatTriggerHash = Animator.StringToHash("EatTrigger"); &#13;
</pre><p>The next step is to get the reference to the Animator controller in the <code class="literal">Start()</code> function, so to be used in the other functions. We can achieve this by using the <code class="literal">GetComponent()</code> function, which returns the component specified as <code class="literal">Type</code> attached to the same gameObject of this script. Therefore, we can simply add this line in the <code class="literal">Start()</code> function:</p><pre class="programlisting">    void Start () { &#13;
       <span class="emphasis"><em> //Get the reference to the Animator</em></span> &#13;
        Animator = GetComponent&lt;Animator&gt;(); &#13;
  } &#13;
</pre><p>Now, as for a modular workflow, we can create some private functions to implement the logic behind controlling the state machine. However, we will deal with them when we need to call them later on.</p><p>So now, we need a function that allows our panda to move towards a point in the map. This function takes a <code class="literal">Vector3</code> as input parameter, which is the destination point on the map. Based on the speed variable, it creates a step for our panda. Then, using the <code class="literal">MoveTowards()</code> function, it moves the panda of one step towards the destination point:</p><pre class="programlisting">
<span class="emphasis"><em>    //Function that based on the speed of the Panda makes it moving towards the destination point, specified as Vector3</em></span> &#13;
    private void MoveTowards(Vector3 destination) { &#13;
       <span class="emphasis"><em> //Create a step and then move in towards destination of one step</em></span> &#13;
        float step = speed * Time.deltaTime; &#13;
        transform.position = Vector3.MoveTowards(transform.position, destination, step); &#13;
    } &#13;
</pre><p>Another function will be called when the panda is hit by a sprinkle from one of the player's cupcake towers. It has as input a float, which is the amount of damage the panda has taken from the hit. So, the function subtracts this value to the health of the panda, and then checks if the health is less than zero. If so, the function triggers the Die Animation by set the <code class="literal">DieTrigger</code> parameter. We don't need to then destroy the panda because once death is triggered, the state machine behaviour will take care of it. On the other hand, if the panda is not dead yet, the function, instead, plays the Hit Animation:</p><pre class="programlisting">
<span class="emphasis"><em>    //Function that takes as input the damage that Panda received when hit by a sprinkle.</em></span>
<span class="emphasis"><em>//After have detracted the damage to the amount of health of the Panda checks if the Panda</em></span>
<span class="emphasis"><em> //is still alive, and so play the Hit animation, or if the health goes below zero the Die animation</em></span> &#13;
    private void Hit(float damage) { &#13;
           <span class="emphasis"><em>//Subtract the damage to the health of the Panda</em></span> &#13;
        health -= damage; &#13;
           <span class="emphasis"><em>//Then it triggers the Die or the Hit animations based if the Panda is still alive </em></span>        &#13;
 if(health &lt;= 0) { &#13;
            Animator.SetTrigger(AnimDieTriggerHash); &#13;
        } &#13;
        else { &#13;
            Animator.SetTrigger(AnimHitTriggerHash); &#13;
        } &#13;
    } &#13;
</pre><p>One last function we need to add is for when the panda reaches the end of its path and it's standing in front of the player's cake. Here the function just triggers the <code class="literal">Eat animation</code>. How to damage the player is something that we will deal in the next chapter:</p><pre class="programlisting">
<span class="emphasis"><em>       //function that triggers the Eat animation</em></span> &#13;
    private void Eat() { &#13;
        Animator.SetTrigger(AnimEatTriggerHash); &#13;
    } &#13;
</pre><p>We can save the script for now. It should appear like this in the Inspector:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_04_055.jpg" /></div><p>No need to worry now about how to set the speed and the health! We will see this when we will talk about gameplay programming.</p><p>Unless you want to read the next optional section, which will guide you through more advanced topics, we can say that we have finished with animation. If you don't want to read the next section, or want to come back to it later, maybe once you've finished the whole book, you can skip directly to the homework and summary sections. Otherwise, take a break and continue with the next section.</p></div></div></div>