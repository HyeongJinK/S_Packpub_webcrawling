<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec86"></a>Panda invasion – spawning Pandas</h2></div></div><hr /></div><p>In this section, we will implement the spawning system of the game. This can be done in many ways. However, since we have only one kind of Panda (at least for the moment), we will implement it in a simple way. In any case, we will use coroutines to implement the system, and we will see a template structure which we might also use in more complex spawning systems (in the next chapter, some ideas of more complex spawning systems will be provided).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec99"></a>What is a coroutine?</h3></div></div></div><p>It is a structure that Unity provides to allow functions to be interrupted and continued in other frames of the game. In the case of our spawning system, we don't want to spawn all the Pandas at the same time, but a little bit over time. This over time can be controlled with coroutines. You can definitely learn more and see some examples in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/Coroutines.html" target="_blank">https://docs.unity3d.com/Manual/Coroutines.html</a></p><p>However, the most important things to know about coroutines are listed here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>They are special functions which have an <code class="literal">IEnumerator</code> as a return value.</p></li><li style="list-style-type: disc"><p>They can be started with the <code class="literal">StartCoroutine()</code> function and stopped with the <code class="literal">StopCourotine()</code> function.</p></li><li style="list-style-type: disc"><p>They cannot run/start within any <code class="literal">Update()</code> function. The reason is because the <code class="literal">Update()</code> function's nature is to be called one time per frame (or more), whereas the coroutine's nature is to run at the time they specify.</p></li><li style="list-style-type: disc"><p>They can use a special instruction; yield: It allows them to wait for something, such as a fixed amount of time, the end of the frame, or even another coroutine. In any case, after the yield, they expect a return value. Common functions that are used with yield are:
</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">WaitForEndOfFrame()</code>: Waits until the next frame (official documentation: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html" target="_blank">https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html</a>)</p></li><li style="list-style-type: disc"><p><code class="literal">WaitForSeconds()</code>: Waits a specific amount of time specified in seconds as a parameter (official documentation: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/WaitForSeconds.html" target="_blank">https://docs.unity3d.com/ScriptReference/WaitForSeconds.html</a>)</p></li><li style="list-style-type: disc"><p><code class="literal">WaitUntil()</code>: Waits until a certain condition is met (official documentation: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/WaitUntil.html" target="_blank">https://docs.unity3d.com/ScriptReference/WaitUntil.html</a>)</p></li></ul></div></li></ul></div><p>Moreover, you can even implement custom yield instructions, as shown in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html" target="_blank">https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html</a></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note104"></a>Note</h3><p>For the most curious of you, coroutines are not threads. In fact, coroutines run on the same thread as the rest of the game.</p></div><p>It takes time to get used to them, since they are hard to make work when you have complex environments, and as such they are often considered as an advanced topic. But they unlock many potentialities in what can be done, which is fundamental for good gameplay programming. Unfortunately, in this book we don't have enough space to dedicate them a proper space, but I hope that with the official documentation, this small explanation, and the example of the spawning system in the next section, you will be able to better understand coroutines.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec100"></a>Sketching the idea of how it works</h3></div></div></div><p>We will divide our game into waves. Each wave has a determined number of Pandas, which will be spawned over time at an increasing intensity. Once all of the Pandas of that wave have been shot down, the game will increase the number of spawned Pandas for the next wave and start it. When all the waves are completed by the player, the level can be considered as a win.</p><p>In particular, we will have a cycle in a coroutine which will manage the different waves and wait till the end of a wave before starting another one. A second routine will take care of the single wave, to spawn Pandas for it, and check when all the Pandas have been shot down by the player.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec101"></a>Setting up the spawning system</h3></div></div></div><p>Designers should be provided with a way to place where the Pandas will be spawned. As such, we can create an empty game object, and call it <code class="literal">SpawningPoint</code>. Moreover, you can attach to it a gizmo, similar to what we have done with waypoints in the previous chapter. As a result, it will be visible in the <span class="strong"><strong>Scene</strong></span> view. So, at the end you should have something like this:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_07_11.jpg" /></div><p>Open the <code class="literal">GameManagerScript</code> and let's add a variable to keep track of where this <code class="literal">SpawningPoint</code> is. Since we just need the position, we can just take the Transform, instead of the whole game object:</p><pre class="programlisting">
<span class="emphasis"><em>//The Spawning Point transform so to get where the Pandas should be&#13;
  spawned</em></span> &#13;
private Transform spawner; &#13;
</pre><p>To set its value, let's change the <code class="literal">Start()</code> function like the following:</p><pre class="programlisting">void Start () {&#13;
  <span class="emphasis"><em>//Get the reference to the Player's health</em></span>&#13;
  playerHealth = FindObjectOfType&lt;HealthBarScript&gt;();&#13;
 &#13;
<span class="emphasis"><em> //Get the reference to the Spawner</em></span>&#13;
  spawner = GameObject.Find("Spawning Spot").transform;&#13;
}</pre><p>Also, we need three more variables. One is for the prefab of the Panda to instantiate the right enemy, another is for the number of waves that the player has to face, and the last one for the number of Pandas per wave (which will increase between waves):</p><pre class="programlisting">
<span class="emphasis"><em>//The Panda Prefab that should be spawned as enemy</em></span>&#13;
public GameObject pandaPrefab;&#13;
&#13;
<span class="emphasis"><em>//The number of waves that the player has to face in this level</em></span>&#13;
public int numberOfWaves;&#13;
&#13;
<span class="emphasis"><em>//The number of Pandas that the player as to face per wave.&#13;
//It increase when a wave is won.</em></span>&#13;
public int numberOfPandasPerWave;</pre><p>After we have saved the script, we have to assign the variable in the <span class="strong"><strong>Inspector</strong></span>, as shown in the following screenshot (feel free to change the values to suit the balance of your game):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_07_12.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec102"></a>Managing waves</h3></div></div></div><p>In this section, we are going to implement the first of the two coroutines aforementioned. In fact, this coroutine will cycle over all the waves, and call the second one to handle the single wave. Between waves, the number of spawned enemies is increased. If the player has won all the waves, then the <code class="literal">GameOver()</code> function is called in the winning mode.</p><p>Thus, open the <code class="literal">GameManagerScript</code> and we can start to write the following:</p><pre class="programlisting">
<span class="emphasis"><em>//Coroutine that spawns the different waves of Pandas </em></span>&#13;
private IEnumerator WavesSpawner() { &#13;
 <span class="emphasis"><em> //For each wave</em></span> &#13;
  for(int i = 0; i &lt; numberOfWaves; i++) { &#13;
    <span class="emphasis"><em>//Let the PandaSpawner coroutine to handle the single wave. When it&#13;
      finishes &#13;
    //also the wave is finished, and so this coroutine can continue.</em></span> &#13;
    yield return PandaSpawner(); &#13;
    <span class="emphasis"><em>//Increase the number of Pandas that are generated per wave</em></span> &#13;
    numberOfPandasPerWave += 3; &#13;
  } &#13;
 <span class="emphasis"><em> //If the Player won all the waves, call the GameOver function in&#13;
    "winning" mode</em></span> &#13;
  GameOver(true); &#13;
} &#13;
</pre><p>As you can see from the code, we call call the <code class="literal">PandaSpawner()</code> coroutine, which we implement in the next section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec103"></a>The single wave</h3></div></div></div><p>Now for the tough part. Here we need to write a coroutine that is able to handle a whole wave of Pandas. Therefore, let's look at it step-by-step, starting with creating the coroutine:</p><pre class="programlisting">
<span class="emphasis"><em>//Coroutine that spawns the Pandas for a single wave, and waits until&#13;
  "all the Pandas are in Heaven"</em></span> &#13;
private IEnumerator PandaSpawner() { &#13;
  <span class="emphasis"><em>//Rest of the code</em></span> &#13;
} &#13;
</pre><p>The first thing to do is to initialize the <code class="literal">numberOfPandasToDefeat</code> variable, to keep track of how many Pandas the player has defeated so far. Of course, we will initialize this number to be the same as the number of Pandas that will be spawned in the wave:</p><pre class="programlisting">
<span class="emphasis"><em>//Initialize the number that needs to be defeated for this wave</em></span> &#13;
numberOfPandasToDefeat = numberOfPandasPerWave; &#13;
</pre><p>The next step is to cycle through all the Pandas to spawn, to progressively spawn them:</p><pre class="programlisting">
<span class="emphasis"><em>//Progressively spawn Pandas</em></span> &#13;
for(int i=0; i &lt; numberOfPandasPerWave; i++) {&#13;
  <span class="emphasis"><em>//Rest of the code inside the cycle</em></span> &#13;
} &#13;
<span class="emphasis"><em>//Rest of the code outside the cycle</em></span>
</pre><p>Inside the cycle, we need to first spawn the Pandas at their spawned position (with no rotation, which means having the identity as a <span class="strong"><strong>quaternion</strong></span>). Then, we need to wait for a time that depends both on how many Pandas are left and by a random number. In particular, we will calculate the ratio of how many Pandas are left, and use it to interpolate between two times. As a result, the greater the number of Pandas spawned so far, the less time to wait. Then, this is added to a random number, to add a bit of chance in our game. Here is the code:</p><pre class="programlisting">
<span class="emphasis"><em>//Spawn/Instantiate a Panda at the Spawner position</em></span> &#13;
Instantiate(pandaPrefab, spawner.position, Quaternion.identity);&#13;
 &#13;
<span class="emphasis"><em>//Wait a time that depends both on how many Pandas are left to be &#13;
//spawned and by a random number</em></span> &#13;
float ratio = (i * 1f) / (numberOfPandasPerWave - 1); &#13;
float timeToWait = Mathf.Lerp(3f, 5f, ratio) + Random.Range(0f, 2f); &#13;
yield return new WaitForSeconds(timeToWait); &#13;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note105"></a>Note</h3><p>Of course, this is not the only way to implement this and the numbers in the code are arbitrary. In a real game, everything should be decided in order to balance the game, by the hard work of designing and play testing. You can find a bit more about this in the next chapter.</p></div><p>Outside the cycle, instead, we need to wait until all the Pandas have been shot down by the player (or some game over conditions have been met) before ending the coroutine, and so give back control to the <code class="literal">WavesSpawner()</code> coroutine for the next wave:</p><pre class="programlisting">
<span class="emphasis"><em>//Once all the Pandas are spawned, wait until all of them are defeated &#13;
//by the player (or a gameover condition occurred before)</em></span> &#13;
yield return new WaitUntil(() =&gt; numberOfPandasToDefeat &lt;= 0); &#13;
</pre><p>Save the script, and as a result, the player has to face many, terrible waves of sweet-toothed Pandas!</p></div></div>