<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec58"></a>Rigidbodies</h2></div></div><hr /></div><p>Rigidbodies are, along with Colliders, the core of the Physics engine beneath Unity. When they are attached to a game object, they place it under the control of the Physics engine, which will take care to properly move its Transform. In fact, they should be moved with other functions, and scripts shouldn't touch the Transform. We will see this in detail later.</p><p>The exact name of the component is <span class="strong"><strong>Rigidbody 2D</strong></span> (whereas <span class="strong"><strong>Rigidbody</strong></span> is for the 3D Physics engine, but for brevity many times we will use the term rigidbody to specify a <span class="strong"><strong>Rigidbody 2D</strong></span> component).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note63"></a>Note</h3><p>From Unity 5.4, and then again in Unity 5.5, the <span class="strong"><strong>Rigidbody 2D</strong></span> component has slightly changed. In fact, many improvements have been made to the Physics engine of Unity.</p></div><p>Once the component is added to a game object, it looks like this:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_012.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec59"></a>How a Rigidbody 2D works</h3></div></div></div><p>Every time we wanted to position an object (or its children) or move it, we changed its Transform, which defines where it is in the space as well as how it is rotated or scaled. However, the Physics engine will simulate how the object will interact in a world where physics is simulated. So, if the object has a collision with another one, it will change direction or speed. This means that the Physics engine has to change in some way the Transform of the object (that's why we shouldn't touch it with scripts for physical objects; we will see later how to deal with them by scripting). This way is the Rigidbody component, which is a sort of hub between the Physics engine and the properties of the object, including the Transform.</p><p>Therefore, after the Physics engine has made its calculation, it communicates with the rigidbody, which needs to be in its next position, and the Rigidbody component provides to change the Transform to match that new position.</p><p>The same applies to colliders (we will see them in detail soon). Each collider attached to the same object of the rigidbody (or to some of its children) will be linked to the rigidbody, and we shouldn't modify the collider or move it but instead move the whole rigidbody. These colliders, which are linked to the rigidbody, allow the rigidbody to actually collide with colliders of another rigidbody and give them a shape in the physics world.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec60"></a>Body types</h3></div></div></div><p>The most important variable in a <span class="strong"><strong>Rigidbody 2D</strong></span> is the <span class="strong"><strong>Body Type</strong></span>, which is highlighted in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_013.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note64"></a>Note</h3><p>If you are using a previous version of Unity (older than 5.5), this variable won't be available. However, you can still get the kinematic mode by checking the <span class="strong"><strong>Is Kinematic</strong></span> parameter, which is available in older versions (from 5.4 and below). You can see this highlighted in the following screenshot (Unity 5.4):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_014.jpg" /></div><p>
</p><p>And here in Unity 5.3:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_015.jpg" /></div><p>
</p><p>Older versions, such as 5.2 and below, are similar to the 5.3.</p></div><p>In fact, depending on how the <span class="strong"><strong>Body Type</strong></span> is set, it affects the other settings available on the component. Moreover, it's important to remember that any <span class="strong"><strong>Collider 2D</strong></span> attached to a <span class="strong"><strong>Rigidbody 2D</strong></span> inherits the <span class="strong"><strong>Rigidbody 2D</strong></span> component's <span class="strong"><strong>Body Type</strong></span>.</p><p>The <span class="strong"><strong>Body Type</strong></span> determines how the object will move, how the colliders will interact, and therefore also how computationally expensive that rigidbody will be.</p><p>Changing the <span class="strong"><strong>Body Type</strong></span> of a <span class="strong"><strong>Rigidbody 2D</strong></span> at runtime can be complicated. There are a few things that you need to consider; for example, when a <span class="strong"><strong>Body Type</strong></span> changes, various mass-related internal properties are recalculated immediately. In addition, all existing contacts for the Collider 2D components attached to the Rigidbody 2D need to be reevaluated during the GameObject's next <code class="literal">FixedUpdate</code>. As a result, depending on the number of contacts and Collider 2D components that are attached to the body, when you change the <span class="strong"><strong>Body Type</strong></span> of the rigidbody, it can cause variations in performance.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note65"></a>Note</h3><p>It's worthwhile to mention that sometimes rigidbodies are described as colliding with each other. Although this is true when we talk about physics (so when we talk of rigid bodies), it is not true in the case of Rigidbody 2D<span class="strong"><strong> </strong></span>(the component of Unity). In fact, in terms of the Physics engine of Unity, only colliders attached to rigidbodies will collide. However, saying that two rigidbodies have collided is a short way of saying that their colliders have hit each other.</p></div><p>The <span class="strong"><strong>Body Type</strong></span> can be set to be of three types. Let's see them in detail:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Dynamic</strong></span>: This means that the rigidbody will follow all dynamic calculations, which means dealing with forces that cause motion. In fact, the rigidbody will have a mass and both linear and angular drag. Moreover, the body will be affected by gravity as well. In fact, this is the default body type, since it is the most used and collides with everything. But exactly for this reason, it is also the most computationally expensive body type.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Kinematic</strong></span>: This means that the body is still able to move as a physical object, but there are no forces for its motion, and therefore it is not affected by gravity either. In fact, you need to script its motion with any formula (we will see this later), which may or may not be physically realistic (or maybe it is in your game world). However, it is still able to collide, which means the Physics engine will notify your script that the rigidbody has collided, and then it's up to us what happens next. In the case of a collision with a dynamic body type, the kinematic one is considered immovable, which means with an infinite mass. In fact, all dynamic properties, such as mass, are not available. From a computational point of view, the kinematic body type is faster than the dynamic one, since not calculating all the dynamic forces demands less resources from the Physics engine.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Static</strong></span>: This means the rigidbody is not supposed to move at all under the Physics engine (or under simulation). This is intended for an object with infinite mass. Under a simulation, a static Rigidbody 2D is designed to not move. In the instance of something colliding with it, a static Rigidbody 2D behaves like an immovable object (as if it has infinite mass). It is also the least resource-intensive body type to use. A static body only collides with dynamic Rigidbody 2Ds. Having two static Rigidbody 2Ds collide is not supported. This is simply because they are not designed to move. As a result, there are a limited number of properties that are available for this body type.</p></li></ul></div><p>To better understand the differences between these body types, here is a table with the different features available for each one of them (we will see them in detail in the next section):</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/B03794_05_A-2.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec61"></a>Rigidbody properties</h3></div></div></div><p>In the previous table, we saw many properties; they may or may not be available for some body types. But what do they actually do and what do they determine for the rigidbody? Let's explore these properties in detail:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Material</strong></span>: A physics material that determines properties of collisions, such as friction and bounce (we will see more about physics materials later). This material will be applied to all the colliders under the control of the rigidbody (we will see more about colliders in the next section). This comes in handy when you need to have many colliders with the same physics material.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Simulated</strong></span>: A checkbox that enables the rigidbody to interact with the Physics engine. If it is unchecked, then the rigidbody and so all the colliders referring to it will be disabled and transparent for the Physics engine as if they don't exist. This is useful to enable and disable many colliders at runtime (see the optional <span class="emphasis"><em>More about physics</em></span> section to know more).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Use Auto Mass</strong></span>: A checkbox that, if enabled, allows Unity to calculate the mass of the object by itself. These calculations are based on the dimension and density of each of the colliders that are referring to that specific rigidbody.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Mass</strong></span>: If the previous checkbox is disabled, we can manually specify a mass for our rigidbody.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Linear Drag</strong></span>: The value of the linear drag that affects the rigidbody. If it is different from zero, the object will eventually stop moving.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Angular Drag</strong></span>: The value of the angular drag that affects the rigidbody. If it is different from zero, the object will eventually stop rotating.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Gravity Scale</strong></span>: This is a multiplier to the gravity value for that specific rigidbody. This means that a value of <code class="literal">0.4</code> will reduce the gravity to 40% of its original value. This is useful when in your game you have objects that react to gravity in a different way. Imagine a fireball cast by your wizard; you may want it to have a rather straight trajectory (even if it is still a parabola, unless the trajectory is completely straight and the <span class="strong"><strong>Gravity Scale</strong></span> is set to <code class="literal">0</code>, which means no gravity affects the rigidbody). Whereas you want the grenade of your soldier to have a clear parabolic trajectory, since it is affected by gravity. Values greater than <code class="literal">1</code> lead to a stronger gravity than for its original value as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_016.jpg" /></div><p>On the left in the preceding diagram is a fireball, which is not affected by gravity when the gravity scale is set to zero, leading to a straight line trajectory. On the right is a grenade, which is affected by gravity (because the gravity scale is greater than zero; in this case, it is exactly <code class="literal">1</code>, which means normal gravity). Without other forces, rigidbodies with a linear velocity and affected by gravity have a parabolic trajectory.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Use Full Kinematic Contacts</strong></span>: A checkbox available only for kinematic body types. If enabled, it allows the kinematic rigidbody to collide with other kinematic rigidbodies. By default, it is set to false, which means that the rigidbody will only collide with dynamic rigidbodies (with the exception of colliders set as triggers).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Collision Detection</strong></span>: The way Unity detects collisions. It can be either <span class="strong"><strong>Discrete</strong></span> or <span class="strong"><strong>Continuous</strong></span>. In the first case, collision detection is calculated only on the position of the physical objects, and if they collide (which means that if the colliders overlap after the update of the positions of the objects, then Unity calculates the collision). On the contrary, continuous collision detection is calculated on the trajectory itself and not only on the positions of the objects. Imagine you have a really fast bullet, which is heading against a really thin wall. Since the game is discrete (the game renders frame by frame), when the bullet is near the wall, in the next update, it can be so fast that its new position is behind the wall. As such, with discrete collision detection, the bullet has crossed the wall without problems, because the Physics engine doesn't detect any collision. With continuous collision detection instead, the Physics engine is aware of the trajectory that the bullet has followed and does calculations on it. So, even if the the final position of the bullet is behind the wall, the collision is detected and it is properly handled by the Physics engine, which recalculates the new position of the bullet taking the collision into account as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_017.jpg" /></div><p>On the left in the preceding diagram is the discrete method, in which only the different positions between frames are taken into consideration. Therefore, if the position of the bullet in the next frame is behind the wall, the discrete method won't detect the collision. On the right is the continuous method, in which the whole trajectory of the bullet is taken into consideration. Therefore, even if in the next frame the bullet is behind the wall, the collision is detected and a new position is calculated based on the collision. This second method is a bit more computationally expensive.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Sleeping Mode</strong></span>: This is the way Unity deals with whether a rigidbody should be awake or sleeping at the beginning, or whether it has the possibility to sleep at all. The possible choices of this variable, with self-explanatory names, are: <span class="strong"><strong>Never Sleep</strong></span>, <span class="strong"><strong>Start Awake</strong></span>, and <span class="strong"><strong>Start Asleep</strong></span>. A rigidbody is sleeping when it is not taken completely into consideration by the Physics engine (it differs from not being simulated, and now we see why). Imagine how many objects in your game could be potently moving but they don't at the moment. For example, imagine a ball pit with thousands of balls, but at the moment none of them are moving. In this scenario, it's useless to call each one of them in the Physics engine for void calculations. Another example: imagine a pendulum that is stopping, and its oscillation arc is too small to be perceived by the player. Calculating the exact position of the pendulum on this arc is a waste of computational resources. It's better to stop the pendulum or the balls (set them into sleeping mode) until an event, such as the player diving in the ball pit or pushing the pendulum. So, for performance reasons, not all rigidbodies are awake at any moment. However, they can be awoken by an event, which is usually automatic in the Physics engine. But it can also be controlled by you within a script (we will see more details about this in the next section).</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Interpolate</strong></span>: When a rigidbody is moving, maybe under a force, the Physics engine performs some calculations on which will be its next position. However, the Physics engine is not perfect and cannot replicate our physics. In fact, algorithms are subjected to numerical instability, which may result in a jerky motion in our case. Therefore, Unity offers you two ways to smooth the motion and make it less jerky, plus the option <span class="strong"><strong>None</strong></span>, in which no smoothing is performed. The first way, called <span class="strong"><strong>Interpolate</strong></span>, takes into consideration the previous position of the rigidbody. On the contrary, the second way, called <span class="strong"><strong>Extrapolate</strong></span>, takes into consideration the prevision of the next position of the object. Both methods work well, and you can perceive the difference between them and <span class="strong"><strong>None</strong></span>. However, the difference between the two could be tricky to understand, especially since their behaviour is really similar, and understanding which one is better for your game can sometimes be determined just by trial and error (unless you have really specific needs).</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_018.jpg" /><div class="caption"><p>On the left, the trajectory is not interpolated; it leads to a fragmented trajectory. On the right, the trajectory is interpolated and its curve is smoothed.</p></div></div></li><li style="list-style-type: disc"><p><span class="strong"><strong>Constraints</strong></span>: These prevent the rigid body from moving or rotating in a certain way, if not at all. In the case of 2D, you can freeze the motion along <span class="emphasis"><em>x</em></span> or <span class="emphasis"><em>y</em></span> or both axes and rotation along the <span class="emphasis"><em>z-</em></span>axis. All of them are independent checkboxes, which can be selected in any combination. Of course, having all of them selected means that the rigidbody won't be able to move. Imagine you are developing a puzzle game and your main character game needs to move a box, maybe by pushing it. However, we don't want the box to start to rotate on itself if the player doesn't push the middle point of the box. As such, we can freeze the rotation of the box, still allowing the box to move and be pushed by the main character.</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_019.jpg" /><div class="caption"><p>On the left, there are no constraints, and therefore when the player pushes, the object might rotate. On the right, the rotation is frozen, and when the player pushes, the object won't rotate. Which behaviour to choose depends on the design of your game.</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note66"></a>Note</h3><p><span class="strong"><strong>Info</strong></span><span class="strong"><strong>: </strong></span>A foldout showing all the other variables of the rigidbody, which is very useful in debugging.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec62"></a>Dealing with rigidbodies</h3></div></div></div><p>Now that we have explored the Rigidbody 2D component in detail, let's see how we can deal with it within scripts. As previously explained, scripts are not supposed to change the Transform of a rigidbody. So how we can move them? The answer is that some special functions exist.</p><p>These functions need to be called on the rigidbody; therefore probably you may want to have a reference to the Rigidbody 2D, like this fragment of script:</p><pre class="programlisting">
<span class="emphasis"><em>//Reference to the RigidBody2D component </em></span> &#13;
public Rigidbody2D rb2D;&#13;
&#13;
void Start() { &#13;
 <span class="emphasis"><em> //Get the reference to the Rigidbody2D component</em></span> &#13;
  rb2D = GetComponent&lt;Rigidbody2D&gt;(); &#13;
} &#13;
</pre><p>As a result, you can call the functions in this way:</p><pre class="programlisting">Rb2D.NameOfTheFunction() &#13;
</pre><p>Where of course, instead of <code class="literal">NameOfTheFunction</code> there will be one of the functions listed next. However, if you remember, the Physics engine might be called more than once per frame, and therefore all of these functions should be called within <code class="literal">FixedUpdate()</code>.</p><p>So how can we actually move a rigidbody? For dynamic body types, we can either just leave them at the mercy of the external forces such as gravity, collisions, and so on, or we can apply a specific force.</p><p>In order to apply a force to the rigidbody, there are the following useful functions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">AddForce(Vector2 force, ForceMode2D mode = ForceMode2D.Force)</code>: Applies a force specified in the <code class="literal">force</code> parameter. Moreover, enum  <code class="literal">ForceMode2D</code> is an optional parameter that specifies whether the force should act as an impulse or not. By default, it is not an impulse.</p></li><li style="list-style-type: disc"><p><code class="literal">AddForceAtPosition(Vector2 force, Vector2 position, ForceMode2D mode = ForceMode2D.Force)</code>: Behaves like the previous function, but you can also specify an application point for the force.</p></li><li style="list-style-type: disc"><p><code class="literal">AddRelativeForce(Vector2 relativeForce, ForceMode2D mode = ForceMode2D.Force)</code>: Behaves like the first function, but the force is specified in local coordinates.</p></li><li style="list-style-type: disc"><p><code class="literal">AddTorque(float torque, ForceMode2D mode = ForceMode2D.Force)</code>: This applies a torque to the rigidbody; likewise, the first function applies instead a force.</p></li></ul></div><p>For kinematic body types instead, we have two functions to explicitly move these kinds of body types and still allow the Physics engine to perform collision detection correctly. Inside these functions, we directly pass a position and a rotation, which can be calculated with any formula. Therefore they can follow any physics law you want (or one that is meaningful in your game):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">public void MovePosition(Vector2 position)</code>: Moves the rigidbody to the specified position</p></li><li style="list-style-type: disc"><p><code class="literal">public void MoveRotation(float angle)</code>: Rotates the rigidbody to the specified angle</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note67"></a>Note</h3><p>The easiest example is to apply the classical kinematic law for velocity to make the kinematic body move in a straight line indefinitely. For the most curious of you, the formula is the following:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_020.jpg" /></div><p>The ∆ (read delta) in physics means the final minus the initialwhich can be rewritten (by explicitly separating the delta of the space) as:</p><div class="mediaobject"><img src="/graphics/9781784397173/graphics/image_05_021.jpg" /></div><p>We can translate this into Unity with the following fragment of code (instead of <code class="literal">Time.deltaTime</code>, we need to use <code class="literal">Time.deltaFixedTime</code>):</p><pre class="programlisting">public Vector2 velocity;
void FixedUpdate () {
  rb2D.MovePosition(rb2D.position + velocity * Time.fixedDeltaTime);
} 
</pre></div><p>Moreover, we have some or the other function for all kinds of body types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><code class="literal">IsAwake()</code>: Returns true if the rigidbody is awake.</p></li><li style="list-style-type: disc"><p><code class="literal">IsSleeping()</code>: Returns true if the rigidbody is sleeping.</p></li><li style="list-style-type: disc"><p><code class="literal">IsTouching(Collider2D collider)</code>: Returns true if the collider is touching the rigidbody (which means any of the colliders attached to the rigidbody)</p></li><li style="list-style-type: disc"><p><code class="literal">OverlapPoint(Vector2 point)</code>: Returns true if the point is overlapping the rigidbody (which means any of the colliders attached to the rigidbody)</p></li><li style="list-style-type: disc"><p><code class="literal">Sleep()</code>: Makes the rigidbody sleep</p></li><li style="list-style-type: disc"><p><code class="literal">WakeUp()</code>: Disables the sleeping mode of the rigidbody</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note68"></a>Note</h3><p>For the full list of functions and variables of a Rigidbody 2D component, you can consult the official documentation here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Rigidbody2D.html" target="_blank">https://docs.unity3d.com/ScriptReference/Rigidbody2D.html</a>.</p></div></div></div>