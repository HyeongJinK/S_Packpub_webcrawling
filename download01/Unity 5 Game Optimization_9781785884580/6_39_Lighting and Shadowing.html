<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec40"></a>Lighting and Shadowing</h2></div></div><hr /></div><p>Lighting and Shadowing <a id="id457" class="indexterm"></a>can affect all parts of the graphics pipeline, and so they will be treated separately. This is perhaps one of the most important parts of game art and design to get right. Good Lighting and Shadowing can turn a mundane scene into something spectacular as there is something magical about professional coloring that makes it visually appealing. Even the low-poly art style (think Monument Valley) relies heavily on a good lighting and shadowing profile in order to allow the player to distinguish one object from another. But, this isn't an art book, so we will focus on the performance characteristics of various Lighting and Shadowing features.</p><p>Unity offers two styles of dynamic light rendering, as well as baked lighting effects through lightmaps. It also provides multiple ways of generating shadows with varying levels of complexity and runtime processing cost. Between the two, there are a lot of options to explore, and a lot of things that can trip us up if we're not careful.</p><p>The Unity<a id="id458" class="indexterm"></a> documentation covers all of these features in an excellent amount of detail (start with this page and work through them: <a class="ulink" href="http://docs.unity3d.com/Manual/Lighting.html" target="_blank">http://docs.unity3d.com/Manual/Lighting.html</a>), so we'll examine these features from a performance standpoint.</p><p>Let's tackle the two main light rendering modes first. This setting can be found under <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span> | <span class="strong"><strong>Other Settings</strong></span> | <span class="strong"><strong>Rendering</strong></span>, and can be configured on a per-platform basis.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec76"></a>Forward Rendering</h3></div></div></div><p>Forward Rendering is the classical form of rendering lights in our scene. Each object is likely to be rendered in multiple passes through the same Shader. How many passes are required will be based on the number, distance, and brightness of light sources. Unity will try to prioritize which <a id="id459" class="indexterm"></a>directional light is affecting the object the most and render the object in a "base pass" as a starting point. It will then take up to four of the most powerful point lights nearby and re-render the same object multiple times through the same Fragment Shader. The next four point lights will then be processed on a per-vertex basis. All remaining lights are treated as a giant blob by means of a technique called <a id="id460" class="indexterm"></a>
<span class="strong"><strong>spherical harmonics</strong></span>.</p><p>Some of this behavior can be simplified by setting a light's Render Mode to values such as <span class="strong"><strong>Not Important</strong></span>, and changing the value of <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Quality</strong></span> | <span class="strong"><strong>Pixel Light Count</strong></span>. This value limits how many lights will be treated on a per pixel basis, but is overridden by any lights with a <span class="strong"><strong>Render Mode</strong></span> set to <span class="strong"><strong>Important</strong></span>. It is therefore up to us to use this combination of settings responsibly.</p><p>As you can imagine, the <a id="id461" class="indexterm"></a>design of Forward Rendering can utterly explode our Draw Call count very quickly in scenes with a lot of point lights present, due to the number of render states being configured and Shader passes being reprocessed. CPU-bound applications should avoid this rendering mode if possible.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>More information on <a id="id462" class="indexterm"></a>Forward Rendering can be found in the Unity documentation: <a class="ulink" href="http://docs.unity3d.com/Manual/RenderTech-ForwardRendering.html" target="_blank">http://docs.unity3d.com/Manual/RenderTech-ForwardRendering.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec77"></a>Deferred Shading</h3></div></div></div><p>Deferred Shading or<a id="id463" class="indexterm"></a> Deferred Rendering as it is sometimes known, is only available on GPUs running at least Shader Model 3.0. In other words, any desktop graphics card made after around 2004. The technique has been around for a while, but it has not resulted in a complete replacement of the Forward Rendering method due to the caveats involved and limited support on mobile devices. Anti-aliasing, transparency, and animated characters receiving shadows are all features that cannot be managed through Deferred Shading alone and we must use the Forward Rendering technique as a fallback.</p><p>Deferred Shading is so named because actual shading does not occur until much later in the process; that is, it is deferred until later. From a performance perspective, the results are quite impressive as it can generate very good per pixel lighting with surprisingly little Draw Call effort. The advantage is that a huge amount of lighting can be accomplished using only a single pass through the lighting Shader. The main disadvantages include the additional costs if we wish to pile on advanced lighting features such as Shadowing and any steps that must pass through Forward Rendering in order to complete, such as transparency.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p>The Unity<a id="id464" class="indexterm"></a> documentation contains an <a id="id465" class="indexterm"></a>excellent source of information on the Deferred Shading technique, its advantages, and its pitfalls: <a class="ulink" href="http://docs.unity3d.com/Manual/RenderTech-DeferredShading.html" target="_blank">http://docs.unity3d.com/Manual/RenderTech-DeferredShading.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec78"></a>Vertex Lit Shading (legacy)</h3></div></div></div><p>Technically, there are more than two lighting methods. Unity allows us to use a couple of legacy lighting systems, only one of which may see actual use in the field: Vertex Lit Shading. This is a<a id="id466" class="indexterm"></a> massive simplification of lighting, as lighting is only considered per vertex, and not per pixel. In other words, entire faces are colored based on the incoming light color, and not individual pixels.</p><p>It is not expected that many, or really any, 3D games will make use of this legacy technique, as a lack of shadows and proper lighting make visualizations of depth very difficult. It is mostly relegated to 2D games that don't intend to make use of shadows, normal maps, and various other lighting features, but it is there if we need it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec79"></a>Real-time Shadows</h3></div></div></div><p>Soft Shadows are <a id="id467" class="indexterm"></a>expensive, Hard Shadows are cheap, and No Shadows are free. <span class="strong"><strong>Shadow Resolution</strong></span>, <span class="strong"><strong>Shadow Projection</strong></span>, <span class="strong"><strong>Shadow Distance</strong></span>, and <span class="strong"><strong>Shadow Cascades</strong></span> are all settings we can find under <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Quality</strong></span> | <span class="strong"><strong>Shadows</strong></span> that we can use to modify the behavior and complexity of our shadowing passes. That summarizes almost everything we need to know about Unity's real-time shadowing techniques from a high-level performance standpoint. We will cover shadows more in the following section on optimizing our lighting effects.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec80"></a>Lighting optimization</h3></div></div></div><p>With a cursory glance<a id="id468" class="indexterm"></a> at all of the relevant lighting techniques, let's run through some techniques we can use to improve lighting costs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec64"></a>Use the appropriate Shading Mode</h4></div></div></div><p>It is worth testing<a id="id469" class="indexterm"></a> both of the main rendering modes to see which one best suits our game. Deferred Shading is often used as a backup in the event that Forward Rendering is becoming a burden on performance, but it really depends on where else we're finding bottlenecks as it is sometimes difficult to tell the difference between them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec65"></a>Use Culling Masks</h4></div></div></div><p>A Light Component's <span class="strong"><strong>Culling Mask</strong></span> property is a layer-based mask that can be used to limit which objects will be affected by the given Light. This is an effective way of reducing lighting<a id="id470" class="indexterm"></a> overhead, assuming that the layer interactions also make sense with how we are using layers for physics optimization. Objects can only be a part of a single layer, and reducing physics overhead probably trumps lighting overhead in most cases; thus, if there is a conflict, then this may not be the ideal approach.</p><p>Note that there is limited support for Culling Masks when using Deferred Shading. Because of the way it treats lighting in a very global fashion, only four layers can be disabled from the mask, limiting our ability to optimize its behavior through this method.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec66"></a>Use Baked Lightmaps</h4></div></div></div><p>Baking Lighting<a id="id471" class="indexterm"></a> and Shadowing into a Scene is significantly less processor-intensive than generating them at runtime. The downside is the added application footprint, memory consumption, and potential for memory bandwidth abuse. Ultimately, unless a game's lighting effects are being handled exclusively through Legacy Vertex Lighting or a single Directional Light, then it should probably include Lightmapping to make some huge budget savings on lighting calculations. Relying entirely on real-time lighting and shadows is a recipe for disaster unless the game is trying to win an award for the smallest application file size of all time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec67"></a>Optimize Shadows</h4></div></div></div><p>Shadowing passes<a id="id472" class="indexterm"></a> mostly consume our Draw Calls and fill rate, but the amount of vertex position data we feed into the process and our selection for the <span class="strong"><strong>Shadow Projection</strong></span> setting will affect the front end's ability to generate the required shadow casters and shadow receivers. We should already be attempting to reduce vertex counts to solve front end bottlenecking in the first place, and making this change will be an added multiplier towards that effort.</p><p>Draw Calls are consumed during shadowing by rendering visible objects into a separate buffer (known as the shadow map) as either a shadow caster, a shadow receiver, or both. Each object that is rendered into this map will consume another Draw Call, which makes shadows a huge performance cost multiplier, so it is often a setting that games will expose to users via quality settings, allowing users with weaker hardware to reduce the effect or even disable it entirely.</p><p>
<span class="strong"><strong>Shadow Distance</strong></span> is a global multiplier for runtime shadow rendering. The fewer shadows we need to draw, the happier the entire rendering process will be. There is little point in rendering shadows at a great distance from the camera, so this setting should be configured specific to our game and how much shadowing we expect to witness during gameplay. It is also a common setting that is exposed to the user to reduce the burden of rendering shadows.</p><p>Higher values<a id="id473" class="indexterm"></a> of <span class="strong"><strong>Shadow Resolution</strong></span> and <span class="strong"><strong>Shadow Cascades</strong></span> will increase our memory bandwidth and fill rate consumption. Both of these settings can help curb the effects of artefacts in shadow rendering, but at the cost of a much larger shadow map size that must be moved around and of the canvas size to draw to.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>The Unity documentation contains an excellent summary on the topic of the aliasing effect of shadow maps and how<a id="id474" class="indexterm"></a> the <span class="strong"><strong>Shadow Cascades</strong></span> feature helps to solve the problem: <a class="ulink" href="http://docs.unity3d.com/Manual/DirLightShadows.html" target="_blank">http://docs.unity3d.com/Manual/DirLightShadows.html</a>.</p></div><p>It's worth noting that Soft Shadows do not consume any more memory or CPU overhead relative to Hard Shadows, as the only difference is a more complex Shader. This means that applications with enough fill rate to spare can enjoy the improved graphical fidelity of Soft Shadows.</p></div></div></div>