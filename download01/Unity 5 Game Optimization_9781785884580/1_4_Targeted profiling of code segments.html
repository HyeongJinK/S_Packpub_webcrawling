<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>Targeted profiling of code segments</h2></div></div><hr /></div><p>If our performance problem isn't solved by the above checklist, then we probably have a real issue on our hands that demands further analysis. The task of figuring out exactly where the<a id="id61" class="indexterm"></a> problem is located still remains. The Profiler window is effective at showing us a broad overview of performance; it can help us find specific frames to investigate and can quickly inform us which MonoBehaviour and/or method may be causing issues. However, we must still determine exactly where the problem exists. We need to figure out if the problem is reproducible, under what circumstances a performance bottleneck arises, and where exactly within the problematic code block the issue is originating from.</p><p>To accomplish these, we will need to perform some profiling of targeted sections of our code, and there are a handful of useful techniques we can employ for this task. For Unity projects, they essentially fit into two categories:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Controlling the Profiler from script code</p></li><li style="list-style-type: disc"><p>Custom timing and logging methods</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"></a>Note</h3><p>Note that the following section mostly focusses on how to investigate Scripting bottlenecks through C# code. Detecting the source of bottlenecks in other engine components will be discussed in their related chapters.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec14"></a>Profiler script control</h3></div></div></div><p>The Profiler can be controlled in script code through the static Profiler class. There are several useful methods in the<a id="id62" class="indexterm"></a> Profiler class that we can explore within the Unity documentation, but the most important methods are the delimiter methods that activate and deactivate profiling at runtime: <code class="literal">Profiler.BeginSample()</code> and <code class="literal">Profiler.EndSample()</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip10"></a>Tip</h3><p>Note that the delimiter methods, <code class="literal">BeginSample()</code> and <code class="literal">EndSample()</code>, are only compiled in development builds, and as such they cause no overhead in the final build. Therefore, it is safe to leave them in our codebase if we wish to use them for profiling tests at a later date.</p></div><p>The <code class="literal">BeginSample()</code> method has an overload that allows a custom name for the sample to appear in the CPU Usage Area's Hierarchy Mode view. For example, the following code will profile invocations of this method and make the data appear in the Breakdown View under a custom heading:</p><div class="informalexample"><pre class="programlisting">void DoSomethingCompletelyStupid() {
  Profiler.BeginSample("My Profiler Sample");

  List&lt;int&gt; listOfInts = new List&lt;int&gt;();
  for(int i = 0; i &lt; 1000000; ++i) {
    listOfInts.Add(i);
  }

  Profiler.EndSample();
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip11"></a>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p>We should expect that invoking this poorly designed method (it generates a list containing a million integers, and then does absolutely nothing with it) will cause a huge spike in CPU usage, chew up several Megabytes of memory, and appear in the Profiler Breakdown View under the heading <span class="emphasis"><em>My Profiler Sample</em></span> as the following screenshot shows:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_01_07.jpg" /></div><p>Note that these <a id="id63" class="indexterm"></a>custom sample names do not appear at the root of the hierarchy when we perform <span class="strong"><strong>Deep Profiling</strong></span>. The following screenshot shows the Breakdown View for the same code under Deep Profiling:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_01_08.jpg" /></div><p>Note how the custom<a id="id64" class="indexterm"></a> name for the sample does not appear at the top of the sample, where we may expect it to. It's unclear what causes this phenomenon, but this can cause some confusion when examining the Deep Profiling data within <span class="strong"><strong>Hierarchy</strong></span> Mode, so it is good to be aware of it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec15"></a>Custom CPU Profiling</h3></div></div></div><p>The Profiler is just <a id="id65" class="indexterm"></a>one tool at our disposal. Sometimes, we may want to perform customized profiling and logging of our code. Maybe we're not confident the Unity Profiler is giving us the right answer, maybe we consider its overhead cost too great, or maybe we just like having complete control of every single aspect of our application. Whatever our motivations, knowing some techniques to perform an independent analysis of our code is a useful skill to have. It's unlikely we'll only be working with Unity for the entirety of our game development careers, after all.</p><p>Profiling tools are very complex, so it's unlikely we would be able to generate a comparable solution on our own within a reasonable time frame. When it comes to testing CPU usage, all we need is an accurate timing system, a fast, low-cost way of logging that information, and some piece of code to test against. It just so happens that the .NET library (or, technically, the Mono framework) comes with a <code class="literal">Stopwatch</code> class under the <code class="literal">System.Diagnostics</code> namespace. We can stop and start a <code class="literal">Stopwatch</code> object at any time, and we can easily acquire a measure of how much time has passed since the Stopwatch was started.</p><p>Unfortunately, this class is not very accurateâ€”it is accurate only to milliseconds, or tenths of a millisecond at best. Counting high-precision real time with a CPU clock can be a surprisingly difficult task when we start to get into it; so, in order to avoid a detailed discussion of the topic, we should try to find a way for the <code class="literal">Stopwatch</code> class to satisfy our needs.</p><p>Before we get obsessed with the topic of high precision, we should first ask ourselves if we even need it. Most games expect to run at 30 FPS (frames-per-second) or 60 FPS, which means they<a id="id66" class="indexterm"></a> only have around 33 ms or 16 ms, respectively, to compute everything for the entire frame. So, hypothetically, if we only need to bring the performance of a particular code block under 10ms, then repeating the test thousands of times to get microsecond precision wouldn't really tell us anything useful.</p><p>However, if precision is important, then one effective way to increase it is by running the same test multiple times. Assuming that the test code block is both easily repeatable and not exceptionally long, then we should be able to run thousands, or even millions, of tests within a reasonable timeframe and then divide the total elapsed time by the number of tests we just performed to get a more accurate time for a single test.</p><p>The following is a class definition for a custom timer that uses a <code class="literal">Stopwatch</code> to count time for a given number of tests:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System;
using System.Diagnostics;
using System.Collections;

public class CustomTimer : IDisposable {
  private string m_timerName;
  private int m_numTests;
  private Stopwatch m_watch;

  // give the timer a name, and a count of the number of tests we're running
  public CustomTimer(string timerName, int numTests) {
    m_timerName = timerName;
    m_numTests = numTests;
    if (m_numTests &lt;= 0)
      m_numTests = 1;
    m_watch = Stopwatch.StartNew();
  }

  // called when the 'using' block ends
  public void Dispose() {
    m_watch.Stop();
    float ms = m_watch.ElapsedMilliseconds;
    UnityEngine.Debug.Log(string.Format("{0} finished: {1:0.00}ms total, {2:0.000000}ms per test for {3} tests", m_timerName, ms, ms / m_numTests, m_numTests));
  }
}</pre></div><p>The following is an example of the <code class="literal">CustomTimer</code> class usage:</p><div class="informalexample"><pre class="programlisting">int numTests = 1000;

using (new CustomTimer("My Test", numTests)) {
  for(int i = 0; i &lt; numTests; ++i) {
    TestFunction();
  }
} // the timer's Dispose() method is automatically called here</pre></div><p>There are three things to note when using this approach. Firstly, we are only making an average of multiple method invocations. If processing time varies enormously between invocations, then that will not be well-represented in the final average. Secondly, if memory access is common, then repeatedly requesting the same blocks of memory will result in an artificially higher cache hit rate, which will bring the average time down when compared to<a id="id67" class="indexterm"></a> a typical invocation. Thirdly, the effects of JIT compilation will be effectively hidden for similarly artificial reasons as it only affects the first invocation of the method. JIT compilation is something that will be covered in more detail in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>.</p><p>The <code class="literal">using</code> block is typically used to safely ensure that unmanaged resources are properly destroyed when they go out of scope. When the <code class="literal">using</code> block ends, it will automatically invoke the object's<a id="id68" class="indexterm"></a> <code class="literal">Dispose()</code> method to handle any cleanup operations. In order to achieve this, the object must implement the <code class="literal">IDisposable</code> interface, which forces it to define the <code class="literal">Dispose()</code> method.</p><p>However, the same language feature can be used to create a distinct code block, which creates a short-term object, which then automatically processes something useful when the code block ends.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note09"></a>Note</h3><p>Note that the <code class="literal">using</code> block should not be confused with the <code class="literal">using</code> statement, which is used at the start of a script file to pull in additional namespaces. It's extremely ironic that the keyword for managing namespaces in C# has a naming conflict with another keyword.</p></div><p>As a result, the <code class="literal">using</code> block and the <code class="literal">CustomTimer</code> class give us a clean way of wrapping our target test code in a way which makes it obvious when and where it is being used.</p><p>Another concern to worry about is application warm up. Unity has a significant startup cost when a Scene<a id="id69" class="indexterm"></a> begins, given the number of calls to various GameObjects' <code class="literal">Awake()</code> and <code class="literal">Start()</code> methods, as well as initialization of other components such as the Physics and Rendering systems. This early overhead might only last a second, but that can have a significant effect on the results of our testing. This makes it crucial that any runtime testing begins after the application has reached a steady state.</p><p>If possible, it would be wise to wrap the target code block in an <code class="literal">Input.GetKeyDown()</code> method check in order to have control over when it is invoked. For example, the following code will only execute our test method when the <span class="emphasis"><em>Space Bar</em></span> is pressed:</p><div class="informalexample"><pre class="programlisting">if (Input.GetKeyDown(KeyCode.Space)) {
  int numTests = 1000;

  using (new CustomTimer("Controlled Test", numTests)) {
    for(int i = 0; i &lt; numTests; ++i) {
      TestFunction();
    }
  }
}</pre></div><p>There are three important design features of the <code class="literal">CustomTimer</code> class: it only prints a single log message for the entire test, only reads the value from the <code class="literal">Stopwatch</code> after it has been stopped, and uses <code class="literal">string.Format()</code> for generating a custom string.</p><p>As explained earlier, Unity's console logging mechanism is prohibitively expensive. As a result, we should never use these logging methods in the middle of a profiling test (or even gameplay, for that matter). If we find ourselves absolutely needing detailed profiling data that prints out lots of individual messages (such as performing a timing test on each iteration of a loop, to find which iteration is costing more time than the rest), then it would be wiser to cache the logging data and print it all at the end, as the <code class="literal">CustomTimer</code> class does. This will reduce runtime overhead, at the cost of some memory consumption. The alternative is that many milliseconds are lost to printing each <code class="literal">Debug.Log()</code> message in the middle of the test, which pollutes the results.</p><p>The second feature is that the <code class="literal">Stopwatch</code> is stopped before the value is read. This is fairly obvious; reading the value while it is still counting might give us a slightly different value than stopping it first. Unless we dive deep into the Mono project source code (and the specific version Unity uses), we might not know the exact implementation of how <code class="literal">Stopwatch</code> counts time, at what points CPU ticks are counted, and at what moments any application context switching is triggered by the OS. So, it is often better to err on the side of caution and prevent any more counting before we attempt to access the value.</p><p>Finally, there's the usage of <code class="literal">string.Format()</code>. This will be covered in more detail in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>, but the short explanation is that this method is used because generating custom strings using the <code class="literal">+operator</code> results in a surprisingly large amount <a id="id70" class="indexterm"></a>of memory consumption, which attracts the attention of the garbage collector. This would conflict with our goal of achieving accurate timing and analysis.</p></div></div>