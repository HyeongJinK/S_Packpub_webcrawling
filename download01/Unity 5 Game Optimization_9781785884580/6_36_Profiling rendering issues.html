<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec37"></a>Profiling rendering issues</h2></div></div><hr /></div><p>Poor rendering <a id="id377" class="indexterm"></a>performance can manifest itself in a number of ways, depending on whether the device is <span class="strong"><strong>CPU-bound</strong></span>, or <span class="strong"><strong>GPU-bound</strong></span>; in the latter case, the root cause could originate from a number of places within the graphics pipeline. This can make the investigatory stage rather involved, but once the source of the bottleneck is discovered and the problem is resolved, we can expect significant improvements as small fixes tend to reap big rewards when it comes to the rendering subsystem.</p><p>We briefly touched upon the subject of being CPU/GPU-bound in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>The Benefits of Batching</em></span>. To summarize the earlier discussion, we know that the CPU sends rendering instructions through the graphics API, that funnel through the hardware driver to the GPU device, which results in commands entering the GPU's <span class="strong"><strong>Command Buffer</strong></span>. These commands are processed by the massively parallel GPU system one by one until the buffer is empty. But there are a lot more nuances involved in this process.</p><p>The following shows a (greatly simplified) diagram of a typical GPU pipeline (which can vary based on technology and various optimizations), and the broad rendering steps that take place during each stage:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_06_09.jpg" /></div><p>The top row represents the work that takes place on the CPU, the act of calling into the graphics API, through the hardware driver, and pushing commands into the GPU. Ergo, a CPU-bound application will be primarily limited by the complexity, or sheer number, of graphics API calls.</p><p>Meanwhile, a GPU-bound application will be limited by the GPU's ability to process those calls, and empty<a id="id378" class="indexterm"></a> the Command Buffer in a reasonable timeframe to allow for the intended frame rate. This is represented in the next two rows, showing the steps taking place in the GPU. But, because of the device's complexity, they are often simplified into two different sections: the front end and the back end.</p><p>The front end refers to the part of the rendering process where the GPU has received mesh data, a draw call has been issued, and all of the information that was fed into the GPU is used to transform vertices and run through Vertex Shaders. Finally, the rasterizer generates a batch of fragments to be processed in the back end. The back end refers to the remainder of the GPU's processing stages, where fragments have been generated, and now they must be tested, manipulated, and drawn via Fragment Shaders onto the frame buffer in the form of pixels.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"></a>Tip</h3><p>Note that "Fragment Shader" is the <a id="id379" class="indexterm"></a>more technically accurate term for Pixel Shaders. Fragments are generated by the rasterization stage, and only technically become pixels once they've been processed by the Shader and drawn to the Frame Buffer.</p></div><p>There are a number of different approaches we can use to determine where the root cause of a graphics rendering<a id="id380" class="indexterm"></a> issue lies:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Profiling the GPU with the Profiler</p></li><li style="list-style-type: disc"><p>Examining individual frames with the Frame Debugger</p></li><li style="list-style-type: disc"><p>Brute Force Culling</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec66"></a>GPU profiling</h3></div></div></div><p>Because graphics<a id="id381" class="indexterm"></a> rendering involves both the CPU and GPU, we must examine the problem using both the <span class="strong"><strong>CPU Usage</strong></span> and <span class="strong"><strong>GPU Usage</strong></span> areas of the Profiler as this can tell us which component is working hardest.</p><p>For example, the following<a id="id382" class="indexterm"></a> screenshot shows the Profiler data for a CPU-bound application. The test involved creating thousands of simple objects, with no batching techniques taking place. This resulted in an extremely large Draw Call count (around 15,000) for the CPU to process, but giving the GPU relatively little work to do due to the simplicity of the objects being rendered:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_06_04.jpg" /></div><p>This example shows that the CPU's "rendering" task is consuming a large amount of cycles (around 30 ms per frame), while the GPU is only processing for less than 16 ms, indicating that the bottleneck resides in the CPU.</p><p>Meanwhile, Profiling a GPU-bound application via the Profiler is a little trickier. This time, the test involves creating a small number of high polycount objects (for a low Draw Call per vertex ratio), with dozens of real-time point lights and an excessively complex Shader with a texture, normal texture, heightmap, emission map, occlusion map, and so on, (for a high workload per pixel ratio).</p><p>The following screenshot shows Profiler data for the example Scene when it is run in a standalone application:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_06_06.jpg" /></div><p>As we can see, the rendering task of the <span class="strong"><strong>CPU Usage</strong></span> area matches closely with the total rendering costs <a id="id383" class="indexterm"></a>of the <span class="strong"><strong>GPU Usage</strong></span> area. We can<a id="id384" class="indexterm"></a> also see that the CPU and GPU time costs at the bottom of the image are relatively similar (41.48 ms versus 38.95 ms). This is very unintuitive as we would expect the GPU to be working much harder than the CPU.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip40"></a>Tip</h3><p>Be aware that the CPU/GPU millisecond cost values are not calculated or revealed unless the appropriate Usage Area has been added to the Profiler window.</p></div><p>However, let's see what happens when we test the same exact Scene through the Editor:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_06_05.jpg" /></div><p>This is a better representation of what we would expect to see in a GPU-bound application. We can see how the CPU and GPU time costs at the bottom are closer to what we would <a id="id385" class="indexterm"></a>expect to see (2.74 ms vs 64.82 ms).</p><p>However, this data is highly polluted. The spikes in the CPU and GPU Usage areas are the result of the Profiler Window UI updating during testing, and the overhead cost of running through the<a id="id386" class="indexterm"></a> Editor is also artificially increasing the total GPU time cost.</p><p>It is unclear what causes the data to be treated this way, and this could certainly change in the future if enhancements are made to the Profiler in future versions of Unity, but it is useful to know this drawback.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note27"></a>Note</h3><p>Trying to determine whether our application is truly GPU-bound is perhaps the only good excuse to perform a Profiler test through the Editor.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec67"></a>The Frame Debugger</h3></div></div></div><p>A new feature in Unity 5 is<a id="id387" class="indexterm"></a> the Frame <a id="id388" class="indexterm"></a>Debugger, a debugging tool that can reveal how the Scene is rendered and pieced together, one Draw Call at a time. We can click through the list of Draw Calls and observe how the Scene is rendered up to that point in time. It also provides a lot of useful details for the selected Draw Call, such as the current render target (for example, the shadow map, the camera depth texture, the main camera, or other custom render targets), what the Draw Call did (drawing a mesh, drawing a static batch, drawing depth shadows, and so on), and what settings were used (texture data, vertex colors, baked lightmaps, directional lighting, and so on).</p><p>The following screenshot<a id="id389" class="indexterm"></a> shows a Scene that is only being partially rendered due to the currently selected Draw Call within the Frame Debugger. Note<a id="id390" class="indexterm"></a> the shadows that are visible from baked lightmaps that were rendered during an earlier pass before the object itself is rendered:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_06_07.jpg" /></div><p>If we are bound by Draw Calls, then this tool can be effective in helping us figure out what the Draw Calls are being spent on, and determine whether there are any unnecessary Draw Calls that are not having an effect on the scene. This can help us come up with ways to reduce them, such as removing unnecessary objects or batching them somehow. We can also use this tool to observe how many additional Draw Calls are consumed by rendering features, such as shadows, transparent objects, and many more. This could help us, when we're creating multiple quality levels for our game, to decide what features to enable/disable under the low, medium, and high quality settings.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec68"></a>Brute force testing</h3></div></div></div><p>If we're poring<a id="id391" class="indexterm"></a> over our Profiling data, and we're still not <a id="id392" class="indexterm"></a>sure we can determine the source of the problem, we can always try the brute force method: cull a specific activity from the Scene and see if it results in greatly increased performance. If a small change results in a big speed improvement, then we have a strong clue about where the bottleneck lies. There's no harm in this approach if we eliminate <a id="id393" class="indexterm"></a>enough unknown variables to be sure the data is leading us in the right direction.</p><p>We will cover<a id="id394" class="indexterm"></a> different ways to brute force test a particular issue in each of the upcoming sections.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec69"></a>CPU-bound</h3></div></div></div><p>If our application is <a id="id395" class="indexterm"></a>CPU-bound, then we will observe a generally poor FPS value within the <span class="strong"><strong>CPU Usage</strong></span> area of the Profiler window due to the rendering<a id="id396" class="indexterm"></a> task. However, if <span class="strong"><strong>VSync</strong></span> is enabled the data will often get muddied up with large spikes representing pauses as the CPU waits for the screen refresh rate to come around before pushing the current frame buffer. So, we should make sure to disable the <span class="strong"><strong>VSync</strong></span> block in the <span class="strong"><strong>CPU Usage</strong></span> area before deciding the CPU is the problem.</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_06_08.jpg" /></div><p>Brute-forcing a test for CPU-bounding can be achieved by reducing Draw Calls. This is a little unintuitive since, presumably, we've already been reducing our Draw Calls to a minimum through techniques such as Static and Dynamic Batching, Atlasing, and so forth. This would mean we have very limited scope for reducing them further.</p><p>What we can do, however, is disable the Draw-Call-saving features such as batching and observe if the situation gets significantly worse than it already is. If so, then we have evidence that we're either already, or very close to being, CPU-bound. At this point, we should see whether we can re-enable these features and disable rendering for a few choice objects (preferably those with low complexity to reduce Draw Calls without over-simplifying the rendering of our scene). If this results in a significant performance improvement then, unless we can find further opportunities for batching and mesh combining, we may be faced with the unfortunate option of removing objects from our scene as the only means of becoming performant again.</p><p>There are some additional opportunities for Draw Call reduction, including Occlusion Culling, tweaking our Lighting and Shadowing, and modifying our Shaders. These will be explained in the following sections.</p><p>However, Unity's<a id="id397" class="indexterm"></a> rendering system can be multithreaded, depending on the targeted platform, which version of Unity we're running, and various settings, and this can affect how the graphics subsystem is being bottlenecked by the CPU, and slightly changes the definition of what being CPU-bound means.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec52"></a>Multithreaded rendering</h4></div></div></div><p>Multithreaded rendering was first introduced in Unity v3.5 in February 2012, and enabled by default on multicore systems that could handle the workload; at the time, this was only PC, Mac, and Xbox 360. Gradually, more devices were added to this list, and since Unity v5.0, all major <a id="id398" class="indexterm"></a>platforms now enable multithreaded rendering by default (and possibly some builds of Unity 4).</p><p>Mobile devices were also starting to feature more powerful CPUs that could support this feature. Android multithreaded rendering (introduced in Unity v4.3) can be enabled through a checkbox under <span class="strong"><strong>Platform Settings</strong></span> | <span class="strong"><strong>Other Settings</strong></span> | <span class="strong"><strong>Multithreaded Rendering</strong></span>. Multithreaded rendering on iOS can be enabled by configuring the application to make use of the Apple Metal API (introduced in Unity v4.6.3), under <span class="strong"><strong>Player Settings</strong></span> | <span class="strong"><strong>Other Settings</strong></span> | <span class="strong"><strong>Graphics API</strong></span>.</p><p>When multithreaded rendering is enabled, tasks that must go through the rendering API (OpenGL, DirectX, or Metal), are handed over from the main thread to a "worker thread". The worker thread's purpose is to undertake the heavy workload that it takes to push rendering commands through the graphics API and driver, to get the rendering instructions into the GPU's Command Buffer. This can save an enormous number of CPU cycles for the main thread, where the overwhelming majority of other CPU tasks take place. This means that we free up extra cycles for the majority of the engine to process physics, script code, and so on.</p><p>Incidentally, the mechanism by which the main thread notifies the worker thread of tasks operates in a very similar way to the Command Buffer that exists on the GPU, except that the commands are much more high-level, with instructions like "render this object, with this Material, using this Shader", or "draw <span class="emphasis"><em>N</em></span> instances of this piece of procedural geometry", and so on. This feature has been exposed in Unity 5 to allow developers to take direct control of the rendering subsystem from C# code. This customization is not as powerful as having direct API access, but it is a step in the right direction for Unity developers to implement unique graphical effects.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note28"></a>Note</h3><p>Confusingly, the Unity API name for this feature is called "CommandBuffer", so be sure not to confuse it with the GPU's Command Buffer.</p></div><p>Check the Unity documentation <a id="id399" class="indexterm"></a>on CommandBuffer to make use of this feature: <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html" target="_blank">http://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html</a>.</p><p>Getting back to the task at hand, when we discuss the topic of being CPU-bound in graphics rendering, we need to keep in mind whether or not the multithreaded renderer is being used, since the actual root cause of the problem will be slightly different depending on whether this feature is enabled or not.</p><p>In single-threaded rendering, where all graphics API calls are handled by the main thread, and in an ideal<a id="id400" class="indexterm"></a> world where both components are running at maximum capacity, our application would become bottlenecked on the CPU when 50 percent or more of the time per frame is spent handling graphics API calls. However, resolving these bottlenecks can be accomplished by freeing up work from the main thread. For example, we might find that greatly reducing the amount of work taking place in our AI subsystem will improve our rendering significantly because we've freed up more CPU cycles to handle the graphics API calls.</p><p>But, when multithreaded rendering is taking place, this task is pushed onto the worker thread, which means the same thread isn't being asked to manage both engine work and graphics API calls at the same time. These processes are mostly independent, and even though additional work must still take place in the main thread to send instructions to the worker thread in the first place (via the internal CommandBuffer system), it is mostly negligible. This means that reducing the workload in the main thread will have little-to-no effect on rendering performance.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note29"></a>Note</h3><p>Note that being GPU-bound is the same regardless of whether multithreaded rendering is taking place.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec53"></a>GPU Skinning</h4></div></div></div><p>While we're on the subject of CPU-bounding, one task that can help reduce CPU workload, at the expense of additional <a id="id401" class="indexterm"></a>GPU workload, is GPU Skinning. <span class="strong"><strong>Skinning</strong></span> is the process where mesh vertices are transformed based on the current location of their animated bones. The<a id="id402" class="indexterm"></a> animation system, working on the CPU, only transforms the bones, but another step in the rendering process must take care of the vertex transformations to place the vertices around those bones, performing a weighted average over the bones connected to those vertices.</p><p>This vertex processing task can either take place on the CPU or within the front end of the GPU, depending on whether the <span class="strong"><strong>GPU Skinning</strong></span> option is enabled. This feature can be toggled under <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player Settings</strong></span> | <span class="strong"><strong>Other Settings</strong></span> | <span class="strong"><strong>GPU Skinning</strong></span>.</p></div></div></div>