<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>Disabling unused scripts and objects</h2></div></div><hr /></div><p>Scenes can get pretty busy sometimes, especially when we're building large, open worlds. The more objects invoking code in an <code class="literal">Update()</code> method, the worse things will scale and the slower your game<a id="id145" class="indexterm"></a> becomes. However, much of what is being processed may be completely unnecessary if it is outside of the player's view or simply too far away to matter. This may not be a possibility in large city-building simulation games where the entire simulation must be processed at all times, but it is often possible in first person and racing games, where the player is wandering around a large expansive area, where non-visible objects can be temporarily disabled without having any noticeable effect on gameplay.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec25"></a>Disabling objects by visibility</h3></div></div></div><p>Sometimes, we want <a id="id146" class="indexterm"></a>Components or GameObjects to be disabled when they're not visible. Unity comes with built-in rendering features to avoid rendering objects that are not visible by Cameras (<span class="strong"><strong>Frustum Culling</strong></span>, which is automatic in all versions), and to avoid rendering objects that are hidden behind other objects (<span class="strong"><strong>Occlusion Culling</strong></span>, to be discussed in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Dynamic Graphics</em></span>), but this does not affect Components that are non-renderable, such as AI scripts. We must control that behavior ourselves.</p><p>This problem can be solved easily by using the <code class="literal">OnBecameVisible()</code> and <code class="literal">OnBecameInvisible()</code> MonoBehaviour callbacks. As the names imply, these callback methods are invoked when a renderable object has become visible or invisible with respect to the game view and any Cameras in our Scene. In addition, when there are multiple Cameras in a Scene (for example, a local multiplayer game), the callbacks are only invoked if the object becomes visible to any <span class="emphasis"><em>one</em></span> Camera, and becomes invisible to <span class="emphasis"><em>all</em></span> Cameras. This means the aforementioned callbacks will be called at exactly the right times to implement this feature.</p><p>Since the visibility callbacks relate to and communicate with the rendering system, the GameObject must have a renderable object attached, such as a Mesh or SkinnedMesh. We must ensure that the Components we want to receive the visibility callbacks from are attached to the same GameObject as the renderable object and not some parent or sub-object, otherwise they won't be invoked.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Tip</h3><p>Note that Unity also counts the hidden camera of the Scene View towards the <code class="literal">OnBecameVisible()</code> and <code class="literal">OnBecameInvisible()</code> callbacks. If we find that these methods are not being invoked properly during Play Mode testing, make sure to turn the Scene View Camera away from everything.</p></div><p>To enable/disable individual<a id="id147" class="indexterm"></a> components with the visibility callbacks, we can add the following methods:</p><div class="informalexample"><pre class="programlisting">void OnBecameVisible() { enabled = true; }
void OnBecameInvisible() { enabled = false; }</pre></div><p>And, to enable/disable the entire GameObject the Component is attached to, we can implement the methods this way instead:</p><div class="informalexample"><pre class="programlisting">void OnBecameVisible() { gameObject.SetActive(true); }
void OnBecameInvisible() { gameObject.SetActive(false); }</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec26"></a>Disabling objects by distance</h3></div></div></div><p>In other situations, we <a id="id148" class="indexterm"></a>want Components or GameObjects to be disabled after they are far enough away from the player, such that they may be barely visible, but too far away to matter. A good candidate for this type of activity is roaming AI creatures that we want to see at a distance, but where we don't need it to process anything.</p><p>The following code is a simple Coroutine that periodically checks the total distance from the target object and disables itself if it strays too far away from it:</p><div class="informalexample"><pre class="programlisting">[SerializeField] GameObject _target;
[SerializeField] float _maxDistance;
[SerializeField] int _coroutineFrequency;

void Start() {
  StartCoroutine(DisableAtADistance());
}

IEnumerator DisableAtADistance() {
  while(true) {
    float distSqrd = (Transform.position - _target.transform.position).sqrMagnitude;

    if (distSqrd &lt; _maxDistance * _maxDistance) {
      enabled = true;
    } else {
      enabled = false;
    }

    for (int i = 0; i &lt; _coroutineFrequency; ++i) {
      yield return new WaitForEndOfFrame();
    }
  }
}</pre></div><p>We should assign the Player object (or whatever object we want it to compare with) to the <code class="literal">_target</code> field in the Inspector, define the maximum distance in <code class="literal">_maxDistance</code>, and modify the frequency with which the Coroutine is invoked by using the <code class="literal">_coroutineFrequency</code> property. Any time the object<a id="id149" class="indexterm"></a> goes further than <code class="literal">_maxDistance</code> distance away from the object assigned to <code class="literal">_target</code>, it will be disabled. It will be re-enabled if it returns within that distance.</p><p>A subtle performance-enhancing feature of this implementation is comparing against distance-squared instead of the raw distance. This leads us conveniently to our next tip.</p></div></div>