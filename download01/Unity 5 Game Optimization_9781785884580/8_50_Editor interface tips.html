<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec49"></a>Editor interface tips</h2></div></div><hr /></div><p>The following <a id="id630" class="indexterm"></a>collection of tips relates to<a id="id631" class="indexterm"></a> the Editor and its interface controls.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec112"></a>General</h3></div></div></div><p>We can prioritize which Scripts will have their Update and Fixed Update methods called before others, by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Script Execution Order</strong></span>. With the exception of some time-sensitive systems, such as audio processing, if we find ourselves trying to solve complex <a id="id632" class="indexterm"></a>problems using this feature, it implies that we've got some fragile and tight coupling between our Components. From a software design perspective, this can be a warning sign that we might need to approach the problem from another angle. However, it can be helpful to have particular objects get their <code class="literal">Update()</code> and <code class="literal">LateUpdate()</code> functions called before other objects, in order to do some bookkeeping.</p><p>Integrating Unity projects with a Source Control solution can be a little tricky. The first step is to force the project to generate <code class="literal">.meta</code> files for assets; if we don't do this, then anyone pulling data into their local Unity project must regenerate their own metadata files. This can easily cause conflicts, so it is essential that everyone uses the same versions. Visible metadata files can be enabled by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Editor</strong></span> | <span class="strong"><strong>Version Control</strong></span> | <span class="strong"><strong>Mode</strong></span> | <span class="strong"><strong>Visible Meta Files</strong></span>. All of the <code class="literal">.meta</code> files will now be visible within the file structure and available for upload into Source Control.</p><p>It can also be helpful to convert certain asset data into a Text-only format, rather than binary data, to allow manual editing of data files. This turns many data files into the much more human-readable YAML format. For instance, if we're using <code class="literal">ScriptableObjects</code> to store custom data, we can use a text editor to search and edit these files without having to do it all through the Unity Editor and serialization system. This can save a lot of time, especially when hunting for a particular data value or when multiediting across different derived types. This option can be enabled by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Editor</strong></span> | <span class="strong"><strong>Asset Serialization</strong></span> | <span class="strong"><strong>Mode</strong></span> | <span class="strong"><strong>Force Text</strong></span>.</p><p>The Editor has a log file, which can be accessed by opening the Console window (where log messages are printed out to), clicking on the "hamburger icon" (made from three horizontal lines) at the top-right, and selecting <span class="strong"><strong>Open Editor Log</strong></span>. If we recently built our project, it will contain a breakdown of compressed file sizes of all assets that were packed into the executable and ordered by size. This is an extremely helpful way of figuring out which assets are consuming the majority of our application footprint (hint: it's almost always Texture files), and which files are taking up more space than we would expect.</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_08_01.jpg" /></div><p>Additional windows <a id="id633" class="indexterm"></a>can be added to the Editor by right-clicking on the title of an existing window and selecting <span class="strong"><strong>Add Tab</strong></span>. This also allows us to add <span class="emphasis"><em>duplicate</em></span> windows, such as having more than one <span class="strong"><strong>Inspector</strong></span> View open at a time:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_08_02.jpg" /></div><p>Having duplicate views can be kind of redundant, unless we use the "lock icon" to lock the given view to its current selection. When we select an object, all <span class="strong"><strong>Inspector</strong></span> Views will update to show the object's data, except for any locked <span class="strong"><strong>Inspector</strong></span> Views, which continue to show the data of the object they were locked to.</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_08_03.jpg" /></div><p>Common tricks that make use<a id="id634" class="indexterm"></a> of window locking include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Using two of the same View (<span class="strong"><strong>Inspector</strong></span>, <span class="strong"><strong>Animation</strong></span>, and so forth) to compare two objects side-by-side or easily copy data from one to another</p></li><li style="list-style-type: disc"><p>Using a duplicate <span class="strong"><strong>Project</strong></span> View to move large data sets around</p></li><li style="list-style-type: disc"><p>Testing what happens to any dependent objects if an object is tweaked during runtime</p></li><li style="list-style-type: disc"><p>Selecting multiple objects in the <span class="strong"><strong>Project</strong></span> View, then dragging-and-dropping them into a serialized array in the <span class="strong"><strong>Inspector</strong></span> View without losing the original selection</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec113"></a>The Inspector View</h3></div></div></div><p>We can enter calculations into <a id="id635" class="indexterm"></a>numeric inspector fields. For example, typing <code class="literal">4*128</code> into an <code class="literal">int</code> field will resolve the value to <code class="literal">512</code>, sparing us from having to pull out a calculator or do the math in our head.</p><p>Array elements can be duplicated and deleted from a list (in the same fashion as the hotkeys mentioned previously) by right-clicking on the root element and selecting <span class="strong"><strong>Duplicate Array Element</strong></span> or <span class="strong"><strong>Delete Array Element</strong></span>.</p><p>A Component's context menu can be accessed through both the small cog icon in the upper-right or by right-clicking on the name of the Component. Every Component's context menu contains a <span class="strong"><strong>Reset</strong></span> option, which resets all values back to their default, sparing us from having to reset values manually. This is useful when working with Transform Components, as this option will set the object's position and rotation to <code class="literal">(0,0,0)</code> and its scale to <code class="literal">(1,1,1)</code>.</p><p>It's commonly known that, if a GameObject was spawned from a Prefab, then the entire object can be reverted back to its initial Prefab state using the <span class="strong"><strong>Revert</strong></span> button at the top of the <span class="strong"><strong>Inspector</strong></span> View. However, it's less well known that individual values can be reverted by right-clicking on the name of the value and selecting <span class="strong"><strong>Revert Value to Prefab</strong></span>. This restores the selected value, leaving the rest untouched.</p><p>The <span class="strong"><strong>Inspector</strong></span> View has a debug mode that can be accessed by clicking on the hamburger icon next to the lock icon and selecting <span class="strong"><strong>Debug</strong></span>. This will disable all custom Inspector drawing and reveal all raw data within the given GameObject and its components, even private data fields. Private fields are grayed-out and cannot be modified through the <span class="strong"><strong>Inspector</strong></span> View, but this gives us a useful way of examining private data and other hidden values during Play Mode. The <span class="strong"><strong>Debug</strong></span> view also reveals internal ObjectIDs, which can be useful if we're doing "interesting" things with Unity's serialization system and want to resolve conflicts.</p><p>If we have an array of data<a id="id636" class="indexterm"></a> elements serialized in the <span class="strong"><strong>Inspector</strong></span> View, then they are typically labeled <code class="literal">Element &lt;N&gt;</code> where <code class="literal">&lt;N&gt;</code> is the array index. This can make it tricky to find a specific element if our array elements are a series of serialized classes or structs, which tend to have multiple children themselves. However, if the <span class="emphasis"><em>very first field</em></span> in the object is a string, then the elements will be named after the value of the string field.</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_08_04.jpg" /></div><p>When a mesh object is selected, the <span class="strong"><strong>Preview</strong></span> window at the bottom of the <span class="strong"><strong>Inspector</strong></span> View is often fairly small, making it hard to see details in the mesh and how it will look when it appears in our Scene. But, if we right-click on the top bar of the <span class="strong"><strong>Preview</strong></span> window, it will be detached and enlarged, making it much easier to see our mesh. We don't have to worry about setting the detached window back to its original home because, if the detached window is closed, then the <span class="strong"><strong>Preview</strong></span> window will return to the bottom of the <span class="strong"><strong>Inspector</strong></span> View.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec114"></a>The Project View</h3></div></div></div><p>The <span class="strong"><strong>Project</strong></span> View's search bar <a id="id637" class="indexterm"></a>allows us to filter for objects of a particular type by clicking on the small icon to the right of the search bar. This provides a list of different types we can filter by, revealing all objects of that type within the entire project. However, selecting these options simply fills the search bar with a string of the <code class="literal">t:&lt;type&gt;</code> format, which applies the appropriate filter.</p><p>Thus, we can simply type the equivalent strings into the search bar for the sake of speed. For instance, typing <code class="literal">t:prefab</code> will filter for all Prefabs, no matter where they can be found in the hierarchy; <code class="literal">t:texture</code> will reveal textures, <code class="literal">t:scene</code> will reveal Scenes, and so on. Adding multiple search filters in the search bar will include objects of all types (it does not reveal objects which only satisfy both filters). These filters are modifiers in addition to name-based filtering, so adding a plain text string will cause a name-based search through the filtered objects. For example, <code class="literal">t:texture normalmap</code> will find all texture files that include the word <code class="literal">normalmap</code> in their name.</p><p>If we're making use of <code class="literal">AssetBundles</code> and the built-in labeling system, the <span class="strong"><strong>Project</strong></span> View's search bar also allows<a id="id638" class="indexterm"></a> us to hunt down bundled objects by their label using <code class="literal">l:&lt;label type&gt;</code>.</p><p>If a <code class="literal">MonoBehaviour</code> script contains serialized references (using <code class="literal">[SerializeField]</code> or <code class="literal">public</code>) to Unity Assets, such as Meshes and Textures, then we can assign default values directly into the script itself. Select the script file in the <span class="strong"><strong>Project</strong></span> View and the <span class="strong"><strong>Inspector</strong></span> View should contain a field for the asset for us to drag-and-drop the default assignment into.</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_08_05.jpg" /></div><p>By default, the <span class="strong"><strong>Project</strong></span> View splits files and folders into two columns and treats them separately. If we prefer the <span class="strong"><strong>Project</strong></span> View to have a typical hierarchy folder and file structure, then we can set it to <span class="strong"><strong>One Column Layout</strong></span> in its context menu (the hamburger icon at the top right). This can be a great space saver in some Editor layouts.</p><p>Right-clicking on any object in the <span class="strong"><strong>Project</strong></span> View and selecting <span class="strong"><strong>Select Dependencies</strong></span> will reveal all objects upon which<a id="id639" class="indexterm"></a> this asset relies in order to exist, such as Textures, Meshes, <code class="literal">MonoBehaviour</code> script files, and so on. For Scene files, it will list all entities referenced within that Scene. This is helpful if we're trying to perform some asset cleanup.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec115"></a>The Hierarchy View</h3></div></div></div><p>A lesser-known feature of the<a id="id640" class="indexterm"></a> <span class="strong"><strong>Hierarchy</strong></span> View is the ability to perform component-based filtering within the currently active Scene. Confusingly, it uses the same syntax as performing type-based filtering in the <span class="strong"><strong>Project</strong></span> View and can therefore be accomplished by typing <code class="literal">t:&lt;component name&gt;</code>. For example, typing <code class="literal">t:light</code> into the <span class="strong"><strong>Hierarchy</strong></span> View search bar will reveal all objects in the Scene that contain a Light component.</p><p>Upper- or lower-case characters are unimportant, but the string must match the full component name in order for the search to complete. Components that derive from the given type will also be revealed, so typing <code class="literal">t:renderer</code> will reveal all objects with derived components such as Mesh Renderers, Skinned Mesh Renderers, and so on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec116"></a>The Scene and Game Views</h3></div></div></div><p>The Scene View camera is not visible from the Game View, but it is generally a lot easier to move around and place through the<a id="id641" class="indexterm"></a> use of the hotkeys mentioned previously. The Editor allows us to align the selected object to the same position and rotation of the Scene camera<a id="id642" class="indexterm"></a> by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Align with View</strong></span> (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>F</em></span> / Cmd + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>F</em></span>). This means that we can use the camera controls to place the Scene camera where we would like our object to be, and place the object there by aligning it to the camera.</p><p>Similarly, we can align the Scene view to the selected object by navigating to the <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Align View to Selected</strong></span> option. This is useful for checking if the given object is pointing in the right direction.</p><p>We can perform similar component-based filtering on the Scene View, as we can with the <span class="strong"><strong>Hierarchy</strong></span> View, using the <code class="literal">t:&lt;component&gt;</code> syntax within its search bar.</p><p>At the very top right of the Unity Editor is a drop down labeled <span class="strong"><strong>Layers</strong></span>. This contains a Layer-based filtering and locking system for the Scene View. Toggling on the "eye" icon will show/hide all objects of that Layer within the Scene View. Toggling the lock icon will allow or prevent objects of the given layer from being selected. This is helpful for things such as preventing someone from accidentally selecting and moving background objects that have already<a id="id643" class="indexterm"></a> been situated in the perfect location.</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_08_06.jpg" /></div><p>A commonly known and useful <a id="id644" class="indexterm"></a>feature of the Editor is that GameObjects can be given special icons or labels to make them easier to find in the Scene View. This is particularly helpful for objects with no renderer but that we wish to find easily. For instance, objects such as Lights and Cameras have built-in icons that identify them in our Scene View more easily.</p><p>However, the same gizmos can be revealed within the <span class="strong"><strong>Game</strong></span> View by clicking on the <span class="strong"><strong>Gizmos</strong></span> button at the top right of the <span class="strong"><strong>Game</strong></span> View. The drop down for this option determines what gizmos will be visible when this option is enabled.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec117"></a>Play Mode</h3></div></div></div><p>Since Play Mode changes are <a id="id645" class="indexterm"></a>not automatically saved, it is wise to modify the tint color applied during Play Mode to make it blatantly obvious which mode we're current working with. This value can be set by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Preferences</strong></span> | <span class="strong"><strong>Colors</strong></span> | <span class="strong"><strong>Playmode tint</strong></span>.</p><p>Changes can be saved from Play Mode by simply using the clipboard. If we're tweaking an object in Play Mode and we're happy with its settings, then we can copy the object into the clipboard using <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> (Cmd + <span class="emphasis"><em>C</em></span>), and paste it back into the Scene once Play Mode ends with <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>V</em></span> (Cmd + <span class="emphasis"><em>V</em></span>). All settings on the object at the time of the copy will be kept. The same can be done with individual values or entire components using the <span class="strong"><strong>Copy Component</strong></span> and <span class="strong"><strong>Paste Component</strong></span> options in the component's context menu. However, the clipboard can only contain data for one object, component, <span class="emphasis"><em>or</em></span> value, at a time.</p><p>Another approach, which allows us to save the data of multiple objects during Play Mode, is to create Prefabs from them by dragging and dropping them into the <span class="strong"><strong>Project</strong></span> Window at runtime, once we're happy with the settings. If the original object was derived from a Prefab, and we wish to update it across all instances, then we only need to overwrite the old Prefab with the new one we created by dragging and dropping the copy on top of the original. Note that this also works during Play Mode runtime, but it can be dangerous since there is no dialog pop-up to confirm the overwrite. Be very careful not to overwrite the wrong Prefab.</p><p>We can use the <span class="strong"><strong>Frame Skip</strong></span> button (the button to the right of the Pause button in the Editor) to iterate one frame at a time. This can be useful for watching frame-by-frame physics or gameplay behavior. Keep in mind that this causes both one Fixed Update and one Update to be called each step, in equal counts, which may not exactly reflect actual runtime behavior where we<a id="id646" class="indexterm"></a> tend to have unequal calls to these methods.</p><p>If the Pause button is enabled when Play Mode begins, then the game will be paused just after the very first frame, giving us a chance to observe any anomalies that occurred from initialization of our Scene.</p></div></div>