<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec16"></a>Removing empty callback declarations</h2></div></div><hr /></div><p>When we<a id="id101" class="indexterm"></a> create new <code class="literal">MonoBehaviour</code> script files in Unity, whether we're using Unity 4 or Unity 5, it creates two boilerplate methods for us:</p><div class="informalexample"><pre class="programlisting">// Use this for initialization
void Start () {

}

// Update is called once per frame
void Update () {

}</pre></div><p>The Unity engine hooks in to these methods during initialization and adds them to a list of methods to call back at key moments. However, if we leave these as empty declarations in our codebase, then they will cost us a small overhead whenever the engine invokes them.</p><p>The <code class="literal">Start()</code> method is only called when the GameObject is instantiated for the first time, which can be whenever the scene is loaded or a new GameObject is instantiated from a Prefab. Therefore, leaving the empty <code class="literal">Start()</code> declaration may not be particularly noticeable unless there's a lot of GameObjects in the scene invoking them at startup time. However, it also adds unnecessary overhead to any <code class="literal">GameObject.Instantiate()</code> call, which typically happens <a id="id102" class="indexterm"></a>during key events, so they can potentially contribute to, and exacerbate, already poor performances situation when lots of events are happening simultaneously.</p><p>Meanwhile, the <code class="literal">Update()</code> method is called every time the scene is rendered. If our scene contains thousands of GameObjects owning components with these empty <code class="literal">Update()</code> declarations, then we can be wasting a lot of CPU cycles and causing havoc on our frame rate.</p><p>Let's prove this with a simple test. Our test scene should have GameObjects with two types of Component, one type with an empty <code class="literal">Update()</code> declaration, and another with no methods defined:</p><div class="informalexample"><pre class="programlisting">public class CallbackTestComponent : MonoBehaviour {
  void Update () {}
}

public class EmptyTestComponent : MonoBehaviour {
}</pre></div><p>Here are the test results for <code class="literal">32,768</code> Components of each type. If we enable all objects with no stub methods during runtime, then nothing interesting happens with CPU usage in the Profiler. We may notice some memory consumption changes and some slightly different VSync activity, but nothing very concerning. However, as soon as we enable all the objects with empty Unity callback declarations, we will observe a huge increase in CPU usage:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_02_05.jpg" /></div><p>The fix for this is simple; delete the empty declarations. Unity will have nothing to hook into, and nothing will be called. Sometimes, <span class="emphasis"><em>finding</em></span> such empty declarations in an expansive codebase can be difficult, but using some basic regular expressions (regex), we should be able to find what we're looking for relatively easily.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Tip</h3><p>All <a id="id103" class="indexterm"></a>common code-editing tools for Unity, such as MonoDevelop, Visual Studio, and even Notepad++, provide a way to perform a regex-based search on the entire codebase. Check the tool's documentation for more information, since the method can vary greatly depending on the tool and its version.</p></div><p>The following regex search should find any empty <code class="literal">Update()</code> declarations in our code:</p><div class="informalexample"><pre class="programlisting">void\s*Update\s*?\(\s*?\)\s*?\n*?\{\n*?\s*?\}</pre></div><p>This regex checks for a standard method definition of the <code class="literal">Update()</code> method, while including any surplus whitespace and newline characters that can be distributed throughout the method declaration.</p><p>Naturally, all of the above is also true for the non-boilerplate Unity callbacks, such as <code class="literal">OnGUI()</code>, <code class="literal">OnEnable()</code>, <code class="literal">OnDestroy()</code>, <code class="literal">FixedUpdate()</code>, and so on. Check the MonoBehaviour Unity<a id="id104" class="indexterm"></a> Documentation page for a complete list of these callbacks at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a>.</p><p>It might seem unlikely that someone generated empty versions of these callbacks in our codebase, but never say <span class="emphasis"><em>never</em></span>. For example, if we use a common base class MonoBehaviour throughout all of our custom components, then a single empty callback declaration in that base class will permeate the entire game, which can cost us dearly. Be particularly careful of the <code class="literal">OnGUI()</code> method, as it can be invoked multiple times within the same frame or user<a id="id105" class="indexterm"></a> interface (UI) event.</p></div>