<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec26"></a>Materials and Shaders</h2></div></div><hr /></div><p>
<span class="strong"><strong>Shaders</strong></span> are short programs which define how<a id="id186" class="indexterm"></a> the GPU should render incoming vertex and pixel data. A <a id="id187" class="indexterm"></a>Shader on its own does not have the necessary knowledge of state to accomplish anything of value. It requires inputs such as diffuse textures, normal maps, colors, and so on, and must decide what Render State variables are required in order to complete its intended task.</p><p>Unity's <span class="strong"><strong>Material</strong></span> system is essential to providing this information to our Shaders. Ultimately, this just <a id="id188" class="indexterm"></a>means a Shader is dependent upon a Material in order to be used to render an object. Every Shader needs a Material, and every Material must have a Shader. Even newly imported meshes that are introduced into the Scene without any assigned Materials are automatically assigned a default (hidden) Material, which gives them a basic diffuse Shader and a white coloration. So, there is no way of getting around this relationship.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>A single Material can only support a single Shader. The use of multiple Shaders on the same mesh requires separate Materials to be assigned to different parts of the same mesh.</p></div><p>These two systems <a id="id189" class="indexterm"></a>capture the majority of the Render State variables we discussed in the previous section. As a result, if we can minimize the number of Materials being used to render the Scene, then we minimize the amount of Render State changes required, and hence reduce the amount of time the CPU spends preparing the GPU each frame.</p><p>Let's begin with a simple Scene in order to visualize the behavior of Materials and batching. But, before we start, we should disable several global options for rendering features to avoid distracting ourselves with advanced rendering features:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Quality</strong></span> and set <span class="strong"><strong>Shadows</strong></span> to <span class="strong"><strong>Disable Shadows</strong></span> (or select the default <span class="strong"><strong>Fastest</strong></span> quality level)</p></li><li style="list-style-type: disc"><p>Navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span>, open the <span class="strong"><strong>Other Settings</strong></span> tab, and disable <span class="strong"><strong>Static Batching</strong></span>, <span class="strong"><strong>Dynamic Batching</strong></span>, and <span class="strong"><strong>GPU Skinning</strong></span> if they are enabled</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Tip</h3><p>The <span class="strong"><strong>Static Batching</strong></span> and <span class="strong"><strong>GPU Skinning</strong></span> options are not available in Unity 4 Free Edition, and require an upgrade to Unity 4 Pro Edition.</p></div></li></ul></div><p>Next, we'll create a Scene that contains a single Directional Light and eight meshes; four cubes, and four spheres, where each object has its own unique Material, position, rotation, and scale:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_03_01.jpg" /></div><p>If we observe the <span class="strong"><strong>Batching</strong></span> value in the <span class="strong"><strong>GameView's</strong></span> <span class="strong"><strong>Stats</strong></span> popup, we see nine total batches (note that this value will be labeled <span class="strong"><strong>Draw Calls</strong></span> in the Unity 4 <span class="strong"><strong>Stats</strong></span> popup). Unless the Camera's <span class="strong"><strong>Clear Flags</strong></span> setting is set to <span class="strong"><strong>Don't Clear</strong></span>, then one batch will be consumed <a id="id190" class="indexterm"></a>drawing the Camera background. This could be the Scene's Skybox or a<a id="id191" class="indexterm"></a> single quad that fills the screen with all pixels colored as per the Camera's <span class="strong"><strong>Background</strong></span> color property.</p><p>The next eight batches are used to draw our eight objects. In each case, the Draw Call involves preparing the rendering system using the Material's properties and asking the GPU to render the given mesh at its current position, rotation, and scale. The Material also defines which Shader is used, which controls the programmable parts of the graphics pipeline (vertex and fragment steps).</p><p>Note that if the Rendering Path setting under the <span class="strong"><strong>Player</strong></span> Settings is set to <span class="strong"><strong>Forward</strong></span>, then we can enable and disable the Directional Light in our Scene and the number of batches remains at nine. The first Directional Light in <span class="strong"><strong>Forward</strong></span> rendering is effectively free at least in terms of Draw Calls. As soon as we add more Lights to our Scene, whether they are Directional, Point, Spot, or Area Lights, we cause all objects to be rendered with an additional "pass" through the Shader for each Light, up to the value of the <span class="strong"><strong>Pixel Light Count</strong></span> value under the <span class="strong"><strong>Quality</strong></span> Settings (lights with high brightness values are prioritized first).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"></a>Note</h3><p>Lighting options can become a significant source of Draw Calls, and you will learn more about this system in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Dynamic Graphics</em></span>.</p></div><p>As previously <a id="id192" class="indexterm"></a>mentioned, we can theoretically minimize the number of Draw Calls by<a id="id193" class="indexterm"></a> reducing how often we cause the system to change Render State information. So, part of the goal therefore is to reduce the amount of Materials we use. But, if we set all objects to use the same Material, we don't see any benefit and the number of batches remains at nine:</p><div class="mediaobject"><img src="/graphics/9781785884580/graphics/4939_03_02.jpg" /></div><p>This is because we're not actually reducing the number of Render State changes nor efficiently grouping mesh information. Without any form of batching, the rendering system is not smart enough to realize we're overwriting the exact same Render State values, and then asking it to render the same meshes, over and over again. This presents an opportunity to have the rendering process recognize these situations, render all of these meshes together as one object, and avoid unnecessary Draw Calls. This is basically how Dynamic Batching works to reduce our Draw Calls.</p></div>