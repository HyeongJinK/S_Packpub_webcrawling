<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec23"></a>Faster GameObject null reference checks</h2></div></div><hr /></div><p>It turns out that<a id="id174" class="indexterm"></a> performing a <code class="literal">null</code> reference check against a Unity object invokes a method on the other side of the native-managed bridge (mentioned earlier and explored in more detail in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>), which, as expected, results in some unnecessary performance overhead:</p><div class="informalexample"><pre class="programlisting">if (gameObject != null) {
  // do stuff with gameObject
}</pre></div><p>There is a simple alternative that generates a functionally equivalent output, but operates around twice as quickly (although it does obfuscate the purpose of the code a little):</p><div class="informalexample"><pre class="programlisting">if (!System.Object.ReferenceEquals(gameObject, null)) {
  // do stuff with gameObject
}</pre></div><p>This applies to both GameObjects and Components, as well as other Unity objects, which have both native and managed representations. However, some rudimentary testing reveals that either approach still consumes mere nanoseconds on an Intel Core i5 3570K processor. So, unless you are performing massive amounts of <code class="literal">null</code> reference checks, then the gains might be marginal at best.</p><p>However, it is noteworthy in the sense that there can be many other simple alternatives that have yet to be discovered, which can help improve performance by circumventing the native-managed bridge.</p></div>