<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec41"></a>Using crowds</h2></div></div><hr /></div><p>Crowd <a id="id211" class="indexterm"></a>simulations are far less cut and dry. There really isn't any one way to implement them in a general sense. While not a strict restriction, the term generally refers to simulating crowds of humanoid agents navigating an area while avoiding each other and the environment. Like flocks, the use of crowd simulations has been widely used in films. For example, the epic armies battling one another in <span class="emphasis"><em>Lord of the Rings</em></span> were completely procedurally generated using the crowd simulation software Massive, which was created for using it in the film. While the use of crowd algorithms is not as widespread in video games as in films, certain genres rely on the concept more than others. Real-time strategy games often involve armies of characters, moving in unison across the screen.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec45"></a>Implementing a simple crowd simulation</h3></div></div></div><p>Our implementation <a id="id212" class="indexterm"></a>will be quick, simple, and effective, and it will focus on using Unity's NavMesh feature. Thankfully, NavMesh will handle much of the heavy lifting for us. Our scene has a simple walking surface with a NavMesh baked onto it, a couple of targets, and two teams of capsules, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_11.jpg" /><div class="caption"><p>The classic scenario: red versus blue</p></div></div><p>In the previous screenshot, we can see that our red and blue targets are opposite to their teamsâ€”red and blue, respectively. The setup is straightforward. Each capsule has a <code class="literal">CrowdAgent.cs</code> component attached to it, and when you hit play, each agent will head towards their target while avoiding each other and the oncoming capsules from the opposite team. Once they reach their destination, they will gather around the target.</p><p>While the game is running, you can even select a single capsule or a group of them in the editor to see their behavior visualized. As long as you have the navigation window active, you'll be able to see some debugging information about your NavMesh and the agents on it, as you can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_12.jpg" /></div><p>It's worth checking <a id="id213" class="indexterm"></a>this out in the editor to really get an idea of how this looks in motion, but we've labeled a few key elements in the preceding screenshot:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>1</strong></span>: This is the destination arrow that points toward the <code class="literal">NavMeshAgent</code> destination, which for this little guy is <code class="literal">RedTarget</code>. All this arrow cares about is where the destination is, regardless of the direction the agent is facing or moving toward.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>2</strong></span>: This arrow is the heading arrow. It shows the actual direction the agent is moving in. The direction of the agent takes into account several factors, including the position of its neighbors, space on the NavMesh, and the destination.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>3</strong></span>: This debug menu allows you to show a few different things. In our case, we enabled <span class="strong"><strong>Show Avoidance</strong></span> and <span class="strong"><strong>Show Neighbours</strong></span>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>4</strong></span>: Speaking of avoidance, this cluster of squares, ranging from dark to light and floating over the agents, represents the areas to avoid between our agent and the destination. The darker squares indicate areas that are densely populated by other agents or blocked by the environment, while the lighter-white squares <a id="id214" class="indexterm"></a>indicate areas that are safe to walk through. Of course, this is a dynamic display, so watch it change as you play in the editor.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec46"></a>Using the CrowdAgent component</h3></div></div></div><p>The <a id="id215" class="indexterm"></a>
<code class="literal">CrowdAgent</code> component is incredibly <a id="id216" class="indexterm"></a>simple, but gets the job done. As mentioned earlier, Unity does most of the heavy lifting for us. The following code gives our <code class="literal">CrowdAgent</code> a destination:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

[RequireComponent(typeof(NavMeshAgent))]
public class CrowdAgent : MonoBehaviour {
       
    public Transform target;

    private NavMeshAgent agent;

   void Start () {
        agent = GetComponent&lt;NavMeshAgent&gt;();
        agent.speed = Random.Range(4.0f, 5.0f);
        agent.SetDestination(target.position);
   }
}</pre></div><p>The script requires a component of type <code class="literal">NavMeshAgent</code>, which it assigns to the <code class="literal">agent</code> variable on <code class="literal">Start()</code>. We then set its speed randomly between two values for some added effect. Lastly, we set its destination to be the position of the target marker. The target marker is assigned via the inspector, as you can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_13.jpg" /></div><p>The preceding <a id="id217" class="indexterm"></a>screenshot illustrates a red capsule as <a id="id218" class="indexterm"></a>it has <span class="strong"><strong>RedTarget (Transform)</strong></span> set as its <span class="strong"><strong>Target</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec47"></a>Adding some fun obstacles</h3></div></div></div><p>Without <a id="id219" class="indexterm"></a>having to do anything else in our code, we can make a few changes to our scene layout and enable a few components provided by Unity to dramatically alter the behavior of our agents. In our <code class="literal">CrowdsObstacles</code> scene, we've added a few walls to the environment, creating a maze-like layout for our red and blue teams of capsules to traverse, as you can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_14.jpg" /><div class="caption"><p>Let the game begin!</p></div></div><p>The fun part about this example is that because of the randomized speed of each agent, the results will <a id="id220" class="indexterm"></a>be totally different each time. As the agents move through the environment, they'll be blocked by teammates or opposing agents and will be forced to re-route and find the quickest route to their target. Of course, this concept is not new to us, as we saw <code class="literal">NavMeshAgent</code> avoiding obstacles in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Finding Your Way</em></span>, except that we have many, many more agents in this scenario. To add a bit more fun to the example, we've also added a simple up-down animation to one of the walls and a <code class="literal">NavMeshObstacle</code> component, which looks something like this:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_15.jpg" /><div class="caption"><p>Nav Mesh Obstacle looks a bit different in Unity 5</p></div></div><p>Note that our obstacle does not need to be set to <span class="strong"><strong>Static</strong></span> when we are using this component. Our obstacle is mostly box-like, so we leave the default <span class="strong"><strong>Shape</strong></span> setting as <span class="strong"><strong>Box</strong></span> (<span class="strong"><strong>Capsule</strong></span> is another choice). The <span class="strong"><strong>Size</strong></span> and <span class="strong"><strong>Center</strong></span> options let us move the outline of our shape around and resize it, but the default settings fit our shape perfectly, which is what we want, so let's <a id="id221" class="indexterm"></a>leave that alone. The next option <span class="strong"><strong>Carve</strong></span> is important. It essentially does exactly what it says; it carves a space out of the NavMesh, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_16.jpg" /><div class="caption"><p>The sane obstacle at two different points of its up-down animation</p></div></div><p>The left screenshot shows the space carved out when the obstacle is on the surface, while the NavMesh is connected in the right screenshot when the obstacle is raised off the surface. We can leave <span class="strong"><strong>Time to Stationary</strong></span> and <span class="strong"><strong>Move Threshold</strong></span> as they are, but we do want to make sure that <span class="strong"><strong>Carve Only Stationary</strong></span> is turned off. This is because our obstacle is moving, and if we didn't tick this box, it would not carve out the space from the NavMesh, and our agents would be trying to move through the obstacle whether it was up or down, which is not the behavior we are after in this case.</p><p>As the obstacle moves up and down and the mesh is carved out and reconnected, you'll notice the agents changing their heading. With the navigation debug options enabled, we can also see a very interesting visualization of everything going on with our agents at any given moment. It may seem a bit cruel to mess with our poor agents like this, but we're doing it for science!</p><p>The following <a id="id222" class="indexterm"></a>screenshot gives us a glimpse into the chaos and disorder we're subjecting our poor agents to:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_17.jpg" /><div class="caption"><p>I'm secretly rooting for the blue team</p></div></div></div></div>