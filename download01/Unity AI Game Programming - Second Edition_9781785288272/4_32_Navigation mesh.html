<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec35"></a>Navigation mesh</h2></div></div><hr /></div><p>Next, we'll learn <a id="id147" class="indexterm"></a>how to use Unity's built-in navigation mesh generator that can make pathfinding for AI agents a lot easier. As of Unity 5, NavMesh is available to all the users. Previously a Unity Pro-only feature, NavMesh is now a part of the Personal Edition of Unity. We were briefly exposed to Unity's NavMesh in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Finite State Machines and You</em></span>, which relied on a NavMesh agent for movement in testing our state machine. Now, we will finally dive in and explore all that this system has to offer. AI pathfinding needs representation of the scene in a particular format. We've seen that using a 2D grid (array) for A* Pathfinding on a 2D map. AI agents need to know where the obstacles are, especially the static obstacles. Dealing with collision avoidance between dynamically moving objects is another subject, primarily known as steering behaviors. Unity has a built-in navigation feature to generate a NavMesh that represents the scene in a context that makes sense for our AI agents to find the optimum path to the target. This chapter comes with a Unity project that has four scenes in it. You should open it in Unity and see how it works to get a feeling of what we are going to build. Using this sample project, we'll study how to create a NavMesh and use it with AI agents inside our own scenes.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec31"></a>Setting up the map</h3></div></div></div><p>To get started, we'll <a id="id148" class="indexterm"></a>build a simple scene, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_19.jpg" /><div class="caption"><p>A scene with obstacles</p></div></div><p>This is the first scene in our sample project called <code class="literal">NavMesh01-Simple.scene</code>. You can use a plane as a <a id="id149" class="indexterm"></a>ground object and several cube entities as the wall objects. Later, we'll put in some AI agents (we'll be turning to our trusted tank for this example as well) to go to the mouse-clicked position, as in an <span class="strong"><strong>RTS</strong></span> (<span class="strong"><strong>real-time strategy</strong></span>) game.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec32"></a>Navigation Static</h3></div></div></div><p>Once we've added the <a id="id150" class="indexterm"></a>walls and ground, it's important to mark them as <span class="strong"><strong>Navigation Static</strong></span> so that the NavMesh generator knows that these are the static obstacle objects to avoid. Only game objects marked as navigation static will be taken into account when building the NavMesh, so be sure to mark any environment elements accordingly. To do this, select all those objects, click on the <span class="strong"><strong>Static</strong></span> dropdown, and choose <span class="strong"><strong>Navigation Static</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_20.jpg" /><div class="caption"><p>The Navigation Static property</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec33"></a>Baking the navigation mesh</h3></div></div></div><p>Now we're done <a id="id151" class="indexterm"></a>with our scene. Let's bake the NavMesh. Firstly, we need to open the navigation window. Navigate to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Navigation</strong></span>. The navigation window is broken up into three different sections. The first, <span class="strong"><strong>Object</strong></span>, looks similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_21.jpg" /><div class="caption"><p>The navigation object window</p></div></div><p>The <span class="strong"><strong>Object</strong></span> tab of the navigation window is simply a shortcut to selecting objects and modifying their navigation-related attributes. Toggling between the <span class="strong"><strong>Scene Filter</strong></span> options, <span class="strong"><strong>All</strong></span>, <span class="strong"><strong>Mesh Renderers</strong></span>, and <span class="strong"><strong>Terrains</strong></span>, will filter out objects in your hierarchy accordingly so that you can easily select objects and change their <span class="strong"><strong>Navigation Static</strong></span> and <span class="strong"><strong>Generate OffMeshLinks</strong></span> flags as well as set their <span class="strong"><strong>Navigation Area</strong></span>.</p><p>The second tab is the <span class="strong"><strong>Bake</strong></span> tab. It looks similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_22.jpg" /></div><p>If you've ever stumbled <a id="id152" class="indexterm"></a>across this tab prior to Unity 5, you may notice that it now looks a bit different. Unity 5 added a visualizer to see exactly what each setting does. Let's take a look at what each of these settings does:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Agent Radius</strong></span>: The Unity documentation describes it best as the NavMesh agent's "personal space". The agent will use this radius when it needs to avoid other objects.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Agent Height</strong></span>: This is similar to radius, except for the fact that it designates the height of the agent that determines if it can pass under obstacles, and so on.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Max Slope</strong></span>: This is the max angle that the agent can walk up to. The agent will not be able to walk up the slopes that are steeper than this value.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Step Height</strong></span>: Agents can step or climb over obstacles of this value or less.</p></li></ul></div><p>The second category of values only applies when you checked <span class="strong"><strong>Generate OffMeshLinks</strong></span> when building your NavMesh. This simply means that the agent will be able to potentially navigate the NavMesh even when gaps are present due to physical distance:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Drop Height</strong></span>: Fairly straightforward, this is the distance an agent can jump down. For example, the height of a cliff from which an agent will be "brave enough" to jump down.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Jump Distance</strong></span>: This is the distance an agent will jump between offmesh links.</p></li></ul></div><p>The third and final set of parameters is not the one that you would generally need to change:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Manual Voxel Size</strong></span>: Unity's NavMesh implementation relies on voxels. This setting lets you increase the accuracy of the NavMesh generation. A lower number is more accurate, while a larger number is less accurate, but faster.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Min Region Area</strong></span>: Areas smaller than this will simply be culled away, and ignored.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Height Mesh</strong></span>: It gives you a higher level of detail in vertical placement of your agent at the cost of speed at runtime.</p></li></ul></div><p>The third and last tab is the <a id="id153" class="indexterm"></a>
<span class="strong"><strong>Areas</strong></span> tab, which looks similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_23.jpg" /></div><p>If you recall, the <span class="strong"><strong>Object</strong></span> tab allows you to assign the specific objects to certain areas, for example, grass, sand, water, and so on. You can then assign an area mask to an agent, which allows you to pick areas agents can or cannot walk through. The cost parameter affects the likeliness of an agent to attempt to traverse that area. Agents will prefer lower-cost paths when possible.</p><p>We will keep our example simple, but feel free to experiment with the various settings. For now, we'll leave the default values and just click on <span class="strong"><strong>Bake</strong></span> at the bottom of the window. You should see a progress bar baking the NavMesh for your scene, and after a while, you'll see your <a id="id154" class="indexterm"></a>NavMesh in your scene, as shown in following diagram:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_24.jpg" /><div class="caption"><p>The navigation mesh baked</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec34"></a>Using the NavMesh agent</h3></div></div></div><p>We're pretty much <a id="id155" class="indexterm"></a>done with setting up our super simple scene. Now, let's add some AI agents to see if it works. We'll use our tank model here, but if you're working with your own scene and don't have this model, you can just put a cube or a sphere entity as an agent. It'll work the same way.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_25.jpg" /><div class="caption"><p>The tank entity</p></div></div><p>The next step is to add the <span class="strong"><strong>NavMesh Agent</strong></span> component to our tank entity. This component makes pathfinding really easy. We don't need to deal with pathfinding algorithms directly anymore as Unity handles this for us in the background. By just setting the <code class="literal">destination</code> property of the component during runtime, our AI agent will automatically find the path itself.</p><p>Navigate to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Navigation</strong></span> | <span class="strong"><strong>Nav Mesh Agent</strong></span> to add this component.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_26.jpg" /><div class="caption"><p>The Nav Mesh Agent properties</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note03"></a>Note</h3><p>Unity <a id="id156" class="indexterm"></a>reference for the <span class="strong"><strong>NavMesh Agent</strong></span> component can be found at <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/class-NavMeshAgent.html" target="_blank">http://docs.unity3d.com/Documentation/Components/class-NavMeshAgent.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec35"></a>Setting a destination</h3></div></div></div><p>Now that we've set <a id="id157" class="indexterm"></a>up our AI agent, we need a way to tell this agent where to go and update the destination of our tanks to the mouse-click position.</p><p>So, let's add a sphere entity to be used as a marker object and then attach the following <code class="literal">Target.cs</code> script to an empty game object. Drag-and-drop this sphere entity onto this script's <code class="literal">targetMarker</code> transform property in the inspector.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec36"></a>The Target class</h3></div></div></div><p>This is a simple <a id="id158" class="indexterm"></a>class that does three things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Gets the mouse-click position using a ray</p></li><li style="list-style-type: disc"><p>Updates the marker position</p></li><li style="list-style-type: disc"><p>Updates the destination property of all the NavMesh agents</p></li></ul></div><p>The following <a id="id159" class="indexterm"></a>lines show the code present in this class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Target : MonoBehaviour {
  private NavMeshAgent[] navAgents;
  public Transform targetMarker;

  void Start() {
    navAgents = FindObjectsOfType(typeof(NavMeshAgent)) as 
        NavMeshAgent[];
  }

  void UpdateTargets(Vector3 targetPosition) {
    foreach (NavMeshAgent agent in navAgents) {
      agent.destination = targetPosition;
    }
  }

  void Update() {
    int button = 0;

    //Get the point of the hit position when the mouse is 
    //being clicked
    if(Input.GetMouseButtonDown(button)) {
      Ray ray = Camera.main.ScreenPointToRay(
          Input.mousePosition);

      RaycastHit hitInfo;

      if (Physics.Raycast(ray.origin, ray.direction, 
          out hitInfo)) {
        Vector3 targetPosition = hitInfo.point;
        UpdateTargets(targetPosition);
        targetMarker.position = targetPosition + 
            new Vector3(0,5,0);
      }
    }
  }
}</pre></div><p>At the start of the game, we look for all the <code class="literal">NavMeshAgent</code> type entities in our game and store them in our reference <code class="literal">NavMeshAgent</code> array. Whenever there's a mouse-click event, we do a simple raycast to determine the first objects that collide with our ray. If the ray hits any object, we update the position of our marker and update each NavMesh agent's destination by setting the destination property with the new position. We'll be using this script throughout this chapter to tell the destination position for our AI agents.</p><p>Now, test run the scene and <a id="id160" class="indexterm"></a>click on a point where you want your tanks to go. The tanks should come as <a id="id161" class="indexterm"></a>close as possible to that point while avoiding the static obstacles like walls.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec37"></a>Testing slopes</h3></div></div></div><p>Let's build a scene <a id="id162" class="indexterm"></a>with some slopes like this:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_27.jpg" /><div class="caption"><p>Scene with slopes</p></div></div><p>One important thing to note is that the slopes and the wall should be in contact with each other. Objects need to be perfectly connected when creating such joints in the scene with the purpose of generating a NavMesh later, otherwise, there'll be gaps in NavMesh and the agents will not be able to find the path anymore. For now, make sure to connect the slope properly.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_28.jpg" /><div class="caption"><p>A well-connected slope</p></div></div><p>Next, we can adjust the <code class="literal">Max Slope</code> property in the <span class="strong"><strong>Navigation</strong></span> window's <span class="strong"><strong>Bake</strong></span> tab according to the level of slope in our scenes that we want to allow agents to travel. We'll use <code class="literal">45</code> degrees here. If your slopes are steeper than this, you can use a higher <code class="literal">Max Slope</code> value.</p><p>Bake the scene, and you <a id="id163" class="indexterm"></a>should have a NavMesh generated like this:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_29.jpg" /><div class="caption"><p>NavMesh generated</p></div></div><p>Next, we'll place some tanks with the <span class="strong"><strong>NavMesh Agent</strong></span> component. Create a new cube object to be used as a target reference position. We'll be using our previous <code class="literal">Target.cs</code> script to update <a id="id164" class="indexterm"></a>the destination property of our AI agent. Test run the scene, and you should have your AI agents crossing the slopes to reach the target.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec38"></a>Exploring areas</h3></div></div></div><p>In games with <a id="id165" class="indexterm"></a>complex environments, we usually have some areas that are harder to travel in than others, such as a pond or lake compared to crossing a bridge. Even though it could be the shortest path to target by crossing the pond directly, we would want our agents to choose the bridge as it makes more sense. In other words, we want to make crossing the pond to be more navigationally expensive than using the bridge. In this section, we'll look at NavMesh areas, a way to define different layers with different navigation cost values.</p><p>We're going to build a scene, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_30.jpg" /><div class="caption"><p>Scene with layers</p></div></div><p>There'll be three planes to represent two ground planes connected with a bridge-like structure and a water plane between them. As you can see, it's the shortest path for our tank to cross over the water plane to reach our cube target, but we want our AI agents to choose the bridge if possible and to cross the water plane only if absolutely necessary, such as when the target object is on the water plane.</p><p>The scene hierarchy can <a id="id166" class="indexterm"></a>be seen in the following screenshot. Our game level is composed of planes, slopes, and walls. We've a tank entity and a destination cube with the <code class="literal">Target.cs</code> script attached.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_31.jpg" /><div class="caption"><p>The Scene Hierarchy</p></div></div><p>As we saw earlier, NavMesh areas can be edited in the <span class="strong"><strong>Areas</strong></span> tab of the <span class="strong"><strong>Navigation</strong></span> window.</p><p>Unity comes with three default layers—<code class="literal">Default</code>, <code class="literal">Not Walkable</code>, and <code class="literal">Jump</code>—each with potentially different cost values. Let's add a new layer called <code class="literal">Water</code> and give it a cost of <code class="literal">5</code>.</p><p>Next, select the water plane. Go to the <span class="strong"><strong>Navigation</strong></span> window and under the <span class="strong"><strong>Object</strong></span> tab, set <span class="strong"><strong>Navigation Area</strong></span> to <span class="strong"><strong>Water</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_32.jpg" /><div class="caption"><p>The Water area</p></div></div><p>Bake the NavMesh for the scene and run it to test it. You should see that the AI agents now choose the slope rather than going through the plane marked as the water layer because it's <a id="id167" class="indexterm"></a>more expensive to choose this path. Try experimenting with placing the target object at different points in the water plane. You will see that the AI agents will sometimes swim back to the shore and take the bridge rather than trying to swim all the way across the water.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec39"></a>Making sense of Off Mesh Links</h3></div></div></div><p>Sometimes, there <a id="id168" class="indexterm"></a>could be some gaps inside the scene that can make the navigation meshes disconnected. For example, our agents will not be able to find the path if our slopes are not connected to the walls in our previous examples. Or, we could have set up points where our agents could jump off the wall and onto the plane below. Unity has a feature called <span class="strong"><strong>Off Mesh Links</strong></span> to connect such gaps. Off Mesh Links can either be set up manually or generated automatically by Unity's NavMesh generator.</p><p>Here's the example scene that we're going to build in this example. As you can see, there's a small gap between the <a id="id169" class="indexterm"></a>two planes. Let's see how to connect these two planes using Off Mesh Links.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_33.jpg" /><div class="caption"><p>Scene with Off Mesh Links</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec40"></a>Using the generated Off Mesh Links</h3></div></div></div><p>Firstly, we'll use the <a id="id170" class="indexterm"></a>autogenerated Off Mesh Links to connect the two planes. The first thing to do is to mark these two planes as the <span class="strong"><strong>Off Mesh Link Generation</strong></span> static in the property inspector, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_34.jpg" /><div class="caption"><p>Off Mesh Link Generation static</p></div></div><p>You can set the distance threshold to autogenerate Off Mesh Links in the <span class="strong"><strong>Bake</strong></span> tab of the <span class="strong"><strong>Navigation</strong></span> window as seen earlier.</p><p>Click on <span class="strong"><strong>Bake</strong></span>, and you should have Off Mesh Links connecting two planes like this:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_35.jpg" /><div class="caption"><p>Generated Off Mesh Links</p></div></div><p>Now our AI agents can <a id="id171" class="indexterm"></a>traverse and find the path across both planes. Agents will be essentially teleported to the other plane once they have reached the edge of the plane and found the Off Mesh Link. Unless having a teleporting agent is what you want, it might be a good idea to place a bridge to allow the agent to cross.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec41"></a>Setting the manual Off Mesh Links</h3></div></div></div><p>If we don't want to <a id="id172" class="indexterm"></a>generate Off Mesh Links along the edge, and want to force the agents to come to a certain point to be teleported to another plane, we can also manually set up the Off Mesh Links. Here's how:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_36.jpg" /><div class="caption"><p>The manual Off Mesh Links setup</p></div></div><p>This is our scene with a significant gap between two planes. We placed two pairs of sphere entities on both sides of the plane. Choose a sphere, and add an Off Mesh Link by navigating to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Navigation</strong></span> | <span class="strong"><strong>Off Mesh Link</strong></span>. We only need to add this component on <a id="id173" class="indexterm"></a>one sphere. Next, drag-and-drop the first sphere to the <span class="strong"><strong>Start</strong></span> property, and the other sphere to the <span class="strong"><strong>End</strong></span> property.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_37.jpg" /><div class="caption"><p>The Off Mesh Link component</p></div></div><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_38.jpg" /><div class="caption"><p>The manual Off Mesh Links generated</p></div></div><p>Go to the <span class="strong"><strong>Navigation</strong></span> window and bake the scene. The planes are now connected with the manual Off Mesh Links that can be used by AI agents to traverse even though there's a gap.</p></div></div>