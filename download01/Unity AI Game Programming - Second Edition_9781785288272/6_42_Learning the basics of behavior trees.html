<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec43"></a>Learning the basics of behavior trees</h2></div></div><hr /></div><p>It is called a <a id="id223" class="indexterm"></a>tree because it is a hierarchical, branching system of <a id="id224" class="indexterm"></a>nodes with a common parent, known as the root. As you've surely learned from reading this book, by now, behavior trees, too, mimic the real thing they are named afterâ€”in this case, trees. If we were to visualize a behavior tree, it would look something like the following figure:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_06_01.jpg" /><div class="caption"><p>A basic tree structure</p></div></div><p>Of course, behavior trees can be made up of any number of nodes and children nodes. The nodes at the very end of the hierarchy are referred to as leaf nodes, just like a tree. Nodes can represent behaviors or tests. Unlike state machines, which rely on transition rules to traverse through it, a BT's flow is defined strictly by each node's order within the larger hierarchy. A BT begins evaluating from the top (based on the preceding visualization) of the <a id="id225" class="indexterm"></a>tree, then continues through each child, which, in turn, runs through each of its children until a condition is met or the leaf node is reached. BTs always begin evaluating from the root node.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec48"></a>Understanding different node types</h3></div></div></div><p>The names of <a id="id226" class="indexterm"></a>the different types of nodes may vary depending on who you ask, and even nodes themselves are sometimes referred to as tasks. While the complexity of a tree is dependent entirely upon the needs of the AI, the high-level concepts about how BTs work are fairly easy to understand if we look at each component individually. The following is true for each node regardless of what type of node we're referring to. A <a id="id227" class="indexterm"></a>node will always return one of the <a id="id228" class="indexterm"></a>following states:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Success</strong></span>: The <a id="id229" class="indexterm"></a>condition the node was checking for has been met.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Failure</strong></span>: The <a id="id230" class="indexterm"></a>condition the node was checking for was not, and will not be met.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Running</strong></span>: The <a id="id231" class="indexterm"></a>validity of the condition the node is checking for has not been determined. Think of this as our "please wait" state.</p></li></ul></div><p>Due to the potential complexity of a BT, most implementations are asynchronous, which, at least for Unity, means that evaluating a tree will not block the game from continuing other operations. The evaluation process of the various nodes in a BT can take several frames, if necessary. If you had to evaluate several trees on any number of agents at a time, you can imagine how it would negatively affect the performance of the program to have to wait for each of them to <a id="id232" class="indexterm"></a>return a true or false to the root node. This is why the "running" state is important.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec12"></a>Defining composite nodes</h4></div></div></div><p>Composite <a id="id233" class="indexterm"></a>nodes are called so as they have one or more children. Their state is based entirely upon the result of evaluating its children, and while <a id="id234" class="indexterm"></a>its children are being evaluated, it will be in a "running" state. There are a couple of composite node types, which are mostly defined by how their children are evaluated:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Sequences</strong></span>: The defining characteristic of a sequence is that the entire sequence of <a id="id235" class="indexterm"></a>children needs to complete successfully <a id="id236" class="indexterm"></a>in order for it to evaluate as a success itself. If any of the children at any step of the sequence return false, the sequence itself will report a failure. It is important to note that, in general, sequences are executed from left to right. The following figures show a successful sequence and a failed sequence, respectively:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_06_02.jpg" /><div class="caption"><p>A successful sequence node</p></div></div><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_06_03.jpg" /><div class="caption"><p>An unsuccessful sequence node</p></div></div></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Selectors</strong></span>: By <a id="id237" class="indexterm"></a>comparison, selectors are much more forgiving parents to their children nodes. If any one of the children nodes in a selector sequence returns true, the selector says, "eh, good enough!" and returns true immediately, without evaluating any more of its children. The only way a selector node will return false is if all of its children are evaluated and none of them return a success.</p></li></ul></div><p>Of course, each <a id="id238" class="indexterm"></a>composite node type has its use depending on the <a id="id239" class="indexterm"></a>situation. You can think of the different types of sequence nodes as "and" and "or" conditionals.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec13"></a>Understanding decorator nodes</h4></div></div></div><p>The biggest <a id="id240" class="indexterm"></a>difference between a composite node <a id="id241" class="indexterm"></a>and a decorator node is that a decorator can have exactly one child and one child only. At first, this may seem unnecessary as you would, in theory, be able to get the same functionality by containing the condition in the node itself <a id="id242" class="indexterm"></a>rather than relying on its child, but the decorator node is special in that it essentially takes the state returned by the child and evaluates the response based on its own parameters. A decorator can even specify how its children are evaluated and how often they are. These are some common decorator types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Inverter</strong></span>: Think of the inverter as a NOT modifier. It takes the opposite of the state <a id="id243" class="indexterm"></a>returned by its child. For example, if the child returns TRUE, the decorator evaluates as FALSE, and vice versa. This is the equivalent of having the <code class="literal">!</code> operator in front of a Boolean in C#.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Repeater</strong></span>: This <a id="id244" class="indexterm"></a>repeats the evaluation of the child a specified (or infinite) number of times until it evaluates as either TRUE or FALSE as determined by the decorator. For example, you may want to wait indefinitely until a certain condition is met, such as "having enough energy" before <a id="id245" class="indexterm"></a>a character uses an attack.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Limiter</strong></span>: This simply limits the number of times a node will be evaluated to avoid getting an agent stuck in an awkward infinite behavior loop. This decorator, in <a id="id246" class="indexterm"></a>contrast to the repeater, can be used to make sure a character only tries to, for example, kick the door open so many times before giving up and trying something else.</p></li></ul></div><p>Some decorator nodes can be used for debugging and testing your trees. For example:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Fake state</strong></span>: This always evaluates true or false as specified by the decorator. This is very <a id="id247" class="indexterm"></a>helpful for asserting certain behavior in your agent. You can also have the decorator maintain a fake "running" state indefinitely to see how other agents around it will behave, for example.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Breakpoint</strong></span>: Just <a id="id248" class="indexterm"></a>like a breakpoint in code, you can have this node fire off logic to notify you via debug logs or other methods that the node has been reached.</p></li></ul></div><p>These types are not monolithic archetypes that are mutually exclusive. You can combine these types of nodes <a id="id249" class="indexterm"></a>to suit your needs. Just be careful not to <a id="id250" class="indexterm"></a>combine too much functionality into one decorator to the point where it may be more efficient or convenient to use a sequence node instead.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec14"></a>Describing the leaf node</h4></div></div></div><p>We briefly covered <a id="id251" class="indexterm"></a>leaf nodes earlier in the chapter to make a <a id="id252" class="indexterm"></a>point about the structure of a BT, but leaf nodes, in reality, can be <a id="id253" class="indexterm"></a>just about any sort of behavior. They are magical in the sense that they can be used to describe any sort of logic your agent can have. A leaf node can specify a walk function, shoot command, or kick action. It doesn't matter what it does or how you decide to have it evaluate its states, it just has to be the last node in its own hierarchy and return any of the three states a node can return.</p></div></div></div>