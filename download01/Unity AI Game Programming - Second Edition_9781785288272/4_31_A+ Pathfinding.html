<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec34"></a>A* Pathfinding</h2></div></div><hr /></div><p>Next up, we'll be <a id="id122" class="indexterm"></a>implementing the A* algorithm in a Unity environment using C#. The A* Pathfinding algorithm is widely used in games and interactive applications even though there are other algorithms, such as Dijkstra's algorithm, because of its simplicity and effectiveness. We've briefly covered this algorithm previously in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>The Basics of AI in Games</em></span>, but let's review the algorithm again from an implementation perspective.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec29"></a>Revisiting the A* algorithm</h3></div></div></div><p>Let's review the <a id="id123" class="indexterm"></a>A* algorithm again before we proceed to implement it in the next section. First, we'll <a id="id124" class="indexterm"></a>need to represent the map in a traversable data structure. While many structures are possible, for this example, we will use a 2D grid array. We'll implement the <code class="literal">GridManager</code> class later to handle this map information. Our <code class="literal">GridManager</code> class will keep a list of the <code class="literal">Node</code> objects that are basically titles in a 2D grid. So, we need to implement that <code class="literal">Node</code> class to handle things such as node type (whether it's a traversable node or an obstacle), cost to pass through and cost to reach the goal <code class="literal">Node</code>, and so on.</p><p>We'll have two variables to store the nodes that have been processed and the nodes that we have to process. We'll call them closed list and open list, respectively. We'll implement that list type in the <code class="literal">PriorityQueue</code> class. And then finally, the following A* algorithm will be implemented in the <code class="literal">AStar</code> class. Let's take a look at it:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We begin at the starting node and put it in the open list.</p></li><li><p>As long as the open list has some nodes in it, we'll perform the following processes:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Pick the first node from the open list and keep it as the current node. (This is assuming that we've sorted the open list and the first node has the least cost value, which will be mentioned at the end of the code.)</p></li><li><p>Get the neighboring nodes of this current node that are not obstacle types, such as a wall or canyon that can't be passed through.</p></li><li><p>For each neighbor node, check if this neighbor node is already in the closed list. If not, we'll calculate the total cost (<code class="literal">F</code>) for this neighbor node using the following formula: </p><div class="informalexample"><pre class="programlisting">F = G + H</pre></div></li><li><p>In the preceding formula, <code class="literal">G</code> is the total cost from the previous node to this node and <code class="literal">H</code> is the total cost from this node to the final target node.</p></li><li><p>Store this cost data in the neighbor node object. Also, store the current node as the parent node as well. Later, we'll use this parent node data to trace back the actual path.</p></li><li><p>Put this neighbor node in the open list. Sort the open list in ascending order, ordered by the total cost to reach the target node.</p></li><li><p>If there's no more neighbor nodes to process, put the current node in the closed list and remove it from the open list.</p></li><li><p>Go back to step 2.</p></li></ol></div></li></ol></div><p>Once you have completed <a id="id125" class="indexterm"></a>this process your current node should be in the target goal node position, but only if there's an obstacle free path to reach the goal node from the start node. If it is not at the goal node, there's no available path to the target node from the current node position. If there's a valid path, all we have to do now is to trace back from current node's parent node until we reach the start node again. This will give us a path list of all the nodes that we chose during our pathfinding process, ordered from the target node to the start node. We then just reverse this path list since we want to know the path from the start node to the target goal node.</p><p>This is a general overview of the algorithm we're going to implement in Unity using C#. So let's get started.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec30"></a>Implementation</h3></div></div></div><p>We'll implement the preliminary classes that were mentioned before, such as the <code class="literal">Node</code>, <code class="literal">GridManager</code>, and <code class="literal">PriorityQueue</code> classes. Then, we'll use them in our main <code class="literal">AStar</code> class.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec05"></a>Implementing the Node class</h4></div></div></div><p>The <code class="literal">Node</code> <a id="id126" class="indexterm"></a>class will handle each tile object in our 2D grid, representing the maps shown in the <code class="literal">Node.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System;

public class Node : IComparable {
  public float nodeTotalCost;
  public float estimatedCost;
  public bool bObstacle;
  public Node parent;
  public Vector3 position;

  public Node() {
    this.estimatedCost = 0.0f;
    this.nodeTotalCost = 1.0f;
    this.bObstacle = false;
    this.parent = null;
  }

  public Node(Vector3 pos) {
    this.estimatedCost = 0.0f;
    this.nodeTotalCost = 1.0f;
    this.bObstacle = false;
    this.parent = null;
    this.position = pos;
  }

  public void MarkAsObstacle() {
    this.bObstacle = true;
  }</pre></div><p>The <code class="literal">Node</code> class has properties, such as the cost values (<code class="literal">G</code> and <code class="literal">H</code>), flags to mark whether it is an obstacle, its positions, and parent node. The <code class="literal">nodeTotalCost</code> is <code class="literal">G</code>, which is the movement cost value from starting node to this node so far and the <code class="literal">estimatedCost</code> is <code class="literal">H</code>, which is total estimated cost from this node to the target goal node. We also have <a id="id127" class="indexterm"></a>two simple constructor methods and a wrapper method to set whether this node is an obstacle. Then, we implement the <code class="literal">CompareTo</code> method as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  public int CompareTo(object obj) {
    Node node = (Node)obj;
    //Negative value means object comes before this in the sort
      //order.
    if (this.estimatedCost &lt; node.estimatedCost)
      return -1;
    //Positive value means object comes after this in the sort
      //order.
    if (this.estimatedCost &gt; node.estimatedCost) return 1;
    return 0;
  }
}</pre></div><p>This method is important. Our <code class="literal">Node</code> class inherits from <code class="literal">IComparable</code> because we want to override this <code class="literal">CompareTo</code> method. If you can recall what we discussed in the previous algorithm section, you'll notice that we need to sort our list of node arrays based on the total estimated cost. The <code class="literal">ArrayList</code> type has a method called <code class="literal">Sort</code>. This method basically looks for this <code class="literal">CompareTo</code> method, implemented inside the object (in this case, our <code class="literal">Node</code> objects) from the list. So, we implement this method to sort the node objects based on our <code class="literal">estimatedCost</code> value.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip05"></a>Tip</h3><p>The <code class="literal">IComparable.CompareTo</code> method, which is a .NET framework feature, can be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec06"></a>Establishing the priority queue</h4></div></div></div><p>The <code class="literal">PriorityQueue</code> <a id="id128" class="indexterm"></a>class is a short and simple class to make the handling of the nodes' <code class="literal">ArrayList</code> easier, as shown in the following <code class="literal">PriorityQueue.cs</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class PriorityQueue {
  private ArrayList nodes = new ArrayList();

  public int Length {
    get { return this.nodes.Count; }
  }

  public bool Contains(object node) {
    return this.nodes.Contains(node);
  }

  public Node First() {
    if (this.nodes.Count &gt; 0) {
      return (Node)this.nodes[0];
    }
    return null;
  }

  public void Push(Node node) {
    this.nodes.Add(node);
    this.nodes.Sort();
  }

  public void Remove(Node node) {
    this.nodes.Remove(node);
    //Ensure the list is sorted
    this.nodes.Sort();
  }
}</pre></div><p>The preceding code listing should be easy to understand. One thing to notice is that after adding or <a id="id129" class="indexterm"></a>removing node from the nodes' <code class="literal">ArrayList</code>, we call the <code class="literal">Sort</code> method. This will call the <code class="literal">Node</code> object's <code class="literal">CompareTo</code> method and will sort the nodes accordingly by the <code class="literal">estimatedCost</code> value.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec07"></a>Setting up our grid manager</h4></div></div></div><p>The <code class="literal">GridManager</code> <a id="id130" class="indexterm"></a>class handles all the properties of the grid, representing the map. We'll keep a singleton instance of the <code class="literal">GridManager</code> class as we need only one object to represent the map, as shown in the following <code class="literal">GridManager.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class GridManager : MonoBehaviour {
  private static GridManager s_Instance = null;

  public static GridManager instance {
    get {
      if (s_Instance == null) {
        s_Instance = FindObjectOfType(typeof(GridManager)) 
            as GridManager;
        if (s_Instance == null)
          Debug.Log("Could not locate a GridManager " +
              "object. \n You have to have exactly " +
              "one GridManager in the scene.");
      }
      return s_Instance;
    }
  }</pre></div><p>We look for the <code class="literal">GridManager</code> <a id="id131" class="indexterm"></a>object in our scene and if found, we keep it in our <code class="literal">s_Instance</code> static variable:</p><div class="informalexample"><pre class="programlisting">  public int numOfRows;
  public int numOfColumns;
  public float gridCellSize;
  public bool showGrid = true;
  public bool showObstacleBlocks = true;

  private Vector3 origin = new Vector3();
  private GameObject[] obstacleList;
  public Node[,] nodes { get; set; }
  public Vector3 Origin {
    get { return origin; }
  }</pre></div><p>Next, we declare all the variables; we'll need to represent our map, such as number of rows and columns, the size of each grid tile, and some Boolean variables to visualize the grid and obstacles as well as to store all the nodes present in the grid, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  void Awake() {
    obstacleList = GameObject.FindGameObjectsWithTag("Obstacle");
    CalculateObstacles();
  }
  // Find all the obstacles on the map
  void CalculateObstacles() {
    nodes = new Node[numOfColumns, numOfRows];
    int index = 0;
    for (int i = 0; i &lt; numOfColumns; i++) {
      for (int j = 0; j &lt; numOfRows; j++) {
        Vector3 cellPos = GetGridCellCenter(index);
        Node node = new Node(cellPos);
        nodes[i, j] = node;
        index++;
      }
    }
    if (obstacleList != null &amp;&amp; obstacleList.Length &gt; 0) {
      //For each obstacle found on the map, record it in our list
      foreach (GameObject data in obstacleList) {
        int indexCell = GetGridIndex(data.transform.position);
        int col = GetColumn(indexCell);
        int row = GetRow(indexCell);
        nodes[row, col].MarkAsObstacle();
      }
    }
  }</pre></div><p>We look for all the game <a id="id132" class="indexterm"></a>objects with an <code class="literal">Obstacle</code> tag and put them in our <code class="literal">obstacleList</code> property. Then we set up our nodes' 2D array in the <code class="literal">CalculateObstacles</code> method. First, we just create the normal node objects with default properties. Just after that, we examine our <code class="literal">obstacleList</code>. Convert their position into row-column data and update the nodes at that index to be obstacles.</p><p>The <code class="literal">GridManager</code> class has a couple of helper methods to traverse the grid and get the grid cell data. The following are some of them with a brief description of what they do. The implementation is simple, so we won't go into the details.</p><p>The <code class="literal">GetGridCellCenter</code> method returns the position of the grid cell in world coordinates from the cell index, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  public Vector3 GetGridCellCenter(int index) {
    Vector3 cellPosition = GetGridCellPosition(index);
    cellPosition.x += (gridCellSize / 2.0f);
    cellPosition.z += (gridCellSize / 2.0f);
    return cellPosition;
  }

  public Vector3 GetGridCellPosition(int index) {
    int row = GetRow(index);
    int col = GetColumn(index);
    float xPosInGrid = col * gridCellSize;
    float zPosInGrid = row * gridCellSize;
    return Origin + new Vector3(xPosInGrid, 0.0f, zPosInGrid);
  }</pre></div><p>The <code class="literal">GetGridIndex</code> <a id="id133" class="indexterm"></a>method returns the grid cell index in the grid from the given position:</p><div class="informalexample"><pre class="programlisting">  public int GetGridIndex(Vector3 pos) {
    if (!IsInBounds(pos)) {
      return -1;
    }
    pos -= Origin;
    int col = (int)(pos.x / gridCellSize);
    int row = (int)(pos.z / gridCellSize);
    return (row * numOfColumns + col);
  }

  public bool IsInBounds(Vector3 pos) {
    float width = numOfColumns * gridCellSize;
    float height = numOfRows* gridCellSize;
    return (pos.x &gt;= Origin.x &amp;&amp;  pos.x &lt;= Origin.x + width &amp;&amp;
        pos.x &lt;= Origin.z + height &amp;&amp; pos.z &gt;= Origin.z);
  }</pre></div><p>The <code class="literal">GetRow</code> and <code class="literal">GetColumn</code> methods return the row and column data of the grid cell from the given index:</p><div class="informalexample"><pre class="programlisting">  public int GetRow(int index) {
    int row = index / numOfColumns;
    return row;
  }

  public int GetColumn(int index) {
    int col = index % numOfColumns;
    return col;
  }</pre></div><p>Another important method is <code class="literal">GetNeighbours</code>, which is used by the <code class="literal">AStar</code> class to retrieve the neighboring nodes of a particular node:</p><div class="informalexample"><pre class="programlisting">  public void GetNeighbours(Node node, ArrayList neighbors) {
    Vector3 neighborPos = node.position;
    int neighborIndex = GetGridIndex(neighborPos);

    int row = GetRow(neighborIndex);
    int column = GetColumn(neighborIndex);

    //Bottom
    int leftNodeRow = row - 1;
    int leftNodeColumn = column;
    AssignNeighbour(leftNodeRow, leftNodeColumn, neighbors);

    //Top
    leftNodeRow = row + 1;
    leftNodeColumn = column;
    AssignNeighbour(leftNodeRow, leftNodeColumn, neighbors);

    //Right
    leftNodeRow = row;
    leftNodeColumn = column + 1;
    AssignNeighbour(leftNodeRow, leftNodeColumn, neighbors);

    //Left
    leftNodeRow = row;
    leftNodeColumn = column - 1;
    AssignNeighbour(leftNodeRow, leftNodeColumn, neighbors);
  }

  void AssignNeighbour(int row, int column, ArrayList neighbors) {
    if (row != -1 &amp;&amp; column != -1 &amp;&amp; 
        row &lt; numOfRows &amp;&amp; column &lt; numOfColumns) {
      Node nodeToAdd = nodes[row, column];
      if (!nodeToAdd.bObstacle) {
        neighbors.Add(nodeToAdd);
      }
    }
  }</pre></div><p>First, we retrieve the <a id="id134" class="indexterm"></a>neighboring nodes of the current node in the left, right, top, and bottom, all four directions. Then, inside the <code class="literal">AssignNeighbour</code> method, we check the node to see whether it's an obstacle. If it's not, we push that neighbor node to the referenced array list, <code class="literal">neighbors</code>. The next method is a debug aid method to visualize the grid and obstacle blocks:</p><div class="informalexample"><pre class="programlisting">  void OnDrawGizmos() {
    if (showGrid) {
      DebugDrawGrid(transform.position, numOfRows, numOfColumns, 
          gridCellSize, Color.blue);
    }
    Gizmos.DrawSphere(transform.position, 0.5f);
    if (showObstacleBlocks) {
      Vector3 cellSize = new Vector3(gridCellSize, 1.0f,
        gridCellSize);
      if (obstacleList != null &amp;&amp; obstacleList.Length &gt; 0) {
        foreach (GameObject data in obstacleList) {
          Gizmos.DrawCube(GetGridCellCenter(
              GetGridIndex(data.transform.position)), cellSize);
        }
      }
    }
  }

  public void DebugDrawGrid(Vector3 origin, int numRows, int
    numCols,float cellSize, Color color) {
    float width = (numCols * cellSize);
    float height = (numRows * cellSize);

    // Draw the horizontal grid lines
    for (int i = 0; i &lt; numRows + 1; i++) {
      Vector3 startPos = origin + i * cellSize * new Vector3(0.0f,
        0.0f, 1.0f);
      Vector3 endPos = startPos + width * new Vector3(1.0f, 0.0f,
        0.0f);
      Debug.DrawLine(startPos, endPos, color);
    }

    // Draw the vertical grid lines
    for (int i = 0; i &lt; numCols + 1; i++) {
      Vector3 startPos = origin + i * cellSize * new Vector3(1.0f,
        0.0f, 0.0f);
      Vector3 endPos = startPos + height * new Vector3(0.0f, 0.0f,
        1.0f);
      Debug.DrawLine(startPos, endPos, color);
    }
  }
}</pre></div><p>Gizmos can be used to <a id="id135" class="indexterm"></a>draw visual debugging and setup aids inside the editor scene view. The <code class="literal">OnDrawGizmos</code> method is called every frame by the engine. So, if the debug flags, <code class="literal">showGrid</code> and <code class="literal">showObstacleBlocks</code>, are checked, we just draw the grid with lines and obstacle cube objects with cubes. Let's not go through the <code class="literal">DebugDrawGrid</code> method, which is quite simple.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip06"></a>Tip</h3><p>You can learn more about gizmos in the Unity reference documentation at <a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Gizmos.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Gizmos.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec08"></a>Diving into our A* implementation</h4></div></div></div><p>The <code class="literal">AStar</code> class is the <a id="id136" class="indexterm"></a>main class that will utilize the classes we have implemented so far. You can go back to the algorithm section if you want to review this. We start with our <code class="literal">openList</code> and <code class="literal">closedList</code> declarations, which are of the <code class="literal">PriorityQueue</code> type, as shown in the <code class="literal">AStar.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class AStar {
  public static PriorityQueue closedList, openList;</pre></div><p>Next, we implement a method called <code class="literal">HeuristicEstimateCost</code> to calculate the cost between the two nodes. The calculation is simple. We just find the direction vector between the two by subtracting one position vector from another. The magnitude of this resultant vector gives the direct distance from the current node to the goal node:</p><div class="informalexample"><pre class="programlisting">  private static float HeuristicEstimateCost(Node curNode, 
      Node goalNode) {
    Vector3 vecCost = curNode.position - goalNode.position;
    return vecCost.magnitude;
  }</pre></div><p>Next, we have our main <code class="literal">FindPath</code> method:</p><div class="informalexample"><pre class="programlisting">  public static ArrayList FindPath(Node start, Node goal) {
    openList = new PriorityQueue();
    openList.Push(start);
    start.nodeTotalCost = 0.0f;
    start.estimatedCost = HeuristicEstimateCost(start, goal);

    closedList = new PriorityQueue();
    Node node = null;</pre></div><p>We initialize our open and closed lists. Starting with the start node, we put it in our open list. Then we start processing our open list:</p><div class="informalexample"><pre class="programlisting">    while (openList.Length != 0) {
      node = openList.First();
      //Check if the current node is the goal node
      if (node.position == goal.position) {
        return CalculatePath(node);
      }

      //Create an ArrayList to store the neighboring nodes
      ArrayList neighbours = new ArrayList();

      GridManager.instance.GetNeighbours(node, neighbours);

      for (int i = 0; i &lt; neighbours.Count; i++) {
        Node neighbourNode = (Node)neighbours[i];

        if (!closedList.Contains(neighbourNode)) {
          float cost = HeuristicEstimateCost(node,
              neighbourNode);

          float totalCost = node.nodeTotalCost + cost;
          float neighbourNodeEstCost = HeuristicEstimateCost(
              neighbourNode, goal);

          neighbourNode.nodeTotalCost = totalCost;
          neighbourNode.parent = node;
          neighbourNode.estimatedCost = totalCost + 
              neighbourNodeEstCost;

          if (!openList.Contains(neighbourNode)) {
            openList.Push(neighbourNode);
          }
        }
      }
      //Push the current node to the closed list
      closedList.Push(node);
      //and remove it from openList
      openList.Remove(node);
    }

    if (node.position != goal.position) {
      Debug.LogError("Goal Not Found");
      return null;
    }
    return CalculatePath(node);
  }</pre></div><p>This code implementation resembles the algorithm that we have previously discussed, so you can refer back to it if you are not clear of certain things. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Get the first node of our <code class="literal">openList</code>. Remember our <code class="literal">openList</code> of nodes is always sorted every time a new node is added. So, the first node is always the node with the least estimated cost to the goal node.</p></li><li><p>Check whether the current node is already at the goal node. If so, exit the <code class="literal">while</code> loop and build the <code class="literal">path</code> array.</p></li><li><p>Create an array list to store the neighboring nodes of the current node being processed. Use the <code class="literal">GetNeighbours</code> method to retrieve the neighbors from the grid.</p></li><li><p>For every node in the <code class="literal">neighbors</code> array, we check whether it's already in <code class="literal">closedList</code>. If not, we calculate the cost values, update the node properties with the new cost values as well as the parent node data, and put it in <code class="literal">openList</code>.</p></li><li><p>Push the current node to <code class="literal">closedList</code> and remove it from <code class="literal">openList</code>. Go back to step 1.</p></li></ol></div><p>If there are no more nodes <a id="id137" class="indexterm"></a>in <code class="literal">openList</code>, our current node should be at the target node if there's a valid path available. Then, we just call the <code class="literal">CalculatePath</code> method with the current node parameter:</p><div class="informalexample"><pre class="programlisting">  private static ArrayList CalculatePath(Node node) {
    ArrayList list = new ArrayList();
    while (node != null) {
      list.Add(node);
      node = node.parent;
    }
    list.Reverse();
    return list;
  }
}</pre></div><p>The <code class="literal">CalculatePath</code> method traces through each node's parent node object and builds an array list. It gives an array list with nodes from the target node to the start node. Since we want a path array from the start node to the target node, we just call the <code class="literal">Reverse</code> method.</p><p>So, this is our <code class="literal">AStar</code> class. We'll write a test script in the following code to test all this and then set up a scene to use them in.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec09"></a>Implementing a Test Code class</h4></div></div></div><p>This class will use <a id="id138" class="indexterm"></a>the <code class="literal">AStar</code> class to find the path from the start node to the goal node, as shown in the following <code class="literal">TestCode.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class TestCode : MonoBehaviour {
  private Transform startPos, endPos;
  public Node startNode { get; set; }
  public Node goalNode { get; set; }

  public ArrayList pathArray;

  GameObject objStartCube, objEndCube;
  private float elapsedTime = 0.0f;
  //Interval time between pathfinding
  public float intervalTime = 1.0f;</pre></div><p>First, we set up the variables that we'll need to reference. The <code class="literal">pathArray</code> is to store the nodes array returned from the <code class="literal">AStar FindPath</code> method:</p><div class="informalexample"><pre class="programlisting">  void Start () {
    objStartCube = GameObject.FindGameObjectWithTag("Start");
    objEndCube = GameObject.FindGameObjectWithTag("End");

    pathArray = new ArrayList();
    FindPath();
  }

  void Update () {
    elapsedTime += Time.deltaTime;
    if (elapsedTime &gt;= intervalTime) {
      elapsedTime = 0.0f;
      FindPath();
    }
  }</pre></div><p>In the <code class="literal">Start</code> method, we look for objects with the <code class="literal">Start</code> and <code class="literal">End</code> tags and initialize our <code class="literal">pathArray</code>. We'll be trying to find our new path at every interval that we set to our <code class="literal">intervalTime</code> property in case the positions of the start and end nodes have changed. Then, we call the <code class="literal">FindPath</code> method:</p><div class="informalexample"><pre class="programlisting">  void FindPath() {
    startPos = objStartCube.transform;
    endPos = objEndCube.transform;

    startNode = new Node(GridManager.instance.GetGridCellCenter(
        GridManager.instance.GetGridIndex(startPos.position)));

    goalNode = new Node(GridManager.instance.GetGridCellCenter(
        GridManager.instance.GetGridIndex(endPos.position)));

    pathArray = AStar.FindPath(startNode, goalNode);
  }</pre></div><p>Since we implemented our pathfinding algorithm in the <code class="literal">AStar</code> class, finding a path has now become a lot simpler. First, we take the positions of our start and end game objects. Then, we create new <code class="literal">Node</code> objects using the helper methods of <code class="literal">GridManager</code> and <code class="literal">GetGridIndex</code> to <a id="id139" class="indexterm"></a>calculate their respective row and column index positions inside the grid. Once we get this, we just call the <code class="literal">AStar.FindPath</code> method with the start node and goal node and store the returned array list in the local <code class="literal">pathArray</code> property. Next, we implement the <code class="literal">OnDrawGizmos</code> method to draw and visualize the path found:</p><div class="informalexample"><pre class="programlisting">  void OnDrawGizmos() {
    if (pathArray == null)
      return;

    if (pathArray.Count &gt; 0) {
      int index = 1;
      foreach (Node node in pathArray) {
        if (index &lt; pathArray.Count) {
          Node nextNode = (Node)pathArray[index];
          Debug.DrawLine(node.position, nextNode.position,
            Color.green);
          index++;
        }
      }
    }
  }
}</pre></div><p>We look through our <code class="literal">pathArray</code> and use the <code class="literal">Debug.DrawLine</code> method to draw the lines connecting the nodes from the <code class="literal">pathArray</code>. With this, we'll be able to see a green line connecting the nodes <a id="id140" class="indexterm"></a>from start to end, forming a path, when we run and test our program.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec10"></a>Setting up our sample scene</h4></div></div></div><p>We are going to <a id="id141" class="indexterm"></a>set up a scene that looks something similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_11.jpg" /><div class="caption"><p>A sample test scene</p></div></div><p>We'll have a directional light, the start and end game objects, a few obstacle objects, a plane entity to be used as ground, and two empty game objects in which we put our <code class="literal">GridManager</code> and <code class="literal">TestAStar</code> scripts. This is our scene hierarchy:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_12.jpg" /><div class="caption"><p>The scene Hierarchy</p></div></div><p>Create a bunch of cube <a id="id142" class="indexterm"></a>entities and tag them as <code class="literal">Obstacle</code>. We'll be looking for objects with this tag when running our pathfinding algorithm.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_13.jpg" /><div class="caption"><p>The Obstacle node</p></div></div><p>Create a cube entity and tag it as <code class="literal">Start</code>.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_14.jpg" /><div class="caption"><p>The Start node</p></div></div><p>Then, create another <a id="id143" class="indexterm"></a>cube entity and tag it as <code class="literal">End</code>.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_15.jpg" /><div class="caption"><p>The End node</p></div></div><p>Now, create an empty game object and attach the <code class="literal">GridManager</code> script. Set the name as <code class="literal">GridManager</code> because we use this name to look for the <code class="literal">GridManager</code> object from our script. Here, we can set <a id="id144" class="indexterm"></a>up the number of rows and columns for our grid as well as the size of each tile.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_16.jpg" /><div class="caption"><p>The GridManager script</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec11"></a>Testing all the components</h4></div></div></div><p>Let's hit the play button <a id="id145" class="indexterm"></a>and see our A* Pathfinding algorithm in action. By default, once you play the scene, Unity will switch to the <span class="strong"><strong>Game</strong></span> view. Since our pathfinding visualization code is written for the debug drawn in the editor view, you'll need to switch back to the <span class="strong"><strong>Scene</strong></span> view or enable <span class="strong"><strong>Gizmos</strong></span> to see the path found.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_17.jpg" /><div class="caption"><p>Found path one</p></div></div><p>Now, try to move the start or end node around in the scene using the editor's movement gizmo (not in the <span class="strong"><strong>Game</strong></span> view, but the <span class="strong"><strong>Scene</strong></span> view).</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_04_18.jpg" /><div class="caption"><p>Found path two</p></div></div><p>You should see the path <a id="id146" class="indexterm"></a>updated accordingly if there's a valid path from the start node to the target goal node, dynamically in real time. You'll get an error message in the console window if there's no path available.</p></div></div></div>