<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec22"></a>Creating the enemy tank</h2></div></div><hr /></div><p>Let's go <a id="id59" class="indexterm"></a>ahead and create an animator controller in your assets folder. This will be your enemy tank's state machine. Call it <code class="literal">EnemyFsm</code>.</p><p>This state machine will drive the tank's basic actions. As described earlier, in our example, the enemy can patrol, chase, and shoot the player. Let's go ahead and set up our state machine. Select the <code class="literal">EnemyFsm</code> asset and open up the <span class="strong"><strong>Animator</strong></span> window.</p><p>Now, we'll go ahead and create three empty states that will conceptually and functionally represent our enemy tank's states. Name them <code class="literal">Patrol</code>, <code class="literal">Chase</code>, and <code class="literal">Shoot</code>. Once they are created and named, we'll want to make sure we have the correct default state <a id="id60" class="indexterm"></a>assigned. At the moment, this will vary depending on the order in which you created and named the states, but we want the <span class="strong"><strong>Patrol</strong></span> state to be the default state, so right-click on it and select <span class="strong"><strong>Set as Layer Default State</strong></span>. Now it is colored orange and the <span class="strong"><strong>Entry</strong></span> state is connected to it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>Choosing transitions</h3></div></div></div><p>At this point, we <a id="id61" class="indexterm"></a>have to make some design and logic decisions regarding the way our states will flow into each other. When we map out these transitions, we also want to keep in mind the conditions that trigger the transitions to make sure they are logical and work from a design-standpoint. Out in the wild, when you're applying these techniques on your own, different factors will play into how these transitions are handled. In order to best illustrate the topic at hand, we'll keep our transitions simple and logical:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Patrol</strong></span>: From <a id="id62" class="indexterm"></a>patrol, we can transition into chasing. We will use a chain of conditions to choose which state we'll transition into, if any.</p><p>Can the enemy tank see the player? If yes, we go to the next step; if not, we continue with patrolling.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Chase</strong></span>: From this <a id="id63" class="indexterm"></a>state, we'll want to continue to check whether the player is within sight to continue chasing, close enough to shoot, or completely out of sight that would send us back into the patrol state.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Shoot</strong></span>: Same as <a id="id64" class="indexterm"></a>earlier, we'll want to check our range for shooting and then the line of sight to determine whether or not we can chase to get within the range.</p></li></ul></div><p>This particular example has a simple and clean set of transition rules. If we connect our states accordingly, we'll end up with a graph looking more or less similar to this one:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/4204_02_08.jpg" /></div><p>Keep in mind that the <a id="id65" class="indexterm"></a>placement of the nodes is entirely up to you, and it does not affect the functionality of the state machine in any way. You try to place your nodes in a way that keeps them organized so that you can track your transitions visually.</p><p>Now that we have our states mapped out, let's assign some behaviors to them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Making the cogs turn</h3></div></div></div><p>This is <a id="id66" class="indexterm"></a>the part I'm sure you've been waiting for. I know, I've kept you waiting, but for good reasonâ€”as we now get ready to dive into coding, we do so with a good understanding of the logical connection between the states in our FSM. Without further ado, select our <span class="strong"><strong>Patrol</strong></span> state. In the hierarchy, you'll see a button labeled <span class="strong"><strong>Add Behaviour</strong></span>. Clicking this gives you a context menu very similar to the <span class="strong"><strong>Add Component</strong></span> button on regular game objects, but as we mentioned before, this button creates the oh-so-unique state machine behaviors.</p><p>Go ahead and name this behavior <code class="literal">TankPatrolState</code>. Doing so creates a script of the same name in your project and attaches it to the state we created it from. You can open this script via the project window, or by double-clicking on the name of the script in the inspector. What you'll find inside will look similar to this:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class TankPatrolState : StateMachineBehaviour {

   // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state
   //override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {
   //
   //}

   // OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks
   //override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {
   //
   //}

   // OnStateExit is called when a transition ends and the state machine finishes evaluating this state
   //override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {
   //
   //}

   // OnStateMove is called right after Animator.OnAnimatorMove(). Code that processes and affects root motion should be implemented here
   //override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {
   //
   //}

   // OnStateIK is called right after Animator.OnAnimatorIK(). Code that sets up animation IK (inverse kinematics) should be implemented here.
   //override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) {
   //
   //}
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip03"></a>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p>Before we begin, uncomment each method. Let's break it down step by step. Unity creates this file for you, but all the methods are commented out. Essentially, the commented code acts as a guide. Much like the methods provided for you in a <code class="literal">MonoBehaviour</code>, these methods are called for you by the underlying logic. You don't need to know <a id="id67" class="indexterm"></a>what's going on behind the scenes to use them; you simply have to know when they are called to leverage them. Luckily, the commented code provides a brief description of when each method is called, and the names are fairly descriptive themselves. There are two methods here we don't need to worry about: <code class="literal">OnStateIK</code> and <code class="literal">OnStateMove</code>, which are animation messages, so go ahead and delete them and save the file.</p><p>To reiterate what's stated in the code's comments, the following things happen:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">OnStateEnter</code> is called when you enter the state, as soon as the transition starts</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnStateUpdate</code> is called on each frame, after MonoBehaviors update</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnStateExit</code> is called after the transition out of the state is finished</p></li></ul></div><p>The following two states, as we mentioned, are animation-specific, so we do not use those for our purposes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">OnStateIK</code> is called just before the IK system gets updated. This is an animation and rig-specific concept.</p></li><li style="list-style-type: disc"><p>
<code class="literal">OnStateMove</code> is used on avatars that are set up to use root motion.</p></li></ul></div><p>Another important piece of information to note is the parameters passed into these methods:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The animator parameter is a reference to the animator that contains this animator controller, and therefore, this state machine. By extension of that, you can fetch a reference to the game object that the animator controller is on, and from there, you can grab any other components attached to it. Remember, the state machine behavior exists only as an asset, and does not exist in the class, meaning this is the best way to get references to runtime classes, such as mono behaviors.</p></li><li style="list-style-type: disc"><p>The animator state info provides information about the state you're currently in, however, the uses for this are primarily focus on animation state info, so it's not as useful for our application.</p></li><li style="list-style-type: disc"><p>Lastly, we have the <a id="id68" class="indexterm"></a>layer index, which is an integer telling us which layer within the state machine our state is in. The base layer is index 0, and each layer above that is a number higher.</p></li></ul></div><p>Now that we understand the basics of a state machine behavior, let's get the rest of our components in order. Before we can actually see these behaviors in action, we have to go back to our state machine and add some parameters that will drive the states.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec01"></a>Setting conditions</h4></div></div></div><p>We will <a id="id69" class="indexterm"></a>need to provide our enemy tank with a few conditions to transitions states. These are the actual parameters that will drive the functionality.</p><p>Let's begin with the <span class="strong"><strong>Patrol</strong></span> state. In order for our enemy tank to go from <span class="strong"><strong>Patrol</strong></span> to <span class="strong"><strong>Shoot</strong></span>, we need to be in range of the player, in other words, we'll be checking the distance between the enemy and the player, which is best represented by a float value. So, in your <span class="strong"><strong>Parameters</strong></span> panel, add a float and name it <code class="literal">distanceFromPlayer</code>. We can also use this parameter to determine whether or not to go into the <span class="strong"><strong>Chase</strong></span> state.</p><p>The <span class="strong"><strong>Shoot</strong></span> state and the <span class="strong"><strong>Chase</strong></span> state will share a common condition, which is whether or not the player is visible. We'll determine this via a simple raycast, which will in turn, tell us whether the player was in line-of-sight or not. The best parameter for this is a Boolean, so create a Boolean and call it <code class="literal">isPlayerVisible</code>. Leave the parameter unchecked, which means false.</p><p>Now we'll assign the conditions via the transition connectors' inspector. To do this, simply select a connector. When selected, the inspector will display some information about the current transition, and most importantly, the conditions, which show up as a list. To add a condition, simply click on the <span class="strong"><strong>+</strong></span> (plus) sign:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/4204_02_09.jpg" /></div><p>Let's tackle each <a id="id70" class="indexterm"></a>transition one by one.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Patrol to Chase</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">distanceFromPlayer &lt; 5</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">isPlayerVisible == true</code>
</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781785288272/graphics/4204_02_10.jpg" /><div class="caption"><p>The patrol to chase transition conditions</p></div></div></li></ul></div><p>Chase to patrol gets a bit more interesting as we have two <span class="emphasis"><em>separate</em></span> conditions that can trigger a transition. If we were to simply add two conditions to that transition, both would have to be evaluated to true in order for the transition to occur, but we want to check whether the player is out of range or they are out of sight. Luckily, we can have multiple transitions between the same two states. Simply add another transition connection as you normally would. Right-click on the <span class="strong"><strong>Chase</strong></span> state and then make a transition to the <span class="strong"><strong>Patrol</strong></span> state. You'll notice that you now have two transitions listed at the top of the inspector. In addition, your transition connection indicator shows multiple arrows instead of just one to indicate that there are multiple transitions between these two <a id="id71" class="indexterm"></a>states. Selecting each transition in the inspector will allow you to give each one separate condition:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Chase to Patrol (A)</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">distanceFromPlayer &gt; 5</code>
</p></li></ul></div></li><li style="list-style-type: disc"><p>Chase to Patrol (B)</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">isPlayerVisible == false</code>
</p></li></ul></div></li><li style="list-style-type: disc"><p>Chase to Shoot</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">distanceFromPlayer &lt; 3</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">isPlayerVisible == true</code>
</p></li></ul></div></li><li style="list-style-type: disc"><p>Shoot to Chase</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">distanceFromPlayer &gt; 3</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">distanceFromPlayer &lt; 5</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">isPlayerVisible == true</code>
</p></li></ul></div></li><li style="list-style-type: disc"><p>Shoot to Patrol (A)</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">distanceFromPlayer &gt; 6</code>
</p></li></ul></div></li><li style="list-style-type: disc"><p>Shoot to Patrol (B)</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">isPlayerVisible == false</code>
</p></li></ul></div></li></ul></div><p>We now have our states and transitions set. Next, we need to create the script that will drive these values. All we need to do is set the values, and the state machine will handle the rest.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec02"></a>Driving parameters via code</h4></div></div></div><p>Before going any farther, we'll need a few things from the assets we imported earlier in the chapter. For starters, go ahead and open the DemoScene folder of this chapter. You'll notice the scene is <a id="id72" class="indexterm"></a>fairly stripped down and only contains an environment prefab and some waypoint transforms. Go ahead and drop in the <code class="literal">EnemyTankPlaceholder</code> prefab into the scene.</p><p>You may notice a few components that you may or may not be familiar with on the EnemyTank. We'll get a chance to thoroughly explore NavMesh and NavMeshAgent in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Finding Your Way</em></span>, but for now, these are necessary components to make the whole thing work. What you will want to focus on is the <span class="strong"><strong>Animator</strong></span> component which will house the state machine (animator controller) we created earlier. Go ahead and drop in the state machine into the empty slot before continuing.</p><p>We will also need a placeholder for the player. Go ahead and drop in the <code class="literal">PlayerTankPlaceholder</code> prefab as well. We won't be doing much with this for now. As with the enemy tank placeholder prefab, the player tank placeholder prefab has a few components that we can ignore for now. Simply place it in the scene and continue.</p><p>Next, you'll want to add a new component to the <code class="literal">EnemyTankPlaceholder</code> game objectâ€”the <code class="literal">TankAi.cs</code> script, which is located in the <code class="literal">Chapter 2</code> folder. If we open up the script, we'll find this inside it:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class TankAi : MonoBehaviour {
    // General state machine variables
    private GameObject player;
    private Animator animator;
    private Ray ray;
    private RaycastHit hit;
    private float maxDistanceToCheck = 6.0f;
    private float currentDistance;
    private Vector3 checkDirection;

    // Patrol state variables
    public Transform pointA;
    public Transform pointB;
    public NavMeshAgent navMeshAgent;
    
    private int currentTarget;
    private float distanceFromTarget;
    private Transform[] waypoints = null;

    private void Awake() {
        player = GameObject.FindWithTag("Player");
        animator = gameObject.GetComponent&lt;Animator&gt;();
        pointA = GameObject.Find("p1").transform;
        pointB = GameObject.Find("p2").transform;
        navMeshAgent = gameObject.GetComponent&lt;NavMeshAgent&gt;();
        waypoints = new Transform[2] {
            pointA,
            pointB
        };
        currentTarget = 0;
        navMeshAgent.SetDestination(waypoints[currentTarget].position);
    }

    private void FixedUpdate() {
        //First we check distance from the player 
        currentDistance = Vector3.Distance(player.transform.position, transform.position);
        animator.SetFloat("distanceFromPlayer", currentDistance);

        //Then we check for visibility
        checkDirection = player.transform.position - transform.position;
        ray = new Ray(transform.position, checkDirection);
        if (Physics.Raycast(ray, out hit, maxDistanceToCheck)) {
            if(hit.collider.gameObject == player){
                animator.SetBool("isPlayerVisible", true);
            } else {
                animator.SetBool("isPlayerVisible", false);
            }
        } else {
            animator.SetBool("isPlayerVisible", false);
        }

        //Lastly, we get the distance to the next waypoint target
        distanceFromTarget = Vector3.Distance(waypoints[currentTarget].position, transform.position);
        animator.SetFloat("distanceFromWaypoint", distanceFromTarget);
    }

    public void SetNextPoint() {
        switch (currentTarget) {
            case 0:
                currentTarget = 1;
                break;
            case 1:
                currentTarget = 0;
                break;
        }
        navMeshAgent.SetDestination(waypoints[currentTarget].position);
    }
}</pre></div><p>We have a series of <a id="id73" class="indexterm"></a>variables that are required to run this script, so we'll run through what they're for in order:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">GameObject player</code>: This is a reference to the player placeholder prefab we dropped in earlier.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Animator animator</code>: This is the animator for our enemy tank, which contains the state machine we created.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Ray ray</code>: This is simply a declaration for a ray that we'll use in a raycast test on our <code class="literal">FixedUpdate</code> loop.</p></li><li style="list-style-type: disc"><p>
<code class="literal">RaycastHit hit</code>: This is a declaration for the hit information we'll receive from our raycast test.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Float maxDistanceToCheck</code>: This number coincides with the value we set in our transitions inside the state machine earlier. Essentially, we are saying that we're only checking as far as this distance for the player. Beyond that, we can assume that the player is out of range.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Float currentDistance</code>: This is the current distance between the player and the enemy tanks.</p></li></ul></div><p>You'll notice we skipped a few variables. Don't worry, we'll come back to cover these later. These are the variables we'll be using for our patrol state.</p><p>Our <code class="literal">Awake</code> method handles fetching the references to our player and animator variables. You can also declare the preceding variables as public or prefix them with the <code class="literal">[SerializeField]</code> attribute and set them via the inspector.</p><p>The <code class="literal">FixedUpdate</code> method is fairly straightforward; the first part gets the distance between the position of the player and the enemy tank. The part to pay special attention to is <code class="literal">animator.SetFloat("distanceFromPlayer", currentDistance)</code>, which passes in the information from this script into the parameter we defined earlier in our state machine. The same is true for the following section of the code, which passes in <a id="id74" class="indexterm"></a>the hit result of the raycast as a Boolean. Lastly, it sets the <code class="literal">distanceFromTarget</code> variable, which we'll be using for the patrol state in the next section.</p><p>As you can see, none of the code concerns itself with how or why the state machine will handle transitions; it merely passes in the information the state machine needs, and the state machine handles the rest. Pretty cool, right?</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec03"></a>Making our enemy tank move</h4></div></div></div><p>You may have <a id="id75" class="indexterm"></a>noticed, in addition to the variables we didn't cover yet, that our tank has no logic in place for moving. This can be easily handled with a substate machine, which is a state machine within a state. This may sound confusing at first, but we can easily break down the patrol state into substates. For our example, the Patrol state will be in one of the two substates: moving to the current waypoint and finding the next waypoint. A waypoint is essentially a destination for our agent to move toward. In order to make these changes, we'll need to go into our state machine again.</p><p>First, create a substate by clicking on an empty area on the canvas and then selecting <span class="strong"><strong>Create Sub-State Machine</strong></span>. Since we already have our original Patrol state and all the connections that go with it, we can just drag-and-drop our <span class="strong"><strong>Patrol</strong></span> state into our newly-created substate to merge the two. As you drag the Patrol state over the substate, you'll notice a plus sign appears by your cursor; this means you're adding one state to the other. When you drop the <span class="strong"><strong>Patrol</strong></span> state in, the new substate will absorb it. Substates have a unique look; they are six-sided rather than rectangular. Go ahead and rename the substate to <code class="literal">Patrol</code>.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/4204_02_11.jpg" /></div><p>To enter a substate, simply double-click on it. Think of it as going in a level lower into the substate. The window will look fairly similar, but you will notice a few things: your <span class="strong"><strong>Patrol</strong></span> state is connected to a node called (<span class="strong"><strong>Up) Base Layer</strong></span>, which essentially is the connection out from this level to the upper level that the substate machine sits on, and the <span class="strong"><strong>Entry</strong></span> state connects directly to the <span class="strong"><strong>Patrol</strong></span> state.</p><p>Unfortunately, this is <a id="id76" class="indexterm"></a>not the functionality we want as it's a closed loop that doesn't allow us to get in and out of the state into the individual waypoint states we need to create, so let's make some changes. First, we'll change the name of the substate to <code class="literal">PatrolEntry</code>. Next, we need to assign some transitions. When we enter this <span class="strong"><strong>Entry</strong></span> state, we want to decide whether to continue moving to the current waypoint, or to find a new one. We'll represent each of the outcomes as a state, so create two states: <code class="literal">MovingToTarget</code> and <code class="literal">FindingNewTarget</code>, then create transitions from the <span class="strong"><strong>PatrolEntry</strong></span> state to each one of the new states. Likewise, you'll want to create a transition between the two new states, meaning a transition from the MovingToTarget state to the FindingNewTarget state and vice versa. Now, add a new float parameter called <code class="literal">distanceFromWaypoint</code> and set up your conditions like this:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>PatrolEntry to MovingToTarget:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">distanceFromWaypoint &gt; 1</code>
</p></li></ul></div></li><li style="list-style-type: disc"><p>PatrolEntry to FindingNewTarget:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">distanceFromWaypoint &lt; 1</code>
</p></li></ul></div></li><li style="list-style-type: disc"><p>MovingToTarget to FindingNewTarget:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">distanceFromWaypoint &lt; 1</code>
</p></li></ul></div></li></ul></div><p>You're probably wondering why we didn't assign transition rule from the finding new target state to the MovingToTarget state. This is because we'll be executing some code via a state machine behavior and then automatically going into the MovingToTarget state without requiring any conditions. Go ahead and select the FindingNewTarget state and add a behavior and call it <code class="literal">SelectWaypointState</code>.</p><p>Open up the new script and remove all the methods, except for <code class="literal">OnStateEnter</code>. Add the following functionality to it:</p><div class="informalexample"><pre class="programlisting">TankAi tankAi = animator.gameObject.GetComponent&lt;TankAi&gt;();
tankAi.SetNextPoint();</pre></div><p>What we're doing here is getting a reference to our <code class="literal">TankAi</code> script and calling its <code class="literal">SetNextPoint()</code> method. Simple enough, right?</p><p>Lastly, we need to redo our <a id="id77" class="indexterm"></a>outgoing connections. Our new states don't have transitions out of this level, so we need to add one using the exact same conditions that our <span class="strong"><strong>PatrolEntry</strong></span> state has to the <span class="strong"><strong>(Up) Base Layer</strong></span> state. This is where <span class="strong"><strong>Any State</strong></span> comes in handyâ€”it allows us to transit from any state to another state, regardless of individual transition connections, so that we don't have to add transitions from each state to the <span class="strong"><strong>(Up) Base Layer</strong></span> state; we simply add it once to the <span class="strong"><strong>Any State</strong></span>, and we're set! Add a transition from the <span class="strong"><strong>Any State</strong></span> to the <span class="strong"><strong>PatrolEntry</strong></span> state and use the same conditions as the <span class="strong"><strong>Entry</strong></span> state has to the <span class="strong"><strong>(Up) Base Layer</strong></span> state. This is a work-around to not being able to connect directly from the <span class="strong"><strong>Any State </strong></span>to the (<span class="strong"><strong>Up) Base Layer </strong></span>state.</p><p>When you're done, your substate machine should look similar to this:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/4204_02_12.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec04"></a>Testing</h4></div></div></div><p>Now, all we have to do is hit play and watch our enemy tank patrol back and forth between the two provided waypoints. If we place the player in the editor in the enemy tank's <a id="id78" class="indexterm"></a>path, we'll see the transition happen in the animator, out of the Patrol state, into the Chase state, and when we move the player out of range, back into the Patrol state. You'll notice our Chase and Shoot states are not fully fleshed out yet. This is because we'll be implementing these states via concepts we'll cover in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Implementing Sensors</em></span>, and <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Finding Your Way</em></span>.</p></div></div></div>