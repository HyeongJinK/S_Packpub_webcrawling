<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec40"></a>Using an alternative implementation</h2></div></div><hr /></div><p>Here's a <a id="id196" class="indexterm"></a>simpler implementation of the flocking algorithm. In this example, we'll create a cube object and place a rigid body on our boids. With Unity's rigid body physics, we can simplify the translation and steering behavior of our boid. To prevent our boids from overlapping each other, we'll add a sphere collider physics component.</p><p>We'll have two components in this implementation as well: individual boid behavior and controller behavior. The controller will be the object that the rest of the boids try to follow.</p><p>The code <a id="id197" class="indexterm"></a>in the <code class="literal">Flock.cs</code> file is as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Flock : MonoBehaviour {
  internal FlockController controller;

  void Update () {
    if (controller) {
      Vector3 relativePos = steer() * Time.deltaTime;

      if (relativePos != Vector3.zero) 
          rigidbody.velocity = relativePos;

      // enforce minimum and maximum speeds for the boids
      float speed = rigidbody.velocity.magnitude;
      if (speed &gt; controller.maxVelocity) {
        rigidbody.velocity = rigidbody.velocity.normalized * 
          controller.maxVelocity;
      }
      else if (speed &lt; controller.minVelocity) {
        rigidbody.velocity = rigidbody.velocity.normalized * 
            controller.minVelocity;
      }
    }
  }</pre></div><p>The <code class="literal">FlockController</code> will be created in a moment. In our <code class="literal">Update()</code> method, we calculate the velocity for our boid using the following <code class="literal">steer()</code> method and apply it to its rigid body velocity. Next, we check the current speed of our rigid body component to verify whether it's in the range of our controller's maximum and minimum velocity limits. If not, we cap the velocity at the preset range:</p><div class="informalexample"><pre class="programlisting">  private Vector3 steer () {
    Vector3 center = controller.flockCenter - 
        transform.localPosition;  // cohesion

    Vector3 velocity = controller.flockVelocity - 
        rigidbody.velocity;  // alignment

    Vector3 follow = controller.target.localPosition - 
        transform.localPosition;  // follow leader

    Vector3 separation = Vector3.zero;

    foreach (Flock flock in controller.flockList) {
      if (flock != this) {
        Vector3 relativePos = transform.localPosition - 
            flock.transform.localPosition;

        separation += relativePos / (relativePos.sqrMagnitude);
      }
    }

    // randomize
    Vector3 randomize = new Vector3( (Random.value * 2) - 1, 
        (Random.value * 2) - 1, (Random.value * 2) - 1);

    randomize.Normalize();

    return (controller.centerWeight * center + 
        controller.velocityWeight * velocity + 
        controller.separationWeight * separation + 
        controller.followWeight * follow + 
        controller.randomizeWeight * randomize);
  }
}</pre></div><p>The <code class="literal">steer()</code> method implements separation, cohesion, and alignment, and follows the leader rules of <a id="id198" class="indexterm"></a>the flocking algorithm. Then, we sum up all the factors together with a random weight value. With this <code class="literal">Flock</code> script together with rigid body and sphere collider components, we create a <code class="literal">Flock</code> prefab, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_07.jpg" /><div class="caption"><p>The Flock</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec44"></a>Implementing the FlockController</h3></div></div></div><p>The <a id="id199" class="indexterm"></a>
<code class="literal">FlockController</code> is a simple behavior to generate the <a id="id200" class="indexterm"></a>boids at runtime and update the center as well as the average velocity of the flock.</p><p>The code in the <code class="literal">FlockController.cs</code> file is as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class FlockController : MonoBehaviour {
  public float minVelocity = 1;  //Min Velocity
  public float maxVelocity = 8;  //Max Flock speed
  public int flockSize = 20;  //Number of flocks in the group

  //How far the boids should stick to the center (the more 
  //weight stick closer to the center)
  public float centerWeight = 1;

  public float velocityWeight = 1;  //Alignment behavior

  //How far each boid should be separated within the flock
  public float separationWeight = 1;

  //How close each boid should follow to the leader (the more 
  //weight make the closer follow)
  public float followWeight = 1;

  //Additional Random Noise
  public float randomizeWeight = 1; 

  public Flock prefab;
  public Transform target;

  //Center position of the flock in the group
  internal Vector3 flockCenter;  
  internal Vector3 flockVelocity;  //Average Velocity

  public ArrayList flockList = new ArrayList();

  void Start () {
    for (int i = 0; i &lt; flockSize; i++) {
      Flock flock = Instantiate(prefab, transform.position, 
          transform.rotation) as Flock;
      flock.transform.parent = transform;
      flock.controller = this;
      flockList.Add(flock);
    }
  }</pre></div><p>We declare all <a id="id201" class="indexterm"></a>the properties to implement the flocking <a id="id202" class="indexterm"></a>algorithm and then start with the generation of the boid objects based on the flock size input. We set up the controller class and parent transform object as we did last time. Then, we add the created boid object in our <code class="literal">ArrayList</code> function. The <code class="literal">target</code> variable accepts an entity to be used as a moving leader. We'll create a sphere entity as a moving target leader for our flock:</p><div class="informalexample"><pre class="programlisting">  void Update () {
    //Calculate the Center and Velocity of the whole flock group
    Vector3 center = Vector3.zero;
    Vector3 velocity = Vector3.zero;

    foreach (Flock flock in flockList) {
      center += flock.transform.localPosition;
      velocity += flock.rigidbody.velocity;
    }

    flockCenter = center / flockSize;
    flockVelocity = velocity / flockSize;
  }
}</pre></div><p>In our <code class="literal">Update()</code> method, we keep updating the average center and velocity of the flock. These are the <a id="id203" class="indexterm"></a>values referenced from our boid object and <a id="id204" class="indexterm"></a>they are used to adjust the cohesion and alignment properties with the controller.</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_08.jpg" /><div class="caption"><p>The Flock controller</p></div></div><p>The following is <a id="id205" class="indexterm"></a>our <code class="literal">Target</code> entity with the <code class="literal">TargetMovement</code> <a id="id206" class="indexterm"></a>script, which we will create in a moment. The movement script is the same as what we saw in our previous Unity sample controller's movement script:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_09.jpg" /><div class="caption"><p>The Target entity with the TargetMovement script</p></div></div><p>Here is how <a id="id207" class="indexterm"></a>our <code class="literal">TargetMovement</code> script works. We pick a <a id="id208" class="indexterm"></a>random point nearby for the target to move to. When we get close to that point, we pick a new point. The boids will then follow the target.</p><p>The code in the <code class="literal">TargetMovement.cs</code> file is as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class TargetMovement : MonoBehaviour {
  //Move target around circle with tangential speed
  public Vector3 bound;
  public float speed = 100.0f;

  private Vector3 initialPosition;
  private Vector3 nextMovementPoint;

  void Start () {
    initialPosition = transform.position;
    CalculateNextMovementPoint();
  }
  void CalculateNextMovementPoint () {
    float posX = Random.Range(initialPosition.x = bound.x, 
        initialPosition.x+bound.x);
    float posY = Random.Range(initialPosition.y = bound.y, 
        initialPosition.y+bound.y);
    float posZ = Random.Range(initialPosition.z = bound.z, 
        initialPosition.z+bound.z);

    nextMovementPoint = initialPosition+ 
        new Vector3(posX, posY, posZ);
  }
  void Update () {
    transform.Translate(Vector3.forward * speed * Time.deltaTime);
    transform.rotation = Quaternion.Slerp(transform.rotation, 
        Quaternion.LookRotation(nextMovementPoint - 
        transform.position), 1.0f * Time.deltaTime);

    if (Vector3.Distance(nextMovementPoint, transform.position) 
        &lt;= 10.0f) CalculateNextMovementPoint();
  }
}</pre></div><p>After we put <a id="id209" class="indexterm"></a>everything together, we should have nice flocking <a id="id210" class="indexterm"></a>boids flying around in our scene, chasing the target:</p><div class="mediaobject"><img src="/graphics/9781785288272/graphics/B04204_05_10.jpg" /><div class="caption"><p>Flocking with Craig Reynold's algorithm</p></div></div></div></div>