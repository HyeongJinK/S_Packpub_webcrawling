<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec68"></a>Creating a distance displayer</h2></div></div><hr /></div><p>In this recipe, you will learn how to <a id="id426" class="indexterm"></a>create a distance displayer, which can be a very useful feature. For instance, when we want to display the proximity of an object or a character, a visual displayer or even an auditory distance displayer can give us a better indication of how far or close we are from a particular thing. This is done in order to assist us during gameplay, for example, to avoid a particular enemy, or not enter a dangerous region of a game.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec190"></a>How to do it...</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To begin, we have to create a UI image that will be our distance displayer. Right-click on the <span class="strong"><strong>Hierarchy</strong></span> panel, then go to <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Image</strong></span>, and rename it <span class="strong"><strong>DistanceDisplayer</strong></span>. Of course, it is possible to resize the image, change <span class="strong"><strong>Source Image</strong></span>, and then place it as we wish in <span class="strong"><strong>Canvas</strong></span>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip36"></a>Tip</h3><p>We are going to change the color of the <span class="strong"><strong>Image (Script)</strong></span> component. However, in order to avoid color distortion on our <span class="strong"><strong>HUD</strong></span> component, we should make <span class="strong"><strong>Source Image</strong></span> completely white, with the form of the part we want to change color. In other images, we construct all the decorations around the component. In this recipe, for the sake of simplicity, we will keep the square image as default.</p></div></li><li><p>Now, we need to<a id="id427" class="indexterm"></a> create the UI text that will display the distance as a number to the player. Again, right-click on the <span class="strong"><strong>Hierarchy</strong></span> panel, then go to <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Text</strong></span>, and rename it <span class="strong"><strong>DistanceDisplayerText</strong></span>. Resize to fit the image, tweak all the parameters that deal with the font as you like, change <span class="strong"><strong>Color</strong></span> to <span class="strong"><strong>white</strong></span>, and finally place it in the middle of <span class="strong"><strong>DistanceDisplayer</strong></span>. It doesn't matter if the text cannot be seen, since the background has the same color. This is because it will change at runtime.</p></li><li><p>Select <span class="strong"><strong>DistanceDisplayer</strong></span>. In the <span class="strong"><strong>Inspector</strong></span>, navigate to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>New Script</strong></span> and name it <span class="strong"><strong>DistanceDisplayerScript</strong></span>. Finally, click on <span class="strong"><strong>Create and Add</strong></span>.</p></li><li><p>Double-click on the script in order to edit it. Every time that we deal with the UI, because we are going to use the <span class="strong"><strong>Image</strong></span> class, we have to add the <code class="literal">using UnityEngine.UI;</code> statement at the beginning of the script. Before the beginning of the class, we can also add this line: <code class="literal">[RequireComponent(typeof(Image))]</code> (without the semicolon at the end). As a result, this script requires an <span class="strong"><strong>Image (Script)</strong></span> component that is attached to the same game object of the script.</p></li><li><p>The first variables that we need are used to store both <span class="strong"><strong>DistanceDisplayer</strong></span> and <span class="strong"><strong>DistanceDisplayerScript</strong></span>. Since we can easily assign them through the script, we can make them private:</p><div class="informalexample"><pre class="programlisting">  private Image img;
  private Text txt;</pre></div></li><li><p>Then, we need a couple of variables to store the <span class="strong"><strong>Transform</strong></span> component of the player and the target of this distance displayer. They have to be <code class="literal">public</code> in order to be set in the <span class="strong"><strong>Inspector</strong></span>:</p><div class="informalexample"><pre class="programlisting">  public Transform player;
  public Transform target;</pre></div></li><li><p>Furthermore, we want to have the possibility of setting two colors. As such, <span class="strong"><strong>DistanceDisplayer</strong></span> lerps between them in the <span class="strong"><strong>Inspector</strong></span>. So again, the variables have to be <code class="literal">publi</code>
<code class="literal">c</code>:</p><div class="informalexample"><pre class="programlisting">  public Color firstColor;
  public Color secondColor;</pre></div></li><li><p>We need one more <code class="literal">public</code> variable. Hence, we can set it from the <span class="strong"><strong>Inspector</strong></span>, which is used to calculate the color lerp that will be implemented later on. Therefore, let's add this line:</p><div class="informalexample"><pre class="programlisting">  public float farthestDistance;</pre></div></li><li><p>The next step is to write the <code class="literal">Start()</code> function in which we will store the initial values for<a id="id428" class="indexterm"></a> our <code class="literal">private</code> variables. So let's take the reference to the <span class="strong"><strong>Image (Script)</strong></span> component using the <code class="literal">GetComponent&lt;Image&gt;()</code> function. Then, we will also use the <code class="literal">GetComponentInChildren&lt;Text&gt;()</code> function to get the <span class="strong"><strong>Text (Script)</strong></span> component that is attached to <span class="strong"><strong>DistanceDisplayerText</strong></span> in the child of <span class="strong"><strong>DistanceDisplayer</strong></span>. Thus, we can write the following:</p><div class="informalexample"><pre class="programlisting">  void Start () {
    img = GetComponent&lt;Image&gt; ();
    txt = GetComponentInChildren&lt;Text&gt;();
  }</pre></div></li><li><p>Since <span class="strong"><strong>DistanceDisplayer</strong></span> has to be updated often, we can do it in every frame by implementing the logic inside the <code class="literal">Update()</code> function. Here is its structure:</p><div class="informalexample"><pre class="programlisting">  void Update () {
  }</pre></div></li><li><p>The first operation that we need to do is calculate the distance between the player and the target. This can be done easily using the <code class="literal">default Distance()</code> function in the <code class="literal">Vector3</code> class. Add this line in the <code class="literal">Update()</code> function:</p><div class="informalexample"><pre class="programlisting">    float distance = Vector3.Distance (player.position, target.position);</pre></div></li><li><p>Next, we can update the text of <span class="strong"><strong>DistanceDisplayerText</strong></span> by assigning to it the distance transformed into a string. We will also need to shorten the value of the float. To do this, we will need to pass the <code class="literal">F2</code> string as a parameter:</p><div class="informalexample"><pre class="programlisting">    txt.text = distance.ToString ("F2");</pre></div></li><li><p>The last thing that we need to do in the <code class="literal">Update()</code> function is assign a color to <code class="literal">img</code> using the <code class="literal">Lerp</code>:</p><div class="informalexample"><pre class="programlisting">    img.color = Color.Lerp (firstColor, secondColor, 1 - (distance / farestDistance));</pre></div></li><li><p>After we have completed all the previous steps, our script will be ready to run. Save it and then come back to Unity.</p></li><li><p>Then, we need to assign the <code class="literal">public</code> variables. Depending on how our game is structured, the way in which we assign them will change. However, in the <span class="emphasis"><em>There's more...</em></span> section, you can find out how to test the script that we have just written.</p></li><li><p>Now we can run the game. Once the game is running, the <span class="strong"><strong>Distance Displayer</strong></span> should look like this:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_08_01.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec191"></a>How it works...</h3></div></div></div><p>Here, we created a distance<a id="id429" class="indexterm"></a> displayer that shows the distance from the player and the target, and it also changes color according to the linear interpolation between the two colors.</p><p>Since the distance could be between zero and infinity, we need to set a scale to perform the lerping of the color. In this case, the <code class="literal">farthestDistance</code> variable will specify the farthest distance when the lerp is complete. Therefore, we divide the distance by <code class="literal">farthestDistance</code> so that we can obtain the percentage of the distance normalized between zero and <code class="literal">farthestDistance</code>. In fact, if the distance is greater than <code class="literal">farthestDistance</code>, the<a id="id430" class="indexterm"></a> lerp is considered to be completed. If so, since there is a -1 that makes the value of the lerp smaller than zero, <code class="literal">firstColor</code> is shown. Otherwise, the resulting value controls the lerp.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec192"></a>There's more...</h3></div></div></div><p>We can improve our distance displayer by integrating some new features. These will be explained by the following sections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec66"></a>Testing the script</h4></div></div></div><p>Since this script is<a id="id431" class="indexterm"></a> intended to work when it is integrated inside a game, we need to ensure that it works the way it is supposed to, given this context. To do this, we need to construct a test scene. A simple way of doing this is by creating an entire scene inside the canvas using 2D UI elements. However, we must keep in mind that this script also works for a 3D environment.</p><p>Let's begin to create our test scene by creating a couple of images inside the canvas. To do this, right-click on <span class="strong"><strong>Canvas</strong></span> and then go to <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Image</strong></span>. So that we don't get confused, we can name them <span class="strong"><strong>TargetObject</strong></span> and <span class="strong"><strong>PlayerObject</strong></span> respectively. Once we have done this, the next step is to allow the player to move inside the scene. We can easily do this by attaching the drag script that we created in the <span class="emphasis"><em>Making a draggable panel</em></span> recipe in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Creating Panels for Menus</em></span>, to the player. Remember that we also need to attach the <span class="strong"><strong>Event Trigger (Script)</strong></span> component as specified in that recipe to make it work. Once we have completed these steps, we should have something like this:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_08_02.jpg" /></div><p>An interesting alternative is to modify the script by adding handlers. We did this in the <span class="emphasis"><em>Changing the cursor at runtime</em></span> recipe in the previous chapter. By adding handlers to the script, we can achieve the same result in a more user-friendly way, since it avoids the need to add the <span class="strong"><strong>Event Trigger (Script)</strong></span> component. After we have done this, we are able to move the <span class="strong"><strong>PlayerObject</strong></span> by dragging it on the screen.</p><p>Now it's time to<a id="id432" class="indexterm"></a> set the parameters of <span class="strong"><strong>DistanceDisplayerScript</strong></span> in the <span class="strong"><strong>Inspector</strong></span>. Drag <span class="strong"><strong>PlayerObject</strong></span> inside the <span class="strong"><strong>Player</strong></span> variable and <span class="strong"><strong>TargetObject</strong></span> inside the <span class="strong"><strong>Target</strong></span> variable. Next, we need to set the colors so that we can identify the proximity of an object. For instance, if it is not ideal for the player to be close to an object, we should assign a <span class="emphasis"><em>positive</em></span> color, such as green, to <code class="literal">firstColor</code> when the player is significantly distant from the object. In contrast, if the player is too close to the object, we can assign a more <span class="emphasis"><em>negative</em></span> color, such as red, to <code class="literal">secondColor</code>. Otherwise, we can reverse them, or adapt them for our game.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip37"></a>Tip</h3><p>When Unity creates a new color as the default, it has all the parameters set to zero, so it is black. But the alpha channel is also set to zero, so when you choose another color, ensure that you also set an appropriate alpha channel for what you want to achieve.</p></div><p>The last parameter that we want to set is <span class="strong"><strong>Farthest Distance</strong></span>. This depends on the spatial scale of our game. However, the meaning of this parameter is as follows: it is the farthest distance at which the player must be from the target object for the color of the displayer to not change anymore. To set it properly, we should experiment with different values in our game in order to achieve the desired results. In this example scene, just try setting it to <span class="strong"><strong>400</strong></span>.</p><p>In the end, we should see something like this in the <span class="strong"><strong>Inspector</strong></span>, which reflects the parameters and colors that we identified within our script:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_08_03.jpg" /></div><p>Next, we can click on play and drag <span class="strong"><strong>PlayerObject</strong></span> around to see how the distance displayer changes its color based on the location of <span class="strong"><strong>PlayerObject</strong></span> with respect to the target. We can also get <a id="id433" class="indexterm"></a>an idea of the distance by seeing it expressed as a number in <span class="strong"><strong>DistanceDisplayerText</strong></span>. Furthermore, if it is required, we can tweak the <code class="literal">farthestDistance</code> variable using this information.</p><p>Here is a screenshot of the scene:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_08_04.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec67"></a>Optimizing the code by using a delayed update through coroutines</h4></div></div></div><p>It could be <a id="id434" class="indexterm"></a>computationally expensive to update <span class="strong"><strong>DistanceDisplayer</strong></span> for every frame. As a result, we can use coroutines to optimize our code.</p><p>To do this, let's create a new <code class="literal">public</code> variable to set the amount of time that we want to wait for before the UI element is updated. As the default, we can choose <code class="literal">0.8f</code> as its value. Hence, we use this line:</p><div class="informalexample"><pre class="programlisting">public float updateTime = 0.8f;</pre></div><p>Moreover, we need to create a new function that returns an <code class="literal">IEnumerator</code> type, and we can call it <code class="literal">updateDistanceDisplayer()</code>, as follows:</p><div class="informalexample"><pre class="programlisting">  IEnumerator updateDistanceDisplayer(){
  }</pre></div><p>Since this is a coroutine<a id="id435" class="indexterm"></a> and it has a behavior similar that of to the <code class="literal">Update()</code> function, we need to place an infinite cycle in it by adding the following code:</p><div class="informalexample"><pre class="programlisting">  while (true) {
  }</pre></div><p>Before you erase the <code class="literal">Update()</code> function, cut its body by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>X</em></span>, and paste the code in the <code class="literal">while</code> statement by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>V</em></span>.</p><p>Finally, we have to wait until a certain amount of time has elapsed before the cycle repeats. It should be noted that in general, this amount is greater than the time that Unity takes to render a frame. As a result, this is a more efficient solution than the previous one. It works because we don't need to constantly change <span class="strong"><strong>Distance Displayer</strong></span>. Furthermore, it can simulate more realistic <span class="strong"><strong>Distance Detector</strong></span> that has a delay. Also, the coroutine structure allows us to implement other types of functionality, such as sound. Therefore, we need a <code class="literal">yield</code> statement along with calling the <code class="literal">WaitForSeconds()</code> function to wait as many seconds we want. After incorporating this into the script, we should have the following:</p><div class="informalexample"><pre class="programlisting">  float distance = Vector3.Distance (player.position, target.position);
  txt.text = distance.ToString ("F2");
  img.color = Color.Lerp (firstColor, secondColor, 1 - (distance / farthestDistance));
  yield return new WaitForSeconds(updateTime);</pre></div><p>Even if we cannot notice any difference, the code is more optimized and is ready to incorporate new functionality (for example, multitarget detecting or sound), as described in the following sections.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec68"></a>Multi target detecting</h4></div></div></div><p>In some games, it could<a id="id436" class="indexterm"></a> be useful if our <span class="strong"><strong>Distance Displayer</strong></span> could detect more than one target. For example, consider a shooter game in which we want to show the location of the closest enemy, or a platform game in which we want to show where the closest treasure is located. In these examples, we have to change our <span class="strong"><strong>Distance Displayer</strong></span> to detect multiple targets. In order to do this, we have to convert the <span class="strong"><strong>target</strong></span> variable into an array so that we can override its definition with this one:</p><div class="informalexample"><pre class="programlisting">public Transform[] targets;</pre></div><p>It is worth noting that we have also changed the name of the variable from <span class="strong"><strong>target</strong></span> to <span class="strong"><strong>targets</strong></span>. This has been done to maintain consistency and indicate that we are now detecting more than one target. If you have followed the previous section, you will notice that we cannot calculate<a id="id437" class="indexterm"></a> the distance within our coroutine with just one line of code anymore. In fact, we have to iterate over all the targets that we have set in the <span class="strong"><strong>Inspector</strong></span> and then pick the closest one. So let's fix this issue by replacing the distance calculation with these lines:</p><div class="informalexample"><pre class="programlisting">float distance = float.MaxValue; //Or Vector3.Distance (player.position, targets[0].position);
foreach(Transform t in targets){
  if (distance &gt; Vector3.Distance (player.position, t.position)){
    distance = Vector3.Distance (player.position, t.position);
  }
}</pre></div><p>In the first line, we set the distance to the maximum <code class="literal">float</code>. This is because every time the <code class="literal">foreach</code> cycle selects a target in our array, it checks whether the distance with this one is less than the lowest distance it has found so far. We can also change this value, the initial distance, to the distance between the player and the first target of the array.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip38"></a>Tip</h3><p>Since the <code class="literal">targets</code> variable is <code class="literal">public</code>, we have to be sure that the array contains at least one element. So, if we are not sure of this, we should add a control to check whether the array contains at least one element. Furthermore, this control should go in the coroutine and not in the <code class="literal">Start()</code> function. This is because its value could change over time.</p></div><p>Then, we actually use the <code class="literal">foreach</code> statement to cycle over the array. Next, using an <code class="literal">if</code> statement, we can check whether the new element picked from the array is closer to the player or not.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"></a>Tip</h3><p>We can take advantage of the fact that the <code class="literal">targets</code> array is public. What this means is that we can add and remove elements dynamically. For instance, we can remove dead enemies or add new ones when they are spawned. Lastly, we should also convert the array into <code class="literal">List&lt;T&gt;</code> to handle the dynamic nature of a set of objects more easily.</p><p>Something to keep in mind regarding performance is that until we make the element count in the array relatively small, this script should not have any problem running from a computational standpoint. However, if the array becomes very large, it could take a while to render a frame, especially if our game is already full of heavy scripts. In this case, we have the option of handling the dimension of the array dynamically to remove futile objects (such as enemies that we already know are too far, maybe because they are in another room of the level). It could<a id="id438" class="indexterm"></a> solve the problem and add them back in a second moment.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec69"></a>Beep sound</h4></div></div></div><p>If we want to add a beep sound to <span class="strong"><strong>Distance Displayer</strong></span> to make the player aware when it has been updated (using a sound), we can achieve this by adding another <code class="literal">public</code> variable. We do this <a id="id439" class="indexterm"></a>so that we can set the sound from the <span class="strong"><strong>Inspector</strong></span>:</p><div class="informalexample"><pre class="programlisting">public AudioClip beep;</pre></div><p>Finally, to reproduce the sound through each cycle of our coroutine, let's add this line before the <code class="literal">yield</code> statement:</p><div class="informalexample"><pre class="programlisting">AudioSource.PlayClipAtPoint (beep, Input.mousePosition);</pre></div><p>Since the sound comes from the user interface, we have chosen to play it to <code class="literal">Input.mousePosition</code>. As a result, we do not need to instantiate an <code class="literal">AudioSource</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec70"></a>Increasing the ratio of the beep sound according to the distance</h4></div></div></div><p>There are many<a id="id440" class="indexterm"></a> ways by which we can indicate distances of objects or characters during gameplay. In this recipe, we used color as a way to indicate the proximity of the player to an object. However, what can also be a nice way to indicate distance to a player is through the use of audio. For example, a player may be trying to avoid being seen by an enemy, which encourages the player to use a great degree of stealth as he navigates throughout the level. So, in order to indicate to the player that he is coming in the view of an enemy, we may use a beep sound. It can be heard once the player begins to get closer to the enemy. This may start with quite a large amount of time between each beep, and as the player gets closer, the time between two beeps is reduced. This can create a more dramatic atmosphere, which a change in color may not be able to achieve. So, let's see how to do it.</p><p>Every time the <code class="literal">updateTime</code> changes, we don't need this variable anymore. So, we can remove it and change the argument of the <code class="literal">WaitForSeconds()</code> function to this:</p><div class="informalexample"><pre class="programlisting">Mathf.Clamp01(distance/farthestDistance)</pre></div><p>By doing this, we calculate the ratio between the distance from the target and <code class="literal">farthestDistance</code>, and clamp its value between 0 and 1. In this way, we can obtain a percentage of how far the target is, where 0% means the same point as that of the player (distance is zero) and 100% means that the target is farther than <code class="literal">farthestDistance</code>. Then we use this percentage, converted into a decimal, for the time to wait until the next update of <span class="strong"><strong>Distance Displayer</strong></span>.</p><p>We<a id="id441" class="indexterm"></a> can also decide to keep the <code class="literal">updateTime</code> variable in order to still control how much time to wait, by multiplying it with our new argument in this way:</p><div class="informalexample"><pre class="programlisting">Mathf.Clamp01(distance/farthestDistance)*updateTime</pre></div><p>If we do, the percentage will be on <code class="literal">updateTime</code>. For example, if the distance is half of <code class="literal">farthestDistance</code>, the next update will be in half of <code class="literal">updateTime</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec193"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If you want to get a better understanding of how to change colors gradually, you can refer to the previous chapter in the <span class="emphasis"><em>Creating a slider that changes colors gradually</em></span> recipe, or consult the official<a id="id442" class="indexterm"></a> documentation about the <code class="literal">Lerp</code> function at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Color.Lerp.html" target="_blank">http://docs.unity3d.com/ScriptReference/Color.Lerp.html</a>.</p></li><li style="list-style-type: disc"><p>Furthermore, in order to test the script as described in the <span class="emphasis"><em>There's more...</em></span> section, we can refer to the <span class="emphasis"><em>Making a draggable panel</em></span> and <span class="emphasis"><em>Changing the cursor at runtime</em></span> recipes contained in chapters 4, 5, and 7 respectively. In <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Creating Panels for Menus</em></span>, we have taken the drag script; whereas, in <span class="emphasis"><em>Chapter 7</em></span>, <span class="emphasis"><em>Applying Runtime Customizations</em></span>, you can refer to use handlers and therefore also have another point of view to solving problems.</p></li><li style="list-style-type: disc"><p>Finally, if you want to better understand how you can shorten the float number with the <code class="literal">ToString()</code> function, you can refer to the <span class="emphasis"><em>Implementing a numeric timer</em></span> recipe from <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Implementing Timers</em></span>.</p></li><li style="list-style-type: disc"><p>In addition, if we want more control over the number of digits, we can implement the structure that is explained in the <span class="emphasis"><em>Change the number of decimal digits shown</em></span> section contained in the same chapter, inside the <span class="emphasis"><em>There's more...</em></span> section of the <span class="emphasis"><em>Creating a mixed timer</em></span> recipe.</p></li></ul></div></div></div>