<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec73"></a>Adding a smooth tilt effect</h2></div></div><hr /></div><p>There are many effects that can be applied to both 2D and 3D menus. Some of them can be small and subtle, such as a glow effect when the player moves the mouse cursor on a menu item. But while these effects are typically a nice touch for creating more dynamic interactions, they<a id="id470" class="indexterm"></a> are usually complementary to 2D menus. 3D menus provide us with the ability to add another layer of movement along another dimension. As such, we can have the entire menu perform a range of different movements, such as rotation and tilting, both on its own and via user interaction. Since we are able to utilize the <span class="emphasis"><em>z</em></span> axis, we are able to have elements projected in a different way. For instance, we are able to have the elements placed at various locations along the <span class="emphasis"><em>z</em></span> axis. When we rotate items that are farther away, they rotate at a slower rate than those that are closer (to the camera). This is known as the parallax effect. This recipe will touch on some basic movements, such as moving and rotating the 3D UI element. These movements could be for the entire menu, by making it rotate according to the mouse's position.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec204"></a>How to do it...</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>If we apply this effect to a menu that doesn't use the third dimension (all the elements have the <span class="emphasis"><em>z</em></span> axis set to zero), it will just deform the menu and ultimately ruin the user experience. Therefore, it's important to use an adequate menu to <a id="id471" class="indexterm"></a>apply this effect to - one that takes the <span class="emphasis"><em>z</em></span> axis into consideration. Let's take the menu that we created in the previous recipe, or if you prefer, you can create another menu by keeping in mind to use the third dimension.</p></li><li><p>Select the root of your menu. This is the element that has all the others as children. In the <span class="strong"><strong>Inspector</strong></span>, go to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>New Script</strong></span> and name it <span class="strong"><strong>TiltEffectScript</strong></span>. Finally, click on <span class="strong"><strong>Create and Add</strong></span>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip45"></a>Tip</h3><p>If your menu does not have a root, it is good practice to always have one. This is for keeping the contents of your menu in an ordered structure and applying modifications to all the elements in an easier way within your scripts. In order to create it on an existing menu, right-click on the <span class="strong"><strong>Hierarchy</strong></span> Panel and then select <span class="strong"><strong>Create Empty</strong></span>. Finally, rename it to <span class="strong"><strong>MenuRoot</strong></span>. Use <span class="strong"><strong>Rect Tool</strong></span> to modify the size of <span class="strong"><strong>MenuRoot</strong></span> until it includes all the UI elements that belong to the menu. Now, select all the elements and drag them onto <span class="strong"><strong>MenuRoot</strong></span>. We do this because it allows us to parent them to our root.</p></div></li><li><p>Double-click on the script in order to edit it. Since we are not going to directly use the UI components, but just their transforms, in order to manipulate their rotation, we don't have to add the <code class="literal">using UnityEngine.UI;</code> statement at the beginning of the script.</p></li><li><p>We need a <code class="literal">public</code> variable to set in the <span class="strong"><strong>Inspector</strong></span> that stores the range of degrees to which the UI element can turn on the <span class="emphasis"><em>x</em></span> axis and the <span class="emphasis"><em>y</em></span> axis. Therefore, we can use <code class="literal">Vector2</code> and set some arbitrary starting values:</p><div class="informalexample"><pre class="programlisting">public Vector2 range = new Vector2(10f, 6f);</pre></div></li><li><p>Since we also want to give the possibility to decide the velocity of rotation, we need to create a <code class="literal">public</code> variable for it. Again, set its starting value arbitrarily:</p><div class="informalexample"><pre class="programlisting">public float speed = 5f;</pre></div></li><li><p>Next, we need a vector variable to set at the beginning to zero. This variable will store the value by which the UI element has been rotated from the starting position in the previous frame. Again, since we need one value for each axis of rotation, we can use <code class="literal">Vector2</code>:</p><div class="informalexample"><pre class="programlisting">private Vector2 tiltRotation = Vector2.zero;</pre></div></li><li><p>Since the rotation of the UI elements has to be calculated and updated for every frame, the implementation of the tilt effect will be in the <code class="literal">Update()</code> function. Since the mouse can move all over the screen, we have to, in some way, clamp its <a id="id472" class="indexterm"></a>value between <code class="literal">-1</code> and <code class="literal">1</code> so that we can also distinguish which side of the screen it is on. This is done in order to represent a percentage of how far the mouse is from the center of the screen. Let's start by calculating the two coordinate halves of the screen:</p><div class="informalexample"><pre class="programlisting">float halfWidth = Screen.width / 2f;
float halfHeight = Screen.height / 2f;</pre></div></li><li><p>After we have identified the position of the mouse in terms of how far it is from the center of the screen, we have to clamp its value along both the axes in order to get a kind of percentage of this distance from the center:</p><div class="informalexample"><pre class="programlisting">float x = Mathf.Clamp((Input.mousePosition.x - halfWidth) / halfWidth, -1f, 1f);
float y = Mathf.Clamp((Input.mousePosition.y - halfHeight) / halfHeight, -1f, 1f);</pre></div></li><li><p>At this point, we could calculate the value of the tilt rotation and assign it to our UI element. However, if we do this, it wouldn't be smooth. Therefore, we have to introduce a delay in the movement. By giving the <code class="literal">x</code> and <code class="literal">y</code> that we have calculated in the previous step, we have to start from the rotation that the UI element had in the last frame and make it rotate a little towards the rotation that it should have at the end. Therefore, to achieve this, we need to linearly interpolate. While doing this, we can pass the time from the last frame as the control parameter. In fact, if we assign this value to <code class="literal">tiltRotation</code>, we can start from this frame and move on to the next one. Furthermore, if we multiply <code class="literal">deltaTime</code> with our speed stored in <code class="literal">speed</code>, we can control how smooth the rotation will be:</p><div class="informalexample"><pre class="programlisting">tiltRotation = Vector2.Lerp(tiltRotation, new Vector2(x, y), Time.deltaTime * speed);</pre></div></li><li><p>Finally, we have to assign the new rotation to the UI element, so by converting the <code class="literal">Euler</code> angles in <code class="literal">Quaternion</code>, we can make the assignment:</p><div class="informalexample"><pre class="programlisting">transform.localRotation = originalRotation * Quaternion.Euler(-tiltRotation.y * range.y, tiltRotation.x * range.x, 0f);</pre></div></li><li><p>Save the script and your work is done. The result at runtime is better when it is moving because it provides more dynamic visuals, as opposed to a static image. However, as<a id="id473" class="indexterm"></a> shown in the following screenshot, we are still able to gain some information about what we will see in the final outcome:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_09_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec205"></a>There's more...</h3></div></div></div><p>It is possible to slightly change the script to make it more customizable by designers. This is the aim of the following sections that will teach us how to do this.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec80"></a>Starting from the original rotation</h4></div></div></div><p>Some menus can have an initial rotation that determines where they start with the tilt effect. In order to do this, we<a id="id474" class="indexterm"></a> need to store the initial rotation in a <code class="literal">private</code> variable, like this:</p><div class="informalexample"><pre class="programlisting">private Quaternion originalRotation;</pre></div><p>Then, we have to initialize it in the <code class="literal">Start()</code> function with this line:</p><div class="informalexample"><pre class="programlisting">originalRotation = transform.localRotation;</pre></div><p>Finally, in the last line of our <code class="literal">Update()</code> function, we just multiply the new rotation with the original one:</p><div class="informalexample"><pre class="programlisting">transform.localRotation = originalRotation * Quaternion.Euler(-tiltRotation.y * range.y, tiltRotation.x * range.x, 0f);</pre></div><p>Now, every time the tilt effect is applied, it will start from the initial rotation of the UI element that we have set.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec81"></a>Converting the speed in the smoothness factor</h4></div></div></div><p>In some instances, we<a id="id475" class="indexterm"></a> might want to provide an easier way for designers to tweak the smoothness of the rotation instead of the velocity. In this case, we can replace the <code class="literal">speed</code> variable with this one:</p><div class="informalexample"><pre class="programlisting">public float smoothnessFactor = 0.2f;</pre></div><p>Then, we use <code class="literal">smoothnessFactor</code> in the code in this way:</p><div class="informalexample"><pre class="programlisting">tiltRotation = Vector2.Lerp(tiltRotation, new Vector2(x, y), Time.deltaTime * (1f/ smoothnessFactor);</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec82"></a>Inverting the axis</h4></div></div></div><p>In some games, both<a id="id476" class="indexterm"></a> the axes are inverted, and in others, only one axis is. Since we have scripted our tilt effect to include a range vector that can have negative values, we can achieve inversion by changing the sign to the components of the range vector. Of course, it is possible to have only one negative value to invert a specific axis. Furthermore, to simplify designers' lives, we can keep the values for the vector positive. Thus, we just need to change the signs of the vector components when they are utilized in the script. This means negative to positive and vice versa. In particular, we have to change the following line in this way:</p><div class="informalexample"><pre class="programlisting">transform.localRotation = originalRotation * Quaternion.Euler(-tiltRotation.y * -range.y, tiltRotation.x * -range.x, 0f);</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec83"></a>Asymmetric range for the rotation</h4></div></div></div><p>If we want to rotate our <a id="id477" class="indexterm"></a>UI element using an asymmetric tilt effect, it could be a bit tricky, because it is a little more complicated than other concepts that we have previously covered. An asymmetric tilt effect means that when the mouse goes from one side of the screen to another, the range of rotation changes. Therefore, we need another range vector for the symmetric part:</p><div class="informalexample"><pre class="programlisting">public Vector2 symmetricRange = new Vector2(7f, 4f);</pre></div><p>Now, when the script is running, we have to use one vector or the other depending on where the mouse is. Hence, we have to use an <code class="literal">if</code> statement by checking this and applying one range vector or the other when we rotate the UI element:</p><div class="informalexample"><pre class="programlisting">if(tiltRotation.y &gt; 0 &amp;&amp; tiltRotation.x &gt; 0)
  transform.localRotation = originalRotation * Quaternion.Euler(-tiltRotation.y * range.y, tiltRotation.x * range.x, 0f);
if(tiltRotation.y &lt; 0 &amp;&amp; tiltRotation.x &gt; 0)
  transform.localRotation = originalRotation * Quaternion.Euler(-tiltRotation.y * symmetricRange.y, tiltRotation.x * range.x, 0f);
if(tiltRotation.y &gt; 0 &amp;&amp; tiltRotation.x &lt; 0)
  transform.localRotation = originalRotation * Quaternion.Euler(-tiltRotation.y * range.y, tiltRotation.x * symmetricRange.x, 0f);
if(tiltRotation.y &lt; 0 &amp;&amp; tiltRotation.x &lt; 0)
  transform.localRotation = originalRotation * Quaternion.Euler(-tiltRotation.y * symmetricRange.y, tiltRotation.x * symmetricRange.x, 0f);</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec84"></a>Changing the reference of the mouse from the screen to an arbitrary rect</h4></div></div></div><p>In some cases, we don't <a id="id478" class="indexterm"></a>want the area in which the tilt effect takes place to be extended along all of the screen size. In such cases, we should replace it with an arbitrary <code class="literal">Rect</code>. In this case, when we calculate the <code class="literal">x</code> and <code class="literal">y</code> values, we have to use the size of <code class="literal">Rect</code>, as follows:</p><div class="informalexample"><pre class="programlisting">float x = Mathf.Clamp((Input.mousePosition.x - halfRectWidth) / halfRectWidth, -1f, 1f);
float y = Mathf.Clamp((Input.mousePosition.y - halfRectHeight) / halfRectHeight, -1f, 1f);</pre></div><p>If <code class="literal">Rect</code> is not centered in the middle of the screen, remember to add the offset of the position of <code class="literal">Rect</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip46"></a>Tip</h3><p>We can also notice that if some part of the <code class="literal">Rect</code> is outside the screen, the clamp will never be <code class="literal">1</code> or <code class="literal">-1</code>. Therefore, the rotation will not be complete. While we may want to do this, it is<a id="id479" class="indexterm"></a> better practice to tweak the range vector in order to achieve the same effect.</p></div></div></div></div>