<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec78"></a>Implementing advanced features for minimaps</h2></div></div><hr /></div><p>In comparison to the simple minimap that we created in the last recipe, a more complex minimap features <a id="id513" class="indexterm"></a>more detailed attributes, such as the shape of a minimap. In this recipe, we will make the minimap circular using masks. Also, you will learn how to add layers to hide various objects so that they don't feature<a id="id514" class="indexterm"></a> inside of the minimap. This may be particularly useful if you want to hide specific objects and characters and even some locations throughout your game. Finally, we will look at how to add icons to the minimap, also through the use of layers.</p><p>Furthermore, in the <span class="emphasis"><em>There's more…</em></span> section of this recipe, you can find other advanced features to implement in your minimap.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec217"></a>How to do it...</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Since this recipe will teach you how to implement some advanced features in a minimap, it is assumed that the previous recipe for creating a minimap has been completed. However, you don't have to follow the entire recipe. You can also take ideas on how to improve your minimap with these advanced features. So, let's start by shaping it.</p></li><li><p>In order to transform the minimap's shape into a circle, we have to use masks. You learned about them in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>UI Essentials</em></span> in the <span class="emphasis"><em>Adding a circular mask to an image</em></span> recipe. We can take the mask that we created in that recipe and use it again here. Thus, we can create a new image, rename it <span class="strong"><strong>MinimapMask</strong></span>, and set the white circle to its <span class="strong"><strong>Source Image</strong></span>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip48"></a>Tip</h3><p>It is possible to use any other shape that we want. Just keep in mind that if you create any shape, the white sections of the mask texture will be the parts that are visible.</p></div></li><li><p>We place <span class="strong"><strong>MinimapMask</strong></span> over our <span class="strong"><strong>Minimap</strong></span> and parent the latter with the first one.</p></li><li><p>The next step is to add the <span class="strong"><strong>Mask</strong></span> component to <span class="strong"><strong>MinimapMask</strong></span>. To do this, go to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Mask</strong></span>. Since we don't want to see the original graphic of our mask, we need to make sure that we uncheck <span class="strong"><strong>Show Mask Graphic</strong></span>.</p></li><li><p>Now, our minimap should have a circular shape, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_10_06.jpg" /></div></li><li><p>Another interesting<a id="id515" class="indexterm"></a> feature that we can add to the interface of the minimap is a compass. To do<a id="id516" class="indexterm"></a> this, create another image element and rename it <span class="strong"><strong>Compass</strong></span>. Finally, attach a sprite to it, like this:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_10_07.jpg" /></div></li><li><p>Now, we have<a id="id517" class="indexterm"></a> only to place it behind<a id="id518" class="indexterm"></a> the minimap, and ensure that the part of the interface we want is visible. We should end up with something similar to the following:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_10_08.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>In the <span class="emphasis"><em>There's more…</em></span> section of this recipe, you can find out more about the compass.</p></div></li><li><p>Furthermore, minimaps <a id="id519" class="indexterm"></a>often use icons or symbols within themselves as a way of indicating to the player various objects and even characters. For instance, the<a id="id520" class="indexterm"></a> player could be represented as a little white arrow and the enemies as red dots. To implement this feature on the minimap, we have to use layers. To edit layers, go to the top-right corner of Unity, click on <span class="strong"><strong>Layer</strong></span>, and then click on <span class="strong"><strong>Edit Layers...</strong></span>, as shown here:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_10_09.jpg" /></div></li><li><p>As we can see, a menu now appears in the <span class="strong"><strong>Inspector</strong></span>, showing all the layers. Some of the layers, from <span class="strong"><strong>0</strong></span> to <span class="strong"><strong>7</strong></span>, are built-in layers and cannot be modified. In contrast, all other<a id="id521" class="indexterm"></a> layers are user layers, which<a id="id522" class="indexterm"></a> we are going to modify. If you have followed the <span class="emphasis"><em>Making UI elements affected by different lights</em></span> recipe contained in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Creating Panels for Menus</em></span> you should see that some of the user layers have already been set. If they are, we can just use the other ones:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_10_10.jpg" /></div></li><li><p>Now, let's add another couple of layers and call them <span class="strong"><strong>HideMinimap</strong></span> and <span class="strong"><strong>ShowMinimap</strong></span>. We do this so that all the objects that belong to the first layer are not displayed on the map but in the main camera. Thus, all the objects that belong<a id="id523" class="indexterm"></a> to the second layer are shown in the minimap but not in the main camera. Ultimately, all the <a id="id524" class="indexterm"></a>objects that belong to another layer, including nothing/default, are shown in both the cameras (such as the terrain).</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip49"></a>Tip</h3><p>According to the design of our game, different objects in the world could already have a layer assigned to them. This may have been done in order to implement other functions of the game. Therefore, we have to extend the concepts that we are covering in this recipe to multiply layers, since we cannot change the layer of an object that is used by other scripts in the game.</p><p>Therefore, instead of creating these two layers, we have to imagine them as a set of other layers that are already implemented — the ones we want to show on the minimap and the ones we don't want to. So in the next steps, every time we perform an operation with one of the two layers, we have to perform that action on all the layers that belong to the set of layers that we want to show in the minimap.</p></div></li><li><p>Next, we have to assign these layers to our objects in the scene. Let's start assigning the <span class="strong"><strong>HideMinimap</strong></span> layer to the <span class="strong"><strong>Player</strong></span> and to all other objects that we don't want to show in the minimap. This can be because they may be replaced by an icon, or simply because we don't want them to be displayed at all in the minimap (for example, other characters in a scene, treasure to find, and coins to collect). To<a id="id525" class="indexterm"></a> assign a layer, select the object and change the layer from <span class="strong"><strong>Default</strong></span> to <span class="strong"><strong>HideMinimap</strong></span>. This<a id="id526" class="indexterm"></a> option can be found just under the name of the object in the <span class="strong"><strong>Inspector</strong></span>, as shown in this screenshot:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_10_11.jpg" /></div></li><li><p>We have to hide this entire set of objects from <span class="strong"><strong>MinimapCamera</strong></span>. We can do this by selecting it and, then<a id="id527" class="indexterm"></a> in the <span class="strong"><strong>Inspector</strong></span>, changing <span class="strong"><strong>Culling Mask</strong></span> in order to uncheck the <span class="strong"><strong>HideMinimap</strong></span> layer. In fact, the camera will not render these objects anymore, and as a result, they will not appear on the <span class="strong"><strong>Render Texture</strong></span> that is attached to<a id="id528" class="indexterm"></a> our <span class="strong"><strong>Minimap</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_10_12.jpg" /></div></li><li><p>Now, we have to create the icons that will be displayed in the minimap. In this recipe, for the sake of simplicity, we will use only spheres, which will be rendered as dots from the top-down view of the camera. But feel free to attach your own icon as a texture on a quad. However, keep in mind that you should rotate it along the <span class="emphasis"><em>y</em></span> axis only, because it is supposed to rotate like an icon. This means that it can only rotate left or right and not in all directions like a 3D object.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip50"></a>Tip</h3><p>By using monochromatic spheres, we don't have to consider rotation, since it will always be rendered as a circle of their color, independent of the rotation they have.</p></div></li><li><p>So, let's create a new sphere and a new material for it. We can change the <span class="strong"><strong>Albedo</strong></span> value of <span class="strong"><strong>Texture</strong></span> to a color that we want to give to the dot in the minimap that will be our player (for example, cyan). Rename the sphere <span class="strong"><strong>PlayerMinimapIcon</strong></span>. Put it under the <span class="strong"><strong>MinimapCamera</strong></span>. If needed, depending on the <a id="id529" class="indexterm"></a>
<span class="strong"><strong>Size</strong></span> you have set previously, increase or decrease the scale of the sphere so that it appears bigger or smaller in the minimap. Next, place the sphere at the same position of the player and then attach it to the player object.</p></li><li><p>The main camera is still able to render <span class="strong"><strong>PlayerMinimapIcon</strong></span>. However, we don't want this. In<a id="id530" class="indexterm"></a> order to stop the camera from rendering this, we change the <span class="strong"><strong>PlayerMinimapIcon</strong></span> layer to <span class="strong"><strong>ShowMinimap</strong></span>, as we did in step 12. Next, cut this layer from the rendering of the main camera by unchecking the <span class="strong"><strong>Showminimap</strong></span> layer from its <span class="strong"><strong>Culling Mask</strong></span>.</p></li><li><p>Repeat these three last steps for all the objects that you want to represent as icons. Also, we don't have to change the cameras this time, since their <span class="strong"><strong>Culling Masks</strong></span> are already set properly.</p></li><li><p>Finally, we have created a nice minimap that is ready to be used. Especially if we have already built our 3D world, it will be a pleasure to navigate through it with the minimap. Furthermore, take a look at the <span class="emphasis"><em>There's more…</em></span> section to implement some even more advanced features.</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_10_13.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec218"></a>How it works...</h3></div></div></div><p>In this recipe, we added<a id="id531" class="indexterm"></a> new features to the minimap that we had developed in the first recipe of this chapter.</p><p>First, we gave our minimap <a id="id532" class="indexterm"></a>a shape using the mask component. In fact, as you learned in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>UI Essentials</em></span>, we can use another picture to shape our UI elements.</p><p>Then we added a new <span class="strong"><strong>Image</strong></span> element to our minimap so that we can use a compass in the interface. This works as both a decorative element and also a way to indicate north to the player.</p><p>Finally, we used layers. By using them, it is possible for us to tell elements that are rendered by our cameras from elements that are not. This is useful for both hiding elements on the minimap and showing something only in the minimap, such as icons.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec219"></a>There's more...</h3></div></div></div><p>If we have implemented all the features so far, we already came up with a very good minimap. However, if you want to push your skills and learn more about how to improve your minimap, the following sections will give you the right tools to achieve this.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec90"></a>Limiting the boundaries of the minimap camera</h4></div></div></div><p>It is good practice to design well-structured boundaries for our level, ideally so that when the player gets closer<a id="id533" class="indexterm"></a> to the boundaries, the minimap shouldn't display areas of the game environment that the player cannot access. However, in spite of our best efforts, a player may still go close to the boundaries, and since the minimap is centered on the player, it could display these areas, which are outside the bounds. Therefore, we want to make the minimap stop being centered on the player when he is close to the boundaries, and return to tracking the player when he goes back inside the area where the minimap could follow him without showing inaccessible parts of the world.</p><p>In general, the shape of the map could be anything, and in this case, we have to set the script to properly distinguish between whether or not the player is close to the edge of this area. Here, for the sake of simplicity, we will implement rectangular edges.</p><p>Let's set two variables for our edge. The first variable is a <code class="literal">Vector2</code>, where the first value is for the <code class="literal">min</code> and <code class="literal">max</code> movement along the <span class="emphasis"><em>x</em></span> axis that the minimap can reach. The second one is also a <code class="literal">Vector2</code>, but this time for <code class="literal">min</code> and <code class="literal">max</code> along the <span class="emphasis"><em>z</em></span> axis:</p><div class="informalexample"><pre class="programlisting">public Vector2 xBoundaries;
public Vector2 zBoundaries;</pre></div><p>In the <code class="literal">Update()</code> function, we want to find out whether the player is inside this area or not. If so, we can just set the position as we usually do. Otherwise, we have to set the minimap to the closest position that it can reach to best track the player when he is outside the area. If the player still manages to view past the boundaries of the map, it is likely that there are issues with the way in which the map is designed, or that there is a bad setting of the boundaries' vectors. Thus, during the design of the map, designers need to ensure that its boundaries are kept adequately constrained to the dimensions of the minimap. Therefore, we can replace the line of code that updates the position with these lines:</p><div class="informalexample"><pre class="programlisting">float newXPosition = playerTransform.position.x;
float newZPosition = playerTransform.position.z;

if (newXPosition &lt; xBoundaries.x)
  newXPosition = xBoundaries.x;
if (newXPosition &gt; xBoundaries.y)
  newXPosition = xBoundaries.y;

if (newZPosition &lt; zBoundaries.x)
  newZPosition = zBoundaries.x;
if (newZPosition &gt; zBoundaries.y)
  newZPosition = zBoundaries.y;

transform.position = new Vector3 (newXPosition, transform.position.y, newZPosition);</pre></div><p>Now let's set the vectors<a id="id534" class="indexterm"></a> in the <span class="strong"><strong>Inspector</strong></span> and test it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec91"></a>Rotating the minimap according to where the player is facing</h4></div></div></div><p>In the same game, the<a id="id535" class="indexterm"></a> minimap doesn't always face the same direction, but changes according to where the player is facing. This is so that everything that is displayed is done in a way that is relative to the player's perspective. This is often used in first-person games. In order to implement it, we have to change the rotation of the minimap time after time.</p><p>So, at the end of the <code class="literal">Update()</code> function, we not only have to move the camera but also have to rotate the minimap according to the player's direction. Therefore, we want to rotate the <span class="emphasis"><em>y</em></span> axis of <span class="strong"><strong>MinimapCamera</strong></span> so that it matches the rotation along the <span class="emphasis"><em>y</em></span> axis of the player. The other two axes are not touched, so set them equal as before. To do this, we can add the following to our script:</p><div class="informalexample"><pre class="programlisting">transform.rotation = Quaternion.Euler(new Vector3(transform.rotation.eulerAngles.x,playerTransform.rotation.eulerAngles.y,transform.rotation.eulerAngles.z));</pre></div><p>As the camera rotates, the view is reflected inside the minimap, which also assumes the same rotation as the player.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec92"></a>Smoothly rotating the minimap compass to point towards the relative north of the game environment</h4></div></div></div><p>A compass in the<a id="id536" class="indexterm"></a> minimap is a nice element that complements it, not only as an additional aesthetical element, but also for actually indicating the location of north within our game to the player. Especially if our minimap rotates according to the direction that the player is facing, we cannot use a static compass, and thus we have to move it. However, just as in reality, the compass should not be instantaneous. Therefore, we need to add a slight delay in rotating the compass so that it feels realistic.</p><p>We have to store the transform value of the compass. To do this, we need to create a variable for it:</p><div class="informalexample"><pre class="programlisting">public Transform compass;</pre></div><p>Since it is a public variable, we can assign it in the <span class="strong"><strong>Inspector</strong></span>. It is also worth keeping in mind that we should provide designers with the ability to tweak the velocity of rotation of the compass according to the design of the game. To do this, we again need to add a variable:</p><div class="informalexample"><pre class="programlisting">public float compassRotationSpeed = 1f;</pre></div><p>Because the north of our game could be located anywhere, we need to provide designers with the option of changing the direction of the compass through an offset from the standard north, which can often be the immediate direction that the player is facing when the scene is loaded. Therefore, we should create a variable for this as well:</p><div class="informalexample"><pre class="programlisting">public float compassOrientationOffset = 0f;</pre></div><p>At the end of the <code class="literal">Update()</code> function, we have to set the rotation of the compass. This is so that it can accurately point toward north relative to the game environment. Now, in order to make this rotation smooth, we have to perform a <code class="literal">Lerp</code> from the current rotation of the compass to<a id="id537" class="indexterm"></a> the desired one, which assumes the same direction that the player is facing. Furthermore, at this rotation, we can add <code class="literal">compassOrientationOffset</code> in order to reposition the location of north so that it reflects the in-game bearing of north. As a final parameter to control the lerp, we take the time from the last frame and multiply it by <code class="literal">compassRotationSpeed</code>:</p><div class="informalexample"><pre class="programlisting">compass.rotation = Quaternion.Lerp (compass.rotation, Quaternion.Euler (0, 0, playerTransform.rotation.eulerAngles.y+compassOrientationOffset), Time.deltaTime * compassRotationSpeed);</pre></div><p>We have used the <code class="literal">Quaternion.Lerp()</code> function because it works very well with rotations. In fact, when the player changes rotation from +160 degrees to -160 degrees, we would want the compass to traverse the shortest path of rotation possible to reach the final orientation. As a result, in this example, we would want the rotation path to be only 40 degrees, and not 320 degrees, as it would have happened if we had used the normal lerp between angles. By using Quaternions, we can avoid this problem and thus find the shortest path to rotate our compass.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec93"></a>Improving the lighting within the minimap</h4></div></div></div><p>Sometimes, within<a id="id538" class="indexterm"></a> the game world, lighting can add to the game experience. However, the minimap does not require the same amount of detailed lighting. In fact, it should be clear and easy for the player to follow while he is traversing the game's environment. As such, we need to take into consideration the fact that the lighting that we have for the minimap allows it to be viewed easily.</p><p>If we try to modify the lighting by setting a layer to some lights and then excluding that layer from the <span class="strong"><strong>Culling Mask</strong></span> of the minimap camera, we won't see any change. This is because the light, along with the shadows that it casts, is independent from the layer and from the <span class="strong"><strong>Culling Mask</strong></span> of the camera. Therefore, we have to use some advanced features of Unity.</p><p>Similar to <code class="literal">Start()</code> and <code class="literal">Update()</code>, there are other special functions that Unity itself calls at certain moments during all the processes to render the final frame on the screen. In particular, we will implement the <code class="literal">OnPreCull()</code> function, which is called before a frame is rendered with a specific camera, and also the <code class="literal">OnPostRender()</code> function, which is called when the frame for that specific camera is already rendered.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip51"></a>Tip</h3><p>Keep in mind that these two functions are called by Unity only if they are implemented in a script attached to an active camera.</p></div><p>These two functions<a id="id539" class="indexterm"></a> allow us to change the world's state before the camera renders a frame, and then put the world back to its original state after the frame has been rendered. We will see how to use these functions at the end of this section.</p><p>In order to avoid having shadows, we can turn the shadow casting of the lights off in our world and then turn it on again after the rendering. Keep in mind that even if we turn off the shadows, there might be some parts of the game that are not illuminated and thus appear like soft shadows. This is because it also depends on which shader the object has, and this affects how it is seen in the 3D world.</p><p>Since we have used the <span class="strong"><strong>Terrain</strong></span> object in Unity to build this test scene, we can change its shader. We can achieve this by going to its settings (select it in the <span class="strong"><strong>Hierarchy</strong></span> panel and then click on the <span class="strong"><strong>cog</strong></span> in the <span class="strong"><strong>Inspector</strong></span>). Then we go to <span class="strong"><strong>Material</strong></span> and change to <span class="strong"><strong>Built in Legacy Diffuse</strong></span>. Using a directional light with <span class="strong"><strong>Shadow Type</strong></span> set to <span class="strong"><strong>No Shadow</strong></span> and a rotation of 90 degrees on the <span class="emphasis"><em>x</em></span> axis and zero on the other two axes, it is possible to render a <span class="strong"><strong>Terrain</strong></span> that appears to have no shadows of any kind.</p><p>Shadows are not the only issue that we have to face. For instance, some lights may feel right within the 3D world but not in the minimap. An example of this would be if we have a fire in the game. While a fire may look appealing and contribute to the atmosphere, it is probably not ideal to have it in a minimap. So, we may want to remove it. Furthermore, including something such as a fire inside the minimap as well could be computationally expensive. This is because it needs to be rendered twice, once with the main camera and also for <span class="strong"><strong>MinimapCamera</strong></span>. However, even if we remove the fire from the minimap through layers, the light of the fire will still be present when the minimap is rendered. Therefore, we have to remove this light as well when we render the minimap.</p><p>Additionally, imagine that our game implements a day-night cycle. Ideally, we would like our minimap to always appear the same and not reflect the changes throughout the cycle. Therefore, we have to maintain the same lighting for our minimap. This means that we have to render different settings for the lighting on each of the two cameras.</p><p>We can deal with all of this by using the two aforementioned functions. In order to do this, let's create some variables. The first is an array for all the lights that we want to disable when the minimap is rendered. By setting it as <code class="literal">public</code>, we can just drag all the lights that we don't want on the minimap in this variable, within the <span class="strong"><strong>Inspector</strong></span>. So, let's add this to our script:</p><div class="informalexample"><pre class="programlisting">public Light[] minimapLightsVisible;</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip52"></a>Tip</h3><p>If we have a lot of lights that are useful for the game but not for the minimap, we should put all of them here. Furthermore, by doing this, we can also improve performance.</p></div><p>Now, we need another array for all the lights whose shadows we don't want to cast in our minimap. Even this time, we make it <code class="literal">public</code> so that we can set it in the <span class="strong"><strong>Inspector</strong></span>:</p><div class="informalexample"><pre class="programlisting">public Light[] minimapLightsNoShadows;</pre></div><p>Finally, an array with all the lights we want to render only in the minimap. We can keep these <code class="literal">public</code> for the <a id="id540" class="indexterm"></a>same reason:</p><div class="informalexample"><pre class="programlisting">public Light[] minimapLightsNotVisible;</pre></div><p>Now we can write the special functions that we mentioned earlier. Let's start with <code class="literal">OnPreCull()</code>. Here, we have to disable all the lights in <code class="literal">minimapLightsNotVisible</code>, make all the lights in <code class="literal">minimapLightsNoShadows</code> stop casting shadows, and turn all the lights in <code class="literal">minimapLightsVisible</code> on. Therefore, we use these lines:</p><div class="informalexample"><pre class="programlisting">void OnPreCull (){
  foreach(Light l in minimapLightsNotVisible)
    l.enabled = false;

  foreach(Light l in minimapLightsNoShadows)
    l.shadows = LightShadows.None;

  foreach(Light l in minimapLightsVisible)
    l.enabled = true;
}</pre></div><p>Finally, we have to do the opposite process in the <code class="literal">OnPostRender()</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">void OnPostRender(){
  foreach(Light l in minimapLightsNotVisible)
    l.enabled = true;
  
  foreach(Light l in minimapLightsNoShadows)
    l.shadows = LightShadows.Soft;
  
  foreach(Light l in minimapLightsVisible)
    l.enabled = false;
}</pre></div><p>However, there is still more about lighting for us to know. In this example, every time we put a light in one of the three arrays, it will be enabled and disabled — every time in the same way. For instance, suppose that we have a light that is turned on or off during runtime in the game environment. If we don't want to render it on the minimap, we include it in the <code class="literal">minimapLightsNotVisible</code> array. However, when <code class="literal">OnPostRender()</code> is called, it is turned on irrespective of what its state was before the rendering of the minimap. Therefore, a more<a id="id541" class="indexterm"></a> sophisticated implementation of this technique would include to store the original lighting of the scene in the <code class="literal">PreCull()</code> function, and then to restore it back into the <code class="literal">PostRender()</code> function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec94"></a>Ideas for implementing the minimap in closed environments</h4></div></div></div><p>In a closed environment, this<a id="id542" class="indexterm"></a> minimap might not work. For instance, there is a multi-storeyed building, and ideally we wish to render on the minimap the floor where the player currently is. Otherwise, our icon could also be hidden by other elements. Therefore, we have to use layers to hide different parts of the building and change the <span class="strong"><strong>Culling Mask</strong></span> of <span class="strong"><strong>MinimapCamera</strong></span> at runtime. Another solution is to use different cameras and then switch between them every time the player goes to a new floor. In this case, it's preferable to keep all the other cameras that are not in use disabled, for performance reasons.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec95"></a>Other techniques for minimaps</h4></div></div></div><p>Of course, the<a id="id543" class="indexterm"></a> techniques that are explained here are not the only ways to implement a minimap. This section is aimed at giving you an idea about other ways to implement minimaps.</p><p>If our graphics team has drawn the levels' schematics, we can use them to implement a minimap. Here, instead of using another camera, we can use these level schematics along with a mask, as we did before in this recipe by shaping the map as a circle. The main issue here is to move and rotate the picture according to where the player is. However, the limitation here is that this is hard when the map keeps changing over time. For instance, if we want to display moving platforms, we have to link them with other pictures or icons in the minimap and move them with respect to the main map schematics. The advantage in this case is performance, since we don't have to render what appears in the minimap frame by frame. Furthermore, the aesthetic aspect of the level schematics as a minimap could have a nicer result than the realistic look of a map with a top view. In addition, if we implement this system in Unity, we don't need <span class="strong"><strong>Render Textures</strong></span>, and therefore we don't necessarily require Unity Pro.</p><p>Another technique is a mix of the following two: one technique that you learned in this chapter, using another camera for a minimap; and the previous one, using level schematics. The basic idea here is to render the top view of the map only once, in order to keep the top view of the map and make gains in performance. So, we can take pictures of the map from the top view by setting all the layers, merge them into a unique picture, and use that one as level schematics with the previous technique.</p><p>In both of these implementations, we have to consider how to properly include icons on the minimap. This is because their positions depend on the locations of objects or characters in the real world that they are representing. Again, if we use UI elements as icons, we have to properly position and rotate them on the minimap.</p><p>This helps us <a id="id544" class="indexterm"></a>understand that there isn't a single technique that is best; all of them have their own advantages and disadvantages, which have to been taken into consideration when we design our game. Thus, at this stage, we need to carefully choose the technique that better suits our needs.</p></div></div></div>