<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec45"></a>Creating an extendable element with a final fade effect</h2></div></div><hr /></div><p>In this recipe, you <a id="id245" class="indexterm"></a>will learn how to create an extendable UI element with a final fade effect. These kinds of decorative elements are<a id="id246" class="indexterm"></a> useful in the background with smaller graphics such as nice images or simple shapes. Often, they are used in main or pause menus in order to make the background dynamic and give more life to the menu. Additional techniques about how to animate the menu itself can be found in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Animating the UI</em></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec120"></a>How to do it...</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First of all, we need to create a UI element. In this example, we will use a square, but you can also use a decorative star or another shape that you prefer. To do this, right-click on the <span class="strong"><strong>Hierarchy</strong></span> panel and then navigate to <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Image</strong></span>. Rename it to <span class="strong"><strong>Extendable Element</strong></span>. Of course, it is possible to resize, change the source image, and place an image that we have chosen.</p></li><li><p>Next, we need to create a script that extends our image on the screen and gradually decreases<a id="id247" class="indexterm"></a> the alpha channel of the color. By decreasing the alpha channel, it<a id="id248" class="indexterm"></a> will begin to fade away. So, let's go to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>New Script</strong></span> and name it to <span class="strong"><strong>ExtendableElementScript</strong></span>. Then click on <span class="strong"><strong>Create and Add</strong></span>.</p></li><li><p>Now, double-click on the script in order to edit it. Since we are going to use the <code class="literal">Image</code> class, we have to add the <code class="literal">using UnityEngine.UI;</code> statement again at the beginning of the script. Before the beginning of the class, we can add this line: <code class="literal">[RequireComponent(typeof(Image))]</code> (without the semicolon at the end). By doing this, we are saying that in order to use this script, it requires an <span class="strong"><strong>Image</strong></span> component that is attached to the same game object of this script. In addition, this prevents designers from using this script without an <span class="strong"><strong>Image (Script)</strong></span> component.</p></li><li><p>We need two public variables to be shown in the <span class="strong"><strong>Inspector</strong></span> so that designers can tweak them, one for the speed and another for the amount of time the UI element continues to expand before it is destroyed. Thus, we can add the following lines to our script:</p><div class="informalexample"><pre class="programlisting">public float speed;
public float surviveTime;</pre></div></li><li><p>Furthermore, we need three private variables, two of them to keep track of the <code class="literal">RectTransform</code> component, and the third one to keep track of the original <code class="literal">SizeDelta</code> without seeking it every time. In addition, a couple of other variables are used to accumulate the time for every frame. So let's add the following:</p><div class="informalexample"><pre class="programlisting">private float x, y;
private RectTransform rectTransform;
private Vector2 originalSizeDelta;</pre></div></li><li><p>As usual, in the <code class="literal">Start()</code> function, we will store the reference of the game elements inside our variables. We assign <code class="literal">RectTransform</code>, attached to the same game object in which this script is placed, by calling the <code class="literal">GetComponent&lt;RectTransform&gt;()</code> function, to the <code class="literal">rectTransform</code> variable. Furthermore, we will set the <code class="literal">originalSizeDelta</code> variable. Therefore, we can write this code:</p><div class="informalexample"><pre class="programlisting">rectTransform = GetComponent&lt;RectTransform&gt; ();
originalSizeDelta = rectTransform.sizeDelta;</pre></div></li><li><p>Inside the <code class="literal">Start()</code> function, we have to start the fade effect by calling <code class="literal">CrossFadeAlpha()</code> and then passing some parameters. One is the final alpha value, which is <code class="literal">0f</code> in this case. Another is the time of the fading, which in this case is the<a id="id249" class="indexterm"></a> entire span of time before the object is destroyed:</p><div class="informalexample"><pre class="programlisting">GetComponent&lt;Image&gt;().CrossFadeAlpha(0f, surviveTime, false);</pre></div></li><li><p>In the last line<a id="id250" class="indexterm"></a> of the <code class="literal">Start()</code> function, we call the <code class="literal">GameObject.Destroy()</code> function to destroy the game object in which this script is attached after the time that we have specified in the <span class="strong"><strong>Inspector</strong></span> through the <code class="literal">surviveTime</code> variable:</p><div class="informalexample"><pre class="programlisting">GameObject.Destroy(gameObject, surviveTime);</pre></div></li><li><p>Now, in the <code class="literal">Update()</code> function, we have to increase the <code class="literal">x</code> and <code class="literal">y</code> variables by the time from the last frame multiplied by the speed. Finally, we set new <code class="literal">sizeDelta</code> of <code class="literal">rectTransform</code> equal to a <code class="literal">Vector2</code> with <code class="literal">x</code> and <code class="literal">y</code> as coordinates plus <code class="literal">originalSizeDelta</code>:</p><div class="informalexample"><pre class="programlisting">x += speed * Time.deltaTime;
y += speed * Time.deltaTime;
rectTransform.sizeDelta = new Vector2(x, y) + originalSizeDelta;</pre></div></li><li><p>For the next step, we can save the script and come back to Unity. From the <span class="strong"><strong>Inspector</strong></span> window we can tweak <code class="literal">speed</code> and <code class="literal">surviveTime</code>. These values depend on what we are trying to achieve, but let's set them to 20 and 10 respectively. We can test the script and see whether everything works as it should. In this screenshot, we can see a frame of the effect:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_05_01.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec121"></a>How it works...</h3></div></div></div><p>In the <code class="literal">Start()</code> function, we launch two Unity coroutines. The first one is launched from the <code class="literal">GetComponent&lt;Image&gt;().CrossFadeAlpha(0f, surviveTime, false);</code> line, and the second one is launched from <code class="literal">GameObject.Destroy(gameObject, surviveTime);</code>.</p><p>The first coroutine<a id="id251" class="indexterm"></a> gradually changes the <code class="literal">Alpha</code> value to create the fade effect. The second destroys the game object when it is no<a id="id252" class="indexterm"></a> longer required. As a result, it improves the performance of our game, because the scene doesn't contain futile objects.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec122"></a>There's more...</h3></div></div></div><p>By changing this effect, it is possible to achieve very interesting variations of it. This is what we are going to learn in the following sections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec33"></a>Changing the speed for each axis</h4></div></div></div><p>We may want to<a id="id253" class="indexterm"></a> let designers customize the effect more, for instance, by having different speeds for each axis. In order to implement this, we need to modify our script. Instead of a common <code class="literal">speed</code> variable, we need a <code class="literal">speed</code> variable for each axis. Therefore, we need a couple of variables. So, let's consider this line:</p><div class="informalexample"><pre class="programlisting">public float speed;</pre></div><p>We replace it with these two lines:</p><div class="informalexample"><pre class="programlisting">public float speedX;
public float speedY;</pre></div><p>Now, in the <code class="literal">Update()</code> function, we have to change the way the <code class="literal">x</code> and <code class="literal">y</code> variables are updated. Thus, we can rewrite the code in the following way:</p><div class="informalexample"><pre class="programlisting">x += speedX * Time.deltaTime;
y += speedY * Time.deltaTime;</pre></div><p>When we do this, <a id="id254" class="indexterm"></a>
<code class="literal">x</code> and <code class="literal">y</code> change accordingly to different speeds. We can set the variables again in the <span class="strong"><strong>Inspector</strong></span> and check whether everything works.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec34"></a>Fade-in instead of Fade-out</h4></div></div></div><p>We may want to reverse the process and have an element that appears instead of one that fades away. This could <a id="id255" class="indexterm"></a>be a useful way of decorating our UIs differently. It is possible for us to mix the two ways in order to create a more decorative UI, where there are both elements that enter and elements that fade away. In order to do this, we need to change a couple of lines of code. Keep in mind that at the end, the object will be destroyed anyway.</p><p>First, we need to consider the <code class="literal">CrossFadeAlpha()</code> function:</p><div class="informalexample"><pre class="programlisting">GetComponent&lt;Image&gt;().CrossFadeAlpha(0f, surviveTime, false);</pre></div><p>Change it to these two lines:</p><div class="informalexample"><pre class="programlisting">GetComponent&lt;Image&gt;().CrossFadeAlpha(0f, 0f, false);
GetComponent&lt;Image&gt;().CrossFadeAlpha(1f, surviveTime, false);</pre></div><p>In order to understand the previous lines, we need to remember that the <code class="literal">CrossFadeAlpha()</code> function doesn't take care of the initial <code class="literal">Alpha</code> value of the <span class="strong"><strong>Canvas Renderer</strong></span> component. Therefore, the first function sets <span class="strong"><strong>Alpha</strong></span> of the <span class="strong"><strong>Canvas Renderer</strong></span> component to <code class="literal">0</code> immediately so that the image is not visible at the beginning. The second function increases the <code class="literal">Alpha</code> value until <code class="literal">1f</code> over the time specified in the <code class="literal">surviveTime</code> variable, creating the fade-in effect.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec123"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>We may want to increase the effectiveness of our effect by rotating the image while it is expanding. For this case, we are going to extend this script in the <span class="emphasis"><em>Creating an extendable and rotating element with a final fade effect</em></span> recipe.</p></li></ul></div></div></div>