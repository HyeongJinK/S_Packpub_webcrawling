<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec69"></a>Creating a directional radar</h2></div></div><hr /></div><p>Sometimes when <a id="id443" class="indexterm"></a>we play games, we want to know the direction of objects that may be out of view or not visible. A radar is a UI element that makes it possible for this to happen. There are many ways in which a radar can appear, but in this recipe, we will make a directional radar that will take the form of an arrow and show the player the direction of the target.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec194"></a>How to do it...</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's start by creating a new UI image that will be our arrow. Right-click on the <span class="strong"><strong>Hierarchy</strong></span> panel, navigate to <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Image</strong></span>, and rename it <span class="strong"><strong>RadarArrow</strong></span>. Of course, we can<a id="id444" class="indexterm"></a> place it wherever we want on the screen and then change the <span class="strong"><strong>Source Image</strong></span> to an arrow like this one:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_08_05.jpg" /></div><p>If you are using Photoshop, you can easily create this by using the custom shape tool. You can select it by pressing <span class="emphasis"><em>U</em></span> in the toolbox and <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>U</em></span> to cycle through the different shapes. Once the custom shape tool is selected, right-click to bring forth the shape selection panel. Select the arrow that you like. In this example, we selected the second arrow that was listed. Next, drag the arrow out onto the canvas while holding down the <span class="emphasis"><em>Shift</em></span> key in order to constrain the proportions. Now we have a basic arrow icon.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip40"></a>Tip</h3><p>Of course, it is possible to construct all the graphic components of the radar around this arrow, but remember that the arrow should still be visible on the top.</p></div></li><li><p>Our script will <a id="id445" class="indexterm"></a>control the rotation of the arrow according to the position of the target. Therefore, select <span class="strong"><strong>RadarArrow</strong></span>. In the <span class="strong"><strong>Inspector</strong></span>, go to <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>New Script</strong></span>, name it <span class="strong"><strong>SubtitleShowerScript</strong></span>, and then click on <span class="strong"><strong>Create and Add</strong></span>.</p></li><li><p>Double-click on the script in order to edit it. Since we are going to use the <code class="literal">Image</code> class every time we deal with the UI, we have to add the <code class="literal">using UnityEngine.UI;</code> statement at the beginning of the script.</p></li><li><p>Similar to what has been done in previous recipes, we need to store our UI element in a variable. In this case, we will need to store the <span class="strong"><strong>Image (Script)</strong></span> component. We can make this private, since we can set it in the <span class="strong"><strong>Start()</strong></span> function:</p><div class="informalexample"><pre class="programlisting">  private Image arrow;</pre></div></li><li><p>Next, we need to create a couple of variables so that we can store the transforms of <code class="literal">player</code> and <code class="literal">target</code>. Let's make these variables <code class="literal">public</code>, since we should set them in the <span class="strong"><strong>Inspector</strong></span>. So, let's add the following lines of code:</p><div class="informalexample"><pre class="programlisting">  public Transform player;
  public Transform target;</pre></div></li><li><p>In the <code class="literal">Start()</code> function, we have to get the value of our <code class="literal">arrow</code> variable, like this:</p><div class="informalexample"><pre class="programlisting">  void Start () {
    arrow = GetComponent&lt;Image&gt;();
  }</pre></div></li><li><p>Going further, in the <code class="literal">Update()</code> function we have to first calculate the projection of the position of the player on the floor, which is the <code class="literal">xz</code> plane. In fact, most 3D games use this plan as the floor, and we want our radar to detect as if it is looking at the scene from the top view. We can do this very easily just by changing the <code class="literal">y</code> component of the vector to zero (refer to the <span class="emphasis"><em>There's more...</em></span> section to see how to project it on different planes). Therefore, we use this code:</p><div class="informalexample"><pre class="programlisting">    Vector3 playerProjection = new Vector3 (player.position.x, 0, player.position.z);</pre></div></li><li><p>The same has to be done for the target position. Since considerations similar to the previous step are valid, we can write the following:</p><div class="informalexample"><pre class="programlisting">    Vector3 targetProjection = new Vector3 (target.position.x, 0, target.position.z);</pre></div></li><li><p>We also need to calculate the direction that the player is facing, because it will change the orientation of the radar, and again we have to project this on the floor. This time, we also have to normalize since it is a direction:</p><div class="informalexample"><pre class="programlisting">    Vector3 playerDir = (new Vector3 (player.forward.x, 0, player.forward.z).normalized);</pre></div></li><li><p>With the two <a id="id446" class="indexterm"></a>positions projected, we can also calculate the direction of the target relative to the player. So, we have to subtract the two position vectors and again normalize, because this is also a direction:</p><div class="informalexample"><pre class="programlisting">    Vector3 targetDir = (targetProjection - playerProjection).normalized;</pre></div></li><li><p>Now, the problem becomes a two-dimensional problem, but we still work with 3D vectors so that we do not lose generality just in case we change the projection plan (check out the <span class="emphasis"><em>There's more...</em></span> section).</p></li><li><p>The next thing to calculate is the angle between the two directions, and this can be achieved by calculating the arccosine of the dot product between the two direction vectors. Finally, we multiply everything with a constant to convert the angle from radians to degrees:</p><div class="informalexample"><pre class="programlisting">    float angle = Mathf.Acos(Vector3.Dot (playerDir, targetDir))*Mathf.Rad2Deg</pre></div></li><li><p>Since the calculated angle returns a value between <code class="literal">0</code> and <code class="literal">180</code> degrees, we still don't have enough information to know whether our radar has to turn clockwise or not. So, we have to distinguish two cases: whether the target is to the <span class="emphasis"><em>left</em></span> or to the <span class="emphasis"><em>right</em></span> of the player. If we perform the cross product between the two direction vectors and take the <code class="literal">y</code> coordinate to check whether it is negative, we can distinguish the two cases. Finally, we assign a rotation along the <code class="literal">z</code> axis to our arrow accordingly:</p><div class="informalexample"><pre class="programlisting">    if (Vector3.Cross (playerDir, targetDir).y &lt; 0){
      arrow.rectTransform.rotation = Quaternion.Euler (new Vector3 (0, 0, angle));
    } else {
      arrow.rectTransform.rotation = Quaternion.Euler (new Vector3 (0, 0, -angle));
    }</pre></div></li><li><p>We save the script and our work is done. We are yet to assign the target and player public variables. However, this will depend on how the game is structured. You can refer to the <span class="emphasis"><em>There's more...</em></span> section, in which a way of testing the radar is described. If you follow that example, the radar should appear like this:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_08_06.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec195"></a>How it works...</h3></div></div></div><p>If you do not <a id="id447" class="indexterm"></a>understand the concept of 3D geometry with vectors, this recipe may be a bit difficult to follow. However, the concepts covered in this section are not too difficult to work through, especially if we pay attention to the pictures.</p><p>We started by projecting both the player's position and the target's position, on the floor, like this:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_08_07.jpg" /></div><p>Next, we projected the direction<a id="id448" class="indexterm"></a> that the player is facing. We then called this projection vector <code class="literal">playerDir</code>. Calculating the direction of the target respective to the player is simple, since we can just take the difference between the two vectors and normalize. We called this vector <code class="literal">targetDir</code>.</p><p>Thus, we reduced the problem to just two dimensions. As a result, we only had to calculate the acute angle, theta, between <code class="literal">playerDir</code> and <code class="literal">targetDir</code>. It can be calculated as the arccosine of the dot product between the two vectors. Here is a diagram that shows the geometry of the player and the target:</p><div class="mediaobject"><img src="/graphics/9781785885822/graphics/B04903_08_08.jpg" /></div><p>Finally, we rotated the arrow of the radar accordingly, using theta.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec196"></a>There's more...</h3></div></div></div><p>As for the distance displayer, the following sections will teach us how to extend the directional radar to suit different situations that may happen in the design of the game, such as changing the projection plane.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec71"></a>Testing the script</h4></div></div></div><p>Even after we have<a id="id449" class="indexterm"></a> followed all the steps in this recipe, we are still not able to make it run, since this script works when it is integrated into a game. Hence, in order to test it, we need to construct a test scene. The one that is used in this example can be found in the resource bundle of this book. Otherwise, this can be done by placing a plane and then increasing the scale so that we can see it as the floor within the scene. Next, we can add a cube that represents our player and another cube that represents the target. Set the public variables by dragging both the cubes that you have created, and then click on play. If we move the two cubes in the scene in the <span class="strong"><strong>Scene</strong></span> view, we can see the radar reacting in the <span class="strong"><strong>Game</strong></span> view.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip41"></a>Tip</h3><p>We have projected all the vectors onto the <span class="emphasis"><em>xz</em></span> plane. So, if the target or the player changes position along the <span class="emphasis"><em>y</em></span> component, the radar isn't affected.</p></div><p>If we want to see the angles projected on the plane more clearly, just for debugging or learning purposes, we can use the <code class="literal">Gizmos</code> function to better observe this process. We can do this by moving the plane down a little and then adding this function to our script:</p><div class="informalexample"><pre class="programlisting">void OnDrawGizmos() {
  Gizmos.color = Color.red;
  Gizmos.DrawLine(new Vector3 (player.position.x, 0, player.position.z), new Vector3 (target.position.x, 0, target.position.z));
  Gizmos.color = Color.green;
  Gizmos.DrawRay (new Ray(new Vector3 (player.position.x, 0, player.position.z),(new Vector3 (player.forward.x, 0, player.forward.z).normalized)));
}</pre></div><p>It draws the two <a id="id450" class="indexterm"></a>directions <code class="literal">playerDir</code> and <code class="literal">targetDir</code> in the <span class="strong"><strong>Scene</strong></span> view.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec72"></a>Changing the projection plane</h4></div></div></div><p>Our game may have another floor that isn't the classical one that is found on the <code class="literal">xz</code> plane. For example, if it is a 2D game, the entire game is on another plane, or if the gravity of the <a id="id451" class="indexterm"></a>game changes at runtime, we should be able to change the projection plane accordingly.</p><p>If we only need to project onto the other two orthogonal planes, we just have to set the missing component to 0 (for example, in the <code class="literal">xz</code> plane, the missing component is <code class="literal">y</code>; in the <code class="literal">xy</code> plane, it is <code class="literal">z</code>). So, the two position projections along with the facing direction in the <code class="literal">xy</code> plane are as follows:</p><div class="informalexample"><pre class="programlisting">Vector3 playerProjection = new Vector3 (player.position.x, player.position.y, 0);
Vector3 targetProjection = new Vector3 (target.position.x, target.position.y, 0);
Vector3 playerDir = (new Vector3 (player.forward.x, player.forward.y, 0).normalized);</pre></div><p>And these are for the <code class="literal">yz</code> plane:</p><div class="informalexample"><pre class="programlisting">Vector3 playerProjection = new Vector3 (0, player.position.y, player.position.z);
Vector3 targetProjection = new Vector3 (0, target.position.y, target.position.z);
Vector3 playerDir = (new Vector3 (0, player.forward.y, player.forward.z).normalized);</pre></div><p>In general, as long as we have the normal of the plane where we want to project, we can use the following static function to project:</p><div class="informalexample"><pre class="programlisting">Vector3.ProjectOnPlane(vectorToProject, planeNormal)</pre></div><p>Of course, in all of these cases, we also have to change the check inside the <code class="literal">if</code> statement so that the arrow can<a id="id452" class="indexterm"></a> rotate in the right direction.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec73"></a>Closest target detection</h4></div></div></div><p>Since the part of the script that detects the closest target in a set is very similar to the script used in the previous recipe, inside the <span class="emphasis"><em>There's More...</em></span> section, we can just refer to it. This time, however, we don't<a id="id453" class="indexterm"></a> have to store the distance but the target itself, so we use the following code:</p><div class="informalexample"><pre class="programlisting">float distance = float.MaxValue;
Transform target;
foreach(Transform t in targets){
  if (distance &gt; Vector3.Distance (player.position, t.position)){
    distance = Vector3.Distance (player.position, t.position);
    target = t;
  }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec74"></a>Adding a delay in the radar through a coroutine</h4></div></div></div><p>Again, the modification for <a id="id454" class="indexterm"></a>adding a delay in the radar is very similar to one in the previous chapter, so just revisit that section to learn how to implement the coroutine.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec75"></a>More ideas on how to use the radar</h4></div></div></div><p>The directional radar<a id="id455" class="indexterm"></a> can be used in a number of different ways, such as detecting enemies in shooter games or assisting the player in locating treasure in platform games, especially if we integrate it with a <span class="strong"><strong>Distance Displayer</strong></span>. Since this radar shows only the direction and not the distance, we can provide the player with an option to choose a <span class="strong"><strong>Distance Displayer</strong></span> or a <span class="strong"><strong>Directional Radar</strong></span>. Furthermore, we can incorporate both of them together in order to provide the player with more powerful equipment.</p><p>Lastly, we can consider implementing a 3D directional radar. In it, the arrow can rotate in all directions to point towards the target. In this case, we don't need to project the vectors, but we should be careful while calculating all the angles in order to rotate the arrow properly.</p></div></div></div>