<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec39"></a>Decisions and On-Demand Decision Making</h2></div></div><hr /></div><p>You may have noticed while playing the soccer (football) game in the previous exercise that the game went into slow motion at times. This is because the agent brains were consuming too much processing power, thus slowing the game's frame rate. This can be a problem, as we have seen from several agents running. The <span>reason</span><a id="id324673124" class="indexterm"></a> for this is that we are currently letting the agent/brains make a decision every five frames, or 1/12 second. While this is great for training, in a real game, we likely want our agents to respond at the same speed as a human would. This can remove the issue of performance since the agents now decide much less frequently. We can tune this using a feature called <span class="strong"><strong>On-Demand Decision Making</strong></span> and <span class="strong"><strong>Decision Frequency</strong></span>. Open up Unity to the last Soccer example we used and follow this exercise:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Load up the <strong class="userinput"><code>SoccerTwos</code></strong> scene from the <code class="literal">Assets/ML-Agents/Examples/Soccer/Scenes</code> folder.</li><li>Locate the <span class="strong"><strong>Players/Striker</strong></span> object in the <span class="strong"><strong>Hierarchy</strong></span> window and select it.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Find the <span class="strong"><strong>Decision Frequency</strong></span> property and <span>change</span><a id="id324673593" class="indexterm"></a> it from <code class="literal">5</code>, as shown in the following screenshot, to another value, up or down:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789138139/graphics/377398c7-2613-4b18-b4ea-402a106476ad.png" /></div><p>Setting the Decision Frequency to a different value</p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>A value of 5 means the agent will act or decide every five frames. At 60 frames per second, this represents a reaction time of 1/12 a second or <code class="literal">.083</code> seconds, which is a little quick for a person. Human reaction times can vary by age, sex, and many other factors, but for our purposes, we want to use a value of <code class="literal">.25</code> to <code class="literal">.5</code> seconds.</li><li>Set the <span class="strong"><strong>Decision Frequency</strong></span> property to <code class="literal">30</code>, as this will represent a reaction time of <code class="literal">.5</code> seconds.</li><li>Open up the <span class="strong"><strong>Goalie</strong></span> and <span class="strong"><strong>Goalie(1)</strong></span> agents and set them to use a value of <code class="literal">30</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Open the <span class="strong"><strong>Striker(1)</strong></span> agent and set its <span class="strong"><strong>Decision Frequency</strong></span> property to <code class="literal">1</code>. Remember: this is our player agent, and we don't want to hinder its reaction time, since we want to compare our own reactions to that of the agents.</li><li>Press the Play button to run the scene and play the game with the <span class="strong"><strong>WASD</strong></span> keys. Do you notice anything different?</li></ol></div><p>Yeah, you likely won't immediately notice any big differences. As the game plays out, you may notice that the game stays fairly fluid and doesn't slow down, but more importantly, the agents appear to react at the same speed. While we changed the reaction time to be 6x slower, the agents still appear to react at the same speed. This is mostly due to our perception of the situation, but the important take away is to train with low decision frequency and play at high decision frequency. In the next section, we will look at another technique that gives us more control on when decisions are made.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec35"></a>The Bouncing Banana</h3></div></div></div><p>If you want to be more accurate in a simulation or game, you may <span>want</span><a id="id325402757" class="indexterm"></a> to set different reaction times for different input signals or events. For instance, you may only want an agent to react after it hits an object or trigger, thus not requiring the agent brain to react to a null input. Unity implemented a feature in ML-Agents called On-Demand Decision Making, which allows an agent to wait before making a decision. Unity, of course, has a sample for this, so let's open up the editor and follow this exercise:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Locate and open the <span class="strong"><strong>Bouncer</strong></span> scene in the <code class="literal">Assets/ML-Agents/Examples/Bouncer</code> folder.</li><li>Find and select the <span class="strong"><strong>BouncerBrain</strong></span> in the <span class="strong"><strong>Hierarchy</strong></span> window. Set the <span class="strong"><strong>Brain Type</strong></span> to <span class="strong"><strong>Internal</strong></span> and make sure the <span class="strong"><strong>Graph Model</strong></span> is set to a <span class="strong"><strong>TextAsset</strong></span> bytes file.</li><li>Press the Play button to run the scene and watch the agent jump for the banana.</li></ol></div><p>The last example, while quick, was a great example of <strong class="userinput"><code>On-Demand Decision</code></strong><strong class="userinput"><code>Making</code></strong>. The agent in this example has the following set on the <strong class="userinput"><code>Bouncer Agent</code></strong> script, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789138139/graphics/aaad0b27-bc4e-447f-8a54-6bc7dde67848.png" /></div><p>
Setting an On-Demand Decision property on the Agent</p><p>When using <strong class="userinput"><code>On-Demand Decisions</code></strong>, we need to <span>invoke</span><a id="id325405972" class="indexterm"></a> a request called <code class="literal">RequestDecision</code> in our C# agent code. Let's see what this looks like by taking a close look at the <code class="literal">BouncerAgent</code> script and the <code class="literal">FixedUpdate</code> method, as shown in the following code:</p><pre class="programlisting"> private void FixedUpdate()
 {
   if ((Physics.Raycast(transform.position, new Vector3(0f,-1f,0f), 0.51f))
     &amp;&amp; jumpCooldown &lt;= 0f)
   {
<span class="strong"><strong>RequestDecision();</strong></span>
     jumpLeft -= 1;
     jumpCooldown = 0.1f;
     rb.velocity = default(Vector3);
   }
   jumpCooldown -= Time.fixedDeltaTime;
   if (gameObject.transform.position.y &lt; -1)
   {
     AddReward(-1);
     Done();
     return;
   }
   if ((gameObject.transform.localPosition.x &lt; -19)
     ||(gameObject.transform.localPosition.x &gt;19)
     || (gameObject.transform.localPosition.z &lt; -19)
     || (gameObject.transform.localPosition.z &gt; 19))
   {
   AddReward(-1);
   Done();
   return;
   }

   if (jumpLeft == 0)
   {
     Done();
   }
   bodyObject.transform.rotation = Quaternion.Lerp(bodyObject.transform.rotation,
   Quaternion.LookRotation(lookDir),
   Time.fixedDeltaTime * 10f);
 }</pre><p>The first line in <code class="literal">FixedUpdate</code> checks to see if the game object is close to the floor using <code class="literal">Physics.Raycast</code> by using a downward pointing vector <code class="literal">(0,-1,0)</code> to a distance of <code class="literal">.51</code> units, making sure that the <code class="literal">jumpCooldown</code> is less than <code class="literal">0</code>. When the agent gets close to the ground and has done waiting for the <code class="literal">jumpCooldown</code> time, it calls <code class="literal">RequestDecision()</code> which signals to the brain that it is time to make a decision. While the brain is set to use <span class="strong"><strong>On-Demand</strong></span> decisions, the brain will not act until a <code class="literal">RequestDecision</code> is called.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip28"></a>Note</h3><p><code class="literal">FixedUpdate</code>, if you are less familiar with Unity, is the method that gets called for each physics time update and is tied to the physics update cycle. This is different than the <code class="literal">Update</code> method, which gets called for each render frame. The difference is subtle but you generally want to put collision detection code in <code class="literal">FixedUpdate</code>.</p></div><p>The rest of the code in <code class="literal">FixedUpdate</code> checks to see if the agent has fallen off the platform. If it has, then the episode resets. Otherwise, the agent will rotate in the orientation of the look direction (<code class="literal">lookDir</code>), which we set earlier in the script. If you are having trouble following the rest of the code, then you will need to brush up on your C# and Unity programming skills.</p><p>On-Demand decisions are an excellent way to both manage multiple agent's performance and give your agents more realistic behaviors. One of the things you need to keep in mind when building agents is how they actually interact with other players or, possibly, agents. Being able to tune decision frequency and timing are powerful features that we will spend more time on in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Terrarium Revisited â€“ A Multi-Agent Ecosystem</em></span>.</p><p>In the next section, we get back into introducing more <span>interesting</span><a id="id325408542" class="indexterm"></a> training techniques where we will train an agent by letting them imitate our actions.</p></div></div>