<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl2sec19"></a>Implementing the snap to grid behaviour</h2></div></div><hr /></div><p>To create our first level in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Editor Scripting</em></span>, we used a hot key to snap the level piece prefabs between them. Here, we will do the same, but instead of using<a id="id74" class="indexterm"></a> the hot key, the level piece prefabs are going to snap to the grid automatically.</p><p>Here, we will assume that the <code class="literal">Level</code> game object position and rotation is always (0,0,0) and the scale is (1,1,1). Also, the <span class="strong"><strong>2D mode</strong></span> is selected by default.</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_02_21.jpg" /></div><p>Later, we will work on how keep this configuration by default. Based on the grid we created, we need to implement a few things to achieve our goal:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>A way to convert 3D coordinates to grid coordinates and vice versa</p></li><li style="list-style-type: disc"><p>A way to know when these coordinates are outside the boundaries of the grid</p></li></ul></div><p>Inside the <code class="literal">Level</code> class, add the following methods in the <code class="literal">Level.cs</code> script:</p><div class="informalexample"><pre class="programlisting">public Vector3 WorldToGridCoordinates(Vector3 point) {
  Vector3 gridPoint = new Vector3(
  (int)((point.x - transform.position.x) / GridSize) ,
  (int)((point.y - transform.position.y) / GridSize), 0.0f);
  return gridPoint;
}
    
public Vector3 GridToWorldCoordinates(int col, int row) {
  Vector3 worldPoint = new Vector3(
  transform.position.x + (col * GridSize + GridSize / 2.0f),
  transform.position.y + (row * GridSize + GridSize / 2.0f),
        0.0f);
  return worldPoint;
}
public bool IsInsideGridBounds(Vector3 point) {
  float minX = transform.position.x;
  float maxX = minX + _totalColumns * GridSize;
  float minY = transform.position.y;
  float maxY = minY + _totalRows * GridSize;
  return (point.x &gt;= minX &amp;&amp; point.x &lt;= maxX &amp;&amp; point.y &gt;= minY &amp;&amp; point.y &lt;= maxY);
}
public bool IsInsideGridBounds(int col, int row) {
  return (col &gt;= 0 &amp;&amp; col &lt; _totalColumns &amp;&amp; row &gt;= 0 &amp;&amp; row &lt; _totalRows);
}</pre></div><p>The <code class="literal">WorldToGridCoordinates</code> method receives a <code class="literal">Vector3</code> point and returns a <code class="literal">Vector3</code> where <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> correspond to the <code class="literal">col</code> and <code class="literal">row</code> coordinates in the grid (a <code class="literal">Vector3</code> was used in order to avoid the creation of a new struct).</p><p>The <code class="literal">GridToWorldCoordinates</code> method receives a <code class="literal">col</code> and <code class="literal">row</code> position of the grid and returns a <code class="literal">Vector3</code> corresponding to the world coordinates (assuming <span class="emphasis"><em>z</em></span> = 0). The <code class="literal">IsInsideGridBounds</code> method has two different signatures. One receives a </p><p>
<code class="literal">Vector3</code> point and returns <code class="literal">true</code> if the coordinates <code class="literal">col</code> and <code class="literal">row</code> are inside the grid. The other one does the same but instead of a vector, receives a grid coordinate (<code class="literal">col</code>, <code class="literal">row</code>).</p><p>We will start using these methods intensively soon, but for now, just to verify these work properly, let's create a script called <code class="literal">SnapToGridTest.cs</code> with the following code (you can discard this script at the end of this chapter):</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using RunAndJump;

[ExecuteInEditMode]
public class SnapToGridTest: MonoBehaviour {
        
    private void Update () {
        Vector3 gridCoord = Level.Instance.WorldToGridCoordinates (transform.position);
        transform.position = Level.Instance.GridToWorldCoordinates((int)gridCoord.x, (int) gridCoord.y);
    }
        
    private void OnDrawGizmos () { 
        Color oldColor = Gizmos.color;
        Gizmos.color = (Level.Instance.IsInsideGridBounds (transform.position)) ? Color.green : Color.red;
        Gizmos.DrawCube (transform.position, Vector3.one * Level.GridSize);
        Gizmos.color = oldColor;
    }
}</pre></div><p>The <code class="literal">SnapToGridTest.cs</code> file renders a gizmo cube on the <span class="strong"><strong>Scene</strong></span> <span class="strong"><strong>View</strong></span>; this will change the color based on its position. With a reference to the level script, the <code class="literal">SnapToGridTest</code> method will be green if its position is contained by the grid, and red if the opposite happens.</p><p>In the <code class="literal">Update</code> function, we adjusted the position of the game object so it remains snapped to<a id="id75" class="indexterm"></a> the grid cells. We added a special<a id="id76" class="indexterm"></a> attribute before the class declaration called <code class="literal">ExecuteInEditMode</code>. This attribute allows the <code class="literal">Update</code> function to be called, even when the editor is not in play mode.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note08"></a>Note</h3><p>By default, script components are only executed in play mode. By adding the attribute <code class="literal">ExecuteInEditMode</code>, each script component will also have its callback functions executed while the Editor is not in Play mode. Be careful: the expected behavior have differences compared to the same script running in Play mode, for example, the <code class="literal">Update</code> function is only called when something in the scene is changed. To get more information about this, visit the <a id="id77" class="indexterm"></a>following link:</p><p>
<a class="ulink" href="http://docs.unity3d.com/ScriptReference/ExecuteInEditMode.html" target="_blank">http://docs.unity3d.com/ScriptReference/ExecuteInEditMode.html</a>
</p></div><p>Wait for Unity to compile the script and then, with the <code class="literal">Level</code> game object in the scene, add a few game objects with the <code class="literal">SnapToGridTest.cs</code> script attached inside the <code class="literal">Level</code> game object.</p><p>Start moving the <code class="literal">SnapToGridTest</code> game objects inside and outside the grid with the mouse, you will notice that the boundary detection works and changes the color of the gizmo cube while always snapping to the grid:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_02_22.jpg" /></div><p>Well <a id="id78" class="indexterm"></a>done! We've finished our gizmo grid feature.</p></div>