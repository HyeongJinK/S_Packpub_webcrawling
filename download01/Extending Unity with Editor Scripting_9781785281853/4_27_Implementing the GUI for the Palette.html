<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec29"></a>Implementing the GUI for the Palette</h2></div></div><hr /></div><p>In this section, we<a id="id167" class="indexterm"></a> will add our custom GUI and functionalities to the Palette window.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec38"></a>Creating tabs</h3></div></div></div><p>We want to use the <a id="id168" class="indexterm"></a>category names as labels for a set of tabs in the Palette window. When we select one of these tabs, only the level piece prefabs of the selected category will be displayed.</p><p>We will create a method called <code class="literal">GetListFromEnum</code>. This will help us to easily list enums for further use. Let's add this method inside the <code class="literal">EditorUtils</code> class:</p><div class="informalexample"><pre class="programlisting">public static List&lt;T&gt; GetListFromEnum&lt;T&gt; () {
    List&lt;T&gt; enumList = new List&lt;T&gt; ();
    System.Array enums = System.Enum.GetValues (typeof(T));
    foreach (T e in enums) { 
        enumList.Add (e);
    }
    return enumList;
}</pre></div><p>The method receives an enum type as a generic type and returns a list with all the enum values in it.</p><p>Now, to create the GUI for the tabs, we need to make a few updates in the <code class="literal">PaletteWindow.cs</code> script, as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using UnityEditor;
<span class="strong"><strong>using System.Collections.Generic;</strong></span>

namespace RunAndJump.LevelCreator {
    public class PaletteWindow : EditorWindow {
<span class="strong"><strong>    private List&lt;PaletteItem.Category&gt; _categories;</strong></span>
<span class="strong"><strong>    private List&lt;string&gt; _categoryLabels;</strong></span>
<span class="strong"><strong>    private PaletteItem.Category _categorySelected;</strong></span>
  
// Rest of the codeâ€¦
}
}</pre></div><p>Now, we <a id="id169" class="indexterm"></a>initialize these variables in the <code class="literal">OnEnable</code> method:</p><div class="informalexample"><pre class="programlisting"> private void OnEnable() {
  if (_categories == null) {
      InitCategories ();
    }
}

private void InitCategories () {
  Debug.Log ("InitCategories called...");
  _categories = EditorUtils.GetListFromEnum&lt;PaletteItem.Category&gt; ();
  _categoryLabels = new List&lt;string&gt; ();
  foreach (PaletteItem.Category category in _categories) {
    _categoryLabels.Add (category.ToString ());
  }
}</pre></div><p>Here, we get and save the categories using a string array; this will be used to set up the labels of the tabs.</p><p>Create a new method called <code class="literal">DrawTabs</code> and add the following:</p><div class="informalexample"><pre class="programlisting">private void DrawTabs () {
    int index = (int)_categorySelected;
    index = GUILayout.Toolbar (index, _categoryLabels.ToArray ());
    _categorySelected = _categories [index];
  }</pre></div><p>Here, we use the class GUI to render a toolbar. This GUI component is an array of buttons; depending on the button you press, the number representing that button is returned.</p><p>Now, let's add a reference of this method inside the <code class="literal">OnGUI</code> method:</p><div class="informalexample"><pre class="programlisting">private void OnGUI() {
    DrawTabs();
}</pre></div><p>Now, save and wait for Unity to compile. If the Palette window is open, close it. Then, go to the Level Creator menu and click on <span class="strong"><strong>Show Palette</strong></span>.</p><p>You will see the following:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_04_10.jpg" /></div><p>You will<a id="id170" class="indexterm"></a> see the tabs working, and each time you press a tab, the category is saved in the variable <code class="literal">_categorySelected</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec39"></a>Creating a scrollable area</h3></div></div></div><p>In the space<a id="id171" class="indexterm"></a> we are not using for the tabs, we will present all the available level piece prefabs of the selected category. As the number of prefabs can be huge, we will model this as a scrollable area.</p><p>Before we create the scrollable area, we need to define a few variables inside the <code class="literal">PaletteWindow</code> class:</p><div class="informalexample"><pre class="programlisting">private string _path = "Assets/Prefabs/LevelPieces";
private List&lt;PaletteItem&gt; _items;
private Dictionary&lt;PaletteItem.Category, List&lt;PaletteItem&gt;&gt; _categorizedItems;
private Dictionary&lt;PaletteItem, Texture2D&gt; _previews;
private Vector2 _scrollPosition;
private const float ButtonWidth = 80;
private const float ButtonHeight = 90;</pre></div><p>The <code class="literal">_path</code> variable defines where the Palette window will search the level piece prefabs. In this case, we will in <code class="literal">Assets/Prefabs/LevelPieces</code>.</p><p>We also created two dictionaries, which are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">_categorizedItems</code>: This is where the keys are the category and the values are lists of the <code class="literal">PaletteItem</code> class instances</p></li><li style="list-style-type: disc"><p>
<code class="literal">_previews</code>: This is where the keys are the <code class="literal">PaletteItem</code> class and the value is a Texture2D that represents the preview of the item</p></li></ul></div><p>Again, all the initialization will occur inside the <code class="literal">OnEnable</code> method:</p><div class="informalexample"><pre class="programlisting">private void OnEnable () {
    // Debug.Log("OnEnable called...");
    if (_categories == null) {
        InitCategories ();
    }
    if (_categorizedItems == null) {
        InitContent ();
    }
}
private void InitContent () {
    Debug.Log ("InitContent called...");
    // Set the ScrollList
    _items = EditorUtils.GetAssetsWithScript&lt;PaletteItem&gt; (_path);
    _categorizedItems = new Dictionary&lt;PaletteItem.Category, List&lt;PaletteItem&gt;&gt; ();
    _previews = new Dictionary&lt;PaletteItem, Texture2D&gt; ();
    // Init the Dictionary
    foreach (PaletteItem.Category category in _categories) {
        _categorizedItems.Add (category, new List&lt;PaletteItem&gt; ());
    }
    // Assign items to each category 
    foreach (PaletteItem item in _items) {
        _categorizedItems [item.category].Add (item);
    }
}</pre></div><p>To explain<a id="id172" class="indexterm"></a> how to implement the scrollable area, we will use a top-down approach. So, let's start by defining the method responsible for drawing this. Create a method called <code class="literal">DrawScroll</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">private void DrawScroll () {
    if (_categorizedItems [_categorySelected].Count == 0) {
        EditorGUILayout.HelpBox ("This category is empty!", MessageType.Info);
        return;
    }
    int rowCapacity = 
        Mathf.FloorToInt (position.width / (ButtonWidth));
    _scrollPosition = 
        GUILayout.BeginScrollView (_scrollPosition);
    int selectionGridIndex = -1;
    selectionGridIndex = GUILayout.SelectionGrid (
        selectionGridIndex,
        GetGUIContentsFromItems (), 
        rowCapacity, 
        GetGUIStyle ());
    GetSelectedItem (selectionGridIndex);
    GUILayout.EndScrollView ();
}</pre></div><p>In this method, we first check whether the current category has level piece prefabs, if isn't, a text <span class="strong"><strong>This category is empty</strong></span> is displayed.</p><p>To render a <a id="id173" class="indexterm"></a>grid of elements inside a scrollable area, we use the following methods:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">BeginScrollView</code> and <code class="literal">EndScrollView</code>: These methods are used to define the scrollable area</p></li><li style="list-style-type: disc"><p>
<code class="literal">SelectionGrid</code>: This method is used to generate a grid of buttons</p></li></ul></div><p>By default, the <code class="literal">SelectionGrid</code> method creates a group of buttons that behaves like toggle buttons and the index (from 0 to n-1, where n is the total of elements) of the button selected is returned. To avoid the toggle behavior, we always clean the index returned. So, we save the result in the <code class="literal">selectionGridIndex</code> variable, but we always set this to <code class="literal">-1</code> before passing it again to the method.</p><p>We are going to use the class <code class="literal">AssetPreview</code>, part of the <code class="literal">UnityEditor</code> namespace, to automatically create the previews of the level piece prefabs.</p><p>The <code class="literal">GetAssetPreview</code> method returns a Texture2D representing the preview of a game object. This means that if the game object changes, its representation in the Palette will change too.</p><p>Add a new method called <code class="literal">GeneratePreviews</code> with the following code:</p><div class="informalexample"><pre class="programlisting">private void GeneratePreviews () {
    foreach (PaletteItem item in _items) {
        if (!_previews.ContainsKey (item)) {
            Texture2D preview = AssetPreview.GetAssetPreview (item.gameObject);
        if (preview != null) {
          _previews.Add (item, preview);
      }
    }
  }
}</pre></div><p>This preceding code could be called in the <code class="literal">OnEnable</code> method; the problem appears when you restart Unity. In this process, all the previews are generated in the Unity editor and there is a huge probability that the previews won't be available when you call the <code class="literal">OnEnable</code> method.</p><p>It's because of this that we will place the <code class="literal">GeneratePreviews</code> method inside the <code class="literal">Update</code> method, checking constantly until we get the previews. The following is the <code class="literal">Update</code> method:</p><div class="informalexample"><pre class="programlisting">private void Update () {
            if (_previews.Count != _items.Count) {
                GeneratePreviews ();
            }
        }</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>To get more<a id="id174" class="indexterm"></a> information about the <code class="literal">AssetPreview</code> class, visit <a class="ulink" href="http://docs.unity3d.com/ScriptReference/AssetPreview.html" target="_blank">http://docs.unity3d.com/ScriptReference/AssetPreview.html</a>.</p></div><p>To define<a id="id175" class="indexterm"></a> the elements of the <code class="literal">SelectionGrid</code> GUI, we created two auxiliary methods in the <code class="literal">PaletteWindow</code> class. The first method is <code class="literal">GetGUIContentsFromItems</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private GUIContent[] GetGUIContentsFromItems () {
    List&lt;GUIContent&gt; guiContents = new List&lt;GUIContent&gt; ();
    if(_previews.Count == _items.Count) {
        int totalItems = _categorizedItems [_categorySelected].Count;
        for (int i = 0; i &lt; totalItems; i ++) {
            GUIContent guiContent = new GUIContent ();
            guiContent.text = _categorizedItems [_categorySelected] [i].itemName;
            guiContent.image = _previews [_categorizedItems [_categorySelected] [i]];
            guiContents.Add (guiContent);
        }
    }
    return guiContents.ToArray ();
}</pre></div><p>We use a <code class="literal">GUIContent</code> object to create a button that have with the label and an image. The data for the label comes from the <code class="literal">PaletteItem</code> class and the image from the dictionary that we created in the <code class="literal">OnEnable</code> method.</p><p>This method takes care of including in the array only the <code class="literal">GUIContent</code> instances related to the level pieces prefabs available in the current category.</p><p>The second auxiliary method is <code class="literal">GetGUIStyle</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private GUIStyle GetGUIStyle () {
      GUIStyle guiStyle = new GUIStyle (GUI.skin.button);
      guiStyle.alignment = TextAnchor.LowerCenter;
      guiStyle.imagePosition = ImagePosition.ImageAbove;
      guiStyle.fixedWidth = ButtonWidth;
      guiStyle.fixedHeight = ButtonHeight;
      return guiStyle;
    }</pre></div><p>We use <a id="id176" class="indexterm"></a>an instance of the class <code class="literal">GUIStyle</code> parameter to change how the button looks (we will talk more about this in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Changing the Look and Feel of the Editor with GUI Styles and GUI Skins</em></span>).</p><p>By default, a button will place the label and image, respectively, in a horizontal way. Here, we change this to place the image over the label and also to centrally align the text of that label.</p><p>Finally, in order to know which piece was selected in the Palette, we created a method called <code class="literal">GetSelectedItem</code> that converts the index returned by the <code class="literal">SelectionGrid</code> GUI component to a level piece:</p><div class="informalexample"><pre class="programlisting">private void GetSelectedItem (int index) {
            if (index != -1) {
                PaletteItem selectedItem = 
                    _categorizedItems [_categorySelected] [index];
                Debug.Log ("Selected Item is: " + 
                    selectedItem.itemName);
}</pre></div><p>Now, the last thing to do is to add <code class="literal">DrawScroll</code> to the <code class="literal">OnGUI</code> method:</p><div class="informalexample"><pre class="programlisting">private void OnGUI() {
    DrawTabs();
    DrawScroll();
}</pre></div><p>After saving and waiting for Unity to compile, go to the <span class="strong"><strong>Level Creator</strong></span> menu and click on <span class="strong"><strong>Show Palette</strong></span> (if the Palette is open, close it and open it again):</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_04_11.jpg" /></div><p>Now, all the level pieces inside the path <code class="literal">Assets/Prefabs/LevelPieces</code> appear in the Palette. You don't need to navigate across the project hierarchy to find them. If you click on a <a id="id177" class="indexterm"></a>tab, only the pieces of that category are displayed.</p><p>If you select a category without level pieces, you will see something like this:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_04_12.jpg" /></div><p>A text indicates that the category is empty. Now, if we change the category of all the level pieces to Misc, we will see a crowd category, but the scroll area handles the overflow adding a scrollbar to navigate:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_04_13.jpg" /></div><p>We have the Palette window up and running. Now, we need to integrate this to the rest of the Level Creator tool. In the final part of this chapter, we will work on the integration of this<a id="id178" class="indexterm"></a> editor window with the custom inspector we created in the previous chapter.</p></div></div>