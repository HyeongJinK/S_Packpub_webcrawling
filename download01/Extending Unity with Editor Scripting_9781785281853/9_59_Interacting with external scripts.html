<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec56"></a>Interacting with external scripts</h2></div></div><hr /></div><p>In this section, you <a id="id365" class="indexterm"></a>will learn how to call bash scripts from Unity and how to integrate this to our pipeline.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p>The examples here are using bash scripts (OS X). You can extend these to be used on Windows by your own</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec75"></a>Displaying the build information in the video game</h3></div></div></div><p>We will add a<a id="id366" class="indexterm"></a> tiny text in the title screen containing two things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Hash</strong></span>: This corresponds to the commit used to create the build</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Date</strong></span>: This corresponds to the date on which the build is created</p></li></ul></div><p>This information, which we will call the build info, will be updated every time you create a new build.</p><p>If you start the <a id="id367" class="indexterm"></a>game in the Title scene, you will see a little text <span class="strong"><strong>Build Info</strong></span> in the top-left corner </p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_09_11.jpg" /></div><p>Let's replace this text. First, create a new script called <code class="literal">BuildInfo.Autogenerated.cs</code> inside <code class="literal">Tools/AppBuilder/Scripts</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">namespace AppBuilder {	
  public class BuildInfo {
    public const string Hash = "";
    public const string Date = "";
  }
}</pre></div><p>Now, open the <code class="literal">TitleScene.cs</code> script and overwrite the method <code class="literal">SetBuildInfo</code> as follows:</p><div class="informalexample"><pre class="programlisting">private void SetBuildInfo() {
  string info = "";
  info += "Hash: " + AppBuilder.BuildInfo.Hash +"\n";
  info += "Date: " + AppBuilder.BuildInfo.Date;
  BuildInfoText.text = info;
}</pre></div><p>If you run the video game, you will see the labels for the <span class="strong"><strong>Hash</strong></span> and the <span class="strong"><strong>Date</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_09_12.jpg" /></div><p>Obtaining <a id="id368" class="indexterm"></a>the date is easy, but for the Git hash, we will use an external script.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec76"></a>Using the bash script in our pipeline</h3></div></div></div><p>Unity<a id="id369" class="indexterm"></a> doesn't allow us to create text files that are not meant to be used as C# or JavaScript scripts, so access the folder <code class="literal">Assets/Tools/Bash</code> from outside and create a new text file called <code class="literal">mac_githash.sh</code> and add the following code to the file:</p><div class="informalexample"><pre class="programlisting">#! /usr/bin/env sh

SHORT_HASH="$( git log --pretty=format:'%h' -n 1 )"
echo $SHORT_HASH</pre></div><p>This script grabs the current commit hash and returns a short version of it. So, instead of 40 characters, this will return something like <code class="literal">4cd9c3a</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"></a>Note</h3><p>You must give execution permission to this script in order to make it work.</p></div><p>To use and call these kinds of scripts from Unity, we will create a utility method that receives the path from the script and parameters, if necessary.</p><p>Inside the <code class="literal">Builder</code> class, add the following method:</p><div class="informalexample"><pre class="programlisting">private static string ExecuteCommand (
  string command, string arguments = "") {
    System.Diagnostics.Process pProcess = new
    System.Diagnostics.Process ();
    pProcess.StartInfo.FileName = command;
    pProcess.StartInfo.Arguments = arguments;
    pProcess.StartInfo.UseShellExecute = false;
    pProcess.StartInfo.RedirectStandardOutput = true;
    pProcess.Start ();
    string strOutput = pProcess.StandardOutput.ReadToEnd ();
    pProcess.WaitForExit ();
    return strOutput;
  }
)</pre></div><p>In this <a id="id370" class="indexterm"></a>method we use the <code class="literal">Process</code> class, which is part of the .Net API. This provides access to local and remote processes and enables you to start and stop local system processes.</p><p>Basically, we are creating a <code class="literal">Process</code> instance here, setting its properties, and finally executing it. If there is any kind of output, that will be returned by the method as a string.</p><p>For each bash script we want to use, we must use this method to integrate it with our editor scripting code.</p><p>Still in the <code class="literal">Builder</code> class, we now create a new method to wrap the scripts we created in the folder <code class="literal">Bash</code>:</p><div class="informalexample"><pre class="programlisting">private static string batchPath = Application.dataPath + "/Tools/AppBuilder/Bash";

private static string GitHash () {
  string command = batchPath + "/mac-githash.sh";
  string output = ExecuteCommand (command);
  // We trim the output to remove new lines at the end.
  return output.Trim();
}</pre></div><p>Now, getting the Git hash is transparent for the rest of the tool because all the interactions with script are encapsulated.</p><p>Remember the <code class="literal">BuildInfo.Autogenerated.cs</code> script we created at the beginning? The main idea for that class is to be overwritten in the pipeline process with the following method:</p><div class="informalexample"><pre class="programlisting">private static void GenerateBuildInfo () {
  string content = "";
  string hash = GitHash();
  string date = System.DateTime.Now.ToString();;
  content += "namespace AppBuilder {\n";
  content += "\tpublic class BuildInfo {\n";
  content += string.Format("\t\tpublic const string Hash = \"{0}\";\n", hash);
  content += string.Format("\t\tpublic const string Date = \"{0}\";\n", date);
  content += "\t}";
  content += "}";

  string buildInfoPath = Application.dataPath + "/Tools/AppBuilder/Scripts/BuildInfo.Autogenerated.cs";
  System.IO.File.WriteAllText (buildInfoPath, content);
}</pre></div><p>As we have<a id="id371" class="indexterm"></a> two assemblies, one for the Editor and another for the video game, we can make modifications of this kind in the code of the video game using an Editor script without problem. The class modification will happen before compiling the video game.</p><p>Update the <code class="literal">Build</code> method:</p><div class="informalexample"><pre class="programlisting">public static void Build(BuildTarget target, string buildName) {
  BuildSettings.UpdateSettings();
<span class="strong"><strong>  GenerateBuildInfo ();</strong></span>
  string[] scenes = GetEnabledScenes();
  string buildFullPath;

  buildFullPath = buildFolderPath + "/" + target + "/" + buildName;
  BuildPipeline.BuildPlayer (scenes, buildFullPath, target, BuildOptions.None);
}</pre></div><p>Now, repeat the process to generate a new build and run it. You will see the build info on the video game title scene:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_09_13.jpg" /></div><p>In the next <a id="id372" class="indexterm"></a>section, we will continue using a part of the tools we created here. However, we will now focus on adding distribution to the build pipeline.</p></div></div>