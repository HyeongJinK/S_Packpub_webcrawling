<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec21"></a>Creating a custom inspector</h2></div></div><hr /></div><p>In this section, we <a id="id90" class="indexterm"></a>will create the base structure to start using custom <a id="id91" class="indexterm"></a>inspectors in our project.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec21"></a>Using the CustomEditor attribute</h3></div></div></div><p>The <code class="literal">CustomEditor</code> attribute is part of the <code class="literal">UnityEditor</code> namespace and is the way Unity <a id="id92" class="indexterm"></a>binds an editor script with a specific type of <a id="id93" class="indexterm"></a>the <code class="literal">MonoBehaviour</code> class to modify the way the default inspector works.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>To use the <code class="literal">CustomEditor</code> attribute, you must place your script inside an <code class="literal">Editor</code> folder, or in a folder nested inside an <code class="literal">Editor</code> folder.</p></div><p>Create a script called <code class="literal">LevelInspector.cs</code> inside the folder <code class="literal">Tools\LevelCreator\Editor</code>, and then add the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using UnityEditor;

namespace RunAndJump.LevelCreator {
    [CustomEditor(typeof(Level))]
    public class LevelInspector : Editor {
    
    }
}</pre></div><p>The attribute <code class="literal">CustomEditor</code> expects a type. In this case, we passed the type Level. Doing this, you will overwrite the inspector of all the <code class="literal">Level</code> class instances in Unity.</p><p>Your must extend from the <code class="literal">Editor</code> class and in this way you will have access to all the methods and properties to create custom inspectors.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p>When you create a custom inspector for a type of class, if you try to select several instances in the editor to make changes at the same time, Unity will not allow you to do so. To support multi-object editing, you must use the <code class="literal">CanEditMultipleObjects</code> attribute. Add this before the class declaration. In this case, we will have just one <code class="literal">Level</code> class instance at a time, so this is not necessary.</p></div><p>Save and wait <a id="id94" class="indexterm"></a>for Unity to compile the script. Once it finishes, you will not see any visual difference.</p><p>Don't worry, breathe deeply and relax; this was expected. We did the base setup but we aren't doing anything to overwrite the normal behavior of the inspector. In the next section, we will <a id="id95" class="indexterm"></a>explore the methods to get a working custom inspector.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec22"></a>Playing with the inspector message methods and target variable</h3></div></div></div><p>Like <a id="id96" class="indexterm"></a>the <code class="literal">Awake</code>, <code class="literal">Update</code>, and <code class="literal">OnDestroy</code> methods in the <code class="literal">MonoBehaviour</code> classes, known as the message methods, inspectors have their own ones to handle similar kind of actions inherited from the <code class="literal">Editor</code> class.</p><p>Let's implement these in our <code class="literal">LevelInspector</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using UnityEditor;

namespace RunAndJump.LevelCreator {
    [CustomEditor(typeof(Level))]
    public class LevelInspector : Editor {

        private Level _myTarget;

        private void OnEnable () {
            Debug.Log ("OnEnable was called...");
            _myTarget = (Level)target;
        }
        
        private void OnDisable () {
            Debug.Log ("OnDisable was called...");
        }
        
        private void OnDestroy () {
            Debug.Log ("OnDestroy was called...");
        }
        
        public override void OnInspectorGUI () {
            EditorGUILayout.LabelField ("The GUI of this inspector was modified.");
            EditorGUILayout.LabelField ("The current level time is: " + _myTarget.TotalTime);
        }
    }
}</pre></div><p>The <code class="literal">OnEnable</code> method is called every time the inspected object is selected. This is a good place for all the initialization code.</p><p>The <a id="id97" class="indexterm"></a>
<code class="literal">OnDisable</code> method is called when the inspected object goes out of scope. This is also called when the object is destroyed and can be used for any cleanup code.</p><p>The <code class="literal">OnDestroy</code> method is called when the inspected object will be destroyed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"></a>Note</h3><p>When scripts are reloaded after the compilation has finished, <code class="literal">OnDisable</code> is called, followed by <code class="literal">OnEnable</code> after the script has been loaded.</p></div><p>The <code class="literal">Editor</code> class has a variable called <code class="literal">target</code>. This variable has a reference to the object inspected and it is used to access the properties of that object and to manipulate them in the custom inspector.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>If your script supports multi-object editing, you must use <code class="literal">targets</code> instead of <code class="literal">target</code>. This will return a Unity object array with all the objects being inspected.</p></div><p>Because <code class="literal">target</code> returns a Unity object, we must cast this to a Level type to access the public methods and variables of the inspected object. We will save this reference in the variable <code class="literal">_myTarget</code> and do the initialization inside the <code class="literal">OnEnable</code> method.</p><p>The last method we need to implement is <code class="literal">OnInspectorGUI</code>. In this method, you can add methods to render the inspector GUI. This one must to be overridden in order to work and you need to keep the access modifier as public.</p><p>As an example, we added two labels to the inspector, and in the second one, we used the <code class="literal">_myTarget</code> variable to access the <code class="literal">TotalTime</code> property of the inspected <code class="literal">Level</code> class.</p><p>This is how our inspector looks now:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_03_06.jpg" /></div><p>Good <a id="id98" class="indexterm"></a>work! In the next section, we will continue working in the GUI for this custom inspector.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>If you want to check more <a id="id99" class="indexterm"></a>about the <code class="literal">Editor</code> class, visit: <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Editor.html" target="_blank">http://docs.unity3d.com/ScriptReference/Editor.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>Adding the GUI elements</h3></div></div></div><p>Before we <a id="id100" class="indexterm"></a>start working in the new GUI, let's see how to make this custom inspector render the default GUI. Let's update the <code class="literal">OnInspectorGUI</code> method:</p><div class="informalexample"><pre class="programlisting">public override void OnInspectorGUI () {
    DrawDefaultInspector();
}</pre></div><p>Save and wait for Unity to compile the script. The <code class="literal">DrawDefaultInspector</code> method will display the default GUI on the inspector.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip08"></a>Tip</h3><p>You can use this method to help you debug your custom inspector for troubleshooting.</p></div><p>We want to split the task of creating this custom inspector in two parts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Data</strong></span>: This part exposes the total time, gravity, BGM, and background variables.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>The Resize feature</strong></span>: This part has the necessary GUI to allow a game designer to resize the level.</p></li></ul></div><p>Let's start with the first part. In the <code class="literal">LevelInspector</code> class, we will modify the <code class="literal">OnInspectorGUI</code> method again and use a new method created by us called <code class="literal">DrawLevelDataGUI</code>:</p><div class="informalexample"><pre class="programlisting">public override void OnInspectorGUI () {
  // DrawDefaultInspector();
  DrawLevelDataGUI ();
}

private void DrawLevelDataGUI () {
  EditorGUILayout.LabelField ("Data", EditorStyles.boldLabel);
  _myTarget.TotalTime = EditorGUILayout.IntField ("Total Time", Mathf.Max (0, _myTarget.TotalTime));
  _myTarget.Gravity = EditorGUILayout.FloatField ("Gravity", _myTarget.Gravity);
  _myTarget.Bgm = (AudioClip)EditorGUILayout.ObjectField ("Bgm", _myTarget.Bgm, typeof(AudioClip), false);
  _myTarget.Background = (Sprite)EditorGUILayout.ObjectField ("Background", _myTarget.Background, typeof(Sprite), false);
}</pre></div><p>The <code class="literal">EditorGUILayout</code> class has several methods to draw an editor GUI. All the methods in this class adapt automatically to the inspector following layout restrictions. You will <a id="id101" class="indexterm"></a>find similar methods in the <code class="literal">EditorGUI</code> class, but the difference is that, on this class, you must specify the rectangle that will contain the GUI element for each one of its methods.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>The <a id="id102" class="indexterm"></a>
<code class="literal">EditorGUILayout</code> and <code class="literal">EditorGUI</code> classes are too <a id="id103" class="indexterm"></a>big to be covered thoroughly in this book, so check the following URLs to get an idea about the options these classes gives us:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://docs.unity3d.com/ScriptReference/EditorGUILayout.html" target="_blank">http://docs.unity3d.com/ScriptReference/EditorGUILayout.html</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://docs.unity3d.com/ScriptReference/EditorGUI.html" target="_blank">http://docs.unity3d.com/ScriptReference/EditorGUI.html</a>
</p></li></ul></div></div><p>We used the <code class="literal">EditorGUILayout</code> class to create several fields. Let's review these:</p><p>
<code class="literal">LabelField</code> was used to display a label with the text data. As a second parameter, we passed a variable from the class <code class="literal">EditorStyles</code> to change the style of the font used by the label - bold style (in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Changing the Look and Feel of the Editor with GUI Styles and GUI Skins</em></span> we will talk more about how to change the look and feel of our tools).</p><p>The <code class="literal">IntField</code> and <code class="literal">FloatField</code> methods work in the same way: both show an editable text field that allows only integers and floats.</p><p>The first parameter is the label for the field and the second one is a reference to the variable used to extract the value displayed in the field. The methods return an integer and a float, respectively; so, you can use these values to overwrite the variables inspected.</p><p>
<code class="literal">ObjectField</code> method is used for objects and requires the type of the object and a Boolean used as a flag to specify whether objects on the scene can be added to this field or not. In our case, we don't require that. The returning value must to be casted.</p><p>Save the <a id="id104" class="indexterm"></a>changes and go back to Unity. Create a new level scene and you should see the following:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_03_07.jpg" /></div><p>If you try to change the <span class="strong"><strong>Total Time</strong></span> field to a negative value, the inspector is not going to allow you because we used the method <code class="literal">Max</code> from the class <code class="literal">Mathf</code> to always guarantee that <code class="literal">TotalTime</code> will be equal to or greater than 0. This means, with a custom inspector, we can improve the validation of all the parameters our game object or component is going to use.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>Implementing the resize feature</h3></div></div></div><p>To start, add the following two variables to the <code class="literal">LevelInspector</code> class:</p><div class="informalexample"><pre class="programlisting">private int _newTotalColumns;
private int _newTotalRows;</pre></div><p>These variables are going to be used to save the new Level size values to previsualize the changes. As soon we decide to proceed with the change, we will update the values <code class="literal">TotalColumns</code> and <code class="literal">TotalRows</code> and do the changes to the <code class="literal">Pieces</code> array.</p><p>The <code class="literal">LevelInspector</code> class will be responsible for the initialization of the <code class="literal">Pieces</code> array because we want to make this happen in an editor context.</p><p>In the <code class="literal">LevelInspector</code> class, create two methods called <code class="literal">InitLevel</code> and <code class="literal">ResetResizeValues</code>. These are going to be called inside the <code class="literal">OnEnable</code> method:</p><div class="informalexample"><pre class="programlisting">private void OnEnable () {
    // Debug.Log ("OnEnable was called...");
    _myTarget = (Level)target;
    InitLevel ();
    ResetResizeValues ();
}

private void InitLevel () {    
    if (_myTarget.Pieces == null || _myTarget.Pieces.Length == 0) {
        Debug.Log("Initializing the Pieces array...");
        _myTarget.Pieces = new LevelPiece[ _myTarget.TotalColumns * _myTarget.TotalRows];
    }
}

private void ResetResizeValues () {
    _newTotalColumns = _myTarget.TotalColumns;
    _newTotalRows = _myTarget.TotalRows;
}</pre></div><p>Now, to <a id="id105" class="indexterm"></a>do the resize, we need to change the length of the <code class="literal">Pieces</code> array and remove all the <code class="literal">LevelPiece</code> instances out of level bounds, destroying the prefab associated to the instances. We will add this in the <code class="literal">LevelInspector</code> class using the name <code class="literal">ResizeLevel</code>:</p><div class="informalexample"><pre class="programlisting">private void ResizeLevel () {
    LevelPiece[] newPieces = new LevelPiece[_newTotalColumns * _newTotalRows];
    for (int col = 0; col &lt; _myTarget.TotalColumns; ++col) {
        for (int row = 0; row &lt; _myTarget.TotalRows; ++row) {
            if (col &lt; _newTotalColumns &amp;&amp; row &lt; _newTotalRows) {
                newPieces [col + row * _newTotalColumns] =
                    _myTarget.Pieces [col + row * _myTarget.TotalColumns];
            } else {
                LevelPiece piece = _myTarget.Pieces [col + row * _myTarget.TotalColumns];
                if (piece != null) {
                    // we must to use DestroyImmediate in a Editor context
                    Object.DestroyImmediate (piece.gameobject);
                }
            }
        }
    }
    _myTarget.Pieces = newPieces;
    _myTarget.TotalColumns = _newTotalColumns;
  _myTarget.TotalRows = _newTotalRows;
}</pre></div><p>With the <a id="id106" class="indexterm"></a>logic done, in the next section, we will implement the GUI we are missing, which is necessary to make the resize.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"></a>Using buttons to trigger actions</h3></div></div></div><p>In the <a id="id107" class="indexterm"></a>
<code class="literal">LevelInspector</code> class, we will modify the <code class="literal">OnInspectorGUI</code> method, adding a new method created by us, called <code class="literal">DrawLevelSizeGUI</code>:</p><div class="informalexample"><pre class="programlisting">public override void OnInspectorGUI () {
      // DrawDefaultInspector();
      DrawLevelDataGUI ();
      DrawLevelSizeGUI ();
    }
private void DrawLevelSizeGUI () {
  EditorGUILayout.LabelField ("Size", EditorStyles.boldLabel);
  _newTotalColumns = EditorGUILayout.IntField ("Columns", Mathf.Max (1, _newTotalColumns));
  _newTotalRows = EditorGUILayout.IntField ("Rows", Mathf.Max (1, _newTotalRows));
  // with this variable we can enable or disable GUI
  bool oldEnabled = GUI.enabled;
  GUI.enabled = (_newTotalColumns != _myTarget.TotalColumns || _newTotalRows != _myTarget.TotalRows);
  bool buttonResize = GUILayout.Button ("Resize", GUILayout.Height (2 * EditorGUIUtility.singleLineHeight));
  if (buttonResize) {
    if (EditorUtility.DisplayDialog (
      "Level Creator", 
      "Are you sure you want to resize the level?\nThis action cannot be undone.",
      "Yes", 
      "No")) {
      ResizeLevel ();
    }
  }
    bool buttonReset = GUILayout.Button ("Reset");
    if (buttonReset) {
        ResetResizeValues ();
    }
    GUI.enabled = oldEnabled;
}</pre></div><p>The beginning of the code is pretty similar to the <code class="literal">DrawLevelDataGUI</code> method; the only difference is the usage of the method <code class="literal">Button</code> from the class <code class="literal">GUILayout</code>.</p><p>
<code class="literal">Button</code> is a method that renders a Button. To check whether the user is clicking on the button, we need to evaluate this method, returning true when clicked, false in other cases.</p><p>Here, two <a id="id108" class="indexterm"></a>buttons were created, the first one with the name <code class="literal">Resize</code>, which will display a popup dialog if clicked on, thanks to the method <code class="literal">DisplayDialog</code> from the class <code class="literal">EditorUtility</code>. If the level designer clicks on <code class="literal">Yes</code>, the method <code class="literal">ResizeLevel</code> will be called.</p><p>The second button called <code class="literal">Reset</code> restores the variables <code class="literal">_newTotalColumns</code> and <code class="literal">_newTotalRows</code> to match the <code class="literal">TotalColumns</code> and <code class="literal">TotalRows</code> values, respectively.</p><p>As it makes no sense to press the <code class="literal">Resize</code> or <code class="literal">Reset</code> buttons if the values for the columns or the rows don't differ, we will disable the buttons using the variable <code class="literal">enabled</code> from the class GUI.</p><p>If <code class="literal">GUI.enabled</code> is false, all the interactive GUI components, such as buttons, will be disabled; the opposite happens when it is true. Remember to always save the original value and then restore it when you are done.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"></a>Note</h3><p>As you may have noticed, you have more classes to get GUI stuff related than <code class="literal">EditorGUI</code> and <a id="id109" class="indexterm"></a>
<code class="literal">EditorGUILayout</code>; you will be able to use <code class="literal">GUI</code> and <code class="literal">GUILayout</code> too. To learn more about these two classes, visit the following <a id="id110" class="indexterm"></a>two websites:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://docs.unity3d.com/ScriptReference/GUI.html" target="_blank">http://docs.unity3d.com/ScriptReference/GUI.html</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://docs.unity3d.com/ScriptReference/GUILayout.html" target="_blank">http://docs.unity3d.com/ScriptReference/GUILayout.html</a>
</p></li></ul></div></div><p>At this point, the aspect of the inspector will be as follows:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_03_08.jpg" /></div><p>The buttons <a id="id111" class="indexterm"></a>are disabled by default until you change the values of the <span class="strong"><strong>Column</strong></span> or <span class="strong"><strong>Row</strong></span> fields:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_03_09.jpg" /></div><p>If you click on <span class="strong"><strong>Resize</strong></span>, the following popup will appear:</p><div class="mediaobject"><img src="/graphics/9781785281853/graphics/B04640_03_10.jpg" /></div><p>If you click on <span class="strong"><strong>Yes</strong></span>, the array of pieces will be updated, but unless you move the mouse cursor over the Scene View, you will still see the level grid without any size change.</p><p>This happens because, when you pass the mouse over the Scene View, you force the redrawing of the visible elements. We need to force this in order to make the resize functionality look correct.</p><p>To do this, we will use the flag <code class="literal">changed</code> for the class <code class="literal">GUI</code>. This will be true if there is any change to the <a id="id112" class="indexterm"></a>Inspector GUI. Let's update the <code class="literal">OnInspectorGUI</code> function again:</p><div class="informalexample"><pre class="programlisting">public override void OnInspectorGUI () {
    // DrawDefaultInspector();
    DrawLevelDataGUI ();
    DrawLevelSizeGUI ();
    
    if(GUI.changed) {
        EditorUtility.SetDirty(_myTarget);
    }
}</pre></div><p>The <code class="literal">SetDirty</code> object, part of the <code class="literal">EditorUtility</code> class, marks the target object as dirty. Unity internally uses the dirty flag to find out when assets have changed and need to be saved to disk; and also, because of this, forces the <code class="literal">Level</code> class to be redrawn.</p><p>We have implemented all the functionality we required. In the rest of this chapter, we will continue working on the GUI.</p></div></div>