<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="11lvl1sec70"></a>Audio optimization tips and tricks for Unity</h2></div></div><hr /></div><p>Now that we understand how to profile the <span>audio</span> performance system, we can more easily identify our potential problem areas. Keep in mind though, that not everything may be an issue and quite often fixing an issue in one area may cause problems in others. This is why you should constantly go back and profile the audio system with every optimization you perform. What you may see is that not every tip or trick works the way you think it should or the fix may be more costly in other areas.</p><p>As we mentioned in the first section, our primary interest will be in optimizing audio system memory and effects of DSP CPU usage. Therefore, we will break up both of these topics into sub-sections and start with audio memory optimization in the next section.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="11lvl2sec31"></a>Memory optimization tips and tricks</h3></div></div></div><p>In the previous profiling section, we <span>observed</span> a static usage of audio memory, which is very good. Yet, what if we wanted to deploy this same game to a mobile platform and needed to cut down on memory? Fortunately, there are a few tricks we can use in order to reduce the memory footprint of our audio clips in memory usage and on disk. We will review a few of those options and the trade-offs in the following exercise:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open up Unity and open the <code class="literal">Assets/Audio/Ambient</code> folder in the <strong class="userinput"><code>Project</code></strong> window. Select the <code class="literal">lake-shore-waves2</code> audio clip. Then select the <strong class="userinput"><code>Inspector</code></strong> window and change the <strong class="userinput"><code>Load Type</code></strong> to <strong class="userinput"><code>Streaming</code></strong> as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781787286450/graphics/8c34a219-a898-4291-ac5b-5fd146b3801b.png" /></div><p>Changing the Load Type on an audio clip resource</p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Then, click on the <strong class="userinput"><code>Apply</code></strong> button to apply the changes to the resource. Locate the <code class="literal">viking_music</code> clip in the <code class="literal">Assets/Audio/Music</code> folder in the <strong class="userinput"><code>Project</code></strong> window. Select the clip and change the <strong class="userinput"><code>Load Type</code></strong> to <strong class="userinput"><code>Streaming</code></strong>, just as you did with the previous clip.
</li></ol></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Press play to run the scene and <span>open</span> the <strong class="userinput"><code>Profiler</code></strong> window. Notice now how the memory usage has been cut by more than half. However, you will also notice that the <code class="literal">Streaming CPU</code> stat is now showing a value that is affecting our total CPU usage as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781787286450/graphics/9a9f0ebb-4ec6-4ae1-86e1-3019b3d61f8d.png" /></div><p>Profiling the audio system after making changes to the resources</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note187"></a>Note</h3><p>As you can see in the screenshot, that while we reduced memory usage by more than half, we also increased the CPU usage. This is one of those trade-offs you need to be aware of. In this case, changing the resources to streaming would likely not be a good choice.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Go back to each of the audio clip resources you changed to Streaming and reset them back to <strong class="userinput"><code>Decompress On Load</code></strong> and make the changes as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781787286450/graphics/4ab8c78d-cf32-4524-aa5b-a80f44949deb.png" /></div><p>Resetting the audio clip to Decompress On Load and reducing the Quality</p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Click on the <strong class="userinput"><code>Apply</code></strong> button and notice how this changes the <strong class="userinput"><code>Imported Size</code></strong>. Be sure to do this for both of the clips.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note188"></a>Note</h3><p>This is an extreme example where we are trying to reduce the file size as much as possible. In most cases, you may not want to reduce the Sample Rate as much.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Run the scene again and <span>again</span> bring up the <strong class="userinput"><code>Profiler</code></strong> window. You will now see the audio memory usage is half of what it was and there is no Streaming CPU usage. The trade-off here is the drastic reduction in the quality of the audio. Although, if you closely listen to the lake waves sound before and after the quality reduction, it will be difficult to tell there is a difference with all the other audio playing.
</li></ol></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Locate the <code class="literal">grunt</code> audio clip in the <code class="literal">Assets/Audio/Direct</code> folder in the <strong class="userinput"><code>Project</code></strong> window and select it. Then, in the Inspector window, change the <strong class="userinput"><code>Compression Format</code></strong> to <strong class="userinput"><code>PCM</code></strong> and click on <strong class="userinput"><code>Apply</code></strong>. Notice, as shown in the following sample screenshot, how the <strong class="userinput"><code>Imported Size</code></strong> changes:</li></ol></div><div class="mediaobject"><img src="/graphics/9781787286450/graphics/43f375d2-9841-48ab-9737-cc781215fdfa.png" /></div><p>Changing the compression settings for the grunt audio clip</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note189"></a>Note</h3><p>Converting an audio clip, such as the grunt sound effect, to use a different compression format, is an excellent way to reduce memory usage. When this clip was imported, it used the default of vorbis. Vorbis is a good format for medium and long playing clips, but is not well suited to short clips.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Run the scene again and see if you can notice a difference in audio memory.</li><li>After you are done testing, stop the scene.</li></ol></div><p>What we just <span>demonstrated</span> is a few ways in which we can reduce the memory footprint of audio resources. While there are more strategies to reduce the memory and CPU usage of audio resources, it becomes a balancing act on when to use them and for what type of audio. For instance, certain types of audio will work better with different strategies and the following table breaks this down for us:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Resource Type</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Usage</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Strategy</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Notes</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Ambient sounds or music</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Continuously playing and medium to long in length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Load Type :</strong></span> Streaming</p><p><span class="strong"><strong>Compression Format :</strong></span> Vorbis</p></td><td style="border-bottom: 0.5pt solid ; "><p>Constantly loads the resource from disk. Low memory footprint but at the cost of Streaming CPU. Works well if the audio clip is especially large and playing constantly.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Ambient sounds, sound effects, instruments, music, or vocals</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Rarely played but requires quick playback, medium to long in length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Load Type :</strong></span> Compressed in memory</p><p><span class="strong"><strong>Compression Format :</strong></span> Vorbis</p><p><span class="strong"><strong>Quality :</strong></span> Less than 100</p></td><td style="border-bottom: 0.5pt solid ; "><p>Compresses the audio clip in memory. Reduction in memory footprint but at a cost of CPU. A good strategy for medium to large audio clips that need to play rarely but quickly.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Ambient sounds or music</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Audio quality is not critical and medium to long in length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Load Type :</strong></span> Decompress On Load</p><p><span class="strong"><strong>Compression Format :</strong></span> PCM or ADPCM</p><p><span class="strong"><strong>Sample Rate Setting :</strong></span> Override sample rate</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reducing the quality of audio in order to save disk space and memory. A fallback strategy to use when you need to reduce platform deployment size. Depending on the audio and where it is used, this may be a good option.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sound effects or instrument loops</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Frequently played and short in length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Load Type :</strong></span> Decompress On Load</p><p><span class="strong"><strong>Compression Format :</strong></span> PCM</p></td><td style="border-bottom: 0.5pt solid ; "><p>PCM will load without any compression and play very quickly. In most cases, you will want to change all your imported short clips to use this setting.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sound effects or instruments</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Frequently played but medium in length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Load Type:</strong></span> Compressed in Memory</p><p><span class="strong"><strong>Compression Format :</strong></span> ADPCM</p></td><td style="border-bottom: 0.5pt solid ; "><p>ADPCM will create files 3-4x smaller than PCM. The file is compressed in memory, so it will consume CPU to play, but much less than Vorbis.</p><p>Try using this setting on the four instrument looping sounds we used for the adaptive music vertical remix.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Sound effects</p></td><td style="border-right: 0.5pt solid ; "><p>Rarely played and short in length</p></td><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Load Type :</strong></span> Compressed in Memory</p><p><span class="strong"><strong>Compression Format :</strong></span> ADPCM</p></td><td style=""><p>Since the files are rarely played, it is better to use compression and suffer a small CPU penalty when playing.</p></td></tr></tbody></table></div><p>Use the preceding table as a guide to adjusting the resource audio clip settings in order to improve your game's memory usage. If you are struggling with which strategy to use, try a couple of different ones and constantly profile the results. It may also be helpful in some instances to profile audio clip settings in isolated scenes. That way you can more easily determine the impact your changes make. In the next section, we will look at how we can optimize effects for better performance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="11lvl2sec32"></a>Effects optimization tips and tricks</h3></div></div></div><p>During the <span>previous</span> profiling exercise, we noticed a significant use in DSP CPU, which as shown is a result of mixing effects and other signal processing. Unfortunately, unlike the memory optimization strategies we looked at in the last section, strategies for optimizing effects are more cut and dry. This means that, in most cases, if effect performance is a concern, you may need to remove those offending effects entirely. Another option is choosing to use another DAW tool saw as Reaper to premix the audio or another audio system such as FMOD.</p><p>Since we have already covered how to identify and disable problem effects, we will focus on the standard list of Audio Mixer effects in the following table and possible tips and/or tricks for optimizing performance:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Effect Type</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Examples</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Tips/Tricks</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Notes</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3D Spatial</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Audio source 3D spatializer</p><p>Occulus spatializer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Limits the number of audio sources using this effect.</p><p>Changes the <strong class="userinput"><code>MaxDistance</code></strong> on the Audio Source 3D Sound Settings to a lower value.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Most developers may forget that this an effect that requires DSP.</p><p>You will almost never want to go with the default <strong class="userinput"><code>MaxDistanc</code></strong>e of <code class="literal">500</code> for the standard Audio Source.</p><p>The larger the effect distance, the longer this effect will consume DSP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Frequency Filter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Lowpass (simple)</p><p>Highpass (simple)</p><p>ParamEQ</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Limits the use of these effects to dynamic or script controlled.</p><p>Balances or filters the audio before importing as a resource.</p></td><td style="border-bottom: 0.5pt solid ; "><p>These effects can be quickly abused as a way to fix poor audio resources.</p><p>Still very useful effects for dynamic scripting or vertical remixing.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Delay</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SFXReverb</p><p>Echo</p><p>Chorus</p><p>Flange</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Routes multiple groups through a return with a single delay effect.</p><p>Limits the use to one delay effect per mix if possible.</p></td><td style="border-bottom: 0.5pt solid ; "><p>These are generally the most expensive effects and SFXReverb is at the top of the list.</p><p>Use them sparingly and try to send multiple groups through the same effect.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Compression</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Normalize</p><p>Compressor</p><p>Duck volume</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Routes these effects through a return when possible.</p></td><td style="border-bottom: 0.5pt solid ; "><p>If you are using Compressor and Normalize to fix vocals or other sounds, consider doing that offline in another DAW before importing.</p><p>Duck volume is expensive so when possible route multiple groups through the same effect.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bypass</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Send</p><p>Receive</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Useful for processing multiple groups through the same effect.</p></td><td style="border-bottom: 0.5pt solid ; "><p>Remember that a Send effect duplicates the signal, which creates additional DSP usage. Yet, this may be a good trade-off if routing multiple sources to a delay effect.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Snapshot</p></td><td style="border-right: 0.5pt solid ; "><p>Snapshot</p></td><td style="border-right: 0.5pt solid ; "><p>Limits the number of parameters being set within a snapshot to only what is needed.</p></td><td style=""><p>Transitioning snapshots can be expensive if you have multiple parameters and have chosen non-linear transition methods.</p></td></tr></tbody></table></div><p>Take your time <span>reviewing</span> the preceding table and use it as a reference when you find yourself profiling effect performance. It is also helpful to understand the impact an effect has on performance, when you are creating your mix within the mixer. While we mentioned snapshots, it is important to realize that a lot could be going on with transitions, none of which is shown in the profiler well. Often the only way you can profile snapshot transitions is by disabling the controlling component (script) and monitoring the effect on performance.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip190"></a>Note</h3><p>Before you take the time to make radical changes and eliminate effects it is usually best to determine if the DSP performance is in fact a problem. One way to monitor this is by seeing how the rendering frame rate performs as the DSP usage peaks. Chances are if the frame rate drops, you have a problem. At some point, it all becomes a bit of a balancing act on priorities between the rendering, physics, AI, and audio.</p></div><p>In the next section, we are going to take a look at how to profile and optimize performance when using FMOD as our audio system.</p></div></div>