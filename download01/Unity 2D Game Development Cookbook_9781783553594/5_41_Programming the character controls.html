<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec51"></a>Programming the character controls</h2></div></div><hr /></div><p>Though we already<a id="id309" class="indexterm"></a> mentioned a few examples of game controls with Rigidbody and Character Controller, in the following recipe, we will code the actual controls for the game character of our prototype. We couldn't do this before we had working platforms in the prototype! In the following recipe, we will make use of the Rigidbody component and its physics features, plus add in a few simple instructions.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec128"></a>Getting ready</h3></div></div></div><p>Open up your project. We <a id="id310" class="indexterm"></a>need a new script for this, so create one as usual in the <code class="literal">Scripts</code> folder of your project and name it <code class="literal">Runner</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec129"></a>How to do it...</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>As usual, the script begins with the variable declarations. We need a reference to the Animator attached to the character for the animations, variables for horizontal and vertical acceleration, and a Boolean variable to take notice whether the character is touching the ground, among the others.</p><p>Add the following lines at the bottom of the script:</p><div class="informalexample"><pre class="programlisting">public static float distTraveled;
public static bool bIsTouch;
private float horAcceleration;
private Animator charAnimator;
private Vector3 jumpVel;
private Transform nextPlat;</pre></div></li><li><p>In the <code class="literal">Start()</code> function, we initialize the variables we need at the beginning of the script with the following lines:</p><div class="informalexample"><pre class="programlisting">void Start () {
  charAnimator = GameObject.Find("runner").GetComponent&lt;Animator&gt;();
  horAcceleration = 4f;
  bIsTouch = false;
  jumpVel = new Vector3 (0,10,0);
}</pre></div></li><li><p>In the <code class="literal">Update()</code> function, we control the speed of the character so that it stays below an arbitrary value that fits our gameplay and also takes into account of the distance traveled by the character, as it may be useful later. Since we are using a Rigidbody component, the relevant code for character controls goes into the <code class="literal">FixedUpdate()</code> function.</p><p>Add the following lines into the <code class="literal">Update()</code> function:</p><div class="informalexample"><pre class="programlisting">void Update () {
  if(rigidbody.velocity.x &gt; 6f){
    Vector3 v = new Vector3(6f, 0, 0);
    rigidbody.velocity=v;
  }
  if(rigidbody.velocity.x &lt; -6f){
    Vector3 v = new Vector3(-6f, 0, 0);
    rigidbody.velocity=v;
  }

  distTraveled=transform.localPosition.x;
}</pre></div></li><li><p>Before <a id="id311" class="indexterm"></a>getting to <code class="literal">FixedUpdate()</code>, let's take a look at the <code class="literal">OnCollisionEnter()</code> and <code class="literal">OnCollisionExit()</code> functions that we use to set <code class="literal">bIsTouch</code> to control whether the character is actually touching a platform. We also set a variable on the Animator to trigger the jump animation clip. Add the following lines to the script:</p><div class="informalexample"><pre class="programlisting">void OnCollisionEnter(Collision c){

  if(c.gameObject.tag == "platform"){
    bIsTouch = true;
    charAnimator.SetBool("bJump",false);
  }
}

void OnCollisionExit(Collision c){
  Debug.Log(bIsTouch);

  if(c.gameObject.tag == "platform"){
    bIsTouch = false;
    charAnimator.SetBool("bJump",true);
  }
}</pre></div></li><li><p>To get these functions to work, we need to define a tag and assign it to the platform triggering the collision, referenced to as <code class="literal">Collision c</code> in the script. To do that, select <span class="strong"><strong>plat_prefab</strong></span> in the <span class="strong"><strong>Project</strong></span> panel, then move to <span class="strong"><strong>Inspector</strong></span>, and click on the drop-down menu in the Tag field. Select <span class="strong"><strong>Add Tag...</strong></span> from the menu, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553594/graphics/3594OT_05_10.jpg" /></div></li><li><p>Set <span class="strong"><strong>Size</strong></span> to <code class="literal">2</code> and<a id="id312" class="indexterm"></a> name the first empty field <code class="literal">platform</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553594/graphics/3594OT_05_11.jpg" /></div></li><li><p>Now select <span class="strong"><strong>plat_prefab</strong></span> again in the <span class="strong"><strong>Project</strong></span> panel and, from the <span class="strong"><strong>Tag</strong></span> menu in <span class="strong"><strong>Inspector</strong></span>, select the <span class="strong"><strong>platform</strong></span> tag that should now be available. You can refer to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553594/graphics/3594OT_05_12.jpg" /></div></li><li><p>Back to the<a id="id313" class="indexterm"></a> script now. In the <code class="literal">FixedUpdate()</code> function, we take the player input (left or right) and use it to add a horizontal speed to the character. We also use the horizontal speed of the character to trigger the running animation.</p><p>Add the following lines into the <code class="literal">FixedUpdate() </code>function:</p><div class="informalexample"><pre class="programlisting">rigidbody.velocity = new Vector3 (Input.GetAxis("Horizontal") * horAcceleration, rigidbody.velocity.y, rigidbody.velocity.z);
charAnimator.SetFloat("fSpeed",rigidbody.velocity.x);</pre></div></li><li><p>Next we control the horizontal speed of the character to switch between the left or right running animation with these lines:</p><div class="informalexample"><pre class="programlisting">if(rigidbody.velocity.x &gt; 0f){
  Quaternion rot = Quaternion.Euler(new Vector3(0,90,0));
  rigidbody.rotation = rot; 
}
if(rigidbody.velocity.x &lt; 0f){
  Quaternion rot = Quaternion.Euler(new Vector3(0,-90,0));
  rigidbody.rotation = rot;  
}</pre></div></li><li><p>Finally, we allow <a id="id314" class="indexterm"></a>the player to use the spacebar to make the character jump. In doing so, we check whether the character is actually touching the ground; we then add the <code class="literal">jumpVel</code> vector to the character velocity and set <code class="literal">bIsTouch</code> to <code class="literal">false</code>. Add the following lines at the end of <code class="literal">FixedUpdate()</code>:</p><div class="informalexample"><pre class="programlisting">if(bIsTouch == true &amp;&amp; Input.GetKeyDown(KeyCode.Space)){
  rigidbody.AddForce(jumpVel,ForceMode.VelocityChange);
  bIsTouch=false;
}</pre></div></li><li><p>The following screenshot shows the complete <code class="literal">FixedUpdate()</code> function of the script:</p><div class="mediaobject"><img src="/graphics/9781783553594/graphics/3594OT_05_13.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec130"></a>How it works...</h3></div></div></div><p>What we implemented is a fairly basic control system based on physics. We add a force to the character when the player hits the left or right button and we prevent the speed from getting too high. We also check whether the character is actually touching the ground before allowing jumps, and whether it prevents the player from jumping while in midair.</p><p>When you apply <a id="id315" class="indexterm"></a>a force to a Rigidbody with the <code class="literal">Rigidbody.AddForce()</code> method, there are several options available with regards to the type of force applied. In this case, we use the <code class="literal">VelocityChange</code> type, which determines an instant change of force, which is useful for our prototype to have the character instantly change the direction it is running in. Other options are available: we suggest you check the manual <a id="id316" class="indexterm"></a>available at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/ForceMode.html" target="_blank">http://docs.unity3d.com/ScriptReference/ForceMode.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec131"></a>There's more...</h3></div></div></div><p>This control system needs many refinements. Still we think we got to the point of how to approach the problems related to side-scrolling with physics. You can move on and refine it yourself. What about providing the character with a max speed parameter and adjusting the jump distance to that value?</p><p>When we approached the character Animator for the first time, we provided examples on how to take advantage of its features. Now that we have a fully animated character, we can fine-tune the Animator to trigger the animation clips we need, when we need them. This is the topic of our next recipe!</p></div></div>