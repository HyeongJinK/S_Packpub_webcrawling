<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec45"></a>Coding physics controls</h2></div></div><hr /></div><p>In this recipe, we show you how to create a <a id="id273" class="indexterm"></a>custom script to control a game object based on physics. It is not the final controller for the character of our prototype: it's a small piece of code that can be used for a classic 2D shooter, based on physics.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec110"></a>Getting ready</h3></div></div></div><p>In the <span class="strong"><strong>Scripts</strong></span> folder in the <span class="strong"><strong>Project</strong></span> panel, create a new C# script and name it <code class="literal">PacktController</code>. Then, double-click on it to open it in <span class="strong"><strong>Monodevelop</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec111"></a>How to do it...</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First we need a bunch of variables to control the forces applied to the GameObject. Add the following lines at the beginning of the script, right below the usual line with the script class declaration:</p><div class="informalexample"><pre class="programlisting">(public class PacktController : MonoBehaviour {):
public float horAcceleration;
  public float cruiseSpeed; //max speed when not pressing
  public float maxSpeed; //max speed while pressing
  public float actualSpeed; //speed at given time
  public float limY; //limit on y, use as mathf.abs
  public float expon; //used to smooth vert movement speed
  public float alpha; //use to tweak the vert movement speed</pre></div></li><li><p>Now get into the <code class="literal">Start()</code> function and add the following line. We need to initialize <code class="literal">horAcceleration</code>:</p><div class="informalexample"><pre class="programlisting">horAcceleration = 4.0f;</pre></div></li><li><p>Next we add a function to the script. Whenever you make use of physics, you should always put instructions <a id="id274" class="indexterm"></a>into the <code class="literal">FixedUpdate()</code> function instead of <code class="literal">Update()</code>. The manual states that <code class="literal">FixedUpdate</code> should be used instead of <code class="literal">Update</code> when dealing with Rigidbodies. For example, when adding a force to a Rigidbody, you have to apply the force for every fixed frame inside <code class="literal">FixedUpdate()</code> instead of every frame inside <code class="literal">Update</code>. The reason is that <code class="literal">FixedUpdate()</code> is called at fixed time intervals and is not subjected to frame rate, thus providing better reliability with physics control.</p></li><li><p>These lines provide the actual speed of our character and set a parameter to smooth its movement:</p><div class="informalexample"><pre class="programlisting">  actualSpeed = Rigidbody.velocity.x
  expon = Time.time * alpha; </pre></div></li><li><p>With regard to the <code class="literal">x</code> <a id="id275" class="indexterm"></a>component of the <code class="literal">Rigidbody.velocity</code> vector we used, it assumes that the character model has been imported front-faced, as we learned in the first chapter of this book. Should you decide to do otherwise for any reason, just remember to take notice of that. With a character rotated 90 degrees on its <span class="emphasis"><em>Y</em></span> axis, for example, the <span class="strong"><strong>z</strong></span> component would affect speed, instead of the x component.</p></li><li><p>The following lines take care of controlling the left\right acceleration of the character by using the left and right arrow keys:</p><div class="informalexample"><pre class="programlisting">  /* control left\right acceleration */
  if (Input.GetKey (KeyCode.RightArrow) &amp;&amp; Mathf.Abs (actualSpeed) &lt; maxSpeed)
  rigidbody.AddForce (Vector3.right * horAcceleration, ForceMode.VelocityChange);

  if (Input.GetKey (KeyCode.LeftArrow) &amp;&amp; Mathf.Abs (actualSpeed) &lt; maxSpeed)
  rigidbody.AddForce (Vector3.left * horAcceleration, ForceMode.VelocityChange);

  if (Input.GetAxis ("Horizontal") != 0 &amp;&amp; Mathf.Abs (actualSpeed) &gt; cruiseSpeed) { 
    Vector3 v = rigidbody.velocity;
    v.x = (-v.x);
    rigidbody.AddForce (v, ForceMode.Acceleration);
  }</pre></div></li><li><p>Now we add the controls to have the game object fly up or down using the input coming from the Left and Right arrow keys. We also implemented a control to prevent the character from getting out of the top and bottom boundaries of the level:</p><div class="informalexample"><pre class="programlisting">//control up\down acceleration
  if (Input.GetKey (KeyCode.UpArrow)) { 
    Vector3 v=rigidbody.velocity;
    v.y=(1-(Mathf.Exp(-expon)))*limY;
    rigidbody.AddForce(v,ForceMode.VelocityChange);
  }

  if (Input.GetKey (KeyCode.DownArrow)) { 
    Vector3 v=rigidbody.velocity;
    v.y=(-1)*(1-(Mathf.Exp(-expon)))*limY;
    rigidbody.AddForce(v,ForceMode.VelocityChange);
  }</pre></div></li><li><p>You can add the <a id="id276" class="indexterm"></a>script to the character in the scene to apply this control system to it. The following screenshot shows the complete script:</p><div class="mediaobject"><img src="/graphics/9781783553594/graphics/3594OT_04_12.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec112"></a>How it works...</h3></div></div></div><p>This script basically does two things. With regard to left\right acceleration, it provides a max speed that is reached while pressing the Left or Right arrow keys, whether the player is moving left or right. As the player releases the keys, the character slows down to a cruise speed, regardless of direction.</p><p>The script also prevents the character from going too far up or down. It sets a limit on the <span class="emphasis"><em>Y</em></span> axis and then uses an asymptotic function to smooth down vertical speed upon reaching that limit.</p><p>You may have noticed <a id="id277" class="indexterm"></a>that the function we are using to code our instructions is <code class="literal">FixedUpdate()</code>. When using <span class="strong"><strong>Rigidbody</strong></span>, this is the function you must use, instead of <code class="literal">popularUpdate()</code>.</p><p>The other thing you should notice is that <span class="strong"><strong>Rigidbody</strong></span> controls are coded as forces applied to the object as a consequence of the player input. In our case, we used the <code class="literal">Rigidbody.AddForce</code> method, which requires a vector to set the direction of the force applied to the R component (<code class="literal">v</code>) and the type of force applied (<code class="literal">ForceMode.VelocityChange</code>). We suggest you check out the manual for a thorough description<a id="id278" class="indexterm"></a> of this method, available at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html" target="_blank">http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html</a>.</p></div></div>