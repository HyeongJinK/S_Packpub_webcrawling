<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec35"></a>Following a path</h2></div></div><hr /></div><p>Paths are usually created by <a id="id260" class="indexterm"></a>connecting waypoints together. So, we'll set up a simple path as shown in the following figure and then make our cube entity follow along the path smoothly. Now, there are many ways to build such a path. The one we are going to implement here could arguably be the simplest one. We'll write a script called <code class="literal">Path.cs</code> <a id="id261" class="indexterm"></a>and store all the waypoint positions in a <code class="literal">Vector3</code> array. Then, from the editor, we'll enter those positions manually. It's bit of a tedious process right now. One option is to use the position of an empty game object as waypoints. Or, if you want, you can create your own editor plugins to automate these kind of tasks, but that is outside the scope of this book. For now, it should be fine to just enter the waypoint information manually, since the number of waypoints that we are creating here are not that substantial.</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400_06_01.jpg" /><div class="caption"><p>Object path</p></div></div><p>First, we create an empty game entity and <a id="id262" class="indexterm"></a>add our path script component as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400_06_02.jpg" /><div class="caption"><p>Here is how the Hierarchy is organized</p></div></div><p>Then, we populate our <span class="strong"><strong>Point A</strong></span> variable with all the points we want to be included in our path:</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400_06_03.jpg" /><div class="caption"><p>Properties of our Path script</p></div></div><p>The previous list shows the waypoints needed to create the path that was described earlier. The other two properties are <code class="literal">debug mode</code> and <code class="literal">radius</code>. If the <code class="literal">debug mode</code> property is checked, the path formed by the positions entered will be drawn as gizmos in the editor window. The <a id="id263" class="indexterm"></a>
<code class="literal">radius</code> property is a range value for the path following entities to use so that they can know when they've <a id="id264" class="indexterm"></a>reached a particular waypoint if they are in this radius range. Since to reach an exact position can be pretty difficult, this range radius value provides an effective way for the path following agents to navigate through the path.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec41"></a>Path script</h3></div></div></div><p>So let's take a look at the path script <a id="id265" class="indexterm"></a>itself. It will be responsible for managing the path for our objects. Look at the following code in the <code class="literal">Path.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Path : MonoBehaviour {
  public bool bDebug = true;
  public float Radius = 2.0f;
  public Vector3[] pointA;

  public float Length {
    get {
      return pointA.Length;
    }
  }

  public Vector3 GetPoint(int index) {
    return pointA[index];
  }

  void OnDrawGizmos() {
    if (!bDebug) return;

    for (int i = 0; i &lt;pointA.Length; i++) {
      if (i + 1&lt;pointA.Length) {
        Debug.DrawLine(pointA[i], pointA[i + 1],
          Color.red);
      }
    }
  }
}</pre></div><p>As you can see, that is a very simple script. It has a <a id="id266" class="indexterm"></a>
<code class="literal">Length</code> property that returns the length and size of the waypoint array if requested. The <code class="literal">GetPoint</code> method returns the <code class="literal">Vector3</code> position of a particular <a id="id267" class="indexterm"></a>waypoint at a <a id="id268" class="indexterm"></a>specified index in the array. Then, we have the <a id="id269" class="indexterm"></a>
<code class="literal">OnDrawGizmos</code> method that is called by Unity3D frame to draw components in the editor environment. The drawing here won't be rendered in the game view unless gizmos, located in the top right corner of the game view, is turned on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec42"></a>Path follower</h3></div></div></div><p>Next we have our vehicle entity, <a id="id270" class="indexterm"></a>which is just a simple cube object in this example. We can replace the cube later with whatever 3D models we want. After we create the script, we add the <span class="strong"><strong>VehicleFollowing</strong></span> script component as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400_06_04.jpg" /><div class="caption"><p>Properties of our Vehicle Following script</p></div></div><p>The script takes a couple of parameters. First is the reference to the path object it needs to follow. Then, the <span class="strong"><strong>Speed</strong></span> and <span class="strong"><strong>Mass</strong></span> properties, which are needed to calculate its acceleration properly. <a id="id271" class="indexterm"></a>
<span class="strong"><strong>Is Looping</strong></span> is a flag that makes this entity follow the path continuously if it's checked. Let's take a <a id="id272" class="indexterm"></a>look at the following code in the <code class="literal">VehicleFollowing.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class VehicleFollowing : MonoBehaviour {
  public Path path;
  public float speed = 20.0f;
  public float mass = 5.0f;
  public bool isLooping = true;

  //Actual speed of the vehicle
  private float curSpeed;

  private int curPathIndex;
  private float pathLength;
  private Vector3 targetPoint;

  Vector3 velocity;</pre></div><p>First, we initialize the properties and set up the direction of our velocity vector with the entity's forward vector in the <code class="literal">Start</code> <a id="id273" class="indexterm"></a>method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  void Start () {
    pathLength = path.Length;
    curPathIndex = 0;

    //get the current velocity of the vehicle
    velocity = transform.forward;
  }</pre></div><p>There are only two methods that are important in this script, the <code class="literal">Update</code> and <code class="literal">Steer</code> methods. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">  void Update () {
    //Unify the speed
    curSpeed = speed * Time.deltaTime;

    targetPoint = path.GetPoint(curPathIndex);

    //If reach the radius within the path then move to next
      //point in the path
        if (Vector3.Distance(transform.position, targetPoint) &lt;
          path.Radius) {
          //Don't move the vehicle if path is finished
        if (curPathIndex &lt; pathLength - 1) curPathIndex++;
          else if (isLooping) curPathIndex = 0;
          else return;
    }

    //Move the vehicle until the end point is reached in
      //the path
        if (curPathIndex &gt;= pathLength ) return;

    //Calculate the next Velocity towards the path
        if (curPathIndex &gt;= pathLength-1&amp;&amp; !isLooping)
          velocity += Steer(targetPoint, true);
          else velocity += Steer(targetPoint);

    //Move the vehicle according to the velocity
      transform.position += velocity;
    //Rotate the vehicle towards the desired Velocity
      transform.rotation = Quaternion.LookRotation(velocity);
  }</pre></div><p>In the <code class="literal">Update</code> method, we check <a id="id274" class="indexterm"></a>whether our entity has reached a particular waypoint by calculating the distance between its current position and the path's radius range. If it's in the range, we just increase the index to look it up from the waypoints array. If it's the last waypoint, we check if the <code class="literal">isLooping</code> flag is <a id="id275" class="indexterm"></a>set. If it is set, then we set the target to the starting waypoint. Otherwise, we just stop at that point. Though, if we wanted, we could make it so our object turned around and went back the way it came. In the next part, we will calculate the acceleration from the <code class="literal">Steer</code> method. Then, we rotate our entity and update the position according to the speed and direction of the velocity:</p><div class="informalexample"><pre class="programlisting">  //Steering algorithm to steer the vector towards the target
    public Vector3 Steer(Vector3 target,
      bool bFinalPoint = false) {
    //Calculate the directional vector from the current
      //position towards the target point
    Vector3 desiredVelocity = (target -transform.position);
    float dist = desiredVelocity.magnitude;

    //Normalise the desired Velocity
    desiredVelocity.Normalize();

    //Calculate the velocity according to the speed
    if (bFinalPoint&amp;&amp;dist&lt;10.0f) desiredVelocity *= 
      (curSpeed * (dist / 10.0f));
      else desiredVelocity *= curSpeed;

    //Calculate the force Vector
    Vector3 steeringForce = desiredVelocity - velocity; 
    Vector3 acceleration = steeringForce / mass;

    return acceleration;
  }
}</pre></div><p>The <code class="literal">Steer</code> method takes <a id="id276" class="indexterm"></a>the parameter; target <code class="literal">Vector3</code> position to move, whether this is the final waypoint in the path. The first thing we do is calculate the remaining distance from the current position to the target position. The target position vector minus the current position vector gives a vector towards the target position vector. The magnitude of this vector is the remaining distance. We then normalize this vector just to preserve the <code class="literal">direction</code> <a id="id277" class="indexterm"></a>property. Now, if this is the final waypoint, and the distance is less than <code class="literal">10</code> of a number we just decided to use, we slow down the velocity gradually according to the remaining distance to our point until the velocity finally becomes zero. Otherwise, we just update the target velocity with the specified <a id="id278" class="indexterm"></a>speed value. By subtracting the current velocity vector from this target velocity vector, we can calculate the new steering vector. Then by dividing this vector with the mass value of our entity, we get the acceleration.</p><p>If you run the scene, you should see your cube object following the path. You can also see the path that is drawn in the editor view. Play around with the speed and mass value of the follower and radius values of the path and see how they affect the overall behavior of the system.</p></div></div>