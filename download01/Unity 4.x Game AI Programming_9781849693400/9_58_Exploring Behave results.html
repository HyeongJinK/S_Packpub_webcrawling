<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec56"></a>Exploring Behave results</h2></div></div><hr /></div><p>Now let's update our <a id="id419" class="indexterm"></a>handler methods to play with other Behave results. We'll increase the <code class="literal">alpha</code> value during the <code class="literal">FadeIn</code> action, and until it reaches <code class="literal">255</code>, we'll return <code class="literal">Running</code> from the <a id="id420" class="indexterm"></a>
<code class="literal">FadeIn</code> action as given in the following code:</p><div class="informalexample"><pre class="programlisting">  private int alpha = 0;
  private int gameLoading = 0;

  public BehaveResult TickFadeInAction (Tree sender) {
    if (gameLoading &gt;= 100) {
      return BehaveResult.Failure;
    }

    alpha++;
    Debug.Log ("FadeIn ticked! Alpha:" + alpha.ToString());
    if (alpha &lt; 255) {
      return BehaveResult.Running;
    }
    else {
      alpha = 255;
      return BehaveResult.Success;
    }
  }</pre></div><p>So, the sequence will not move on to next child and will keep ticking this <code class="literal">FadeIn</code> action. Only when the <code class="literal">alpha</code> reaches to <code class="literal">255</code>, this action will return <code class="literal">Success</code> and the sequence will move on to the next child node. Once we have reached the <code class="literal">GotoGame</code> action and until the <code class="literal">gameLoading</code> progress has reached <code class="literal">100</code> we'll only return <code class="literal">Failure</code> so that will not start this sequence again until the loading is complete.</p><p>The next action is the <a id="id421" class="indexterm"></a>
<code class="literal">FadeOut</code> action and it'll decrease the <code class="literal">alpha</code> value. Similar to <code class="literal">FadeIn</code>, until it reaches <code class="literal">0</code>, we'll only return <code class="literal">Running</code>. So, the sequence will also return <code class="literal">Running</code> and when the sequence is ticked the next time, it'll tick starting from this action. This is something to note with the <code class="literal">Running</code> result that it'll resume from that child node and not from the left-most child.</p><div class="informalexample"><pre class="programlisting">  public BehaveResult TickFadeOutAction (Tree sender) {
     alpha--;
    Debug.Log ("FadeOut ticked! Alpha:" + alpha.ToString());	
    if (alpha &gt; 0) {
      return BehaveResult.Running;
    }
    else {
      alpha = 0;
      return BehaveResult.Success;
    }
  }</pre></div><p>Finally when the <code class="literal">FadeOut</code> action returns <code class="literal">Success</code>, the sequence will move on to the <code class="literal">GotoGame</code> action and increase the <code class="literal">gameLoading</code> value. Once this value reaches <code class="literal">100</code>, we'll return <code class="literal">Success</code>, otherwise, we'll <a id="id422" class="indexterm"></a>only return <code class="literal">Running</code>, as given in the following code:</p><div class="informalexample"><pre class="programlisting">  public BehaveResult TickGotoGameAction (Tree sender) {
    gameLoading++;
    Debug.Log ("GotoGame ticked! Game loading: " + 
        gameLoading.ToString());	
    if (gameLoading &lt; 100) {
      return BehaveResult.Running;
    }
    else {
      return BehaveResult.Success;
    }
  }</pre></div><p>We just used all three Behave results, <code class="literal">Success</code>, <code class="literal">Failure</code>, and <code class="literal">Running</code> in the preceding example. Before we test this, we need to temporary increase the <code class="literal">Frequency</code> value (for example, <code class="literal">25</code>). Otherwise it will take it 10 minutes for our sequence to complete! Now, let's move on to other behavior tree elements.</p></div>