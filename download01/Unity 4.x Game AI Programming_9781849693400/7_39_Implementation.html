<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec39"></a>Implementation</h2></div></div><hr /></div><p>We'll implement the preliminary classes that were mentioned before, such as the <code class="literal">Node</code> class, the <code class="literal">GridManager</code> <a id="id307" class="indexterm"></a>class, and the <a id="id308" class="indexterm"></a>
<code class="literal">PriorityQueue</code> class. Then we'll use them in our main <code class="literal">AStar</code> class.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec45"></a>Node</h3></div></div></div><p>The <code class="literal">Node</code> class will <a id="id309" class="indexterm"></a>handle each tile object in our 2D grid representing the maps shown in the <code class="literal">Node.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System;

public class Node : IComparable {
  public float nodeTotalCost;
  public float estimatedCost;
  public bool bObstacle;
  public Node parent;
  public Vector3 position;

  public Node() {
    this.estimatedCost = 0.0f;
    this.nodeTotalCost = 1.0f;
    this.bObstacle = false;
    this.parent = null;
  }

  public Node(Vector3 pos) {
    this.estimatedCost = 0.0f;
    this.nodeTotalCost = 1.0f;
    this.bObstacle = false;
    this.parent = null;
    this.position = pos;
  }

  public void MarkAsObstacle() {
    this.bObstacle = true;
  }</pre></div><p>The <code class="literal">Node</code> class has properties, such as the cost values (<code class="literal">G</code> and <code class="literal">H</code>), flags to mark whether it is an obstacle, its positions and parent node. The <code class="literal">nodeTotalCost</code> is <code class="literal">G</code>, which is the movement cost value from starting node to this node so far and the <code class="literal">estimatedCost</code> is <code class="literal">H</code>, which is total estimated cost from this node to the target goal node. <a id="id310" class="indexterm"></a>We also have two simple constructor methods and a wrapper method to set whether this node is an obstacle. Then, we implement the <a id="id311" class="indexterm"></a>
<code class="literal">CompareTo</code> method as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  public int CompareTo(object obj) {
    Node node = (Node)obj;
    //Negative value means object comes before this in the sort
      //order.
    if (this.estimatedCost &lt; node.estimatedCost)
      return -1;
    //Positive value means object comes after this in the sort
      //order.
    if (this.estimatedCost &gt; node.estimatedCost) return 1;
    return 0;
  }
}</pre></div><p>This method is important. Our <code class="literal">Node</code> class inherits from <code class="literal">IComparable</code> because we want to override this <code class="literal">CompareTo</code> <a id="id312" class="indexterm"></a>method. If you can recall what we discussed in the previous algorithm section, you'll notice that we need to sort our list of node arrays based on the total estimated cost. The <a id="id313" class="indexterm"></a>
<code class="literal">ArrayList</code> type has a method called <code class="literal">Sort</code>. <code class="literal">Sort</code> basically looks for this <a id="id314" class="indexterm"></a>
<code class="literal">CompareTo</code> method, implemented <a id="id315" class="indexterm"></a>inside the object (in this case our <code class="literal">Node</code> objects) from the list. So, we implement this method to sort the node objects based on our <code class="literal">estimatedCost</code> value. You can learn more about this .NET framework feature in the following resource.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note05"></a>Note</h3><p>The <code class="literal">IComparable.CompareTo</code> method can be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/system.icomparable.compareto.aspx</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec46"></a>PriorityQueue</h3></div></div></div><p>A <code class="literal">PriorityQueue</code> is a short and <a id="id316" class="indexterm"></a>simple class to make the handling of the nodes, <code class="literal">ArrayList</code> easier as shown in the following <a id="id317" class="indexterm"></a>
<code class="literal">PriorityQueue.cs</code> class:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class PriorityQueue {
  private ArrayList nodes = new ArrayList();

  public int Length {
    get { return this.nodes.Count; }
  }

  public bool Contains(object node) {
    return this.nodes.Contains(node);
  }

  public Node First() {
    if (this.nodes.Count &gt; 0) {
      return (Node)this.nodes[0];
    }
    return null;
  }

  public void Push(Node node) {
    this.nodes.Add(node);
    this.nodes.Sort();
  }

  public void Remove(Node node) {
    this.nodes.Remove(node);
    //Ensure the list is sorted
    this.nodes.Sort();
  }
}</pre></div><p>The preceding code listing should be easy to <a id="id318" class="indexterm"></a>understand. One thing to notice is that after adding or removing node from the nodes' <code class="literal">ArrayList</code>, we call the <code class="literal">Sort</code> <a id="id319" class="indexterm"></a>method. This will call the <code class="literal">Node</code> object's <code class="literal">CompareTo</code> method, and will sort the nodes accordingly by the <code class="literal">estimatedCost</code> value.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec47"></a>GridManager</h3></div></div></div><p>A <code class="literal">GridManager</code> class handles all the <a id="id320" class="indexterm"></a>properties of the grid representing the map. We'll keep a singleton instance of the <code class="literal">GridManager</code> class, as we need only one object to represent the map, as shown in the following <code class="literal">GridManager.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class GridManager : MonoBehaviour {
  private static GridManager s_Instance = null;

  public static GridManager instance {
    get {
      if (s_Instance == null) {
        s_Instance = FindObjectOfType(typeof(GridManager)) 
            as GridManager;
        if (s_Instance == null)
          Debug.Log("Could not locate a GridManager " +
              "object. \n You have to have exactly " +
              "one GridManager in the scene.");
      }
      return s_Instance;
    }
  }</pre></div><p>We look for the <code class="literal">GridManager</code> <a id="id321" class="indexterm"></a>object in our scene and if found, we keep it in our <a id="id322" class="indexterm"></a>
<code class="literal">s_Instance</code> static variable.</p><div class="informalexample"><pre class="programlisting">  public int numOfRows;
  public int numOfColumns;
  public float gridCellSize;
  public bool showGrid = true;
  public bool showObstacleBlocks = true;

  private Vector3 origin = new Vector3();
  private GameObject[] obstacleList;
  public Node[,] nodes { get; set; }
  public Vector3 Origin {
    get { return origin; }
  }</pre></div><p>Next, we declare all the variables; we'll need to represent our map, such as number of rows and columns, the size of each grid <a id="id323" class="indexterm"></a>tile, and some boolean variables to visualize the grid and obstacles as well as to store all the nodes present in the grid as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  void Awake() {
    obstacleList = GameObject.FindGameObjectsWithTag("Obstacle");
    CalculateObstacles();
  }
  // Find all the obstacles on the map
  void CalculateObstacles() {
    nodes = new Node[numOfColumns, numOfRows];
    int index = 0;
    for (int i = 0; i &lt; numOfColumns; i++) {
      for (int j = 0; j &lt; numOfRows; j++) {
        Vector3 cellPos = GetGridCellCenter(index);
        Node node = new Node(cellPos);
        nodes[i, j] = node;
        index++;
      }
    }
    if (obstacleList != null &amp;&amp; obstacleList.Length &gt; 0) {
      //For each obstacle found on the map, record it in our list
      foreach (GameObject data in obstacleList) {
        int indexCell = GetGridIndex(data.transform.position);
        int col = GetColumn(indexCell);
        int row = GetRow(indexCell);
        nodes[row, col].MarkAsObstacle();
      }
    }
  }</pre></div><p>We look for all the game objects with a tag <code class="literal">Obstacle</code> and put them in our <code class="literal">obstacleList</code> property. <a id="id324" class="indexterm"></a>Then we set up our nodes' 2D array in the <code class="literal">CalculateObstacles</code> method. <a id="id325" class="indexterm"></a>First, we just create the normal node objects with default properties. Just after that we examine our <code class="literal">obstacleList</code>. Convert their position into row, column data and update the nodes at that index to be obstacles.</p><p>The <code class="literal">GridManager</code> has a couple of helper methods to traverse the grid and get the grid cell data. The following are some of them with a brief description of what they do. The implementation is simple, so we won't go into the details.</p><p>The <code class="literal">GetGridCellCenter</code> method <a id="id326" class="indexterm"></a>returns the position of the grid cell in world coordinates from the cell index, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  public Vector3 GetGridCellCenter(int index) {
    Vector3 cellPosition = GetGridCellPosition(index);
    cellPosition.x += (gridCellSize / 2.0f);
    cellPosition.z += (gridCellSize / 2.0f);
    return cellPosition;
  }

  public Vector3 GetGridCellPosition(int index) {
    int row = GetRow(index);
    int col = GetColumn(index);
    float xPosInGrid = col * gridCellSize;
    float zPosInGrid = row * gridCellSize;
    return Origin + new Vector3(xPosInGrid, 0.0f, zPosInGrid);
  }</pre></div><p>The <code class="literal">GetGridIndex</code> <a id="id327" class="indexterm"></a>method returns the grid cell index in the grid from the given position:</p><div class="informalexample"><pre class="programlisting">  public int GetGridIndex(Vector3 pos) {
    if (!IsInBounds(pos)) {
      return -1;
    }
    pos -= Origin;
    int col = (int)(pos.x / gridCellSize);
    int row = (int)(pos.z / gridCellSize);
    return (row * numOfColumns + col);
  }

  public bool IsInBounds(Vector3 pos) {
    float width = numOfColumns * gridCellSize;
    float height = numOfRows* gridCellSize;
    return (pos.x &gt;= Origin.x &amp;&amp;  pos.x &lt;= Origin.x + width &amp;&amp;
        pos.x &lt;= Origin.z + height &amp;&amp; pos.z &gt;= Origin.z);
  }</pre></div><p>The <code class="literal">GetRow</code> and <code class="literal">GetColumn</code> <a id="id328" class="indexterm"></a>methods <a id="id329" class="indexterm"></a>return the row and column data of the grid cell from the given index:</p><div class="informalexample"><pre class="programlisting">  public int GetRow(int index) {
    int row = index / numOfColumns;
    return row;
  }

  public int GetColumn(int index) {
    int col = index % numOfColumns;
    return col;
  }</pre></div><p>Another important method is <code class="literal">GetNeighbours</code>, which is used by the <code class="literal">AStar</code> class to retrieve the neighboring nodes of a particular node:</p><div class="informalexample"><pre class="programlisting">  public void GetNeighbours(Node node, ArrayList neighbors) {
    Vector3 neighborPos = node.position;
    int neighborIndex = GetGridIndex(neighborPos);

    int row = GetRow(neighborIndex);
    int column = GetColumn(neighborIndex);

    //Bottom
    int leftNodeRow = row - 1;
    int leftNodeColumn = column;
    AssignNeighbour(leftNodeRow, leftNodeColumn, neighbors);

    //Top
    leftNodeRow = row + 1;
    leftNodeColumn = column;
    AssignNeighbour(leftNodeRow, leftNodeColumn, neighbors);

    //Right
    leftNodeRow = row;
    leftNodeColumn = column + 1;
    AssignNeighbour(leftNodeRow, leftNodeColumn, neighbors);

    //Left
    leftNodeRow = row;
    leftNodeColumn = column - 1;
    AssignNeighbour(leftNodeRow, leftNodeColumn, neighbors);
  }

  void AssignNeighbour(int row, int column, ArrayList neighbors) {
    if (row != -1 &amp;&amp; column != -1 &amp;&amp; 
        row &lt; numOfRows &amp;&amp; column &lt; numOfColumns) {
      Node nodeToAdd = nodes[row, column];
      if (!nodeToAdd.bObstacle) {
        neighbors.Add(nodeToAdd);
      }
    }
  }</pre></div><p>First, we retrieve the neighboring nodes of the current node in the left, right, top, and bottom four directions. Then, inside the <a id="id330" class="indexterm"></a>
<code class="literal">AssignNeighbour</code> method, we check the node to see whether it's an obstacle. If it's not then we push that neighbor node to the referenced array list, <code class="literal">neighbors</code>. The next method is a debug aid method to visualize the grid and obstacle blocks.</p><div class="informalexample"><pre class="programlisting">  void OnDrawGizmos() {
    if (showGrid) {
      DebugDrawGrid(transform.position, numOfRows, numOfColumns, 
          gridCellSize, Color.blue);
    }
    Gizmos.DrawSphere(transform.position, 0.5f);
    if (showObstacleBlocks) {
      Vector3 cellSize = new Vector3(gridCellSize, 1.0f,
        gridCellSize);
      if (obstacleList != null &amp;&amp; obstacleList.Length &gt; 0) {
        foreach (GameObject data in obstacleList) {
          Gizmos.DrawCube(GetGridCellCenter(
              GetGridIndex(data.transform.position)), cellSize);
        }
      }
    }
  }

  public void DebugDrawGrid(Vector3 origin, int numRows, int
    numCols,float cellSize, Color color) {
    float width = (numCols * cellSize);
    float height = (numRows * cellSize);

    // Draw the horizontal grid lines
    for (int i = 0; i &lt; numRows + 1; i++) {
      Vector3 startPos = origin + i * cellSize * new Vector3(0.0f,
        0.0f, 1.0f);
      Vector3 endPos = startPos + width * new Vector3(1.0f, 0.0f,
        0.0f);
      Debug.DrawLine(startPos, endPos, color);
    }

    // Draw the vertial grid lines
    for (int i = 0; i &lt; numCols + 1; i++) {
      Vector3 startPos = origin + i * cellSize * new Vector3(1.0f,
        0.0f, 0.0f);
      Vector3 endPos = startPos + height * new Vector3(0.0f, 0.0f,
        1.0f);
      Debug.DrawLine(startPos, endPos, color);
    }
  }
}</pre></div><p>Gizmos can be used to draw visual debugging and setup aids inside the editor scene view. <code class="literal">OnDrawGizmos</code> is called every frame by the engine. So, if the debug flags, <code class="literal">showGrid</code> and <code class="literal">showObstacleBlocks</code> are checked, we just draw the grid with lines and obstacle cube objects with cubes. Let's not go through the <a id="id331" class="indexterm"></a>
<code class="literal">DebugDrawGrid</code> method, which is quite simple.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note06"></a>Note</h3><p>You can learn more about gizmos <a id="id332" class="indexterm"></a>in the following Unity3D reference documentation at <a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Gizmos.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Gizmos.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec48"></a>AStar</h3></div></div></div><p>The <code class="literal">AStar</code> class is the main class that <a id="id333" class="indexterm"></a>will utilize the classes we have implemented so far. You can go back to the algorithm section, if you want to review this. We start with our <code class="literal">openList</code> and <code class="literal">closedList</code> declarations which are of the <code class="literal">PriorityQueue</code> type as shown in the <code class="literal">AStar.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class AStar {
  public static PriorityQueue closedList, openList;</pre></div><p>Next we implement a method called <a id="id334" class="indexterm"></a>
<code class="literal">HeuristicEstimateCost</code> to calculate the cost between the two nodes. The calculation is simple. We just find the direction vector between the two by subtracting one position vector from another. The magnitude of this resultant vector gives the direct distance from the current node to the goal node.</p><div class="informalexample"><pre class="programlisting">  private static float HeuristicEstimateCost(Node curNode, 
      Node goalNode) {
    Vector3 vecCost = curNode.position - goalNode.position;
    return vecCost.magnitude;
  }</pre></div><p>Next, we have our main <a id="id335" class="indexterm"></a>
<code class="literal">FindPath</code> method:</p><div class="informalexample"><pre class="programlisting">  public static ArrayList FindPath(Node start, Node goal) {
    openList = new PriorityQueue();
    openList.Push(start);
    start.nodeTotalCost = 0.0f;
    start.estimatedCost = HeuristicEstimateCost(start, goal);

    closedList = new PriorityQueue();
    Node node = null;</pre></div><p>We initialize our open and closed lists. <a id="id336" class="indexterm"></a>Starting with the start node, we put it in our open list. Then we start processing our open list.</p><div class="informalexample"><pre class="programlisting">    while (openList.Length != 0) {
      node = openList.First();
      //Check if the current node is the goal node
      if (node.position == goal.position) {
        return CalculatePath(node);
      }

      //Create an ArrayList to store the neighboring nodes
      ArrayList neighbours = new ArrayList();

      GridManager.instance.GetNeighbours(node, neighbours);

      for (int i = 0; i &lt; neighbours.Count; i++) {
        Node neighbourNode = (Node)neighbours[i];

        if (!closedList.Contains(neighbourNode)) {
          float cost = HeuristicEstimateCost(node,
              neighbourNode);

          float totalCost = node.nodeTotalCost + cost;
          float neighbourNodeEstCost = HeuristicEstimateCost(
              neighbourNode, goal);

          neighbourNode.nodeTotalCost = totalCost;
          neighbourNode.parent = node;
          neighbourNode.estimatedCost = totalCost + 
              neighbourNodeEstCost;

          if (!openList.Contains(neighbourNode)) {
            openList.Push(neighbourNode);
          }
        }
      }
      //Push the current node to the closed list
      closedList.Push(node);
      //and remove it from openList
      openList.Remove(node);
    }

    if (node.position != goal.position) {
      Debug.LogError("Goal Not Found");
      return null;
    }
    return CalculatePath(node);
  }</pre></div><p>This code implementation resembles the algorithm that we have previously discussed, so you can refer back to it, if you are not <a id="id337" class="indexterm"></a>clear of certain things.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Get the first node of our <code class="literal">openList</code>. Remember our <code class="literal">openList</code> of nodes is always sorted every time a new node is added. So the first node is always the node with the least estimated cost to the goal node.</p></li><li><p>Check if the current node is already at the goal node. If so, exit the <code class="literal">while</code> loop and build the <code class="literal">path</code> array.</p></li><li><p>Create an array list to store the neighboring nodes of the current node being processed. Use the <a id="id338" class="indexterm"></a>
<code class="literal">GetNeighbours</code> method to retrieve the neighbors from the grid.</p></li><li><p>For every node in the neighbors array, we check if it's already in the <code class="literal">closedList</code>. If not, put it in the calculate the cost values, update the node properties with the new cost values as well as the parent node data and put it in <code class="literal">openList</code>.</p></li><li><p>Push the current node to <code class="literal">closedList</code> and remove it from <code class="literal">openList</code>. Go back to step 1.</p></li></ol></div><p>If there are no more nodes in <code class="literal">openList</code>, our current node should be at the target node if there's a valid path available. Then we just call the <a id="id339" class="indexterm"></a>
<code class="literal">CalculatePath</code> method with the current node parameter.</p><div class="informalexample"><pre class="programlisting">  private static ArrayList CalculatePath(Node node) {
    ArrayList list = new ArrayList();
    while (node != null) {
      list.Add(node);
      node = node.parent;
    }
    list.Reverse();
    return list;
  }
}</pre></div><p>The <code class="literal">CalculatePath</code> <a id="id340" class="indexterm"></a>method traces through each node's parent node object and builds an array list. It gives an array list with nodes from target node to start node. Since we want a path array from start node to target node we just call the <code class="literal">Reverse</code> method.</p><p>So this is our <code class="literal">AStar</code> class. We'll write a test script in the following code to test all this. Then set up a scene to use them in.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec49"></a>TestCode class</h3></div></div></div><p>This class will use the <code class="literal">AStar</code> <a id="id341" class="indexterm"></a>class to find the path from the start node to the goal node as shown in the following <code class="literal">TestCode.cs</code> file:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class TestCode : MonoBehaviour {
  private Transform startPos, endPos;
  public Node startNode { get; set; }
  public Node goalNode { get; set; }

  public ArrayList pathArray;

  GameObject objStartCube, objEndCube;
  private float elapsedTime = 0.0f;
  //Interval time between pathfinding
  public float intervalTime = 1.0f;</pre></div><p>First we set up the variables that we'll need to reference. The <code class="literal">pathArray</code> is to store the nodes array returned from the <code class="literal">AStar FindPath</code> method.</p><div class="informalexample"><pre class="programlisting">  void Start () {
    objStartCube = GameObject.FindGameObjectWithTag("Start");
    objEndCube = GameObject.FindGameObjectWithTag("End");

    pathArray = new ArrayList();
    FindPath();
  }

  void Update () {
    elapsedTime += Time.deltaTime;
    if (elapsedTime &gt;= intervalTime) {
      elapsedTime = 0.0f;
      FindPath();
    }
  }</pre></div><p>In the <code class="literal">Start</code> method <a id="id342" class="indexterm"></a>we look for objects with the tags <code class="literal">Start</code> and <code class="literal">End</code>, and initialize our <code class="literal">pathArray</code> as well. We'll be trying to find our new path at every interval that we set to our <code class="literal">intervalTime</code> <a id="id343" class="indexterm"></a>property in case the positions of the start and end nodes have changed. Then we call the <code class="literal">FindPath</code> method.</p><div class="informalexample"><pre class="programlisting">  void FindPath() {
    startPos = objStartCube.transform;
    endPos = objEndCube.transform;

    startNode = new Node(GridManager.instance.GetGridCellCenter(
        GridManager.instance.GetGridIndex(startPos.position)));

    goalNode = new Node(GridManager.instance.GetGridCellCenter(
        GridManager.instance.GetGridIndex(endPos.position)));

    pathArray = AStar.FindPath(startNode, goalNode);
  }</pre></div><p>Since we implemented our pathfinding algorithm in the <code class="literal">AStar</code> class, finding a path has now become a lot simpler. First, we take the positions of our start and end game objects. Then, we create new <code class="literal">Node</code> objects <a id="id344" class="indexterm"></a>using the helper methods of <code class="literal">GridManager</code>, <code class="literal">GetGridIndex</code>, to calculate their <a id="id345" class="indexterm"></a>respective row and column index positions inside the grid. Once we get that we just call the <code class="literal">AStar.FindPath</code> method <a id="id346" class="indexterm"></a>with the start node and goal node, and store the returned array list in the local <a id="id347" class="indexterm"></a>
<code class="literal">pathArray</code> property. Next we implement the <a id="id348" class="indexterm"></a>
<code class="literal">OnDrawGizmos</code> method to draw and visualize the path found.</p><div class="informalexample"><pre class="programlisting">  void OnDrawGizmos() {
    if (pathArray == null)
      return;

    if (pathArray.Count &gt; 0) {
      int index = 1;
      foreach (Node node in pathArray) {
        if (index &lt; pathArray.Count) {
          Node nextNode = (Node)pathArray[index];
          Debug.DrawLine(node.position, nextNode.position,
            Color.green);
          index++;
        }
      }
    }
  }
}</pre></div><p>We look through our <code class="literal">pathArray</code> and use the <code class="literal">Debug.DrawLine</code> method to draw the lines connecting the nodes from the <code class="literal">pathArray</code>. With that we'll be able to see a green line connecting the nodes from start to end forming a path, when we run and test our program.</p></div></div>