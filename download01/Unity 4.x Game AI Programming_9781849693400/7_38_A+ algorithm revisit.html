<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec38"></a>A* algorithm revisit</h2></div></div><hr /></div><p>Let's review the A* algorithm again <a id="id302" class="indexterm"></a>before we proceed to implement it in next section. First, we'll need to represent the map in a traversable data structure. While many structures are possible, for this example we will use a 2D grid array. We'll implement the <a id="id303" class="indexterm"></a>
<code class="literal">GridManager</code> class later to handle this map information. Our <code class="literal">GridManager</code> class will keep a list of the <code class="literal">Node</code> objects that are basically titles in a 2D grid. So we need to implement that <code class="literal">Node</code> class to handle things such as node type; whether it's a traversable node or an obstacle, cost to pass through and cost to reach the goal <code class="literal">Node</code>, and so on.</p><p>We'll have two variables to store the nodes that have been processed and the nodes that we have to process. We'll call them closed list and open list respectively. We'll implement that list type in the <a id="id304" class="indexterm"></a>
<code class="literal">PriorityQueue</code> class. And then finally, the following A* algorithm will be <a id="id305" class="indexterm"></a>implemented in the <code class="literal">AStar</code> class. Let's take a look at it:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, we start with the starting node and put it in the open list.</p></li><li><p>As long as the open list has some nodes in it, we'll perform the following process.</p></li><li><p>Pick the first node from the open list and keep it as the current node. (This is assuming that we've sorted the open list and the first node has the least cost value, which will be mentioned at the end of the code.)</p></li><li><p>Get the neighboring nodes of this current node, which are not obstacle types, such as a wall or canyon that can't be passed through.</p></li><li><p>For each neighbor node, check if this neighbor node is already in the closed list. If not we'll calculate the total cost (<code class="literal">F</code>) for this neighbor node using the following formula:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">F = G + H</code>
</pre></div><p>In the preceding formula, <code class="literal">G</code> is the total cost from the previous node to this node and <code class="literal">H</code> is the total cost from this node to the final target node.</p></li><li><p>Store that cost data in the neighbor node object. Also, store the current node as the parent node as well. Later we'll use this parent node data to trace back the actual path.</p></li><li><p>Put this neighbor node in the open list. Sort the open list in ascending order, ordered by the total cost to reach the target node.</p></li><li><p>If there's no more neighbor nodes to process, put the current node in the closed list and remove it from the open list.</p></li><li><p>Go back to step 2.</p></li></ol></div><p>Once you have completed this process your current node should be in the target goal node position, but only if there's an obstacle free path to reach the goal node from the start node. If it is not at the goal node, then there's no available path to the target node from the current node position. If there's a valid path all we have to do now is to trace back from current node's parent node, until we reach the start node again. That'll give us a path list of all the nodes that we chose during our <a id="id306" class="indexterm"></a>pathfinding process ordered from the target node to the start node. We then just reverse this path list, since we want to know the path from the start node to the target goal node.</p><p>This is a general overview of the algorithm we're going to implement in Unity3D using C#. So let's get started.</p></div>