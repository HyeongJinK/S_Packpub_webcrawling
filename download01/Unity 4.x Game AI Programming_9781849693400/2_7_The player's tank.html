<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec12"></a>The player's tank</h2></div></div><hr /></div><p>Now before writing the script for our <a id="id55" class="indexterm"></a>player tank, let's take a look at how we set up the <a id="id56" class="indexterm"></a>
<span class="strong"><strong>PlayerTank</strong></span> game object. Our <span class="strong"><strong>Tank</strong></span> object is basically a simple <span class="strong"><strong>Mesh</strong></span> with a <span class="strong"><strong>Rigidbody</strong></span> <a id="id57" class="indexterm"></a>component, and a <span class="strong"><strong>Box Collider</strong></span> component. The <span class="strong"><strong>Tank</strong></span> object is not a single <span class="strong"><strong>Mesh</strong></span>, but two separate meshes, <span class="strong"><strong>Tank</strong></span> and <span class="strong"><strong>Turret</strong></span>. We make <span class="strong"><strong>Turret</strong></span> a child of <span class="strong"><strong>Tank</strong></span>. This is to allow independent rotation of the <span class="strong"><strong>Turret</strong></span> object using the mouse movement. And at the same time, since it's the child of the <span class="strong"><strong>Tank</strong></span> object, it'll follow wherever the <span class="strong"><strong>Tank</strong></span> body goes as well. Then create an empty game object to be our <span class="strong"><strong>SpawnPoint</strong></span> transform. It will be used as a reference position point, when shooting a bullet. Also we need to assign the <span class="strong"><strong>Player</strong></span> tag to our <span class="strong"><strong>Tank</strong></span> object. So that's how our <span class="strong"><strong>Tank</strong></span> entity is set up. Now let's take a look at the controller class.</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400_02_01.jpg" /><div class="caption"><p>Tank entity</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec18"></a>The PlayerTankController class</h3></div></div></div><p>This class will be the primary <a id="id58" class="indexterm"></a>means by which the player will control the <span class="strong"><strong>Tank</strong></span> object using it. We will be using the <span class="emphasis"><em>W</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>S</em></span>, and <span class="emphasis"><em>D</em></span> keys to move and steer the tank, and the left mouse button to aim and shoot the <span class="strong"><strong>Turret</strong></span> object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>Unity only knows how to work with the standard QWERTY keyboard layout. For those of us who use a different keyboard, all we have to do is pretend that we are using a QWERTY keyboard, and then everything will work out fine.</p><p>This book will also assume the use of a QWERTY keyboard, as well as the use of a two-button mouse, with the left mouse button set to the primary mouse button.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"></a>Initialization</h3></div></div></div><p>The properties <a id="id59" class="indexterm"></a>of our <code class="literal">TankController</code> class are as follows. First we set up our <a id="id60" class="indexterm"></a>
<code class="literal">Start</code> function and the <code class="literal">Update</code> functions.</p><p>The code in <a id="id61" class="indexterm"></a>the<code class="literal"> PlayerTankController.cs</code> file is as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class PlayerTankController : MonoBehaviour
{
    public GameObject Bullet;

    private Transform Turret;
    private Transform bulletSpawnPoint;
    private float curSpeed, targetSpeed, rotSpeed;
    private float turretRotSpeed = 10.0f;
    private float maxForwardSpeed = 300.0f;
    private float maxBackwardSpeed = -300.0f;

    //Bullet shooting rate
    protected float shootRate = 0.5f;
    protected float elapsedTime;

    void Start()
    {

      //Tank Settings
      rotSpeed = 150.0f;

      //Get the turret of the tank
      Turret = gameObject.transform.GetChild(0).transform;
      bulletSpawnPoint = Turret.GetChild(0).transform;
    }

    void Update()
    {
      UpdateWeapon();
      UpdateControl();
    }</pre></div><p>The first child object of our <code class="literal">Tank</code> entity is the <code class="literal">Turret</code> object, and the first child of the <code class="literal">Turret</code> object is the <code class="literal">bulletSpawnPoint</code>. The <code class="literal">Start</code> function finds these objects, and then assigns them to their <a id="id62" class="indexterm"></a>respective variables. We will assign our <code class="literal">Bullet</code> variable later, after we create our <code class="literal">Bullet</code> object. Also we included the <code class="literal">Update</code> function, which calls our <code class="literal">UpdateControl</code> and <code class="literal">UpdateWeapon</code> functions, which we will create soon.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec03"></a>Shooting bullet</h4></div></div></div><p>Whenever the player clicks the <a id="id63" class="indexterm"></a>left mouse button, we check whether the total elapsed time since the last fire has passed the fire rate of the weapon. If it has, then we create a new <code class="literal">Bullet</code> object at the <code class="literal">SpawnPoint</code> variable's position. This way, we can prevent shooting continuously without any limit.</p><div class="informalexample"><pre class="programlisting">    void UpdateWeapon()
    {
      if (Input.GetMouseButtonDown(0))
      {
        elapsedTime += Time.deltaTime;
        if (elapsedTime &gt;= shootRate)
        {
          //Reset the time
          elapsedTime = 0.0f;

          //Instantiate the bullet
          Instantiate(Bullet, bulletSpawnPoint.position, 
          bulletSpawnPoint.rotation);
        }
      }
    }</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec04"></a>Controlling the tank</h4></div></div></div><p>The player will rotate the <a id="id64" class="indexterm"></a>
<code class="literal">Turret</code> object using the mouse. So, this <a id="id65" class="indexterm"></a>part is a little bit tricky. Our <code class="literal">Camera</code> will look down upon the battlefield. From that, we'll <a id="id66" class="indexterm"></a>use ray casting to determine the direction to turn, based on the <code class="literal">mousePosition</code> object on the battlefield.</p><div class="informalexample"><pre class="programlisting">    void UpdateControl()
    {
      //AIMING WITH THE MOUSE
      //Generate a plane that intersects the transform's 
      //position with an upwards normal.
      Plane playerPlane = new Plane(Vector3.up, 
      transform.position + new Vector3(0, 0, 0));

      // Generate a ray from the cursor position
      Ray RayCast = 
      Camera.main.ScreenPointToRay(Input.mousePosition);

      //Determine the point where the cursor ray intersects 
      //the plane.
      float HitDist = 0;

      // If the ray is parallel to the plane, Raycast will 
      //return false.
      if (playerPlane.Raycast(RayCast, out HitDist))
      {
        //Get the point along the ray that hits the 
        //calculated distance.
        Vector3 RayHitPoint = RayCast.GetPoint(HitDist);

        Quaternion targetRotation =
        Quaternion.LookRotation(RayHitPoint - 
        transform.position);

        Turret.transform.rotation = 
        Quaternion.Slerp(Turret.transform.rotation, 
        targetRotation, Time.deltaTime * 
        turretRotSpeed);
      }</pre></div><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400_02_02.jpg" /><div class="caption"><p>Raycast to aim with mouse</p></div></div><p>This is how it works:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Set up a plane that intersects <a id="id67" class="indexterm"></a>with the player <a id="id68" class="indexterm"></a>tank with an upward normal.</p></li><li><p>Shoot a ray from screen space with the mouse position (in the preceding diagram, it's assumed that we're looking down at the tank).</p></li><li><p>Find the point where the ray intersects the plane.</p></li><li><p>Finally, find the rotation from the current position to that intersection point.</p></li></ol></div><p>Then we check for the <a id="id69" class="indexterm"></a>key-pressed inputs, and then move/rotate the tank accordingly.</p><div class="informalexample"><pre class="programlisting">      if (Input.GetKey(KeyCode.W))
      {
        targetSpeed = maxForwardSpeed;
      }
      else if (Input.GetKey(KeyCode.S))
      {
        targetSpeed = maxBackwardSpeed;
      }
      else
      {
        targetSpeed = 0;
       }

      if (Input.GetKey(KeyCode.A))
      {
        transform.Rotate(0, -rotSpeed * Time.deltaTime, 
        0.0f);
      }
      else if (Input.GetKey(KeyCode.D))
      {
        transform.Rotate(0, rotSpeed * Time.deltaTime, 
        0.0f);
      }

      //Determine current speed
      curSpeed = Mathf.Lerp(curSpeed, targetSpeed, 7.0f * 
      Time.deltaTime);
      
      transform.Translate(Vector3.forward * Time.deltaTime * 
      curSpeed);
    }
}</pre></div></div></div></div>