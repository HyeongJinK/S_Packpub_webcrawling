<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch09"></a>Chapter 9. Behavior Trees</h2></div></div></div><p>Behavior trees are another way of controlling states and behaviors of our game characters. They are also an alternative to <span class="strong"><strong>finite state machines</strong></span> (<span class="strong"><strong>FSMs</strong></span>), which was described in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Finite State Machines</em></span>. <a id="id387" class="indexterm"></a>Even though FSMs are simple to implement, intuitive, and easy to understand, it's hard to maintain and scale once the logic becomes too complex. One of the reasons for this is that in state machines, all the transitions between states have to be precisely defined. So, as the size of state machine becomes bigger, updating the structure of a state machine with all the transitions becomes extremely complex. So AI developers have moved on to find new ways and other techniques, such as <span class="strong"><strong>hierarchical FSM</strong></span> (<span class="strong"><strong>HFSM</strong></span>) and <span class="strong"><strong>Hierarchical Task Networks</strong></span> (<span class="strong"><strong>HTNs</strong></span>). Behavior trees are one of them that have become <a id="id388" class="indexterm"></a>popular <a id="id389" class="indexterm"></a>with the use of AAA games such as Halo, Crysis, and Spore.</p><p>Since this book is focused on implementing AI in Unity3D, we won't cover implementing the whole behavior tree system from scratch. Luckily there's a powerful plugin called Behave for Unity3D to implement behavior trees. So we'll be using this in this chapter as well as studying the general components and ideas of behavior trees while implementing simple demos.</p></div>