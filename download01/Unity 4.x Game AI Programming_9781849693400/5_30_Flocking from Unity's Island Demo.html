<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec32"></a>Flocking from Unity's Island Demo</h2></div></div><hr /></div><p>In this section, we'll create our own scene with flocks of objects and implement the flocking behavior in C#. There are <a id="id221" class="indexterm"></a>two main components in this example: the <a id="id222" class="indexterm"></a>individual boid behavior and a main controller to maintain and lead the crowd.</p><p>Our scene hierarchy is shown in the following screenshot. As you can see, we have several boid entities, <span class="strong"><strong>UnityFlock,</strong></span> under a <a id="id223" class="indexterm"></a>controller named <span class="strong"><strong>UnityFlockController</strong></span>. <span class="strong"><strong>UnityFlock</strong></span> entities are individual boid objects, and they'll reference to their parent <span class="strong"><strong>UnityFlockController</strong></span> entity to use it as a leader. <span class="strong"><strong>UnityFlockController</strong></span> will update the next destination point randomly once it reaches the current destination point.</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400_05_05.jpg" /><div class="caption"><p>Scene hierarchy</p></div></div><p><span class="strong"><strong>UnityFlock</strong></span> is a prefab with <a id="id224" class="indexterm"></a>just a cube mesh and a <span class="strong"><strong>UnityFlock</strong></span> script. We can <a id="id225" class="indexterm"></a>use any other mesh representation for <a id="id226" class="indexterm"></a>this prefab to represent something more interesting like birds.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec38"></a>Individual Behavior</h3></div></div></div><p>Boid is a term coined by Craig Reynold that refers to some bird like object. We'll use this term to describe each individual object in our flock. Now let's implement our boid behavior. You can find the following script in <code class="literal">UnityFlock.cs</code>, and this is the behavior that controls each boid in our flock.</p><p>The code in the <a id="id227" class="indexterm"></a>
<code class="literal">UnityFlock.cs</code> file can be shown as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class UnityFlock : MonoBehaviour {
  public float minSpeed = 20.0f;
  public float turnSpeed = 20.0f;
  public float randomFreq = 20.0f;
  public float randomForce = 20.0f;

  //alignment variables
  public float toOriginForce = 50.0f; 
  public float toOriginRange = 100.0f;

  public float gravity = 2.0f;

  //seperation variables
  public float avoidanceRadius = 50.0f;
  public float avoidanceForce = 20.0f;

  //cohesion variables
  public float followVelocity = 4.0f;
  public float followRadius = 40.0f;

  //these variables control the movement of the boid
  private Transform origin;
  private Vector3 velocity;
  private Vector3 normalizedVelocity;
  private Vector3 randomPush;
  private Vector3 originPush;
  private Transform[] objects;
  private UnityFlock[] otherFlocks;
  private Transform transformComponent;</pre></div><p>We declare the input values for our algorithm that can be set up and customized from the editor. First, we define the minimum movement speed, <code class="literal">minSpeed</code> and rotation speed, <code class="literal">turnSpeed</code>, for our boid. <a id="id228" class="indexterm"></a>
<code class="literal">randomFreq</code> is used to determine how many times we want to update the <a id="id229" class="indexterm"></a>
<code class="literal">randomPush</code> value based on the <code class="literal">randomForce</code> value. This force creates a randomly increased and decreased velocity and makes the flock movement look more realistic.</p><p><code class="literal">toOriginRange</code> specifies <a id="id230" class="indexterm"></a>how spread out we want our flock to be. We also use <code class="literal">toOriginForce</code> to <a id="id231" class="indexterm"></a>keep the boids in range and maintain a distance with the flock's origin. Basically, these are the properties to deal with the alignment rule of our flocking algorithm. The <a id="id232" class="indexterm"></a>
<code class="literal">avoidanceRadius</code> and <code class="literal">avoidanceForce</code> properties are used to maintain a minimum distance <a id="id233" class="indexterm"></a>between individual boids. These are the properties that apply the separation rule to our flock.</p><p><code class="literal">followRadius</code> <a id="id234" class="indexterm"></a>and <code class="literal">followVelocity</code> <a id="id235" class="indexterm"></a>are used to keep a minimum distance with the leader or the origin of the flock. They are used to comply with the cohesion rule of the flocking algorithm.</p><p><code class="literal">origin</code> will be the parent object to control the whole group of flocking objects. Our boid needs to know about the other boids in the flock. So, we use the <code class="literal">objects</code> and <code class="literal">otherFlocks</code> properties to store the neighboring boids' information.</p><p>This is the initialization method for our boid:</p><div class="informalexample"><pre class="programlisting">  void Start () {
    randomFreq = 1.0f / randomFreq;

    //Assign the parent as origin
    origin = transform.parent;

    //Flock transform
    transformComponent = transform;

    //Temporary components
    Component[] tempFlocks= null;

    //Get all the unity flock components from the parent 	
    //transform in the group
    if (transform.parent) {
      tempFlocks = transform.parent.GetComponentsInChildren
          &lt;UnityFlock&gt;();
    }

    //Assign and store all the flock objects in this group
    objects = new Transform[tempFlocks.Length];
    otherFlocks = new UnityFlock[tempFlocks.Length];

    for (int i = 0;i&lt;tempFlocks.Length;i++) {
      objects[i] = tempFlocks[i].transform;
      otherFlocks[i] = (UnityFlock)tempFlocks[i];
    }

    //Null Parent as the flock leader will be 
    //UnityFlockController object
    transform.parent = null;

    //Calculate random push depends on the random frequency 
//provided
    StartCoroutine(UpdateRandom());
  }</pre></div><p>We set the parent of the object of our boid as <code class="literal">origin</code>, meaning that this will be the controller object to follow generally. Then, we grab all the other boids in the group and store them in our own variables for later references.</p><p>The <code class="literal">StartCoroutine</code> <a id="id236" class="indexterm"></a>method starts the <a id="id237" class="indexterm"></a>
<code class="literal">UpdateRandom()</code> method as a coroutine:</p><div class="informalexample"><pre class="programlisting">  IEnumerator UpdateRandom() {
    while (true) {
      randomPush = Random.insideUnitSphere * randomForce;
      yield return new WaitForSeconds(randomFreq + 
          Random.Range(-randomFreq / 2.0f, randomFreq / 2.0f));
    }
  }</pre></div><p>The <code class="literal">UpdateRandom()</code> method <a id="id238" class="indexterm"></a>updates the <code class="literal">randomPush</code> value throughout the game with an interval based on <code class="literal">randomFreq</code>. <code class="literal">Random.insideUnitSphere</code> returns a <code class="literal">Vector3</code> object with random <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> values within a sphere with a radius of the <code class="literal">randomForce</code> value. Then, we wait for a certain random amount of time before resuming the <code class="literal">while(true)</code> loop to update the <code class="literal">randomPush</code> value again.</p><p>Now, here's our boid behavior's <code class="literal">Update()</code> <a id="id239" class="indexterm"></a>method that helps our boid entity comply with the three rules of the flocking algorithm:</p><div class="informalexample"><pre class="programlisting">  void Update () {
    //Internal variables
    float speed = velocity.magnitude;
    Vector3 avgVelocity = Vector3.zero;
    Vector3 avgPosition = Vector3.zero;
    float count = 0;
    float f = 0.0f;
    float d = 0.0f;
    Vector3 myPosition = transformComponent.position;
    Vector3 forceV;
    Vector3 toAvg;
    Vector3 wantedVel;

    for (int i = 0;i&lt;objects.Length;i++){
      Transform transform= objects[i];
      if (transform != transformComponent) {
        Vector3 otherPosition = transform.position;

        // Average position to calculate cohesion
        avgPosition += otherPosition;
        count++;

        //Directional vector from other flock to this flock
        forceV = myPosition - otherPosition;

        //Magnitude of that directional vector(Length)
        d= forceV.magnitude;

        //Add push value if the magnitude, the length of the 
        //vector, is less than followRadius to the leader
        if (d &lt; followRadius) {
          //calculate the velocity, the speed of the object, based
           //on the avoidance distance between flocks if the 
          //current magnitude is less than the specified 
          //avoidance radius
          if (d &lt; avoidanceRadius) {
            f = 1.0f - (d / avoidanceRadius);
            if (d &gt; 0) avgVelocity += 
                (forceV / d) * f * avoidanceForce;
          }

          //just keep the current distance with the leader
          f = d / followRadius;
          UnityFlock otherSealgull = otherFlocks[i];
          //we normalize the otherSealgull velocity vector to get 
          //the direction of movement, then we set a new velocity
          avgVelocity += otherSealgull.normalizedVelocity * f * 
              followVelocity;  
        }
      }
    }</pre></div><p>The preceding code implements the separation rule. First, we check the distance between the current boid and the other boids and update the velocity accordingly, as explained in the comments.</p><p>Next, we calculate the average velocity of the flock by dividing the current velocity with the number of boids in the flock:</p><div class="informalexample"><pre class="programlisting">    if (count &gt; 0) {
      //Calculate the average flock velocity(Alignment)
      avgVelocity /= count;

      //Calculate Center value of the flock(Cohesion)
      toAvg = (avgPosition / count) - myPosition;
    }  
    else {
      toAvg = Vector3.zero;
    }

    //Directional Vector to the leader
    forceV = origin.position -  myPosition;
    d = forceV.magnitude;   
    f = d / toOriginRange;

    //Calculate the velocity of the flock to the leader
    if (d &gt; 0) //if this void is not at the center of the flock
        originPush = (forceV / d) * f * toOriginForce;

    if (speed &lt; minSpeed &amp;&amp; speed &gt; 0) {
      velocity = (velocity / speed) * minSpeed;
    }

    wantedVel = velocity;

    //Calculate final velocity
    wantedVel -= wantedVel *  Time.deltaTime;	
    wantedVel += randomPush * Time.deltaTime;
    wantedVel += originPush * Time.deltaTime;
    wantedVel += avgVelocity * Time.deltaTime;
    wantedVel += toAvg.normalized * gravity * Time.deltaTime;

    //Final Velocity to rotate the flock into
    velocity = Vector3.RotateTowards(velocity, wantedVel, 
        turnSpeed * Time.deltaTime, 100.00f);

    transformComponent.rotation = Quaternion.LookRotation(velocity);

    //Move the flock based on the calculated velocity
    transformComponent.Translate(velocity * Time.deltaTime, 
        Space.World);

    //normalise the velocity
    normalizedVelocity = velocity.normalized;
  }
}</pre></div><p>Finally, we add up all the factors such as <code class="literal">randomPush</code>, <code class="literal">originPush</code>, and <code class="literal">avgVelocity</code> to calculate our final target velocity, <code class="literal">wantedVel</code>. We also update our current <code class="literal">velocity</code> to <code class="literal">wantedVel</code> with linear <a id="id240" class="indexterm"></a>interpolation using the <code class="literal">Vector3.RotateTowards</code> method. Then, we move our boid based <a id="id241" class="indexterm"></a>on the new velocity using the <code class="literal">Translate()</code> method.</p><p>Next, we create a cube mesh, and add this <span class="strong"><strong>UnityFlock</strong></span> script, and make it a prefab as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400_05_03.jpg" /><div class="caption"><p>Unity flock prefab</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec39"></a>Controller</h3></div></div></div><p>Now it is time to create the <a id="id242" class="indexterm"></a>controller class. This class updates its own position so that the other individual boid objects know where to go. This object is referenced in the <code class="literal">origin</code> variable in the preceding <a id="id243" class="indexterm"></a>
<span class="strong"><strong>UnityFlock</strong></span> script.</p><p>The code in the <code class="literal">UnityFlockController.cs</code> file can be shown as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class UnityFlockController : MonoBehaviour {
  public Vector3 offset;
  public Vector3 bound;
  public float speed = 100.0f;

  private Vector3 initialPosition;
  private Vector3 nextMovementPoint;

  // Use this for initialization
  void Start () {
    initialPosition = transform.position;
    CalculateNextMovementPoint();
  }

  // Update is called once per frame
  void Update () {
    transform.Translate(Vector3.forward * speed * Time.deltaTime);
    transform.rotation = Quaternion.Slerp(transform.rotation, 
        Quaternion.LookRotation(nextMovementPoint - 
        transform.position), 1.0f * Time.deltaTime);

    if (Vector3.Distance(nextMovementPoint, 
        transform.position) &lt;= 10.0f) 
        CalculateNextMovementPoint();
  }</pre></div><p>In our <code class="literal">Update()</code> method, we check whether our controller object is near the target destination point. If it is, we update our <code class="literal">nextMovementPoint</code> variable again with the <code class="literal">CalculateNextMovementPoint()</code> method we just discussed:</p><div class="informalexample"><pre class="programlisting">  void CalculateNextMovementPoint () {
    float posX = Random.Range(initialPosition.x - bound.x, 
        initialPosition.x + bound.x);
    float posY = Random.Range(initialPosition.y - bound.y, 
        initialPosition.y + bound.y);
    float posZ = Random.Range(initialPosition.z - bound.z, 
        initialPosition.z + bound.z);

    nextMovementPoint = initialPosition + new Vector3(posX, 
        posY, posZ);
  }
}</pre></div><p>The <code class="literal">CalculateNextMovementPoint()</code> method finds the next random destination position in a range between the <a id="id244" class="indexterm"></a>current position and the boundary vectors.</p><p>Putting it all together, as shown in the previous scene hierarchy screenshot, you should have flocks flying around somewhat realistically:</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400_05_01.jpg" /><div class="caption"><p>Flocking using the Unity seagull sample</p></div></div></div></div>