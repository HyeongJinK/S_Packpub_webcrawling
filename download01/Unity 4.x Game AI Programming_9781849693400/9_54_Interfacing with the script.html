<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec52"></a>Interfacing with the script</h2></div></div><hr /></div><p>Before we can access this behavior <a id="id400" class="indexterm"></a>tree from a script we need to build or compile this behavior tree. Behave will compile the tree to a DLL so that we can reference and implement our own custom actions from our scripts. It is important to note that whenever we change anything inside the library, we will have to recompile the library before we try and use what we added. There are two options to build a Behave library either debug or release. These build options only apply to our Behave library and not to our actual game. We'll be using the debug build in this tutorial that will allow us to debug our behavior trees using Behave's built-in visual debugger.</p><p>So, to compile your behavior tree just select the Behave library (in this case <code class="literal">AgentBehaveLib</code>) and then click on <span class="strong"><strong>Build library debug</strong></span> from the inspector panel. After a moment you'll see two new files are added to your project directory. You might need to refresh your project folder to see the changes. With that successfully built library we are now ready to implement the actions in our script. So let's create a new C# script and call it <code class="literal">AgentController</code>.</p><p>The first thing we need to do is to import Behave runtime library which can be found under the <code class="literal">Behave.Runtime</code> <a id="id401" class="indexterm"></a>namespace. And we need to implement the <code class="literal">IAgent</code> interface defined by the Behave system so that we can handle our own actions.</p><p>The code in the <code class="literal">AgentController.cs</code> file <a id="id402" class="indexterm"></a>is as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using Behave.Runtime;
using Tree = Behave.Runtime.Tree;

public class AgentController : MonoBehaviour, IAgent {

  Tree m_Tree;</pre></div><p>Then we declare a <code class="literal">Tree</code> variable to reference our behavior tree. Then inside our <code class="literal">Start</code> method, we use the <a id="id403" class="indexterm"></a>
<code class="literal">InstantiateTree</code> static method of our library to create an instance of our behavior tree. The <code class="literal">BLAgentBehaveLib</code> library is generated by Behave using this naming pattern, <code class="literal">BL{YourLibraryName}</code>. Behave uses that kind of naming convention, as you will see later, and it's important to keep the names the way it needs. The <a id="id404" class="indexterm"></a>
<code class="literal">InstantiateTree</code> method accepts two parameters: the tree type to instantiate and the reference to a class that implements the <code class="literal">IAgent</code> interface, in our case we just pass in this to refer the current class. Notice that the tree type is a combination of what we called our collection and what we called our tree.</p><div class="informalexample"><pre class="programlisting">  IEnumerator Start () {
    m_Tree = BLAgentBehaveLib.InstantiateTree( 
        BLAgentBehaveLib.TreeType.NewCollection1_NewTree1, this);
    while (Application.isPlaying &amp;&amp; m_Tree != null) {
      yield return new 
      WaitForSeconds(1.0f/m_Tree.Frequency);
      AIUpdate();
    }
  }</pre></div><p>Behave has a real-time loop that calls our own <code class="literal">update</code> method, <code class="literal">AIUpdate</code> is the update method we created and is called in a particular interval based on the <code class="literal">frequency</code> property specified in our tree. Inside our <a id="id405" class="indexterm"></a>
<code class="literal">AIUpdate</code> method we just called the <code class="literal">Tick</code> method of our tree instance. [Note: Behave uses the term tick instead of update.]</p><div class="informalexample"><pre class="programlisting">  void AIUpdate() {
    m_Tree.Tick();
  }</pre></div><p>There are three methods that we need to implement for our <span class="strong"><strong>IAgent</strong></span> interface. They are as follows:</p><div class="informalexample"><pre class="programlisting">BehaveResult Tick (Tree sender, bool init);
void Reset (Tree sender);
int SelectTopPriority (Tree sender, params int[] IDs);</pre></div><p>So we'll be implementing them. The <a id="id406" class="indexterm"></a>
<code class="literal">Tick</code> and <code class="literal">Reset</code> methods are called whenever an action or a decorator (which <a id="id407" class="indexterm"></a>we'll discuss later) is, well ticked or reset. If we have implemented our own handler methods for our actions, these methods will be used instead:</p><div class="informalexample"><pre class="programlisting">  public BehaveResult Tick(Tree sender, bool init) {
    Debug.Log("Ticked Received by unhandled " +
      (BLAgentBehaveLib.IsAction(sender.ActiveID) ? "Action " : "Decorator ") + 
      " ... " + (BLAgentBehaveLib.IsAction(sender.ActiveID) ? 
      ((BLAgentBehaveLib.ActionType)sender.ActiveID).ToString() : 
      ((BLAgentBehaveLib.DecoratorType)sender.ActiveID).ToString()));
    return BehaveResult.Success;
  }

  public void Reset (Tree sender) {

  }</pre></div><p>Inside our generic <code class="literal">Tick</code> method, we just <a id="id408" class="indexterm"></a>print out the name of the action or decorator node from the <code class="literal">sender</code> parameter that receives this tick, as follows:</p><div class="informalexample"><pre class="programlisting">  public int SelectTopPriority (Tree sender, params int[] IDs) {
    return 0;
  }
}</pre></div><p>Again, we'll come back to this <a id="id409" class="indexterm"></a>
<code class="literal">SelectTopPriority</code> method in a short while. Right now, we'll try to run this behavior. Just create an empty game object and attach this <code class="literal">AgentController</code> script to it. Then, hit play. If you follow along with this whole section, you should be able to see the nice log messages in the console as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400OT_09_16.jpg" /><div class="caption"><p>Unhandled Action results</p></div></div><p>What that means is now our behavior tree is working together with our script. But as we mentioned before, since we don't have our own handler for the <span class="strong"><strong>MyAction</strong></span> node, the default <code class="literal">Tick</code> method is <a id="id410" class="indexterm"></a>called and it's <a id="id411" class="indexterm"></a>printing this message. So let's go back to our script and write our own handler function for the <span class="strong"><strong>MyAction</strong></span> node, as given in the following code:</p><div class="informalexample"><pre class="programlisting">  public BehaveResult TickMyActionAction (Tree sender) {
     Debug.Log ("MyAction ticked!");
    return BehaveResult.Success;
  }</pre></div><p>To implement your own action handler you just need to follow this specific naming pattern, which is <code class="literal">BehaveResult Tick{Name}Action (Tree sender)</code>. In this example, <code class="literal">{Name}</code> is the name of our action, <span class="strong"><strong>MyAction</strong></span>. Now if you play the project you'll see the log message printed by your own action handler as follows:</p><div class="mediaobject"><img src="/graphics/9781849693400/graphics/3400OT_09_17.jpg" /><div class="caption"><p>Action results</p></div></div><p>With that you should have a basic understanding of how to use Behave. Next we'll move on to other elements that are used to control the execution flow of actions in our behavior tree.</p></div>