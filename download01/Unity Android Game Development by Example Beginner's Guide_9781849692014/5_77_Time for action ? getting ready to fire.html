<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec79"></a>Time for action – getting ready to fire</h2></div></div><hr /></div><p>The enemy will shoot in a similar manner<a id="id389" class="indexterm"></a> to how the player fires, but we will use some basic AI to control the direction and firing speed, replacing the player's input controls:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We will start this off with a new script called <code class="literal">ShootAtPlayer</code>. Create it in the <code class="literal">Scripts</code> folder.</p></li><li><p>As with all our other scripts, we start this one out with two variables. The first variable will hold the last position the enemy tank was at. It will not be shooting if the tank is in motion, so we need to store that last position to see if we have moved. The second variable will be the maximum speed at which we can move and shoot. If the tank moves faster than this, it will not fire.</p><div class="informalexample"><pre class="programlisting">private Vector3 lastPosition = Vector3.zero;
public float maxSpeed = 1f;</pre></div></li><li><p>The next two variables dictate how long it takes the tank to ready a shot. It is unrealistic to be shooting the player in every single frame. So, we use the first variable to adjust the length of time it takes to ready a shot, and the second to store when the shot is ready.</p><div class="informalexample"><pre class="programlisting">public float readyLength = 2f;
private float readyTime = -1;</pre></div></li><li><p>The next variable is how fast the turret can rotate. While the tank is readying its shot, the turret will not be rotating to point at the player. That gives the player an opportunity to move out of the way. However, we need a speed to keep the turret from snapping to face the player after shooting.</p><div class="informalexample"><pre class="programlisting">public float turretSpeed = 45f;</pre></div></li><li><p>The last two variables here hold references to other parts of the tank. The <code class="literal">turretPivot</code> variable, of course, is the pivot of the turret that we will be rotating. The <code class="literal">muzzlePoint</code> variable will be used as the point from where our cannon is fired. These will be used in the same manner as the ones for the player's tank.</p><div class="informalexample"><pre class="programlisting">public Transform turretPivot;
public Transform muzzlePoint;</pre></div></li><li><p>For the first function of the script, we will make use of the <a id="id390" class="indexterm"></a>
<code class="literal">Update</code> function. It starts by calling a function that will check to see whether it is possible to fire the cannon. If we can fire, we perform some checks on our <code class="literal">readyTime</code> variable. If it is less than zero, we have not yet begun to ready our shot and call a function to do so. Otherwise, if it is less than the current time, we have finished the preparation<a id="id391" class="indexterm"></a> and call the function to fire the cannon. If we are unable to fire, we first call a function to clear any preparations and then rotate the turret to face the player.</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(CheckCanFire()) {
    if(readyTime &lt; 0) {
      PrepareFire();
    }
    else if(readyTime &lt;= Time.time) {
      Fire();
    }
  }
  else {
    ClearFire();
    RotateTurret();
  }
}</pre></div></li><li><p>Next, we will create our <code class="literal">CheckCanFire</code> function. The first part of code checks to see if we have moved too fast. First, we use <code class="literal">Vector3.Distance</code> to see how far we have moved since the last frame. By dividing the distance by the length of the frame, we are able to determine the speed with which we moved. Next, we update our <code class="literal">lastPosition</code> variable with our current position, so it is ready for the next frame. Finally, we compare the current speed with the <code class="literal">maxSpeed</code>. If we moved too fast in this frame, we are unable to fire and return a result of <code class="literal">false</code>.</p><div class="informalexample"><pre class="programlisting">public bool CheckCanFire() {
  float move = Vector3.Distance(lastPosition, transform.position);
  float speed = move / Time.deltaTime;

  lastPosition = transform.position;

  if(speed &gt; maxSpeed) return false;</pre></div></li><li><p>For the second half of the <code class="literal">CheckCanFire</code> function<a id="id392" class="indexterm"></a>, we check to see if the turret is pointed at the player. First, we find the direction to the player. Given any point in space and subtracting the second point's location from it, will give us the direction from the second point to the first as a vector. We then flatten the direction by setting the <code class="literal">y</code> value to <code class="literal">0</code>. This is done because we do not want to be looking up or down at the player. Then, we use <code class="literal">Vector3.Angle</code> to<a id="id393" class="indexterm"></a> find the angle between the direction to the player and our turret's forward direction. Finally, we compare the angle to a low value to determine whether we are looking at the player, and return the result.</p><div class="informalexample"><pre class="programlisting">  Vector3 targetDir = PlayerPosition.position – turretPivot.position;
  targetDir.y = 0;

  float angle = Vector3.Angle(targetDir, turretPivot.forward);

  return angle &lt; 0.1f;
}</pre></div></li><li><p>The <code class="literal">PrepareFire</code> function<a id="id394" class="indexterm"></a> is quick and easy. It simply sets our <code class="literal">readyTime</code> variable to the time in the future when the tank will be done preparing its shot.</p><div class="informalexample"><pre class="programlisting">public void PrepareFire() {
  readyTime = Time.time + readyLength;
}</pre></div></li><li><p>The <code class="literal">Fire</code> function starts by making sure that we have a <code class="literal">muzzlePoint</code> reference to shoot from.</p><div class="informalexample"><pre class="programlisting">public void Fire() {
  if(muzzlePoint == null) return;</pre></div></li><li><p>The function continues with the creation of a <code class="literal">RaycastHit</code> variable to store the result of our shot. We use <code class="literal">Physics.Raycast</code> and <code class="literal">SendMessage</code>, just as we did in the <code class="literal">FireControls</code> script, to shoot at anything and tell it that we hit it.</p><div class="informalexample"><pre class="programlisting">RaycastHit hit;
if(Physics.Raycast(muzzlePoint.position, muzzlePoint.forward, out hit)) {
  hit.transform.gameObject.SendMessage("RemovePoints", 3, SendMessageOptions.DontRequireReceiver);
}</pre></div></li><li><p>The <code class="literal">Fire</code> function<a id="id395" class="indexterm"></a> finishes by clearing the fire preparations.</p><div class="informalexample"><pre class="programlisting">  ClearFire();
}</pre></div></li><li><p>The <code class="literal">ClearFire</code> function<a id="id396" class="indexterm"></a> is another quick function. It sets our <code class="literal">readyTime</code> variable to be less than zero, indicating that the tank is not preparing to fire.</p><div class="informalexample"><pre class="programlisting">public void ClearFire() {
  readyTime = -1;
}</pre></div></li><li><p>The last function for the script is <code class="literal">RotateTurret</code>. It begins by checking the <code class="literal">turretPivot</code> variable and canceling the function should the reference be missing. It is followed by the finding of the flat direction that points at the player, just as we did earlier. Next, <a id="id397" class="indexterm"></a>we create the <code class="literal">step</code> variable to hold how much we can move this frame. We use <code class="literal">Vector3.RotateTowards</code> to find a vector that is closer to pointing at our target than the current forward direction is. Finally, we use <code class="literal">Quaternion.LookRotation</code> to create a special rotation that points our turret in the new direction.</p><div class="informalexample"><pre class="programlisting">public void RotateTurret() {
  if(turretPivot == null) return;

  Vector3 targetDir = PlayerPosition.position – turretPivot.position;
  targetDir.y = 0;

  float step = turretSpeed * Time.deltaTime;

  Vector3 rotateDir = Vector3.RotateTowards(turretPivot.forward, targetDir, step, 0);
  turretPivot.rotation = Quaternion.LookRotation(rotateDir);
}</pre></div></li><li><p>Now, returning to Unity, create an empty <span class="strong"><strong>GameObject</strong></span> and rename it to <code class="literal">MuzzlePoint</code>.</p></li><li><p>Position <code class="literal">MuzzlePoint</code> as we did for the player, at the end of the cannon.</p></li><li><p>Make <code class="literal">MuzzlePoint</code> a child of the cannon and zero out any <span class="strong"><strong>Y</strong></span> rotation that might be on it, in the <span class="strong"><strong>Inspector</strong></span> window.</p></li><li><p>Next, add our new <code class="literal">ShootAtPlayer</code> script to the enemy tank. Additionally, connect the references to the <code class="literal">TurretPivot</code> and <code class="literal">MuzzlePoint</code> variables.</p></li><li><p>Finally, for the enemy tank, hit the <span class="strong"><strong>Apply</strong></span> button in the <span class="strong"><strong>Inspector</strong></span> window to update the prefab.</p></li><li><p>If you play the game now, you will see the enemy rotating to point at you, but your score never decreases. This is because of two issues. First, the tank is slightly floating. It doesn't matter where in the world you place it, when playing the game, the tank will slightly float. This is because of the way the NavMeshAgent component functions. The fix is simple, just set the <span class="strong"><strong>Base Offset</strong></span> to <code class="literal">-0.3</code> in the <span class="strong"><strong>Inspector</strong></span> window. This tricks the system and puts the tank on the ground.</p></li><li><p>The second reason the score isn't changing is because the player is missing a function. Open the <code class="literal">ScoreCounter</code> script.</p></li><li><p>We will be adding the <code class="literal">RemovePoints</code> function<a id="id398" class="indexterm"></a>. Given an amount, this function simply removes<a id="id399" class="indexterm"></a> that many points from the player's score.</p><div class="informalexample"><pre class="programlisting">public void RemovePoints(int amount) {
  score -= amount;
}</pre></div><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_05_05.jpg" /></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec72"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>We gave the enemy the ability to attack the player. The new <code class="literal">ShootAtPlayer</code> script checks first to see whether the tank has slowed down and whether the cannon is trained on the player. If so, it will take regular shots at the player to reduce their score. The player is going to need to keep moving and aim at targets fast, if they hope to be left with any points at the end of the game.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec73"></a>Have a go hero – player feedback</h3></div></div></div><p>Unless you are paying close attention to your score, it is difficult to tell when you are being shot at. We will be working with explosions in a future chapter but, even so, the player needs some feedback to tell what is going on. Most games will flash a red texture on the screen when the player is hit, whether or not there are any explosions. Try creating a simple texture and drawing it on the screen for half a second when the player is hit.</p></div></div>