<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec43"></a>Time for action – controlling the chassis</h2></div></div><hr /></div><p>A normal tank rotates in place, and it can easily move forward and back. We will make our tank do this with the creation of a single script.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The second script is called <code class="literal">ChassisControls</code>. It will make our tank move around. Create it in the <code class="literal">Scripts</code> folder as well.</p></li><li><p>The first three lines<a id="id219" class="indexterm"></a> of the script define the variables the tank will need to move around. We will also be able to change them in the <span class="strong"><strong>Inspector</strong></span> window, in case our tank is too fast or too slow. The first line defines a variable that holds a connection to a <code class="literal">CharacterController</code> component. This component will easily move the tank around, but will allow it to be stopped by walls and other colliders. The next two lines of code define how fast we move and rotate:</p><div class="informalexample"><pre class="programlisting">public CharacterController characterControl;
public float moveSpeed = 10f;
public float rotateSpeed = 45f;</pre></div></li><li><p>Now let's add our good friend <code class="literal">OnGUI</code> to the mix. This should look mostly familiar. We are<a id="id220" class="indexterm"></a> creating four buttons that will sit in the bottom-left corner of the screen. When the first two buttons are pressed, we make a call to a function that will move our tank and give it a value for how fast it can move. A positive value is going to move us forward and a negative value will move us backward. The last two buttons do the same thing, except with rotation instead of movement. A positive value will rotate to the right and a negative value will rotate the tank to the left. These buttons are also <code class="literal">RepeatButtons</code>. A normal button will only activate once for each time it is pressed. A repeat button is active as long as it is held down. The good side of this is that it will allow our tank to move every frame the button is held down. The down side is a quirk in how the <code class="literal">RepeatButton</code> and <code class="literal">OnGUI</code> functions work. If one of these buttons is active, nothing will be drawn after that button in the <code class="literal">OnGUI</code> function. It is a bit annoying, but suits our needs for now.</p><div class="informalexample"><pre class="programlisting">public void OnGUI() {
  Rect fore = new Rect(50, Screen.height – 150, 50, 50);
  if(GUI.RepeatButton(fore, "f")) {
    MoveTank(moveSpeed);
  }

  Rect back = new Rect(50, Screen.height – 50, 50, 50);
  if(GUI.RepeatButton(back, "b")) {
    MoveTank(-moveSpeed);
  }

  Rect left = new Rect(0, Screen.height – 100, 50, 50);
  if(GUI.RepeatButton(left, "l")) {
    RotateTank(-rotateSpeed);
  }

  Rect right = new Rect(100, Screen.height – 100, 50, 50);
  if(GUI.RepeatButton(right, "r")) {
    RotateTank(rotateSpeed);
  }
}</pre></div></li><li><p>Only two functions left to go. We start the following line of code by defining our <code class="literal">MoveTank</code> function. It needs to be passed with a speed value to dictate how far and in which direction to go. It was mentioned a moment ago; a positive value will go forward and a negative value will go backwards.</p><div class="informalexample"><pre class="programlisting">public void MoveTank(float speed) {</pre></div></li><li><p>In order to move in three-dimensional spaces, we need a vector—a value with both direction and magnitude. Therefore, we define a movement vector and set it to the tank's forward direction, multiplied by the tank's speed, and again multiplied by the amount of time since the last frame. If you remember from the geometry class, <a id="id221" class="indexterm"></a>3D space has three directions: x, y, and z. In Unity, the following convention applies: x is to the right, y is up, and z is forward. The <span class="strong"><strong>Transform</strong></span> component holds an object's position, rotation, and scale. We can access the <span class="strong"><strong>Transform</strong></span> component of any object in Unity by calling upon the <code class="literal">.transform</code> value that Unity provides. The <span class="strong"><strong>Transform</strong></span> component also provides a forward value that will give us a vector that points forward relative to the object. Also, we want to move at a regular pace, for example, a certain number of meters per second, hence we make use of <code class="literal">Time.deltaTime</code>. This is a value provided by Unity that holds how many seconds it has been since the last frame of the game was drawn on screen. Think of it like a flip book. In order to make it look like a guy is walking across the page, he needs to move slightly on each page. In the case of a game, the pages are not flipped regularly. So, we have to modify our movement by how long it has taken to flip to the new page. This helps us to maintain an even pace.</p><div class="informalexample"><pre class="programlisting">  Vector3 move = characterControl.transform.forward * speed * Time.deltaTime;</pre></div></li><li><p>Next, we want to stay on the ground. In general, any character you want to control in a game does not automatically receive all of the physics that a boulder would, such as gravity. For example, when jumping,  you temporarily remove gravity so the character can go up. That is why the next line of code does a simple implementation of gravity by subtracting the normal speed of gravity and again keeps it in pace with our frame rate:</p><div class="informalexample"><pre class="programlisting">  move.y -= 9.8f * Time.deltaTime;</pre></div></li><li><p>Finally, for the <a id="id222" class="indexterm"></a>
<code class="literal">MoveTank</code> function, we actually do the moving. The <code class="literal">CharacterController</code> component has a special <code class="literal">Move</code> function that will move the character but constrain it by collisions. We just need to tell it how far and in which direction we want to move this frame by passing the <code class="literal">Move</code> vector to it. That final curly brace, of course, closes off the function.</p><div class="informalexample"><pre class="programlisting">  characterControl.Move(move);
}</pre></div></li><li><p>The <code class="literal">RotateTank</code> function is the last one. This function also needs a speed value to dictate how fast and in which direction to rotate. We start by defining another vector; but, instead of defining which direction to move, this one will dictate which direction to rotate around. In this case, we will be rotating around our up direction. We then multiply that by our speed and <code class="literal">Time.deltaTime</code> to move fast enough and keep pace with our frame rate.</p><div class="informalexample"><pre class="programlisting">public void RotateTank(float speed) {Vector3 rotate = Vector3.up * speed * Time.deltaTime;</pre></div></li><li><p>The last bit of the function actually does the rotation. The <span class="strong"><strong>Transform</strong></span> component provides a <code class="literal">Rotate</code> function. Rotation, especially in 3D space, can become weird and<a id="id223" class="indexterm"></a> difficult very quickly. The <code class="literal">Rotate</code> function handles all of that for us; we just need to supply it with the values to be applied for rotation. Also, don't forget the curly brace to close off the function.</p><div class="informalexample"><pre class="programlisting">  characterControl.transform.Rotate(rotate);
}</pre></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec29"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>We created a script to control the movement of our tank. It will draw a group of buttons on the screen, so that our tank can move forward and back. This is done using a special <code class="literal">Move</code> function from the <code class="literal">CharacterController</code> component. We also used a special <code class="literal">Rotate</code> function provided by the <span class="strong"><strong>Transform</strong></span> component to rotate our tank using another set of buttons.</p></div></div>