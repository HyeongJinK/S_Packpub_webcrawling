<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec89"></a>Time for action â€“ flying asteroids</h2></div></div><hr /></div><p>The first objects we <a id="id418" class="indexterm"></a>will be avoiding in our infinite space will be asteroids:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To make the asteroids work, we will first need to make the player ship's rotation and speed available for the asteroids to use. To do this, we need to create a new script and call it <code class="literal">PlayerShip</code>.</p></li><li><p>Again, this script starts with a group of variables. The first is the speed of the player's ship. The asteroids and other objects in the space will use it to move around the player. The second variable will hold a reference to the <code class="literal">TiltSteering</code> script that we created earlier. This will give us access to the ship's rotational speed. The last variable is a static variable that will hold a reference to the instance of this script that exists in the scene. This will allow other scripts to access the information stored by this script. We call the <code class="literal">use</code> variable to indicate to other scripts that this is the instance they should access.</p><div class="informalexample"><pre class="programlisting">public float speed = 10f;
public TiltSteering tilt;

private static PlayerShip use;</pre></div></li><li><p>Next, we make use of the <code class="literal">Awake</code> function. This function is automatically called at the beginning of the game, making it perfect for initialization. We are using it to simply set the <code class="literal">use</code> variable that we created earlier to the current instance of the script.</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  use = this;
}</pre></div></li><li><p>The next function is for providing other scripts with the player's current rotation. Being static, any script can call it at any time. The function first checks to see whether a reference is available to the current instance of the script. If it cannot be found, a neutral rotation, <code class="literal">Quaternion.identity</code>, is returned. Otherwise, the rotation of the transform that the script instance is attached to is returned.</p><div class="informalexample"><pre class="programlisting">public static Quaternion GetRotation() {
  if(use == null) return Quaternion.identity;

  return use.transform.rotation;
}</pre></div></li><li><p>The <code class="literal">Rotate</code> function here is for faking the movement of the player. This function takes<a id="id419" class="indexterm"></a> the transform that is passed to it and moves and rotates it to make it look like it is the player that has moved through space. As with the previous <code class="literal">GetRotation</code> function, it first checks for a reference to the player and does nothing if there isn't one.</p><div class="informalexample"><pre class="programlisting">public static void Rotate(Transform other) {
  if(use == null) return;</pre></div></li><li><p>To rotate the asteroid, and anything else, around the player's position, its current position needs to be multiplied by the mirror of the player's current rotation. To do that, we need to adjust the rotation so that it can be mirrored properly. The Euler angles of the player's rotation are stored in a variable for manipulation. We then shift the values that are greater than 180, just as we did earlier. The rotation is then scaled by the player ship's rotation speed. Finally, it is multiplied by the frame speed to keep it in time.</p><div class="informalexample"><pre class="programlisting">Vector3 euler = use.transform.eulerAngles;
if(euler.x &gt; 180f) euler.x -= 360f;
if(euler.y &gt; 180f) euler.y -= 360f;
euler.Scale(new Vector3(use.tilt.vertRotateSpeed, use.tilt.horizRotateSpeed, 0));
euler *= Time.deltaTime;</pre></div></li><li><p>We turn the negative Euler rotation, which is the mirrored rotation, back into a Quaternion and store it in a variable for use.</p><div class="informalexample"><pre class="programlisting">Quaternion mirror = Quaternion.Euler(-euler);</pre></div></li><li><p>The mirrored rotation is then multiplied by the passed object's position, updating the position to be rotated around the player as if they were turning. The player's rotation is then multiplied by a forward-facing vector, the player's speed, and finally the frame speed. This is all subtracted from the object's current position in order to imitate the player's forward movement. Finally, the passed object's rotation is multiplied by the mirrored rotation to change its orientation. Altogether, this fakes the movement of the player.</p><div class="informalexample"><pre class="programlisting">other.position = mirror * other.position;
other.position -= playerRotation * Vector3.forward * use.speed * Time.deltaTime;
other.rotation *= mirror;</pre></div></li><li><p>Add the script to the <code class="literal">PlayerShipPivot</code> object that was created previously. Be sure to connect the <code class="literal">TiltSteering</code> reference.</p></li><li><p>Next, we need to make use of that script by creating another. Name it <code class="literal">Asteroid</code>. This script will control an asteroid as it flies through space and the player is forced to avoid it.</p></li><li><p>The first two of the variables for this script are used for determining a random speed at which the asteroid will fly through space. The third variable will hold the<a id="id420" class="indexterm"></a> random speed. The final variable will hold the random direction in which the asteroid is flying through space.</p><div class="informalexample"><pre class="programlisting">public float minSpeed = 5f;
public float maxSpeed = 10f;

private float speed = 1f;
private Vector3 direction = Vector3.forward;</pre></div></li><li><p>Next, we again make use of the <code class="literal">Awake</code> function<a id="id421" class="indexterm"></a> for initialization. Any point that lies on the surface of a sphere with a radius of one is essentially a vector that points in a random direction. Therefore, we use <code class="literal">Random.onUnitSphere</code> to find a random direction for the asteroid to go. It is followed by the use of <code class="literal">Random.Range</code> and the first two variables to determine a random speed for the asteroid to travel.</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  direction = Random.onUnitSphere;
  speed = Random.Range(minSpeed, maxSpeed);
}</pre></div></li><li><p>The last function for this script is <code class="literal">LateUpdate</code>. We need the asteroid to move after the player's ship has updated its rotation; that is why we use this function. The first line of the function uses the <code class="literal">GetRotation</code> function<a id="id422" class="indexterm"></a> that we created for the <code class="literal">PlayerShip</code> script and stores it in a variable for use.</p><div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  Quaternion playerRotation = PlayerShip.GetRotation();</pre></div></li><li><p>Next, we make a call to the <code class="literal">PlayerShip.Rotate</code> function<a id="id423" class="indexterm"></a>, passing it the asteroid's transform, so that the asteroid can be moved to fake the player's movement.</p><div class="informalexample"><pre class="programlisting">PlayerShip.Rotate(transform);</pre></div></li><li><p>The next line of code rotates the asteroid's movement direction by the player's rotation, again making a change that fakes the player's movement. The position is again updated with the asteroid's own movement in the adjusted direction.</p><div class="informalexample"><pre class="programlisting">direction = playerRotation * direction;
transform.position += direction * speed * Time.deltaTime;</pre></div></li><li><p>The function and the script finishes with a check to see if the asteroid is too far away from the player. We do this by checking <code class="literal">sqrMagnitude</code> of the asteroid's position. The length of a vector is its magnitude. For positional vectors, this is the distance from the center point. The <code class="literal">sqrMagnitude</code> is the square of the<a id="id424" class="indexterm"></a> vector's magnitude. This is much faster to calculate and just as easy for comparison. We just need to compare it to the square of the desired value. In this case a max distance of about 300, whose square is 100,000, will work well for our needs. If you remember from math class, 1e5 is the same as a one with five zeros behind it, which is 1 million. Finally, if the asteroid is too far away, it is destroyed.</p><div class="informalexample"><pre class="programlisting">  if(transform.position.sqrMagnitude &gt; 1e5) Destroy(gameObject);
}</pre></div></li><li><p>In order to test this script, we need an asteroid prefab. To create it, start off by adding the <code class="literal">Asteroid</code> model to the scene and deleting two of the three meshes.</p></li><li><p>Add the script to the model and drag it to the <code class="literal">Prefabs</code> folder, turning it into a prefab.</p><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_06_02.jpg" /></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec82"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>We created two scripts and a prefab. The first script is used by the player's ship to relay information about its rotation and speed to other scripts. The second script controls the motion of asteroids in the<a id="id425" class="indexterm"></a> game world. Because of the weirdness in the model's behavior when subjected to extreme distances, the player never actually moves. The game world and all of the objects in it are instead moved around the player. Finally, we created an asteroid prefab. Try adding several prefabs to the scene and try them out. You can fly in, out, and around them even though your ship never actually moves.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec83"></a>Adding space collisions</h3></div></div></div><p>Flying around, you probably noticed that you can fly straight through the asteroids. To make it possible for the player to hit them, we need to add some collision to the player's ship and the asteroid. This is similar to what was done for the Tank Battle game. We will be going into more <a id="id426" class="indexterm"></a>detail about how the collision works in the next chapter, but we will need to make use of the <span class="strong"><strong>Rigidbody</strong></span> component. It provides access to Physics calculations and allows us to group colliders to make more complex collision shapes.</p></div></div>