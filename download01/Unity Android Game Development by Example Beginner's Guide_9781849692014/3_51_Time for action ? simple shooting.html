<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec55"></a>Time for action – simple shooting</h2></div></div><hr /></div><p>With the addition of one more object <a id="id276" class="indexterm"></a>and a single script, we can start shooting at our targets.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, we need to add an empty <code class="literal">GameObject</code> to our tank. Rename it to <code class="literal">MuzzlePoint</code> and make it a child of the cannon's pivot point object. Once done, position it at the end of the cannon so the blue arrow points away from the tank, along the same direction as the cannon. This will be the point where our bullets will come from.</p></li><li><p>We also need something to indicate where we are shooting. The explosions are covered in future chapters, so choose <span class="strong"><strong>Sphere</strong></span> from the <span class="strong"><strong>Create Other</strong></span> menu and rename it <code class="literal">TargetPoint</code>.</p></li><li><p>Set the sphere's scale to <code class="literal">0.2</code> for each axis<a id="id277" class="indexterm"></a> and give it a red material. This way it can be more easily seen, without being completely obtrusive.</p></li><li><p>Remove the <code class="literal">SphereCollider</code> component from <code class="literal">TargetPoint</code>. The <code class="literal">SphereCollider</code> has to be removed because we don't want to shoot our own target indicator.</p></li><li><p>Now, create a new script and call it <code class="literal">FireControls</code>.</p></li><li><p>This should start to look familiar to you. We start with variables to hold references to our muzzle and targeting objects that we just created. They are followed by an <a id="id278" class="indexterm"></a>
<code class="literal">OnGUI</code> function that draws a button in the bottom-right corner of the screen, just above where we drew the turret control buttons. If the button is pressed, we call upon the <code class="literal">Fire</code> function that we will create next.</p><div class="informalexample"><pre class="programlisting">public Transform muzzlePoint;
public Transform targetPoint;

public void OnGUI() {
  Rect fire = new Rect(Screen.width – 70, Screen.height – 220, 50, 50);
  if(GUI.Button(fire, "Fire")) {
    Fire();
  }
}</pre></div></li><li><p>The <code class="literal">Fire</code> function starts by defining a variable that will hold the detailed information about what was shot. It is followed by an <code class="literal">if</code> statement that checks the <code class="literal">Physics.Raycast</code> function. The <code class="literal">Raycast</code> function<a id="id279" class="indexterm"></a> works just like shooting a gun. We start with a position (the muzzle point's position) pointing in a specific direction (forward relative to the muzzle point) and get out what was hit. If we hit something, the <code class="literal">if</code> statement evaluates to true; otherwise it is false and we would skip ahead. When we do hit something, we first move our target point to the point that was hit. We then use the <code class="literal">SendMessage</code> function to tell what we hit that it was hit. The <code class="literal">SendMessage</code> function<a id="id280" class="indexterm"></a> is only available for <code class="literal">GameObjects</code> and <code class="literal">MonoBehaviours</code>, and our <code class="literal">Target</code> script is on the root object for the target, hence the <code class="literal">hit.transform.root.gameObject</code> in order to get at the <code class="literal">GameObject</code> that was hit. The <a id="id281" class="indexterm"></a>
<code class="literal">SendMessage</code> function takes the name of a function and tries to find it on the <code class="literal">GameObject</code> to which the message was sent. We are also providing it with a value, <code class="literal">hit.point</code>, to give to the function that should be found. The <code class="literal">SendMessageOptions.DontRequireReceiver</code> part of the line keeps the function from throwing an error if it is unable to find the desired function. The last part of our <code class="literal">Fire</code> function <a id="id282" class="indexterm"></a>occurs if we didn't hit anything. We send our target point back to the world origin, so the player can tell that they missed everything.</p><div class="informalexample"><pre class="programlisting">public void Fire() {
  RaycastHit hit;
  if(Physics.Raycast(muzzlePoint.position, muzzlePoint.forward, out hit)) {
    targetPoint.position = hit.point;
    hit.transform.root.gameObject.SendMessage("Hit", hit.point, SendMessageOptions.DontRequireReceiver);
  }
  else {
    targetPoint.position = Vector3.zero;
  }
}</pre></div></li><li><p>The last thing to do is to add the <code class="literal">Hit</code> function to the end of our <code class="literal">Target</code> script. We start the function by getting the current state ID, just as we did earlier in the script. However, this time we check only against our extended idle ID. If they do not match, we use return to exit the function early. We do this because we don't want to let the player shoot any targets that are down or in mid transition. If our state is correct, we continue by telling the animation that we were hit using the <code class="literal">SetBool</code> function<a id="id283" class="indexterm"></a>.</p><div class="informalexample"><pre class="programlisting">public void Hit(Vector3 point) {
  int currentStateId = animator.GetCurrentAnimatorStateInfo(0).nameHash;
  if(currentStateId != idleExtendId) return;
  animator.SetBool(wasHitId, true);</pre></div></li><li><p>The rest of the <code class="literal">Hit</code> function figures out which side the target was hit on. To do this, we first had to convert the point that we received from world space into local space. The <code class="literal">InverseTransformPoint</code> function<a id="id284" class="indexterm"></a> from our <span class="strong"><strong>Transform</strong></span> component does this nicely. We then do a check to see where the shot came from. Because of the way the target is constructed, if the shot was positive on the x axis, it came from behind. Otherwise, it came from the front. Either way, we set the <code class="literal">inTheFront</code> parameter<a id="id285" class="indexterm"></a> from our state machine to the proper value. Then we give the player some points by incrementing the static variable that we created on our <code class="literal">ScoreCounter</code> script, way back at the beginning of the chapter.</p><div class="informalexample"><pre class="programlisting">Vector3 localPoint = transform.InverseTransformPoint(point);
  if(localPoint.x &gt; 0) {
    animator.SetBool(inTheFrontId, false);
    ScoreCounter.score += 5;
  }
  else {
    animator.SetBool(inTheFrontId, true);
    ScoreCounter.score += 10;
  }
}</pre></div></li><li><p>Finally, be sure to add the<a id="id286" class="indexterm"></a> new <code class="literal">FireControls</code> script to the tank. Also, you need to connect the references to the <code class="literal">MuzzelPoint</code> and <code class="literal">TargetPoint</code> objects.</p></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec45"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>We created a script that allows us to fire the cannon of our tank. The method of using ray tracing is the simplest and most widely used. In general, bullets fly too fast for us to see them. Ray tracing is like this, that is; it is instant. However, this method does not take gravity, or anything else that might change the direction of a bullet, into account.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec46"></a>Have a go hero – better GUI</h3></div></div></div><p>Now that all of the buttons and components are in place, make them look better. Use the skills you gained from the previous chapter to style the GUI and make it great. Perhaps you could even manage to create a directional pad for the movement.</p></div></div>