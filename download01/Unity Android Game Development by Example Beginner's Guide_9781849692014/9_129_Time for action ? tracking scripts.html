<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec127"></a>Time for action – tracking scripts</h2></div></div><hr /></div><p>We will be creating this script in the Space Fighter game:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, we will need a special class that will keep track of our performance statistics. Create a new script and name it <code class="literal">TrackerStat</code>.</p></li><li><p>To begin this script, we first need to change the class definition line. We do not want or need to extend the <code class="literal">MonoBehaviour</code> class. So, find the following line of code:</p><div class="informalexample"><pre class="programlisting">public class TrackerStat : MonoBehaviour {</pre></div><p>And, change it to the following:</p><div class="informalexample"><pre class="programlisting">public class TrackerStat {</pre></div></li><li><p>This script starts with four variables. The first will be used as an ID, allowing us to track multiple scripts at once by supplying different key values. The second will keep track of the average amount of time that the tracked bits of code are taking. The third is just the total number of times the tracked code has been called. The fourth is the longest time the code has taken to execute.</p><div class="informalexample"><pre class="programlisting">public string key = "";
public float averageTime = 0;
public int totalCalls = 0;
public float longestCall = 0;</pre></div></li><li><p>Next, we have two more variables. These will do the work of actually tracking how long the script takes to execute. The first is the time when the tracking starts. The second is a flag marking that tracking has started.</p><div class="informalexample"><pre class="programlisting">public float openTime = 0;
public bool isOpen = false;</pre></div></li><li><p>The first function<a id="id728" class="indexterm"></a> for this script is <code class="literal">Open</code>. This function is called when we want to start tracking a bit of code. It first checks to see if the code is already being tracked. It uses <code class="literal">Debug.LogWarning</code> to send a warning to the <span class="strong"><strong>Console</strong></span> window, if it is. Next, it sets the flag marking that code is being tracked. Finally, the function tracks the time it was called by using <code class="literal">Time.realtimeSinceStartup</code>, which is the actual number of seconds since the game started.</p><div class="informalexample"><pre class="programlisting">public void Open() {
  if(isOpen) {
    Debug.LogWarning("Tracking is already open. Key: " + key);
  }

  isOpen = true;
  openTime = Time.realtimeSinceStartup;
}</pre></div></li><li><p>The next function, <code class="literal">Close</code>, acts as the opposite of the previous one. It is called when we have reached the end of the code we want to track. The time when the tracking should stop is passed to it. This is done to minimize the amount of excess code being executed. As with the previous function, it checks to see if tracking is being done, sending out another warning and exiting early if it is not. Next, the <code class="literal">isOpen</code> flag is cleared by setting it to <code class="literal">false</code>. Finally, the amount of time since tracking was opened is calculated and the <code class="literal">AddValue</code> function<a id="id729" class="indexterm"></a> is called.</p><div class="informalexample"><pre class="programlisting">public void Close(float closeTime) {
  if(!isOpen) {
    Debug.LogWarning("Tracking is already closed. Key: " + key);
    return;
  }
  isOpen = false;
  AddValue(closeTime - openTime);
}</pre></div></li><li><p>This last function for this script is <code class="literal">AddValue</code>. This function is passed <code class="literal">callLength</code>, the length of time that the tracked bit of code took. It then uses some math to add the value to <code class="literal">averageTime</code>. Next, the function compares the current <code class="literal">longestCall</code> with the new value and selects the longest. Finally, the function increments <code class="literal">totalCalls</code>.</p><div class="informalexample"><pre class="programlisting">public void AddValue(float callLength) {
  float totalTime = averageTime * totalCalls;
  averageTime = (totalTime + callLength) / (totalCalls + 1);

  longestCall = longestCall &lt; callLength ? callLength : longestCall;

  totalCalls++;
}</pre></div></li><li><p>Next, we need to<a id="id730" class="indexterm"></a> create another new script and name it <code class="literal">ScriptTracker</code>. This script will allow us to do actual performance tracking.</p></li><li><p>This script starts off with a single variable. This variable maintains all of the stats that are currently being tracked. Note the use of <code class="literal">static</code> here; it allows us to easily update the list from anywhere in the game.</p><div class="informalexample"><pre class="programlisting">private static TrackerStat[] stats = new TrackerStat[0];</pre></div></li><li><p>The first function for this script, <code class="literal">Open</code>, allows us to start tracking the code execution. It uses the <code class="literal">static</code> flag, so the function can be called easily by any script. A <code class="literal">key</code> value is passed to the function, allowing us to group track calls. The function starts by creating a variable to hold the <code class="literal">index</code> of the stat to start tracking. Next, it loops through the current set of <code class="literal">stats</code> to find a matching <code class="literal">key</code> value. If one is found, the <code class="literal">index</code> variable is updated with the value and the loop is exited.</p><div class="informalexample"><pre class="programlisting">public static void Open(string key) {
  int index = -1;

  for(int i=0;i&lt;stats.Length;i++) {
    if(stats[i].key == key) {
      index = i;
      break;
    }
  }</pre></div></li><li><p>The <code class="literal">Open</code> function<a id="id731" class="indexterm"></a> continues by checking if a stat was found. The <code class="literal">index</code> variable will only be less than zero if we make it through the whole loop of current <code class="literal">stats</code> and are unable to find a matching <code class="literal">key</code>. If one is not found, we call <code class="literal">AddNewStat</code>, which will be created shortly, to create the new stat for tracking. The <code class="literal">index</code> is then set to that of the new stat. Finally, the stat is triggered to start tracking by using the stat's <code class="literal">Open</code> function.</p><div class="informalexample"><pre class="programlisting">  if(index &lt; 0) {
    AddNewStat(key);
    index = stats.Length – 1;
  }

  stats[index].Open();
}</pre></div></li><li><p>The <code class="literal">AddNewStat</code> function<a id="id732" class="indexterm"></a> is passed the <code class="literal">key</code> of the stat that is to be created. It starts by storing the list of <code class="literal">stats</code> in a temporary variable and increasing the size of the <code class="literal">stats</code> list by one. Each value is then transferred from the <code class="literal">temp</code> list to the larger <code class="literal">stats</code> list. Finally, a new stat is created, it is assigned to the last slot in the <code class="literal">stats</code> list, and the <code class="literal">key</code> is set.</p><div class="informalexample"><pre class="programlisting">private static void AddNewStat(string key) {
  TrackerStat[] temp = stats;
  stats = new TrackerStat[temp.Length + 1];
  
  for(int i=0;i&lt;temp.Length;i++) {
    stats[i] = temp[i];
  }

  stats[stats.Length – 1] = new TrackerStat();
  stats[stats.Length – 1].key = key;
}</pre></div></li><li><p>Next, we have the <code class="literal">Close</code> function<a id="id733" class="indexterm"></a>. This function is passed the <code class="literal">key</code> value of the stat to be closed. It starts by finding the time that the function was called, minimizing the<a id="id734" class="indexterm"></a> amount of excess code being tracked. It continues by looping through the list of <code class="literal">stats</code> to find a matching <code class="literal">key</code>. If one is found, the stat's <code class="literal">Close</code> function is called and the function is exited. If a match is not found, <code class="literal">Debug.LogError</code> is called to send an error message to the <span class="strong"><strong>Console</strong></span> window.</p><div class="informalexample"><pre class="programlisting">public static void Close(string key) {
  float closeTime = Time.realtimeSinceStartup;

  for(int i=0;i&lt;stats.Length;i++) {
    if(stats[i].key == key) {
      stats[i].Close(closeTime);
      return;
    }
  }

  Debug.LogError("Tracking stat not found. Key: " + key);
}</pre></div></li><li><p>The last static function for this script is <code class="literal">Clear</code>. It only empties the stats list, making it ready for fresh tracking.</p><div class="informalexample"><pre class="programlisting">public static void Clear() {
  stats = new TrackerStat[0];
}</pre></div></li><li><p>The last step for the script is the <code class="literal">OnGUI</code> function. This function will let us see our statistics while the game is playing. In it we make heavy use of the <code class="literal">GUILayout</code> class and its functions. <code class="literal">GUILayout</code> automatically arranges the various GUI elements, allowing us to spend less time arranging and more time analyzing. We first use <code class="literal">BeginVertical</code> to start a vertical list of elements. <code class="literal">BeginHorizontal</code> is used to start a horizontal list of elements. The <code class="literal">Label</code> function is<a id="id735" class="indexterm"></a> then used to create titles for each row of our statistics. We are using the <code class="literal">GUILayout.Width</code> function to give each label a specific width, making the layout look much nicer. Next, <code class="literal">EndHorizontal</code> is called to close the horizontal list. Every call to <code class="literal">BeginHorizontal</code> must be paired with an <code class="literal">EndHorizontal</code> else Unity will make many complaints.</p><div class="informalexample"><pre class="programlisting">public void OnGUI() {
  GUILayout.BeginVertical();

  GUILayout.BeginHorizontal();
  GUILayout.Label("Key", GUILayout.Width(150));
  GUILayout.Label("Average", GUILayout.Width(100));
  GUILayout.Label("Total", GUILayout.Width(50));
  GUILayout.Label("Longest", GUILayout.Width(100));
  GUILayout.EndHorizontal();</pre></div></li><li><p>Next, we loop through our list of stats. For each, we create a horizontal list and use <code class="literal">Label</code> to draw each stat on the screen. The <code class="literal">ToString</code> function<a id="id736" class="indexterm"></a> is used to convert the numbers to strings, needed by the labels.</p><div class="informalexample"><pre class="programlisting">  for(int i=0;i&lt;stats.Length;i++) {
    GUILayout.BeginHorizontal();

    GUILayout.Label(stats[i].key.ToString(), GUILayout.Width(150));
    GUILayout.Label(stats[i].averageTime.ToString(), GUILayout.Width(100));
    GUILayout.Label(stats[i].totalCalls.ToString(), GUILayout.Width(50));
    GUILayout.Label(stats[i].longestCall.ToString(), GUILayout.Width(100));

    GUILayout.EndHorizontal();
  }</pre></div></li><li><p>The <code class="literal">OnGUI</code> function<a id="id737" class="indexterm"></a> finishes by creating a button, that calls upon the <code class="literal">Clear</code> function when clicked. And finally, the <code class="literal">EndVertical</code> function<a id="id738" class="indexterm"></a> is called to end the vertical list of elements. Every call to <code class="literal">BeginVertical</code> must be paired with a call to <code class="literal">EndVertical</code>, just as the horizontal lists.</p><div class="informalexample"><pre class="programlisting">  if(GUILayout.Button("Clear"))
    Clear();

  GUILayout.EndVertical();
}</pre></div></li><li><p>To test these <a id="id739" class="indexterm"></a>scripts, open up your <code class="literal">PlayerShip</code> script. To the beginning of the <code class="literal">Rotate</code> function, add the following line to start tracking how long it takes to run.</p><div class="informalexample"><pre class="programlisting">ScriptTracker.Open("PlayerShip_Rotate");</pre></div></li><li><p>Towards the end of the <a id="id740" class="indexterm"></a>
<code class="literal">Rotate</code> function, we need to call the <code class="literal">Close</code> function with the same key.</p><div class="informalexample"><pre class="programlisting">ScriptTracker.Close("PlayerShip_Rotate");</pre></div></li><li><p>Finally, create an empty game object and add your <code class="literal">ScriptTracker</code> script to it. Start the game and take a look at the results.</p><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_09_01.jpg" /></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec147"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>We created a tool for testing specific parts of code. By wrapping any bit of code in calls to the functions and sending a unique ID, we can determine how long it takes to execute the code. By averaging out the calls to the script, and wrapping different parts of code, we can determine exactly which parts of a script are taking the longest to complete. We can also find out if the parts of code have been called too many times. Both cases are ideal points to start looking at for minimizing processing and lag.</p><p>Be sure to remove any references to this tool before you deploy your game. If left in the final levels, it can add an unnecessary amount of load on the CPU. This adverse effect on the game could make the game unplayable. Always remember to clear out any uses of tools that are exclusively for Editor debugging.</p></div></div>