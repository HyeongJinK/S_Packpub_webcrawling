<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec25"></a>Time for action â€“ creating Tic-tac-toe</h2></div></div><hr /></div><p>The basic Tic-tac-toe game involves two players and a 3 x 3 grid. The players take turns filling X's and O's. The <a id="id98" class="indexterm"></a>player who first fills a line of three squares with his/her letter wins the game. If all squares are filled without a player achieving a line of three, the game is a tie. Let's perform the following steps to create our game:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The first thing to do is to create a project for this chapter. So, start up Unity and we will do just that.</p></li><li><p>If you have been following along so far, Unity should boot up into the last project that was open. This isn't a bad feature, but it can become extremely annoying. Think of it like this: you have been working on a project for a while and it has grown large. Now you need to quickly open something else, but Unity defaults to your huge project. If you wait for it to open before you can work on anything else, it can consume a lot of time. To change this feature, go to the top of the Unity window and click on <span class="strong"><strong>Edit</strong></span> followed by <span class="strong"><strong>Preferences</strong></span>. This is the same place where we changed our script editor's preferences. This time, though, we are going to change settings in the <span class="strong"><strong>General</strong></span> tab<a id="id99" class="indexterm"></a>. The following screenshot shows the options present under the <span class="strong"><strong>General</strong></span> tab:</p><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_02_01.png.jpg" /></div></li><li><p>At this moment,<a id="id100" class="indexterm"></a> the primary concern is the <span class="strong"><strong>Always Show Project Wizard</strong></span> option; however, we will still cover all of the options in turn. All the options under the <span class="strong"><strong>General</strong></span> tab are explained in detail as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Auto Refresh</strong></span>: This is one of the best features of Unity. As assets are changed outside of Unity, this option lets Unity automatically detect the change and refresh the asset inside your project.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Always Show Project Wizard</strong></span>: This is a great first option to go check whenever installing Unity. Instead of opening the last project, Unity opens <span class="strong"><strong>Project Wizard</strong></span>. From there, you can open any project of your choice or create a new one. This is always a good one to turn on.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Compress Assets on Import</strong></span>: This is the checkbox for automatically compressing your game assets when they are first imported to Unity.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Editor Analytics</strong></span>: This is the checkbox for Unity's anonymous usage statistics. Leave it checked and the Unity Editor sends info occasionally to the Unity source. It doesn't hurt anything to leave it on, and helps the Unity team make the Unity Editor better. But it comes down to personal preference.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Show Asset Store search hits</strong></span>: This setting is only relevant if you are planning to use the Asset Store. The Asset Store can be a great source of assets and tools for any game; however, since we are not going to use it, the relevance to this book is rather limited. It does what the name suggests. When you search the Asset Store for something from within the Unity Editor, the number of results is displayed based on this checkbox.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Verify Saving Assets</strong></span>: This is a good one to be left off. If this is on, every time you click on <span class="strong"><strong>Save</strong></span> in Unity. A dialog box will pop up so that you can make sure you save any and all of the assets that have changed since your last save. It is not so much about your models and textures, but concerned with Unity's internal files, the materials, and prefabs. Best to leave it off for now.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Skin (Pro Only)</strong></span>: This option only applies to Unity's pro users. It gives the option to switch between the light and dark versions of the Unity Editor. It is purely cosmetic, so go with your gut for this one.</p></li></ul></div></li><li><p>With your preferences <a id="id101" class="indexterm"></a>set, now go up to <span class="strong"><strong>File</strong></span> and follow it with selecting <span class="strong"><strong>Open Project</strong></span>.</p></li><li><p>Select the <span class="strong"><strong>Create New Project</strong></span> tab, followed by the <span class="strong"><strong>Browse...</strong></span> button to pick a location and name for the new project.</p></li><li><p>We will not be using any of the included packages, so click on <span class="strong"><strong>Create</strong></span> and we can get on with it.</p></li><li><p>Once Unity finishes initializing the new project, create two new scripts in the <span class="strong"><strong>Project</strong></span> panel, just as we did for the <span class="emphasis"><em>Hello World</em></span> project in the previous chapter. Name the new scripts as <code class="literal">TicTacToeControl</code> and <code class="literal">SquareState</code>. Open them and clear out the default functions; again, just as we did in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Saying Hello to Unity and Android</em></span>.</p></li><li><p>The <code class="literal">SquareState</code> script will hold the possible states of each square of our game board. To do that, clear everything out of the script and replace it with a simple enumeration. An enumeration is just a list of potential values. This one is concerned with the player who controls the square. Do X's control it, O's control it, or is it clear because the game board is traditionally clear by default. <code class="literal">Clear</code> becomes the first and therefore the default state.</p><div class="informalexample"><pre class="programlisting">public enum SquareState {
  Clear,
  XControl,
  OControl
}</pre></div></li><li><p>In our other script, <code class="literal">TicTacToeControl</code>, we start with two variables that will largely control the flow of the game. The first defines our game board. Traditionally the game is played on a 3 x 3 grid, therefore nine squares. The second line dictates whose turn it is. How it is going to change will be made clear in a little bit, but for now suffice it to say that if it is X's turn, the value will be true. If it is not X's turn, the value will be false.</p><div class="informalexample"><pre class="programlisting">public SquareState[] board = new SquareState[9];
public bool xTurn = true;</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip04"></a>Tip</h3><p>In Unity, every<a id="id102" class="indexterm"></a> script by default inherits from the <code class="literal">MonoBehaviour</code> class. This gives our scripts two primary benefits.</p><p>First, it allows us to add our scripts to objects as components. The filename of the script also needs to be the exact same as the class name within the script, if you plan on adding the script to an object.</p><p>The second benefit of the <code class="literal">MonoBehaviour</code> class is the variety of variables and functions that come with it. The variables give us access to all the parts that make up objects in Unity. The functions provide a number of automatic features and access to the game initialization and loop. This is what we are most interested in at this particular moment.</p></div></li><li><p>In order to draw anything in each GUI frame, one needs to utilize the <code class="literal">OnGUI</code> function provided by the <code class="literal">MonoBehaviour</code> class. That is where we will draw our game board. The <code class="literal">OnGUI</code> function lets us draw our interface every frame. Inside it, we will first define the width and height of our board squares.</p><div class="informalexample"><pre class="programlisting">public void OnGUI() {
  float width = 75;
  float height = 75;</pre></div></li><li><p>Following that is a pair of for-loops. Because our board is a 3 x 3 grid, we need the loops to count three rows of three squares.</p><div class="informalexample"><pre class="programlisting">for(int y=0;y&lt;3;y++) {
    for(int x=0;x&lt;3;x++) {</pre></div></li><li><p>Inside the loops we must first figure out which square we are currently drawing. It becomes hard to play a game, if you don't know which square was touched.</p><div class="informalexample"><pre class="programlisting">int boardIndex = (y * 3) + x;</pre></div></li><li><p>The next line of code defines whether the square is going to be drawn as a <code class="literal">Rect</code> class. A <code class="literal">Rect</code> class is defined in GUI space as x position, y position, width, and height. In Unity, GUI space is defined as the top-left corner being (0,0) and the bottom-right is <code class="literal">Screen.width</code>, <code class="literal">Screen.height</code>. The width and height of the screen are the number of pixels.</p><div class="informalexample"><pre class="programlisting">Rect square = new Rect(x * width, y * height, width, height);</pre></div></li><li><p>We then figure<a id="id103" class="indexterm"></a> out who controls the square. The following line of code is a little complicated, but it is really just a compressed <code class="literal">if</code> statement. Basically, it works like this: first check a condition and if it is true return the first value, whatever is between the question mark and the colon. If the condition is false, return the value after the colon. Two of these compressed <code class="literal">if</code> statements were combined here; if the square is owned by X, set our owner to X. Otherwise, if it is owned by O, set the owner to O. If neither of the conditions is true, nobody owns the square and we set our owner to an empty string.</p><div class="informalexample"><pre class="programlisting">string owner = board[boardIndex] == SquareState.XControl ? "X" : board[boardIndex] == SquareState.OControl ? "O" : "";</pre></div></li><li><p>Now that all the hard work of figuring out where we are is done, we actually draw our game board square. This is done through the use of a wonderful little function provided by Unity, <code class="literal">GUI.Button</code>. To use this function in its basic form, we must tell the function where the button should be drawn and what text to display, hence rect and string. We give it our square and owner variables, it does all the hard work of actually drawing on screen, and we are given back a Boolean result, whether or not the button was pressed. Therefore, we check it with an <code class="literal">if</code> statement and if true, we send to a new function which square was pressed, letting it handle setting the owner. Also, don't forget the extra curly braces to close up the loops and the function.</p><div class="informalexample"><pre class="programlisting">      if(GUI.Button(square, owner))
        SetControl(boardIndex);
    }
  }
}</pre></div></li><li><p>The <code class="literal">SetControl</code> function<a id="id104" class="indexterm"></a> is pretty short; it simply sets the owner for whichever square is passed to it. It first makes sure that the index given is actually within the range for our board. If it is not, we'll exit the function early. The next line of code sets control of the board square based on whose turn it is. If it is X's turn, set the square to <code class="literal">XControl</code>; otherwise set control to <code class="literal">OControl</code>. Finally we change whose turn it is. This is done by simply setting our <code class="literal">xTurn</code> Boolean to the opposite of itself, indicating that it is the other person's turn.</p><div class="informalexample"><pre class="programlisting">public void SetControl(int boardIndex) {
  if(boardIndex &lt; 0 || boardIndex &gt;= board.Length) return;

  board[boardIndex] = xTurn ? SquareState.XControl : SquareState.OControl;
  xTurn = !xTurn;
}</pre></div></li><li><p>We are<a id="id105" class="indexterm"></a> just about ready to play our game. We just need to set up the scene. To do this, start by dragging our <code class="literal">TicTacToeControl</code> script from the <span class="strong"><strong>Project</strong></span> pane of the Unity Editor  to the <span class="strong"><strong>Main Camera</strong></span> object in the <span class="strong"><strong>Hierarchy</strong></span> pane of the Unity Editor.</p></li><li><p>Now save the scene, just as we did in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Saying Hello to Unity and Android</em></span>, as <code class="literal">TicTacToe</code>.</p></li><li><p>It is possible to play the game at this point. It is also possible to do so on a device; just follow the same steps as in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Saying Hello to Unity and Android</em></span>, but for now just perform testing in the Unity Editor. Later in this chapter we will cover a much easier way to build to our devices.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip05"></a>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>We created the very base of what we need to play Tic-tac-toe. We did this with two short and simple scripts. However, while playing the game now, you probably noticed a few things about it. For starters, it doesn't look particularly fantastic. That is extremely odd, considering it is the point of this chapter, but we will address that soon enough. Second, there are no checks to determine whether or not somebody already controls a square.</p><p>Also, there are no checks to see if anybody won the game. Finally, if you decided to build to device, you might have noticed one of the great things about Unity's GUI functions. There is no special programming needed to make any of the GUI functions work with touch inputs rather than the mouse. A lot of time is saved when you don't have to worry about special inputs, especially if you plan on multiplatform targeting.</p></div></div>