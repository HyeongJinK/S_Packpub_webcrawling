<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec44"></a>Time for action – controlling the turret</h2></div></div><hr /></div><p>This script will allow the player<a id="id224" class="indexterm"></a> to rotate their turret and aim the cannon.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The last script we need to create for our tank is <code class="literal">TurretControls</code>. This script will allow players to rotate the turret left and right and tilt the cannon up and down. As with all of the others, create it in the <code class="literal">Scripts</code> folder.</p></li><li><p>The first two variables we define will hold pointers to the turret and cannon pivots, the empty <code class="literal">GameObjects</code> that we created for our tank. The second set is the speed that our turret and cannon will rotate at. Finally we have some limit values. If we didn't limit how much our cannon could rotate, it would just spin around and around, passing through our tank. This isn't the most realistic behavior for a tank, so we must put some limits on it. The limits are in the range of 300 because straight ahead is zero degree and down is 90 degree. We want it to be the upwards angle, so it is in the range of 300. We also use 359.9 because Unity will change 360 to zero so it can continue to rotate.</p><div class="informalexample"><pre class="programlisting">public Transform turretPivot;
public Transform cannonPivot;

public float turretSpeed = 45f;
public float cannonSpeed = 20f;

public float lowCannonLimit = 315f;
public float highCannonLimit = 359.9f;</pre></div></li><li><p>The next step is to create the <code class="literal">OnGUI</code> function to draw buttons and give the player control of the turret. This function is almost identical to the <code class="literal">OnGUI</code> function we made for the <code class="literal">ChassisControls</code> script. The differences are in the fact that the <code class="literal">Rects</code> class will move to the bottom-right corner of the screen, and that we are calling the <code class="literal">RotateCannon</code> and <code class="literal">RotateTurret</code> functions. When we send a speed to <code class="literal">RotateCannon</code>, we need a positive value to go up and a negative value to <a id="id225" class="indexterm"></a>go down. <code class="literal">RotateTurret</code> will largely function like the <code class="literal">RotateTank</code> function; a positive speed will rotate to the right and a negative speed will rotate to the left.</p><div class="informalexample"><pre class="programlisting">public void OnGUI() {
  Rect up = new Rect(Screen.width – 100, Screen.height – 150, 50, 50);
  if(GUI.RepeatButton(up, "u")) {
    RotateCannon(cannonSpeed);
  }

  Rect down = new Rect(Screen.width – 100, Screen.height – 50, 50, 50);
  if(GUI.RepeatButton(down, "d")) {
    RotateCannon(-cannonSpeed);
  }

  Rect left = new Rect(Screen.width – 150, Screen.height – 100, 50, 50);
  if(GUI.RepeatButton(left, "l")) {
    RotateTurret(-turretSpeed);
  }

  Rect right = new Rect(Screen.width – 50, Screen.height – 100, 50, 50);
  if(GUI.RepeatButton(right, "r")) {
    RotateTurret(turretSpeed);
  }
}</pre></div></li><li><p>Next is the <a id="id226" class="indexterm"></a>
<code class="literal">RotateTurret</code> function. It works exactly in the same way as the <code class="literal">RotateTank</code> function. However, instead of looking at a <code class="literal">CharacterController</code> component 's <code class="literal">Transform</code> variable, we act upon the <code class="literal">turretPivot</code> variable that was defined at the beginning of the function.</p><div class="informalexample"><pre class="programlisting">public void RotateTurret(float speed) {
  Vector3 rotate = Vector3.up * speed * Time.deltaTime;
  turretPivot.Rotate(rotate);
}</pre></div></li><li><p>The last function, <code class="literal">RotateCannon</code>, gets a little more down-and-dirty with rotations. The fault completely lies with the need to put limits on the rotation of the cannon. After <a id="id227" class="indexterm"></a>opening the function, the first step is to figure out how much we are going to be rotating this frame. We are using a float value instead of a vector because we have to set the rotation ourselves.</p><div class="informalexample"><pre class="programlisting">public void RotateCannon(float speed) {
  float rotate = speed * Time.deltaTime;</pre></div></li><li><p>Next, we define a variable that holds our current rotation. We do this because Unity will not let us act on the rotation directly. Unity actually keeps track of rotation as a quaternion. This is a complex method of defining rotations that is beyond the scope of this book. Luckily, Unity gives us access to an x, y, z method of defining rotations called <code class="literal">EulerAngles</code>. It is a rotation around each of the three axes in 3D space. The <code class="literal">localEulerAngles</code> value of a <span class="strong"><strong>Transform</strong></span> component is the rotation relative to the parent <code class="literal">GameObject</code>.</p><div class="informalexample"><pre class="programlisting">Vector3 euler = cannonPivot.localEulerAngles;</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip13"></a>Tip</h3><p>It is called <code class="literal">EulerAngles</code> because of <span class="emphasis"><em>Leonhard Euler</em></span>, a Swiss mathematician who defined this method of defining rotations.</p></div></li><li><p>Next, we adjust the rotation and apply the limits in one go through the use of the <code class="literal">Mathf.Clamp</code> function<a id="id228" class="indexterm"></a>. <code class="literal">Mathf</code> is a group of useful math functions. The <code class="literal">Clamp</code> function takes a value and makes it no lower and no higher than the other two values passed to the function. So, we first send it our x axis rotation, which is the result of subtracting <code class="literal">rotate</code> from the current x rotation of <code class="literal">euler</code>. Because the positive rotation is clockwise around an axis, we have to subtract our rotation to go up instead of down with a positive value. Next, we pass our lower limit to the <code class="literal">Clamp</code> function, followed by our higher limit: the <code class="literal">lowCannonLimit</code> and <code class="literal">highCannonLimit</code> variables that we defined at the top of the script.</p><div class="informalexample"><pre class="programlisting">euler.x = Mathf.Clamp(euler.x – rotate, lowCannonLimit, highCannonLimit);</pre></div></li><li><p>Finally, we have to actually apply the new rotation to our cannon's pivot point. This is simply setting the <code class="literal">localEulerAngles</code> value of the <span class="strong"><strong>Transform</strong></span> component to the new value. And again, be sure to use the curly brace to close off the function.</p><div class="informalexample"><pre class="programlisting">  cannonPivot.localEulerAngles = euler;
}</pre></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec30"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>We created a script that will control the turret of the tank. Through the use of buttons on the screen, the player is able<a id="id229" class="indexterm"></a> to tilt the cannon and rotate the turret. This script functioned in a very similar manner to the <code class="literal">ChassisControls</code> script we created earlier. The difference came in limiting the amount the cannon can tilt.</p></div></div>