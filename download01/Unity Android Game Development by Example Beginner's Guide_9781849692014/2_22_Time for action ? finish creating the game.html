<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec27"></a>Time for action â€“ finish creating the game</h2></div></div><hr /></div><p>Let us finish the creation of our game by creating an opening screen. We will then add some checks to stop <a id="id108" class="indexterm"></a>players from selecting squares more than once. Follow that with a check to see if anyone won and finally display a game over screen. With that, the game will be ready for us to make it look great.</p><p>Let's perform the following steps for finishing our game:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We will do all this by first creating another script like our <code class="literal">SquareState</code> script. Create the new <code class="literal">GameState</code> script and clear out the default contents. Add the following code snippet and we will have the values needed to track the current state of our game:</p><div class="informalexample"><pre class="programlisting">public enum GameState {
  Opening,
  MultiPlayer,
  GameOver
}</pre></div></li><li><p>We now need to update our <code class="literal">TicTacToeControl</code> script. For starters, because we want to be able to play multiple games, add the <code class="literal">NewGame</code> function to the script. This function initializes our control variables so that we can start a fresh game with a clear board. It will not do very well for players to start a new game and have the board already filled in. This function will be used by our main menu, which we will be writing shortly.</p><div class="informalexample"><pre class="programlisting">public void NewGame() {
  xTurn = true;
  board = new SquareState[9];
}</pre></div></li><li><p>But first, we need to update our <code class="literal">OnGUI</code> function<a id="id109" class="indexterm"></a>. To do that, start by moving all of the current contents of <code class="literal">OnGUI</code> to a new function called <code class="literal">DrawGameBoard</code>.</p></li><li><p>Now, we<a id="id110" class="indexterm"></a> need to change our cleared <code class="literal">OnGUI</code> function to the following code snippet in order to allow it to check and draw the proper screen based on the current game state. A <code class="literal">switch</code> statement works the same as a bunch of <code class="literal">if</code> and <code class="literal">else if</code> statements. In our case, we check the game state and call a different function based on what it is. For example, if the game state is equal to <code class="literal">GameState.MultiPlayer</code>, we will call the <code class="literal">DrawGameBoard</code> function, which should now contain what used to be in the <code class="literal">OnGUI</code> function.</p><div class="informalexample"><pre class="programlisting">public void OnGUI() {
  switch(gameState) {
    case GameState.Opening:
      DrawOpening();
      break;
    case GameState.MultiPlayer:
      DrawGameBoard();
      break;
    case GameState.GameOver:
      DrawGameOver();
      break;
  }
}</pre></div></li><li><p>By this point you are probably wondering where that game state variable is coming from. If you guessed that it was automatically provided by Unity, you are wrong. We have to track our own game state. That is why we created the <code class="literal">GameState</code> script earlier. Add the following line of code to the top of our <code class="literal">TicTacToeControl</code> class<a id="id111" class="indexterm"></a>, right above where we defined our game board:</p><div class="informalexample"><pre class="programlisting">public GameState gameState = GameState.Opening;</pre></div></li><li><p>Next, we need to create the other two game state screens. Let us start with the opening screen. When we draw our opening screen, we start by defining the <code class="literal">Rect</code> class used by our title. We follow that with a quick call to <code class="literal">GUI.Label</code>. By passing it a <code class="literal">Rect</code> class to position itself by and some text, the text is simply drawn on screen. This function is the best way to draw a section of text on the screen.</p><div class="informalexample"><pre class="programlisting">public void DrawOpening() {
  Rect titleRect = new Rect(0, 0, 300, 75);
  GUI.Label(titleRect, "Tic-Tac-Toe");</pre></div></li><li><p>The following line of code defines the <code class="literal">Rect</code> class used by our <code class="literal">New Game</code> button. We want to be sure that it was right under the title, so it starts with the title's x position. We then combine the title's y position with its height to find the position right underneath it. Next, we used the width from the title so that our button<a id="id112" class="indexterm"></a> will cover the entire position under it. Finally, the height is set to <code class="literal">75</code> because it is a good size for fingers and we don't want it to change based on the title. We could have just as easily used all the values from the title or just put in the numbers but our title will change later when we start styling everything.</p><div class="informalexample"><pre class="programlisting">  Rect multiRect = new Rect(titleRect.x, titleRect.y + titleRect.height, titleRect.width, 75);</pre></div></li><li><p>Finally, we make a call that will draw our button. You may remember our use of the <code class="literal">GUI.Button</code> function from when we drew the game board. If the button is pressed, the game state is set to <code class="literal">MultiPlayer</code> that will start our game. The <code class="literal">NewGame</code> function is also called, which will reset our game board. And of course, there is an extra curly brace to finish off the function.</p><div class="informalexample"><pre class="programlisting">  if(GUI.Button(multiRect, "New Game")) {
    NewGame();
    gameState = GameState.MultiPlayer;
  }
}</pre></div></li><li><p>We have one screen left to draw, the game over screen. To do this, we will create the function referenced by our <code class="literal">OnGUI</code> function. However, in order for a game to end, there must be a winner, so add the following line of code right under our game state variable. We are making extended use of the <code class="literal">SquareState</code> enumeration. If the winner variable is equal to <code class="literal">Clear</code>, nobody won the game. If it is equal to <code class="literal">XControl</code> or <code class="literal">OControl</code>, the relevant player has won. Don't worry, it will make more sense when we create the game over screen next and the winner check system in a little bit.</p><div class="informalexample"><pre class="programlisting">public SquareState winner = SquareState.Clear;</pre></div></li><li><p>There is nothing particularly new in the <code class="literal">DrawGameOver</code> function. First, we'll define where we are going to write who won the game. We'll then figure out who won, using our winner variable. After drawing the winner title, the <code class="literal">Rect</code> class used is shifted down by its height so it can be reused. Finally, we'll draw a button that changes our game state back to <code class="literal">Opening</code>, which is of course our main menu.</p><div class="informalexample"><pre class="programlisting">public void DrawGameOver() {
  Rect winnerRect = new Rect(0, 0, 300, 75);
  string winnerTitle = winner == SquareState.XControl ? "X Wins!" : winner == SquareState.OControl ? "O Wins!" : "It's A Tie!";
  GUI.Label(winnerRect, winnerTitle);

  winnerRect.y += winnerRect.height;
  if(GUI.Button(winnerRect, "Main Menu"))
    gameState = GameState.Opening;
}</pre></div></li><li><p>To make sure<a id="id113" class="indexterm"></a> we are not overwriting squares that somebody already controls, we need to make a few changes to our <code class="literal">DrawGameBoard</code> function<a id="id114" class="indexterm"></a>. First, it would be helpful if the players could easily tell whose turn it is. To do this, we'll add the following code snippet to the end of the function. This should start to become familiar. We'll first define where we want to draw. Then, we'll use our <code class="literal">xTurn</code> Boolean to determine what to write about whose turn it is. Finally, it is the <code class="literal">GUI.Label</code> function to draw it on screen.</p><div class="informalexample"><pre class="programlisting">Rect turnRect = new Rect(300, 0, 100, 100);
string turnTitle = xTurn ? "X's Turn!" : "O's Turn!";
GUI.Label(turnRect, turnTitle);</pre></div></li><li><p>We now need to change the bit where we draw the board square, the <code class="literal">GUI.Button</code> function<a id="id115" class="indexterm"></a>. We need to only draw that button if the square is clear. The following code snippet will do just that by moving the button inside of a new <code class="literal">if</code> statement. It checks whether the board square is clear. If it is, we draw the button. Otherwise, we use a label to write the owner to the button's location.</p><div class="informalexample"><pre class="programlisting">if(board[boardIndex] == SquareState.Clear) {
  if(GUI.Button(square, owner))
    SetControl(boardIndex);
}
else GUI.Label(square, owner);</pre></div></li><li><p>The last thing we need to do is make a system that checks for a winner. We will do this in another function provided by the <code class="literal">MonoBehaviour</code> class.<a id="id116" class="indexterm"></a> <code class="literal">LateUpdate</code> is called at the end of every frame, just before things are drawn on the screen. You might be wondering to yourself, why don't we just create a function that is called at the end of <code class="literal">OnGUI</code>, which is already called every frame? The reason is that the <code class="literal">OnGUI</code> function gets a little weird when drawing some of the GUI elements. It will sometimes be called more than once so that it can draw everything. So, for the most part, the functionality should never be controlled by <code class="literal">OnGUI</code>. That is what <code class="literal">Update</code> and <code class="literal">LateUpdate</code> are for. <code class="literal">Update</code> is the normal game loop where most of a game's functionality is called from. <code class="literal">LateUpdate</code> is for things that need to happen after the objects' update, such as our check for a game over.</p></li><li><p>Add the following <code class="literal">LateUpdate</code> function to our <code class="literal">TicTacToeControl</code> class.<a id="id117" class="indexterm"></a> We'll start with a check to make sure we should even be checking for a winner. If the game isn't in a state where we are playing, in this case <code class="literal">MultiPlayer</code>, exit here and go no further.</p><div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  if(gameState != GameState.MultiPlayer) return;</pre></div></li><li><p>Follow that with a short <code class="literal">for</code> loop. A victory in this game is a run of three matching squares. We start by checking the column that is marked by our loop. If the first square is not <code class="literal">Clear</code>, compare it to the square below; if they match, check it against the square below that. Our board is stored as a list but drawn <a id="id118" class="indexterm"></a>as a grid, so we have to add three to go down a square. The <code class="literal">else if</code> statement follows checks of each row. By multiplying our loop value by three, we will skip down a row of each loop. We'll again compare the square to <code class="literal">SquareState.Clear</code>, then to the square one to its right, and finally two to the right. If either set of conditions is correct, we'll send the first square in the set out to another function to change our game state.</p><div class="informalexample"><pre class="programlisting">  for(int i=0;i&lt;3;i++) {
    if(board[i] != SquareState.Clear &amp;&amp; board[i] == board[i + 3] &amp;&amp; board[i] == board[i + 6]) {
      SetWinner(board[i]);
      return;
    }
    else if(board[i * 3] != SquareState.Clear &amp;&amp; board[i * 3] == board[(i * 3) + 1] &amp;&amp; board[i * 3] == board[(i * 3) + 2]) {
      SetWinner(board[i * 3]);
      return;
    }
  }</pre></div></li><li><p>The following code snippet is largely the same as the <code class="literal">if</code> statements we just wrote previously. However, these lines of code check the diagonals. If the conditions are true, again send out to the other function to change game states. You have probably also noticed the returns after the function calls. If we have found a winner at any point, there is no need to check any more of the board. So, we'll exit the <code class="literal">LateUpdate</code> function early.</p><div class="informalexample"><pre class="programlisting">  if(board[0] != SquareState.Clear &amp;&amp; board[0] == board[4] &amp;&amp; board[0] == board[8]) {
    SetWinner(board[0]);
    return;
  }
  else if(board[2] != SquareState.Clear &amp;&amp; board[2] == board[4] &amp;&amp; board[2] == board[6]) {
    SetWinner(board[2]);
    return;
  }</pre></div></li><li><p>This is the last little bit for our <code class="literal">LateUpdate</code> function. If no one has won the game, as determined by the previous parts of this function, we have to check for a tie. This<a id="id119" class="indexterm"></a> is done by checking all of the squares of the game board. If any one of them is <code class="literal">Clear</code>, the game has yet to finish and we exit the function. But, if we make it through the entire loop without finding a <code class="literal">Clear</code> square, we go set the winner but declare a tie.</p><div class="informalexample"><pre class="programlisting">  for(int i=0;i&lt;board.Length;i++) {
    if(board[i] == SquareState.Clear)
      return;
  }
  SetWinner(SquareState.Clear);
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip06"></a>Tip</h3><p>Do remember to close the last curly brace. It is needed to close off the <code class="literal">LateUpdate</code> function. If you forget it, some annoying errors will come your way.</p></div></li><li><p>Finally, we'll create the <code class="literal">SetWinner</code> function that is called repeatedly in our <code class="literal">LateUpdate</code> function<a id="id120" class="indexterm"></a>. Short and sweet, we'll pass to this function that is going to win. It sets our winner variable and changes our game state to <code class="literal">GameOver</code>.</p><div class="informalexample"><pre class="programlisting">public void SetWinner(SquareState toWin) {
  winner = toWin;
  gameState = GameState.GameOver;
}</pre></div><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_02_02.png.jpg" /></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>That is it. Congratulations! We now have a fully functioning Tic-tac-toe game and you survived the process. In the next sections, we will finally get to make it all look pretty. That is a good thing because, as the screenshot shows, the game does not look great right now.</p></div></div>