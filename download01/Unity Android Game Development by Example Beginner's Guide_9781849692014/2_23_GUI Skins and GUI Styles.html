<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec28"></a>GUI Skins and GUI Styles</h2></div></div><hr /></div><p>GUI Styles are how we change the look and feel of GUI elements, buttons, and labels in Unity. A GUI Skin contains several GUI Styles and allows us to change the look of the entire <a id="id121" class="indexterm"></a>GUI without explicitly defining GUI Styles for each element. To create a GUI Skin, right-click in the <span class="strong"><strong>Project</strong></span> window of the Unity Editor, just as with creating a new script. Go to <span class="strong"><strong>Create</strong></span> but, instead of selecting <span class="strong"><strong>Script</strong></span>, go to the bottom and select <span class="strong"><strong>GUI skin</strong></span>. Selecting this option will create the new GUI Skin and let us name it to <code class="literal">GameSkin</code>. By looking at our <code class="literal">GameSkin</code> in the <span class="strong"><strong>Inspector</strong></span> window<a id="id122" class="indexterm"></a>, you can see what we have to work with.</p><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_02_03.png.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>At the top is a<a id="id123" class="indexterm"></a> <span class="strong"><strong>Font</strong></span> attribute. By importing font files to your project and placing one here, you can change the default font used by text in the whole game.</p></li><li style="list-style-type: disc"><p>Under that is a long list of GUI elements, including our good friends <span class="strong"><strong>Button</strong></span> and <span class="strong"><strong>Label</strong></span>. These are all <a id="id124" class="indexterm"></a>GUI Styles and coincide with the GUI functions that we use to draw things on screen. For example, unless otherwise specified, when we use the <code class="literal">Button</code> function, it will draw using the <span class="strong"><strong>Button</strong></span> GUI Style.</p></li><li style="list-style-type: disc"><p>Following the list of GUI elements is a <span class="strong"><strong>Custom Styles</strong></span> attribute<a id="id125" class="indexterm"></a>. This is where we can put any extra styles that we want to use. Of our dozen buttons, perhaps we want one to have red text. That GUI Style would go here.</p></li><li style="list-style-type: disc"><p>At the bottom is a <span class="strong"><strong>Settings</strong></span> attribute<a id="id126" class="indexterm"></a>. By expanding it, we can see it is fairly short. It includes options for whether or not multiclicks can be used for selection, what color of cursor and how fast it should flash when in a text field, and what color the highlight on selected words should be. The defaults here are just fine. Unless there is a very specific look or need, these values can be ignored.</p></li></ul></div><p>Now, let us go over what it takes to be a GUI Style. Expand the <a id="id127" class="indexterm"></a>
<span class="strong"><strong>Button</strong></span> GUI Style from our <code class="literal">GameSkin</code> example. No matter what the GUI Style is used for, they all are made up the same. It may look like there are many attributes that make up a GUI Style, but most of them are nearly identical, making it much simpler.</p><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_02_04.png.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The first attribute is fairly straightforward, but perhaps the most important. <span class="strong"><strong>Name</strong></span> is what Unity uses to find GUI Styles and apply them to GUI elements. It lets us know what the style is supposed to be; however, if there is a typo between it and the code, you will never see your style in the game.</p></li><li style="list-style-type: disc"><p>The next <a id="id128" class="indexterm"></a>several groups of values describe how the GUI element should look when in a particular state. This is where the bulk of your styling will go. The primary states of any element are <span class="strong"><strong>Normal</strong></span>, <span class="strong"><strong>Hover</strong></span>, <span class="strong"><strong>Active</strong></span>, and <span class="strong"><strong>Focused</strong></span>. Secondary to these are <span class="strong"><strong>On Normal</strong></span>, <span class="strong"><strong>On Hover</strong></span>, <span class="strong"><strong>On Active</strong></span>, and <span class="strong"><strong>On Focused</strong></span>. These secondary states only occur as the GUI element transfers into the corresponding primary state. Not every GUI element makes use of every state, and you have the ability to control which states an element can go into, but we will discuss that a little later. Let's see in detail how these states work:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Normal</strong></span>: This is the<a id="id129" class="indexterm"></a> default state of any GUI element. It is always used and occurs any time the element is not being interacted with.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Hover</strong></span>: This state is <a id="id130" class="indexterm"></a>used primarily by buttons and other clickable elements. When your mouse is on top of a GUI element, it will enter this state, if it can. However, since the focus of this book is touch screens, we do not have a mouse to really concern ourselves with. So, we will not be using this state.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Active</strong></span>: This has to<a id="id131" class="indexterm"></a> be the second most important state. An element enters this state when it is activated. For example, when one presses a button, it is active. By clicking on or touching a button, it enters the <span class="strong"><strong>Active</strong></span> state. All of the GUI elements that can be interacted with use this state.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Focused</strong></span>: This is a rarely used state. In terms of Unity's GUI, focused means having <a id="id132" class="indexterm"></a>keyboard control. The only element that uses it by default is the <span class="strong"><strong>Text Field</strong></span>.</p></li></ul></div></li><li style="list-style-type: disc"><p>If you were to expand any of the states, you would see that it has two attributes, <span class="strong"><strong>Background</strong></span> and <span class="strong"><strong>Text Color</strong></span>. The <span class="strong"><strong>Background</strong></span> attribute is a texture. It can be any texture in your game. The <span class="strong"><strong>Text Color</strong></span> attribute is simply the color of any text that appears in the GUI element. Except for the <span class="strong"><strong>Normal</strong></span> state, if a state does not have a background texture, it will not be used. This can be both good and annoying. If we do not want our buttons to show that they have been hovered over, simply remove the texture from the Hover state's <span class="strong"><strong>Background</strong></span> attribute. It becomes annoying when we want a GUI element that does not have a background image of its own, but we do want the text to change color between states. How do we make use of the active state, but not use a texture for the background? The answer is that we create a blank image, but it is not quite as simple as saving off a 100 percent transparent PNG and using that. The GUI Style is too smart for that. It detects that the image is completely blank, making it no different than if there was no image. And so, the state still is not used. To get around this, create a small, blank PNG image, but take a single pixel and make it 90 percent transparent white. This might seem like a hack solution, but it is, unfortunately, the only way. At such a low transparency, we can't detect the pixel; though it is not actually clear. However, Unity sees that there is a slightly white pixel that must be drawn and does so.</p></li><li style="list-style-type: disc"><p>Now, you might be thinking, that's stupid. I'm just going to create images of all of my buttons and not worry about the text. It is indeed stupid but the response to that is, what if you need to slightly change the text of a button? Or perhaps the text on the button is dynamic based on the player's name. In nearly every project I have been a part of there has been a need to create the not quite blank image.</p></li><li style="list-style-type: disc"><p>Below the GUI element's states are <span class="strong"><strong>Border</strong></span>, <span class="strong"><strong>Margin</strong></span>, <span class="strong"><strong>Padding</strong></span>, and <span class="strong"><strong>Overflow</strong></span>. These attributes control how an element interacts with its background images and contained text. Inside each you will find <span class="strong"><strong>Left</strong></span>, <span class="strong"><strong>Right</strong></span>, <span class="strong"><strong>Top</strong></span>, and <span class="strong"><strong>Bottom</strong></span> values. Since every element is drawn as a rectangle, these correspond to each side of the said rectangle. They are defined in pixels, just like our GUI space. Let's see all these attributes in detail as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Border</strong></span>: This lets <a id="id133" class="indexterm"></a>us define how many pixels from each side should not be stretched. When defining a GUI element, the background is normally stretched evenly across the space occupied. If you were to create a blue box with red edging and rounded corners, these values would keep your edges and corners regular while still stretching the blue on the inside.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Margin</strong></span>: This is only used by<a id="id134" class="indexterm"></a> Unity's automatic GUI layout system named GUILayout. It is how much extra space should be around the outside of the element.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Padding</strong></span>: This is the space <a id="id135" class="indexterm"></a>between the borders of an element and the text that it contains. If you want the text of a button left-justified but in slightly, you should use <span class="strong"><strong>Padding</strong></span>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Overflow</strong></span>: This defines an <a id="id136" class="indexterm"></a>extra space for your background image. When creating our buttons, we defined a <code class="literal">Rect</code> class for how much space the button takes up. If we are to use <code class="literal">Overflow</code>, the button itself would be where the <code class="literal">Rect</code> class is, but the background would extend beyond each edge as dictated by the values. This would be useful for buttons with a shadow or glow around them.</p></li></ul></div></li><li style="list-style-type: disc"><p>The next several values have to do with the text in an element. The <span class="strong"><strong>Font</strong></span> attribute is a font that is used specifically by this style. If this value is left empty, the font from the GUI Skin is used. <span class="strong"><strong>Font Size</strong></span> is how big the letters of the text should be. This works just like your favorite word processor, except that a value of zero means to use the default font size defined in the font object. <span class="strong"><strong>Font Style</strong></span> also works like your word processor. It lets you choose between <span class="strong"><strong>Normal</strong></span>, <span class="strong"><strong>Bold</strong></span>, and <span class="strong"><strong>Italic</strong></span> text. This only makes a difference if it is supported by your chosen font.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Alignment</strong></span> defines where<a id="id137" class="indexterm"></a> to justify the text in the GUI element. Imagine splitting your element into a 3 x 3 grid. <span class="strong"><strong>Alignment</strong></span> is the same as the position of the grid.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Word Wrap</strong></span> defines<a id="id138" class="indexterm"></a> whether or not text should split into multiple lines if it is too long. It again works on the same principle as your word processor. If checked and the line of text would extend beyond the sides of the GUI element, the text is split into as many lines as necessary to keep it within the bounds.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Rich Text</strong></span> is a fairly new<a id="id139" class="indexterm"></a> and interesting feature of GUI Styles. It allows us to use HTML style markup to control text. You could put the tags <code class="literal">&lt;b&gt;</code> and <code class="literal">&lt;/b&gt;</code> around a word in your Label's text, and instead of writing those tags, Unity will make the words in between bold. We can make use of the bold, italics, size, and color tags. This allows for selectively making parts of our text bold or italics. We can make certain words larger or smaller. And, the color of any part of the text can be altered using hexadecimal values.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Text Clipping</strong></span> became weird<a id="id140" class="indexterm"></a> in the recent updates. It used to be a nice drop-down list of values, but now it is an integer field. Either way, it still serves its function. If the text extends beyond the edges of the GUI element, this attribute dictates what to do. A value of zero means don't clip the text, let it extend beyond the edges. Any value that is not zero will cause the text to be clipped. Any text that extends beyond the borders will simply not be drawn.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Image Position</strong></span> is used in <a id="id141" class="indexterm"></a>conjunction with GUIContent. GUIContent is a way of passing GUI elements the text, an icon image, and a tool tip. <span class="strong"><strong>Image Position</strong></span> describes how the image and text interact. The image can either go to the left of the text or above. Or, we can choose to only use either the image or the text. Since tool tips aren't really useful in a touch environment, GUIContent is of limited use to us. For that reason, we will not be using it extensively, if at all.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Content Offset</strong></span> adjusts<a id="id142" class="indexterm"></a> anything contained inside the GUI element by the values provided. If all of your text is normally centered in your button, this will allow you to move it slightly to the right and up. It is an aesthetic thing, for when you need a very specific look.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Fixed Width</strong></span> and <span class="strong"><strong>Fixed Height</strong></span> provides<a id="id143" class="indexterm"></a> approximately the same function. If any value other <a id="id144" class="indexterm"></a>than zero is provided for these attributes, they will override the corresponding values in the <code class="literal">Rect</code> class used for the GUI element. So, if you wanted buttons to always be one hundred pixels wide, no matter where they are in the game, you could set <span class="strong"><strong>Fixed Width</strong></span> to one hundred and they will do just that.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Stretch Width</strong></span> and <span class="strong"><strong>Stretch Height</strong></span><a id="id145" class="indexterm"></a> also serves about the same function. They are used by GUILayout for automatic placement of GUI elements. It pretty much gives<a id="id146" class="indexterm"></a> the system permission to make elements wider/skinnier and taller/shorter, respectively, in order to satisfy its conditions for a better layout. The way GUILayout arranges elements is not always the best. It is good, if you need something up quick. But it gets complicated if you want any sort of deeper control.</p></li></ul></div></div>