<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>Differences between Pro and Basic</h2></div></div><hr /></div><p>Unity comes with two licensing options, <a id="id10" class="indexterm"></a>Pro and Basic, <a id="id11" class="indexterm"></a>which can be found at <a class="ulink" href="https://store.unity3d.com" target="_blank">https://store.unity3d.com</a>. In order to follow the bulk of this book, Unity Basic is all that is required. However, real-time shadows in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Setting the Stage – Camera Effects and Lighting</em></span>, the whole of <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Getting Around – Pathfinding and AI</em></span>, and some of the optimization features discussed in <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Optimization</em></span>, will require Unity Pro.<a id="id12" class="indexterm"></a> If you are not quite ready to spend the $3,000 required to purchase a full Unity Pro license with the Android add-on, there are other options. Unity Basic is free and comes with a 30-day free trial of Unity Pro. This trial is full and complete, just as if one has purchased Unity Pro. It is also possible to upgrade your license at a later date. Where Unity Basic<a id="id13" class="indexterm"></a> comes with mobile options for free, Unity Pro requires the purchase of Pro add-ons for each of the mobile platforms.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec08"></a>License comparison overview</h3></div></div></div><p>License comparisons can be found at <a class="ulink" href="http://unity3d.com/unity/licenses" target="_blank">http://unity3d.com/unity/licenses</a>. This section will cover the specific differences between Unity Android Pro and Unity Android Basic. We will explore what the feature is and how useful it is.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>NavMeshes, Pathfinding, and crowd Simulation</strong></span>: This feature is Unity's built-in pathfinding system. It allows characters to find their way from point to point around your game. Just bake your navigation data in the editor and let Unity take over<a id="id14" class="indexterm"></a> at runtime. This feature is great if you don't have the ability or inclination to program a pathfinding system yourself. There is a whole slew of tutorials online about how to program pathfinding and do crowd simulation. It is completely possible to do all of this in Unity Basic; you just need to provide the tools yourself.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>LOD Support</strong></span>: <span class="strong"><strong>LOD</strong></span> (<span class="strong"><strong>Level-of-detail</strong></span><a id="id15" class="indexterm"></a>) lets you control how complex a mesh is, based on its distance from the camera. When the camera is close to an object, render a complex mesh with a bunch of detail in it. When the camera is far from that object, render a simple mesh, because all that detail is not<a id="id16" class="indexterm"></a> going to be seen anyway. Unity Pro provides a built-in system to manage this. However, this is another system that could be created in Unity Basic. Whether using Pro or not, this is an important feature for game efficiency. By rendering less complex meshes at a distance, everything can be rendered faster, leaving more room for awesome gameplay.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Audio Filter</strong></span>: Audio filters<a id="id17" class="indexterm"></a> allow you to add effects to audio clips at runtime. Perhaps you created gravel footstep sounds for your character. Your character is running, and we can hear the footsteps just fine, when suddenly they enter a tunnel and a solar flare hits, causing a<a id="id18" class="indexterm"></a> time warp and slowing everything down. Audio filters would allow us to warp the gravel footstep sounds to sound like they are coming from within a tunnel and are slowed by a time warp. Of course, you could also just have the audio guy create a new set of tunnel gravel footsteps in the time warp sounds.<a id="id19" class="indexterm"></a> But this might double the amount of audio in your game and limits how dynamic we can be with it at runtime. We either are or are not playing the time warp footsteps. Audio filters would allow us to control how much time warp is affecting our sounds.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Video Playback and Streaming</strong></span>: When dealing with complex or high-definition cut scenes, being able to play a video becomes very important. Including them in a<a id="id20" class="indexterm"></a> build especially with a mobile target can require a lot of space. This is where the streaming part of this feature comes in. This feature not only lets us play video,<a id="id21" class="indexterm"></a> it also lets us stream that video from the internet. There is, however, a drawback to this feature. On mobile platforms, the video has to go through the device's built-in, video-playing system. This means the video can only be played full-screen and cannot be used as a texture. Theoretically, though, you could break your video into individual pictures for each frame and flip through them at runtime, but this is not recommended for build size and video quality reasons.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Fully Fledged Streaming with Asset Bundles</strong></span>: Asset bundles are a great feature provided by <a id="id22" class="indexterm"></a>Unity Pro. They allow you to create extra content and stream it to the users, without ever requiring an update to the game. You could add new characters, levels, or just about any other content you can think of. Their only drawback is that you cannot add more code. The functionality cannot change, but the content can. This is one of the best features of Unity Pro.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>100,000 Dollar Turnover</strong></span>: This one isn't so much a feature as it is a guideline. According to Unity's End User License Agreement, the basic version of Unity cannot<a id="id23" class="indexterm"></a> be licensed by any group or individual that made $100,000 in the previous fiscal year. This basically means, if you make a bunch of money, you have to buy Unity Pro. Of course, if you are making that much money, you can probably afford it without issue. That is the view of Unity at least, and the reason why it is there.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Mecanim: IK Rigs</strong></span>: Unity's new animation system, Mecanim, supports many exciting new features, one<a id="id24" class="indexterm"></a> of which is IK. If you are unfamiliar with the term, IK allows one to define the target point of an animation and let the system figure out how to get there. Imagine you have a cup sitting on a table and a character that wants to pick it up. You could animate the character to bend over and pick it up, but what if the character is slightly to the side? Or any number of other slight offsets that a player <a id="id25" class="indexterm"></a>could cause, completely throwing off your animation. It is simply impractical to animate for every possibility. With IK, it hardly matters that the character is slightly off. We just define the goal point for the hand and leave the arm to the IK system. It calculates for us how the arm needs to move in order to get the hand to the cup. Another fun use is making characters look at interesting things as they walk around a room. A guard could track the nearest person, the player character could look at things that they can interact with, or a tentacle monster could lash out at the player without all the complex animation. This will be an exciting one to play with.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Mecanim: Sync Layers &amp; Additional Curves</strong></span>
</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Sync layers, inside Mecanim, allow us to keep multiple sets of animation states in time with each other. Say you have a soldier that you want to animate differently based on how much health he has. When at full health, he walks around briskly. After a little damage,<a id="id26" class="indexterm"></a> it becomes more of a trudge. If health is below half, a limp is introduced to his walk. And when almost dead, he crawls along the ground. With sync layers, we can create one animation state machine and duplicate it to multiple layers. By changing the animations and syncing the layers, we can easily transition between the different animations while maintaining the state machine.</p></li><li style="list-style-type: disc"><p>Additional curves are simply the ability to add curves to your animations. This means we can control various values with the animation. For example, in the game world, when a character picks up their feet for a jump, gravity will pull them down almost immediately. By adding an extra curve to that animation, in Unity, we can control how much gravity is affecting the character, allowing them to actually get in the air when jumping. This is a useful feature for controlling such values right alongside the animations, but one could just as easily create a script that holds and controls the curves.</p></li></ul></div></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Custom Splash Screen</strong></span>: Though pretty self-explanatory, it is perhaps not immediately evident why<a id="id27" class="indexterm"></a> this feature is <a id="id28" class="indexterm"></a>specified, unless you have worked with Unity before. When an application built in Unity initializes on any platform, it displays a splash screen. In Unity Basic this will always be the Unity logo. By purchasing Unity Pro, you can substitute the Unity logo with any image you want.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Build Size Stripping</strong></span>: This is an important feature for mobile platforms. Build size stripping removes all of the excess from your final build. Unity does a very good job<a id="id29" class="indexterm"></a> at only including the assets that you have created that are used in the final build. With the stripping, it <a id="id30" class="indexterm"></a>also only includes the parts of the engine itself that are used in the game. This is of great use when you absolutely have to get under that limit for downloading from the cell towers. On the other hand, you could create something similar to the asset bundles. Just let the users buy the framework, and download the assets later.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Realtime Directional Shadows</strong></span>: Lights and shadows add a lot to the mood of a scene. This feature allows us to go beyond blob shadows and use realistic looking shadows. This is all well and good if you have the processing space for it. <a id="id31" class="indexterm"></a>Most mobile devices do not. This feature should also never be used for static scenery. Instead, use static lightmaps, which is what they are for. But if you can find a good balance between simple needs and quality, this could be the feature that creates the difference between an alright and an awesome game.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>HDR, tone mapping</strong></span>: <span class="strong"><strong>HDR</strong></span> (<span class="strong"><strong>High Dynamic Range</strong></span>) and tone mapping allow us to create <a id="id32" class="indexterm"></a>more realistic lighting effects. Standard rendering uses values from zero to one to represent how much of each color in a pixel is on. This does not allow for a full spectrum of lighting options to be explored. HDR lets the system use<a id="id33" class="indexterm"></a> values beyond this range and process them using tone mapping to create better effects, such as a bright morning room or the bloom from a car window reflecting the sun. The downside of this feature is in the processor. The device can still only handle values between zero and one, so converting them takes time. Additionally, the more complex the effect, the more time it takes to render it. It would be surprising to see this used well on handheld devices, even in a simple game. Maybe the modern tablets could handle it.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Light Probes</strong></span>: Light probes are an<a id="id34" class="indexterm"></a> interesting little feature. When placed in the world, light probes figure out how an object should be lit. Then, as a character walks around, they<a id="id35" class="indexterm"></a> tell it how to be shaded. The character is, of course, lit by the lights in the scene but there are limits on how many lights can shade an object at once. Light probes do all the complex calculations beforehand, allowing for better shading at runtime. Again, however, there are concerns about the processing power. Too little and you won't get a good effect; too much and there will be no processing left for playing the game.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lightmapping with Global Illumination and area lights</strong></span>: All versions of Unity support lightmaps, allowing for the baking of complex static shadows and lighting effects. With the addition of global illumination and area lights, you can add another<a id="id36" class="indexterm"></a> touch of realism to your scenes. However, every version of Unity also lets you import your own lightmaps. This means, you could use some other program to render the lightmaps and import them separately.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Static Batching</strong></span>: This feature speeds up the rendering process. Instead of spending time on each <a id="id37" class="indexterm"></a>frame grouping objects for faster rendering, this allows the system to save the groups<a id="id38" class="indexterm"></a> generated beforehand. Reducing the number of draw calls is a powerful step towards making a game run faster. That is exactly what this feature does.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Render-to-Texture Effects</strong></span>: This is a fun feature, but of limited use. It simply allows you to redirect the rendering of the camera from going to the screen and instead go to a texture. This texture could then, in its most simple form, be put onto a <a id="id39" class="indexterm"></a>mesh and act like a surveillance camera. You could also do some custom post processing, <a id="id40" class="indexterm"></a>such as removing the color from the world as the player loses their health. However, that option could become very processor-intensive.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Full-Screen Post-Processing Effects</strong></span>: This is another processor-intensive feature that probably will not make it into your mobile game. But you can add some very cool effects<a id="id41" class="indexterm"></a> to your scene. Such as, adding motion blur when the player is moving really fast, <a id="id42" class="indexterm"></a>or a vortex effect to warp the scene as the ship passes through a warped section of space. One of the best is using the bloom effect to give things a neon-like glow.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Occlusion Culling</strong></span>:<a id="id43" class="indexterm"></a> This is another great optimization feature. The standard camera system renders everything that is within<a id="id44" class="indexterm"></a> the camera's view frustum, the view space. Occlusion culling lets us set up volumes in the space our camera can enter. These volumes are used to calculate what the camera can actually see from those locations. If there is a wall in the way, what is the point of rendering everything behind it? Occlusion culling calculates this and stops the camera from rendering anything behind that wall.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Navmesh: Dynamic Obstacles and Priority</strong></span>: This feature works in conjunction with<a id="id45" class="indexterm"></a> the pathfinding system. In scripts, we can dynamically set obstacles, and characters will find their way around them. Being able to set priorities means different types of characters can take different types of objects into consideration when finding their way around. A soldier must go around the barricades to reach his target. The tank, however, could just crash through, should it desire to.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>.Net Socket Support</strong></span>: This<a id="id46" class="indexterm"></a> feature is only useful if you plan on doing fancy things over a user's network. Multiplayer<a id="id47" class="indexterm"></a> networking is already supported in every version of Unity. The multiplayer that is available, though, does require a master server. With the use of sockets, one could create connections to other devices locally.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Profiler and GPU profiling</strong></span>: This is a very useful feature. The profiler provides tons of information<a id="id48" class="indexterm"></a> about how much load your game puts on the processor. With this information we can get right down into the nitty-gritties and determine exactly how long a <a id="id49" class="indexterm"></a>script takes to process. Towards the end of the book, though, we will also create a tool for determining how long specific parts of your code take to process.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Script Access to Asset Pipeline</strong></span>: This is an alright feature. With full access to the pipeline, there is a lot<a id="id50" class="indexterm"></a> of custom processing that can be done on assets and builds. The full range of possibilities are beyond the scope of this book. But think of it as being<a id="id51" class="indexterm"></a> able to tint all of the imported textures slightly blue.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Dark Skin</strong></span>: This is entirely<a id="id52" class="indexterm"></a> a cosmetic feature. Its point and purpose are questionable. But if a smooth, dark-skinned look is<a id="id53" class="indexterm"></a> what you desire, this is the feature you want. There is an option in the editor to change it to the color scheme used in Unity Basic. For this feature, whatever floats your boat goes.</p></li></ul></div></div></div>