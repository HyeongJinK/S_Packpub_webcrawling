<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec105"></a>Time for action – creating the slingshot</h2></div></div><hr /></div><p>Most of the slingshot's appearance<a id="id485" class="indexterm"></a> will actually be an optical illusion:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To start off the creation of the slingshot, add the <code class="literal">slingshot</code> model to the scene and position it at the origin. Apply a light brown material to the <code class="literal">Fork</code> model and a dark <a id="id486" class="indexterm"></a>brown one to the <code class="literal">Pouch</code> model.</p></li><li><p>Next, we need four empty <span class="strong"><strong>GameObject</strong></span>. Make them all the children of the <code class="literal">Slingshot</code> object.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Name the first <code class="literal">FocalPoint</code> and center it between the fork prongs of the slingshot. This will be the point through which we fire all of the birds.</p></li><li style="list-style-type: disc"><p>The second is <code class="literal">Pouch</code>. Make the <code class="literal">pouch</code> model a child of this object, setting its position to <code class="literal">0.5</code> on the <span class="strong"><strong>X</strong></span> axis and <code class="literal">0</code> on the <span class="strong"><strong>Y</strong></span> and <span class="strong"><strong>Z</strong></span> axes. This will make the pouch appear in front of the current bird without having to make a complete pouch model.</p></li><li style="list-style-type: disc"><p>Third is <code class="literal">BirdPoint</code>; this will position the bird that is being fired. Make it a child of the <code class="literal">Pouch</code> point and set its position to <code class="literal">0</code> on the <span class="strong"><strong>X</strong></span> and <span class="strong"><strong>Y</strong></span> axes and <code class="literal">0.3</code> on the <span class="strong"><strong>Z</strong></span> axis.</p></li><li style="list-style-type: disc"><p>Last is <code class="literal">WaitPoint</code>; the birds waiting to be fired will be positioned behind this point. Set its position to <code class="literal">0</code> for the <span class="strong"><strong>X</strong></span> axis, <code class="literal">0.5</code> for the <span class="strong"><strong>Y</strong></span> axis, and <code class="literal">-4</code> for the <span class="strong"><strong>Z</strong></span> axis.</p></li></ul></div></li><li><p>Next, rotate the <code class="literal">Fork</code> model so that we can see both prongs of the fork. The values of <code class="literal">270</code> for the <span class="strong"><strong>X</strong></span> axis, <code class="literal">25</code> for the <span class="strong"><strong>Y</strong></span> axis, and <code class="literal">0</code> for the <span class="strong"><strong>Z</strong></span> axis will work well.</p></li><li><p>The <code class="literal">Slingshot</code> script will provide most of the interaction for the player. Create it now.</p></li><li><p>We start it with a group of variables. The first will keep a reference to the damper that was mentioned earlier. The second group keeps track of the birds that will be used in the level. Next is a group of variables that will track the current bird that is ready to be fired. Fourth, we have some variables to hold references to the points we created a moment ago. The <code class="literal">maxRange</code> variable is the distance from the focal point to which the player can drag the pouch. The last two variables define how powerfully the bird will be launched.</p><div class="informalexample"><pre class="programlisting">public RigidbodyDamper rigidbodyDamper;

public GameObject[] levelBirds = new GameObject[0];
private GameObject[] currentBirds;
private int nextIndex = 0;
public Transform waitPoint;
public Transform toFireBird;
public bool didFire = false;
public bool isAiming = false;

public Transform pouch;
public Transform focalPoint;
public Transform pouchBirdPoint;

public float maxRange = 3;

public float maxFireStrength = 25;
public float minFireStrength = 5;</pre></div></li><li><p>As with our other scripts, we use the <code class="literal">Awake</code> function for initialization. The <code class="literal">levelBirds</code> variable will hold references to all of the <code class="literal">bird</code> prefabs that will be used in the level.<a id="id487" class="indexterm"></a> We start by creating an instance of each one and storing it in the <code class="literal">currentBirds</code> variable. The <code class="literal">isKinematic</code> variable is set to <code class="literal">true</code> on each bird's <span class="strong"><strong>Rigidbody</strong></span> so that it does not move when it is not in use. Next, it readies the first bird to be fired and, finally, it positions the remaining birds behind the <code class="literal">waitPoint</code>.</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  currentBirds = new GameObject[levelBirds.Length];
  for(int i=0;i&lt;levelBirds.Length;i++) {
    GameObject nextBird = Instantiate(levelBirds[i]) as GameObject;
    nextBird.rigidbody.isKinematic = true;
    currentBirds[i] = nextBird;
  }

  ReadyNextBird();
  SetWaitPositions();
}</pre></div></li><li><p>The <code class="literal">ReadyNextBird</code> function<a id="id488" class="indexterm"></a> first checks to see if we have run out of birds. If so, it calls the <code class="literal">LevelTracker</code> script to trigger the Game Over event. The <code class="literal">nextIndex</code> variable tracks the current location of the birds in the list to fire at the player. Next, the function checks to make sure the next slot actually has a bird, incrementing the index and trying for a new bird if it does not have one. If there is a bird available, it is stored in the <code class="literal">toFireBird</code> variable and made a child of the <code class="literal">BirdPoint</code> object we created; its position and rotation are zeroed out. Finally, the firing and aiming flags are reset.</p><div class="informalexample"><pre class="programlisting">public void ReadyNextBird() {
  if(currentBirds.Length &lt;= nextIndex) {
    LevelTracker.OutOfBirds();
    return;
  }

  if(currentBirds[nextIndex] == null) {
    nextIndex++;
    ReadyNextBird();
    return;
  }

  toFireBird = currentBirds[nextIndex].transform;
  nextIndex++;

  toFireBird.parent = pouchBirdPoint;
  toFireBird.localPosition = Vector3.zero;
  toFireBird.localRotation = Quaternion.identity;

  didFire = false;
  isAiming = false;
}</pre></div></li><li><p>The <code class="literal">SetWaitingPositions</code> function<a id="id489" class="indexterm"></a> uses the position of the <code class="literal">waitPoint</code> to position all of the <a id="id490" class="indexterm"></a>remaining birds behind the slingshot.</p><div class="informalexample"><pre class="programlisting">public void SetWaitingPositions() {
  for(int i=nextIndex;i&lt;currentBirds.Length;i++) {
    if(currentBirds[i] == null) continue;
    Vector3 offset = Vector3.forward * (i – nextIndex) * 2;
    currentBirds[i].transform.position = waitPoint.position – offset;
  }
}</pre></div></li><li><p>The <code class="literal">Update</code> function<a id="id491" class="indexterm"></a> starts by checking to see if the player has fired a bird and watches the <code class="literal">rigidbodyDamper.allSleeping</code> variable to see if all of the physics objects have stopped moving. Once they do, the next bird is readied to fire. If we have not fired, the aiming flag is checked and the <code class="literal">DoAiming</code> function is called to handle the aiming. If the player is neither aiming nor has just fired a bird, we check for touch input and, if the player touches close enough to the focal point, we flag that the player has started aiming.</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(didFire) {
    if(rigidbodyDamper.allSleeping) {
      ReadyNextBird();
      SetWaitingPositions();
    }
    return;
  }
  else if(isAiming) {
    DoAiming();}
  else {
    if(Input.touchCount &lt;= 0) return;
    Vector3 touchPoint = GetTouchPoint();
    isAiming = Vector3.Distance(touchPoint, focalPoint.position) &lt; maxRange / 2;
  }
}</pre></div></li><li><p>The <code class="literal">DoAiming</code> function<a id="id492" class="indexterm"></a> checks to see if the player has stopped touching the screen and fires the current bird when they have. If they have not, we position the pouch at the current touch point. Finally, the pouch's position is limited to keep it within the maximum range.</p><div class="informalexample"><pre class="programlisting">private void DoAiming() {
  if(Input.touchCount &lt;= 0) {
    FireBird();
    return;
  }

  Vector3 touchPoint = GetTouchPoint();

  pouch.position = touchPoint;
  pouch.LookAt(focalPoint);

  float distance = Vector3.Distance(focalPoint.position, pouch.position);
  if(distance &gt; maxRange) {
    pouch.position = focalPoint.position – (pouch.forward * maxRange);
  }
}</pre></div></li><li><p>The <code class="literal">GetTouchPoint</code> function<a id="id493" class="indexterm"></a> uses <code class="literal">ScreenPointToRay</code> to find out where the player is touching in 3D space. This is just as when we were shooting asteroids but, because this game is 2D, we can just look at the ray's origin and return it with a <a id="id494" class="indexterm"></a>zero for its x axis value.</p><div class="informalexample"><pre class="programlisting">private Vector3 GetTouchPoint() {
  Ray touchRay = Camera.main.ScreenPointToRay(Input.GetTouch(0).position);
  Vector3 touchPoint = touchRay.origin;
  touchPoint.x = 0;
  return touchPoint;
}</pre></div></li><li><p>Finally, for this script, we have the <code class="literal">FireBird</code> function<a id="id495" class="indexterm"></a>. This function starts by setting our <code class="literal">didFire</code> flag to <code class="literal">true</code>. Next, it finds out the direction to fire by finding the direction from the pouch's position to the <code class="literal">focalPoint</code>. It also uses the distance between them to determine the power to fire the bird with, clamping it between our min and max strengths. Then, it releases the bird by clearing its parent and setting its <code class="literal">isKinematic</code> flag to <code class="literal">false</code>. To launch it, we use the <code class="literal">rigidbody.AddForce</code> function<a id="id496" class="indexterm"></a> and pass the direction multiplied by the power to it. <code class="literal">ForceMode.Impulse</code> is also passed to make the force applied once and immediately. Next, the pouch is positioned at the <code class="literal">focalPoint</code>, as if it were actually<a id="id497" class="indexterm"></a> under tension. And finally, we call <code class="literal">rigidbodyDamper.ReadyDamp</code> to start the damping of the <code class="literal">Rigidbody</code> movement.</p><div class="informalexample"><pre class="programlisting">private void FireBird() {
  didFire = true;

  Vector3 direction = (focalPoint.position – pouch.position).normalized;
  float distance = Vector3.Distance(focalPoint.position, pouch.position);
float power = distance &lt;= 0 ? 0 : distance / maxRange;
  power *= maxFireStrength;
  power = Mathf.Clamp(power, minFireStrength, maxFireStrength);

  toFireBird.parent = null;
  toFireBird.rigidbody.isKinematic = false;
  toFireBird.rigidbody.AddForce(direction * power, ForceMode.Impulse);

  pouch.position = focalPoint.position;

  rigidbodyDamper.ReadyDamp();
}</pre></div></li><li><p>Before we can make use of the <code class="literal">Slingshot</code> script, we need to create the <code class="literal">RigidbodyDamper</code> script.</p></li><li><p>This script starts with six variables. The first two define how long to wait before the damping movement and how much to damp it by. The next two track whether it can apply the damping and when it will start. Next, is a variable that will be filled with a list of all the rigidbodies that are currently in the scene. Finally, it has the <code class="literal">allSleeping</code> flag that will be set to <code class="literal">true</code> when the movement has stopped.</p><div class="informalexample"><pre class="programlisting">public float dampWaitLength = 10f;
public float dampAmount = 0.9f;
private float dampTime = -1;
private bool canDamp = false;
private Rigidbody[] rigidbodies = new Rigidbody[0];

public bool allSleeping = false;</pre></div></li><li><p>The <code class="literal">ReadyDamp</code> function<a id="id498" class="indexterm"></a> starts by using <code class="literal">FindObjectsOfType</code> to fill the list with all of the rigidbodies. It sets when to start damping as the sum of the current time and the wait length. It marks that the script can do its damping and resets the <code class="literal">allSleeping</code> flag. <a id="id499" class="indexterm"></a>Finally, it uses <code class="literal">StartCoroutine</code> to call the <code class="literal">CheckSleepingRigidbodies</code> function. This is a special way of calling functions to make them run in the background without blocking the rest of the game from running.</p><div class="informalexample"><pre class="programlisting">public void ReadyDamp() {
  rigidbodies = FindObjectsOfType(typeof(Rigidbody)) as Rigidbody[];
  dampTime = Time.time + dampWaitLength;
  canDamp = true;
  allSleeping = false;

  StartCoroutine(CheckSleepingRigidbodies());
}</pre></div></li><li><p>In the <code class="literal">FixedUpdate</code> function<a id="id500" class="indexterm"></a>, we first check to see if we can damp the movement and whether it is time to do it. If it is, we loop through all of the rigidbodies, applying our damp to each one's rotational and linear velocity. Those that are kinematic, controlled by scripts, and already sleeping, meaning they stopped moving, are skipped.</p><div class="informalexample"><pre class="programlisting">public void FixedUpdate() {
  if(!canDamp || dampTime &gt; Time.time) return;

  foreach(Rigidbody next in rigidbodies) {
    if(next != null &amp;&amp; !next.isKinematic &amp;&amp; !next.IsSleeping()) {
      next.angularVelocity *= dampAmount;
      next.velocity *= dampAmount;
    }
  }
}</pre></div></li><li><p>The <code class="literal">CheckSleepingRigidbodies</code> function<a id="id501" class="indexterm"></a> is special and will run in the background. This is made possible by the <code class="literal">IEnumerator</code> flag at the beginning of the function and the <code class="literal">yield return null</code> line in the middle. Together, these allow the function to pause regularly and keep from freezing the rest of the game while it waits for the function to complete. The function starts by creating a check flag and using it to check if all of the rigidbodies have stopped moving. If one is found still moving, the flag is set to <code class="literal">false</code> and the function pauses until the next frame, when it will try again. When it reaches the end, because all of the rigidbodies are sleeping, it sets the <code class="literal">allSleeping</code> flag to <code class="literal">true</code>, so that the slingshot can ready the next bird. It also stops itself from damping while the player is getting ready to fire the next bird.</p><div class="informalexample"><pre class="programlisting">private IEnumerator CheckSleepingRigidbodies() {
  bool sleepCheck = false;

  while(!sleepCheck) {
    sleepCheck = true;

    foreach(Rigidbody next in rigidbodies) {
      if(next != null &amp;&amp; !next.isKinematic &amp;&amp; !next.IsSleeping()) {
        sleepCheck = false;
        yield return null;
        break;
      }
    }
  }

  allSleeping = true;
  canDamp = false;
}</pre></div></li><li><p>Finally, we have the <a id="id502" class="indexterm"></a>
<code class="literal">AddBodiesToCheck</code> function. This function will be used by anything that spawns new physics objects after the player has fired the bird. It starts by creating a temporary list and expanding the current one. Next, it adds all of the values from the temporary list to the expanded one. Finally, the list of rigidbodies <a id="id503" class="indexterm"></a>is added after those of the temporary list.</p><div class="informalexample"><pre class="programlisting">public void AddBodiesToCheck(Rigidbody[] toAdd) {
  Rigidbody[] temp = rigidbodies;
  rigidbodies = new Rigidbody[temp.Length + toAdd.Length];

  for(int i=0;i&lt;temp.Length;i++) {
    rigidbodies[i] = temp[i];
  }
  for(int i=0;i&lt;toAdd.Length;i++) {
    rigidbodies[i + temp.Length] = toAdd[i];
  }
}</pre></div></li><li><p>Return to Unity and add the two scripts to the <code class="literal">Slingshot</code> object. On the <code class="literal">Slingshot</code> script component, connect the references to the <span class="strong"><strong>Rigidbody Damper</strong></span> component and each of the points. Also, add to the <span class="strong"><strong>Level Birds</strong></span> list as many references to the red bird as you want for the level.</p></li><li><p>To keep objects from rolling back and through the slingshot, create a <span class="strong"><strong>Box Collider</strong></span> component and position it at the stock of the <code class="literal">Fork</code> model.</p></li><li><p>To finish off the look of the slingshot, we need to create the elastic bands that tie the pouch to the fork. We will do this by first creating the <code class="literal">SlingshotBand</code> script.</p></li><li><p>The script starts with two variables. One for the point that the band will end at and one to reference the <code class="literal">LineRenderer</code> that will draw it.</p><div class="informalexample"><pre class="programlisting">public Transform endPoint;
public LineRenderer lineRenderer;</pre></div></li><li><p>The <code class="literal">Awake</code> function makes<a id="id504" class="indexterm"></a> sure the <code class="literal">lineRenderer</code> variable has only two points and sets their initial positions.</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  if(lineRenderer == null) return;
  if(endPoint == null) return;

  lineRenderer.SetVertexCount(2);
  lineRenderer.SetPosition(0, transform.position);
  lineRenderer.SetPosition(1, endPoint.position);
}</pre></div></li><li><p>In the <code class="literal">LateUpdate</code> function<a id="id505" class="indexterm"></a>, we set the <code class="literal">lineRenderer</code> variable's end position to the <code class="literal">endPoint</code> value. This point will move around with the pouch, so we need to constantly update the renderer.</p><div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  if(endPoint == null) return;
  if(lineRenderer == null) return;

  lineRenderer.SetPosition(1, endPoint.position);
}</pre></div></li><li><p>Return to Unity and create an empty <span class="strong"><strong>GameObject</strong></span>. Name it <code class="literal">Band_Near</code> and make it a child of the <code class="literal">Slingshot</code> object.</p></li><li><p>As children of this new point, create a cylinder and a second empty <span class="strong"><strong>GameObject</strong></span>, named <code class="literal">Band</code>.</p></li><li><p>Give the cylinder a brown material and position it near the prong of the slingshot fork.</p></li><li><p>To the <code class="literal">Band</code> object, add a <span class="strong"><strong>Line Renderer</strong></span> component found under <span class="strong"><strong>Effects</strong></span> in the <span class="strong"><strong>Component</strong></span> menu. After positioning it in the center of the cylinder, add the <code class="literal">SlingshotBand</code> script to the object.</p></li><li><p>To the <span class="strong"><strong>Line Renderer</strong></span> under <span class="strong"><strong>Materials</strong></span>, you can put your brown material in the slot to color the band. under <span class="strong"><strong>Parameters</strong></span>. Set the <span class="strong"><strong>Start Width</strong></span> to <code class="literal">0.5</code> and the <span class="strong"><strong>End width</strong></span> to <code class="literal">0.2</code> to set the size of the line.</p></li><li><p>Next, create one more empty <span class="strong"><strong>GameObject</strong></span> and name it <code class="literal">BandEnd_Near</code>. Make it a child of the <code class="literal">Pouch</code> object and position it inside the pouch.</p></li><li><p>Now, connect the script's references to its line renderer and end point.</p></li><li><p>To make the second band, <a id="id506" class="indexterm"></a>duplicate the four objects we just created and position them far from the prong of the fork. The end point for this band can just be moved back along the x axis to keep it out of the way of the birds.</p></li><li><p>Finally, turn the whole thing into a prefab so it can be easily reused in other levels.</p><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_07_04.jpg" /></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec106"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>We created the slingshot that will be used to fire birds. We used techniques we learned in the previous chapter to handle touch input and track the player's finger while they aim and shoot. If you save your scene and position the camera to look at the slingshot, you will notice that it is complete if not entirely playable. Birds can be fired at the pig fortress, although we can only see the destruction from within Unity's <span class="strong"><strong>Scene</strong></span> view.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec107"></a>Watching</h3></div></div></div><p>The game is technically playable at this point, but it is kind of hard to see what is going on. Next, we will create a system to control the camera. It will allow the player to drag the camera left and right, follow the bird when it is launched and return to the slingshot when everything stops moving. There will also be a set of limits to keep the camera from going too far and viewing things we do not want the player to see.</p></div></div>