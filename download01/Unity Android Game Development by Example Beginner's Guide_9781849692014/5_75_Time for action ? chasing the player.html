<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec77"></a>Time for action – chasing the player</h2></div></div><hr /></div><p>Our next script will control our simple chase AI. Because we are making use of the <span class="strong"><strong>NavMesh</strong></span> and <span class="strong"><strong>NavMeshAgent</strong></span> components, <a id="id385" class="indexterm"></a>we can leave nearly all the difficult portions of pathfinding to Unity:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Again, create a new script. This time name it <code class="literal">ChasePlayer</code>.</p></li><li><p>The first line for this script simply holds a reference to the <span class="strong"><strong>NavMeshAgent</strong></span> component that we set up earlier. We need access to this component in order to move the enemy.</p><div class="informalexample"><pre class="programlisting">public NavMeshAgent agent;</pre></div></li><li><p>The last segment of code first makes sure that we have our <span class="strong"><strong>NavMeshAgent</strong></span> reference and then updates our goal destination. It uses the <code class="literal">PlayerPosition</code> script's variable, that was set up earlier, and the<a id="id386" class="indexterm"></a> <code class="literal">SetDestination</code> function from the <span class="strong"><strong>NavMeshAgent</strong></span>. Once we tell the function where to go, the <span class="strong"><strong>NavMeshAgent</strong></span> component does all the hard work of getting us there. We are updating our goal destination in the <code class="literal">FixedUpdate</code> function because we do not need to update the destination in every frame. Updating too often could cause a serious lag if there are a whole lot of enemies. The <code class="literal">FixedUpdate</code> function is called at regular intervals and is slower than the frame rate, so it is perfect.</p><div class="informalexample"><pre class="programlisting">public void FixedUpdate() {
  if(agent == null) return;

  agent.SetDestination(PlayerPosition.position);
}</pre></div></li><li><p>We now need to add the script to our enemy tank. Select the <code class="literal">prefab</code> in the <span class="strong"><strong>Project</strong></span> window, and drag-and-drop the script in the <span class="strong"><strong>Inspector</strong></span> panel, underneath the <span class="strong"><strong>NavMeshAgent</strong></span> component.</p></li><li><p>Be sure to connect the reference, as we have done previously. Drag the <span class="strong"><strong>NavMeshAgent</strong></span> component to the <span class="strong"><strong>Agent</strong></span> value in the <span class="strong"><strong>Inspector</strong></span> window.</p></li><li><p>Play the game now to try it out. Wherever the enemy starts, it finds its way around all the buildings<a id="id387" class="indexterm"></a> and makes it to the player's position. As you drive around, you can watch the enemy follow. However, the enemy tank ends up going through our tank. Also, we can drive through it.</p></li><li><p>The first step to fixing it is to add some colliders. Add a <span class="strong"><strong>Box Collider</strong></span> component from underneath <span class="strong"><strong>Physics</strong></span> in the <span class="strong"><strong>Component</strong></span> menu to the turret, chassis, and each of the <span class="strong"><strong>TreadCase</strong></span> objects. Neither the cannon nor the treads need colliders. The tread casings already cover the area of the treads, and the cannon is too small a target to be shot at properly.</p><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_05_08.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>If you are making any of these changes in the <span class="strong"><strong>Scene</strong></span> view, be sure to click on the <span class="strong"><strong>Apply</strong></span> button in the <span class="strong"><strong>Inspector</strong></span> window to update the root prefab object.</p></div></li><li><p>The last thing to change is the <span class="strong"><strong>Stopping Distance</strong></span> property on the <span class="strong"><strong>NavMeshAgent</strong></span> component. When the tanks fight, they move into range and start firing. They do not try to occupy the same space as the enemy, unless that enemy is <a id="id388" class="indexterm"></a>small and squishy. By setting <span class="strong"><strong>Stopping Distance</strong></span> to <code class="literal">10</code> we are able to replicate this behavior.</p><div class="mediaobject"><img src="/graphics/9781849692014/graphics/2014OT_05_04.jpg" /></div></li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec70"></a>
<span class="emphasis"><em>What just happened?</em></span>
</h3></div></div></div><p>In this section, we created a script that causes a <span class="strong"><strong>NavMeshAgent</strong></span> component, in this case our enemy tank, to chase the player. We added colliders to stop us from driving through the enemy. And, we adjusted the <span class="strong"><strong>Stopping Distance</strong></span> to give us a better tank behavior.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec71"></a>Have a go hero – adding shadow</h3></div></div></div><p>Try adding a blob shadow to the enemy tank. This will give it a better visual sense of being grounded. You can just copy the one that was made for the player's tank.</p></div></div>