<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec44"></a>Bonus items</h2></div></div><hr /></div><p>Now let's focus on a distinct and extensible feature, namely bonuses or rewards. Rewards systems and positive feedback are important properties for games wherever the player repeatedly encounters time-critical challenges. When provided judiciously and appropriately, rewards reinforce the player's successes, making them feel good, and encouraging them to play on. It's important not to over or under-reward. By under-rewarding, you make the game seem too difficult or boring, and by over-rewarding, you remove the challenge and desensitize the player to rewards completely.</p><p>Rewards take many forms, from steam achievements, certificates, and badges, to power-ups and extra items. For more information on player motivation and in-game achievements, see the book <span class="emphasis"><em>Gamification with Unity 5.x</em></span>, <span class="emphasis"><em>Packt</em></span> (<a class="ulink" href="https://www.packtpub.com/game-development/gamification-unity-5x" target="_blank">https://www.packtpub.com/game-development/gamification-unity-5x</a>). In <span class="emphasis"><em>Dead Keys</em></span>, we'll reward the player with collectible badges. These are issued based on typing time: that is, when the player types and completes a word successfully, while also beating a minimum <span class="emphasis"><em>letters per minute record</em></span>, they'll be rewarded with an achievement badge. These will appear horizontally at the bottom of the screen and accumulate through the level as the player collects rewards. The reward asset is included in the book companion files and should be imported into the project (if you've not already imported it) as a 2D sprite texture.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_055.jpg" /></div><p>
</p><p>Importing a rewards badge icon</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>Remember, the <span class="strong"><strong>Generate Mip Maps</strong></span> option should be disabled for 2D sprites which appear in the UI. Mip mapping reduces texture quality as it moves further from the camera. We neither need nor want such quality reduction in this case.</p></div><p>The UI needs for the bonus objects are distinct from the other UI elements we've been working on. The bonus objects accumulate over time, appearing one by one, in a row at the screen-bottom as they're collected. To achieve this, we'll make some bonus objects in the editor and the game will simply hide and show these objects as needed. However, we still want a clean and easy mechanism for arranging the bonus objects in a row, as opposed to relying on manual alignment for each one. To get started, create a canvas object, configured to <span class="emphasis"><em>Stretch with Screen Size</em></span>. Then add an image object as a child, configured to display the bonus sprite.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_056.jpg" /></div><p>
</p><p>Creating an initial bonus object</p><p>Now, we could create more bonus objects by duplicating the existing ones and repositioning them wherever they're needed. However, this grows tedious quickly, especially when creating many objects. Instead, we can use a Horizontal Layout Group, which forces Unity to automatically align and position horizontal elements. Let's see how this works. Select the parent canvas object, then choose <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Layout</strong></span> | <span class="strong"><strong>Horizontal Layout Group</strong></span> to add a <span class="strong"><strong>Horizontal Layout Group</strong></span> component to the object. Doing this may change the appearance, size or layout of the bonus graphic.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_057.jpg" /></div><p>
</p><p>Adding a Horizontal Layout Group</p><p>After adding a <span class="strong"><strong>Horizontal Layout </strong></span>Group to the canvas object, you can duplicate the bonus objects to add more. When you do this, all new instances are automatically aligned side by side, in a row because of the <span class="strong"><strong>Horizontal Layout Group</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_058.jpg" /></div><p>
</p><p>Duplicating bonus objects, aligning them in a row via the Horizontal Layout Group</p><p>The relative spacing between elements can be controlled from the <span class="strong"><strong>Horizontal Layout Group</strong></span>. Simply increase or decrease the spacing field from the object <span class="strong"><strong>Inspector</strong></span>. In my case, the bonus icons appear with too much pixel spacing between them. We can reduce the spacing by setting the spacing field to a negative value.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_059.jpg" /></div><p>
</p><p>Changing the pixel spacing between UI elements</p><p>By default, the <span class="strong"><strong>Horizontal LayoutÂ Group</strong></span> overrides the width and height settings for each element, working to accommodate the total number of elements in a row. This can often be problematic when you want specific sizes, or different sizes, for each element. You can control this, however, by adding a Layout Element component to each element in the row. To do this, select each bonus object and choose <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Layout</strong></span> | <span class="strong"><strong>Layout Element</strong></span> from the application menu. This adds a <span class="strong"><strong>Layout Element</strong></span> component to each object.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_060.jpg" /></div><p>
</p><p>Adding a Layout Element to a bonus object, controlling the size of each element.</p><p>Next, use the minimum and preferred size fields to control the size of the bonus object. For <span class="emphasis"><em>Dead Keys</em></span>, the bonus object is <span class="emphasis"><em>256x265</em></span> pixels. The minimum field specifies the smallest size an element can possibly be in any circumstances and Unity will never shrink an element smaller than that size, even if more elements are added to the row and cannot fit on screen. The preferred field instead specifies the ideal size for an element whenever that size is possible, otherwise the element may be resized to smaller dimensions if it's necessary to make room for more elements.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_061.jpg" /></div><p>
</p><p>Configuring a Layout Element within a group</p><p>Now label all the bonus objects with a <span class="strong"><strong>BonusObject</strong></span> tag (create this tag, if necessary). This is important for helping Unity quickly identify bonus objects in code at scene startup, as these should be hidden until a bonus is achieved.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_062.jpg" /></div><p>
</p><p>Tagging bonus objects</p><p>Next, create a <code class="literal">UIBonus.cs</code> script file and assign this to the canvas parent object. This script hides all bonus objects at level startup and determines whether a bonus object should be hidden. Comments are included after the following code sample:</p><pre class="programlisting">using UnityEngine; &#13;
using System.Collections; &#13;
 &#13;
public class UIBonus : MonoBehaviour  &#13;
{ &#13;
    public GameObject[] BonusObjects; &#13;
 &#13;
    // Use this for initialization &#13;
    void Awake ()  &#13;
    { &#13;
        BonusObjects = GameObject.FindGameObjectsWithTag ("BonusObject"); &#13;
    } &#13;
     &#13;
    // Update is called once per frame &#13;
    void Update () &#13;
    { &#13;
        ///Set bonus level &#13;
        //Hide/Show all bonus objects &#13;
        for (int i = 0; i &lt; BonusObjects.Length; i++)  &#13;
        { &#13;
            if (i &lt; GameManager.ThisInstance.BonusLevel) &#13;
                BonusObjects [i].SetActive (true); &#13;
            else &#13;
                BonusObjects [i].SetActive (false); &#13;
        } &#13;
    } &#13;
} &#13;
</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec53"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">BonusObjects</code> array references all scene objects tagged as <code class="literal">BonusObject</code>. This will refer to one or more objects.</p></li><li style="list-style-type: disc"><p>The <code class="literal">GameManager</code> class, which is an overarching class that persists across scenes, maintains the variable <code class="literal">BonusLevel</code>. This is an integer determining how many bonus objects have been collected, if any.</p></li><li style="list-style-type: disc"><p>The <code class="literal">Update</code> function cycles through all bonus objects, and enables them depending on the size of the <code class="literal">BonusLevel</code>. This makes sense because, as additional bonus levels are reached, more bonus objects should become visible.</p></li><li style="list-style-type: disc"><p>The order of bonus objects in the array is irrelevant as the <span class="strong"><strong>Horizontal Layout Group</strong></span> automatically resizes and reorders only active objects. Thus, as bonus objects become active, they'll be added and resized as needed within the Layout group.</p></li></ul></div><p>Excellent work! We've now coded a bonus system from which specific bonus objects may be unlocked by using an integer variable <code class="literal">BonusLevel</code>. This is good, but still we don't have the functionality to actually collect a bonus in-game, even though the framework is now in place. To achieve this, we'll need a zombie to destroy.</p></div></div>