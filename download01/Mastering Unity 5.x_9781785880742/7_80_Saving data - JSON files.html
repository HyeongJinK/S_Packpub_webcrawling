<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec78"></a>Saving data - JSON files</h2></div></div><hr /></div><p>Saving data to XML is an important and powerful ability. XML is such a common data-interchange format that almost all data-driven applications must support it, both for loading and saving data. Nevertheless, XML files are often large, syntactically verbose, and inappropriate for saving small nuggets of data. XML files can be needlessly large in file size, and can be time-consuming to process. As a result, JSON has emerged as a lighter alternative, and it is commonly adopted in games. Since the release of Unity 5.3, JSON is a natively-supported format. Prior to this release, developers needed to use third-party add-ins. This section covers the latest, native JSON tools provided with Unity. However, if you want or need to use an earlier release, then take a look at the following, free third-party add-on offering JSON support, available here: <a class="ulink" href="http://wiki.unity3d.com/index.php/SimpleJSON" target="_blank">http://wiki.unity3d.com/index.php/SimpleJSON</a>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_07_024.jpg" /></div><p>
</p><p>JSON parser</p><p>To get started using JSON in Unity, create a new project and add the script file, <code class="literal">SerializeTransformJSON.cs</code>. This should be attached to an empty object in the <span class="strong"><strong>Scene</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_07_025.jpg" /></div><p>
</p><p>Adding a new JSON parser script to the Scene</p><p>This JSON script achieves identical results to the XML serializer; saving the transform component of each object. However, both the code and resultant JSON file are shorter, as we'll see. And have a look comments that follow:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
using System.IO; 
//------------------------------------------ 
[System.Serializable] 
public class TransformData 
{ 
   public Vector3 Position; 
   public Quaternion Rot; 
   public Vector3 Scale; 
   public string ObjectName = string.Empty; 
} 
//------------------------------------------ 
[System.Serializable] 
public class TransformCollection 
{ 
   public TransformData[] DataArray; 
} 
//------------------------------------------ 
public class serializeTransformJSON : MonoBehaviour 
{ 
   //------------------------------------------ 
   public Transform[] TransformArray; 
   public string FilePath = "/Saves/MyTransformData.json"; 
   public TransformCollection MyData; 
   //------------------------------------------ 
   // Use this for initialization 
   void Awake ()  
   { 
         //Get transform component 
         TransformArray = Object.FindObjectsOfType&lt;Transform&gt;(); 
         TransformCollection MyData = new TransformCollection (); 
   } 
   //------------------------------------------ 
   public void SaveData() 
   { 
         //Create new array 
         MyData.DataArray = new TransformData[TransformArray.Length]; 
 
         for(int i=0; i&lt;MyData.DataArray.Length; i++) 
         { 
               MyData.DataArray[i] = new TransformData (); 
               MyData.DataArray[i].Position = TransformArray[i].position; 
               MyData.DataArray[i].Rot = TransformArray[i].rotation; 
               MyData.DataArray[i].Scale = TransformArray[i].localScale; 
               MyData.DataArray[i].ObjectName = TransformArray[i].name; 
         } 
 
         string JSONString = JsonUtility.ToJson(MyData); 
         string SavePath = Application.persistentDataPath + "/" + FilePath; 
 
         File.WriteAllText(SavePath, JSONString); 
         Debug.Log ("Saving Data To: " + SavePath); 
   } 
   //------------------------------------------ 
   public void LoadData() 
   { 
         string LoadPath = Application.persistentDataPath + "/" + FilePath; 
         string JSONString = File.ReadAllText (LoadPath); 
 
         MyData = JsonUtility.FromJson&lt;TransformCollection&gt;(JSONString); 
 
         //Update objects 
         for (int i = 0; i &lt; MyData.DataArray.Length; i++)  
         { 
               //Find object of matching name 
               GameObject Selected = GameObject.Find(MyData.DataArray[i].ObjectName); 
 
               //Get transform component 
               Transform SelectedTransform = Selected.GetComponent&lt;Transform&gt;(); 
 
               SelectedTransform.position = MyData.DataArray [i].Position; 
               SelectedTransform.localScale = MyData.DataArray [i].Scale; 
               SelectedTransform.rotation = MyData.DataArray [i].Rot; 
         } 
   } 
   //------------------------------------------ 
   void Update() 
   { 
         if (Input.GetKeyDown (KeyCode.S))  
         { 
               SaveData(); 
               return; 
         } 
 
         if (Input.GetKeyDown (KeyCode.L))  
         { 
               LoadData(); 
               return; 
         } 
   } 
   //------------------------------------------ 
} 
//------------------------------------------ 
</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec72"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">TransformData </code>class is the serializable primitive object storing the raw transform data extracted from the transform component. However, for the JSON serializer, we'll use the <code class="literal">Vector3</code> and <code class="literal">Quaternion</code> data types, as these serialize to a file without issues.</p></li><li style="list-style-type: disc"><p>In the <code class="literal">Awake</code> function, all transform components are found using the <code class="literal">Object.FindObjectsOfType</code> function. This generates an array of found transform components in the class variable, <code class="literal">TransformArray</code>.</p></li><li style="list-style-type: disc"><p>The <code class="literal">SaveData</code> function is run to serialize all transform components in the scene to a specified JSON file in the <code class="literal">Application.persistentDataPath</code>. This method only serializes all objects currently in the scene, and it assumes each object has a unique name.</p></li><li style="list-style-type: disc"><p>The <code class="literal">SaveData</code> function begins by converting all position, rotation, and scale data from transform components to the <code class="literal">TransformData</code> class, ready to be serialized.</p></li><li style="list-style-type: disc"><p>The <code class="literal">JSONUtility</code> class features all functions for interacting with the native Unity JSON API. You can find more information on this class from the Unity documentation online here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/JsonUtility.html" target="_blank">https://docs.unity3d.com/ScriptReference/JsonUtility.html</a>.</p></li><li style="list-style-type: disc"><p>The <code class="literal">JsonUtility.ToJson</code> function converts a serializable object in memory to a JSON compliant string, which is the function return value. This string could be written to a file, or even dispatched over an Internet connection to another computer.</p></li><li style="list-style-type: disc"><p>The <code class="literal">File.WriteAllText</code> function saves a string to a file, including strings with new lines and returns. This is used to save the JSON data to a file, ready for loading back at any time.</p></li><li style="list-style-type: disc"><p>The <code class="literal">LoadData</code> function is the reverse of the <code class="literal">SaveData</code> function. <code class="literal">LoadData</code> uses <code class="literal">JSONUtility.FromJSON </code>to convert a JSON string back into object form. This can then be loaded back into the object transform components to restore object data. Remember, this method relies on each object in the scene having a unique name, to identify associations between transform components and objects.</p></li><li style="list-style-type: disc"><p>The <code class="literal">Update</code> function is called once per frame and that is where <span class="emphasis"><em>S </em></span>can be pressed on the keyboard to save a scene state, and <span class="emphasis"><em>L</em></span> to load. This is for testing purposes only, and a production version would have this code removed.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note55"></a>Note</h3><p>For sending JSON data over an Internet connection, to a website or server, consider the <code class="literal">WWW</code> class or <code class="literal">WWWForm</code> class. More information on these classes can be found online here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/WWW.html" target="_blank">https://docs.unity3d.com/ScriptReference/WWW.html</a> and <a class="ulink" href="https://docs.unity3d.com/ScriptReference/WWWForm.html" target="_blank">https://docs.unity3d.com/ScriptReference/WWWForm.html</a>.</p></div><p>Great work! Now let's try the code. Press play on the tool bar and run the game. As with testing the XML code, move the objects around from the scene view and press <span class="emphasis"><em>S </em></span>on the keyboard to save the scene state. When you do this, a confirmation message including the filename path is printed in the console as the JSON file is saved.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_07_026.jpg" /></div><p>
</p><p>Saving a JSON file</p><p>You can open JSON files inside MonoDevelop, complete with syntax highlighting, code completion, and formatting.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_07_027.jpg" /></div><p>
</p><p>Previewing JSON files in MonoDevelop</p><p>Here is an example of JSON data saved from my scene. The syntax is lightweight compared to the XML version, and if your objects have the same names, you can copy and paste this code to your scenes to reload my scene arrangement too:</p><pre class="programlisting">{"DataArray":[ 
   {"Position":{"x":-1.5399999618530274,"y":3.450000047683716,"z":3.390000104904Ã¥175}, 
   "Rot":{"x":0.0,"y":0.0,"z":0.0,"w":1.0}, 
   "Scale":{"x":1.0,"y":1.0,"z":1.0}, 
   "ObjectName":"Sphere"}, 
   {"Position":{"x":3.562999963760376,"y":4.000999927520752,"z":-1.0789999961853028}, 
   "Rot":{"x":0.0,"y":0.0,"z":0.0,"w":1.0}, 
   "Scale":{"x":1.0,"y":1.0,"z":1.0}, 
   "ObjectName":"Cylinder"}, 
   {"Position":{"x":0.0,"y":3.0,"z":0.0}, 
   "Rot":{"x":0.0,"y":0.0,"z":0.0,"w":1.0}, 
   "Scale":{"x":1.0,"y":1.0,"z":1.0}, 
   "ObjectName":"Plane"}, 
   {"Position":{"x":0.0,"y":0.0,"z":0.0}, 
   "Rot":{"x":0.0,"y":0.0,"z":0.0,"w":1.0}, 
   "Scale":{"x":1.0,"y":1.0,"z":1.0}, 
   "ObjectName":"Env"}, 
   {"Position":{"x":0.2613380551338196,"y":3.5299999713897707,"z":1.1299999952316285}, 
   "Rot":{"x":0.0,"y":0.0,"z":0.0,"w":1.0}, 
   "Scale":{"x":1.0,"y":1.0,"z":1.0}, 
   "ObjectName":"Cube"}, 
   {"Position":{"x":0.0,"y":3.0,"z":0.0}, 
   "Rot":{"x":0.4082178771495819,"y":-0.23456968367099763,"z":0.10938163101673126,"w":0.8754261136054993}, 
   "Scale":{"x":1.0,"y":1.0,"z":1.0}, 
   "ObjectName":"Directional Light"}, 
   {"Position":{"x":4.758632183074951,"y":6.4804534912109379,"z":4.9773664474487309}, 
   "Rot":{"x":-0.10605409741401673,"y":0.8876926302909851,"z":-0.2560384273529053,"w":-0.36769381165504458}, 
   "Scale":{"x":1.0,"y":1.0,"z":1.0}, 
   "ObjectName":"Main Camera"} 
   ] 
} 
</pre><p>Now press play on the toolbar to test run JSON file loading. Simply press <span class="emphasis"><em>L </em></span>on the keyboard to restore the scene back from the saved data.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_07_028.jpg" /></div><p>
</p><p>Restore data back from JSON files</p><p>Excellent work! In reaching this far you can now load data from both the XML and JSON formats into Unity for restoring games. This not only allows you to implement load and save states, but also other features such as third-party contents and assets, and user-defined levels that can be sent to others in JSON.</p></div></div>