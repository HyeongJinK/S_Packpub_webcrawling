<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec15"></a>Level lighting - preparation</h2></div></div><hr /></div><p>Reaching this far you've now made a complete scene in terms of meshes representing the first level, composed from modular environment pieces (corridor sections). Presently, the level features no lighting, navigation meshes, music or audio, and Occlusion Data; but, we'll add these soon. Let's start with lighting. In Unity, there are three main lighting types or systems, which exist on a spectrum:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Baked lighting</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Real-time lighting</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Precomputed global illumination</strong></span>
</p></li></ul></div><p>These are discussed in detail further here.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec30"></a>Baked lighting</h3></div></div></div><p>Baked lighting is the optimal lighting method, but it can only be used under specific circumstances. With Baked lighting, all lighting data (highlights, shadows, and so on) are precalculated and saved to a texture (lightmap). The lightmap is then applied to scene geometry using a second UV channel (Lightmap UVs), on top of their standard materials, using multiplicative blending. This makes geometry appear illuminated by scene lights. This approach is ideal for achieving high levels of realism while maintaining excellent runtime performance, because it saves Unity from having to calculate lighting at runtime. But lightmapping only works properly for static objects (objects that never move), such as walls, floors, ceilings, and architecture.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_019.jpg" /></div><p>
</p><p>A lighmap texture for the scene</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec31"></a>Dynamic lighting</h3></div></div></div><p>Dynamic lighting is the opposite of Baked lighting. With Baked lighting, all lighting information is precalculated, that is, calculated ahead of runtime. Dynamic lighting, however, is calculated at runtime. This means Unity accepts all lights affecting an object as input, the object itself, and its surrounding objects, and then produces the best lighting approximation it can. The upside of dynamic lighting is that it changes and updates in real time as objects transform in the scene. The downside is computational expense (it's expensive) and realism, as quality sacrifices are made to produce lighting effects in real time. In short, you never want to use dynamic lighting unless you absolutely have to! Thankfully, Unity offers us some tools (<span class="strong"><strong>Light Probes</strong></span>) for semi-baking lighting data, reducing the impact of dynamic lighting.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_020.jpg" /></div><p>
</p><p>Dynamic lighting</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec32"></a>Precomputed global illumination</h3></div></div></div><p>The problem with Baked lighting is its static and unchanging nature. After a lightmap is baked, it cannot be changed without rebaking. In contrast, the problem with dynamic lighting is its performance intensive nature. Light calculated in real time demands lots of resources and processing time. Since Unity 5,  Unity offers a middle-way solution known as precomputed <span class="strong"><strong>global illumination</strong></span> (<span class="strong"><strong>GI</strong></span>). This system lets you recompute (bake) significant lighting data about how light bounces around in the scene, and yet retain the ability to change scene lights at runtime. In short, with precomputed GI you can-move lights, and change their colour and intensity at runtime, and all lighting changes take effect in the scene soon after. However, precomputed GI is restricted only to static objects (non-moving objects). Objects that move must still be illuminated using either dynamic lighting, or a semi-dynamic form, such as Light Probes (as we'll see).</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_021.jpg" /></div><p>
</p><p>Precomputed global illumination</p><p>The three aforementioned lighting systems are not mutually exclusive-they can be used to varying degrees with each other. But for <span class="emphasis"><em>Dead Keys</em></span>, we'll stick with Baked lighting for the environment (since the environment never moves), and semi-dynamic lighting (Light Probes) for animated objects, such as NPCs.</p></div></div>