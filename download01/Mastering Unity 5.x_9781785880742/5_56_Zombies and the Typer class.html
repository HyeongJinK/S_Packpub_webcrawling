<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec56"></a>Zombies and the Typer class</h2></div></div><hr /></div><p>We've now configured the zombie to display the selected word, and also to add text stylizations based on player input. However, we still haven't linked player input through the <code class="literal">Typer</code> class (coded in the previous chapter) with the zombie NPC. Let's do this now by adding a new function to the <code class="literal">EnemyAI</code> class, namely <code class="literal">UpdateTypedWord</code>. This function compares the typed word with the associated word to determine the extent of a match. The purpose is twofold, firstly, to generate the <code class="literal">MatchedWord</code> string, for highlighting the typed portion of the <code class="literal">Associated Word</code>; and secondly, to fire a word matched event (<code class="literal">OnTypingMatched</code>), which causes the zombie to die. Consider the following code:</p><pre class="programlisting">    //------------------------------------ &#13;
    public void UpdateTypedWord() &#13;
    { &#13;
        //If not chasing or attacking, then ignore &#13;
        if(ActiveState != AISTATE.CHASE &amp;&amp; ActiveState != AISTATE.ATTACK) return; &#13;
 &#13;
        MatchedWord = WordList.CompareWords (Typer.TypedWord, AssocWord); &#13;
 &#13;
        //Check for typing match &#13;
        if (MatchedWord.Length != AssocWord.Length) &#13;
            return; &#13;
 &#13;
        if (MatchedWord.Equals (AssocWord)) &#13;
            OnTypingMatched.Invoke (); //Match found. Invoke matched event &#13;
    } &#13;
    //------------------------------------  &#13;
</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec60"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">UpdateTypedWord</code> function starts by determining the zombie state, as player typing and combat only applies when the zombie is chasing or attacking.</p></li><li style="list-style-type: disc"><p>Next, the <code class="literal">CompareWords</code> function determines the extent of the match, if any, between the typed word and the associated word. This function is part of the <code class="literal">WordList</code> class, coded in the previous chapter. It returns a string representing the amount of match between the typed string and the associated word. If there is no match, the string length will be 0. If there is a partial match, the string length will be &gt; 0 but less than the associated word length. There is a complete match when the associated word length and the typed-string length are identical.</p></li><li style="list-style-type: disc"><p>When a match is detected, the <code class="literal">OnTypingMatched</code> event is invoked. This is a Unity Event on the zombie character, and this should initiate the zombie death sequence.</p></li></ul></div><p>To initiate the death sequence from the object Inspector (in the <code class="literal">OnTypingMatched</code> event), we'll need a public <code class="literal">Die</code> function. This is important because only public functions can be launched as actions, inside Unity Events, from the object Inspector. Let's look at the code for this, as follows:</p><pre class="programlisting">    //------------------------------------ &#13;
    public void Die() &#13;
    { &#13;
        //Update Game Score &#13;
        GameManager.ThisInstance.Score += ScorePoints; &#13;
        ScoreText.OnScoreChange.Invoke (); &#13;
 &#13;
        //Calculate Bonus, if achieved &#13;
        float LettersPerSecond = AssocWord.Length / Typer.ElapsedTime; &#13;
 &#13;
        //If we beat best times, then get bonus &#13;
        if (LettersPerSecond &lt; Typer.RecordLettersPerSecond)  &#13;
        { &#13;
            //Bonus achieved &#13;
            ++GameManager.ThisInstance.BonusLevel; &#13;
        } &#13;
 &#13;
        ActiveState = AISTATE.DEAD; &#13;
        --ActiveEnemies; &#13;
 &#13;
        //Reset matched word &#13;
        MatchedWord = string.Empty; &#13;
 &#13;
        //Update Navigator &#13;
        Navigator.ThisInstance.EnemyDie.Invoke(); &#13;
    } &#13;
    //------------------------------------  &#13;
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec61"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">Die</code> function starts by incrementing the player score by the <code class="literal">ScorePoints</code> variable. This is an integer property and represents the number of points achieved for killing the enemy.</p></li><li style="list-style-type: disc"><p>The game then determines if a bonus should be unlocked, because a new record has been set by typing the full word (total number of letters) in the fastest time.</p></li><li style="list-style-type: disc"><p>In addition, the <code class="literal">ActiveEnemies</code> field is a static integer property. Being static it is, in effect, shared across all instances. It represents the total number of active enemies in the level. That is, the total number of enemies who are either searching, chasing, or attacking the player right now and, thus, who can be dispatched through typing combat.</p></li><li style="list-style-type: disc"><p>As the enemy is destroyed, the <code class="literal">ActiveEnemies</code> field is decremented. If this value falls to 0, the in-game camera can move forwards to a new destination.</p></li><li style="list-style-type: disc"><p>The camera <code class="literal">Navigator</code> class is notified of each enemy death through the <code class="literal">EnemyDie</code> event.</p></li></ul></div><p>Now we can configure the zombie for a death event through the object Inspector event interface. Select the zombie, and from the <code class="literal">OnTypingMatched</code> field, call the <code class="literal">Die</code> function and enable an explosion particle:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_05_041.jpg" /></div><p>
</p><p>Configuring the zombie typing matched event</p><p>The explosion system is included in the standard particle system package. Remember, this can be imported from <span class="strong"><strong>Assets </strong></span>| <span class="strong"><strong>Import Package </strong></span>| <span class="strong"><strong>Particle Systems</strong></span>, from the <span class="strong"><strong>Assets</strong></span> menu:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_05_042.jpg" /></div><p>
</p><p>Importing the ParticleSystems package, if needed</p><p>At this point we have completed the <code class="literal">AIEnemy</code> class, and we're almost ready for a test run. Let's see the full and final enemy class code, as follows:</p><pre class="programlisting">//------------------------------------ &#13;
using UnityEngine; &#13;
using System.Collections; &#13;
using UnityEngine.EventSystems; &#13;
using UnityEngine.Events; &#13;
using UnityEngine.UI; &#13;
//------------------------------------ &#13;
public class AIEnemy : MonoBehaviour &#13;
{ &#13;
    //------------------------------------ &#13;
    public enum AISTATE {IDLE = 0, CHASE = 1, ATTACK = 2, DEAD=3}; &#13;
    public AISTATE ActiveState &#13;
    { &#13;
        get{ return mActiveState; } &#13;
        set &#13;
        {  &#13;
            StopAllCoroutines (); &#13;
            mActiveState = value; &#13;
 &#13;
            switch(mActiveState) &#13;
            { &#13;
            case AISTATE.IDLE: &#13;
                    StartCoroutine (StateIdle()); &#13;
                break; &#13;
 &#13;
                case AISTATE.CHASE: &#13;
                    StartCoroutine (StateChase()); &#13;
                break; &#13;
 &#13;
                case AISTATE.ATTACK: &#13;
                    StartCoroutine (StateAttack()); &#13;
                break; &#13;
 &#13;
                case AISTATE.DEAD: &#13;
                    StartCoroutine (StateDead()); &#13;
                break; &#13;
            } &#13;
                 &#13;
            OnStateChanged.Invoke (); &#13;
        } &#13;
    } &#13;
         &#13;
    [SerializeField] &#13;
    private AISTATE mActiveState = AISTATE.IDLE; &#13;
    //------------------------------------ &#13;
    //Events called on FSM changes &#13;
    public UnityEvent OnStateChanged; &#13;
    public UnityEvent OnIdleEnter; &#13;
    public UnityEvent OnChaseEnter; &#13;
    public UnityEvent OnAttackEnter; &#13;
    public UnityEvent OnTypingChanged; &#13;
    public UnityEvent OnTypingMatched; &#13;
    //------------------------------------ &#13;
    //Component references &#13;
    private Animator ThisAnimator = null; &#13;
    private NavMeshAgent ThisAgent = null; &#13;
    private Transform ThisTransform = null; &#13;
 &#13;
    //Reference to player transform &#13;
    private Transform PlayerTransform = null; &#13;
 &#13;
    //Points for enemy &#13;
    public int ScorePoints = 10; &#13;
 &#13;
    //Reference to Score Text &#13;
    private UIScore ScoreText = null; &#13;
 &#13;
    //Player health component &#13;
    private Health PlayerHealth = null; &#13;
 &#13;
    //Word associated &#13;
    public string AssocWord = string.Empty; &#13;
 &#13;
    //Extent of word match with associated word &#13;
    public string MatchedWord = string.Empty; &#13;
 &#13;
    //Amount of damage to deal on attack &#13;
    public int AttackDamage = 10; &#13;
 &#13;
    //Text component &#13;
    private Text NameTextComp = null; &#13;
 &#13;
    //Active enemy count (how many enemies wandering at one time?) &#13;
    public static int ActiveEnemies = 0; &#13;
 &#13;
    //Sound to play on hit &#13;
    public AudioSource HitSound = null; &#13;
    //------------------------------------ &#13;
    void Awake() &#13;
    { &#13;
        ThisAnimator = GetComponent&lt;Animator&gt; (); &#13;
        ThisAgent = GetComponent&lt;NavMeshAgent&gt; (); &#13;
        PlayerTransform = GameObject.FindGameObjectWithTag ("Player").GetComponent&lt;Transform&gt; (); &#13;
        PlayerHealth = PlayerTransform.GetComponent&lt;Health&gt;(); &#13;
        //Find and get associated UI Text &#13;
        NameTextComp = GetComponentInChildren&lt;Text&gt; (); &#13;
        ThisTransform = GetComponent&lt;Transform&gt; (); &#13;
        HitSound = GetComponent&lt;AudioSource&gt; (); &#13;
        ScoreText = GameObject.FindGameObjectWithTag ("ScoreText").GetComponent&lt;UIScore&gt; (); &#13;
 &#13;
        //Hide text &#13;
        NameTextComp.gameObject.SetActive(false); &#13;
    } &#13;
    //------------------------------------ &#13;
    void Start() &#13;
    { &#13;
        //Set active state &#13;
        ActiveState = mActiveState; &#13;
 &#13;
        //Get random word &#13;
        AssocWord = WordList.ThisInstance.GetRandomWord(); &#13;
 &#13;
        UpdateText(); &#13;
    } &#13;
    //------------------------------------ &#13;
    public IEnumerator StateIdle() &#13;
    { &#13;
        //Run idle animation &#13;
        ThisAnimator.SetInteger("AnimState", (int) ActiveState); &#13;
 &#13;
        //While in idle state &#13;
        while(ActiveState == AISTATE.IDLE) &#13;
        { &#13;
     &#13;
            yield return null; &#13;
        } &#13;
    } &#13;
    //------------------------------------ &#13;
    public IEnumerator StateChase() &#13;
    { &#13;
        ++ActiveEnemies; &#13;
 &#13;
        //Run chase animation &#13;
        ThisAnimator.SetInteger("AnimState", (int) ActiveState); &#13;
 &#13;
        //Set destination &#13;
        ThisAgent.SetDestination (PlayerTransform.position); &#13;
 &#13;
        //Wait until path is calculated &#13;
        while (!ThisAgent.hasPath) &#13;
            yield return null; &#13;
 &#13;
        //While in idle state &#13;
        while(ActiveState == AISTATE.CHASE) &#13;
        { &#13;
            if (ThisAgent.remainingDistance &lt;= ThisAgent.stoppingDistance) &#13;
            { &#13;
                ThisAgent.Stop (); &#13;
                yield return null; &#13;
                ActiveState = AISTATE.ATTACK; &#13;
                yield break; &#13;
            } &#13;
 &#13;
            yield return null; &#13;
        } &#13;
    } &#13;
    //------------------------------------ &#13;
    public IEnumerator StateAttack() &#13;
    { &#13;
        //Run attack animation &#13;
        ThisAnimator.SetInteger("AnimState", (int) ActiveState); &#13;
 &#13;
        //While in idle state &#13;
        while(ActiveState == AISTATE.ATTACK) &#13;
        { &#13;
            //Look at player &#13;
            Vector3 PlanarPosition = new Vector3(PlayerTransform.position.x, ThisTransform.position.y, PlayerTransform.position.z); &#13;
            ThisTransform.LookAt(PlanarPosition, ThisTransform.up); &#13;
 &#13;
            //Get distance between enemy and player &#13;
            float Distance = Vector3.Distance(PlayerTransform.position, ThisTransform.position); &#13;
 &#13;
            if (Distance &gt; ThisAgent.stoppingDistance*2f) &#13;
            { &#13;
                ThisAgent.Stop (); &#13;
                yield return null; &#13;
                ActiveState = AISTATE.CHASE; &#13;
                yield break; &#13;
            } &#13;
 &#13;
            yield return null; &#13;
        } &#13;
    } &#13;
    //------------------------------------ &#13;
    public IEnumerator StateDead() &#13;
    { &#13;
        //Run dead animation &#13;
        ThisAnimator.SetInteger("AnimState", (int) ActiveState); &#13;
 &#13;
        //While in idle state &#13;
        while(ActiveState == AISTATE.DEAD) &#13;
        { &#13;
 &#13;
            yield return null; &#13;
        } &#13;
    } &#13;
    //------------------------------------ &#13;
    public void UpdateTypedWord() &#13;
    { &#13;
        //If not chasing or attacking, then ignore &#13;
        if(ActiveState != AISTATE.CHASE &amp;&amp; ActiveState != AISTATE.ATTACK) return; &#13;
 &#13;
        MatchedWord = WordList.CompareWords (Typer.TypedWord, AssocWord); &#13;
 &#13;
        //Check for typing match &#13;
        if (MatchedWord.Length != AssocWord.Length) &#13;
            return; &#13;
 &#13;
        if (MatchedWord.Equals (AssocWord)) &#13;
            OnTypingMatched.Invoke (); //Match found. Invoke matched event &#13;
    } &#13;
    //------------------------------------ &#13;
    //Deal damage to the player &#13;
    public void DealDamage() &#13;
    { &#13;
        PlayerHealth.Value -= AttackDamage; &#13;
        HitSound.Play (); &#13;
    } &#13;
    //------------------------------------ &#13;
    // Update is called once per frame &#13;
    public void UpdateText () &#13;
    { &#13;
        //Build UI String &#13;
        NameTextComp.text = "&lt;color=red&gt;" + MatchedWord + "&lt;/color&gt;" + AssocWord.Substring(MatchedWord.Length,AssocWord.Length-MatchedWord.Length); &#13;
    } &#13;
    //------------------------------------ &#13;
    public void Die() &#13;
    { &#13;
        //Update Game Score &#13;
        GameManager.ThisInstance.Score += ScorePoints; &#13;
        ScoreText.OnScoreChange.Invoke (); &#13;
 &#13;
        //Calcluate Bonus, if achieved &#13;
        float LettersPerSecond = AssocWord.Length / Typer.ElapsedTime; &#13;
 &#13;
        //If we beat best times, then get bonus &#13;
        if (LettersPerSecond &lt; Typer.RecordLettersPerSecond)  &#13;
        { &#13;
            //Bonus achieved &#13;
            ++GameManager.ThisInstance.BonusLevel; &#13;
        } &#13;
 &#13;
        ActiveState = AISTATE.DEAD; &#13;
        --ActiveEnemies; &#13;
 &#13;
        //Reset matched word &#13;
        MatchedWord = string.Empty; &#13;
 &#13;
        //Update Navigator &#13;
        Navigator.ThisInstance.EnemyDie.Invoke(); &#13;
    } &#13;
    //------------------------------------ &#13;
    public void WakeUp() &#13;
    { &#13;
        ActiveState = AISTATE.CHASE; &#13;
    } &#13;
    //------------------------------------ &#13;
} &#13;
//------------------------------------  &#13;
</pre></div></div>