<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec39"></a>The Typer object</h2></div></div><hr /></div><p>The <code class="literal">WordList</code> class supports the import and tokenization of a dictionary, generating an array of words on a line by line basis. The <code class="literal">GetRandomWord</code> function returns a randomly selected word from the dictionary and the <code class="literal">CompareWord</code> function determines whether a typed word matches the chosen one entirely, partially, or not at all. Having now created this class, we begin work here on the <code class="literal">Typer</code> class, which actually accepts typed input from the keyboard, processes that input and displays UI complements for player feedback. Let's start by creating an object hierarchy. Create a new, empty object at the scene origin to act as the topmost node for the <span class="strong"><strong>Typer</strong></span>. Name the object <code class="literal">Typer</code> and then create a <code class="literal">Canvas</code> object as a child. The canvas contains all objects for the associated UI.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_014.jpg" /></div><p>
</p><p>Creating a Typer object</p><p>As with previous canvas components, we'll configure it to support multiple resolutions with a scaling technique. Set the <span class="strong"><strong>UI Scale Mode</strong></span> to <span class="strong"><strong>Scale With Screen Size</strong></span> and specify a <span class="strong"><strong>Reference Resolution</strong></span> of <code class="literal">1920</code> X <code class="literal">1080</code>. The rationale for this is covered in depth in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Player Controls - Movement.</em></span>
</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_015.jpg" /></div><p>
</p><p>Configuring the Canvas Scaler for multiple resolutions</p><p>The canvas is necessary for showing UI elements as the player types on the keyboard during zombie combat. Specifically, as a new letter is typed, it should appear in the center of the screen as UI text and then zoom inwards into the scene (away from the camera), as though it were a projectile being thrown at an oncoming zombie. To achieve this, start by creating a new <code class="literal">Text</code> object as a child of the <code class="literal">Canvas</code> object.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_016.jpg" /></div><p>
</p><p>Creating a Text object as a child of the Typer's Canvas Scaler</p><p>Position the text to the screen center, previewing your results in the game tab, then use <span class="strong"><strong>stretch</strong></span> anchoring to align the left, right, top and bottom text borders to the screen edges. In addition, from the <span class="strong"><strong>Text</strong></span> component in the object <span class="strong"><strong>Inspector</strong></span>, set the text horizontal alignment to screen center and text vertical alignment to screen center. This ensures the text is always positioned at the center of the screen.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_017.jpg" /></div><p>
</p><p>Aligning text to the screen center</p><p>The text will be an animated UI element to express motion, impact and attack whenever the gamer presses keys on the keyboard. Specifically, the text will zoom inwards, growing smaller as it moves towards the screen center, replicating the effect of being thrown into the world toward attacking zombies. To start creating the animation, select the text object, and open the <span class="strong"><strong>Animation </strong></span>window by choosing <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Animation</strong></span> from the application menu. Two channels should be animated, namely <span class="strong"><strong>Scale</strong></span> (for changing text size) and <span class="strong"><strong>Color</strong></span> (for fading the alpha). Add these two channels by clicking the <span class="strong"><strong>Add Property</strong></span> button.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_018.jpg" /></div><p>
</p><p>Creating animation channels for Scale and Color</p><p>Use the first key frame (<span class="emphasis"><em>Frame 0</em></span>) to reset all text properties back to their defaults each time it plays. Specifically, set the <span class="strong"><strong>Text : Scale</strong></span> to <code class="literal">2</code> (a scale that fills the screen) and set the <span class="strong"><strong>Text : Color</strong></span> to an alpha of <code class="literal">0</code>, making the text invisible. Using the first key frame to reset object properties can be an effective strategy, especially for animations that play repeatedly or regularly but not on a loop.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note31"></a>Note</h3><p>Keep the animation timeline between zero to one second for the text attack animation. This means we can rescale the duration up or down as needed, while retaining control over total duration. Hence, <span class="emphasis"><em>1 x t = t</em></span>, <span class="emphasis"><em>2 x t </em></span>= <span class="emphasis"><em>2t</em></span>, and so on.</p></div><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_019.jpg" /></div><p>
</p><p>Setting text Scale and Color for the starting frame</p><p>For the second key frame (that is, <span class="emphasis"><em>Frame 1</em></span>), change the <span class="strong"><strong>Text Color</strong></span> to Alpha <code class="literal">1</code>, making the text visible. It doesn't matter what the text object actually says in the view port at design time, because the text will change programmatically based on keyboard input.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_020.jpg" /></div><p>
</p><p>Showing the text for an attack animation</p><p>Before inserting intervening frames, add the last frame to the timeline. It's good practice to <span class="emphasis"><em>block in</em></span> an animation, first by creating core key frames at the beginning, middle, and end. These define the main structure of motion. Then, later, refine those frames by adding intervening ones describing the changes between them. In our case, the last frame should shrink the text to a <span class="strong"><strong>Scale</strong></span> of <code class="literal">0.2</code>, and reset the color Alpha back to <code class="literal">0</code>. This creates the effect of text being thrown into the scene, before disappearing, or fading, as it moves further from us.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_021.jpg" /></div><p>
</p><p>Defining the last key frame</p><p>Right now, with only the start and end frames defined, text transparency fades to Alpha <code class="literal">0</code> from start to end. To keep the text visible and clearer for longer, we'll need an extra frame, between the start and end to retain text visibility. Move to <span class="strong"><strong>0.33</strong></span> in the timeline, and insert a color frame, keeping the Alpha at <code class="literal">255</code> (or 1 in normalized values). This holds text color between times <span class="strong"><strong>0</strong></span>
<span class="strong"><strong>-</strong></span>
<span class="strong"><strong>0.33</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_022.jpg" /></div><p>
</p><p>Holding text color between time 0-0.33</p><p>Remember to disable animation looping for the clip. The animation will probably play frequently, but not on a loop. Select the clip from the <span class="strong"><strong>Project </strong></span>panel and disable the <span class="strong"><strong>Loop Time</strong></span> check box.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_023.jpg" /></div><p>
</p><p>Disable animation looping</p><p>This completes the text animation itself. It's pretty simple but, despite this simplicity, its importance in-game cannot be understated for usability reasons. It will serve several important design functions. Firstly, it offers feedback (confirming that a key was pressed); secondly, it educates by asserting the primary game mechanic (text typing as an aggressive and combative act); and, thirdly, it expresses the <span class="emphasis"><em>direction of action</em></span> (text moving away from the viewer) as an action that damages enemies in front of us. Thus, wrapped up in a simple UI animation, without reliance on text instructions, we educate the player on how to play and on the importance of their actions. </p><p>Now let's configure the associated animator graph which, by default, always plays the first animation clip at level startup. Open the graph editor and create a new trigger parameter called <span class="strong"><strong>ThrowText</strong></span>. This parameter will be invoked whenever text is typed in combat.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_024.jpg" /></div><p>
</p><p>Creating a ThrowText trigger parameter</p><p>Next, create an empty node as the starting, default node for the graph by simply right-clicking and selecting <span class="strong"><strong>Create State</strong></span> | <span class="strong"><strong>Empty</strong></span> from the context menu. Then, right-click the node and select <span class="strong"><strong>Set as Layer Default State</strong></span>. Connect the empty node to the <span class="strong"><strong>
<span class="strong"><strong>ThrowTextA</strong></span>nim</strong></span> animation, and use the <span class="strong"><strong>ThrowText</strong></span> trigger as a condition.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_025.jpg" /></div><p>
</p><p>Connecting the starting node to Throw Text by a trigger condition</p><p>Don't forget to add a backwards transition from the animation node to the idle node. Simply create a transition without a condition and enable <span class="strong"><strong>Has Exit Time</strong></span>. This ensures animation flow returns to the idle node after the text animation completes. You may also need to select the animation node and change its <span class="strong"><strong>Speed</strong></span> to match your needs. I've set my speed to five.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_04_026.jpg" /></div><p>
</p><p>Creating a two-way node connection</p><p>Voila! We've now created a text-throw animation and configured this alongside an animator graph with a trigger. The next step is to link the animation to code that accepts user input.</p></div>