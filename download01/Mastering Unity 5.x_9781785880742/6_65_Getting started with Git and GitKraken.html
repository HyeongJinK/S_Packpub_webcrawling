<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec64"></a>Getting started with Git and GitKraken</h2></div></div><hr /></div><p>So let's start using the Git client, GitKraken, to manage the <span class="emphasis"><em>DeadKeys</em></span> project using version control with Git. By doing this, we'll be able to keep track of every change made to <span class="emphasis"><em>DeadKeys</em></span> from here onwards, and we'll also be able to reverse and forward development history, as needed. Before getting started with Git, let's clarify a few technical terms. These are presented in point form in a carefully selected order, as below:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Git is software for tracking changes to a group of files and folders. The total collection of tracked files, including Git meta-data for storing information about the changes, is known as a <span class="strong"><strong>Repository</strong></span> (or <span class="strong"><strong>Repo</strong></span>). This is essentially a folder containing many files.</p></li><li style="list-style-type: disc"><p>A Repo can be remote (stored on a web server) or local (stored on a local hard drive). Often both types are involved. As a user downloads the remote version onto their local machine, they are creating a clone.</p></li><li style="list-style-type: disc"><p>Creating a new Repo from scratch is called <span class="strong"><strong>Initializing</strong></span> a Repo (or <span class="strong"><strong>Init</strong></span> for short).</p></li></ul></div><p>When you first start GitKraken you'll be faced with three main options: <span class="strong"><strong>Open</strong></span>, <span class="strong"><strong>Clone,</strong></span> and <span class="strong"><strong>Init</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_023.jpg" /></div><p>
</p><p>Gettingstarted with GitKraken...</p><p>These three main options (<span class="strong"><strong>Open</strong></span>, <span class="strong"><strong>Clone</strong></span>, and <span class="strong"><strong>Init</strong></span>) have a technical meaning in the world of Git.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Open</strong></span>:<span class="strong"><strong> </strong></span>This lets you pick a folder on the computer that contains a local Repo. This contains all your Unity project files (as well as additional Git files for version control).</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Clone</strong></span>: This lets you specify a Remote Repo to download.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Init</strong></span>: This lets you create a new and empty Repo. Let's a create new Repo. To do this, click the<span class="strong"><strong> Init</strong></span> button.</p></li></ul></div><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_024.jpg" /></div><p>
</p><p>Creating a new Repo</p><p>After selecting <span class="strong"><strong>Init</strong></span>, you can choose where  the Repo is created. You can create a local Repo on the computer, or a repo on<span class="strong"><strong> Github</strong></span> or <span class="strong"><strong>BitBucket</strong></span>. These are free, web-based servers for hosting Git repos. Later, we'll use BitBucket. For now, let's create a local Repo. To do this, select the<span class="strong"><strong> Local</strong></span> tab, and enter a <span class="strong"><strong>New repository path</strong></span> (this references a folder on the computer where the Repo should be created). The folder should be empty.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_025.jpg" /></div><p>
</p><p>Naming and locating the Repo</p><p>Next, we should choose a <span class="strong"><strong>GitIgnore Template</strong></span>. This is a special text file included in the Git Repo, listing all file and folder types that Git should ignore when tracking. This is important because some files, like user preference data and UI customizations, should remain local to a specific user. These should not be shared because each user has their own UI preferences and customizations. The only files we should track are the development-relevant files, and any files needed to support those. Thankfully, GitKraken ships with pre-configured GitIgnore files for specific programs that we can use immediately. Click the <span class="strong"><strong>GitIgnore</strong></span> field, and then choose <span class="strong"><strong>Unity</strong></span> from the dropdown. This configures the Repo to ignore user-preference data for Unity.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_026.jpg" /></div><p>
</p><p>Selecting a GitIgnore file</p><p>The GitIgnore file conforms to a specific Git syntax, and it uses wildcard symbols (<code class="literal">*</code>) to specify the different file types and naming conventions to be ignored. The GitIgnore file for Unity is as follows:</p><pre class="programlisting">/[Ll]ibrary/  
/[Tt]emp/  
/[Oo]bj/  
/[Bb]uild/  
  
# Autogenerated VS/MD solution and project files  
*.csproj  
*.unityproj  
*.sln  
*.suo  
*.tmp  
*.user  
*.userprefs  
*.pidb  
*.booproj  
  
# Unity3D generated meta files  
*.pidb.meta  
  
# Unity3D Generated File On Crash Reports  
sysinfo.txt 
</pre><p>Now click the <span class="strong"><strong>Create Repository </strong></span>button, to generate a new Repo, and the <span class="emphasis"><em>GitKraken</em></span> interface will display the main Repo details. The Repo is empty to start with, with the exception of the Git meta-data files, used internally to track file changes. Excellent! We now have our first Repo.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_027.jpg" /></div><p>
</p><p>The Git Repo interfaces</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec68"></a>Commits and branches</h3></div></div></div><p>The Git Repo is a folder-based database of files and changes. A Repo is effectively a chronological sequence of project Snapshots. It keeps track of the state of your project across time. A <span class="strong"><strong>Snapshot</strong></span> simply represents the complete state of your project at a specific date and time. When you first create a Repo, the Repo consists of one Branch, called the <span class="strong"><strong>MasterBranch.</strong></span> A Branch represents a single, complete timeline of snapshots. A timeline is a good analogy because changes to the project happen in time, one after another, and each change builds from the ones before along a continuous line or <span class="emphasis"><em>Branch</em></span>. The GitKraken interface indicates that a Branch (named <span class="strong"><strong>Master</strong></span>) has been created and is currently active.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_028.jpg" /></div><p>
</p><p>The active branch</p><p>The left-hand column lists all branches in the Repo (there can be multiple branches). The topmost breadcrumb trail indicates the currently active branch. The active branch is simply the branch that tracks all changes happening to files. Let's now make our first change to the files by copying and pasting our Dead Keys project into our Git project folder. To do this, you can use Windows Explorer or Mac Finder to transfer the files.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_029.jpg" /></div><p>
</p><p>Copying files into the Git Repo</p><p>After adding the files to the <code class="literal">Project</code> folder, GitKraken detects the change and updates the interface with a new entry to the master branch. This appears at the top of the Tracked Changes list.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_030.jpg" /></div><p>
</p><p>New changes tracked on the Master Branch</p><p>The tracked changes are not yet part of the Repo. Right now, Git has only detected the changes and displayed these inside the interface. The <span class="emphasis"><em>green number</em></span> added to the list indicates the total number of files to which changes have been detected. In this case, 1,024 new files have been copied into the project folder, and these are all files included in the <span class="emphasis"><em>Dead Keys</em></span> Unity project. For Git to accept these files and add them to the Repo as part of the Branch history, we must stage the files. This is about marking all files that Git should track and maintain as part of the Branch. For this initial change, we want to track and add all files. Select the new, topmost entry in the list to select it, and the <span class="strong"><strong>Properties</strong></span> panel (on the right-side) displays more information.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_031.jpg" /></div><p>
</p><p>Selecting the changes</p><p>Each detected file where a new change has occurred is located by Git in one of two lists, Staged or Unstaged. All changes begin, by default, in the Unstaged list. This is a list of files where changes have occurred. Git will mostly ignore them until you specify that a specific file should be added to the Staged list. Files added to the Staged list simply remain together, in a collection, until you confirm that Git should acknowledge the change, and then add them to the activate branch as a Snapshot (called a <span class="strong"><strong>Commit).</strong></span> Let's add all the new changes to the Staged List. To do this, click the<span class="strong"><strong> Stage<span class="strong"><strong> a</strong></span>
</strong></span>
<span class="strong"><strong>ll changes</strong></span> button from the Unstaged List.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_032.jpg" /></div><p>
</p><p>Staging changes</p><p>This adds all <span class="strong"><strong>Unstaged Files</strong></span> to the Staged List. By doing this you are preparing to make a package (<span class="emphasis"><em>Commit</em></span>) to the active Branch. Next, we'll need to name the Commit. A Commit represents all recently changed files to save. This should be a general summative name, describing all files to be staged. To do this, click the entry name in the list, and then rename. I've used the name <span class="strong"><strong>First Commit</strong></span> since it represents the initial stage of our development history.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_033.jpg" /></div><p>
</p><p>Naming the First Commit</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>The first commit for Git represents the starting state of a project, even if the project is actually half-finished when the first commit is made. Git only allows you to forward and rewind between actual Commits, as we'll see. We <span class="emphasis"><em>cannot</em></span> <span class="emphasis"><em>rewind</em></span> back to earlier states of the project before the first commit. For this reason, it's good practice to use Git from the outset of your project.</p></div><p>Now we've named the commit, let's write a comment for it. This is a user-defined message, which can be anything we want, but it should be descriptive and meaningful. In addition, the message should be written in the <span class="emphasis"><em>Present tense</em></span> to avoid ambiguity about past work that has since changed, and future work yet to be implemented. For example: avoid writing <span class="emphasis"><em>Added Path-finding function</em></span>, or <span class="emphasis"><em>Will Add Path-finding function</em></span>. Instead, write: <span class="emphasis"><em>Adds Path-finding function</em></span>. This describes what the commit actually does. For the first commit, I'll write <span class="emphasis"><em>Initial State of Unity Project</em></span>. This is our starting point.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_034.jpg" /></div><p>
</p><p>Commenting on the First Commit</p><p>Now click <span class="strong"><strong>Commit</strong></span>, And that's it! We've now created our <span class="strong"><strong>First Commit</strong></span>, and this is updated in the Branch History List. The topmost item in the list represents the latest <span class="emphasis"><em>Commit</em></span>, and this features our custom name and comment.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_035.jpg" /></div><p>
</p><p>Added First Commit</p><p>You can select the commit in the Branch History list to reveal more information in the Properties panel. Each Commit has a specific time and date, author, and a commit ID, which uniquely identifies the commit within the Repo.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_036.jpg" /></div><p>
</p><p>Viewing Commit Details</p><p>Great work! You've now made your first commit and have <span class="emphasis"><em>immortalised</em></span> the initial state of your project. The Commit represents a snapshot in the project; a saved state. This means we can easily return to this state, anytime later, if we need to.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec69"></a>Forwards and backwards with Git</h3></div></div></div><p>Let's test a practical case scenario for <span class="emphasis"><em>Dead Keys</em></span> when using Git. If you open the Git project folder in either Windows Explorer or the Mac Finder, the contents will always reflect the latest commit on the active branch.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_037.jpg" /></div><p>
</p><p>The Project folder represents the Latest Commit on the Active Branch</p><p>But, consider this, what if we made a mistake by creating the latest commit? What if we don't actually care about the latest commit (perhaps because it contains invalid files) and we want to undo it, restoring our work back to the previous commit? To achieve this, we can use the revert command. Simply right-click on the latest Commit in the <span class="strong"><strong>Branch History </strong></span>and choose <span class="strong"><strong>Revert Commit</strong></span> from the context menu.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_038.jpg" /></div><p>
</p><p>Reverting the latest commit</p><p>GitKraken then asks you <span class="strong"><strong>Do you want to immediately </strong></span>
<span class="strong"><strong>commit the reverted changes</strong></span>? (to make the previous Commit the latest one). Let's choose <span class="strong"><strong>Yes</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_039.jpg" /></div><p>
</p><p>Confirming the revert</p><p>After Reverting the latest Commit Git will <span class="emphasis"><em>undo</em></span> all changes included in it. Git does this, however, not by removing the latest Commit per se, but by creating a new Commit, reinstating the first. This highlights an important feature of Git: it never deletes anything! It always adds operations onto previous Commits. Thus, the act of undoing means deleting files or restoring earlier versions from the current state. Consequently, Git always lets you revert backwards through the history, restoring any earlier commits that you need.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_040.jpg" /></div><p>
</p><p>Creating a new reverted commit</p><p>Remember, you can easily revert the reverted commit too! This effectively restores the First Commit including all the <span class="emphasis"><em>Dead Keys</em></span> files.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_06_041-e1484027968403.jpg" /></div><p>
</p><p>Restoring the dead keys project files</p><p>Excellent! We can now make Commits and revert the latest Commit. Next, we'll jump into Unity and configure it for use with GitKraken, and Git more generally.</p></div></div>