<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec22"></a>Occlusion Culling</h2></div></div><hr /></div><p>Unity imposes no official limits on the size of your scene, and there's no established convention or industry-standard making recommendations about scene size. This is a decision largely in your hands. But there will certainly be a limit in a practical sense. The complexity of meshes, materials, and special effects combine together with the number of meshes and their spread to determine just how computationally expensive a scene is when presented to a camera with a specific frustum and field of view. Unity tries to make scene rendering easier on the computer by applying <span class="strong"><strong>Frustum Culling</strong></span> automatically. That is, it silently deactivates (culls) objects outside the viewing volume (frustum) of the camera. As objects leave the frustum, Unity ceases to render them, and as they enter the volume Unity starts rendering them. This optimization works well in many cases, for objects that clearly enter and leave the Frustum.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_065.jpg" /></div><p>
</p><p>Camera frustum defines the limits of what can be seen</p><p>Using Frustum Culling, it becomes possible to create large scenes with many meshes, without worrying about whether the camera will be burdened by unmanageable render workloads. However, despite this, it's important to emphasize that the camera frustum is a volume, which follows the camera, and defines the region inside which all objects could potentially be visible. That is, only objects within the frustum can possibly be seen. But, not all objects in the frustum are necessarily seen. </p><p>For example, if a camera moves close to a wall, the objects beyond it may technically come into the frustum, but they will not, in fact, be seen by the camera, because they will be occluded by the wall. Even so, Unity continues to process and render all frustum objects, even though it actually wastes time doing so, because it doesn't check their visibility after entering the frustum. This can be problematic because even objects within the frustum can still hinder render performance, if they're high-poly and detailed. However, in identifying the problem we see a new window of opportunity for optimization, which Unity supports. Specifically, we can use Occlusion Culling. This lets Unity make further culling decisions about whether objects within the Frustum should be rendered, based on their visibility. To get started with Occlusion Culling, create a new empty object by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> from the application menu.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_066.jpg" /></div><p>
</p><p>Creating a new empty in preparation for Occlusion Culling</p><p>After creating a new, empty object, rename it to <code class="literal">OcclusionArea</code>, and then position it to the world origin (<code class="literal">0</code>,<code class="literal">0</code>,<code class="literal">0</code>). This step is not essential, but it makes for a cleaner workflow.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_067.jpg" /></div><p>
</p><p>Resetting the Occlusion Area to the world origin</p><p>Next, select the empty and navigate to<span class="strong"><strong> Component</strong></span> | <span class="strong"><strong>Rendering</strong></span> | <span class="strong"><strong>Occlusion Area</strong></span> from the application menu. This adds an <span class="strong"><strong>OcclusionArea</strong></span> component, which will contain all Occlusion Data for the scene. It defines how objects relate to each other, making it quicker for cameras to determine whether any object in the frustum is visible.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_068.jpg" /></div><p>
</p><p>Adding an Occlusion Area component in preparation for Occlusion Culling</p><p>By adding an <span class="strong"><strong>Occlusion Area</strong></span> component to the empty, you can use the <span class="strong"><strong>Size</strong></span>
<span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y,</strong></span> and <span class="strong"><strong>Z</strong></span>fields to resize a boundary volume around the scene. The idea is to resize the volume to fully encompass either the entire scene or the area in which Occlusion Culling applies if it's not the entire scene. Ideally, the volume should be sized tightly around the scene, leaving little empty space at the fringes. You may also need to adjust the <span class="strong"><strong>Center</strong></span> field to better size the volume. You can resize the volume through typeins, via the object <span class="strong"><strong>Inspector, </strong></span>or you can interactively resize with the mouse from the viewport by clicking on and dragging the gizmo handles.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_069.jpg" /></div><p>
</p><p>Sizing the Occlusion Culling volume</p><p>After creating an <code class="literal">OcclusionArea</code>, defining an area with densely populated meshes, open the <span class="strong"><strong>Occlusion Culling</strong></span> window by navigating to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Occlusion Culling</strong></span> from the application menu. This displays a free-floating window, which can be docked into the object <span class="strong"><strong>Inspector</strong></span>. This window is used for baking Occlusion Data based on all active Occlusion Areas in the scene.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_070.jpg" /></div><p>
</p><p>Accessing the Occlusion Culling Bake Features</p><p>From the <span class="strong"><strong>Occlusion </strong></span>Culling window, the default settings can often be left as is for scenes using real-world scales. Simply click on the <span class="strong"><strong>Bake</strong></span> button, and Occlusion Data is generated. The bake time varies, depending on the scene and its contents, but it is usually less than a minute. Once completed, the scene is surrounded by gizmo boxes representing spatial divisions that are integral to the culling algorithm.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_071.jpg" /></div><p>
</p><p>Baking Occlusion Data</p><p>You can preview the effects of Occlusion Culling, and its implications for specific cameras, by switching to the <span class="strong"><strong>Visualization</strong></span> tab in the <span class="strong"><strong>Occlusion</strong></span> Culling window, and then selecting a perspective camera in the scene. When you do this, the viewport rendering changes, showing only the meshes visible to the camera given its position, field of view, and frustum. The preview updates in real time as the camera moves. This is helpful for showing how Occlusion Culling works from any camera and perspective, and the extent to which it's optimized for your scene and cameras.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_02_072.jpg" /></div><p>
</p><p>Previewing Occlusion Data</p><p>Excellent! Occlusion Culling is now successfully configured for the scene. Next, we just need to add a camera to the scene for the player character.</p></div>