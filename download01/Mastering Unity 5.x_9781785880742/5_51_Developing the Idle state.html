<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec51"></a>Developing the Idle state</h2></div></div><hr /></div><p>The Idle state is ultimately the starting state for a zombie, and a passive state. Normally, an NPC in Idle will stand around and just look about. It's a state from which action may begin. For <span class="emphasis"><em>Dead Keys</em></span>, the zombies remain in Idle until instructed to change, based on camera movement and the position of the player:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_05_021.jpg" /></div><p>
</p><p>Idle state</p><p>As the player enters the Chase range of an NPC, the NPC comes to life. In many games, a deciding factor will be line of sight. The enemy chases, or pursues the player as they enter their line of sight. However, for <span class="emphasis"><em>Dead Keys</em></span>, this is unnecessary because camera movement, as the player progresses from one point to the next, determines whether an NPC moves into view. For this reason, the <code class="literal">StateIdle</code> coroutine will remain almost empty. However, the <code class="literal">SetInteger</code> function will be called to the set the animator integer parameter:</p><pre class="programlisting">    public IEnumerator StateIdle() &#13;
    { &#13;
        //Run idle animation &#13;
        ThisAnimator.SetInteger("AnimState", (int) ActiveState); &#13;
 &#13;
        //While in idle state &#13;
        while(ActiveState == AISTATE.IDLE) &#13;
        { &#13;
     &#13;
            yield return null; &#13;
        } &#13;
    }  &#13;
</pre><p>Although the <code class="literal">StateIdle</code> coroutine represents everything needed for an NPC in <span class="emphasis"><em>Dead Keys</em></span>, let's take a small detour and consider an NPC for other uses and games. What about cases where NPC states rest on whether the player can be seen (line of sight)? An example is when a NPC chases the player because the player has been seen. Consider the following sample code for an enemy object, with a <span class="strong"><strong>Nav Mesh Agent</strong></span> attached. This code finds a player object in the level and determines whether it can be seen. Comments follow:</p><pre class="programlisting">using UnityEngine; &#13;
using System.Collections; &#13;
//-------------------------------------------------- &#13;
public class Enemy_Script : MonoBehaviour  &#13;
{ &#13;
    private Transform Player = null; &#13;
 &#13;
    //-------------------------------------------------- &#13;
    // Use this for initialization &#13;
    void Start () { &#13;
        Player = GameObject.FindGameObjectWithTag("Player").transform; &#13;
    } &#13;
    //-------------------------------------------------- &#13;
    // Update is called once per frame &#13;
    void Update () { &#13;
        CanSeeAgent(transform, Player, 10f, 30f); &#13;
    } &#13;
    //-------------------------------------------------- &#13;
    //Function to determine if enemy can see player &#13;
    //Agent = The enemy character &#13;
    //Target = The player who may be seen &#13;
    //NearDistance = How close player must be within field of view &#13;
    //FieldofView = Viewing angle enemy must have to be classified as facing player &#13;
    public static bool CanSeeAgent(Transform Agent, Transform Target, float NearDistance, float FieldofView) &#13;
    { &#13;
        //Determine if player is within field of view &#13;
        Vector3 VecDiff = Target.position - Agent.position; &#13;
 &#13;
        //Get angle between look at direction and player direction from enemy &#13;
        float Dot = Vector3.Dot(Agent.forward.normalized, VecDiff.normalized); &#13;
 &#13;
        //If player is behind enemy, then exit &#13;
            if(Dot &lt; 0) return false; &#13;
 &#13;
        //If player is not within viewing angle then exit &#13;
                if(FieldofView &lt; (90f - Dot * 90f)) return false; &#13;
     &#13;
        //Enemy is facing player. Is player within range and is there a direct line? &#13;
        NavMeshHit Hit; &#13;
        if(!NavMesh.Raycast(Agent.position, Target.position, out Hit,-1)) &#13;
        { &#13;
            //Has direct line, is within range? &#13;
            if((Agent.position - Target.position).sqrMagnitude  &gt; NearDistance) return false; &#13;
         &#13;
            //Can be seen (the enemy (Agent) can see the player (Target) &#13;
                        return true; &#13;
        } &#13;
 &#13;
        return false; &#13;
    } &#13;
    //-------------------------------------------------- &#13;
    //Draw forward vector of enemy for line of sight &#13;
    void OnDrawGizmos() &#13;
    { &#13;
        Gizmos.color = Color.red; &#13;
        Vector3 direction = transform.TransformDirection(Vector3.forward) * 5; &#13;
        Gizmos.DrawRay(transform.position, direction); &#13;
    } &#13;
    //-------------------------------------------------- &#13;
} &#13;
//--------------------------------------------------  &#13;
</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec56"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">CanSeeAgent</code> function returns true or false indicating whether a specific NPC (represented by the <code class="literal">Transform</code> component) can see the player (an object tagged as player). True means the player can be seen. False means the player cannot be seen.</p></li><li style="list-style-type: disc"><p>There are several steps in determining player visibility. The first is to establish a field of view for the NPC. That is, an angle threshold either side of the forward vector, representing the angular limits of view.</p></li><li style="list-style-type: disc"><p>To determine whether the player is within the angular limits, the <code class="literal">Vector3.Dot</code> function is used. This function takes two vectors as input and returns information about the angle between the vectors, assuming they were laid out from a common starting point.</p></li><li style="list-style-type: disc"><p>If <code class="literal">Vector3.Dot</code> returns <code class="literal">-1</code> then the two vectors are pointing in exactly the opposite direction. The closer a value moves towards <code class="literal">-1</code>, the further apart the vectors are in orientation.</p></li><li style="list-style-type: disc"><p>If <code class="literal">Vector3.Dot</code> returns <code class="literal">1</code>, then both vectors are pointing in the same direction. The closer a value moves towards <code class="literal">1</code>, the closer together the vectors are in orientation.</p></li><li style="list-style-type: disc"><p>If <code class="literal">Vector3.Dot</code> returns <code class="literal">0</code>, then the two input vectors are perpendicular. That is, intersecting at 90 degrees to each other.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Vector3.Dot</code> is therefore used to determine whether the angle between two vectors is within the field of view. If so, the player can potentially be seen. But, there are additional considerations to explore before we can finally conclude that the player is seen by the NPC.</p></li><li style="list-style-type: disc"><p>In addition to the player being in the NPC's field of view, he or she must be within a specified radius from the NPC. This is because the NPC has a specific horizon or distance beyond which they cannot see. Even when the player is within the field of view, they must also be close enough to be seen. Additionally, there cannot be intervening obstacles (like walls) between the player and NPC. To solve this, the <code class="literal">Raycast</code> function of the <code class="literal">NavMeshAgent</code> is used. This determines whether an unbroken line can be traced between two points, without its leaving the navmesh. If so, a line of sight exists between the NPC and player. Soon we'll code the functionality to change between states!</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p>A sample line of sight project is included in the course companion files, in the folder <code class="literal">Chapter05/LineofSight</code>.</p></div></div></div>