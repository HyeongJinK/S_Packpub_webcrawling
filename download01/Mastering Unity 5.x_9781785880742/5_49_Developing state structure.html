<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec49"></a>Developing state structure</h2></div></div><hr /></div><p>The zombie character has four main states, and therefore the zombie FSM must decide which state should be activated at any time, and which logic should govern the relationship between states. To start implementing the FSM, we'll write the following code, to create a state change function which sets the FSM to a specified state from any of the four available states. Comments follow the code:</p><pre class="programlisting">//------------------------------------ &#13;
using UnityEngine; &#13;
using System.Collections; &#13;
using UnityEngine.EventSystems; &#13;
using UnityEngine.Events; &#13;
using UnityEngine.UI; &#13;
//------------------------------------ &#13;
public class AIEnemy : MonoBehaviour &#13;
{ &#13;
    //------------------------------------ &#13;
    public enum AISTATE {IDLE = 0, CHASE = 1, ATTACK = 2, DEAD = 3}; &#13;
 &#13;
    [SerializeField] &#13;
    private AISTATE mActiveState = AISTATE.IDLE; &#13;
 &#13;
    public AISTATE ActiveState &#13;
    { &#13;
        get{ return mActiveState; } &#13;
        set &#13;
        {  &#13;
            //Stops any running coroutines, if there are any &#13;
            StopAllCoroutines (); &#13;
            mActiveState = value; &#13;
 &#13;
            //Run coroutine associated with active state &#13;
            switch(mActiveState) &#13;
            { &#13;
            case AISTATE.IDLE: &#13;
                StartCoroutine (StateIdle()); &#13;
                break; &#13;
 &#13;
            case AISTATE.CHASE: &#13;
                StartCoroutine (StateChase()); &#13;
                break; &#13;
 &#13;
            case AISTATE.ATTACK: &#13;
                StartCoroutine (StateAttack()); &#13;
                break; &#13;
 &#13;
            case AISTATE.DEAD: &#13;
                StartCoroutine (StateDead()); &#13;
                break; &#13;
            } &#13;
 &#13;
            //Invoke state change event &#13;
            OnStateChanged.Invoke (); &#13;
        } &#13;
    } &#13;
 &#13;
    //Events called on FSM changes &#13;
    public UnityEvent OnStateChanged; &#13;
    //------------------------------------ &#13;
    public IEnumerator StateIdle() &#13;
    { &#13;
        //ADD BODY HERE &#13;
        yield break; &#13;
    } &#13;
    //------------------------------------ &#13;
    public IEnumerator StateChase() &#13;
    { &#13;
        //ADD BODY HERE &#13;
        yield break; &#13;
    } &#13;
    //------------------------------------ &#13;
    public IEnumerator StateAttack() &#13;
    { &#13;
        //ADD BODY HERE &#13;
        yield break; &#13;
    } &#13;
    //------------------------------------ &#13;
    public IEnumerator StateDead() &#13;
    { &#13;
        //ADD BODY HERE &#13;
        yield break; &#13;
    } &#13;
    //------------------------------------ &#13;
}  &#13;
</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec55"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The C# <code class="literal">ActiveState</code> property sets and gets the private variable <code class="literal">mActiveState</code>. This expresses the current state of the FSM.</p></li><li style="list-style-type: disc"><p>Each of the four states (Idle, Chase, Attack, and Dead) correspond to a unique and associated <code class="literal">Coroutine</code> in the class. Right now, the <code class="literal">coroutine</code> is a placeholder. But when implemented, each <code class="literal">Coroutine</code> runs on its own cycle or update loop for as long as a state is active.</p></li><li style="list-style-type: disc"><p>The event <code class="literal">OnStateChanged</code> is invoked whenever a state is changed.</p></li><li style="list-style-type: disc"><p>The <code class="literal">set</code> function for the <code class="literal">ActiveState</code> property updates the current state, stops any existing state by stopping all <code class="literal">Coroutines</code>, and invokes the <code class="literal">OnStateChanged</code> event, allowing Object Inspector level control for state change events, if needed.</p></li></ul></div></div></div>