<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec9"></a>Asset importing for Dead Keys</h2></div></div><hr /></div><p>The previous section explored some general tips on preparing assets for Unity, with optimal performance in mind. These tips are general insofar as they apply for almost all asset types in almost all cases, including <span class="emphasis"><em>Dead Keys</em></span>. Let's now focus on creating our project, DK, a first-person zombie-typer game. This game relies on many assets, from meshes and textures to animation and sound. Here, we'll import and configure many core assets, considering optimization issues and asset-related subjects. We don't need to import all assets right now; we can and often will import more later in development, integrating them into our existing asset library. This section assumes you've already created a new Unity project. From here on, we can begin our work.</p><p>To prepare, let's create a basic folder structure in the <span class="strong"><strong>Project</strong></span> panel to contain all imported assets in a systematic and organized way. The names I've used are self-descriptive and optional. The named folders are <code class="literal">animation</code>, <code class="literal">audio</code>, <code class="literal">audiomixers</code>, <code class="literal">Materials</code>, <code class="literal">meshes</code>, <code class="literal">music</code>, <code class="literal">prefabs</code>, <code class="literal">Resources</code>, <code class="literal">scenes</code>, <code class="literal">scripts</code>, and <code class="literal">textures</code>. Feel free to add more, or change the names, if it suits your purposes.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_020.jpg" /></div><p>
</p><p>Organizing the Project folder</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec20"></a>Importing textures</h3></div></div></div><p>The textures folder will contain all textures to be used by the project. Most importantly, this includes textures for the NPCs zombie characters (hands, arms, legs, and so on) and the modular environment set. In <span class="emphasis"><em>Dead Keys</em></span>, the environment will be a dark industrial interior, full of dark and moody corridors and cross-sections. This environment will really be composed from many smaller, modular pieces (such as corner sections and straight sections) that are fitted together, used and reused, like building blocks to form larger environment complexes. Each of the pieces in the modular set maps in UV space to the same texture (a Texture Atlas), meaning that the entire environment is actually mapped completely by one texture. Let's quickly take a look at that texture:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_021.jpg" /></div><p>
</p><p>Environment Atlas Texture</p><p>All textures for the project are included in the book companion files, in the <code class="literal">ProjectAssets/Textures</code> folder. These should be imported into a Unity project, simply by dragging and dropping them together into the <span class="strong"><strong>Project</strong></span> panel. Using this method, you can import multiple texture files as a single batch, as follows:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_022.jpg" /></div><p>
</p><p>Importing textures into the project</p><p>By default, Unity incorrectly configures Normal Map textures as regular textures. It doesn't distinguish the texture type based on image content. Consequently, after importing Normal Maps, you should configure each one properly. Select the <span class="strong"><strong>Normal map</strong></span> from the <span class="strong"><strong>Project</strong></span> panel, and choose <span class="strong"><strong>Normal map</strong></span> from the <span class="strong"><strong>Texture Type</strong></span> dropdown in the object <span class="strong"><strong>Inspector;</strong></span> afterwards, click on <span class="strong"><strong>Apply </strong></span>to accept the change:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_023.jpg" /></div><p>
</p><p>Importing and configuring Normal maps</p><p>Since every mesh in the modular environment set maps to the same texture space (corners, straight sections, turns, and so on), we'll need to make some minor tweaks to the Atlas Texture settings, for best results. First, select the <span class="strong"><strong>Atlas Texture</strong></span> in the <span class="strong"><strong>Project</strong></span> panel (<code class="literal">DiffuseComposite.png</code>) and change the <span class="strong"><strong>Texture Type</strong></span> to <span class="strong"><strong>Advanced</strong></span>, from the <span class="strong"><strong>Inspector</strong></span> object; this offers us greater control over texture settings:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_024.jpg" /></div><p>
</p><p>Accessing advanced texture properties</p><p>To minimize any texture seams, breaks, and artifacts in the environment texture wherever two mesh pieces meet in the scene, change the texture <span class="strong"><strong>Wrap Mode</strong></span> from <span class="strong"><strong>Repeat</strong></span> to <span class="strong"><strong>Clamp</strong></span>. Clamp mode ensures that edge pixels of a UV island are stretched continuously across the mesh, as opposed to repeated, if needed. This is a useful technique for reducing any seams or artifacts for meshes that map to a Texture Atlas.</p><p>In addition, remove the check mark from the <span class="strong"><strong>Generate Mip Maps</strong></span> option. When activated, this useful optimization shows progressively lower quality textures for a mesh as it moves further from the camera. This helps optimize the render performance at runtime. However, for Texture Atlases, this can be problematic, as Unity's texture resizing causes artifacts and seams at the edges of UV islands wherever two mesh modules meet. This produces pixel bleeding and distortions in the textures.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note6"></a>Note</h3><p>If you want to use Mip Maps with Atlas Textures without risk of artifacts, you can pre-generate your own Mip Map levels. That is, produce lower-quality textures that are calibrated specifically to work with your modular meshes. This may require manual testing and re-testing, until you arrive at textures that work for you. You can generate your own Mip Map levels for Unity by exporting a DDS texture from Photoshop. The DDS format lets you specify custom Mip Map levels directly in the image file. You can download the DDS plugin for Photoshop online at <a class="ulink" href="https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop" target="_blank">https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop</a>.</p></div><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_025.jpg" /></div><p>
</p><p>Optimizing Atlas Textures</p><p>Finally, specify the maximum valid power-2 size for the Atlas Texture, which is <span class="strong"><strong>4096</strong></span>. The format can be <span class="strong"><strong>Automatic Compressed</strong></span>. This will choose the best-available compression method for the desktop platform; then, click on <span class="strong"><strong>Apply:</strong></span>
</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_026.jpg" /></div><p>
</p><p>Applying changes to the Texture Atlas</p><p>In this chapter, we'll put aside most of the UI concerns. However, all GUI textures should be imported as the <span class="strong"><strong>Sprite (2D and UI)</strong></span> texture type, with Mip Maps disabled. For UI textures, it's not necessary to follow the power-2 size rule (that is, pixel sizes of 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 and so on).</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_027.jpg" /></div><p>
</p><p>Importing UI textures</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec21"></a>Importing meshes</h3></div></div></div><p>Ideally, you should import textures before meshes, as we've done here. This is because, on mesh import, Unity automatically creates materials and searches the project for all associated textures. On finding suitable textures, it assigns them to the materials before displaying the results on the mesh, even in the <span class="strong"><strong>Project</strong></span> panel thumbnail previews. This makes for a smoother and easier experience. When you're ready to import meshes, just drag and drop them into the <span class="strong"><strong>Project</strong></span> panel to the designated <code class="literal">meshes</code> folder. By doing this, Unity imports all meshes as a single batch. This project relies heavily on meshes, both animated character meshes for the NPC zombies and static environment meshes for the modular environment-as well as prop meshes and any meshes that you would want to include for your own creative flourish. These files (except your own meshes!) are included in the book's companion files.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_028.jpg" /></div><p>
</p><p>Importing meshes (both environment and character meshes)</p><p>Let's now configure the modular environment meshes. Select all meshes for the environment, including <code class="literal">section_Corner</code>, <code class="literal">section_Cross</code>, <code class="literal">section_Curve</code>, <code class="literal">section_End</code>, <code class="literal">section_Straight</code>, and <code class="literal">section_T</code>. With the environment meshes selected, adjust the following settings:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Set the mesh <span class="strong"><strong>Scale Factor</strong></span> to <code class="literal">1</code>, creating a 1:1 ratio between the model, as it was made in the modeling software, to how the model appears in Unity.</p></li><li style="list-style-type: disc"><p>Disable <span class="strong"><strong>Import BlendShapes</strong></span>. The environment meshes contain no blended shapes to import, and you can streamline to import and re-import process by disabling unnecessary options.</p></li><li style="list-style-type: disc"><p>Disable <span class="strong"><strong>Generate Colliders</strong></span>. In many cases, we'd have enabled this setting. However, Dead Keys is a first-person shooter with a fixed, AI controlled camera, as opposed to free roam movement. This leaves the player with no possibility of walking through walls or passing through floors.</p></li><li style="list-style-type: disc"><p>Enable <span class="strong"><strong>Generate Lightmap UVs</strong></span>. Enabling this option generates a second UV channel. Unity automatically unwraps your meshes and guarantees no UV island overlap. You can further tweak light map UV generation using the <span class="strong"><strong>Hard Angle</strong></span>, <span class="strong"><strong>Pack Margin</strong></span>, <span class="strong"><strong>Angle </strong></span>
<span class="strong"><strong>Error</strong></span>, and <span class="strong"><strong>Area </strong></span>
<span class="strong"><strong>Error</strong></span> settings. However, the default settings work well for most purposes. The <span class="strong"><strong>Pack Margin</strong></span> can, and perhaps should, be increased if your light map Resolution is low, as we'll see in the next chapter. The angle and error settings should sometimes be increased or decreased to better accommodate light maps for organic and curved surfaces.</p></li></ul></div><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_029.jpg" /></div><p>
</p><p>Configuring Environment Meshes</p><p>In addition to configuring the primary mesh properties, as we've seen, let's also switch to the <span class="strong"><strong>Rig</strong></span> and <span class="strong"><strong>Animations</strong></span> tab. From the <span class="strong"><strong>Rig</strong></span> tab, specify <span class="strong"><strong>None</strong></span> for the <span class="strong"><strong>Animation Type </strong></span>field, as the meshes don't contain animation data.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_030.jpg" /></div><p>
</p><p>Setting the Rig type for environment meshes</p><p>Next, switch to the <span class="strong"><strong>Animations</strong></span> tab. From here, remove the check mark from <span class="strong"><strong>Import Animation</strong></span>. The environment meshes have no animations to import; then, click on <span class="strong"><strong>Apply:</strong></span>
</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_031.jpg" /></div><p>
</p><p>Disabling Import Animation</p><p>Of course, <span class="emphasis"><em>Dead Keys</em></span> is about completing typing exercises to destroy zombies. The zombie character for our project is based on the public domain zombie character, available from <span class="emphasis"><em>Blend Swap</em></span> at <a class="ulink" href="http://www.blendswap.com/blends/view/76443" target="_blank">http://www.blendswap.com/blends/view/76443</a>. This character has been rigged and configured in Blender for easy import to Unity. Let's configure this character now. Select the <span class="strong"><strong>Zombie</strong></span> mesh in the <span class="strong"><strong>Project</strong></span> panel; and from the object <span class="strong"><strong>Inspector</strong></span>, adjust the following settings:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Set the Mesh <span class="strong"><strong>Scale Factor</strong></span> to 1, to retain its original size.</p></li><li style="list-style-type: disc"><p>Enable <span class="strong"><strong>Import BlendShapes</strong></span>, to allow for custom vertex animation.</p></li><li style="list-style-type: disc"><p>Disable <span class="strong"><strong>Generate Colliders</strong></span>, as collision detection is not needed.</p></li><li style="list-style-type: disc"><p>Enable <span class="strong"><strong>Swap UVs</strong></span> if the texture doesn't look correct on the zombie model from the preview panel. If an object has two or more UV channels (and they sometimes do), Unity occasionally selects the wrong channel by default.</p></li></ul></div><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_032.jpg" /></div><p>
</p><p>Configuring a zombie NPC</p><p>Switch to the Animations tab, and disable the <span class="strong"><strong>Import </strong></span>Animation checkbox. The character mesh should, and will, be animated-performing actions such as walking and attacking animations. However, the character mesh file itself contains no animation data. All character animations will be applied to the mesh from other files.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_033-e1483083928125.jpg" /></div><p>
</p><p>Disable Import Animation for the zombie NPC</p><p>That's great! Now, let's configure the character rig for Mecanim. This is about optimizing the underlying skeleton to allow the model to be animated. To do this, select the <span class="strong"><strong>Rig </strong></span>tab from the <span class="strong"><strong>Inspector</strong></span> object. For the <span class="strong"><strong>Animation Type</strong></span>, choose <span class="strong"><strong>Humanoid</strong></span>; and for <span class="strong"><strong>Avatar Definition</strong></span>, choose <span class="strong"><strong>Create From This Model</strong></span>. The <span class="strong"><strong>Humanoid</strong></span> animation type instructs Unity to see the mesh as a standard bipedal human-a character with a head, torso, two arms, and two legs. This generic structure (as defined in the avatar) is mapped to the mesh bones and allows <span class="strong"><strong>Animation Retargeting</strong></span>. Animation Retargeting is the ability to use and reuse character animations from other files and other models across any humanoid.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_034.jpg" /></div><p>
</p><p>Configuring the zombie rig</p><p>After clicking on the Apply button for the zombie character, a check mark icon appears next to the <span class="strong"><strong>Configure...</strong></span> button. For some character meshes, a <span class="strong"><strong>X</strong></span> icon may appear instead. A check mark signifies that Unity has scanned through all bones in the mesh and successfully identified a humanoid rig, which can be mapped easily to the avatar. An <span class="strong"><strong>X</strong></span> icon signifies a problem, which can be either minor or major. A minor case is where a humanoid character rig is imported, but differs in subtle and important ways from what Unity expects. This scenario is often fixed manually in Unity, using the <span class="strong"><strong>Rig Configuration Window </strong></span>(available by clicking on <span class="strong"><strong>Configure...</strong></span>). In contrast, the problem could be major; for example, the imported mesh may not be humanoid at all, or else it differs so dramatically from anything expected that a radical change and overhaul must be made to the character from within the content creation software.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_035.jpg" /></div><p>
</p><p>Character rig successfully configured</p><p>Even when your character rig is imported successfully, you should still test it inside the <span class="strong"><strong>Rig Configuration Editor</strong></span>. This acts as a <span class="emphasis"><em>sanity check</em></span> and confirms that your rig is working as intended. To do this, click on the <span class="strong"><strong>Configure...</strong></span> button from the <span class="strong"><strong>Rig</strong></span> tab in the object <span class="strong"><strong>Inspector;</strong></span> this displays the Rig Configuration Editor:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_036.jpg" /></div><p>
</p><p>Using the Rig Configuration Editor to examine, test, and repair a skeleton avatar mapping</p><p>From the Rig Configuration Editor, you can see how imported bones map to the humanoid avatar definition. Bones highlighted in green are already mapped to the Avatar, as shown in the <span class="strong"><strong>Inspector</strong></span> object. That is, imported bones turn green when Unity, after analysis, finds a match for them in the Avatar. The Avatar is simply a map or chart defined by Unity, namely, a collection of predetermined bones. The aim of the Rig Configuration Editor is to simply map the bones from the mesh to the avatar, allowing the mesh to be animated by any kind of humanoid animation.</p><p>For the zombie character, all bones will be successfully auto-mapped to the avatar. You can change this mapping, however, simply by dragging and dropping specific bones from the <span class="strong"><strong>Hierarchy</strong></span> panel to the bone slots in the <span class="strong"><strong>Inspector</strong></span> object.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_037.jpg" /></div><p>
</p><p>Defining avatar mappings</p><p>Now, let's stress test our character mesh, checking its bone and avatar mapping and make sure that the character deforms as intended. To do this, switch to the <span class="strong"><strong>Muscles &amp; Settings</strong></span> tab from the <span class="strong"><strong>Inspector</strong></span> object. When you do this, the character's pose changes immediately inside the viewport, which means it is ready for testing.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_038.jpg" /></div><p>
</p><p>Testing bone mappings</p><p>From here, use the character pose sliders in the Inspector object to push the character into extreme poses, previewing its posture in the viewport. The idea is to preview how the character deforms and responds to extremes. The reason such testing is necessary at all is that although bipedal humanoids share a common skeletal structure, they differ widely in body types and heights-some being short and small, and some being large and tall.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_039.jpg" /></div><p>
</p><p>Testing extreme poses</p><p>If you feel your character breaks, intersects, or distorts in extreme poses, you can configure the mesh deformation limits, specifying a minimum and maximum range. To do this, first expand the <span class="strong"><strong>Per-Muscle Settings</strong></span> group for the limbs or bones that are problematic, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_040.jpg" /></div><p>
</p><p>Defining pose extremes</p><p>Then, you can drag and resize the minimum and maximum thumb-sliders to define the minimum and maximum deformation extents for that limb, and for all limbs where needed. These settings constrain the movement and rotation of limbs, preventing them from being pushed beyond their intended limits during animation. The best way to use this tool is to begin with your character in an extreme pose that causes a visible break, and then to refine the <span class="strong"><strong>Per-Muscle Settings</strong></span> until the mesh is repaired.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_041.jpg" /></div><p>
</p><p>Correcting pose breaks</p><p>When you're done making changes to the rig and pose, remember to click on the <span class="strong"><strong>Apply</strong></span> or <span class="strong"><strong>Done</strong></span> button from the <span class="strong"><strong>Inspector</strong></span> object. The <span class="strong"><strong>Done</strong></span> button simply applies the changes and then closes the Rig Configuration Editor.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_042.jpg" /></div><p>
</p><p>Applying rig changes</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec22"></a>Importing animations</h3></div></div></div><p>The Dead Keys game features character animations for the zombies, namely walk, fight, and idle. These are included as FBX files. They can be imported into the <code class="literal">Animations</code> folder. The animations themselves are not intended for or targeted toward the zombies, but Mecanim's Humanoid Retargeting lets us reuse almost any character animations on any humanoid model. Let's now configure the animations. Select each animation, and switch to the <span class="strong"><strong>Rig</strong></span> tab. Choose <span class="strong"><strong>Humanoid</strong></span> for the <span class="strong"><strong>Animation Type</strong></span>, and leave the <span class="strong"><strong>Avatar Definition </strong></span>at <span class="strong"><strong>Create From This Model</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_043.jpg" /></div><p>
</p><p>Specifying a Humanoid animation type for animations</p><p>Now, move to the Animations tab. Enable the <span class="strong"><strong>Loop Time</strong></span> checkbox, to enable animation looping for the clip. Then, click on <span class="strong"><strong>Apply</strong></span>. We'll have good cause to return to the animation settings in later chapters, for further refinement, as we'll see.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_044.jpg" /></div><p>
</p><p>Enabling animation Loop Time for repeating animation clips</p><p>Now, let's explore a common problem with loopable walk animations that have root motion encoded. Root motion refers to the highest-level transformation applied to an animated model. Most bone-based animation applies to lower-level bones in the bone hierarchy (such as arms, legs, and head), and this animation is always measured relative to the top-most parent. </p><p>However, when the root bone is animated, it affects a character's position and orientation in world space. This is known as root motion. One problem that sometimes happens with imported, loopable walk animations is a small deviation or offset away from the neutral starting point in its root motion. This causes a mesh to drift away from its starting orientation over time, especially when the animation is played on a loop. To see this issue in action, select the walk animation for the zombie character, and from the object <span class="strong"><strong>Inspector</strong></span>, preview the animation carefully. As you do this, align your camera view in the preview window in front of the humanoid character and see how, gradually, his walk deviates slowly from the center line on which he begins. This shows that, over time, the character continually drifts. This problem will not just manifest in the preview window, but in-game too!</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_045.jpg" /></div><p>
</p><p>Previewing walk cycle issues</p><p>This problem happens as a result of walk-cycle inaccuracies in root motion. By previewing the <span class="strong"><strong>Average Velocity</strong></span> field from the object <span class="strong"><strong>Inspector</strong></span>, you'll see the <span class="strong"><strong>X</strong></span> motion field is a nonzero value, meaning that offset occurs to the mesh in <span class="strong"><strong>X</strong></span>. This explains the accumulative deviation in the walk, as the animation is repeated.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_046.jpg" /></div><p>
</p><p>Exploring root motion problems</p><p>To fix this problem, enable the <span class="strong"><strong>Bake Into Pose</strong></span> checkbox for the <span class="strong"><strong>Root Transform Rotation </strong></span>section. This lets you override the <span class="strong"><strong>Average Velocity</strong></span> field. Then, adjust the <span class="strong"><strong>Offset</strong></span> field to compensate for the value of <span class="strong"><strong>Average Velocity</strong></span>. The idea is to adjust <span class="strong"><strong>Offset</strong></span> until the value of <span class="strong"><strong>Average Velocity </strong></span>is reset to <span class="strong"><strong>0</strong></span>, indicating no offsetting. Then, click on <span class="strong"><strong>Apply</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_047.jpg" /></div><p>
</p><p>Correcting root motion</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec23"></a>Importing audio</h3></div></div></div><p>Let's import game audio-specifically, the music track. This should be dragged and dropped into the <code class="literal">music</code> folder (the music track <code class="literal">narrow_corridors_short.ogg</code> is included in the book's companion files). Music is an important audio asset that greatly impacts loading times, especially on mobile devices and legacy hardware. Music tracks often exceed one minute in duration, and they encode a lot of data. Consequently, additional configuration is usually needed for music tracks, to prevent them from burdening your games.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_048.jpg" /></div><p>
</p><p>Importing audio files</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip7"></a>Tip</h3><p>Ideally, music should be in a WAV format, to prevent lossy compression when ported to other platforms. If WAV is not possible, then OGG is another valuable alternative. For more information on audio import settings, refer to the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/AudioFiles.html" target="_blank">http://docs.unity3d.com/Manual/AudioFiles.html</a>.</p></div><p>Now, select the imported music track in the Project panel. Disable the <span class="strong"><strong>Preload Audio Data</strong></span> checkbox, and then change the <span class="strong"><strong>Load Type</strong></span> to <span class="strong"><strong>Steaming</strong></span>. This optimizes the music loading process. It means the music track will be loaded in segments during playback, as opposed to entirely in memory from the level beginning, and it will continually load, segment by segment. This prevents longer initial loading times.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_049.jpg" /></div><p>
</p><p>Configuring music for streaming</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec24"></a>Configuring materials</h3></div></div></div><p>As a final step, let's configure mesh materials for the modular environment. By default, these are created and configured automatically by Unity on importing your meshes to the <span class="strong"><strong>Project</strong></span> panel. They'll usually be added to a materials subfolder, alongside your mesh. From here, drag and drop your materials to the higher-level materials folder in the project, organizing your materials together. Don't worry about moving your materials around for organization purposes, Unity will keep track of any references and links to objects.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_050.jpg" /></div><p>
</p><p>Configuring materials</p><p>By default, the <span class="strong"><strong>DiffuseBase</strong></span> material for the modular environment is configured as a standard shader material, with some degree of glossiness. This makes the environment look shinier and smoother than it should be. In addition, the material lacks a Normal Map and Ambient Occlusion map. To configure the material, select the <span class="strong"><strong>DiffuseBase</strong></span> material, and set the <span class="strong"><strong>Shader</strong></span> type to <span class="strong"><strong>Standard (Specular setup):</strong></span>
</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_051.jpg" /></div><p>
</p><p>Changing Shader type</p><p>Next, assign the <span class="strong"><strong>DiffuseBase </strong></span>texture to the <span class="strong"><strong>Albedo</strong></span> slot (the main diffuse texture), and complete the <span class="strong"><strong>Normal Map</strong></span> and Ambient <span class="strong"><strong>Occlusion</strong></span> fields by assigning the appropriate textures, as found in the <code class="literal">textures</code> folder:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_01_052.jpg" /></div><p>
</p><p>Completing the environment material</p></div></div>