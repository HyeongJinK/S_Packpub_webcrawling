<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec32"></a>Navigator GUI</h2></div></div><hr /></div><p>Let's now start work on the UI for <span class="emphasis"><em>Dead Keys</em></span>, which covers a broad range of important subjects. As mentioned, the main interesting area of the UI here is the forward pointing UI arrow (navigator button), which should appear after all zombies are killed and allows the player to continue on their journey through the environment, moving to the next ambush point. As we create this, we'll explore many interesting UI tips and tricks.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_040.jpg" /></div><p>
</p><p>Navigator button</p><p>First, let's create a new empty object to contain all UI elements, including the navigator button to be added in this section, and the remaining elements for later. In addition, add this object to the UI layer in the scene using the object <span class="strong"><strong>Inspector</strong></span>. In general, strive to keep all UI elements on the UI layer, or another dedicated layer that's separate from the non-UI objects. Doing this gives the power and flexibility to easily show and hide UI elements, as well as delegate their rendering to specific cameras.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_041.jpg" /></div><p>
</p><p>Assigning an object to the UI layer</p><p>Next, create an UI canvas object. The canvas is a special UI object which acts as a surface or layer onto which UI elements may be rendered to cameras. As you create the canvas in the scene, assuming this is your first UI object, Unity automatically creates an <span class="strong"><strong>EventSystem</strong></span> in the hierarchy. This object is essential for linking the UI to input, allowing UI objects to detect keyboard, click and tap input events. If your scene doesn't have an <span class="strong"><strong>EventSystem</strong></span>, you can always create one manually, by choosing <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Event System</strong></span> from the application menu.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_042.jpg" /></div><p>
</p><p>Assigning an object to the UI layer</p><p>The <span class="strong"><strong>EventSystem</strong></span> features two notable components: an <span class="strong"><strong>Event System</strong></span> component, and an input module. The <span class="strong"><strong>EventSystem</strong></span> is the nerve center for events and its main duty is to match up abstracted player input (from the input module) to specific objects and events in the scene, like button clicks on UI buttons. The input module is responsible for mapping hardware specific input into a generalized abstracted input that the <span class="strong"><strong>EventSystem</strong></span> uses for firing events. There are several kinds of input module components and each varies to accommodate specific hardware types. These are <span class="strong"><strong>Standalone Input Module</strong></span> (for handling keyboard and mouse input from desktop systems), and touch input modules, for mobile devices like phones and tablets.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_043.jpg" /></div><p>
</p><p>EventSystems with input modules</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec39"></a>Input axes</h3></div></div></div><p>The input module features several named Axes. An input axis is a named, linear space that maps to an input device and typically generates normalized values when input events are received. For example, the horizontal axis, by default, maps to the left and right keys on the keyboard. Left corresponds to <code class="literal">-1</code>, right corresponds to <code class="literal">1</code>, and pressing nothing corresponds to the neutral <code class="literal">0</code>. This convention is especially convenient for creating movement scripts with vectors. Other input Axes are officially buttons, which have an on and off (Boolean) status instead. The named input Axes can be accessed, edited, and configured from within the Unity editor, by choosing Edit | <span class="strong"><strong>Project Settings</strong></span> | Input from the application menu.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_044.jpg" /></div><p>
</p><p>Accessing input Axes</p><p>Using the Axes menu from the object <span class="strong"><strong>Inspector</strong></span>, you can customize input mappings. That is, you change how keyboard, mouse, touch, and gamepad controls relate to the input axis and generated values. You can add additional input Axes with any name and configure them to specific controls (like mouse presses and keyboard events), and you can even add multiple Axes with the same name, mapping them to different controls. This is useful when you need two key assignments to perform the same action in-game; for example, <span class="emphasis"><em>WASD</em></span> and keyboard arrows both mapping to horizontal and vertical Axes controlling character movement.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_045.jpg" /></div><p>
</p><p>Configuring input Axes</p><p>For <span class="emphasis"><em>Dead Keys</em></span>, the default controls may be left as is; they work as intended. Be careful not to delete the default Axes, as this can invalidate many standard asset packages that ship with Unity, causing problems with your game.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_046.jpg" /></div><p>
</p><p>Duplicating input Axes</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec40"></a>The canvas</h3></div></div></div><p>On creating a canvas object, you can now build a user interface. First, let's fix the resolution of our game to 16:9 from the <span class="strong"><strong>Game</strong></span> tab. This will be important for previewing the UI in screen space at an appropriate aspect ratio. To do this, switch to the <span class="strong"><strong>Game</strong></span> tab and choose <span class="strong"><strong>16:9</strong></span> as the screen aspect ratio.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_047.jpg" /></div><p>
</p><p>Setting aspect ratio</p><p>Now, select the canvas object. From the object <span class="strong"><strong>Inspector</strong></span>, set the <span class="strong"><strong>Render Mode</strong></span> to <span class="strong"><strong>Screen Space - Overlay</strong></span>, via the <span class="strong"><strong>Canvas</strong></span> component, if this mode is not already selected. In this mode, the UI on the selected canvas appears on top of everything, literally. It is the highest rendered object and needs no camera for its rendering. Thus, all cameras could, in theory, be deleted from the scene and still our canvas object would render if it were visible. This can be both beneficial and problematic. Beneficial because we don't need any additional scene cameras to render the UI; but sometimes problematic because we lack control over depth sorting of objects. For example, if we want to fade-out the screen using a black overlay, or obscure the UI with other objects or stencils, then we'd need to use a different render mode.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_048.jpg" /></div><p>
</p><p>Changing canvas Render Mode</p><p>Next, let's focus on the <span class="strong"><strong>Canvas Scaler</strong></span> component, which can be especially important for resizing your UI to fit different resolutions and devices. Change the <span class="strong"><strong>UI Scale Mode</strong></span> to <span class="strong"><strong>Scale with Screen Size</strong></span>. This property can be one of three modes, discussed here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Constant Pixel Size</strong></span>: This ensures that UI textures all display on screen at their pixel-accurate sizes, in both width and height. Thus, a texture of <span class="emphasis"><em>100x100</em></span> pixels will consume that many pixels in each dimension, regardless of screen size. This means that higher resolutions (with more pixels) can make your textures look smaller, as they remain at their original size.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Scale With Screen Size</strong></span>: This proportionally stretches or shrinks the width and height of UI textures according to the screen resolution. If the resolution increases, the textures increase in size proportionally, and so on. This mode can be useful for resizing UI elements for different resolutions, but it can cause stretching or pixelation when stretched to a differing aspect ratio or to a much higher or lower resolution than the original.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Constant Physical Size</strong></span>: In this mode, the UI textures retain their sizes based on measurements other than pixels. Valid forms of measure include: points, centimeters, millimeters, inches, and picas.</p></li></ul></div><p>After choosing <span class="strong"><strong>Scale With Screen Size</strong></span>, set the <span class="strong"><strong>Reference Resolution</strong></span> to <span class="emphasis"><em>1920x1080</em></span>. This specifies the default resolution - or more accurately, the resolution at which the UI was designed. It may be displayed at runtime at potentially many resolutions, both higher and lower, but it will have been designed at a specific, native resolution. This is the <span class="strong"><strong>Reference Resolution</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_049.jpg" /></div><p>
</p><p>Changing the Reference Resolution</p><p>Make sure the canvas object has a <span class="strong"><strong>Graphic Raycaster</strong></span> component. This ensures that touch and keyboard input, from the input module, is dispatched to graphical elements in the UI as events, which are sent to the appropriate objects. In short, without this module, all input (clicks, tabs, and key presses) will be ignored for UI objects on this canvas.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_050.jpg" /></div><p>
</p><p>Enabling the Graphics Raycaster</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>Remember, the canvas object should be attached to the UI layer.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec41"></a>The button</h3></div></div></div><p>The canvas object is now properly configured for a multi-resolution setup. Due to the <span class="strong"><strong>Canvas Scaler</strong></span> component, it can be resized automatically to fit many resolutions and devices, from desktop computers to mobile devices. However, the canvas object right now has no controls or widgets on it; buttons, or images, or text edits, and so on. Specifically, we need to add the forward button. To do this, select the canvas object in the hierarchy panel, and right-click. From the context menu, choose <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Button</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_051.jpg" /></div><p>
</p><p>Adding the UI button</p><p>All newly added buttons appear as a default, white button, which should be clickable. When adding your first interactive object, however, it's a good idea to test-play your game, moving your mouse cursor over the button to confirm that it responds by changing appearance - detecting input. If it doesn't, then you should check your <code class="literal">EventSystem</code> setup and the <span class="strong"><strong>Graphic Raycaster</strong></span> component on the canvas object.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_052.jpg" /></div><p>
</p><p>Adding a forwards button</p><p>Assuming the default button works as intended (that is, responds to user input), we're ready to customize its appearance. To do that, select the button and, from the object <span class="strong"><strong>Inspector</strong></span>, drag and drop your button texture into the <span class="strong"><strong>Source Image</strong></span> field of the <span class="strong"><strong>Image</strong></span> component.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_053.jpg" /></div><p>
</p><p>Customizing button appearance</p><p>Normally, the reconfigured <span class="strong"><strong>Source Image</strong></span> field leaves the button distorted and wrongly sized. You can correct this easily by clicking the <span class="strong"><strong>Set Native Size</strong></span> button from the object <span class="strong"><strong>Inspector</strong></span>. This returns the button to its native size, combined with the settings of the <span class="strong"><strong>Canvas Scaler</strong></span> component.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_054.jpg" /></div><p>
</p><p>Setting a button to native size</p><p>In addition to configuring button size, its position should also be carefully defined. Although the newly created button happens (in this case) to be at the screen center, in the appropriate place, your buttons may not always be aligned like that. You can use the transformation tools (move, rotate, and scale) to move the objects into place on screen, but if the screen resolution and aspect ratio change at runtime, it's possible for the button to <span class="emphasis"><em>slip out of place</em></span> and even (potentially) out of the screen. To solve this problem, we can use anchors to fix the object in place. To do this, click the anchor button from the <span class="strong"><strong>Rect Transform</strong></span> component in the object <span class="strong"><strong>Inspector</strong></span> to view a selection of anchor presets.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_055.jpg" /></div><p>
</p><p>Choosing an anchor point</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"></a>Note</h3><p>
<span class="strong"><strong>Rect Transform</strong></span> is the 2D, UI equivalent of the transform component. More information on <span class="strong"><strong>Rect Transform</strong></span> can be found in the online Unity documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/class-RectTransform.html" target="_blank">https://docs.unity3d.com/Manual/class-RectTransform.html</a>.</p></div><p>Each UI object has four anchor points, one at each corner. These points can be locked (anchored) to known screen locations, which all screens have (namely, top-left, top-right, bottom-right, bottom-left, center, middle-left, middle-right, middle-top, and middle-bottom). The anchors therefore align the edges of a UI element in line with specific screen edges so that, if the screen is resized, the element may move or change (if needed) except for the edges where it is anchored. Thus, by centering the button at the screen-center, we lock the button position and it will always be at the center for every resolution and every aspect ratio.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_056.jpg" /></div><p>
</p><p>Centering the anchor</p><p>In addition to the anchor, each UI element has a pivot point, as specified in normalized coordinates. The pivot point represents the coordinate center of an object (its center of rotation); the position within a UI rectangle that actually moves to the specified X, Y, and Z position in world space when an object is translated. The <span class="strong"><strong>Pivot</strong></span> for the forwards button should be its center. In normalized coordinates, this is <span class="emphasis"><em>0.5 x 0.5</em></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_057.jpg" /></div><p>
</p><p>Centering the pivot point</p><p>Finally, let's tag the button appropriately, as we'll use this soon from script. Select the button object on the canvas and assign it a <span class="strong"><strong>NavigatorButton</strong></span> tag via the object <span class="strong"><strong>Inspector</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_058.jpg" /></div><p>
</p><p>Assigning a tag to the navigator button</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec42"></a>Coding button behavior</h3></div></div></div><p>Now, we'll link button clicks to the <code class="literal">Navigator</code> class for moving the camera forward. First, let's refine the <code class="literal">Navigator</code> class, which we started earlier, to support camera movement from the animator graph. The latest code for this class appears as follows:</p><pre class="programlisting">//------------------------------------ 
using UnityEngine; 
using System.Collections; 
using UnityEngine.UI; 
using UnityEngine.EventSystems; 
using UnityEngine.Events; 
//------------------------------------ 
public class Navigator : MonoBehaviour 
{ 
    //------------------------------------ 
//Reference to current camera position 
    public int CurrentNode = 0; 
    private Animator ThisAnimator = null; 
    private int AnimStateHash = Animator.StringToHash("NavState"); 
 
    //Reference to navigator button 
    private Button NavigatorButton = null; 
 
    //Reference to singleton instance 
    public static Navigator ThisInstance 
    { 
        get 
        { 
            //Get or create singleton instance 
            if (mThisInstance == null) 
            { 
                GameObject GO = new GameObject ("Navigator"); 
                mThisInstance = GO.AddComponent&lt;Navigator&gt; (); 
            } 
 
            return mThisInstance; 
        } 
 
        set  
        { 
            //If not null then we already have instance 
            if (mThisInstance != null)  
            { 
                //If different, then remove duplicate immediately 
                if(mThisInstance.GetInstanceID() != value.GetInstanceID()) 
                    DestroyImmediate (value.gameObject); 
 
                return; 
            } 
 
            //If new, then create new singleton instance 
            mThisInstance = value; 
        } 
    } 
 
    private static Navigator mThisInstance = null; 
    //------------------------------------ 
    void Awake() 
    { 
        ThisInstance = this; 
        ThisAnimator = GetComponent&lt;Animator&gt; (); 
        NavigatorButton = GameObject.FindGameObjectWithTag ("NavigatorButton").GetComponent&lt;Button&gt;(); 
    } 
    //------------------------------------ 
    public void Next() 
    { 
        ++CurrentNode; 
        ThisAnimator.SetInteger (AnimStateHash, CurrentNode); 
    } 
    //------------------------------------ 
    public void Prev() 
    { 
        --CurrentNode; 
        ThisAnimator.SetInteger (AnimStateHash, CurrentNode); 
    } 
    //------------------------------------ 
    //Show button if there are no remaining enemies 
    public void ShowMoveButton() 
    { 
         //To be defined 
 
        NavigatorButton.gameObject.SetActive (true); 
    } 
    //------------------------------------ 
} 
//------------------------------------  
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec43"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">CurrentNode</code> variable is an integer representing the progress of the camera through the animator graph and through the scene. It corresponds directly to the <code class="literal">NavState</code> parameter.</p></li><li style="list-style-type: disc"><p>This <code class="literal">NavigatorButton</code> variable maintains a reference to the UI button on the canvas. This reference is retrieved in the <code class="literal">Awake</code> function using the <code class="literal">FindGameObjectWithTag</code> method. Thus, the UI navigator button is required to have an appropriate tag.</p></li><li style="list-style-type: disc"><p>The <code class="literal">Next</code> and <code class="literal">Prev</code> methods are responsible for incrementing and decrementing the <code class="literal">CurrentNode</code> variable and then for updating the <code class="literal">NavState</code> parameter in the graph. Once updated, Mecanim automatically fires any relevant nodes in the graph.</p></li></ul></div><p>Select the canvas button object in the scene and, from the object <span class="strong"><strong>Inspector</strong></span>, scroll to the <span class="strong"><strong>OnClick()</strong></span> section of the <span class="strong"><strong>Button</strong></span> component. Here, you can <span class="strong"><strong>visually script</strong></span> what should occur when the button is pressed. Click the <span class="strong"><strong>+</strong></span> icon to add a new entry for the event.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_059.jpg" /></div><p>
</p><p>Adding a new action to the OnClick event</p><p>Next, click and drag the navigator object from the <span class="strong"><strong>Hierarchy</strong></span> panel into the target slot, identifying the object with a component whose function we should run when the button is clicked. Select the <span class="strong"><strong>Navigator</strong></span> component and choose the <span class="strong"><strong>Next</strong></span> function. This means that <span class="strong"><strong>Next()</strong></span> will execute as the button is pressed, driving the camera forward to the next location on each increment.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_060.jpg" /></div><p>
</p><p>Choosing the Next function as the button's action</p><p>The navigator button is now configured to run the <code class="literal">Next</code> function on the navigator object when clicked. This moves the camera forward. Right now, the button remains visible even when the camera is travelling, but for test purposes this is acceptable. In the next chapter, we'll be refining the controls even further.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_061.jpg" /></div><p>
</p><p>Using the navigator button</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec44"></a>Creating player death</h3></div></div></div><p>In addition to building a player camera that moves from point to point, let's also establish a death animation which will feature in the Mecanim graph. With the death animation, the camera simply falls to the floor and rolls over, and this can interrupt gameplay at any time. The death animation will, of course, occur when the player is killed by a danger in the scene, such as a zombie attack. To get started on creating this, select the navigator object, then add a new animation from the <span class="strong"><strong>Animation</strong></span>
<span class="emphasis"><em> </em></span>window by clicking <span class="strong"><strong>Create New Clip</strong></span>. Create a new animation clip called <code class="literal">anim_Die</code>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_062.jpg" /></div><p>
</p><p>Creating a new animation clip (anim_Die)</p><p>Creating this clip involves a challenge concerning object transformation. Specifically, the death animation may potentially occur anywhere in the scene, at the beginning, middle, end, or elsewhere. That is, the world position (X, Y, Z) at which death can occur is undefined; it could be anywhere. Consequently, we cannot animate for death at the root level of the navigator object because its position values are baked into the animation in world space. If we created a death sequence on the navigator object, as death occurs, the camera will always snap to a single, specified position, as this is coded into the animation. To fix this, we'll use a relative transformation. That is, we'll animate a child object of the navigator - namely the <span class="strong"><strong>Player</strong></span> object. To do this, click the <span class="strong"><strong>Add Property</strong></span> button from the <span class="strong"><strong>Animation</strong></span> window and, instead of selecting the <span class="strong"><strong>Transform</strong></span> component (which applies to the navigator object), choose the <span class="strong"><strong>Player</strong></span> child object, then select its <span class="strong"><strong>Transform</strong></span> component, both position and rotation.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_063.jpg" /></div><p>
</p><p>Selecting the Player Transform component</p><p>This adds an animation track for both the position and rotation keys for the player object, which is a child of the navigator. This ensures that, wherever the navigator moves, the death animation (when played) will be run as a relative offset from the player position, allowing the player to <span class="emphasis"><em>die anywhere</em></span>. Now animate the camera to a falling position over time, using the <span class="strong"><strong>Animation</strong></span> window to create the death animation.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_064.jpg" /></div><p>
</p><p>Creating a death animation</p><p>Great! The death animation is now created. Let's connect that to the animator graph to mix with the existing nodes. The final node graph looks as follows, featuring all major states and stopping points in the scene:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_03_065.jpg" /></div><p>
</p><p>The camera node graph</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec45"></a>Comments</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The graph consists of four travel nodes linked in a sequence, and one death node.</p></li><li style="list-style-type: disc"><p>Transitions between travel nodes is controlled via the integer <code class="literal">NavState</code> parameter.</p></li><li style="list-style-type: disc"><p>The death animation is trigged by the die trigger parameter.</p></li><li style="list-style-type: disc"><p>All travel nodes have the potential to lead to the death animation node. The death animation node has no outward connections, since death is a one-way trip.</p></li></ul></div></div></div>