<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec84"></a>Optimization tips and tricks</h2></div></div><hr /></div><p>The <span class="strong"><strong>Stats</strong></span> panel and the <span class="strong"><strong>Profiler</strong></span> are solid tools for diagnosing performance problems in your game, as well as determining where those problems are in the script, thereby suggesting how they may be corrected. However, as mentioned, optimization should begin at the design phase of development, and should persist throughout all subsequent stages. Consequently, there are some general tips, tricks, and workflows that can be followed, with proper consideration and limitations, to help optimize your game across development, minimizing problems that could emerge later. This section explores some of these tips and tricks, in addition to those already mentioned in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Preparation and Asset-Configuring</em></span>. Let's see these...</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec75"></a>Strings and comparisons</h3></div></div></div><p>Working with strings in Unity is common. Game objects have names and tags, animations have parameters, and games feature many other string properties, including names, localization data, character dialogue, and more. Consequently, we often need to compare two strings, checking to see if two words match-such as searching for objects by name, or checking player-typed words against a dictionary. There are many ways to compare strings in code, but these vary in performance and speed-and the fastest method has not always remained constant across versions. As of Unity 5.5, the optimal method for comparing two strings for equality is as follows:</p><pre class="programlisting">StringOne.Equals(StringTwo, StringComparison.Ordinal); &#13;
</pre><p>The most important part of the preceding code is supplying <code class="literal">StringComparison.Ordinal</code> as a second argument. This ensures the string comparison is based only on upper and lower case versions within the same character set, and assumes the strings are within the same language.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec76"></a>Beware of functions in disguise</h3></div></div></div><p>C# properties are great language features for wrapping up access to variables through internal functions. This helps us validate values assigned to variables, and to detect when variables change. However, C# properties have a performance overhead that makes them expensive when compared to direct variable access. For this reason, to optimize script performance, always seek to cache variables. This problem is most notable in Unity when using <code class="literal">MonoBehaviour</code> class variables, or static class variables, which provide shortcut access to other components or objects. For example:</p><pre class="programlisting">transform.position = new Vector3(0,0,0); &#13;
</pre><p>Here, the <code class="literal">transform</code> variable provides syntax-quick access to the <code class="literal">Transform</code> component attached to the associated game object. However, <code class="literal">transform</code> is a C# property, which as a hidden function call is equivalent to the much slower <code class="literal">GetComponent&lt;Transform&gt;()</code> statement. For this reason, it is better to use the <code class="literal">Awake</code> event of a script to cache the <code class="literal">Transform</code> component to a class variable for quick access later. For example:</p><pre class="programlisting">   void Awake ()  &#13;
   { &#13;
         ThisTransform = GetComponent&lt;Transform&gt; (); &#13;
   } &#13;
</pre><p>By using this code, the <code class="literal">ThisTransform</code> variable should be used throughout to refer to the <code class="literal">Transform</code> component. Other variables that are really properties and that involve hidden function calls include:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">Camera.main</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">rigidbody</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">audio</code>
</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec77"></a>Debug cleaning</h3></div></div></div><p>Here's a great tip for cleaning your project and code of debug statements! We all use the <code class="literal">print</code> and <code class="literal">Debug.Log</code> functions to print debug messages to the console for validating our code and its execution. However, it's easy to add many debug statements, eventually spamming the console with many. And, furthermore, when the time comes to build our game, we normally want to remove all debug statements, to prevent our application from running code that isn't effective anymore. For example, consider the following statement:</p><pre class="programlisting">Debug.Log("Hello World"); &#13;
</pre><p>This code prints the following message to the console, which can be seen from the Unity editor, but not in a standalone build.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_012.jpg" /></div><p>
</p><p>Printing debug messages</p><p>It can be tedious having to remove every <code class="literal">Debug.Log</code> or <code class="literal">Print</code> statement from a final build. So, instead, you can use the <code class="literal">Conditional</code> C# attribute. Consider the following class, which is a <code class="literal">DebugManager</code>, used for printing debug messages:</p><pre class="programlisting">using System.Collections; &#13;
using System.Collections.Generic; &#13;
using UnityEngine; &#13;
using System.Diagnostics; //Namespace for conditional attribute &#13;
 &#13;
public class DebugManager : MonoBehaviour &#13;
{ &#13;
   //This function is only valid when the DEBUG_MANAGER directive is enabled &#13;
   [Conditional("DEBUG_MANAGER")] &#13;
   public static void PrintMessage(string Message) &#13;
   { &#13;
         //Prints a message to the console &#13;
         UnityEngine.Debug.Log (Message); &#13;
   } &#13;
} &#13;
</pre><p>This code uses the <code class="literal">System.Diagnostics</code> namespace to mark the <code class="literal">PrintMessage</code> function with the <code class="literal">Conditional</code> attribute. The function is tagged as <code class="literal">DEBUG_MANAGER</code>. This means that the <code class="literal">PrintMessage</code> function is only valid and compiled with the project when the <code class="literal">DEBUG_MANAGER</code> directive is activated in the <span class="strong"><strong>Player</strong></span> settings window. By default, this directive is not activated, and this means that both the <code class="literal">PrintMessage</code> function and any other lines that call this function are treated by the compiler as comments. Let's see that in action. First, check the player settings to make sure that the <code class="literal">DEBUG_MANAGER</code> directive is not specified. To do that, choose <span class="strong"><strong>Edit | Project Settings | Player</strong></span> from the application menu.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_013.jpg" /></div><p>
</p><p>Accessing the Player settings window</p><p>The <span class="strong"><strong>Player</strong></span> settings window displays a range of important game settings from the Object Inspector. Expand the <span class="strong"><strong>Other Settings</strong></span> tab, and scroll down to the <span class="strong"><strong>Scripting Define Symbols</strong></span> field. This field may be empty, or contain some symbols already defined. By default, the <code class="literal">DEBUG_MANAGER</code> symbol is missing.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_014.jpg" /></div><p>
</p><p>Viewing Scripting Define Symbols from the Player settings window</p><p>When the <code class="literal">DEBUG_MANAGER</code> define is missing, all lines referring to any function marked with the <code class="literal">Conditional</code> attribute will be turned into comments, effectively removing them from your script files.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_015.jpg" /></div><p>
</p><p>Debug code is turned into comments using the Conditional attribute</p><p>Now, add the <code class="literal">DEBUG_MANAGER</code> define into the symbols list from the <span class="strong"><strong>Player</strong></span> settings window. Each define should be separated with the semicolon symbol (<code class="literal">;</code>). Thus, the <code class="literal">DEBUG_MANAGER</code> define can be added, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_016.jpg" /></div><p>
</p><p>Adding the DEBUG_MANAGER define symbol</p><p>On adding the <code class="literal">DEBUG_MANAGER</code> define symbol, all code associated with the <code class="literal">Conditional</code> attribute will be activated automatically in code.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_017.jpg" /></div><p>
</p><p>Enabling Debug code!</p><p>And voila! You now have an easy way to activate and deactivate the debug code for your applications.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec78"></a>Optimizing build size</h3></div></div></div><p>On compiling your game into a standalone executable, whether it's for PC, Mac, or mobiles, you'll always want the build to be as slimline as possible. Ideally, the final build should contain only release-relevant code (stripped of debug statements), and only assets (meshes and textures) used in the game, and these should also be formatted and compressed optimally for the target platform. This ensures that the build runs efficiently for the target hardware and is as small in file size as possible. This is especially important for mobile games and for asset store uploading, as many asset stores place limitations on acceptable file sizes for downloadable games. For this reason, we'll need a way to control the build file size.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note57"></a>Note</h3><p>By default, Unity removes all unused assets during a build operation. It does not remove them from the <span class="strong"><strong>Project</strong></span> panel, but rather removes the assets from the compiled build so that they do not increase its file size. This does not apply to assets in the <code class="literal">Resources</code> folder. For more information on the <code class="literal">Resources</code> folder, see the online documentation at: <a class="ulink" href="https://docs.unity3d.com/Manual/Profiler.html" target="_blank">https://unity3d.com/learn/tutorials/topics/best-practices/resources-folder</a>.</p></div><p>To start optimizing a Build, it's good to assess how much of an impact each asset makes on the final build and where file size savings could be made. To do this, start by building your game. Select <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Build Settings</strong></span> from the application menu.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_018.jpg" /></div><p>
</p><p>Accessing the Build Settings...</p><p>From the <span class="strong"><strong>Build</strong></span> dialog, ensure that the correct <span class="strong"><strong>Build Target Platform</strong></span> is selected, such as Windows or Mac. If it's not, then select the platform from the platform list, and then choose the <span class="strong"><strong>Switch Platform</strong></span> button from the bottom-left button in the dialog.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_019.jpg" /></div><p>
</p><p>Selecting the Build Platform</p><p>Make sure all levels are added to the <span class="strong"><strong>Scenes in Build</strong></span> list, and then choose the <span class="strong"><strong>Build </strong></span>button from the dialog. This prompts you for a save location for the build. Choose a location on your computer, but avoid saving your build anywhere inside the Unity project folder. Saving the build inside the Unity project folder can result in errors that prevent your project from compiling.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_020.jpg" /></div><p>
</p><p>Building for the Target Platform</p><p>After the build completes, open the <span class="strong"><strong>Console </strong></span>window and click the context menu icon, from the top right-hand side of the console. From the context menu that appears, choose <span class="strong"><strong>Open Editor Log</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_021.jpg" /></div><p>
</p><p>Accessing the build log</p><p>By choosing <span class="strong"><strong>Open Editor Log</strong></span>, you can view the most recently generated build log, which is a text file produced by the compiler, indicating build statistics.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_022.jpg" /></div><p>
</p><p>Viewing the build log</p><p>The build log lists all assets included in the compiled build, as well as their final memory consumption (in MBs). Remember, the size of the asset file in the <span class="strong"><strong>Project</strong></span> panel (such as an imported PNG or Mesh file) is not necessarily how large the asset will be in the final build. This is because Unity uses its own internal asset storage system where the size of each imported asset is determined by its type, size, and import settings as defined in the object <span class="strong"><strong>Inspector</strong></span>. The build log lets you determine the compiled size of each asset, and can guide you as to where improvements could be made to reduce size.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_023.jpg" /></div><p>
</p><p>Assets sorted by size</p><p>One of the first strategies for reducing build size is to shrink textures, making them smaller in dimensions and in memory. This is especially effective for mobile platforms where textures are shown on smaller screens. To achieve this, select the texture in the <span class="strong"><strong>Project</strong></span> panel, and change the <span class="strong"><strong>Max Size</strong></span> setting to the smallest size consistent with your intended level of quality.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_024.jpg" /></div><p>
</p><p>Changing texture size</p><p>Disable <span class="strong"><strong>Generate Mip Maps</strong></span>, under the <span class="strong"><strong>Advanced</strong></span> tab, for UI textures and other menu or HUD items, as this can result in several versions of the same texture being produced for different quality settings based on camera viewing distance.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_025.jpg" /></div><p>
</p><p>Disabling Generate Mip Maps</p><p>You can also enable <span class="strong"><strong>Mesh Compression</strong></span> for meshes, which reduces their file size within the build, but at the expense of mesh quality. Higher compression produces lower fidelity meshes. Select the mesh in the <span class="strong"><strong>Project</strong></span> panel, and then select the compression type.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_026.jpg" /></div><p>
</p><p>Enabling Mesh Compression</p><p>If acceptable, you can try reducing the quality of audio files. Simply select an audio file from the <span class="strong"><strong>Project</strong></span> panel, and then reduce the <span class="strong"><strong>Quality</strong></span> slider. Be sure to click <span class="strong"><strong>Apply</strong></span> after adjusting the setting to confirm the change.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_027.jpg" /></div><p>
</p><p>Reducing audio quality</p><p>In addition to adjusting settings for specific assets, you can change the supported API level. This defines the .NET (Mono) library of functions and classes used by your application. Most games use only a small subset of the .NET framework in their scripts and, thus, can use a lighter version of the library. By using this, your games build to a smaller size. To use the smaller version, select <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span> from the application menu. This displays the <span class="strong"><strong>Player</strong></span> settings window in the object <span class="strong"><strong>Inspector</strong></span>.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_028.jpg" /></div><p>
</p><p>Editing Player Settings</p><p>From the <span class="strong"><strong>Player </strong></span>settings window, expand the <span class="strong"><strong>Other Settings</strong></span> group, and select <span class="strong"><strong>.NET 2.0 Subset</strong></span> from the <span class="strong"><strong>Api Compatibility Level </strong></span>dropdown menu.</p><p>
</p><div class="mediaobject"><img src="/graphics/9781785880742/graphics/image_08_029.jpg" /></div><p>
</p><p>Setting the API level</p></div></div>