<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec38"></a>Matching words</h2></div></div><hr /></div><p>Determining whether two words match is an important function for <span class="emphasis"><em>Dead Keys</em></span>. When a player enters a word during combat, we must ascertain several features of that word compared to the chosen one from the word list:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Complete word matches</strong></span>: A complete word match occurs when the player fully and correctly types the selected word, letter for letter. This results in a zombie being killed and is a measure of progress in the scene. Detecting complete word matches is therefore important for progressing gameplay.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Failed matches</strong></span>: A failed word match occurs when the player's most recent keypress fails to match any selected words (there could be multiple zombies) and therefore invalidates any partial matches there may have been up to that point. When a failed match occurs, the player's input is reset and they must retype the word from the first letter.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Partial word matches</strong></span>: A partial match occurs when the player is on their way to entering and completing a word but has yet to type every letter. Some letters will have been entered correctly, but there are additional letters outstanding to make a complete match. Detecting partial matches is important for two main reasons: it helps us identify which zombie the player is targeting, as each zombie represents a different word; and it lets us update the UI with appropriate feedback, indicating how much of the selected word has been matched so far, through color coded text or interface elements.</p></li></ul></div><p>The following function <code class="literal">CompareWords</code> should be added to the <code class="literal">WordList</code> class. Its return value indicates which of the three matches above is true.</p><pre class="programlisting">    //------------------------------------ &#13;
    //Compares two strings and returns the extent of a match &#13;
    //EG: s1="hello" and s2="helicopter" the result = "hel" &#13;
    public static string CompareWords(string s1, string s2) &#13;
    { &#13;
        //Build resulting string &#13;
        string Result = string.Empty; &#13;
 &#13;
        //Get shortest length &#13;
        int ShortestLength = Mathf.Min(s1.Length, s2.Length); &#13;
 &#13;
        //Check for string match &#13;
        for (int i = 0; i &lt; ShortestLength; i++) &#13;
        { &#13;
            if (s1 [i] != s2 [i]) &#13;
                return Result; &#13;
 &#13;
            Result += s1[i]; &#13;
        } &#13;
 &#13;
        //Output result &#13;
        return Result; &#13;
    } &#13;
    //------------------------------------  &#13;
</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec48"></a>Comments</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The <code class="literal">CompareWords</code> function accepts two string arguments for comparison.</p></li><li><p>The comparison proceeds by comparing letters for the length of the shortest string.</p></li><li><p>The return value is a string whose contents reflect the extent of a match. An empty string results i <span class="emphasis"><em>no match</em></span>, and either partial or complete strings are returned for partial or complete matches. Thus, the strings <code class="literal">hel</code> and <code class="literal">hello</code> return <code class="literal">hel</code>, and the strings <code class="literal">door</code> and <code class="literal">don't</code> return <code class="literal">do</code>. Thus, the function returns a new string defining a letter by letter match from the first letter onwards.</p></li></ol></div><p>That's it! We've created a <code class="literal">WordList</code> class. Let's see the full source code for that:</p><pre class="programlisting">//------------------------------------ &#13;
using UnityEngine; &#13;
using System.Collections; &#13;
using System.Collections.Generic; &#13;
//------------------------------------ &#13;
public class WordList : MonoBehaviour &#13;
{ &#13;
    //------------------------------------ &#13;
    //Text asset featuring word list &#13;
    public TextAsset FileWordList = null; &#13;
    public string[] Words; &#13;
 &#13;
    //Members for Singleton &#13;
    public static WordList ThisInstance &#13;
    { &#13;
        get &#13;
        { &#13;
            //Get or create singleton instance &#13;
            if (m_WL == null) &#13;
            { &#13;
                GameObject GO = new GameObject ("WordList"); &#13;
                ThisInstance = GO.AddComponent&lt;WordList&gt; (); &#13;
            } &#13;
 &#13;
            return m_WL; &#13;
        } &#13;
        set  &#13;
        { &#13;
            //If not null then we already have instance &#13;
            if (m_WL != null)  &#13;
            { &#13;
                //If different, then remove duplicate immediately &#13;
                if(m_WL.GetInstanceID() != value.GetInstanceID()) &#13;
                    DestroyImmediate (value.gameObject); &#13;
 &#13;
                return; &#13;
            } &#13;
 &#13;
            //If new, then create new singleton instance &#13;
            m_WL = value; &#13;
            DontDestroyOnLoad (m_WL.gameObject); &#13;
        } &#13;
    } &#13;
    private static WordList m_WL = null; &#13;
    //------------------------------------ &#13;
    // Use this for initialization &#13;
    void Awake ()  &#13;
    { &#13;
        //Set singleton instance &#13;
        ThisInstance = this; &#13;
 &#13;
        //Now load word list, if available &#13;
        if (FileWordList == null) &#13;
            FileWordList = (TextAsset) Resources.Load("WordList"); &#13;
         &#13;
        Words = FileWordList.text.Split (new[] { "\r\n" }, System.StringSplitOptions.None); &#13;
     &#13;
    } &#13;
    //------------------------------------ &#13;
    //Returns a random word from the word list &#13;
    public string GetRandomWord() &#13;
    { &#13;
        return Words[Random.Range(0, Words.Length)].ToLower(); &#13;
    } &#13;
    //------------------------------------ &#13;
    //Compares two strings and returns the extent of a match &#13;
    //EG: s1="hello" and s2="helicopter" the result = "hel" &#13;
    public static string CompareWords(string s1, string s2) &#13;
    { &#13;
        //Build resulting string &#13;
        string Result = string.Empty; &#13;
 &#13;
        //Get shortest length &#13;
        int ShortestLength = Mathf.Min(s1.Length, s2.Length); &#13;
 &#13;
        //Check for string match &#13;
        for (int i = 0; i &lt; ShortestLength; i++) &#13;
        { &#13;
            if (s1 [i] != s2 [i]) &#13;
                return Result; &#13;
 &#13;
            Result += s1[i]; &#13;
        } &#13;
 &#13;
        //Output result &#13;
        return Result; &#13;
    } &#13;
    //------------------------------------ &#13;
} &#13;
//------------------------------------  &#13;
</pre><p>Most classes in Unity must be added to game objects as components. This often requires us to create empty objects in the scene and then drag and drop our scripts onto them from the <span class="strong"><strong>Project</strong></span> panel. However, we don't need to do this for <code class="literal">WordList</code> because its Singleton functionality automatically instantiates a new instance, if one is not already instantiated, whenever it's referenced anywhere in the script through the <code class="literal">ThisInstance</code> C# property.</p></div></div>