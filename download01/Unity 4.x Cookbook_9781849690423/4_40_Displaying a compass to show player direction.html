<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec43"></a>Displaying a compass to show player direction</h2></div></div><hr /></div><p>In games<a id="id242" class="indexterm"></a> where players must refer to maps to confidently navigate large<a id="id243" class="indexterm"></a> terrains, it can be very useful to display a compass in the GUI, presenting a real-time graphical indication of the direction the player is facing. The next screenshot shows a player's third-person controller looking North-West, in between the cube and sphere. The black "blip" circle on the compass indicates that the player is facing this compass direction.</p><div class="mediaobject"><img src="/graphics/9781849690423/graphics/0423_04_06.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec139"></a>Getting ready</h3></div></div></div><p>If you need a set of images for this recipe, you'll find two image files in the <code class="literal">0423_04_03</code> folder. One is a <a id="id244" class="indexterm"></a>background image of a compass circle, and the other is a black circle image to represent the direction the player is facing.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec140"></a>How to do it...</h3></div></div></div><p>To display a compass onscreen, please follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene, and add a directional light.</p></li><li><p>Create a new terrain, set <span class="strong"><strong>Size</strong></span> to 2000 x 2000 and <span class="strong"><strong>Position</strong></span> (-1000, 0, -1000).</p></li><li><p>Import the built-in <span class="strong"><strong>Character Controller</strong></span> Unity package.</p></li><li><p>Add a <span class="strong"><strong>3rd Person Controller</strong></span> to your scene at <span class="strong"><strong>Position</strong></span> (0, 1, 0).</p></li><li><p>Create a cube in front (North) of the <span class="strong"><strong>3rd Person Controller</strong></span> at (0, 1, 5).</p></li><li><p>Create a sphere to the left (West) of the <span class="strong"><strong>3rd Person Controller</strong></span> at (-5, 1, 0).</p></li><li><p>Attach the following script class to the <span class="strong"><strong>Main Camera</strong></span>:</p><div class="informalexample"><pre class="programlisting">// Compass.cs
using UnityEngine;
using System.Collections;

public class Compass : MonoBehaviour
{
 public Transform playerController;
 public Texture compassBackground;
 public Texture playerBlip;
  
 private void OnGUI()
 {
   // background displaying top left in square of 128 pixels
   Rect compassBackgroundRect = new Rect(0,0, 128, 128);
 GUI.DrawTexture(compassBackgroundRect,compassBackground);
   GUI.DrawTexture(CalcPlayerBlipTextureRect(), playerBlip);
 }
  
 private Rect CalcPlayerBlipTextureRect()
 {
   // subtract 90, so North (0 degrees) is UP 
   float angleDegrees = playerController.eulerAngles.y - 90;
   float angleRadians = angleDegrees * Mathf.Deg2Rad;
    
   // calculate (x,y) position given angle
   // blip distance from center is 16 pixels
   float blipX = 16 * Mathf.Cos(angleRadians);
   float blipY = 16 * Mathf.Sin(angleRadians);	
    
   // offset blip position relative to compass center (64,64)
   blipX += 64;
   blipY += 64;
    
   // stretch blip image to display in 10x10 pixel square
   return new Rect(blipX - 5, blipY - 5, 10, 10);
 }
}</pre></div></li><li><p>With<a id="id245" class="indexterm"></a> the <span class="strong"><strong>Main Camera</strong></span> selected in the <span class="strong"><strong>Hierarchy</strong></span> view, drag the <span class="strong"><strong>3rd Person Controller</strong></span>, the compass background image, and the image for the player's direction "blip" into the <span class="strong"><strong>Inspector</strong></span> view for the three public variables.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec141"></a>How it works...</h3></div></div></div><p>The <a id="id246" class="indexterm"></a>
<code class="literal">Compass</code> class <a id="id247" class="indexterm"></a>needs three public variables, the first is a reference to the player's 3rd Person Controller, the other two are images for the compass background image (usually a circle of some kind with the compass letters displayed) and another image to indicate the direction the player is facing on the compass background.</p><p>The <code class="literal">OnGUI()</code> method<a id="id248" class="indexterm"></a> is called every frame, and at each frame the compass background needs to be displayed, followed by the image indicating the player's direction. The position of that "blip" image is calculated and returned by the <code class="literal">CalcPlayerBlipTextureRect()</code> method<a id="id249" class="indexterm"></a>. Both the images are displayed using the <code class="literal">DrawTexture()</code> method<a id="id250" class="indexterm"></a> of the <code class="literal">GUI</code> class, which expects a <code class="literal">Rect</code> object and the <code class="literal">texture</code> object. Many<a id="id251" class="indexterm"></a> recipes result in us knowing the center co-ordinates of a square or rectangle and its size/width/height. Therefore (as the following figure shows) such calculations in this recipe are straightforward to calculate:</p><div class="mediaobject"><img src="/graphics/9781849690423/graphics/0423_04_07.jpg" /></div><p>This recipe makes use of the "yaw" angle of rotation, which is rotation about the y-axis—that is, the direction a character controller is facing. This can be found in the "y" component of a GameObject's <code class="literal">eulerAngles</code> component<a id="id252" class="indexterm"></a> of its transform. You can imagine looking from above, down at the character controller, and seeing what direction they are facing—this is just what we are trying to display graphically with the compass. In mathematics, an angle of zero indicates an east direction. To correct that, we need to subtract 90 degrees from the yaw Euler angle. The angle is then converted into radians, since that is required for the Unity trigonometry methods. We then multiply these <code class="literal">Sin()</code> and <code class="literal">Cos()</code> methods' results by the distance we want the blip to be displayed from the center of the compass circle (in our code example, this is <code class="literal">16</code> pixels). We add 64 pixels to these x and y co-ordinate results since that is the center of the compass' background image. These final values for <code class="literal">blipX</code> and <code class="literal">blipY</code> are the position on screen we wish the center of player's <a id="id253" class="indexterm"></a>directional blip image to be displayed. Knowing the center of the blip image, and its width and height (both 10 pixels) allows the <code class="literal">Rect</code> object to be created for use by the <code class="literal">DrawTexture()</code> method called from <code class="literal">OnGUI()</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec142"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Displaying a radar to indicate relative locations of objects</em></span> recipe.</p></li></ul></div></div></div>