<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec94"></a>Controlling object-to-object movements (seek, flee, follow at a distance)</h2></div></div><hr /></div><p>Computer controlled characters<a id="id654" class="indexterm"></a> (non-player characters) often need to seek and move towards another object (such as the player's character), or alternatively flee away from another character. The logic is the same for both seeking and fleeing, and is demonstrated in this recipe.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec324"></a>Getting ready</h3></div></div></div><p>This recipe builds upon the player-controlled cube Unity project you created in the first recipe. So <a id="id655" class="indexterm"></a>make a copy of that project, open it, and then follow the steps of this recipe.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec325"></a>How to do it...</h3></div></div></div><p>To make an object seek, flee, or follow another object, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a sphere named <code class="literal">Arrow</code>, positioned at (2, 0.5, 2) and with scale (1, 1, 1).</p></li><li><p>Create a second sphere, named <code class="literal">Sphere-small</code>, positioned at (2, 0.5, 2.5) and with scale (0.5, 0.5, 0.5).</p></li><li><p>Make <code class="literal">Sphere-small</code> a child-object of your GameObject <code class="literal">Arrow</code>.</p></li><li><p>Add a <span class="strong"><strong>Rigidbody</strong></span> component from <span class="strong"><strong>Physics</strong></span> to the GameObject <code class="literal">Arrow</code>, modifying the following properties:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Set the value of <span class="strong"><strong>Mass</strong></span> to <span class="strong"><strong>0.3</strong></span></p></li><li style="list-style-type: disc"><p>Uncheck the <span class="strong"><strong>Use Gravity</strong></span> checkbox</p></li><li style="list-style-type: disc"><p>Check (tick) the <span class="strong"><strong>Freeze Position</strong></span> for the <span class="strong"><strong>Y</strong></span> axis only</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781849690423/graphics/0423_09_04.jpg" /></div></li><li><p>Add the following C# script class to your GameObject <code class="literal">Arrow</code>:</p><div class="informalexample"><pre class="programlisting">// file: SeekTarget.cs
using UnityEngine;
using System.Collections;

public class SeekTarget : MonoBehaviour {
  public GameObject playerGO;
  public const float MAX_MOVE_DISTANCE = 500.0f;
  
  private void FixedUpdate () {
    float moveDistance = MAX_MOVE_DISTANCE * Time.deltaTime;
    Vector3 source = transform.position;
    Vector3 target = playerGO.transform.position;

    Vector3 seekVelocity = Seek(source, target, moveDistance);
    seekVelocity = UsefulFunctions.ClampMagnitude(seekVelocity, moveDistance);
    rigidbody.AddForce( seekVelocity, ForceMode.VelocityChange );
    UsefulFunctions.DebugRay(transform.position, seekVelocity, Color.blue);
    UsefulFunctions.DebugRay(transform.position, rigidbody.velocity, Color.yellow);
  }

  private Vector3 Seek(Vector3 source, Vector3 target, float moveDistance){
    Vector3 directionToTarget = Vector3.Normalize( target - source );
    Vector3 velocityToTarget = moveDistance * directionToTarget;
    transform.LookAt( playerGO.transform );

    return velocityToTarget - rigidbody.velocity;
  }
}</pre></div></li><li><p>Ensuring <span class="strong"><strong>Arrow</strong></span> is <a id="id656" class="indexterm"></a>selected, in the <span class="strong"><strong>Inspector</strong></span> for the <code class="literal">SeekTarget</code> scripted component, drag <span class="strong"><strong>Cube-player</strong></span> over the public variable <span class="strong"><strong>playerTransform</strong></span>.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec326"></a>How it works...</h3></div></div></div><p>We have added a Unity <span class="strong"><strong>Rigidbody</strong></span> component from <span class="strong"><strong>Physics</strong></span> to our <code class="literal">Arrow</code> object. This means we can ask Unity to apply a "force" to this object, and Unity will work out how to move the object based on its mass and any previous velocity the object already had.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note46"></a>Note</h3><p>When working with physics and forces, we put our logic into the <code class="literal">FixedUpdate()</code> method<a id="id657" class="indexterm"></a>, which is called at a fixed frame rate, immediately before Unity runs its physics simulation for the frame. Had such logic been located in the <code class="literal">Update()</code> method<a id="id658" class="indexterm"></a>, several <code class="literal">Update()</code> messages, or none, might have been received since the last physics' simulation update, leading to uneven behavior.</p><p>Remember, once you have added a physics rigid body to an object you are influencing through code, that code must be placed into the <code class="literal">FixedUpdate()</code> method.</p></div><p>One danger when adding forces to already moving objects is that they start to move very fast, and this can lead to "overshooting" the target, and sometimes can even leave the chasing object forever orbiting <a id="id659" class="indexterm"></a>around the target, never getting any closer to it. Therefore, we define a <code class="literal">MAX_MOVE_DISTANCE</code> constant, which will set a limit on the size of any force we will apply to <code class="literal">Arrow</code>. As usual, since the frame rate of games vary, we need to use the proportion of this speed maximum that is relative to the time since the last frame (<code class="literal">Time.deltaTime</code>).</p><p>Each time <code class="literal">FixedUpdate()</code> is called, the maximum move distance for this frame (<code class="literal">moveDistance</code>) is calculated first. Then the <code class="literal">Seek()</code> method<a id="id660" class="indexterm"></a> is called passing the current positions of the source (<code class="literal">Arrow</code>) and target (<code class="literal">Cube-player</code>) objects. This method returns a <code class="literal">Vector3</code> object that represents the force we wish to apply to <code class="literal">Arrow</code> to make it move towards the players cube. This force is limited to the size of <code class="literal">moveDistance</code>, and then applied to the <code class="literal">Arrow</code> object as a force to the rigid body component. Finally, the <code class="literal">Arrow</code> object is made to face towards its target, and then two debug rays are drawn, a blue one to show the seeking force we have just applied, and a yellow one to show the current direction/speed velocity that the <code class="literal">Arrow</code> object now has.</p><p>The core of this target-seeking behavior is to make use of the following two key pieces of information, which we do in the <code class="literal">Seek()</code> method:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>direction</em></span> from the <code class="literal">Arrow</code> (source) object towards the player's cube (target) object</p></li><li style="list-style-type: disc"><p>The <span class="emphasis"><em>magnitude</em></span> (length) of the force vector we want to apply to our <code class="literal">Arrow</code> object</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>A <code class="literal">Vector3</code> object is the perfect data structure for forces, since they represent both direction and magnitude (the length of the vector).</p><p>A <span class="strong"><strong>normalized</strong></span> vector<a id="id661" class="indexterm"></a> is simply a vector with a length (magnitude) of 1. This is very useful since we can then multiple a normalized vector by the speed (distance) we want an object to move. Sometimes we refer to a normalized vector as a <span class="strong"><strong>unit vector</strong></span><a id="id662" class="indexterm"></a>, since it has a length of 1.</p></div></li></ul></div><p>The <code class="literal">Seek()</code> method does the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>It calculates the direction from the <code class="literal">Arrow</code> (source) object towards the players cube (target) object by subtracting the source position from the target position, and then normalizing the result.</p></li><li style="list-style-type: disc"><p>This direction is multiplied by <code class="literal">moveDistance</code> to give the velocity vector we'd like the <code class="literal">Arrow</code> object to move.</p></li><li style="list-style-type: disc"><p>If <code class="literal">Arrow</code> is already moving, then simply applying the force towards the target may "nudge" the <code class="literal">Arrow</code> object a little off its current direction towards the target. <a id="id663" class="indexterm"></a>What we really want is to calculate the force to apply to make <code class="literal">Arrow</code> move towards the target taking into account the <code class="literal">Arrow</code> object's current movement. We do this by subtracting the <code class="literal">Arrow</code> object's current movement (<code class="literal">rigidbody.velocity</code>) from the force in the direction of the target. The result is a force that will redirect <code class="literal">Arrow</code> from its current direction towards the target.</p><div class="mediaobject"><img src="/graphics/9781849690423/graphics/0423_09_05.jpg" /></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec327"></a>There's more...</h3></div></div></div><p>The following are some details you don't want to miss.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec73"></a>Using the simpler (and less sophisticated) MoveTowards() method</h4></div></div></div><p>If the only<a id="id664" class="indexterm"></a> movement behavior you wish to implement for an object is a simple seek behavior, Unity does provide a very straightforward method for this purpose. The use of rigid bodies and forces is needed for the later recipes in this chapter, which is why this simple method approach was not taken for this recipe. However, you could replace the code in this recipe for the <code class="literal">SeekTarget</code> class<a id="id665" class="indexterm"></a> with the following, which uses the <code class="literal">MoveTowards()</code> Unity method for a simple seek behavior:</p><div class="informalexample"><pre class="programlisting">// file: MoveTowards.cs
using UnityEngine;
using System.Collections;

public class MoveTowards : MonoBehaviour {
  public Transform playerTransform;
  public float speed = 5.0F;

  private void Update () {
    transform.LookAt(playerTransform);
    float distance = speed * Time.deltaTime;
    Vector3 source = transform.position;
    Vector3 target = playerTransform.position;
    transform.position = Vector3.MoveTowards(source, target, distance);
  }
}</pre></div><p>The <code class="literal">MoveTowards()</code> method<a id="id666" class="indexterm"></a> takes three arguments, namely: the source position, the target position, and how far to move towards the target.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec74"></a>Improving arrival behavior through deceleration when near target</h4></div></div></div><p>A nicer version of the<a id="id667" class="indexterm"></a> seek behavior involves the seeking object to slow down as it gets closer to the target object. This can be achieved by replacing the <code class="literal">Seek()</code> method with a new <code class="literal">Arrive()</code> method. First, replace the statement in <code class="literal">FixedUpdate()</code>, so that the value of <code class="literal">adjustVelocity</code> is returned from the <code class="literal">Arrive()</code> method:</p><div class="informalexample"><pre class="programlisting">Vector3 adjustVelocity = Arrive(source, target);</pre></div><p>Next, define a constant <code class="literal">DECELERATION_FACTOR</code> that we need:</p><div class="informalexample"><pre class="programlisting">const float DECELERATION_FACTOR = 0.6f;</pre></div><p>Finally, implement the <code class="literal">Arrive()</code> method with the following code:</p><div class="informalexample"><pre class="programlisting">private Vector3 Arrive(Vector3 source, Vector3 target){float distanceToTarget = Vector3.Distance(source, target);
  Vector3 directionToTarget = Vector3.Normalize( target - source );
  float speed = distanceToTarget / DECELERATION_FACTOR;
  Vector3 velocityToTarget = speed * directionToTarget;
  
  return velocityToTarget - rigidbody.velocity;
}</pre></div><p>The speed (magnitude) of the force to be applied to the <code class="literal">Arrow</code> object will vary depending<a id="id668" class="indexterm"></a> on the remaining distance to the target (player's cube). This rate of deceleration can be tweaked by changing the value of the <code class="literal">DECELERATION_FACTOR</code> constant. As the distance to the target is reduced (that is, as the <code class="literal">Arrow</code> object gets closer), the size of the force to be applied to <code class="literal">Arrow</code> is smaller, so it slows down as it gets closer to the target. This results in a more natural (and satisfying) movement in target-seeking game objects.</p><p>The next screenshot shows the following two debug rays of the forces on the <code class="literal">Arrow</code> object at a point in time:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The longer ray shows the current movement velocity of the Arrow—upwards and to the right</p></li><li style="list-style-type: disc"><p>The shorter ray shows the force to be applied to <code class="literal">Arrow</code> to make it move towards the player's cube, downwards to the right—which should result in the <code class="literal">Arrow</code> colliding with the target player cube object very soon</p><div class="mediaobject"><img src="/graphics/9781849690423/graphics/0423_09_06.jpg" /></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec75"></a>Implementing flee target and follow at a distance</h4></div></div></div><p>The opposite to <a id="id669" class="indexterm"></a>arrive at is the flee behavior. This involves moving in the opposite direction to where the target is. First, change <code class="literal">FixedUpdate()</code> so that the value of <code class="literal">adjustVelocity</code><a id="id670" class="indexterm"></a> is set differently according to the distance from target (its default is <code class="literal">0</code>; if within the value of <code class="literal">FLEE_RADIUS</code>, it will<a id="id671" class="indexterm"></a> be a force to move away from the target, if outside the value of <code class="literal">SEEK_RADIUS</code>, it will be a force to move towards the target):</p><div class="informalexample"><pre class="programlisting">Vector3 adjustVelocity = Vector3.zero;

float distanceToTarget = Vector3.Distance(target, source);
if( distanceToTarget &lt; FLEE_RADIUS )
  adjustVelocity += Flee(source, target);

if( distanceToTarget &gt; SEEK_RADIUS )
  adjustVelocity += Arrive(source, target);</pre></div><p>Next, define some constants we need:</p><div class="informalexample"><pre class="programlisting">const float DECELERATION_FACTOR = 0.6f;
public const float FLEE_RADIUS = 14f;
public const float SEEK_RADIUS = 6f;</pre></div><p>As the value of <code class="literal">FLEE_RADIUS</code> is larger than that of <code class="literal">SEEK_RADIUS</code>, when the distance to the target is between 6 and 14, then <span class="emphasis"><em>both</em></span> a flee and an arrive force will be calculated, resulting in a deceleration in this overlap zone. The result is a realistic following behavior, whereby the Arrow follows at approximately 10 units, accelerating and decelerating smoothly based on the player's cube movements.</p><p>Add the <code class="literal">Arrive()</code> method<a id="id672" class="indexterm"></a> listed in the previous section, and also add a new method called <code class="literal">Flee()</code> as follows:</p><div class="informalexample"><pre class="programlisting">private Vector3 Flee(Vector3 source, Vector3 target){
  float distanceToTarget = Vector3.Distance(target, source);
  Vector3 directionAwayFromTarget = Vector3.Normalize(source - target);
  float speed = (FLEE_RADIUS - distanceToTarget) / DECELERATION_FACTOR;
  Vector3 velocityAwayFromTarget = speed * directionAwayFromTarget;
  return velocityAwayFromTarget;
}</pre></div><p>The <code class="literal">Flee()</code> method<a id="id673" class="indexterm"></a> works in the opposite way to <code class="literal">Arrive()</code>, so the speed (magnitude) of the velocity force vector will be larger when the target is closer. Therefore, the <code class="literal">Arrow</code> will move quickly away from a nearby target.</p><p>A follow-at-a-distance behavior can be achieved by making an object flee a nearby target, but seek to arrive at a far away target.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec328"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Controlling cube movement through player controls</em></span> recipe</p></li><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Controlling object look-at behavior</em></span> recipe</p></li><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Controlling object group movement through flocking</em></span> recipe</p></li><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Following waypoints in a sequence</em></span> recipe</p></li></ul></div></div></div>