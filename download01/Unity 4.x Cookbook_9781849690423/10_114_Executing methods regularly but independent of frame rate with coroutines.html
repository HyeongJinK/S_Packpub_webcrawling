<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec111"></a>Executing methods regularly but independent of frame rate with coroutines</h2></div></div><hr /></div><p>Optimization <a id="id850" class="indexterm"></a>principal 4: <span class="emphasis"><em>Call methods as few times as possible</em></span>. While it is very simple to put logic into <code class="literal">Update()</code> and have it regularly executed each frame, we can improve the game performance by executing logic as occasionally as possible. So, if we can get away with only checking for some situations every five seconds, then great performance savings can be made to move that logic out of <code class="literal">Update()</code>.</p><p>A <span class="strong"><strong>coroutine</strong></span><a id="id851" class="indexterm"></a> is a function that can suspend its execution until a <span class="strong"><strong>yield</strong></span><a id="id852" class="indexterm"></a> action has completed. One kind of yield action simply waits for a given number of seconds. In this recipe, we use coroutines and <code class="literal">yield</code> to show how a method can only be executed every five seconds. This could be useful for non-player characters to decide whether they should randomly "wake up", or perhaps choose a new location to start moving towards.</p><div class="mediaobject"><img src="/graphics/9781849690423/graphics/0423_10_09.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec387"></a>How to do it...</h3></div></div></div><p>To implement methods <a id="id853" class="indexterm"></a>at regular intervals independent of the frame rate, perform the follow steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following C# script class <code class="literal">TimedMethod</code> in the <span class="strong"><strong>Main Camera</strong></span>:</p><div class="informalexample"><pre class="programlisting">// file: TimedMethod.cs
using UnityEngine;
using System.Collections;

public class TimedMethod : MonoBehaviour {
  private void Start() {
    StartCoroutine(Tick());
  }
  
  private IEnumerator Tick() {
    float delaySeconds = 5.0F;
    while (true) {
      print("tick " + Time.time);
      yield return new WaitForSeconds(delaySeconds);
    }
  }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec388"></a>How it works...</h3></div></div></div><p>When the <code class="literal">Start()</code> message is received, the <code class="literal">Tick()</code> method is started as a coroutine. The <code class="literal">Tick()</code> method sets<a id="id854" class="indexterm"></a> the delay between executions (variable <code class="literal">delaySeconds</code>) to <code class="literal">5</code> seconds. An infinite loop is then started, where the method does its actions (in this case just printing out the time); finally, a <code class="literal">yield</code> instruction is given, which causes the method to suspend execution for the given delay of <code class="literal">5</code> seconds. After the <code class="literal">yield</code> instruction has completed, the loop will execute once again, and so on.</p><p>You may have noticed that there is no <code class="literal">Update()</code> method at all. So, although our game has logic being regularly executed, in this example, there is no logic that has to be executed every frame. Fantastic!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec389"></a>There's more...</h3></div></div></div><p>The following are some details you don't want to miss:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec89"></a>Have different actions happening at different intervals</h4></div></div></div><p>Coroutines<a id="id855" class="indexterm"></a> can be used to have different kinds of logic being executed at different regular intervals. So logic that needs frame-by-frame execution goes into <code class="literal">Update()</code> and logic that works fine once or twice a second, might go into a coroutine with a 0.5-second delay; logic that can get away with less occasional updating can go into another coroutine with a 2- or 5-second delay, and so on. Effective and noticeable performance improvements can be found by carefully analyzing (and testing) different game logic to identify the least frequent execution that is still acceptable.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec390"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Spreading long computations over several frames with coroutines</em></span> recipe</p></li></ul></div></div></div>