<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec100"></a>Managing object behavior with states</h2></div></div><hr /></div><p>Games as a whole, and individual <a id="id733" class="indexterm"></a>objects or characters, can often be thought of (or modeled as) passing through different <span class="emphasis"><em>states</em></span> or <span class="emphasis"><em>modes</em></span>. Modeling states and changes of state (due to events or game conditions) is a very common way to manage the complexity of games and game components. In this recipe, we create a simple three-state game (game playing, game won, and game lost), using a single <a id="id734" class="indexterm"></a>
<code class="literal">GameManager</code> class.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec350"></a>How to do it...</h3></div></div></div><p>To use states to <a id="id735" class="indexterm"></a>manage object behavior, perform the following step:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following C# script class to the <span class="strong"><strong>Main Camera</strong></span>:</p><div class="informalexample"><pre class="programlisting">// file: GameManager
using UnityEngine;
using System.Collections;

public class GameManager : MonoBehaviour {
  private float gameStartTime;
  private float gamePlayingTime;

  private enum GameStateType {
    STATE_GAME_PLAYING,
    STATE_GAME_WON,
    STATE_GAME_LOST,
  }

  private GameStateType currentState;
    
  private void Start () {
    NewGameState( GameStateType.STATE_GAME_PLAYING );
  }

  private void NewGameState(GameStateType newState) {
    // (1) state EXIT actions
    switch( currentState ) {
    case GameStateType.STATE_GAME_PLAYING:
      gameStartTime = Time.time;
      break;
    }

    // (2) change current state
    currentState = newState;

    // (3) state ENTER actions
  }

  private void Update () {
    switch( currentState ) {
    case GameStateType.STATE_GAME_PLAYING:
      StateGamePlayingUpdate();
      break;
    case GameStateType.STATE_GAME_WON:
      StateGameWonUpdate();
      break;
    case GameStateType.STATE_GAME_LOST:
      StateGameLostUpdate();
      break;
    }
  }

  private void OnGUI () {
    switch( currentState ) {
    case GameStateType.STATE_GAME_PLAYING:
      StateGamePlayingGUI();
      break;
    case GameStateType.STATE_GAME_WON:
      StateGameWonGUI();
      break;
    case GameStateType.STATE_GAME_LOST:
      StateGameLostGUI();
      break;
    }
  }
  
  private void StateGamePlayingGUI() {
    GUILayout.Label("state: GAME PLAYING - time since game started = "  + gamePlayingTime);
    bool winGameButtonClicked = GUILayout.Button("WIN the game");
    bool loseGameButtonClicked = GUILayout.Button("LOSE the game");
    
    if( winGameButtonClicked )
      NewGameState( GameStateType.STATE_GAME_WON );

    if( loseGameButtonClicked )
      NewGameState( GameStateType.STATE_GAME_LOST );
  }

  private void StateGameWonGUI() {
    GUILayout.Label("state: GAME WON - game duration = " + gamePlayingTime);
  }

  private void StateGameLostGUI() {
    GUILayout.Label("state: GAME LOST - game duration = " + gamePlayingTime);
  }
  
  private void StateGameWonUpdate() {	print("update - state: GAME WON"); }
  private void StateGameLostUpdate() {	print("update - state: GAME LOST"); }

  private void StateGamePlayingUpdate() {
    gamePlayingTime = (Time.time - gameStartTime);
    print("update - state: GAME PLAYING :: time since game started = " + gamePlayingTime); 
  }

}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec351"></a>How it works...</h3></div></div></div><p>As can be seen<a id="id736" class="indexterm"></a> in the following state chart figure, this recipe models a simple game which starts in the <span class="strong"><strong>GAME PLAYING</strong></span> state, depending on the button clicked by the user, the game moves either into the <span class="strong"><strong>GAME WON</strong></span> state or the <span class="strong"><strong>GAME LOST</strong></span> state. The three possible states of the system are defined using the enumerated type <code class="literal">GameStateType</code>. The current state of the system at any point in time is stored in <code class="literal">currentState</code> variable.</p><div class="mediaobject"><img src="/graphics/9781849690423/graphics/0423_09_14.jpg" /></div><p>Key aspects of state driven games include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>When a state changes, there may be actions as a particular state is exited, then the system changes it data to represent the new state, then there may be actions as the new state is entered</p><p>In our example, this is the responsibility of the <code class="literal">NewGameState()</code> method<a id="id737" class="indexterm"></a>. The code for this method is in three parts, implementing the logic for the following steps: old state exit, set new state, and new state entered.</p></li><li style="list-style-type: disc"><p>When the <code class="literal">GameManager</code> object receives messages (for example, every frame for <code class="literal">Update()</code> and <code class="literal">OnGUI()</code>), its behavior must be appropriate for the current state. So we see<a id="id738" class="indexterm"></a> in these methods <code class="literal">switch</code> statements that call state-specific methods. For example, if the current state is <code class="literal">STATE_GAME_PLAYING</code>, then when an <code class="literal">Update()</code> message is received, the <code class="literal">StateGamePlayingGUI()</code> method<a id="id739" class="indexterm"></a> will be called, and when an <code class="literal">OnGUI()</code> message is received, the <code class="literal">StateGamePlayingGUI()</code>method will be called.</p></li></ul></div><p>However, the size and number of methods in our <code class="literal">GameManager</code> class will grow significantly with more states, and more complex game logic is needed for non-trivial games. The next recipe takes a more sophisticated approach to state-driven games, where each state has its own class.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec352"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Managing complex object behavior with the state pattern</em></span> recipe</p></li></ul></div></div></div>