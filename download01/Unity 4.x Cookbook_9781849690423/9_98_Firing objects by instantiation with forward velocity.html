<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec96"></a>Firing objects by instantiation with forward velocity</h2></div></div><hr /></div><p>A very common game<a id="id691" class="indexterm"></a> behavior for the player (or a computer-controlled non-player-character (NPC)) is to fire a <a id="id692" class="indexterm"></a>projectile in the direction they are facing. This recipe presents a way to achieve this behavior.</p><p>Although there are several steps in this recipe, there are just three script classes, and most of the work is in setting up the cube wall and red sphere projectile, as seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849690423/graphics/0423_09_09.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec333"></a>Getting ready</h3></div></div></div><p>In the <code class="literal">0423_09_05</code> folder, <a id="id693" class="indexterm"></a>you'll find a stone image texture file called <code class="literal">stones.png</code> shown as follows:</p><div class="mediaobject"><img src="/graphics/9781849690423/graphics/0423_09_10.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec334"></a>How to do it...</h3></div></div></div><p>To fire a projectile<a id="id694" class="indexterm"></a>, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new scene and add a directional light.</p></li><li><p>Create a terrain sized 10 x 10, positioned at (0, 0, 0).</p></li><li><p>Create a new cube named <code class="literal">BrickCube</code>, sized (1, 1, 1). Apply the image texture <code class="literal">stones.png</code>, give it the tag <code class="literal">brick</code>, and add a <span class="strong"><strong>Rigidbody</strong></span> component from <span class="strong"><strong>Physics</strong></span> to this GameObject.</p></li><li><p>Create a new Prefab named <code class="literal">Prefab-brick</code>, and drag <span class="strong"><strong>BrickCube</strong></span> into it.</p></li><li><p>Add the following C# script class to <code class="literal">Prefab-brick</code>:</p><div class="informalexample"><pre class="programlisting">// file: DestroyWhenFall.cs
using UnityEngine;
using System.Collections;

public class DestroyWhenFall : MonoBehaviour 
{
  private const float MIN_Y = -1;
  
  void Update () {
    float y = transform.position.y;
    if( y &lt; MIN_Y )
      Destroy( gameObject);
  }
}</pre></div></li><li><p>Create a "pyramid wall" of bricks, by placing nine instances of <code class="literal">BrickPrefab</code> in the scene at the following positions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>bottom row</strong></span>: (2, 0.5, 9) (3, 0.5, 9) (4, 0.5, 9) (5, 0.5, 9) (6, 0.5, 9)</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>middle row</strong></span>: (3, 1.75, 9) (4, 1.75, 9) (5, 1.75, 9)</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>top row</strong></span>: (4, 3, 9)</p></li></ul></div></li><li><p>Create a <a id="id695" class="indexterm"></a>new sphere named <code class="literal">SphereRed</code>, sized (1, 1, 1) with a red material, and add a <span class="strong"><strong>Rigidbody</strong></span> component from <span class="strong"><strong>Physics</strong></span> to this GameObject.</p></li><li><p>Create a new Prefab named <code class="literal">Prefab-sphere</code>, and drag <span class="strong"><strong>SphereRed</strong></span> into the Prefab.</p></li><li><p>Delete <span class="strong"><strong>SphereRed</strong></span> from the scene.</p></li><li><p>Add the <code class="literal">DestroyWhenFall</code> script class<a id="id696" class="indexterm"></a> to <code class="literal">Prefab-sphere</code>.</p></li><li><p>Remove the <span class="strong"><strong>Main Camera</strong></span> GameObject (since there is already a <span class="strong"><strong>Main Camera</strong></span> inside the controller that you'll import in the next step).</p></li><li><p>Import the <span class="strong"><strong>Unity Character Controllers</strong></span> package, and add an instance of the <span class="strong"><strong>First Person Controller</strong></span> at (5, 1, 1).</p></li><li><p>Add the following C# script class to the <span class="strong"><strong>Main Camera</strong></span> inside your <span class="strong"><strong>First Person Controller</strong></span> (ensure <span class="strong"><strong>Main Camera</strong></span> is selected in the <span class="strong"><strong>Hierarchy</strong></span> panel):</p><div class="informalexample"><pre class="programlisting">// file: GameOverManager.cs
using UnityEngine;
using System.Collections;

public class GameOverManager : MonoBehaviour {
  private bool gameWon = false;

  void Update() {
    GameObject[] wallObjects = GameObject.FindGameObjectsWithTag("brick");
    int numWallObjects = wallObjects.Length;

    if( numWallObjects &lt; 1 )
      gameWon = true;
  }

  void OnGUI() {
    if( gameWon )
      GUILayout.Label("Well Done - you have destroyed the whole wall!");
  }
}</pre></div></li><li><p>Also add the following script class to the <span class="strong"><strong>Main Camera</strong></span> inside your <span class="strong"><strong>First Person Controller</strong></span><a id="id697" class="indexterm"></a> (ensure <span class="strong"><strong>Main Camera</strong></span> is selected in the <span class="strong"><strong>Hierarchy</strong></span> panel):</p><div class="informalexample"><pre class="programlisting">// file: FireProjectile.cs
using UnityEngine;
using System.Collections;

public class FireProjectile : MonoBehaviour {
  public Rigidbody projectilePrefab;
  private const float MIN_Y = -1;
  private float projectileSpeed = 15f;

  /** shortest time between firing */
  public const float FIRE_DELAY = 0.25f;
  private float nextFireTime = 0f;

  void Update() {
    if( Time.time &gt; nextFireTime )
      CheckFireKey();
  }

  void CheckFireKey() {
    if( Input.GetButton("Fire1")) {
      CreateProjectile();

      nextFireTime = Time.time + FIRE_DELAY;
    }
  }

  void CreateProjectile() {
      Rigidbody projectile = (Rigidbody)Instantiate(projectilePrefab, transform.position, transform.rotation);

      // create and apply velocity 
    Vector3 projectileVelocity = (projectileSpeed * Vector3.forward);
      projectile.velocity = transform.TransformDirection( projectileVelocity );
  }   
}</pre></div></li><li><p>Ensuring <span class="strong"><strong>Main Camera</strong></span> inside your <span class="strong"><strong>First Person Controller</strong></span> is selected, in the <span class="strong"><strong>Inspector</strong></span> for the <span class="strong"><strong>FireProjectile</strong></span> scripted component, drag <span class="strong"><strong>Prefab-sphere</strong></span> over public variable <span class="strong"><strong>Prefab-projectile</strong></span>.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec335"></a>How it works...</h3></div></div></div><p>Both <a id="id698" class="indexterm"></a>Prefabs (<code class="literal">Prefab-sphere</code> and <code class="literal">Prefab-brick</code>) contain rigid body components; this allows the physics engine to control instances of such objects. We can apply forces to objects with rigid bodies (for example, we can "throw" this object in a given direction), and the object will collide with and bounce off other objects. Both Prefabs also have an instance of the script class <code class="literal">DestroyWhenFall</code>—this adds the simple behavior that when either the red sphere or brick objects fall below the level of the terrain (Y=0), the objects will be destroyed. This prevents the scene from becoming filled up with all of the old sphere projectiles that have been fired. Also, it allows us to detect when the game is completed, that is, when all of the brick objects have been pushed off the terrain. Testing this condition is the responsibility of the <code class="literal">GameOverManager</code> scripted component of the <span class="strong"><strong>Main Camera</strong></span> from <span class="strong"><strong>First Person Controller</strong></span>. For each frame it counts the number of objects tagged with <code class="literal">brick</code>, and once that number is zero, the game completed message is displayed.</p><p>At the heart of this mini-game is the <span class="strong"><strong>Main Camera</strong></span> scripted component <code class="literal">FireProjectile</code><a id="id699" class="indexterm"></a> of <span class="strong"><strong>First Person Controller</strong></span>. Variable <code class="literal">nextFireTime</code> stores the time when the next projectile may be fired, and for each frame the current time is tested to see if that time has been reached. If it has, then the <code class="literal">CheckFireKey()</code>method<a id="id700" class="indexterm"></a> is called. This variable is initialized to zero, so the user doesn't have to wait at all to fire the first time.</p><p>The <code class="literal">CheckFireKey()</code> method tests whether the user is pressing the Fire button at that instant. If the Fire button is pressed, the <code class="literal">CreateProjectile()</code> method<a id="id701" class="indexterm"></a> is called, and the next time duration the player can fire is set to <code class="literal">FIRE_DELAY</code> seconds in the future.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note48"></a>Note</h3><p><span class="strong"><strong>Unity input settings</strong></span></p><p>The default is the left mouse button, but this can be changed in the project input settings by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Input</strong></span>.</p></div><p>The <code class="literal">CreateProjectile()</code> method creates a new instance of the <code class="literal">SpherePrefab</code> (via the public variable <code class="literal">Prefab-projectile</code>) at the same position and rotation of the <span class="strong"><strong>Main Camera</strong></span> of <span class="strong"><strong>First Person Controller</strong></span>. Note that as the camera scripted component <code class="literal">FireProjectile</code> is attached to this camera, any references to transform will retrieve the transform component of that camera.</p><p>A velocity vector for the force (movement) to be applied to the sphere projectile is calculated by multiplying the forward vector with the <code class="literal">projectileSpeed</code> variable<a id="id702" class="indexterm"></a>—this variable can be tweaked to achieve the speed of firing desired for a game. To ensure the sphere projectile is moved in the same direction the camera is facing, the <code class="literal">TransformDirection()</code> method<a id="id703" class="indexterm"></a>
<a id="id704" class="indexterm"></a> of the camera's transform component is used to set the projectile's velocity property. The result is that a new sphere projectile instance is created at the camera location, and the force is applied to make it be fired in the direction the user has oriented the camera of <span class="strong"><strong>First Person Controller</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec336"></a>There's more...</h3></div></div></div><p>The following are some details you don't want to miss.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec76"></a>Addressing efficiency issues with FindGameObjectsWithTag()</h4></div></div></div><p>For small games, where efficiency isn't an issue, the use of <code class="literal">FindGameObjectsWithTag()</code> is fine.<a id="id705" class="indexterm"></a> However, when tweaking a complex game to improve efficiency, the use of this method should be avoided as it requires a search of all GameObjects in a scene and needs to test their tag names again. A more efficient approach would be to maintain a count of the number of instances that have been created, and then to ensure that this count (list) is updated each time an object is destroyed. Thus, the count (or size of the list) is all that would be needed to be tested against for our game over condition. Another alternative to <code class="literal">FindGameObjectsWithTag()</code> is to maintain a dynamic list of all object references. See <a class="link" href="#" linkend="ch10">Chapter 10</a>, <span class="emphasis"><em>Improving Games with Extra Features and Optimization</em></span>, for such optimization recipes.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec337"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Controlling object-to-object movements (seek, flee, follow at a distance)</em></span> recipe</p></li><li style="list-style-type: disc"><p>The <span class="emphasis"><em>Caching, rather than component lookups and "reflection" over objects</em></span> recipe in <a class="link" href="#" linkend="ch10">Chapter 10</a>,<span class="emphasis"><em> Improving Games with Extra Features and Optimization</em></span></p></li></ul></div></div></div>