<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec40"></a>Unravelling the Event System</h2></div></div><hr /></div><p>The <span class="strong"><strong>EventSystem</strong></span> <a id="id577" class="indexterm"></a>is a powerful yet simple manager providing such capabilities as:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Cataloging all the input systems available</p></li><li style="list-style-type: disc"><p>Monitoring the current input state</p></li><li style="list-style-type: disc"><p>Maintaining the currently selected GameObject</p></li><li style="list-style-type: disc"><p>Updating all the various input systems</p></li><li style="list-style-type: disc"><p>Marshalling Raycast testing between input and screen objects (and not just UI GameObjects!)</p></li></ul></div><p>We'll discuss what these mean in detail, shortly.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note145"></a>Note</h3><p>It's worth noting, there can only ever be a single <span class="strong"><strong>EventSystem</strong></span> manager in any scene, no matter how many you try to add. At the core of the <span class="strong"><strong>EventSystem</strong></span> is a static instance that ensures there can be only one.</p></div><p>The <span class="strong"><strong>EventSystem</strong></span> uses all <a id="id578" class="indexterm"></a>the Event logic described in the following sections of this chapter and manages the state of the UI and even processes the events for selected objects (as described previously).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec67"></a>The Event System loop</h3></div></div></div><p>Like most managers <a id="id579" class="indexterm"></a>and Unity itself, the <span class="strong"><strong>EventSystem</strong></span> runs on a loop that looks like the following:</p><div class="mediaobject"><img src="/graphics/9781783553617/graphics/3617OS_06_05.jpg" /></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>
<span class="strong"><strong>The Event System itself</strong></span>: At the start of the loop, the <span class="strong"><strong>Event System</strong></span> verifies it has the details of all the active input systems present in your scene and then kicks off the next stage to test those inputs.</p></li><li><p>
<span class="strong"><strong>Scanner on the scent</strong></span>: Once the manager knows what types of input are available (such as mouse, keyboard, touch, and so on), it tells each input system in turn to gather their current state.</p></li><li><p>
<span class="strong"><strong>Casting out the net</strong></span>: When each input system has its state, they call back to the <span class="strong"><strong>Event System</strong></span> to begin raycasting into the scene using the available raycast systems (Physics raycasters, Graphic raycasters, and so on) to determine if any GameObjects were interacted with by the user's input.</p><p>This then causes the relevant events to be fired informing the relevant GameObjects. (Remember, this affects any GameObject, not just UI. If you only want input to affect UI you have to ensure the <span class="strong"><strong>Canvas</strong></span> blocks raycasts into the scene using a <span class="strong"><strong>CanvasGroup</strong></span>.)</p></li><li><p>
<span class="strong"><strong>The final frontier</strong></span>: Once the <span class="strong"><strong>Event System</strong></span> has finished processing, rendering takes place <a id="id580" class="indexterm"></a>and the <span class="strong"><strong>Canvas</strong></span> draws itself into the scene. This is quite efficient and ensures any user interactions have been dealt with before the drawing takes place (such as a Button highlighting from the user's mouse hovering over it).</p></li><li><p>
<span class="strong"><strong>Back to The EventSystem itself: And the dance begins again</strong></span>:<span class="strong"><strong> </strong></span>Obviously, when you finish the dance you start all over again, once Unity has finished whatever else it needs to do. You know all the other 3D/2D rendering and such.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec68"></a>Controlling state</h3></div></div></div><p>In its other <a id="id581" class="indexterm"></a>roles (because it is the only one), the <span class="strong"><strong>EventSystem</strong></span> ensures what the current state of play is in whatever it does, whether that's:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Which input system is being tested</p></li><li style="list-style-type: disc"><p>What is currently selected (important for the UI navigation system), including what the first (the default object) and previously selected objects were</p></li></ul></div><p>These are key states that need to be tracked at all times through the game loop, understanding what is being processed at this point in time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec69"></a>Raycast Marshalling</h3></div></div></div><p>The <span class="strong"><strong>EventSystem</strong></span> is <a id="id582" class="indexterm"></a>also the go-to manager for raycast testing. As ever, all roads lead back to the <span class="strong"><strong>EventSystem</strong></span>.</p><p>When <a id="id583" class="indexterm"></a>an input module needs to verify if something needs to be notified by a specific input interaction, it asks the <span class="strong"><strong>EventSystem</strong></span> if anything is in the vicinity of the current coordinates for the input action (mouse pointer or touch). The <span class="strong"><strong>EventSystem</strong></span> then takes this position and then loops through all the raycast modules you have registered on your Canvas to see if anything was hit. The currently supported raycast modules are:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Physics Raycaster</strong></span>: Tests <a id="id584" class="indexterm"></a>3D objects within the scene</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Physics 2D Raycaster</strong></span>: Tests <a id="id585" class="indexterm"></a>2D objects within the scene</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Graphics Raycaster</strong></span>: Test <a id="id586" class="indexterm"></a>UI objects within the scene</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Another Raycaster</strong></span>: Build <a id="id587" class="indexterm"></a>your own raycast test component!</p></li></ul></div><p>These tests simply return a set of raycast results (if anything was interacted with by each progressive raycast test) for the input manager to handle.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note146"></a>Note</h3><p>If you are unfamiliar with Raycasting, check out the Unity documentation at <a class="ulink" href="http://unity3d.com/learn/tutorials/modules/beginner/physics/raycasting" target="_blank">http://unity3d.com/learn/tutorials/modules/beginner/physics/raycasting</a>.</p><p>Basically, Raycasting is a simple test that takes one coordinate (say the position of a mouse) and a <a id="id588" class="indexterm"></a>second coordinate (usually dynamically created through the scene using the camera) and tests to see if anything lies between those two points; if anything is hit, this results in a Raycast hit with relevant data about what it was.</p></div></div></div>