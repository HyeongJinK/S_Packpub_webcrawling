<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec31"></a>Measuring performance with the built-in Android profiler</h2></div></div><hr /></div><p>Let's look at what kind of <a id="id368" class="indexterm"></a>information we<a id="id369" class="indexterm"></a> can see from the built-in Android profiler in Unity 5.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec70"></a>General CPU activity</h3></div></div></div><p>Next, we're going to talk about the<a id="id370" class="indexterm"></a> information we can get from the built-in profiler. To make it easier to understand the structure of these messages, we'll cover them in groups. The first group includes the general information or in other words the overall performance statistics on the CPU.</p><p>You will see the total time that was spent by the CPU in the parameter value called <code class="literal">cpu-player</code>. The time that was spent on the CPU side by the OpenGLES driver code will be seen in the value of the parameter called <code class="literal">cpu-ogles-drv</code>. Next, let's consider the following parameter, known as <code class="literal">cpu-waits-gpu</code>. This option will not appear in the built-in profiler for very small values. This value shows how much CPU time was spent waiting for the end of rendering on the GPU side. Next, let's consider the following parameter, known as <code class="literal">msaa-resolve</code>. This value shows how much CPU time was spent on anti-aliasing methods. Let's consider the following parameter, known as <code class="literal">cpu-present</code>. This value shows how much CPU time was spent on executing the OpenGLES <code class="literal">presentRenderbuffer</code> function. Let's also look at the value of the last parameter in this group, known as <code class="literal">frametime</code>. This<a id="id371" class="indexterm"></a> value shows the time spent on the CPU side for frame execution.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"></a>Note</h3><p>Refresh rate of the Android hardware is locked at about 60 Hz, so you will have the frame time at about ~16.7 ms (approximately 16.7 milliseconds we get from computingâ€”1000 milliseconds divided by 60 Hz).</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec71"></a>Rendering statistics</h3></div></div></div><p>Now let's consider the following group of<a id="id372" class="indexterm"></a> statistics based on the rendering. This group contains only four parameters. The first parameter is called a <code class="literal">draw call</code>. The true meaning of this value is to show draw calls quantified per frame. The second parameter of this group is known as <code class="literal">tris</code>. This value indicates how many triangles the renderer will process. The third parameter of this group is known as <code class="literal">verts</code>. This value shows how many vertices the renderer will process. The upper limit number for static geometry is 10,000 vertices and much lower for skinned geometry. Finally, the last parameter, which we will study in this group, is called <code class="literal">batched</code>. The value of this parameter greatly affects your performance, so try to reduce this value as much as possible. This value demonstrates the number of automatically batched draw calls, triangles, and vertices by the Unity engine.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note19"></a>Note</h3><p>In order to improve Unity engine batching, you should use shared materials everywhere possible for all available objects.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec72"></a>Detailed Unity player statistics</h3></div></div></div><p>Now, consider the following group of <a id="id373" class="indexterm"></a>statistics, which is more detailed. The first parameter in the detailed statistics of the built-in profiler is known as <code class="literal">physx</code>. This value indicates the time spent on physics engine execution. The text parameter is called <code class="literal">animation</code>. This value indicates the time spent on bone animations. The third parameter in the detailed statistics is called <code class="literal">culling</code>. This value indicates how much time was spent culling the object's execution. The fourth parameter in the detailed statistics of the built-in profiler is known as <code class="literal">skinning</code>. This value indicates the time we need to apply animations to skinned meshes. The fifth parameter in this detailed statistics is called <code class="literal">batching</code>. This value shows the time spent on batching geometry execution.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note20"></a>Note</h3><p>Batching static geometry is less expensive versus batching dynamic geometry.</p></div><p>The sixth parameter in the <a id="id374" class="indexterm"></a>detailed statistics is called <code class="literal">render</code>. This value represents the execution time spent on rendering visible objects. The seventh parameter is called <code class="literal">fixed-update-count</code>. This value shows the upper and lower values of the <code class="literal">FixedUpdate</code> execution time for the current frame. Try to decrease this value as much as possible because it can decrease your performance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec73"></a>Detailed script statistics</h3></div></div></div><p>There are just three obtainable<a id="id375" class="indexterm"></a> parameters. The first one is known as <code class="literal">update</code>. This value determines the time used for execution per <code class="literal">Update</code> function in your scripts. The next parameter is called <code class="literal">fixedUpdate</code>. This value demonstrates the time used for all executions per <code class="literal">FixedUpdate</code> function in your scripts. The following parameter is known as <code class="literal">coroutines</code>. This value determines the time utilized for coroutines execution in your scripts.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec74"></a>Detailed statistics on memory allocated by scripts</h3></div></div></div><p>Let's cover the following <a id="id376" class="indexterm"></a>group of statistics based on detailed statistics for memory allocation by your scripts. There are only four parameters. The first parameter is called <code class="literal">allocated heap</code>. </p><p>This value represents available memory for allocation. If we need more memory than is available in the heap, a garbage collector will be called. However, if the garbage collector cannot free up more memory for us, then the heap will be increased in size. The next parameter is known as <code class="literal">used heap</code>. This value indicates the allocated heap by objects. It will be increased for each new class instance, and not for structs before the garbage collector will be called one more time. The following parameter is known as <code class="literal">max numbers of collections</code>. This value shows the quantity of the garbage collector calls within the last 30 frames. The last parameter in this group, and the last one in the built-in profiler, is called <code class="literal">collection total duration</code>. This value displays the summarized milliseconds used for the garbage collector calls within the last 30 frames.</p></div></div>