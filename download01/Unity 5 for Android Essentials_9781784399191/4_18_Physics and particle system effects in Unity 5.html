<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec21"></a>Physics and particle system effects in Unity 5</h2></div></div><hr /></div><p>Physics <a id="id252" class="indexterm"></a>for 2D and 3D in Unity are very similar, because they use the same concepts like Ias rigidbodies, joints, and colliders. However, Box2D has more features than Unity's 2D physics engine. It is not a problem to mix 2D and 3D physics engines (built-in, custom, third-party) in Unity. So, Unity provides an easy development way for your innovative games and applications.</p><p>If you need to develop <a id="id253" class="indexterm"></a>some real-life physics in your project, then you should not write your own library, framework, or engine, except specific requirements. However, you should try existing physics engines, libraries, or frameworks with many features already made.</p><p>Let's start our introduction into Unity's built-in physics engine. In the case that you need to set your object under Unity's built-in physics management, you just need to attach the Rigidbody component to this object. After that, your object can collide with other entities in its world and gravity will have an affect on it. In other words, Rigidbody will be simulated physically. In your scripts, you can move any of your Rigidbodies by adding vector forces to them.</p><p>It is not recommended to move the Transform component of a non-kinematic Rigidbody, because it will not collide correctly with other items. Instead, you can apply forces and torque to your Rigidbody.</p><p>A Rigidbody<a id="id254" class="indexterm"></a> can be used also to develop cars with wheel colliders and with some of your scripts to apply forces to it. Furthermore, a Rigidbody is used not <span class="emphasis"><em>only</em></span> for vehicles, but also you can use it for any other physics issues such as airplanes, robots with various scripts for applying forces, and with joints.</p><p>The most useful way to <a id="id255" class="indexterm"></a>utilize a Rigidbody is to use it in collaboration with some primitive colliders (built-in in Unity) such as <code class="literal">BoxCollider</code> and <code class="literal">SphereCollider</code>. Next, we will show you two things to remember about Rigidbody:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In your object's hierarchy, you must never have a child and its parent with the Rigidbody component together at the same time</p></li><li style="list-style-type: disc"><p>It is not recommended to scale Rigidbody's parent object</p></li></ul></div><p>One of the most important and fundamental components of physics in Unity is a Rigidbody component. This component activates physics calculations on the attached object. If you need your object to react to collisions( for example, while playing billiards, balls collide with each other and scatter in different directions) then you must also attach a <code class="literal">Collider</code> component on your GameObject. If you have attached a Rigidbody component to your object, then your object will move through the physics engine, and I recommend that you do not move your object by changing its position or rotation in the <code class="literal">Transform</code> component. If you need some way to move your object, you should apply the various forces acting on the object so that the Unity physics engine assumes all obligations for the calculation of collisions and moving dynamic objects. Also, in some situations, there is a need for a Rigidbody component, but your object must be moved only by changing its position or rotation properties in the <code class="literal">Transform</code> component. It is sometimes necessary to use components without Rigidbody calculating collisions of the object and its motion physics. That is, your object will move by your script or, for example, by running your animation. In order to solve this problem, you should just activate its <code class="literal">IsKinematic</code> property. Sometimes, it is required to use a combination of these two modes when <code class="literal">IsKinematic</code> is turned on and when it is turned off. You can create a symbiosis of these two modes, changing the <code class="literal">IsKinematic</code> parameter directly in your code or in your animation.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip02"></a>Tip</h3><p>Changing the <code class="literal">IsKinematic</code> property very often from your code or from your animation can be the cause of overhead in your performance. Therefore, you should use it very carefully and only when you really need it.</p></div><p>A kinematic Rigidbody object is defined by the <code class="literal">IsKinematic</code> toggle option. If a Rigidbody is <code class="literal">Kinematic</code>, this object will not be affected by collisions, gravity, or forces.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>There is a Rigidbody component for 3D physics engine and an analogous Rigidbody2D for 2D physics engine.</p></div><p>A kinematic Rigidbody<a id="id256" class="indexterm"></a> can interact with other non-kinematic Rigidbodies. In the event of using kinematic Rigidbodies, you should translate their positions and rotation values of the <code class="literal">Transform</code> component by your scripts or animations. When there is a collision between Kinematic and non-kinematic Rigidbodies, then the Kinematic object will properly wake up non-kinematic Rigidbody. Furthermore, the first Rigidbody will apply friction to the second Rigidbody if the second object is on top of the first object.</p><p>Let's list some possible usage<a id="id257" class="indexterm"></a> examples of kinematic Rigidbodies:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>There are situations when you need your objects to be under physics management, but sometimes to be controlled explicitly from your scripts or animations. As an example, you can attach Rigidbodies to the bones of your animated personage and connect them with joints in order to utilize your entity as a ragdoll. If you are controlling your character by Unity's animation system, you should enable the <code class="literal">IsKinematic</code> checkbox. Sometimes you may require your hero to be affected by Unity's built-in physics engine if you are hitting the hero. In this case you should disable the <code class="literal">IsKinematic</code> checkbox.</p></li><li style="list-style-type: disc"><p>If you need a moving item that can push different items, yet not by itself. In case you have a moving platform and you need to place some Rigidbody objects on top, you ought to enable the <code class="literal">IsKinematic</code> checkbox rather than simply attaching a collider without a Rigidbody.</p></li><li style="list-style-type: disc"><p>You may need to enable the <code class="literal">IsKinematic</code> property of your Rigidbody object that is animated and has a genuine Rigidbody follower by utilizing one of the accessible joints.</p></li></ul></div><p>Earlier, I mentioned the collider, but now is the time to discuss this component in more detail. In the case of Unity, the physics engine can calculate collisions. You must specify geometric shapes for your object by attaching the <code class="literal">Collider</code> component. In most cases, the collider does not have to be the same shape as your mesh with many polygons. Therefore, it is desirable to use simple colliders, which will significantly improve your performance, otherwise <a id="id258" class="indexterm"></a>with more complex geometric shapes you risk significantly increasing the computing time for physics collisions. Simple colliders in Unity are known as primitive colliders: <code class="literal">BoxCollider</code>, <code class="literal">BoxCollider2D</code>, <code class="literal">SphereCollider</code>, <code class="literal">CircleCollider2D</code>, and <code class="literal">CapsuleCollider</code>. Also, no one forbids you to combine different primitive colliders to create a more realistic geometric shape that the physics engine can handle very fast compared to <code class="literal">MeshCollider</code>. Therefore, to accelerate your performance, you should use primitive colliders wherever possible. You can also hang on to the child objects of different primitive colliders, which will change its position and rotation, depending on the parent <code class="literal">Transform</code> component. The Rigidbody component must be attached only to the GameObject root in the hierarchy of your entity.</p><p>Unity provides a <code class="literal">MeshCollider</code> component for 3D physics and a <code class="literal">PolygonCollider2D</code> component for 2D physics. The <code class="literal">MeshCollider</code> component will use your object's mesh for its geometric shape. In <code class="literal">PolygonCollider2D</code>, you can edit directly in Unity and create any 2D geometry for your 2D physical computations. In order to react in collisions between different mesh colliders, you must enable a <code class="literal">Convex</code> property. You will certainly sacrifice performance for more accurate physics calculations, but if you have the right balance between quality and performance, then you can achieve good performance only through a proper approach.</p><p>Objects are static when they have a <code class="literal">Collider</code> component without a Rigidbody component. Therefore, you should not move or rotate them by changing properties in their <code class="literal">Transform</code> component, because it will leave a heavy imprint on your performance as a physics engine should recalculate many polygons of various objects for right collisions and ray casts. Dynamic objects are those that have a Rigidbody component. Static objects (attached with the <code class="literal">Collider</code> component and without Rigidbody components) can interact with dynamic objects (attached with <code class="literal">Collider</code> and Rigidbody components). Furthermore, static objects will not be moved by collisions like dynamic objects.</p><p>Also, Rigidbodies can sleep in order to increase performance. Unity provides the ability to control sleep in a Rigidbodies component directly in the code using following functions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">Rigidbody.IsSleeping()</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">Rigidbody.Sleep()</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">Rigidbody.WakeUp()</code>
</p></li></ul></div><p>There are two variables characterized in the physics manager. You can open physics manager right from Unity menu here: <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> |<span class="strong"><strong> Physics</strong></span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">Rigidbody.sleepVelocity</code>: The default value is <code class="literal">0.14</code>. This indicates lower limitations for linear velocity (from zero to infinity) below which objects will sleep.</p></li><li style="list-style-type: disc"><p>
<code class="literal">Rigidbody.sleepAngularVelocity</code>: The default value is <code class="literal">0.14</code>. This indicates lower limitations for angular velocity (from zero to infinity) below which objects will sleep.</p></li></ul></div><p>Rigidbodies awaken when:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>An alternate Rigidbody impacts the resting Rigidbody</p></li><li style="list-style-type: disc"><p>An alternate Rigidbody was joined through a joint</p></li><li style="list-style-type: disc"><p>At the point of adjusting a property of the Rigidbody</p></li><li style="list-style-type: disc"><p>At the point of adding force vectors</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p>A<a id="id259" class="indexterm"></a> kinematic Rigidbody can wake the other sleeping Rigidbodies while static objects (attached with a <code class="literal">Collider</code> component and without a Rigidbody component) can't wake your sleeping Rigidbodies.</p></div><p>The PhysX physics engine which is integrated into Unity works well on mobile devices, but mobile devices certainly have far fewer resources than powerful desktops.</p><p>Let's look at a few points to optimize the physics engine in Unity:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>First of all, note that you can adjust the <code class="literal">Fixed Timestep</code> parameter in the time manager in order to reduce costs for the physical execution time updates. If you increase the value, you can increase the quality and accuracy of physics in your game or in your application, but you will lose the time to process. This can greatly reduce your productivity, or in other words, it can increase CPU overhead.</p></li><li style="list-style-type: disc"><p>The maximum allowed timestep indicates how much time will be spent in the worst case for physical treatment.</p></li><li style="list-style-type: disc"><p>The total processing time for physics depends on the awake rigidbodies and colliders in the scene, as well as the level of complexity of the colliders.</p></li></ul></div><p>Unity provides the ability to use physical materials for setting various properties such as friction and elasticity. For example, a piece of ice in your game may have very low friction or equal to zero (minimum value), while a jumping ball may have a very high friction force or equal to one (maximum value) and also very high elasticity. You should play with the settings of your physical materials for different objects and choose the most suitable solution for you and the best solution for your performance.</p><p>Triggers do not require a lot of processing costs by the physics engine and can greatly help in improving your performance. Triggers are useful in situations where, for example, in your game you need to identify areas near all lights that are automatically turned on in the evening or night if the player is in its trigger zone or in other words within the geometric shape of its collider, which you can design as you wish. Unity triggers allow writing the three callbacks, which will be called when your object enters the trigger, while your object is staying in trigger, and when this object leaves the trigger. Thus, you can register any of these functions, the necessary instructions, for example, turn on the flashlight when entering the trigger zone or turn it off when exiting the trigger zone. It is important to know that in Unity, static objects (objects without a Rigidbody component) will not cause your callbacks to get into the zone trigger if your trigger does not contain a Rigidbody component; that is, in other words at least one of these objects must have a Rigidbody component in order to not ignore your callbacks. In the case of two triggers, there should be at least one object <a id="id260" class="indexterm"></a>attached with a Rigidbody component to your callbacks were not ignored. Remember that when two objects are attached with Rigidbody and <code class="literal">Collider</code> components and if at least one of them is the trigger, then the trigger callbacks will be called and not the collision callbacks. I would also like to point out that your callbacks will be called for each object included in the collision or trigger zone. Also, you can directly control whether your collider is a trigger or not by setting the flag <code class="literal">isTrigger</code> value to <code class="literal">true</code> or <code class="literal">false</code> in your code. Of course, you can mix both options in order to obtain the best performance. All collision callbacks will be called only if at least one of two interacted rigidbodies is not kinematic. I suggest you consider code samples for collision callbacks.</p><p>The first example callback, which will be called at the start of the collision event:</p><div class="informalexample"><pre class="programlisting">void OnCollisionEnter (Collision collision)</pre></div><p>The second example callback, which will be called while staying in the collision state:</p><div class="informalexample"><pre class="programlisting">void OnCollisionStay (Collision collision)</pre></div><p>The third example callback, which will be called at the end of the collision event:</p><div class="informalexample"><pre class="programlisting">void OnCollisionExit (Collision collision)</pre></div><p>The fourth example callback, which will be called at the start of the collision event is much more optimized because it avoids a collision input parameter and thus avoids extra calculations:</p><div class="informalexample"><pre class="programlisting">void OnCollisionEnter ()</pre></div><p>The fifth example callback, which will be called while staying in the collision state is much more optimized because it avoids a collision input parameter and thus avoids extra calculations:</p><div class="informalexample"><pre class="programlisting">void OnCollisionStay ()</pre></div><p>The sixth example callback, which will <a id="id261" class="indexterm"></a>be called at the end of the collision event is more optimized because it avoids the collision input parameter and thus avoids extra calculations:</p><div class="informalexample"><pre class="programlisting">void OnCollisionExit ()</pre></div><p>The seventh example callback, which will be called on entering the trigger collider:</p><div class="informalexample"><pre class="programlisting">void OnTriggerEnter (Collider collider)</pre></div><p>The eighth example callback, which will be called while staying in the trigger collider:</p><div class="informalexample"><pre class="programlisting">void OnTriggerStay (Collider collider)</pre></div><p>The ninth example callback, which will be called on exiting the trigger collider:</p><div class="informalexample"><pre class="programlisting">void OnTriggerExit (Collider collider)</pre></div><p>The tenth example callback, which will be called on entering the trigger without the collider input parameter. This callback will be faster than with the collider input parameter:</p><div class="informalexample"><pre class="programlisting">void OnTriggerEnter ()</pre></div><p>The eleventh example callback, which will be called on the enter trigger without the collider input parameter. This callback will be faster than with the collider input parameter:</p><div class="informalexample"><pre class="programlisting">void OnTriggerStay ()</pre></div><p>The twelfth example callback, which will be called on exiting the trigger without the collider input parameter. This callback will be faster than with the collider input parameter:</p><div class="informalexample"><pre class="programlisting">void OnTriggerExit ()</pre></div><p>Now, let's talk about joints. If you need to attach one Rigidbody to another Rigidbody in order to rotate it around a specific point and axis, for example a hinged door, then you should use HingeJoint (for 2D appropriate name is HingeJoint2D). Unity also provides other types of joints; for example, spring joint is suitable in cases when you need to develop a trampoline or something similar. However, I strongly advise you not to use joints everywhere because that can ruin your performance. Use only what is truly necessary and as often as is really required. The most important thing to improve your performance is to remove all unnecessary things.</p><p>You can also use a <code class="literal">CharacterController</code> component for creating a first person game. The <code class="literal">CharacterController</code> component uses its own physics calculations separately from Rigidbody. </p><p>These are very convenient for walking on different surfaces around the <span class="emphasis"><em>y</em></span> axis without rotation and maintaining the necessary balance in the case of a Rigidbody component. The <code class="literal">CharacterController</code> component also requires much less processing time compared to a Rigidbody. That's why you should try to use <code class="literal">CharacterController</code> whenever possible instead of Rigidbody, but try to make as few as possible like everything else. The <code class="literal">CharacterController</code> component has <code class="literal">CapsuleCollider</code>, which contains upwards along the <span class="emphasis"><em>y</em></span> axis. Next, you will research the <code class="literal">CharacterController</code> properties as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_04_04.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec56"></a>Particle system performance tips and tricks</h3></div></div></div><p>A particle system uses a large<a id="id262" class="indexterm"></a> number of small particles or, in other words, a huge amount of graphical objects in order to create different effects such as dust, rain, snow, fire, explosions, smoke, a waterfall, falling leaves, fog, stars, galaxies, fireworks, various magic effects, and so on. Usually a particle system emits a plurality of particles, which have their own life-time, after which they disappear gradually and are re-emitted. There are also different techniques of using a particle system to create fur, hair, grass, where the particles do not disappear, but they live for a very long time.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"></a>Note</h3><p>Particle systems may be 2D or 3D.</p></div><p>Mathematically, each particle is represented as a point mass with additional attributes, such as appearance, speed, orientation in space, angular velocity, and so on. In the course of the program, each particle changes its state with a specific formula, common to all particles in the system. For example, the particle may be exposed to gravity, to change its size, color, speed, and so on. After all calculations, the particle will be visualized. A particle can be visualized by point, triangle, sprite, or even a full three-dimensional model.</p><p>Currently, there is no uniform implementation of particle systems. In different games and apps, 3D modeling properties, behavior, and appearance of the particles may be fundamentally different.</p><p>In most implementations, new particles are emitted by a so-called <a id="id263" class="indexterm"></a>
<span class="strong"><strong>emitter</strong></span>. If the emitter is a point, the new particles will then occur in the same place. Therefore, it is possible to simulate, for example, an explosion—the emitter is its center. An emitter can be a line, segment, or a plane; for example rain or snow particles should occur at high horizontal planes. The emitter may have an arbitrary geometrical object, and in this case, the new particles will emerge on the entire surface thereof.</p><p>Throughout the lifetime of the particle, the particle is rarely static. Particles can move, rotate, change color and/or transparency, and may deal with three-dimensional objects. Often, particles set the<a id="id264" class="indexterm"></a> maximum life span, after which the particle disappears.</p><p>In three-dimensional, real-time applications or computer games it is generally considered that the particles do not cast shadows on one another and on the geometry of the environment and they do not absorb and emit light. Without these, the simplified particle system will require more resources; in the case of absorption of light, the particles need to be sorted by distance from the camera, and in the case of each particle shadows have to paint several times.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec20"></a>Legacy versus Shuriken Unity's built-in particle systems</h4></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Some <a id="id265" class="indexterm"></a>of Shuriken's <a id="id266" class="indexterm"></a>module's properties cannot be achieved in your scripts.</p></li><li><p>At the same time, the Legacy particle system's properties can be achieved in your scripts.</p></li><li><p>You can turn <code class="literal">emission</code> on and off as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  public ParticleSystem yourParticleSystemVariable;
  void YourMethodName() {
    yourParticleSystemVariable.enableEmission = false;
  }</pre></div></li></ol></div><p>In event of emitting particles in explosions, you should use the <code class="literal">Emit</code> function as shown in the following code example:</p><div class="informalexample"><pre class="programlisting">  public ParticleSystem yourParticleSystemVariable;
  void YourMethodName() {
    yourParticleSystemVariable.Emit(123); //emits 123 particles
  }</pre></div><p>Instead of activating and deactivating the <code class="literal">emission</code> property, you can also control the particles in your emitter as shown here:</p><div class="informalexample"><pre class="programlisting">  public ParticleSystem yourParticleSystem;
  private ParticleSystem.Particle[] 
      yourParticlesList = new ParticleSystem.Particle[1750];
  void YourMethodName() {
    int len = yourParticleSystem.GetParticles(yourParticlesList);
    for(int i=0; i &lt; len; i++) {
          yourParticlesList[i].color = new Color(0,0,1,0.5f);
      }
    yourParticleSystem.SetParticles(yourParticlesList, len);
  }</pre></div><p>Let's list obtainable properties <a id="id267" class="indexterm"></a>of the <code class="literal">Particle</code> class (<a class="ulink" href="http://docs.unity3d.com/ScriptReference/ParticleSystem.Particle.html" target="_blank">http://docs.unity3d.com/ScriptReference/ParticleSystem.Particle.html</a>):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">lifetime</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">startLifetime</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">position</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">rotation</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">color</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">size</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">velocity</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">randomValue</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">angularVelocity</code>
</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>Creating the<a id="id268" class="indexterm"></a> Shuriken <a id="id269" class="indexterm"></a>particle system in Unity is very simple. You just need to navigate to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Other</strong></span> | <span class="strong"><strong>Particle Systems</strong></span>. This will create an instance of the Shuriken Particle System for you to play with.</p><p>To make a Legacy particle system, you have to make a <code class="literal">void</code> GameObject or join the Legacy particle system to an accessible GameObject.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec21"></a>Particle system tips</h4></div></div></div><p>There are numerous things that <a id="id270" class="indexterm"></a>can kill the frame rate in an up-to-date game, and particles are up close to the highest on the rundown of reasons. A key component is that particles are liable to a great deal of overdraw that is not displayed in your opaque geometry.</p><p>The purpose behind the increment in overdraw is that for particles, we have a tendency to have heaps of distinctive primitives (typically quads) that are covered, maybe to copy impacts like flame or smoke. Regularly, every particle primitive is translucent (alpha-mixed), so the z-buffer is not overhauled as pixels are composed and we wind up rendering to pixels at different times. (Interestingly, for hazy geometry, we do keep in touch with the z-buffer, so between a conceivable z-prepass, sorting items front-to-back, progressive z-culling on the GPU, and ordinary profundity testing, the effect is that we have almost no overdraw.)</p><p>Overdraw, thus, prompts expanded employments of both <code class="literal">fillrate</code> (how many pixels the fittings can render to for every second) and <code class="literal">bandwidth</code> (how much information you can exchange to/from the GPU for every second), both of which may be rare assets.</p><p>We concur that particles can result in a considerable measure of issues. Luckily, there are heaps of things that are able to improve the rendering side of a particle system.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Use opaque particles</strong></span>: For <a id="id271" class="indexterm"></a>example, make smoke effects truly thick so that (some or the sum of) the molecule boards will be obscure, with set pattern alpha. For a few particles, in the same way as shrapnel, rocks, or comparable objects, use lightweight geometry particles rather than sprites with alpha borders.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Use wealthier particles</strong></span>: Put more oomph in a solitary molecule sprite so that you require fewer of them. Use flip book surfaces to make surging in for example fire and smoke, instead of stacking sprites.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Top aggregate sum of particles</strong></span>: Use fittings counters on the graphics card to obtain the number of particle pixels that have been rendered, and quit discharging or drawing particles when passing a certain breaking point (which may be set dynamically).</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Decrease state changes</strong></span>: Share shaders between particles. You can get this by, for example, dropping characteristics for far off particles (for example, dropping the normal map at the earliest opportunity).</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Make particles front-to-back premultiplied-alpha style</strong></span>: Using premultiplied alpha (which is cooperative), you can mix particles front-to-back rather than the ordinary back-to-front requesting. The thought here is to utilize the front-to-back attracting to fill a stencil buffer when alpha gets (close) strong and at last, quit drawing particles all together (when they generally won't help the visual scene much).</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Bunch particles together into one molecule entity</strong></span>: Instead of drawing two covering particles separately, you can structure a solitary (bigger) molecule that incorporates the two particles and performs the mixing of the two particles in a staightforward manner in the shader. This has a tendency to decrease the measure of the frame buffer understands we do, as we just need to mix one molecule.</p></li></ul></div></div></div></div>