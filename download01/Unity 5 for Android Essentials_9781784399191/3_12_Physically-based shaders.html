<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec16"></a>Physically-based shaders</h2></div></div><hr /></div><p>Unity makes it very easy to use<a id="id168" class="indexterm"></a> ready shaders or write your own shaders using the Cg language or the surface shaders framework. Surface shaders are written in Cg, but they do a large amount of work that you do not have to write every time when you create a new shader. The surface shader language uses a component-based approach, or in other words a more abstract approach that facilitates writing complex shaders using a sophisticated lighting model. While using the surface shaders framework, graphics programmers do not have to keep reprocessed texture coordinates and matrix transformations. In this chapter, we will describe the different techniques and methods of writing performance-friendly shaders in great detail with nice visual quality effects used in a variety of games and applications developed throughout the world.</p><p>First, let's start with the basic principles and concepts of a shaders. A shader is a pre-compiled program for one of the number of stages of the graphics pipeline used in three-dimensional graphics to determine the final parameters of the object or image. It may include a description of arbitrary complexity absorption and scattering of light, texture mapping, reflection and refraction, shading, surface displacement, and postprocessing effects.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec43"></a>Basic shader concepts</h3></div></div></div><p>Programmable shaders <a id="id169" class="indexterm"></a>are flexible and effective. Seemingly complex surfaces <a id="id170" class="indexterm"></a>can be visualized with simple geometric forms. For example, the shaders can be used to draw a three-dimensional surface of the ceramic tiles on a completely flat surface.</p><p>In Unity, shaders are divided into three types: <span class="strong"><strong>vertex</strong></span>, <span class="strong"><strong>geometry</strong></span>, and <span class="strong"><strong>fragment (pixel)</strong></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec07"></a>The vertex shader</h4></div></div></div><p>The <span class="strong"><strong>vertex shader</strong></span>
<a id="id171" class="indexterm"></a> manipulates data mapped to the vertices of polyhedra. This data <a id="id172" class="indexterm"></a>corresponds to the coordinates of the vertices in space, texture coordinates, a tangent vector, a bi-normal vector, and a normal vector. The vertex shader can be used for perspective vertices transformation, for generating texture coordinates, for lighting calculations, and so on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec08"></a>The geometry shader</h4></div></div></div><p>The <span class="strong"><strong>geometry shader</strong></span>, in<a id="id173" class="indexterm"></a> contrast to the vertex shader, is able to handle not only one <a id="id174" class="indexterm"></a>vertex, but also a whole primitive with a set of vertexes (triangles, quads, and so on). It can be cut (two vertices) and triangular (three vertices), and the information on adjacent vertices (adjacency) can be processed for up to six vertices of the triangular primitive. Furthermore, the geometry shader can generate primitives "on the fly," without using a central processor. They were first used on the <span class="emphasis"><em>Nvidia 8</em></span> series.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec09"></a>The pixel/fragment shader</h4></div></div></div><p>The <span class="strong"><strong>pixel shader</strong></span> works<a id="id175" class="indexterm"></a> with fragments of the bitmap. A pixel shader<a id="id176" class="indexterm"></a> is used in the last stage of the graphics pipeline to generate a fragment of the picture.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec44"></a>Shading languages</h3></div></div></div><p>Shading languages <a id="id177" class="indexterm"></a>usually <a id="id178" class="indexterm"></a>contain special data types such as matrices, samplers, vectors, and a set of built-in variables and constants for easy integration with different 3D libraries. As computer graphics have many application areas, to meet the different needs of the market, developers created a large number of shader languages.</p><p>These shading languages are focused on delivering the highest quality image. Describing the properties of materials made at the highest abstract level to work do not need any special skills or knowledge of programming hardware. Such shaders are usually created by artists in order to ensure "the right kind" such as texture mapping, light sources, and other aspects of art and science at the same time.</p><p>Processing these shaders is usually a resource-intensive task. The aggregate computing power needed for this work can be very high, as it is used to create photo-realistic images. The main part of the similar computation is performed by a visualization of large computer clusters.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec10"></a>Cg</h4></div></div></div><p>The <a id="id179" class="indexterm"></a>Cg shading<a id="id180" class="indexterm"></a> language developed by Nvidia in conjunction with Microsoft (essentially the same language from Microsoft is called <span class="strong"><strong>HLSL</strong></span>, and is included in DirectX 9). Cg is used in Unity and stands as <a id="id181" class="indexterm"></a>
<span class="strong"><strong>C for Graphics</strong></span>. The language is very similar to C and it uses similar data types (<code class="literal">int</code>, <code class="literal">float</code>, and a special 16-bit floating point type—<code class="literal">half</code>). Cg also supports functions and structures. The language has peculiar optimizations like packed arrays—type declarations like <code class="literal">float a [4]</code> and <code class="literal">float4 a</code> are different types. The second announcement is a <a id="id182" class="indexterm"></a>
<span class="strong"><strong>packed array</strong></span>. The packed array operations are faster than conventional operations. Despite the fact that the language was developed by Nvidia, it works without problems with other graphics cards (for example, ATI cards). However, please note that all the shader programs have their own peculiarities, which can be obtained from specialized sources.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec11"></a>Unity shaders in Cg</h4></div></div></div><p>In addition, you should <a id="id183" class="indexterm"></a>know that Unity 5 comes with built-in shaders, which are very useful, <a id="id184" class="indexterm"></a>especially for some basic stuff required in many different games. Now let's start our wonderful journey into the world of Unity shaders in Cg language. Typically, shaders use diffuse components or a lighting model. First, you must understand what should be optimized in your shaders well. Basically, you should try to avoid complicated calculations and labor-intensive functions. In this chapter, firstly, we will examine the different techniques of lighting models that are so often used in game development and production stages. Lighting is one of the fundamental aspects of the shader. Therefore, programmers often use their approximate calculations for lighting to speed up performance.</p><p>Earlier, computer graphics were used as a fixed-function lighting model, which was not a very flexible solution, since it gave graphics programmers only a single lighting model that could only be adjusted by setting a finite set of parameters and textures. Unlike before, where a single fixed-lighting model was used, today, developers use a very flexible programmable approach to create different lighting models with the help of the Cg shader language, especially from the wonderful surface shaders in Unity.</p><p>The diffuse component in the shader will often specify exactly how the rays of light reflect from the surface in all directions. You may find that it is very similar to the work of a mirror that reflects the sun's rays at different angles and in all directions. However, it is not so, and we'll show you this difference in as much detail as possible later on in the chapter.</p><p>The main difference is that a reflective surface like a mirror reflects the image of the surrounding environment, while the diffuse lighting model reflects sunlight back into the field of view.</p><p>In order to create a simple<a id="id185" class="indexterm"></a> and basic diffuse lighting model, you will need to create a <a id="id186" class="indexterm"></a>shader that will contain an emissive color, an ambient color, and of course the total accumulation of color from all light sources. Techniques and tricks that we will show you in the following code will help you create your own lighting models, as well as explore various industry tricks to help you understand the basic ideas to create more complex lighting models using only the textures that will give a huge increase to your productivity. In other words, the use of premade textures to create lighting models can greatly increase your productivity.</p><p>Let's start with the simplest example of our surface shader as shown in the following code. The code was generated by the Unity Editor:</p><div class="informalexample"><pre class="programlisting">// The first line of our shader code specifies the name of the
// shader in order to further select it from a list of all 
// shaders.
Shader "PacktPub/SimpleDiffuseLighting"
{
  // Next is the properties block of parameters of the shader 
  // known as Properties, which is followed by a block of the 
  // shader code known as SubShader.
        Properties
        {
                _MainTex ("Base (RGB)", 2D) = "white" {}
        }
  
        SubShader
        {
                Tags {"RenderType" = "Opaque"}
                LOD 200

                CGPROGRAM
                #pragma surface surf Lambert

                sampler2D _MainTex;
                struct Input
                {
                        float2 uv_MainTex;
                };

                void surf (Input IN, inout SurfaceOutput o)
                {
                        half4 c = tex2D (_MainTex, IN.uv_MainTex);
                        o.Albedo = c.rgb;
                        o.Alpha = c.a;
                }
                ENDCG
        }

    // The shader specified as FallBack will be executed 
    // instead of our shader.
        FallBack "Diffuse"
}</pre></div><p>Let's consider the <code class="literal">Properties</code> block in<a id="id187" class="indexterm"></a> more detail. The properties are some of the very <a id="id188" class="indexterm"></a>important elements while writing shaders. The properties allow the artist to set their own textures or other settings to customize the visual effects. You can tune the properties of the selected shader through Unity materials.</p><p>Unity parses each shader code in order to find built-in structures. The <code class="literal">Properties</code> block is one of these built-in structures that Unity is looking for. Here is an example of the structure of the <code class="literal">Properties</code> block:</p><div class="informalexample"><pre class="programlisting">Properties
{
        _YourVariableName ("Inspector GUI Name", Color) = (1,1,1,1)
}
//      Variable Name   Inspector GUI Name     Type  Default Value</pre></div><p>Each time you create a new property, you will need to name your variable. The variable name is used in the code of your shader, while the inspector GUI name will be shown in the Unity Editor. The type can be any one of the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">Range (min, max)</code>: These are real numbers in the form of a slider from <code class="literal">min</code> to <code class="literal">max</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">Color</code>: This opens the color picker in the Unity inspector for choosing the desired color value</p></li><li style="list-style-type: disc"><p>
<code class="literal">2D</code>: This is used for adding textures</p></li><li style="list-style-type: disc"><p>
<code class="literal">Rect</code>: This is a nonpower of two textures</p></li><li style="list-style-type: disc"><p>
<code class="literal">Cube</code>: This is a cube map texture</p></li><li style="list-style-type: disc"><p>
<code class="literal">Float:</code> These are real values without the slider</p></li><li style="list-style-type: disc"><p>
<code class="literal">Vector</code>: This is a four-component vector with real numbers</p></li></ul></div><p>At the end of the <code class="literal">Properties</code> structure, we <a id="id189" class="indexterm"></a>specified the default <a id="id190" class="indexterm"></a>value.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec45"></a>A custom diffuse lighting model</h3></div></div></div><p>Before you write your <a id="id191" class="indexterm"></a>own diffuse lighting model, we will <a id="id192" class="indexterm"></a>consider our new properties:</p><div class="informalexample"><pre class="programlisting">Properties
{
        _FirstColor ("First Color", Color) = (1,1,1,1)
        _SecondColor ("Second Color", Color) = (0,0,0,0)
        _PowValue ("Pow Value", Range(0,10)) = 5.5
}</pre></div><p>Next, we need to declare these new properties in our shader:</p><div class="informalexample"><pre class="programlisting">float4 _FirstColor;
float4 _SecondColor;
float  _PowValue;</pre></div><p>After the announcement of the properties in the shader code, we can use these variables as shown here:</p><div class="informalexample"><pre class="programlisting">void surf (Input IN, inout SurfaceOutput surface)
{
        float4 c = pow(_FirstColor + _SecondColor, _PowValue);
        surface.Albedo = c.rgb;
        surface.Alpha = c.a;
}</pre></div><p>As a result, you should have a shader as shown here:</p><div class="informalexample"><pre class="programlisting">Shader "PacktPub/YourDiffuseLighting"
{
        Properties
        {
                _FirstColor ("First Color", Color) = (1,1,1,1)
                _SecondColor ("Second Color", Color) = (0,0,0,0)
                _PowValue ("Pow Value", Range(0,10)) = 3.5
        }
  
        SubShader
        {
                Tags {"RenderType" = "Opaque"}
                LOD 200

                CGPROGRAM
                #pragma surface surf Lambert

                float4 _FirstColor;
                float4 _SecondColor;
                float  _PowValue;
                float4 c;
                struct Input
                {
                        float2 uv_MainTex;
                };

                void surf (Input IN, inout SurfaceOutput surface)
                {
                        c = pow(_FirstColor + _SecondColor, _PowValue);
                        surface.Albedo = c.rgb;
                        surface.Alpha = c.a;
                }
                ENDCG
        }
  
        FallBack "Diffuse"
}</pre></div><p>It's time to create your <a id="id193" class="indexterm"></a>own diffuse lighting model. In most cases, no<a id="id194" class="indexterm"></a> built-in lighting is well-suited for specific tasks in the game or application. Specific optimization problems require unique solutions. In order to override the built-in lighting functions you need to register, the <code class="literal">SubShader</code> block in the next line of code:</p><div class="informalexample"><pre class="programlisting">#pragma surface surf YourName</pre></div><p>Now, we can describe our custom lighting function as shown in the following example:</p><div class="informalexample"><pre class="programlisting">inline float4 LightingYourName 
(SurfaceOutput surface, float3 lightDirection, float attenuation)
{
        float delta = max(0, dot(surface.Normal, lightDirection));
        c.rgb = (surface.Albedo * _LightColor0.rgb) * 
                                                (delta * attenuation * 2);
        c.a = surface.Alpha;
        return c;
}</pre></div><p>Now, let's systematically look at the fundamental elements. The <code class="literal">#pragma</code> directive specifies the name of the function to be used for lighting. We used the built-in feature called <span class="strong"><strong>Lambert</strong></span>
<a id="id195" class="indexterm"></a> defined in the <code class="literal">Lighting.cginc</code> file, and now we specified the name of our function for future use. In establishing this lighting function, it is necessary to remember that the name of the function will eventually be formed using the first word of <code class="literal">Lighting + &lt;Your Function Name&gt;</code>, that is, for example if you decide to call a function <code class="literal">SunShine</code>, then the name of your lighting function will be <code class="literal">LightingSunShine</code>. There are three<a id="id196" class="indexterm"></a> options to create your custom lighting <a id="id197" class="indexterm"></a>functions that differ from each other by their input parameters as shown here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">float4 Lighting&lt;YourName&gt; (SurfaceOutput surface, float3 lightDirection, float attenuation) {}</code>: You should use this function for forward rendering, when you don't need the view direction value</p></li><li style="list-style-type: disc"><p>
<code class="literal">float4 Lighting&lt;YourName&gt; (SurfaceOutput surface, float3 lightDirection, float3 viewDirection, float attenuation) {}</code>: You should use this function for forward rendering, when you need the view direction value</p></li><li style="list-style-type: disc"><p>
<code class="literal">float4 Lighting&lt;YourName&gt;_PrePass (SurfaceOutput surface, float4 light) {}</code>: You should use this function for deferred rendering</p></li></ul></div><p>Ultimately, you should get a shader as follows:</p><div class="informalexample"><pre class="programlisting">Shader "PacktPub/YourLightingModel"
{
        Properties
        {
                _FirstColor ("First Color", Color) = (1,1,1,1)
                _SecondColor ("Second Color", Color) = (0,0,0,0)
                _PowValue ("Pow Value", Range(0,10)) = 3.5
        }
  
        SubShader
        {
                Tags {"RenderType" = "Opaque"}
                LOD 200

                CGPROGRAM
                #pragma surface surf YourName

                float4 _FirstColor;
                float4 _SecondColor;
                float  _PowValue;
                float4 c;
    
                struct Input
                {
                        float2 uv_MainTex;
                };
    
                inline float4 LightingYourName (
                        SurfaceOutput surface, 
                        float3 lightDirection, 
                        float attenuation
                ){
                        float delta = max(0, dot(surface.Normal, lightDirection));
                        c.rgb = (surface.Albedo * _LightColor0.rgb) *
                                                (delta * attenuation * 2);
                        c.a = surface.Alpha;
                        return c;
                }

                void surf (Input IN, inout SurfaceOutput surface)
                {
                        c = pow(_FirstColor + _SecondColor, _PowValue);
                        surface.Albedo = c.rgb;
                        surface.Alpha = c.a;
                }
                ENDCG
        }
  
        FallBack "Diffuse"
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec12"></a>A basic reflection environment</h4></div></div></div><p>Next, let's look at other ideas <a id="id198" class="indexterm"></a>and techniques widely known in professional circles around the world that are used to write performance friendly shaders with nice visual effects. The following examples are based on environment reflections on your surface. A simple source code of this shader is shown here:</p><div class="informalexample"><pre class="programlisting">Shader "PacktPub/BasicReflectionEnvironment"
{
        Properties 
        {
                _DiffuseTint ("Diffuse Tint", Color) = (1,1,1,1)
                _MainTex ("Base (RGB)", 2D) = "white" {}
                _CubeMapTexture ("Cube Map Texture", CUBE) = ""{}
                _ReflectionCount ("Reflection Count", Range(0.01, 1)) = 0.17
        }
  
        SubShader 
        {
                Tags {"RenderType"="Opaque"}
                LOD 200
    
                CGPROGRAM
                #pragma surface surf Lambert

                sampler2D _MainTex;
                samplerCUBE _CubeMapTexture;
    
                float4 _DiffuseTint;
                float _ReflectionCount;
    
                float4 c;

                struct Input 
                {
                        float2 uv_MainTex;
                        float3 worldRefl;
                };

                void surf (Input IN, inout SurfaceOutput surface) 
                {
                        c = tex2D (_MainTex, IN.uv_MainTex) * _DiffuseTint;
                        surface.Emission = texCUBE(_CubeMapTexture, IN.worldRefl).rgb * _ReflectionCount;
                        surface.Albedo = c.rgb;
                        surface.Alpha = c.a;
                }
                ENDCG
        }
   
        FallBack "Diffuse"
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec13"></a>Masked texture reflection</h4></div></div></div><p>The next new shader <a id="id199" class="indexterm"></a>implements a new technique that uses a texture to mask the reflection of your environment, and it is shown here:</p><div class="informalexample"><pre class="programlisting">Shader "PacktPub/MaskedTextureReflection"
{
        Properties 
        {
                _DiffuseTint ("Diffuse Tint", Color) = (1,1,1,1)
                _MainTex ("Base (RGB)", 2D) = "white" {}
                _ReflectionCount ("Reflection Count", Range(0, 1)) = 1
                _CubeMapTexture ("Cube Map Texture", CUBE) = ""{}
                _MaskedTextureReflection ("Masked Texture Reflection", 2D) = ""{}
        }
  
        SubShader
        {
                Tags {"RenderType"="Opaque"}
                LOD 200
    
                CGPROGRAM
                #pragma surface surf Lambert

                sampler2D _MainTex;
                sampler2D _MaskedTextureReflection;
    
                samplerCUBE _CubeMapTexture;
    
                float4 _DiffuseTint;
                float _ReflectionCount;
    
                float4 c;

                struct Input 
                {
                        float2 uv_MainTex;
                        float3 worldRefl;
                };

                void surf (Input IN, inout SurfaceOutput surface) 
                {
                        c = tex2D (_MainTex, IN.uv_MainTex);
                        float3 reflectionTexCube = texCUBE(_CubeMapTexture, IN.worldRefl).rgb;
                        float4 reflectionMaskTexel = tex2D(_MaskedTextureReflection, IN.uv_MainTex);
  
                        surface.Albedo = c.rgb * _DiffuseTint;
                        surface.Emission = (reflectionTexCube * reflectionMaskTexel.r) * _ReflectionCount;
                        surface.Alpha = c.a;
                }
                ENDCG
        }
  
        FallBack "Diffuse"
}</pre></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec46"></a>Lighting model techniques</h3></div></div></div><p>Let's consider a variety of techniques and <a id="id200" class="indexterm"></a>methods of<a id="id201" class="indexterm"></a> implementation of the lighting model, which, like the previous shaders, are used worldwide in the game industry as well as in movies and cartoons.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec14"></a>The Lit sphere model</h4></div></div></div><p>To begin, we would like to<a id="id202" class="indexterm"></a> consider the <code class="literal">LitSphere</code> lighting model. The idea is <a id="id203" class="indexterm"></a>very simple and straightforward—we should just use a 2D texture in order to completely bake our light. Alternatively, it is necessary to take into account and not forget that this technique is static and does not change the lighting up until the texture used for baking light is changed. This technique gives very high-quality lighting and is optimized enough, but it is not dynamic. In other words, it does not depend on the angle or distance from the camera or from the viewer that can be changed in real time, because this technique does not depend on the lighting in the scene. Let's explore this shader as follows:</p><div class="informalexample"><pre class="programlisting">Shader "PacktPub/LitSphere" 
{
        Properties 
        {
                _DiffuseTint ("Diffuse Tint", Color) = (1,1,1,1)
                _MainTex ("Base (RGB)", 2D) = "white" {}
                _NormalMapTexture ("Normal Map Texture", 2D) = "bump" {}
        }
  
        SubShader
        {
                Tags {"RenderType"="Opaque"}
                LOD 200
    
                CGPROGRAM
                #pragma surface surf YourUnlit vertex:vert

                sampler2D _MainTex;
                sampler2D _NormalMapTexture;
                float4 _DiffuseTint;
    
                float4 c;
                float2 uv;
    
                inline float4 LightingYourUnlit (SurfaceOutput surface, float3 lightDirection, float attenuation)
                {
                        c.rgb = float4(1,1,1,1) * surface.Albedo;
                        c.a = surface.Alpha;
      
                        return c;
                }

                struct Input 
                {
                        float2 uv_MainTex;
                        float2 uv_NormalMapTexture;
      
                        float3 tangentOne;
                        float3 tangentTwo;
                };
    
void vert (inout appdata_full v, out Input inputData) 
{
        UNITY_INITIALIZE_OUTPUT(Input, inputData);
        
        TANGENT_SPACE_ROTATION;
            
        inputData.tangentOne = mul(rotation, UNITY_MATRIX_IT_MV[0].xyz);
        inputData.tangentTwo = mul(rotation, UNITY_MATRIX_IT_MV[1].xyz);          
}

                void surf (Input IN, inout SurfaceOutput surface) 
                {
                        surface.Normal = UnpackNormal(tex2D(_NormalMapTexture, IN.uv_NormalMapTexture)).rgb;

                        uv.x = dot(IN.tangentOne, surface.Normal);
                        uv.y = dot(IN.tangentTwo, surface.Normal);
    
                        c = tex2D (_MainTex, uv * 0.5 + 0.5);
                        surface.Albedo = c.rgb * _DiffuseTint;
                        surface.Alpha = c.a;
                }
                ENDCG
        } 
  
        FallBack "Diffuse"
}</pre></div><p>There are many different <a id="id204" class="indexterm"></a>techniques and approaches to create lighting models and <a id="id205" class="indexterm"></a>other visual effects; we cannot put all the ideas and techniques into this book, as it is beyond the scope of this book. You can also implement your own new ideas and techniques; it depends on your imagination. The previous examples of different approaches for writing shaders are widely used by developers around the world to create high-quality rendering in real time, and for optimization. Also, you can write shaders that work with the model vertices, so you can very simply create shader that will play the waves animation from the primitive plane.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec47"></a>Realistic rendering</h3></div></div></div><p>Marcos Fajardo of <span class="emphasis"><em>Solid Angle</em></span>—the company <a id="id206" class="indexterm"></a>behind the renderer <span class="emphasis"><em>Arnold</em></span>—noted <a id="id207" class="indexterm"></a>that more and more production studios in the world have either already come to that, or are in the process of transition with the following quote:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"The process is going on in the entire industry, and it's something. I've been working with this for the past ten years or so, and I'm really glad to see that this is happening at last."</em></span></p></blockquote></div><p>Fajardo can be called one of the greatest defenders and activists of global change in the industry. Solid Angle is really at the forefront of the large-scale movement to the path-traced GI with physically-plausible materials and lighting for production decisions (that is, when the budget is smaller and the time frame is more compressed).</p><p>The basis of the popularity of the "honest" method is the desire to "catch two rabbits at once," simplify the lives of artists around the world and to achieve a more realistic picture.</p><p>With some older technology chains, artists can get the scene with a few hundred light sources (where each source is needed to fulfill its role, one for the highlight of a material and the second for the specular reflection on this material, the third and fourth for the glare and reflections on the<a id="id208" class="indexterm"></a> second material, plus ten to simulate global illumination, and so on), with very complex shaders written by the developer with C++, the code was full of tricks and tweaks. Lighting designers often just sit, turning on and off lights, one after the other—it is easy to understand why some of them are so necessary.</p><p>Most companies do <a id="id209" class="indexterm"></a>not count the fact that the introduction of natural light sources and materials make a quick render itself, but there is an expectation that this will greatly facilitate the work of the artist. An hour of work which, to be honest, is a few tens of times more expensive than an hour rendering.</p></div></div>