<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec27"></a>Occlusion culling and level of detail in optimization techniques</h2></div></div><hr /></div><p>Let's look more closely and carefully at the basic principles of occlusion culling<a id="id300" class="indexterm"></a> in Unity (only Pro license) and how to use them in your projects to achieve excellent performance. </p><p>You can open the occlusion culling editor from the Unity menu as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_06_01.jpg" /></div><p>The main aim of the occlusion culling<a id="id301" class="indexterm"></a> mechanism is sifting and filtering off objects that are not visible in the camera area in order to improve optimization. This primarily means that the objects will not be using resources, only when necessary, with the result that of helping you create a game or app that will work much faster.</p><p>Frustum culling<a id="id302" class="indexterm"></a> is different from occlusion culling because it disables the renderers that are outside the view of the camera, but does not disable the renderers that overlap other renderers; for example, if a wall hides an object, it will be invisible for the camera. Using occlusion culling, you can automatically take the advantage of frustum culling. With the usage of visual occlusion culling technique, we can see in two examples as shown in the following screenshots:</p><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_06_02.jpg" /></div><p>In the screenshot shown here, you can see <a id="id303" class="indexterm"></a>occlusion culling in action:</p><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_06_03.jpg" /></div><p>The occlusion culling process in Unity uses a virtual camera that will scan the entire scene and create a hierarchy of potentially visible sets of objects. Then, this information will be used by other cameras in your game or in your application in real time, in order to reduce the number of draw calls and to improve your performance.</p><p>In order to use <a id="id304" class="indexterm"></a>occlusion culling, you need to set the <span class="strong"><strong>Occluder Static</strong></span> tag for each object in the scene to be processed by this optimization mechanism. Also, you can use another object's tag, which is called <span class="strong"><strong>Occludee Static</strong></span> as shown in the next screenshot. Occludees may be obscured by other objects and will be disabled in a similar situation to improve performance, but these objects cannot overlap other objects. Therefore, they will increase the performance of your entire project.</p><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_06_04.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>It is also very important to create areas for occlusion culling, only where the camera will render objects.</p></div><p>We just opened the basic and key aspects of the optimization by occlusion culling approach. We cannot describe all the details of the settings and features in this chapter. The following sections describe the various ideas, methods, approaches, and ways to optimize and improve performance. The purpose of the next section is to direct you on the right path to improve performance. You will use the desired optimization techniques from this chapter, and if it is necessary, you can find more detailed information about methods, implementations, and customizations from the web. Let's now consider another optimization technique known as<a id="id305" class="indexterm"></a> <span class="strong"><strong>Level Of Detail</strong></span> (<span class="strong"><strong>LOD</strong></span>).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec61"></a>Optimizing by LOD</h3></div></div></div><p>The LOD optimization technique is a method of reducing the complexity of frame rendering by reducing the total number of polygons, textures, and other resources in the scene, the general decline in its complexity. A simple example is that the main character model consists of 10,000 polygons. In cases where the treated stage is located close to the camera, it is important to use all the polygons. However, at a great distance from the camera, in the final image, it will take only a few pixels; there is no sense in handling all 10,000 polygons. Perhaps, in this case, it would be enough for hundreds of polygons, or even a couple of pieces and textures, specially prepared for about the same display model. Accordingly, at intermediate distances, it makes sense to use a model consisting of a number of triangles greater than the simplest model and smaller than the most complex.</p><p>The LOD<a id="id306" class="indexterm"></a> method is commonly used for modeling and rendering three-dimensional scenes using multiple difficulty levels (geometric or some other) for the objects in proportion to their distance from the camera. Changing complexity, particularly in the number of triangles in the model may be performed automatically, is based on a three-dimensional model of highest complexity, but can be on the basis of several predefined patterns with different levels of detail. Using a model with less detail for different distances, you will reduce rendering design complexity, almost without compromising the overall image detail.</p><p>The method is particularly effective when the number of objects in the scene is large, and they are located at different distances from the camera. For example, consider a sports game, such as football game or a hockey simulator. Low-poly character models are used when they are away from the camera, but when it approaches, the models are replaced by a large number of polygons. This example is very simple, and it shows that the essence of the method is based on two levels of detail of the model, but no one bothers to create multiple levels of detail. In order to effect change, the LOD level was not too obvious, so the object detail gradually grows.</p><p>Consider the following factors that have an effect on the level of detail technique: the total number of objects on the screen (when one or two characters in the frame, use complex models, and when 10â€“20, they are switched to a simpler model) or the FPS (predetermined limited values of the FPS, which varies with the level of detail, such as FPS below 30 reduces the complexity of the models on the screen, while 60 FPS raises the complexity). Other possible factors that affect the level of detail are as follows: the speed of movement of the object (in case of a rocket in motion you see it moving fast, but a snail moves slowly), the importance of a character from the game's point of view (for example, in football, the player models you see the closest and most often uses more complex geometry and texture). It all depends on the desires and capabilities of a particular developer. The main thing is to not overdo it; frequent and noticeable changes in the level of detail will be annoying.</p><p>We want to remind you that the level of detail does not necessarily refer only to the geometry. The method can also be used to save other resources: texturing (although GPUs use mipmapping, sometimes it makes sense to change the texture on the fly on the other with some detail), lighting technician (close objects covered by a complex algorithm, and distant objects covered by a prime), and texturing techniques.</p></div></div>