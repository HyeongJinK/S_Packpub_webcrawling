<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec33"></a>Real-practice techniques</h2></div></div><hr /></div><p>There are two different performance <a id="id404" class="indexterm"></a>optimization techniques that are used by many professional developers from all over the world.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec82"></a>The high-speed, off-screen particles technique in Unity</h3></div></div></div><p>The next technique is to <a id="id405" class="indexterm"></a>optimize the particle system, which was introduced by NVIDIA, GPU Gems 3. The first step in order to achieve the goal is to render particles into <code class="literal">RenderTexture</code> or, in other words, into another render target with smaller size than screen. The second step in this idea is to blend the particles back into screen. First, we need depth buffer. When we render into another render target, we need depth buffer for its z-testing. In the following line of code, you can register in the <code class="literal">Awake</code> or <code class="literal">Start</code> callbacks just as examples:</p><div class="informalexample"><pre class="programlisting">this.camera.depthTextureMode = DepthTextureMode.depth;</pre></div><p>Let's consider following code for high-speed, off-screen particles:</p><div class="informalexample"><pre class="programlisting">// create the off-screen particles textureRenderTexture yourParticlesRenderTexture = RenderTexture.GetTemporary(
  Screen.width, // yourLowerResolutionIntegerValue 
  Screen.height, // yourLowerResolutionIntegerValue 
  0
);</pre></div><p>The <code class="literal">yourLowerResolutionIntegerValue</code> determines the quality. The highest value means the worst <a id="id406" class="indexterm"></a>quality and the best performance and vice versa.</p><p>The second part is very simple and means just tuning your main camera's properties as shown here:</p><div class="informalexample"><pre class="programlisting">yourMainCamera.targetTexture = yourParticlesRenderTexture;
yourMainCamera.backgroundColor = Color.black;
yourMainCamera.cullingMask = yourLayerMask.value;
yourMainCamera.depthTextureMode = DepthTextureMode.None;
yourMainCamera.clearFlags = CameraClearFlags.SolidColor;</pre></div><p>The next step includes rendering and blending particles into the scene:</p><div class="informalexample"><pre class="programlisting">Shader.SetGlobalVector(
  "_Your_Camera_Depth_Texture_Size",
  Vector4(
    this.camera.pixelWidth, this.camera.pixelHeight, 0.0, 0.0
  )
);
depthCamera.RenderWithShader(
  Shader.Find("Pro/Unity/Performance/Particles/Off-Screen"), 
  "RenderType"
);
Material yourMixedMaterial = YouClassHelper.GetMaterialByShader(
  Shader.Find("Pro/Unity/Performance/Particles/Off-Screen")
);
Vector2 yourTexelOffset = Vector2.Scale(
  source.GetTexelOffset(), 
  Vector2(source.width, source.height)
);
Graphics.BlitMultiTap(
  yourParticlesRenderTexture, source, yourMixedMaterial,  yourTexelOffset
);</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"></a>Note</h3><p>Always release the particles render texture for better performance.</p></div><p>You can <a id="id407" class="indexterm"></a>render (after postprocessing) your <code class="literal">RenderTexture</code> to your destination as shown here:</p><div class="informalexample"><pre class="programlisting">RenderTexture.ReleaseTemporary(yourParticlesRenderTexture);
Graphics.Blit(source, destination);</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec83"></a>The pool technique</h3></div></div></div><p>The next technique is a basic <a id="id408" class="indexterm"></a>pooling system (as shown in Listing 3-1) for Unity in addition for Shuriken particles. Put the pool component on your GameObject and set the name and prefab. The pool summons the <code class="literal">OnCreateEvent</code> strategy on entities when they are <span class="emphasis"><em>made</em></span> in the pool (so put your initialization that typically will go in the <code class="literal">Start</code> or <code class="literal">Awake</code> callback) and an <code class="literal">OnLiberationEvent</code> system when reused items go into the pool. The <code class="literal">OnCreateEvent</code> strategy provides the pool that made the occurrence so that you can store it away and reuse your <span class="strong"><strong>GameObject</strong></span>
<a id="id409" class="indexterm"></a> later:</p><div class="informalexample"><pre class="programlisting">YourPoolClass.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class YourPoolClass : MonoBehaviour
{
      private static readonly Dictionary&lt;string, YourPoolClass&gt; 
      namesOfObjects = new Dictionary&lt;string, YourPoolClass&gt;();

      public static YourPoolClass GetPoolByName(string name) { 
    return namesOfObjects[name]; 
  }

      [SerializeField]
      private string nameOfYourPool = string.Empty;

      [SerializeField]
      private Transform yourPoolPrefab = null;

      [SerializeField]
      private int initialObjectCounter = 23;

      [SerializeField]
      private bool isParentEnabled = true;

      private readonly Stack&lt;Transform&gt; yourObjectsStack = new Stack&lt;Transform&gt;();

      void Awake()
      {
    System.Diagnostics.Debug.Assert(yourPoolPrefab);
    namesOfObjects[nameOfYourPool] = this;

          for (int i = 0; i &lt; initialObjectCounter; i++)
          {
                var t = Instantiate(yourPoolPrefab) as Transform;
                AdjustingYourObject(t);
                LiberationObject(t);
          }
      }

      public Transform GetObject(Vector3 position = new Vector3())
      {
          Transform t = null;

          if (yourObjectsStack.Count &gt; 0) 
    {
                t = yourObjectsStack.Pop();
          } 
    else 
    {
                Debug.LogWarning(
        nameOfYourPool + " pool error!", this
      );
                t = Instantiate(yourPoolPrefab) as Transform;
          }

          t.position = position;
          AdjustingYourObject(t);

          return t;
      }

      private void AdjustingYourObject(Transform obj)
      {
         if (isParentEnabled)
         {
                obj.parent = transform;
          }

          obj.gameObject.SetActiveRecursively(true);
          obj.BroadcastMessage(
      "OnCreateEvent", 
      this, 
      SendMessageOptions.DontRequireReceiver
    );
      }

      public void LiberationObject(Transform obj)
      {
         obj.BroadcastMessage(
      "OnLiberationEvent", 
      this, 
      SendMessageOptions.DontRequireReceiver
    );
          obj.gameObject.SetActiveRecursively(false);
          yourObjectsStack.Push(obj);
      }
}</pre></div><p>This is how to use <a id="id410" class="indexterm"></a>this pooling system:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class YourPoolExampleUsage : MonoBehaviour {
  void Start() {
    YourPoolClass pool = YourPoolClass.GetPoolByName("Bang");
    Transform obj = pool.GetObject(Vector3.zero);
  }
}</pre></div><p>In event of using a particle system with <code class="literal">YourPoolClass</code>, you should use the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

[RequireComponent(typeof(ParticleSystem))]
public class YourPoolParticleSystem : MonoBehaviour
{
    private YourPoolClass yourPoolClass;
    
    void OnCreateEvent(YourPoolClass ypc)
    {
        yourPoolClass = ypc;

        particleSystem.renderer.enabled = true;
        particleSystem.time = 0;
        particleSystem.Clear(true);
        particleSystem.Play(true);
    }

    void OnLiberationEvent()
    {
        particleSystem.Stop();
        particleSystem.time = 0;
        particleSystem.Clear(true);
        particleSystem.renderer.enabled = false;
    }

    void Update()
    {
        if (!particleSystem.IsAlive(true) &amp;&amp; particleSystem.renderer.enabled)
        {
            yourPoolClass.LiberationObject(transform);
        }
    }
}</pre></div></div></div>