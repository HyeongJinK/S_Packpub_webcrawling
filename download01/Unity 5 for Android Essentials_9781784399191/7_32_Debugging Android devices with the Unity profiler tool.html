<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec32"></a>Debugging Android devices with the Unity profiler tool</h2></div></div><hr /></div><p>We can open the <a id="id377" class="indexterm"></a>Unity profiler window <a id="id378" class="indexterm"></a>from the menu, which presents the whole Unity profiler tool. In the upcoming sections, we will explore more about the Unity profiler areas.</p><p>Before starting, we need to know how this tool is works and how simple it is to use. Firstly, let's look more at the Unity profiler tool window structure and separate its parts. As we can see in the next screenshot, there are four main visual parts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Profiler controls</p></li><li style="list-style-type: disc"><p>Usage area</p></li><li style="list-style-type: disc"><p>Profiler timeline</p></li><li style="list-style-type: disc"><p>Information table</p></li></ul></div><p>The upcoming sections focus on these distinctive parts of the Unity profiler tool. Let's dive into the most interesting thing in this instrument.</p><p>Regarding the visual profiler, you can connect to access devices on which your application is performing in order to further analyze the performance of your software. In order to connect to the other device, it is necessary (but not just sufficient) for the profiler to be on the same local network. The <span class="strong"><strong>Active Profiler</strong></span> option allows you to select your device from a list of the desired connections. Besides that, your application should be launched with the <span class="strong"><strong>Development Build enabled</strong></span> checkbox from <span class="strong"><strong>Build Settings</strong></span>. Also in these settings, you will see the <span class="strong"><strong>Autoconnect profiler</strong></span> option, which is necessary to signal whether Unity should or should not be connected to the profiler every time you start your application.</p><p>The following are the Unity profiler buttons:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Record</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Deep Profiler</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Profile Editor</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Active Profiler</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Clear</strong></span>
</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_07_01.jpg" /></div><p>If you look at the top of the profiler window, you will see there is a toolbar, which we will examine in more detail later in the chapter. Using the buttons on the toolbar, you can enable or disable the profiler recording data. Also, you can clear the collected information or navigate in the frame set and much more; we will talk more about this later. Right in the toolbar, we see the <span class="strong"><strong>Current</strong></span> button. After clicking on this button, we will automatically get on a frame and the last detail of its implementation. If your game was played in the Unity editor, it will be suspended, meaning it will be paused. It will also be suspended when switching frames forward or backward, using the arrows buttons, which are not far away from the <span class="strong"><strong>Current</strong></span> button. Also, be aware that the profiler does not preserve all the frames, but only a certain number of the most recent frames. Furthermore, if you go from left to right on the toolbar profiler, we see a <span class="strong"><strong>Clear</strong></span> button to clear all the data that was collected. After this, we see a <span class="strong"><strong>Active Profiler</strong></span> button, which allows you to select a device or the Unity editor for further performance analysis. </p><p>Next, we see a button called <span class="strong"><strong>Profile Editor</strong></span>; if you click on this button, you will begin to get detailed statistics execution for the Unity editor. To the left of this button, you will see the <span class="strong"><strong>Deep Profile</strong></span> button. When this button is activated, it will provide information about all of your scripts and function calls. Deep profiling<a id="id379" class="indexterm"></a> can significantly slow down<a id="id380" class="indexterm"></a> your application or your game, as it will be necessary to spend most of the time processing and requires a huge amount of memory space. Remember that very deep profiling will only work if you use it for small projects, otherwise you run the risk that Unity will not be able to obtain the necessary resources and hang, following which you will have to restart the Unity editor. Also, deep profiling is well suited not only for small projects, but is also very useful for testing key aspects of your game or application. You can use the code in deep profiling, and that is switched ON and OFF for specific pieces of code in your scripts. Only the necessary parts of the code will be profiled and analyzed. </p><p>The <code class="literal">Profiler.BeginSample</code> and <code class="literal">Profiler.EndSample</code> calls are the beginning and endpoints, respectively, of profiling your code, which means that the code between these two function calls will be profiled and detailed statistics will be displayed in the bottom profiler window. We will talk about profiler scripting a little later in this chapter. On the left from the <span class="strong"><strong>Deep Profile</strong></span> button is a button that is called <span class="strong"><strong>Record</strong></span>, and it is needed to enable or disable profiling as we mentioned earlier. Well, the left-most button in the toolbar is called <span class="strong"><strong>Add Profiler,</strong></span> and it is needed to display different profiler areas: <span class="strong"><strong>CPU</strong></span>, <span class="strong"><strong>GPU</strong></span>, <span class="strong"><strong>Rendering</strong></span>, <span class="strong"><strong>Memory</strong></span>, <span class="strong"><strong>Audio</strong></span>, <span class="strong"><strong>Physics 3D</strong></span>, and <span class="strong"><strong>Physics2D</strong></span>. We will talk about these profiler areas later in this chapter.</p><p>If your game or your application is running at a specific frame rate or is synchronized with the vertical blank, then Unity will keep the average time waiting for the synchronization of all frames in a parameter called <code class="literal">Wait For Target FPS</code>, which is displayed in the profiler. By default, the information on waiting times will not be published in the Unity profiler. To change the specified default behavior, you need to enable <code class="literal">View SyncTime</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec75"></a>Profiler timeline</h3></div></div></div><p>In the upper part of the profiler window is<a id="id381" class="indexterm"></a> a graph that shows the profiler load data in<a id="id382" class="indexterm"></a> real time. Statistics are processed in each frame and are saved only in the history of the last couple of hundred frames. If you select one of the frames for further consideration, you will see details at the bottom profiler, which in turn will depend on the selected timeline area (for example, <span class="strong"><strong>CPU</strong></span>, <span class="strong"><strong>GPU,</strong></span> or <span class="strong"><strong>Audio</strong></span>). You can both add and remove various timeline areas. Also, note that the colored squares on the left display different timeline areas. In fact, it is not just the colored squares; they are radio buttons. Thus, it will be much easier to eliminate unnecessary data when optimizing your application.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec76"></a>The CPU area</h3></div></div></div><p>The CPU area clearly <a id="id383" class="indexterm"></a>shows which specific place and how much total time was<a id="id384" class="indexterm"></a> spent on the CPU side of course. If you choose it, then you will have hit on the CPU area. After that, you will see that the bottom profiler displays enough details solely about the execution of your application on the CPU. Also, you can choose two different modes of displaying detailed information:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="strong"><strong>Hierarchy</strong></span> mode displays the information in a hierarchy, by grouping the data</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Group Hierarchy</strong></span> mode displays information on groups that were distributed logically; for example, the <span class="strong"><strong>Rendering</strong></span> group, the <span class="strong"><strong>Scripts</strong></span> group, the <span class="strong"><strong>Physics</strong></span> group, and many more groups</p></li></ul></div><p>The <span class="strong"><strong>Others</strong></span> area of the CPU profiler incorporates <span class="strong"><strong>Loading</strong></span>, <span class="strong"><strong>Audio</strong></span>, <span class="strong"><strong>Animation</strong></span>, <span class="strong"><strong>Particles</strong></span>, <span class="strong"><strong>Playerloop</strong></span>, <span class="strong"><strong>AI</strong></span>, and <span class="strong"><strong>Networking</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec77"></a>The Rendering area</h3></div></div></div><p>The <span class="strong"><strong>Rendering</strong></span> area <a id="id385" class="indexterm"></a>displays rendering statistics as shown in the<a id="id386" class="indexterm"></a> following screenshot. The timeline graphically presents the number of rendered <span class="strong"><strong>Draw Calls</strong></span>, <span class="strong"><strong>Triangles</strong></span>, and <span class="strong"><strong>Vertices</strong></span>. As we can see, the bottom part of the following screenshot and <span class="strong"><strong>Game View Rendering Statistics</strong></span> shown in the next figure are very similar. Further, we will cover the information shown in the following screenshot in details:</p><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_07_02.jpg" /></div><p>The following screenshot is very<a id="id387" class="indexterm"></a> similar to the same statistics<a id="id388" class="indexterm"></a> information:</p><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_07_03.jpg" /></div><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /></colgroup><tbody><tr><td style="" align="left" valign="top">
<p>Time per frame and FPS</p>
</td><td style="" align="left" valign="top">
<p>The time spent rendering one frame in milliseconds; represents quantity of frames per second.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Draw calls</p>
</td><td style="" align="left" valign="top">
<p>The amount of rendered meshes.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Batched (draw Calls)</p>
</td><td style="" align="left" valign="top">
<p>The number of batched draw calls.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Tris and verts</p>
</td><td style="" align="left" valign="top">
<p>The amount of drawn geometry (triangles and vertices).</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Used textures</p>
</td><td style="" align="left" valign="top">
<p>This indicates how many textures were used and the amount of memory needed per frame.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Render textures</p>
</td><td style="" align="left" valign="top">
<p>This shows the amount of times active render texture was switched per frame; furthermore it demonstrates how much memory is used to render texture, and how many render textures there were.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Screen</p>
</td><td style="" align="left" valign="top">
<p>This shows the screen size with its anti-aliasing level and memory usage.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>VRAM usage</p>
</td><td style="" align="left" valign="top">
<p>This roughly indicates the amount of video memory (VRAM) usage; furthermore, represents how much memory your graphic card has.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>VBO total</p>
</td><td style="" align="left" valign="top">
<p>
<span class="strong"><strong>Vertex Buffers Objects</strong></span> (<span class="strong"><strong>VBO</strong></span>)<a id="id389" class="indexterm"></a> is the number of uploaded meshes to the graphics card.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Visible Skinned Meshes</p>
</td><td style="" align="left" valign="top">
<p>This shows<a id="id390" class="indexterm"></a> the amount of rendered skinned<a id="id391" class="indexterm"></a> meshes.</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Animations</p>
</td><td style="" align="left" valign="top">
<p>This represents how many animations can be played.</p>
</td></tr></tbody></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec78"></a>The Memory area</h3></div></div></div><p>While profiling this area, you can choose<a id="id392" class="indexterm"></a> one of the two available modes for different <a id="id393" class="indexterm"></a>displaying modes. The first mode is to display very simple statistics, and the second mode is for displaying very detailed statistics. We cover these two modes in more detail in the following sections:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec22"></a>The simple view</h4></div></div></div><p>We begin with the simplest <a id="id394" class="indexterm"></a>display mode statistics (as shown in the following screenshot). This shows the usage of memory for each profiled frame in a simpler form than it does in the detailed statistics:</p><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_07_04.jpg" /><div class="caption"><p>The simple view of the Unity profiler</p></div></div><p>In order to use memory efficiently, Unity tries to keep a certain amount of memory in advance in the form of a pool, or in other words, as a backup buffer, which greatly improves performance. Statistics memory, or rather information about how much memory is consumed, and for what is the described method of reservation, will be shown at the bottom profiler window. Here <a id="id395" class="indexterm"></a>are the parameters of these statistics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Unity</strong></span>: This indicates the amount of memory used for allocations in the native Unity code</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Mono</strong></span>: This shows how big the heap size was, and the amount of memory used for the garbage collector</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Gfx Driver</strong></span>: This indicates the amount of memory used by the driver on shaders, meshes, render targets, and textures</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>FMOD</strong></span>: This shows the amount of memory used on audio drivers</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Profiler</strong></span>: This indicates the amount of memory used for the Unity's profiler</p></li></ul></div><p>The memory area displays information for fundamental types of objects and assets: textures, meshes, materials, animations, audio, and object count.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec23"></a>The detailed view</h4></div></div></div><p>In a detailed view, you can<a id="id396" class="indexterm"></a> save the current state for further analysis using the <span class="strong"><strong>Take Sample</strong></span> button. In order to obtain such detailed information about the memory usage, the Unity profiler should take time to collect all information needed, and that's why you should not think that you can receive information in real time.</p><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_07_05.jpg" /></div><p>The profiler will show information about where and on what the memory was consumed. The following is a list of groups of objects that will be spent in memory:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Referenced from native code</p></li><li style="list-style-type: disc"><p>Scene object</p></li><li style="list-style-type: disc"><p>Built-in resources</p></li><li style="list-style-type: disc"><p>Marked as don't save</p></li></ul></div><p>After you click on one<a id="id397" class="indexterm"></a> of the objects in the list, Unity will highlight the selected items in the <span class="strong"><strong>Project</strong></span> view or in the <span class="strong"><strong>Scene</strong></span> view. When profiling your application in the Unity editor, the statistics will be less accurate than it could be on a particular device. Some of the costs associated with the Unity editor execution will also be displayed in the average values that will not be true for your application. Therefore, for a more precise analysis of your application, it is the best decision to connect to real devices and profile statistics in that case.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec79"></a>The audio area</h3></div></div></div><p>This<a id="id398" class="indexterm"></a> shows the information <a id="id399" class="indexterm"></a>displayed in the audio area.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec80"></a>The physics area</h3></div></div></div><p>The following is a list <a id="id400" class="indexterm"></a>of information <a id="id401" class="indexterm"></a>displayed in the Physics 3D area (as shown in following screenshot):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Active Bodies</strong></span>: This indicates the number of awake Rigidbodies</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Sleeping Bodies</strong></span>: This displays the number of sleeping Rigidbodies</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Number of Contacts</strong></span>: This shows the total amount of contact points in the scene between all colliders</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Static Colliders</strong></span>: This represents how many colliders were attached on non-Rigidbody objects</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Dynamic Colliders</strong></span>: This demonstrates how many colliders were attached on Rigidbody objects</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784399191/graphics/9191OT_07_06.jpg" /><div class="caption"><p>The detailed view of the Unity profiler</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec81"></a>The GPU area</h3></div></div></div><p>Statistics that are displayed in <a id="id402" class="indexterm"></a>the profiler window for the GPU area are <a id="id403" class="indexterm"></a>very similar to the displayed statistics for CPU area.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note21"></a>Note</h3><p>On the Mac, only OSX 10.7 Lion and later versions support GPU profiling.</p></div></div></div>