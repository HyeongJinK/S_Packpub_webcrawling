<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec23"></a>An overview of the asset bundles in Unity 5</h2></div></div><hr /></div><p>Asset bundles are <span class="strong"><strong>Unity Pro</strong></span>
<a id="id272" class="indexterm"></a> features only. Two main ideas of the asset bundles are:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Easily download content in your application</p></li><li style="list-style-type: disc"><p>Uploading new content in your application</p></li></ul></div><p>Unity <a id="id273" class="indexterm"></a>allows exporting your assets as files, which are known as asset bundles. Your application can download these compressed files whenever needed. This approach will reduce your final build size by streaming in: prefabs, animations, binary files, textures, audio clips, meshes, and scenes, where asset bundles will be utilized. All other asset types are supported by Unity. For binary files, you should set the extension to <code class="literal">.bytes</code> and Unity will recognize these files as <code class="literal">TextAsset</code>. To use asset bundles, you just need to create them and upload them to your server. In the Unity Editor, you can build asset bundles from your assets in the scene. In a situation when you need to upload your asset bundles to the server, you can use any data communication protocol; for example, SSH, FTP, FTPS, SFTP, or any other protocol depending on your choice. In real time, your application, which is written in your script, will download the necessary asset bundles for further work with your packed assets in these exported files.</p><p>We will cover what you should do to create the <code class="literal">AssetBundle</code> file. For this task, you should use the Unity Editor class known as <code class="literal">BuildPipeline</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>If you are using any of the Unity Editor classes in your scripts, then you should always remember to keep these scripts in a folder named <code class="literal">Editor</code> anywhere in your project within any subdirectory of the <code class="literal">Assets</code> folder.</p></div><p>Now, let's create a simple C# script to create <code class="literal">AssetBundle</code>. First of all, we should import two Unity namespaces:</p><div class="informalexample"><pre class="programlisting">  using UnityEngine;
  using UnityEditor;</pre></div><p>After these <a id="id274" class="indexterm"></a>lines of code, you should declare your public class; for example, you can create very simple class declaration:</p><div class="informalexample"><pre class="programlisting">  public class BuilderAssetBundle {
    // the code you will see below
  }</pre></div><p>In the next step, we will create a static function with its <code class="literal">MenuItem</code> for future selection from the Unity Editor menu:</p><div class="informalexample"><pre class="programlisting">  [MenuItem("PacktPub/AssetBundles/Build Asset Bundle")]
  static void Build() {
    // the code you will see below
  }</pre></div><p>After that, you need to fill in your static function with just a single instruction or line of code or something similar depending on your requirements, and you will see the already finished simple class to build your <code class="literal">AssetBundle</code>:</p><div class="informalexample"><pre class="programlisting">  BuildPipeline.BuildAssetBundle(
    Selection.activeObject, 
   Selection.GetFiltered(typeof(Object),SelectionMode.DeepAssets),
    "Assets/Your/Path/To/YourAssetBundle.unity3d",
    BuildAssetBundleOptions.CollectDependencies | 
    BuildAssetBundleOptions.CompleteAssets
  );</pre></div><p>This function creates a compressed <code class="literal">Assets/Your/Path/To/YourAssetBundle.unity3d</code> file with a list of packed assets (any from your project folder) and returns <code class="literal">true</code> if <code class="literal">AssetBundle</code> was created successfully or <code class="literal">false</code> otherwise. The first variable in this function, <code class="literal">Selection.activeObject</code>, indicates which object to use for retrieving packed assets from <code class="literal">AssetBundle</code> using the <code class="literal">AssetBundle.mainAsset</code> property. You can set this value to <code class="literal">null</code> if you are not using it. The second variable is <code class="literal">array Object[]</code> and specifies which assets you need to pack. The third variable is very simple, and it is just a location where you want to save your <code class="literal">AssetBundle</code> file. By specifically adjusting <code class="literal">BuildAssetBundleOptions</code> flags, you can dictate to include all dependencies automatically or only include complete assets. Furthermore, with these options, you can specify that you don't want your assets to be compressed in the <code class="literal">AssetBundle</code> file by setting up the <code class="literal">UncompressedAssetBundle</code> flag. If you want, you can check the <code class="literal">CRC</code> checksum of<a id="id275" class="indexterm"></a> your asset bundles while downloading your exported files via the <code class="literal">WWW.LoadFromCacheOrDownload</code> call. To create asset bundles, you can use three different functions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">BuildPipeline.BuildAssetBundle</code>: This will build any asset type.</p></li><li style="list-style-type: disc"><p>
<code class="literal">BuildPipeline.BuildStreamedSceneAssetBundle</code>: This will include only scenes.</p></li><li style="list-style-type: disc"><p>
<code class="literal">BuildPipeline.BuildAssetBundleExplicitAssetNames</code>: This is similar to <code class="literal">BuildPipeline.BuildAssetBundle</code>, but with a little difference. In this function, you can indicate your string identifier for all included objects.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>You can create the asset bundles for the Web-Player platform and use them in a standalone platform and vice versa. Alternatively, for mobile platforms, you can use only their built files. For example, you can create the asset bundles for Android devices and use them only for Android platforms, but you cannot use them for iOS platforms and vice versa. With built files for the iOS platform, you can use them only within iOS boundaries.</p></div><p>In order to use your class to create the asset bundle, you need to do two simple steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>You should select one single or many assets in your project, which will be packed into your <code class="literal">AssetBundle</code>.</p></li><li><p>From the Unity menu, you should navigate to <span class="strong"><strong>PacktPub</strong></span> | <span class="strong"><strong>AssetBundles</strong></span> | <span class="strong"><strong>Build Asset Bundle</strong></span>.</p></li></ol></div><p>The finished script to create <code class="literal">AssetBundle</code> should be similar to the code shown here:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using UnityEditor;

public class BuilderAssetBundle {
  [MenuItem("PacktPub/AssetBundles/Build Asset Bundle")]
  static void Build() {
    BuildPipeline.BuildAssetBundle(
      Selection.activeObject,
      Selection.GetFiltered(
        typeof(Object),
        SelectionMode.DeepAssets
      ),
      "Assets/Your/Path/To/YourAssetBundle.unity3d",
      BuildAssetBundleOptions.CollectDependencies | 
      BuildAssetBundleOptions.CompleteAssets
    );
  }
}</pre></div><p>We've realized the asset bundles creation, now let's explore how to use them from your scripts. To use your asset bundles, you should follow the next two simple steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Download your <code class="literal">AssetBundle</code> files from any local storage like hard drive or remote storage like any web-server, Unity provides the <code class="literal">WWW</code> helper class for such issues.</p></li><li><p>Load <a id="id276" class="indexterm"></a>or, in other words, unpack your assets from your <code class="literal">AssetBundle</code> files in order to use them further in your game.</p></li></ol></div><p>In the following code, we intend to understand the case of using <code class="literal">AssetBundle</code>. First of all, we need to create a simple C# script and name it, for example, <code class="literal">ImporterAssetBundle</code>. Open the script in your code editor and change it as shown here:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ImporterAssetBundle : MonoBehaviour {
  void Start() {
    StartCoroutine(Import());
  }

  public IEnumerator Import() {
    using (WWW wwwData = WWW.LoadFromCacheOrDownload(
        "http://your-domain.com/your/path/url/new2.unity3d",
        23 // your asset bundle version, as an example only
    )) {
      yield return wwwData;
      GameObject obj = www.assetBundle.mainAsset as GameObject;
      Instantiate(obj);
      www.assetBundle.Unload(false);
    }
  }
}</pre></div><p>Attach this script as a component to your GameObject. The URL in this script is just for example, so you should set your own URL for your <code class="literal">AssetBundle</code> file. Based on this version, Unity's caching system will decide whether to download your file or not. If this file was already cached with the same version number, then Unity will speed up your application. In this script, we called <code class="literal">Import</code> co-routine in the <code class="literal">Start</code> event, but you can call this function anywhere you need and as often as you want. In <code class="literal">Import</code> co-routine, we first used <code class="literal">WWW.LoadFromCacheOrDownload</code> with the sole purpose of loading the required <code class="literal">AssetBundle</code> file by given the URL path and the version number. During the downloading process, Unity will not execute the next instructions from the <code class="literal">yield return www</code> command. Only after the download is complete will Unity run the next commands in<a id="id277" class="indexterm"></a> our co-routine example.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Using the <code class="literal">www</code> instance to retrieve <code class="literal">mainAsset</code> as a GameObject instance from the downloaded <code class="literal">AssetBundle</code>
</p></li><li style="list-style-type: disc"><p>Creating a new instance in real time in the current scene of the retrieved <code class="literal">GameObject</code> instance</p></li><li style="list-style-type: disc"><p>Unloading all the memory used for this <a id="id278" class="indexterm"></a>
<span class="strong"><strong>AssetBundle</strong></span> (for increasing the performance).</p></li></ul></div><p>As making projects is an iterative procedure, you will probably alter your assets not once but multiple times, which may oblige remaking the asset bundles after every change to have the capacity to test them. Despite the fact that it is conceivable to load the asset bundles in the Unity editor, it is not the best solution. Rather, while testing in the Unity editor, you ought to utilize the aide function <code class="literal">Resources.LoadAssetAtPath</code> to abstain from needing to utilize and revamp the asset bundles. The function gives you a chance to load your asset as though it were being stacked from an asset bundle, yet we will skirt the building procedure, and your assets are constantly up and coming. Let's create a new C# script that will improve our last example with some exception handling and with <code class="literal">Resources.LoadAssetAtPath</code> in event of importing within the Unity editor. Create a new script and name it, for example, <code class="literal">MyAssetBundleImporter</code>. The next step is to declare at the beginning of the file the required namespaces that we will use:</p><div class="informalexample"><pre class="programlisting">  using UnityEngine;
  using System.Collections;
After these lines we will declare our public class:
  public class MyAssetBundleImporter {
    // the code you will see below
  }</pre></div><p>Let's declare the <code class="literal">public</code> property in this class for objects that will be retrieved from your <code class="literal">AssetBundle</code>:</p><div class="informalexample"><pre class="programlisting">  public Object assetBundleObject;</pre></div><p>Also, in this class, let's declare our <code class="literal">public</code> and specific <code class="literal">AssetBundle</code> structure with its public properties for further usage:</p><div class="informalexample"><pre class="programlisting">  public struct AssetBundleStruct {
    public string assetSourceName;
    public string assetSourcePath;
    public string assetBundleUrl;
    public int assetBundleVersion;
  }</pre></div><p>Next, we will declare the core of this script, the function which Unity will execute as a co-routine:</p><div class="informalexample"><pre class="programlisting">  public IEnumerator Import&lt;T&gt;(AssetBundleStruct abs) where T : Object {}</pre></div><p>The first step in the co-routine is to initialize our <code class="literal">assetBundleObject</code> to <code class="literal">null</code>:</p><div class="informalexample"><pre class="programlisting">  assetBundleObject = null;</pre></div><p>After that line of<a id="id279" class="indexterm"></a> code, let's declare the main condition in order to decide how to import your asset bundles:</p><div class="informalexample"><pre class="programlisting">  #if UNITY_EDITOR
    // 1st part, the code you will see below
  #else
    // 2nd part, the code you will see below
  #endif</pre></div><p>Let's create a code for the first part of the <code class="literal">if</code>/<code class="literal">else</code>/<code class="literal">endif</code> pre-processor statement:</p><div class="informalexample"><pre class="programlisting">  assetBundleObject = Resources.LoadAssetAtPath(
    abs.assetSourcePath, typeof(T)
  );

  if (null == assetBundleObject){
    Debug.LogError("AssetBundle ERROR Path: " + abs.assetSourcePath);
    Debug.LogError("Asset Bundle could not be found !!!");
  }
  yield break;</pre></div><p>Now, we will create the code for the second part of the <code class="literal">if</code>/<code class="literal">else</code>/<code class="literal">endif</code> preprocessor statement:</p><div class="informalexample"><pre class="programlisting">  WWW www;
  if (Caching.enabled) {
    while (false == Caching.ready) {
      yield return null;
    }
    www = WWW.LoadFromCacheOrDownload(
      abs.assetBundleUrl, abs.assetBundleVersion
    );
  } else {
    www = new WWW(abs.assetBundleUrl);
  }

  yield return www;

  if (null != www.error) {
    Debug.LogError(www.error);
    www.Dispose();
    yield break;
  }

  AssetBundle ab = www.assetBundle;
  www.Dispose();
"  www = null;
  if (string.Empty == abs.assetSourceName || null == abs.assetSourceName) {
    assetBundleObject = ab.mainAsset;
  } else {
    assetBundleObject = ab.Load(abs.assetSourceName, typeof(T));
  }

  ab.Unload(false);</pre></div><p>Let's create a simple<a id="id280" class="indexterm"></a> script inherited from <code class="literal">MonoBehaviour</code>, which will show how you can use your example class <code class="literal">MyAssetBundleImporter</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ExampleMyImporterUsage : MonoBehaviour {
  public MyAssetBundleImporter.AssetBundleStruct abs;
  
  private string _tmpStr;
  private Object _tmpObj;
  void Start() {
    abs = new MyAssetBundleImporter.AssetBundleStruct();
    abs.assetBundleUrl = "http://yourapp.com/your/bundle.unity3d";
    abs.assetBundleVersion = 0;
    abs.assetSourceName = "YourPrefabName";

    StartCoroutine(Import());
  }

  IEnumerator Import() {
    MyAssetBundleImporter mabi = new MyAssetBundleImporter();
    yield return StartCoroutine(mabi.Import&lt;GameObject&gt;(abs));
    if (null != mabi.assetBundleObject) {
      _tmpObj = Instantiate(mabi.assetBundleObject);
    }
  }

  void OnGUI() {
    if (null != _tmpObj) {
      _tmpStr = _tmpObj.name + " was successfully created.";
      GUILayout.Label(_tmpStr);
    } else {
      GUILayout.Label("ERROR: Cannot import your AssetBundle.");
    }
  }
}</pre></div><p>Let's describe what <a id="id281" class="indexterm"></a>happened in the last script. First, we declared one public <code class="literal">AssetBundleStruct</code> variable and two private variables. After that, we created the <code class="literal">Start</code> method, where we initialized our <code class="literal">AssetBundleStruct</code> variable with the right values. Next, we called the co-routine <code class="literal">Import</code> in our <code class="literal">Start</code> function. In the <code class="literal">Import</code> co-routine, we created one single instance of our class <code class="literal">MyAssetBundleImporter</code> to call its <code class="literal">Import</code> co-routine with our initialized structure <code class="literal">abs</code>. If we imported the object and it is not equal to <code class="literal">null</code>, then we instantiate that GameObject in our scene. Also, we show the simple <code class="literal">GUI</code> label that indicates whether we successfully imported our <code class="literal">AssetBundle</code> or not. For using this (only if your <code class="literal">AssetBundle</code> was already created and uploaded) script, you should just attach it as a component to your GameObject in your scene and set up correct values. If those two simple steps were done, then you can play and test your game in the Unity editor or within your build.</p><p>If you need to get an array with all contained objects from your <code class="literal">AssetBundle</code>, you should use the function known as <code class="literal">AssetBundle.LoadAll</code>. In the event where you need to get a list of the string identifiers, you should keep a specific <code class="literal">TextAsset</code> as a map to save your assets' names there.</p><p>In the following steps, we're going to show a simple example about adjusting different texture compressions before building your asset bundle. All we need to remember is two simple steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>In order to force reimporting your assets before building the asset bundle, you should use the <code class="literal">AssetDatabase.ImportAsset</code> function.</p></li><li><p>After you should use <code class="literal">AssetPostprocessor.OnPreprocessTexture</code> to adjust correct values for your texture compression.</p></li></ol></div><p>Now, let's write a simple code example that you can use in your projects like any other examples from this book:</p><div class="informalexample"><pre class="programlisting">  using UnityEngine;
  using UnityEditor;  </pre></div><p>As always, we declare the required namespaces (remember this script will use <code class="literal">UnityEditor</code> and should be located in <code class="literal">Editor</code> folder, we spoke earlier about this Unity requirement). The next step is to define a simple class using the following code:</p><div class="informalexample"><pre class="programlisting">  public class TextureFormatAssetBundles {
    // the code you will see below
  }</pre></div><p>After the simple class declaration, we need to set up one <code class="literal">public</code> and <code class="literal">static</code> variable, at the same time, and three<a id="id282" class="indexterm"></a> different but elementary functions (you can use any desired texture format; in this example, we use <code class="literal">DXT1</code>, <code class="literal">DXT5</code>, and <code class="literal">ETC_RGB4</code>):</p><div class="informalexample"><pre class="programlisting">  public static TextureImporterFormat tif;

  [MenuItem("PacktPub/AssetBundles/Create Asset Bundle DXT1")]
  static void SetTextureFormatDXT1() {
    tif = TextureImporterFormat.DXT1;
    CreateAssetBundle();
  }

  [MenuItem("PacktPub/AssetBundles/Create Asset Bundle DXT5")]
  static void SetTextureFormatDXT5() {
    tif = TextureImporterFormat.DXT5;
    CreateAssetBundle();
  }

  [MenuItem("PacktPub/AssetBundles/Create Asset Bundle ETC_RGB4")]
  static void SetTextureFormatETC_RGB4() {
    tif = TextureImporterFormat.ETC_RGB4;
    CreateAssetBundle();
  }</pre></div><p>Now, we can write our main function <code class="literal">CreateAssetBundle</code> that does all the dirty work:</p><div class="informalexample"><pre class="programlisting">  static void CreateAssetBundle() {
    // the code you will see below
  }</pre></div><p>In our first step, we call the <code class="literal">EditorUtility.SaveFilePanel</code> method in order to show the Unity dialog and to get a selected path string from it. Also, we need to return from this function an empty location variable:</p><div class="informalexample"><pre class="programlisting">  string selectedPath = EditorUtility.SaveFilePanel(
    "Save", // TITLE
    string.Empty, // DIRECTORY PATH
    "Your AssetBundle Name", // DEFAULT FILE NAME
    "unity3d" // FILE EXTENSION
  );

  if (selectedPath.Length == 0) return;</pre></div><p>The next step is to declare an array with our selected objects:</p><div class="informalexample"><pre class="programlisting">  Object[] selectedAssets = Selection.GetFiltered(
    typeof(Object), SelectionMode.DeepAssets
  );</pre></div><p>Further, we have to <a id="id283" class="indexterm"></a>process each texture from our array in a loop in order to get path for that asset source with the help of the <code class="literal">AssetDatabase.GetAssetPath</code> method. For texture, we must use the <code class="literal">AssetDatabase.ImportAsset</code> function to force our texture preprocessing:</p><div class="informalexample"><pre class="programlisting">  for (int i=0; i &lt; selectedAssets.Length; i++) {
    Object obj = selectedAssets[i];
    if ((obj is Texture) == false) continue;
    string texturePath = AssetDatabase.GetAssetPath(
      (UnityEngine.Object) obj
    );
    AssetDatabase.ImportAsset(texturePath);
  }</pre></div><p>After this, we have to build our <code class="literal">AssetBundle</code>:</p><div class="informalexample"><pre class="programlisting">  BuildPipeline.BuildAssetBundle(
    Selection.activeObject,
    selectedAssets,
    selectedPath,
    BuildAssetBundleOptions.CollectDependencies |
    BuildAssetBundleOptions.CompleteAssets
  );</pre></div><p>At the last stage, we can initialize the <code class="literal">Selection.objects</code> list variable with our selected assets array in order to see all of them:</p><div class="informalexample"><pre class="programlisting">  Selection.objects = selectedAssets;</pre></div><p>Now, we should create a very simple class (this script should be placed into the <code class="literal">Editor</code> folder, we mentioned this requirement earlier) inherited from the <code class="literal">AssetPostprocessor</code> class as shown here:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using UnityEditor;

public class TextureAssetsPreprocessor : AssetPostprocessor {
  void OnPreprocessTexture() {
    TextureImporter ti = assetImporter as TextureImporter;
    ti.textureFormat = TextureFormatAssetBundles.tif;
  }
}</pre></div></div>