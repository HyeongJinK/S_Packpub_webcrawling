<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec30"></a>Enemy behavior and AI</h2></div></div><hr /></div><p>The enemy will start with the idle animation as you play the game. Let's add some behavior to the enemy character.</p><p>The AI is implemented by creating a pattern, which will determine when the next state change for the enemy will take place, and the period of time that the enemy will either be idle, defend, or attack.</p><p>The pattern is an array and has 20 elements in it. After all the elements are exhausted the patterns is randomized and the counter is set to 0 again.</p><p>Some intervals last for 10 frames, while others last for up to 120 frames or two seconds. The player has to judge and make sure that he doesn't get hit, and he has to defeat the <code class="literal">enemy</code> before they kill him. This will make more sense once we go through the code.</p><p>Create a new C# script and name it <code class="literal">enemy</code>. Add the following script to the code.</p><p>First, we initialize our variables:</p><pre class="programlisting">    using UnityEngine; 
    using System.Collections; 

    public class enemy : MonoBehaviour { 

    private Animator anim; 

    int myTick = 0; 
    int currentTick = 0; 
    int prevTick = 0; 
    int nextTick = 0; 
    int patternLength = 0; 
    int patterCount = 0; 


    int[] pattern = new[] {10, 10, 10,30, 60, 10, 40, 60, 120, 30, 
                           10, 10,10, 60, 60, 120, 30, 10, 10, 10}; 
    // Use this for initialization </pre><p>In the <code class="literal">Start</code> function, we get the <code class="literal">Animator</code> component and set the pattern, which we will randomizing later:</p><pre class="programlisting">    void Start () { 

    anim = GetComponent&lt;Animator&gt;(); 
    anim.SetBool("bIsDefending", true); 

    Shuffle(pattern); 

    patternLength = pattern.Length; 
    nextTick = pattern[0]; 

    } // start </pre><p>In the <code class="literal">Update</code> function we update the values that we set initially:</p><pre class="programlisting">    // Update is called once per frame 
    void Update () { 

        myTick++; 
        currentTick = myTick;        

        if (currentTick == prevTick + nextTick) { 
            int choice = Random.Range(1, 3); 

            switch (choice) { 

                //will punch 
                case 1: anim.SetBool("bIsDefending", false); 
                    anim.SetTrigger("tIsPunching"); 
                    break; 

                //will defend 
                case 2: anim.SetBool("bIsDefending", true); 
                    break; 

                //will be idle  
                case 3: anim.SetBool("bIsDefending", false); break; 
            } 

            prevTick = currentTick; 
            nextTick = pattern[patterCount]; 

            if ((patterCount + 1) &gt;= pattern.Length){ 
                patterCount = 0; 
                Shuffle(pattern); 
            } 
            else { 
                patterCount++; 
            } 
        } 
    } // Update </pre><p>The <code class="literal">Shuffle</code> function randomizes the initial pattern that we created:</p><pre class="programlisting">    void Shuffle(int[] a){ 

        for (inti = a.Length - 1; i&gt; 0; i--){ 
            int rnd = Random.Range(0, i); 
            int temp = a[i]; 
            a[i] = a[rnd]; 
            a[rnd] = temp; 
        } 

        for (inti = 0; i&lt;a.Length; i++){ 
            Debug.Log(a[i]); 
        } 
     } // shuffle    </pre><p>As in the case of the player at the top of the code, we create a <code class="literal">private</code> variable to store the enemy animator variable.</p><p>We also create a bunch of integer variables called <code class="literal">myTick</code>, <code class="literal">currentTick</code>, <code class="literal">prevTick</code>, <code class="literal">nextTick</code>, <code class="literal">patternLength</code> and <code class="literal">patternCount</code>.</p><p>The <code class="literal">myTick</code> variable is just a counter, which keeps incrementing. The <code class="literal">CurrentTick</code> and <code class="literal">prevTick</code> variables keep track of the current frame tick and <code class="literal">prevTick</code> keeps track of the tick when an action last occurred.</p><p>The <code class="literal">patternLength</code> variable keeps track of the number of the items in the pattern array and <code class="literal">patternCount</code> keeps track of the current pattern number in use.</p><p>Pattern is an array containing the intervals for the actions.</p><p>In the <code class="literal">Start</code> function, we get the Animator component and set the <code class="literal">isDenfendingbool</code> variable to <code class="literal">true</code> so that the enemy starts off defending. We shuffle the pattern and assign the <code class="literal">patternLength</code> and <code class="literal">nextTick</code> to the first element of the pattern.</p><p>Next in the <code class="literal">Update</code> function, we first increment the tick and assign <code class="literal">myTick</code> to the <code class="literal">currentTick</code>.</p><p>We then check whether it is time for the next action to perform by checking if the <code class="literal">currentTick</code> is equal to the sum of the previous tick and <code class="literal">nextTick</code>.</p><p>If it is equal, then we create a random number from one to three. Depending upon whether the returned value is 1, 2, or 3, there is a <code class="literal">switch</code> statement and the enemy will punch, defend, or be idle.</p><p>At the end, we assign the <code class="literal">currentTick</code> to <code class="literal">previousTick</code>, and <code class="literal">nextTick</code> to next <code class="literal">patternCount</code>.</p><p>We also need to increment the <code class="literal">patternCount</code> and to check if the <code class="literal">patternCount</code> variable's value has exceeded the length. If it is has exceeded it, then we need to reset it.</p><p>So, if the value of <code class="literal">patternCount++</code> is greater than or equal to the value of <code class="literal">patternLegth</code>, then we reset the pattern to zero and shuffle the pattern, otherwise we just increment the <code class="literal">patterCount</code>.</p><p>Finally, we also have a function which shuffles the pattern so that it doesn't get repeated. Add this script component to the enemy object in the scene and watch him be idle, block, and punch:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_04_032.png" /></div></div>