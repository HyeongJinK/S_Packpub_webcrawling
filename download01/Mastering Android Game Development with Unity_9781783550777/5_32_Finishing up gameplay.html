<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec33"></a>Finishing up gameplay</h2></div></div><hr /></div><p>To track the player and enemy's health, we need variables to track how much health both have and how much damage both can do to each other.</p><p>For this, open up <code class="literal">playerScript</code> and add variables called <code class="literal">health</code> and <code class="literal">damage</code> at the top of the class. Then, set the value of the <code class="literal">health</code> variable to 100 and that of the <code class="literal">damage</code> variable to 10. So, the player will start with a health of 100, and when they hit the enemy, they will do a damage of 10 to the enemy:</p><pre class="programlisting">    using UnityEngine; 
    using System.Collections; 
    public class playerScript : MonoBehaviour { 
        public int health = 100; 
        public int damage = 20; 

        private Animator anim; 
        // other code 
    } </pre><p>Similarly, add the same code as that of <code class="literal">playerScript</code> class to the <code class="literal">enemyScipt</code> class as well. Since we want to be fair, we will set the enemy's health to be 100 as well and set the damage that they can do to 10. Make sure you use the <code class="literal">public</code> access specifier because only then we will be able to access the health variable when we try to access it in other classes:</p><pre class="programlisting">    public class enemyScript : MonoBehaviour { 

        public int health = 100; 
        public int damage = 10; 

        private Animator anim; 
        // other code    
    } </pre><p>Now, whenever the player/enemy takes a hit, we have to make sure that the health is reduced by the amount of damage that other player/enemy can inflict on them. So, in the section of the <code class="literal">Update</code> function, when we check whether the player or the enemy is getting hit, we have to reduce the amount of health by the damage.</p><p>In the <code class="literal">enemyScript</code> class, for checking if the enemy is hit, change the code as shown here:</p><pre class="programlisting">    GameObject player = GameObject.Find("theDude"); 
    Animator pAnim = player.GetComponent&lt;Animator&gt;(); 

    playerScript pScript = player.GetComponent&lt;playerScript&gt;(); 

    //Getting Hit 

    if (pAnim.GetBool("tIsPunching")){ 
        if (anim.GetBool("bEnemyIsDefending") == false) { 
            Debug.Log("enemy got hit"); 
            anim.SetTrigger("tEnemyGotHit"); 
            anim.SetBool("bEnemyIsDefending", true); 
<span class="strong"><strong>            health -= pScript.damage;</strong></span>
        } 
    }  </pre><p>We get the access to the player script by getting the <code class="literal">gameobject</code> player and adding the <code class="literal">GetComponent</code> component of the player script.</p><p>Once we have access to the script, we can get the amount of damage the player can do and reduce the current health of the enemy by the amount of damage. Now, move to <code class="literal">playerScript</code>, as we have to implement the same in the player script as well when the player gets hit by the enemy:</p><pre class="programlisting">    GameObject enemy = GameObject.Find("Enemy"); 

    Animator eAnim = enemy.GetComponent&lt;Animator&gt;(); 

    enemyScript eScript = enemy.GetComponent&lt;enemyScript&gt;(); 

    if (eScript.isPunching == true) { 
        if (anim.GetBool("bIsDefending") == false) { 
            Debug.Log("player got hit"); 
            anim.SetTrigger("tGotHit"); 
            health -= eScript.damage; 
        } 
    } </pre><p>Here, we will get access to the enemy script so that we can get the enemy damage as we did in the enemy script. Once we have access to the <code class="literal">damage</code> variable, we will reduce the health of the player by the amount of damage that was set in the enemy script. Now, you can run the game and the <code class="literal">Debug.log</code> script. The <code class="literal">Player Health</code> and <code class="literal">Enemy Health</code> entities seem to be getting affected, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_05_001.png" /></div><p>Once we have the player and enemy health being calculated, we can set the game over condition. Once the player's health or enemy's health gets less than or equal to zero, it is game over.</p><p>The gameloop is the controller by the third script. We will call this script <code class="literal">gameScript</code>.</p><p>It is a very simple script that gets access to both <code class="literal">playerScript</code> and <code class="literal">enemyScript</code>, and it checks for the health of both the player and the enemy. Once either of the player or enemy script becomes less than zero, it announces that the game is over.</p><p>So, we will create a new script called <code class="literal">gameScript</code> and add the following lines of code to the script:</p><pre class="programlisting">    using System.Collections; 
    using System.Collections.Generic; 
    using UnityEngine; 

    public class gameScript : MonoBehaviour { 

        playerScript pScript; 
        enemyScript eScript; 
        public bool bGameover = false; 

        // Use this for initialization 
        void Start () { 

            GameObject player = GameObject.Find("theDude"); 
            pScript = player.GetComponent&lt;playerScript&gt;(); 

            GameObject enemy = GameObject.Find("Enemy"); 
            eScript = enemy.GetComponent&lt;enemyScript&gt;(); 
        } 

        // Update is called once per frame 
        void Update () { 
            if (!bGameover) { 

                int playerHealth = pScript.health; 
                int enemyHealth = eScript.health; 

                /* Debug.Log("PlayerHealth: " + playerHealth + "  
                EnemyHealth: " + enemyHealth); */ 

                if (playerHealth&lt;= 0 || enemyHealth&lt;= 0) { 
                    bGameover = true; 
                    Debug.Log(" +++++ GAMEOVER +++++"); 
                } 
            } 
        } 
    } </pre><p>At the top of the class, we created three variables. The first two are for getting access to the player and enemy scripts. The third variable is a public Boolean that sets whether the game is over or not. Since it is the start of the game and it is not over yet, we set it to false at the start.</p><p>In the <code class="literal">Start</code> function, we found the player and the enemy and got access to the individual scripts using the get component function.</p><p>Then, in the <code class="literal">Update</code> function ,we first checked whether the game is not over. If it is not over, then we get the player's and enemy's health and store it in a local variable called <code class="literal">playerHealth</code> and <code class="literal">enemyHealth</code>, respectively.</p><p>We then do a check if the player health or the enemy health is less than or equal to 0. If that is the case then we set the <code class="literal">bGameover</code> Boolean variable to <code class="literal">true</code> and the <code class="literal">Debug.log</code> is called, that it is gameover.</p><p>Now for the script to actually run it needs to be attached to an object in the scene. It could be a dummy object or any other object in the scene. Luckily we have a camera that is just sitting there and is part of the scene. So, we will attach the <code class="literal">gameScript</code> to the camera as a component.</p><p>Once the script is attached to the camera run the game and see if it reaches gameover condition:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_05_002.png" /></div><p>You will notice now that even though the game is over, the enemy keeps punching the player and the player can still punch the enemy. We don't want this as it may lead to some unnecessary bugs in the game.</p><p>So, in the player and enemy scripts, we need to get access to the <code class="literal">gameScript</code> class and make sure that once it is gameover, nothing updates. In the player's class, we will create a new <code class="literal">GameObject</code> called <code class="literal">mainCamera</code> at the top of the class as shown in the following code:</p><pre class="programlisting">    public class playerScript : MonoBehaviour { 

        public int health = 100; 
        public int damage = 20; 

        float totalTime = 0.0f; 
        float timeSinceLastHit = 0.0f; 
        float hitTimeInterval = 0.0f; 

        private Animator anim; 

<span class="strong"><strong>        public GameObject mainCamera;</strong></span>

        // other code 
    } </pre><p>In the <code class="literal">Update</code> function, we get access to the <code class="literal">gameScript</code> complement of the camera and then whatever is in the <code class="literal">Update</code> function, we put it in an <code class="literal">if</code> condition, which will check whether the game is over.</p><p>If the game is not over, then everything inside the <code class="literal">if</code> condition will be updated. Otherwise, it will skip through and not update. Here is the updated <code class="literal">Update</code> function (no pun intended):</p><pre class="programlisting">    void Update () { 
        gameScript gScript = mainCamera.GetComponent&lt;gameScript&gt;(); 

        if (!gScript.bGameover) { 
            totalTime += Time.deltaTime; 

            //Getting Hit  
            GameObject enemy = GameObject.Find("Enemy"); 
            Animator eAnim = enemy.GetComponent&lt;Animator&gt;(); 
            enemyScript eScript = enemy.GetComponent&lt;enemyScript&gt;(); 

            if (eScript.isPunching == true) { 
                if (anim.GetBool("bIsDefending") == false) { 

                    //Debug.Log("player got hit"); 
                    anim.SetTrigger("tGotHit"); 

                    health -= eScript.damage; 
                    Debug.Log("Player Health: " + health); 
                } 
            } 
            // Defending 
            if (Input.GetButtonDown("Fire2")) { 
                //Debug.Log("Jump pressed"); 
                anim.SetBool("bIsDefending", true); 
            } 
            else if (Input.GetButtonUp("Fire2")) { 
                anim.SetBool("bIsDefending", false); 
            } 

            // Debug.Log("Delta time" + timeChangeInMillis); 
            // Attacking 
            if (totalTime&gt;= timeSinceLastHit + hitTimeInterval) { 
                if (Input.GetButtonDown("Fire1")) {     
                    anim.SetBool("bIsDefending", false); 
                    anim.SetTrigger("tIsPunching"); 

                    timeSinceLastHit = totalTime; 
                    //Debug.Log("Fire pressed"); 
                } 
            } 
        } // check if gameover 
    } // update  </pre><p>Now, we have to do the similar operations on enemy script as well. Here is the updated code for the enemy class:</p><pre class="programlisting">    using UnityEngine; 
    using System.Collections; 

    public class enemyScript : MonoBehaviour { 

        public int health = 100; 
        public int damage = 10; 

        private Animator anim; 

        public GameObjectmainCamera; 

        // public GameObject player; 

        int myTick = 0; 
        int currentTick = 0; 
        int prevTick = 0; 
        int nextTick = 10; 
        int punchTick = 0; 

        public bool isPunching = false; 

        int[] pattern = new[] {120, 30, 180, 30, 60, 30, 40, 60, 180,  
                               30, 30, 30 ,120, 60, 60, 180, 30, 30,  
                               120, 30 }; 
        int patternCount = 0; 
        // Use this for initialization 

        void Start () { 
            anim = GetComponent&lt;Animator&gt;(); 
            anim.SetBool("bEnemyIsDefending", true); 

            Shuffle(pattern); 

            nextTick = pattern[0]; 
        } //start 

        // Update is called once per frame 
        void Update () { 

            punchTick--; 
            myTick++; 
            currentTick = myTick; 
     
            gameScript gScript = mainCamera.GetComponent&lt;gameScript&gt;(); 

            if (!gScript.bGameover) { 

                GameObject player = GameObject.Find("theDude"); 
                Animator pAnim = player.GetComponent&lt;Animator&gt;(); 
                playerScript pScript = player.GetComponent&lt;playerScript&gt;(); 

                //Getting Hit 
                if (pAnim.GetBool("tIsPunching")) { 
                    if (anim.GetBool("bEnemyIsDefending") == false) { 
                        // Debug.Log("enemy got hit"); 
                        anim.SetTrigger("tEnemyGotHit"); 
                        anim.SetBool("bEnemyIsDefending", true); 

                        health -= pScript.damage; 

                        Debug.Log("Enemy Health: " + health); 
                    } 
                } 
     
                if (currentTick == prevTick + nextTick) { 
                    int choice = Random.Range(1, 4); 
                    // Debug.Log("Choice" + choice); </pre><p>Depending on a random number going from one to three, we will choose whether the AI will punch, defend, or be idle:</p><pre class="programlisting">                switch (choice) 
                { 
                    //will punch 
                    case 1: 
                        anim.SetBool("bEnemyIsDefending", false); 
                        anim.SetTrigger("tEnemyIsPunching"); 
                        anim.SetBool("bEnemyIsDefending", true); 
                        isPunching = true; 
                        punchTick = 1; 
                        break; 

                    //will defend 
                    case 2: 
                        anim.SetBool("bEnemyIsDefending", true); 
                        break; 

                    //will be idle  
                    case 3:  
                        anim.SetBool("bEnemyIsDefending", false);  
                        break; 
                } 

                prevTick = currentTick; 
                nextTick = pattern[patterCount];//Random.Range(20, 300); 

                if ((patterCount + 1) &gt;= pattern.Length) { 
                    patterCount = 0; 
                    Shuffle(pattern); 
                }  
                else { 
                    patterCount++; 
                } 
            } 

            if (punchTick&lt;= 0) { 
                punchTick = 0; 
                isPunching = false; 
            } 
        } // check if gameover 
    } // Update </pre><p>The <code class="literal">Shuffle</code> function rearranges the initial array so that we get a different set of random numbers:</p><pre class="programlisting">    void Shuffle(int[] a) {  
        for (int i = a.Length - 1; i &gt; 0; i--){ 
            int rnd = Random.Range(0, i); 
            int temp = a[i]; 

            a[i] = a[rnd]; 
            a[rnd] = temp; 
        } 

        for (int i = 0; i &lt;a.Length; i++){ 
            // Debug.Log(a[i]); 
        } 

    } // shuffle </pre><p> </p><p> </p></div>