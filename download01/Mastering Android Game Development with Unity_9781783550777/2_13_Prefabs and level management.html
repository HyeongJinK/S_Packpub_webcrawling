<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Prefabs and level management</h2></div></div><hr /></div><p>There is not a single game which doesn't contain at least one level. Levels are what makes games feel like an experience and adventure. Levels come with different kinds of difficulties and players start to have feelings of accomplishing something and rewards. So, to put the soul in our Penguin Perky game, let's add levels to our game. But the question that arises here is what type of levels we should add to the game. Since the game is endless, so it would be a very suitable to add automatically generated levels with random obstacles and enemies in the game. In order to do that, we need a script that will take care of generating random environments and rooms along with putting enemies and barriers to balance the game difficulty.</p><p>Unity provides developers with the opportunity to instantiate the game objects at runtime and define behaviours in them, also at runtime. We can add rooms, levels, coins, enemies, and so on separately at runtime but Unity provides a better and organized way to handle these types of situations to manage reusable elements at runtime. This is done through the Prefab objects. Let's discuss Prefabs in the next section.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec24"></a>Prefabs</h3></div></div></div><p>According to Unity's documentation, a Prefab is a type of asset--a reusable <code class="literal">GameObject</code> stored in <strong class="userinput"><code>Project View</code></strong>. Prefabs can be inserted into any number of scenes, multiple times per scene. When you add a Prefab to a scene, you create an instance of it. All Prefab instances are linked to the original Prefab and are essentially clones of it. No matter how many instances exist in your project, when you make any changes to the Prefab, you will see the change applied to all instances.</p><p>The following screenshot shows the empty Prefab in the Project browser view:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_027.png" /></div><p>Figure 2.25 An empty BoxPrefab in the Project browser panel</p><p>You will notice that we have a folder called Prefabs in our Assets directory. We created this folder when configuring the project. We will store all the Prefabs used in the game in this directory.</p><p>Prefabs are exactly like game objects. They can have colliders, rigid body, scripts, other components, and so on. The only difference between Prefabs and game objects is that Prefabs can be instantiated at runtime and copy the same behavior at runtime, but game objects can be generated at runtime.</p><p>In order to create an endless level, we have to create a small block of levels for our game. This block will be continuously generated at runtime over and over again as the penguin keeps going through the level. Let's create the small level block in the next section and see how this Prefab theory goes into action.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec25"></a>Creating a Level Block Prefab</h3></div></div></div><p>The Level Block Prefab will have a ground object and a ceiling object to avoid the penguin going out of the bounds from the screen and it will have an environment in the background for decoration and theme purposes.</p><p>Let's start by creating an empty game object in the <strong class="userinput"><code>Hierarchy</code></strong> by right-clicking in hierarchy view and clicking <strong class="userinput"><code>Create Empty</code></strong>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_028.png" /></div><p>Figure 2.26 Creating an empty GameObject</p><p>Now, put all the necessary game objects to be included in the Prefab as a child of this empty game object. We are adding <code class="literal">snow_bg1</code> and <code class="literal">snow_bg2</code> backgrounds, the <code class="literal">floor</code> object, and the <code class="literal">ceiling</code> object at the moment. We can update it later at any time and add new objects and components in the Prefabs. But you must remember that it would change all the existing Prefab objects as well, so you must be careful when you update the Prefab.</p><p>All these objects can be dragged onto the empty created game object to make these children and rename the empty game object <code class="literal">level_block</code> then. The following screenshot shows the game object hierarchy of the <code class="literal">level_block</code> object:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_029.png" /></div><p>Figure 2.27 The level_block game object</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"></a>Note</h3><p>If you have decorated your level block with more objects, decorations, surroundings, and so on, then you should also add them to the level block empty game object.</p></div><p>We have created a level block game object. Now it's time to put it into Prefab form. To do that, right-click on the <strong class="userinput"><code>Prefabs</code></strong> folder in the <strong class="userinput"><code>Assets</code></strong> directory, and choose <strong class="userinput"><code>Create - Prefab</code></strong> from the menu, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_030.png" /></div><p>Figure 2.28 Creating a Prefab</p><p>It will create an empty Prefab in the <strong class="userinput"><code>Prefabs</code></strong> folder. Now, drag the <strong class="userinput"><code>level_block</code></strong> game object from the hierarchy view onto the empty created Prefab and your Prefab will be ready. This is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_031.png" /></div><p>Figure 2.29 Adding an Object to a Prefab</p><p>Once the Prefab is created, it will show you a small preview of the game object contents in the <strong class="userinput"><code>Project Browser</code></strong> panel. You will also observe a small arrow in it, which will explore all the objects put into the Prefab as well. The following screenshot shows the preview of <strong class="userinput"><code>Level Block Prefab</code></strong> in the <strong class="userinput"><code>Project Browser</code></strong> panel:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_032.png" /></div><p>Figure 2.30 Prefab in Project Browser Panel</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"></a>Note</h3><p>The Prefabs can be used in any scenes. These are reusable anywhere throughout the project.</p></div><p>In order to see how the Prefabs will work at runtime, just drag our Level Block Prefab object into the scene a few times in different positions and see how it comes in the view. The following screenshot shows a few level blocks placed in a scene:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_033.png" /></div><p>Figure 2.31 Level Block Prefabs placed randomly in the scene</p><p>You can observe that whenever we drag any Prefab into the scene, it creates the whole block, consisting of all the functionality, child objects, behaviors, scripts, and so on. That is the main advantage of using Prefabs in Unity.</p><p>Our Level Block Prefab is ready. Now we have to tell Unity when to create the block at runtime and at what positions it should be instantiated. We will do this by adding a script called <code class="literal">BlockGenerator.cs</code> into the penguin object. Let's explain about this generator in the next section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec26"></a>The level block generator concept</h3></div></div></div><p>The idea behind the generator script is quite simple. The script has an array of level blocks it can generate (for now, we have only one block created), a list of blocks currently generated, and two additional methods. One method checks to see whether another block needs to be added and the other method actually adds a block.</p><p>To check whether a block needs to be added, the script will enumerate all existing rooms and see whether there is a room ahead, farther than the screen width, to guarantee that the player never sees the end of the level. To understand this more clearly, let's look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_034.png" /></div><p>Figure 2.32 Level block generator idea</p><p>You can see in scenario 1, there is enough space or width yet to cover some distance in the block. But in scenario 2, there is not enough space to cover, because as the penguin moves forward, the empty space will start to show up. So before it shows any blank space, we need to add a new level block beside the current block so that the player never sees any empty spaces there. The figure only tries to clarify the rough concept of how the new block will be added and when. The following screenshot shows a sample generation of blocks and our penguin's moving forward status:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_035.png" /></div><p>Figure 2.33 Penguin Moving Forward and Level Blocks Generating</p><p>You can see that as the penguin keeps moving forward, new blocks will be generating over and over again. Once any block leaves the screen, it will be deleted to optimize the memory usage and increase game performance.</p><p>Let's now bring this whole scenario into action by writing the <code class="literal">BlockGenerator.cs</code> code in the next section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec27"></a>The BlockGenerator.cs code</h3></div></div></div><p>Let's start by creating an empty C# script file in the Scripts folder of the Assets directory with the name <code class="literal">BlockGenerator.cs</code>. Then drag this script onto the penguin object to apply on the penguin.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"></a>Note</h3><p>Any game object can have many scripts applied to it. There is no restriction of scripts or components applied on the game objects.</p></div><p>Open <code class="literal">BlockGenerator.cs</code> in <code class="literal">MonoDevelop</code> by double-clicking it in the <strong class="userinput"><code>Project </code></strong>view or in the <strong class="userinput"><code>Inspector </code></strong>panel.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>You have to add the <code class="literal">System.Collections.Generic</code> namespace if you're going to use the <code class="literal">List&lt;T&gt;</code> class.</p></div><p>Add the following field variables into the <code class="literal">BlockGenerator</code> class:</p><pre class="programlisting">    public GameObject[] availableBlocks;
    public List&lt;GameObject&gt; currentBlocks;
    private float screenWidthInPoints;</pre><p><code class="literal">availableBlocks</code> will contain an array of Prefabs which the script can generate. Currently, we have only one Prefab (<code class="literal">LevelBlockPrefab</code>). But we can create many different blocks types and add them all to this array, so that the script could randomly choose which block type to generate. The <code class="literal">currentBlocks</code> list will store instanced blocks, so that it can check where the last block ends and whether it needs to add more blocks. Once the block is behind the player character, it will remove it as well. The <code class="literal">screenWidthInPoints</code> variable is just required to cache screen size in points.</p><p>You can see these fields in the <strong class="userinput"><code>Inspector </code></strong>view of the penguin game object, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_037.png" /></div><p>Figure 2.34 Block Generator Fields in Inspector</p><p>Now, add the following code in the <code class="literal">Start()</code> method of the <code class="literal">BlockGenerator.cs</code> file:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_038.png" /></div><p>Here you calculate the size of the screen in points. The screen size will be used to determine whether you need to generate a new block, described previously.</p><p>Add the following <code class="literal">AddBlock()</code> method to <code class="literal">BlockGenerator.cs</code>:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_039.png" /></div><p>This method adds a new block using the <code class="literal">farhtestBlockEndX</code> point, which is the rightmost point of the level so far. Here is description of every line of this method:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Picks a random index of the block type (Prefab) to generate.</li><li style="list-style-type: disc">Creates a block object from the array of available blocks using the random index above.</li><li style="list-style-type: disc">Since the block is empty containing all the block parts, you cannot simply take its size. Instead, you get the size of the floor inside the block, which is equal to the block's width.</li><li style="list-style-type: disc">When you set the block position, you set the position of its center so you add the half block width to the position where the level ends. This way gets the point at which you should add the block, so that it starts straight after the last block.</li><li style="list-style-type: disc">This sets the position of the block. You need to change only the x-coordinate since all blocks have the same y and z coordinates equal to zero.</li><li style="list-style-type: disc">Finally, you add the block to the list of current blocks. It will be cleared in the next method, which is why you need to maintain this list.</li></ul></div><p>After the <code class="literal">AddBlock()</code> method, let's go into the details of the <code class="literal">GenerateBlockIfRequired()</code> method:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_040.png" /></div><p>This method is the implementation of the idea explained in the previous section:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Creates a new list to store blocks that need to be removed. Separate lists are required since you cannot remove items from the list while you are iterating through it.</li><li>This is a flag that shows whether you need to add more blocks. By default, it is set to true, but most of the time it will be set to false inside the <code class="literal">foreach</code>.</li></ol></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Saves player position.</li><li>This is the point after which the block should be removed. If a block's position is behind this point (to the left), it needs to be removed.</li><li>If there is no block after the <code class="literal">addBlockX</code>point, you need to add a block, since the end of the level is closer than the screen width.</li><li>In <code class="literal">farthestBlockEndX</code>, you store the point where the level currently ends. You will use this variable to add a new block if required, since the new block should start at that point to make the level seamless.</li><li>In <code class="literal">foreach</code>, you simply enumerate the current blocks. You use the floor to get the block width and calculate the <code class="literal">BlockStartX</code> (the point where the block starts, the leftmost point of the block) and <code class="literal">BlockEndX</code> (the point where the block ends, the rightmost point of the block).</li><li>If there is a block that starts after <code class="literal">addBlockX</code> then you don't need to add blocks right now. However, there is no <code class="literal">break</code> instruction here, since you still need to check whether this block needs to be removed.</li><li>If a block ends to the left of the <code class="literal">removeBlockX</code> point, then it is already off the screen and needs to be removed.</li><li>Here you simply find the rightmost point of the level. This will be the point where the level currently ends. It is used only if you need to add a block.</li><li>This removes blocks that are marked for removal. The mouse <code class="literal">GameObject</code> already flew through them and thus they are far behind, so you need to remove them.</li><li>If at this point <code class="literal">addBlocks</code> is still <code class="literal">true</code>, then the level end is near. <code class="literal">addBlocks</code> will be true if it didn't find a block starting farther than the screen width. This indicates that a new block needs to be added.</li></ol></div><p>So, after all this explanation, let's add our final method, <code class="literal">FixedUpdate()</code> to the the <code class="literal">BlockGenerator.cs</code> files as follows:</p><pre class="programlisting">    void FixedUpdate() 
    {
        GenerateBlockIfRequired(); 
    }</pre><p>Generating blocks in <code class="literal">FixedUpdate()</code> will continue to periodically make sure that the player never experiences blank space in the game. Now, return to Unity and select the <span class="emphasis"><em>penguin</em></span> GameObject in the Hierarchy. In the Inspector, find the <code class="literal">BlockGenerator</code> component. Drag the <strong class="userinput"><code>LevelBlockPrefab</code></strong> from the <strong class="userinput"><code>Hierarchy</code></strong> to the <strong class="userinput"><code>Current Blocks</code></strong> list. Then open the <strong class="userinput"><code>Prefabs </code></strong>folder in <strong class="userinput"><code>Project Browser</code></strong> and drag <strong class="userinput"><code>LevelBlockPrefab</code></strong> from it to <strong class="userinput"><code>Available Blocks. </code></strong>The following screenshot shows the <code class="literal">BlockGenerator</code> component of the penguin object after adding Prefabs in the lists:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_042.png" /></div><p>Figure 2.35 Block Generator Component with Prefabs</p><p>Now run the project and you will see that blocks will keep generating. Note that blocks are appearing and disappearing in the Hierarchy while you fly. And for even more fun, run the scene and switch to the <span class="emphasis"><em>Scene View</em></span> without stopping the game. This way, you will see how blocks are added and removed in real time.</p><p>So, after level generation, let's discuss how to add obstacles such as ice spikes in the game to make the penguin be little careful while going through the level in the next section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec28"></a>Adding ice spikes to the game</h3></div></div></div><p>The penguin flying through the level looks great but the game is all about the challenges and obstacles. So, this section is all about the obstacles which can be added to the game. We will add ice spikes, which will be generated randomly in a similar manner as you generate blocks. Let's create the ice spike first. You need two images for the spikes on and spikes off states.</p><p>The following screenshot shows the spikes on and spikes off states:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_043.png" /></div><p>Figure 2.36 Block generator fields in Inspector pane</p><p>Import these images into Unity with the names <code class="literal">spike_on.png</code> and <code class="literal">spike_off.png</code> in the <strong class="userinput"><code>Graphics</code></strong> folder of the <strong class="userinput"><code>Assets</code></strong> directory. And then we have to create a Prefab of the spike for it. So, here are the steps below:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In the <strong class="userinput"><code>Project</code></strong> view, find the <code class="literal">spike_on</code> sprite and drag it to the scene.</li><li>Select it in the <strong class="userinput"><code>Hierarchy</code></strong> and rename it <code class="literal">spike</code>.</li><li>Set its <strong class="userinput"><code>Sorting Layer</code></strong> to <strong class="userinput"><code>Objects</code></strong><span class="emphasis"><em>.</em></span></li><li>Add a <strong class="userinput"><code>Box Collider 2D</code></strong> component.</li><li>Enable the <strong class="userinput"><code>Is Trigger</code></strong> property in the <strong class="userinput"><code>Box Collider 2D</code></strong> component.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"></a>Note</h3><p>When the Is Trigger property is enabled, the collider will trigger collision events, but will be ignored by the physics engine.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Set the <strong class="userinput"><code>Size</code></strong> of the collider, <span class="emphasis"><em>X</em></span> to <span class="emphasis"><em>0.18</em></span> and <span class="emphasis"><em>Y</em></span> to <span class="emphasis"><em>3.1</em></span>.</li><li>Create a new C# s<span>cript</span> named <code class="literal">SpikeScript.cs</code> in the <strong class="userinput"><code>Scripts</code></strong> folder and attach it to the <code class="literal">spike</code> <span>game object.</span></li></ol></div><p>The following screenshot shows all the steps done here to create a <strong class="userinput"><code>spike</code></strong> GameObject:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_044.png" /></div><p>Fig 2.37 Adding a spike game object</p><p>Now open <code class="literal">SpikeScript.cs</code> and add the following fields in the class:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_045.png" /></div><p>Then add the following code in the <code class="literal">Start()</code> method like this:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_046.png" /></div><p>This will set the time until the spike should toggle its state for the first time. Then, to toggle and rotate the spike, add <code class="literal">FixedUpdate()</code> with the following:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_047.png" /></div><p>Now, select <code class="literal">spike</code> in the Hierarchy. Drag the <code class="literal">spike_on</code> sprite from project browser to the Spike On Sprite property of the <code class="literal">SpikeScript</code> component in the inspector view. Also, do it for the <code class="literal">spike_off</code> sprite as well. Set Rotation speed to 30 and position to (2, 0.25, 0). Run the project and you will get a spike nicely rotating and finally turn into spike game object into a SpikePrefab in spikes folder as we did in the earlier section.</p><p>The following screenshot shows the spike running in the game:</p><div class="mediaobject"><img src="/graphics/9781783550777/graphics/image_02_048.png" /></div><p>Figure 2.38 Spike in the game</p></div></div>