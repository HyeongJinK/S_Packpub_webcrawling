<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec46"></a>Give it a start screen</h2></div></div><hr /></div><p>Finally, to wrap everything up, let's go through implementing a quick, button-based dialog. We're going to add in a start screen<a id="id166" class="indexterm"></a> with a simple logo to the game as well as a start button.</p><p>As discussed earlier, using Unity's GUI system is generally not the best option due to its drawbacks, so we will be using more sprites here. There are two key problems with Unity's native GUI system. The first is performance—it is very slow compared to other solutions due to using a lot of render calls. Secondly, it is extraordinarily time consuming to build a UI with. There is no visual editor, which means you have to write everything in code; it's like HTML in the early '90s all over again. Many people, however, do swear by Unity's native GUI, but overall it's not for everyone. This is exactly why Unity is working on overhauling the entire system with a new GUI system to be added in a future update to the engine.</p><p>Let's create some containers so that we can show only what we want. Create two empty GameObjects and make them both the children of the <span class="strong"><strong>Main Camera</strong></span> object. Name the first one <code class="literal">Container - HUD</code> and the second one <code class="literal">Container - Start</code>. Set the position of both of these GameObjects to <code class="literal">X: 0</code>, <code class="literal">Y: 0</code>, <code class="literal">Z: 0</code> to position them at the center of the camera. Move the <span class="strong"><strong>Round</strong></span> and <span class="strong"><strong>Score</strong></span> objects to the project <span class="strong"><strong>Hierarchy</strong></span> tab so that they become the children of the <span class="strong"><strong>Container - HUD</strong></span> object.</p><p>Import the <code class="literal">Title Screen</code> imagery to the project and set them up as sprites like you have done before. Place the <span class="strong"><strong>Title</strong></span> sprite in the <span class="strong"><strong>Container - Start</strong></span> object, give it a nice position and scale, and set the <span class="strong"><strong>Order in Layer</strong></span> field to <code class="literal">100</code> so that it appears in front of everything else.</p><p>Now for the start button! Add another empty GameObject, name it <code class="literal">Start Button</code>, and place it inside the <span class="strong"><strong>Container – Start</strong></span> object. Give them both an <span class="strong"><strong>Order in Layer</strong></span> property of <code class="literal">100</code>, and make sure they are both in the exact same location with the exact same scale. Add a <span class="strong"><strong>Box Collider 2D</strong></span> component on the <span class="strong"><strong>Start Button</strong></span> object itself, and make sure the collider completely surrounds the button imagery inside. The <span class="strong"><strong>Box Collider 2D</strong></span> component will actually allow the StartButtonController script, which we will write in a couple pages, to accept mouse events.</p><p>Your hierarchy should<a id="id167" class="indexterm"></a> now look a little something like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692564/graphics/2564OT_06_02.jpg" /></div><p>If you're worried that the gameplay elements—enemies and the player—could collide with the UI, then you have a very valid concern! Addressing this is easy. First, add a new layer called <code class="literal">UI</code>. Now, set all of the UI elements to the <span class="strong"><strong>UI</strong></span> layer. Finally, adjust <span class="strong"><strong>Physics 2D</strong></span> <span class="strong"><strong>Layer Collision Matrix</strong></span> in the physics settings, just like before, to prevent collisions. After you edit the matrix, you'll have a setup that looks like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692564/graphics/2564OT_06_03.jpg" /></div><p>You should now have a <a id="id168" class="indexterm"></a>screen that looks something like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692564/graphics/2564OT_06_01.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"></a>Tip</h3><p>While Unity is, at the time of this writing, working on integrating an all-new GUI system, there are some excellent GUI solutions in the asset store. For example, check out NGUI and Scaleform.</p></div><p>Now you've got a <a id="id169" class="indexterm"></a>basic title screen set up. Let's add in some basics so that we can control which UI containers are displayed. Add a new script called <code class="literal">GameStates</code>, attach it to the <span class="strong"><strong>Main Camera</strong></span>, and make it look like the following script. You could technically add the <code class="literal">GameStates</code> script to any object—the camera is just a nice, existing central object.</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class GameStates : MonoBehaviour 
{
    public GameObject hudContainer;
    public GameObject titleContainer;
    public static bool gameActive = false;

    public enum displayStates
    {
        titleScreen = 0,
        hudScreen
    }

    void Start()
    {
        changeDisplayState(displayStates.titleScreen);
    }

    public void changeDisplayState(displayStates newState)
    {
        hudContainer.SetActive(false);
        titleContainer.SetActive(false);

        switch(newState)
        {
            case displayStates.titleScreen:
                gameActive = false;
                titleContainer.SetActive(true);
            break;

            case displayStates.hudScreen:
                gameActive = true;
                hudContainer.SetActive(true);
            break;
        }
    }

    public void startGame()
    {
        changeDisplayState(displayStates.hudScreen);
    }
}</pre></div><p>The last thing you will need is a way to interface with the <span class="strong"><strong>START!</strong></span> button. Create one final script <a id="id170" class="indexterm"></a>called <code class="literal">StartButtonController</code> and code it as shown in the following script:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class StartButtonController : MonoBehaviour
{
    public GameObject upSprite;
    public GameObject downSprite;
    public float downTime = 0.1f;
    public GameStates stateManager = null;
    
    private enum buttonStates
    {
        up = 0,
        down
    }
    
    private buttonStates currentState = buttonStates.up;
    private float nextStateTime = 0.0f;
    
    void Start()
    {
        upSprite.SetActive(true);
        downSprite.SetActive(false);
    }
    
    void OnMouseDown()
    {
        if(nextStateTime == 0.0f &amp;&amp; currentState == StartButtonController.buttonStates.up)
        {
            nextStateTime = Time.time + downTime;
            upSprite.SetActive(false);
            downSprite.SetActive(true);
            currentState = StartButtonController.buttonStates.down;
        }
    }
    
    void Update()
    {
        if(nextStateTime &gt; 0.0f)
        {
            if(nextStateTime &lt; Time.time)
            {
                // Set the button back to its 'up' state
                nextStateTime = 0.0f;
                upSprite.SetActive(true);
                downSprite.SetActive(false);
                currentState = StartButtonController.buttonStates.up;
                
                // Start the game!
                stateManager.startGame();
            }
        }
    }
}</pre></div><p>Now that you've added <code class="literal">StartButtonController</code> to the start button, populate its various fields and you can<a id="id171" class="indexterm"></a> try it out! Now when you start the game, it will launch on the title screen, and when you click on the <span class="strong"><strong>START!</strong></span> button, it will go to the gameplay we have seen this whole time.</p><p>Once you play the game, you will probably notice the one final thing we need to clean up. The player is able to move on the title screen. Let's use that global <code class="literal">GameStates.gameActive</code> Boolean field to fix that.</p><p>Let's fix the player movement first. Open <code class="literal">PlayerStateController</code>, and at the beginning of <code class="literal">LateUpdate()</code>, add the following code:</p><div class="informalexample"><pre class="programlisting">if(!GameStates.gameActive)
    return;</pre></div><p>Now the game won't accept any input unless it is actually active. Other ways to accomplish this include setting the timescale of the engine to <code class="literal">0</code> when the game isn't running, or only generating the player and enemies after the game starts. Also, if you haven't done so already, remove the enemy from the center platform. We don't need him to be on top of the player as soon as the game starts!</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Tip</h3><p>
<span class="strong"><strong>Pro tip</strong></span>
</p><p>Using sprites or 3D models for our GUIs gives us the added benefit of having animated elements. Try your hand at making the buttons scale, the UI slide in and out of the screen, and in general, just have fun with Unity's animation tool to create awesome GUI animations!</p></div></div>