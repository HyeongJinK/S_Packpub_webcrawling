<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec30"></a>Make it move</h2></div></div><hr /></div><p>For the purpose of this <a id="id115" class="indexterm"></a>game, we're going to have the enemies walk back and forth on the platforms. The concept we're going to use here is that of a main object with two notification objects. The notification objects sit on either side of the <span class="strong"><strong>Enemy</strong></span> object and simply tell it when it is about to walk off of a platform object. The notification objects do this by acting as <span class="strong"><strong>triggers</strong></span>
<a id="id116" class="indexterm"></a> and checking to see when they have left the collision area of the <span class="strong"><strong>Platform</strong></span> object:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create two empty GameObjects. Name them <code class="literal">LeftGuide</code> and <code class="literal">RightGuide</code> respectively, and then make these children of the <span class="strong"><strong>Enemy</strong></span> object.</p></li><li><p>Give each one a Box Collider 2D component, check the <span class="strong"><strong>Is Trigger</strong></span> boxes on both, and set their <span class="strong"><strong>Size</strong></span> property as <code class="literal">X: 0.48</code>, <code class="literal">Y: 0.64</code>.</p></li><li><p>Arrange them so that they are on either side of the enemy, outside of its main Box Collider 2D, and just off to the sides of the visual sprite. The following screenshot shows how that looks:</p><div class="mediaobject"><img src="/graphics/9781849692564/graphics/2564OT_03_03.jpg" /></div></li><li><p>Now, create a new script called <code class="literal">EnemyGuideWatcher</code> and code it up as follows:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class EnemyGuideWatcher : MonoBehaviour
{
    public EnemyControllerScriptenemyObject = null;
    
        void OnTriggerExit2D( Collider2D otherObj )
    {
        // If this trigger just left a Platform object, //then the enemy is about to walk off the platform. //Tell the enemy that they need to switch //directions!
        if(otherObj.tag == "Platform")
            enemyObject.switchDirections();
    }
}</pre></div></li><li><p>Attach <code class="literal">EnemyGuideWatcher</code> to both the <span class="strong"><strong>LeftGuide</strong></span> and the <span class="strong"><strong>RightGuide</strong></span> objects and make sure to add the <span class="strong"><strong>Enemy</strong></span> object to the <span class="strong"><strong>Enemy Object</strong></span> field on both objects in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li></ol></div><p>Next, we need to make <a id="id117" class="indexterm"></a>sure the enemy knows how to flip its direction by reversing its movement direction, just like we did with the player back in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introduction to the 2D World of Unity</em></span>. Go back to <code class="literal">EnemyControllerScript</code> and give it some code. Fill the script with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class EnemyControllerScript : MonoBehaviour
{
    public float walkingSpeed = 0.45f;
    private bool walkingLeft = true;
    
    void Start()
    {
        // Randomly default the enemy's direction
        walkingLeft = (Random.Range(0,2) == 1);
        updateVisualWalkOrientation();
    }
    
    void Update()
    {
// Translate the enemy's position based on the direction // that they are currently moving.
        if(walkingLeft)
        {
            transform.Translate(new Vector3(walkingSpeed * 
                Time.deltaTime, 0.0f, 0.0f));
        }
        else
        {
            transform.Translate(new Vector3((walkingSpeed * -1.0f) * Time.deltaTime, 0.0f, 0.0f));
        }
    }
    
    public void switchDirections()
    {
        // Swap the direction to be the opposite of whatever it 
        // currently is
        walkingLeft = !walkingLeft;
        
        // Update the orientation of the Enemy's material to match //the new walking direction
        updateVisualWalkOrientation();
    }
    
    void updateVisualWalkOrientation()
    {
        Vector3 localScale = transform.localScale;
        if(walkingLeft)
        {
            if(localScale.x&gt; 0.0f)
            {
                localScale.x = localScale.x * -1.0f;
                transform.localScale  = localScale;
            }
        }
        else
        {
            if(localScale.x&lt; 0.0f)
            {
                localScale.x = localScale.x * -1.0f;
                transform.localScale  = localScale;              
            }
        } 
    }

}</pre></div><p>Now you have a <a id="id118" class="indexterm"></a>setup where the enemy can walk back and forth on a platform and switch directions before walking off of the ledge. With all the scripts in place, put the enemy on a platform and hit play. Now you can watch them walk back and forth! Regardless of what platform you put the enemy on, they will now walk back and forth across it.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip10"></a>Tip</h3><p>
<span class="strong"><strong>Pro tip</strong></span>
</p><p>With a solid knowledge of Unity's programming system, you could easily customize an enemy so that when it reaches the end of a platform, they will look for another nearby platform and then jump to it, rather than only switching directions. Try adding some additional logic and see what else you can make the enemy do!</p></div></div>