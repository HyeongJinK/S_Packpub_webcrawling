<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Jump to it!</h2></div></div><hr /></div><p>Running back and forth<a id="id89" class="indexterm"></a> and falling off a platform to our death—now that is pretty cool! But you know what it isn't? JUMPING.</p><p>Jumping is going to use a number of new properties. However, most of them aren't anything that we haven't already worked with. Let's start by adjusting our states to support jumping.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec08"></a>Jumping for fun (and profit)</h3></div></div></div><p>First, we need to make it so that the player object can understand how to jump. Open up the <code class="literal">PlayerStateController</code> script. We are going to add a condition to check for jumping.</p><p>In the <code class="literal">LateUpdate</code> function of <code class="literal">PlayerStateController</code>, add the following code after all of the left/right/idle checks that we have previously added:</p><div class="informalexample"><pre class="programlisting">float jump = Input.GetAxis("Jump");
if(jump &gt; 0.0f)
{
if(onStateChange != null) onStateChange(PlayerStateController.playerStates.jump);
}</pre></div><p>We put this after <a id="id90" class="indexterm"></a>the left/right/idle checks so that we can find the current movement state. With this, we can determine what direction we want the player to jump in—or in other words, we are allowing the player to jump left and right as well as straight up.</p><p>OK, so now the player can be told that they are jumping. Next, let's make it actually jump! Head on over to <code class="literal">PlayerStateListener</code> and scroll on down to <code class="literal">onStateChange</code>. In the <code class="literal">newState</code> switch, add a case for jumping and make it look like the following:</p><div class="informalexample"><pre class="programlisting">case PlayerStateController.playerStates.jump:if(playerHasLanded)
    {
// Use the jumpDirection variable to specify if the player
// should be jumping left, right, or vertical
        float jumpDirection = 0.0f;
        if(currentState == PlayerStateController.playerStates.left)
        jumpDirection = -1.0f;
        else if(currentState == PlayerStateController.playerStates.right)
        jumpDirection = 1.0f;
        else
        jumpDirection = 0.0f;
        
        // Apply the actual jump force
        rigidbody2D.AddForce(new Vector2(jumpDirection * playerJumpForceHorizontal, playerJumpForceVertical));
        
        playerHasLanded = false;
        PlayerStateController.stateDelayTimer[ (int)PlayerStateController.playerStates.jump] = 0f;
    }
break;</pre></div><p>At the beginning of <code class="literal">PlayerStateListener</code>, add the following variable:</p><div class="informalexample"><pre class="programlisting">private bool playerHasLanded = true;</pre></div><p>Under the <code class="literal">switch</code> condition <code class="literal">currentState</code>, in the <code class="literal">checkForValidStatePair</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">case PlayerStateController.playerStates.jump:
    // The only state that can take over from Jump is landing     //or kill.
    if(newState == PlayerStateController.playerStates.landing
       || newState == PlayerStateController.playerStates.kill
       || newState == PlayerStateController.playerStates.firingWeapon
)
    returnVal = true;
else
    returnVal = false;
break;</pre></div><p>In the <code class="literal">onStateCycle</code> method, you don't need any special code. However, to keep things clear, make sure that it has a place for jumping using the following <code class="literal">jump</code> case:</p><div class="informalexample"><pre class="programlisting">case PlayerStateController.playerStates.jump:
break;</pre></div><p>Here, we've checked to<a id="id91" class="indexterm"></a> see if the player is moving left or right and then gave the player an impulse force based on its current movement direction. The last thing we need for jumping to work is to add the adjustable variables used in the <code class="literal">AddForce</code> command. At the top of <code class="literal">PlayerStateListener</code>, add the following public variables:</p><div class="informalexample"><pre class="programlisting">    public float playerJumpForceVertical = 500f;
    public float playerJumpForceHorizontal = 250f;</pre></div><p>Now, with these, you can easily and quickly adjust the values to find what seems best for you and your game.</p><p>Go ahead and play the game and press the jump button as assigned in the Input Manager for your project. By default, the jump button in Unity is always the Space bar. Your player should now jump up! You can even jump left or right while running for a running jump. Landing, on the other hand, doesn't do anything right now. Let's change that.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip07"></a>Tip</h3><p>Wouldn't it be cool if the player did an animation while jumping? Using what you've learned about animations and changing between them, challenge yourself to add in a jump animation!</p></div></div></div>