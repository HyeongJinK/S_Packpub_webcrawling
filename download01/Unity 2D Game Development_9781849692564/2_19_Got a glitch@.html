<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec24"></a>Got a glitch?</h2></div></div><hr /></div><p>Now, you may have noticed a small glitch<a id="id98" class="indexterm"></a> if you are holding down your jump button. The player can occasionally get stuck in the ground and then refuse to move or jump. The reason for this is how physics are checked. When objects are moving fast, often they will actually intersect another object before the collision detection occurs. This happens so fast your eyes will rarely ever actually notice it—but to the game's physics, it can mean the difference between working and... freezing in one place. We're now going to improve the capabilities of the state system to address this.</p><p>What we are going to do is add the ability for states to have a conditional check and, if certain conditions are true, abort them from occurring. We are then going to use that check to see if enough time has passed since the previous jump to allow us to jump again. This will ensure that enough time has passed for the physics of the previous landing to have finished resolving, without the player object being somewhat stuck in the ground.</p><p>Let's first add the ability for us to know how many states there are in the <code class="literal">playerState</code> enum. Open up <code class="literal">PlayerStateController</code> and change the bottom part of the <code class="literal">playerStates</code> enum to look like the following code snippet:</p><div class="informalexample"><pre class="programlisting">kill,
resurrect,
_stateCount // Adding this to check the state count</pre></div><p>The<code class="literal"> _stateCount </code>variable will <a id="id99" class="indexterm"></a>now display the actual number of states in the enum. This works because the enum starts at 0. So, whatever the last entry is, provided that the last entry is not an actual state itself, it will always read the correct number of states.</p><p>Next, let's add a new line of code just below the same enum:</p><div class="informalexample"><pre class="programlisting">public static float[] stateDelayTimer = new float[(int)playerStates._stateCount];</pre></div><p>This array will be used to perform any timer checks on the states. Most of the states will not have timers associated with them. However, this setup allows you to easily add timers in the future if, for any reason, you have or want to do so.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"></a>Note</h3><p>Remember that at any time you can make your code more flexible for the future; especially when it doesn't take any extra development time, <span class="emphasis"><em>always</em></span> make it more flexible. You will thank yourself five months from now when you suddenly need to build a huge custom event into the system in a weekend to meet a deadline.</p></div><p>Head on over to <code class="literal">PlayerStateListener</code>, and at the beginning, add the following code to the existing<code class="literal"> Start</code> method:</p><div class="informalexample"><pre class="programlisting">// Set up any specific starting values here
PlayerStateController.stateDelayTimer[ (int)PlayerStateController.playerStates.jump] = 1.0f;</pre></div><p>Now, our jump value has an initial timer value—this will be important (as you will see shortly). Now, go into <code class="literal">onStateChange</code> in <code class="literal">PlayerStateListener</code>. In the <code class="literal">jump</code> portion of the <code class="literal">switch</code> case, change the bottom part to look like the following just after <code class="literal">playerHasLanded = false</code>:</p><div class="informalexample"><pre class="programlisting">PlayerStateController.stateDelayTimer[ (int)PlayerStateController.playerStates.jump] = 0f;</pre></div><p>We use the fact that the timer is <code class="literal">0f</code> as part of our checks. If the timer is <code class="literal">0f</code>, then it is not running, and so we do not allow jumping. Specifically, the timer is not running while the player is in the middle of jumping or in the middle of falling, giving them all the time they need to land and start the timer again.</p><p>Having said that, <a id="id100" class="indexterm"></a>you will also need to change the <code class="literal">falling</code> case statement in the same <code class="literal">switch</code> condition. Make sure that it is like the following code:</p><div class="informalexample"><pre class="programlisting">PlayerStateController.stateDelayTimer[ (int)PlayerStateController.playerStates.jump] = 0f;</pre></div><p>Only one more change to make in this method—we need to add the code that starts the timer backup. In the <code class="literal">landing</code> check of this same <code class="literal">switch</code> condition, add the following line of code:</p><div class="informalexample"><pre class="programlisting">PlayerStateController.stateDelayTimer[(int)PlayerStateController.playerStates.jump]= Time.time + 0.1f;</pre></div><p>That line will cause jumping to be allowed again 0.1 seconds after landing occurs. Once <code class="literal">nextAllowedJumpTime</code> is equal to <code class="literal">0f</code>, we can jump again.</p><p>Almost there!</p><p>Now for the meat of the code that will control this new "conditional abort" functionality—at the very bottom of <code class="literal">PlayerStateListener</code>, add the following method:</p><div class="informalexample"><pre class="programlisting">//checkIfAbortOnStateCondition allows us to do additional state //verification, to see if there is any reason this state should // not be allowed to begin.
bool checkIfAbortOnStateCondition(PlayerStateController.playerStates newState)
{
    bool returnVal = false;
switch(newState)
    {
case PlayerStateController.playerStates.idle:
        break;
            
case PlayerStateController.playerStates.left:
        break;
            
case PlayerStateController.playerStates.right:
        break;
            
case PlayerStateController.playerStates.jump:
float nextAllowedJumpTime = PlayerStateController.stateDelayTimer[ (int)PlayerStateController.playerStates.jump ];
                
if(nextAllowedJumpTime == 0.0f || nextAllowedJumpTime &gt; Time.time)
    returnVal = true;
        break;
            
case PlayerStateController.playerStates.landing:
        break;
            
case PlayerStateController.playerStates.falling:
        break;
            
case PlayerStateController.playerStates.kill:
        break;
            
case PlayerStateController.playerStates.resurrect:
        break;
    }
        
// Value of true means 'Abort'. Value of false means 'Continue'.
        return returnVal;
}</pre></div><p>Now, we just need to<a id="id101" class="indexterm"></a> call the <code class="literal">checkIfAbortOnStateCondition</code> method when we do our state change. In <code class="literal">onStateChange</code>, just after the <code class="literal">newState == currentState</code> check, add the following code snippet:</p><div class="informalexample"><pre class="programlisting">//Verify there are no special conditions that would cause this //state to abort
if(checkIfAbortOnStateCondition(newState))
return;</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip09"></a>Tip</h3><p>When working with a state system, it is best to include all states in any function that works with the state system. All this does is keep your code clean, and if you ever need to grow the functionality of your states, you know that the basic state call is already handled anywhere it might possibly be used.</p></div><p>And that's that! Jumping will no longer be locked up when you're holding down the jump key. This completes the technical functionality of jumping!</p><p>Now your player can fall off the ledge after walking off of it. And with the power of the state system, you won't be able to jump or move left or right in mid-air. Of course, if you wanted to modify things so that the player can glide left and right, the state system makes that easy to accomplish. Make it a challenge to yourself to add gliding to the player's movements!</p><p>The most <a id="id102" class="indexterm"></a>astute of you, while paying attention to the console, probably noticed an error that keeps popping up: <span class="strong"><strong>SendMessagehitDeathTrigger has no receiver!</strong></span>. What's happening here is the <code class="literal">SendMessage</code> method in the death trigger is sending messages to all colliders that hit it—which happens to include the <code class="literal">SceneryToggler</code> object. To fix this, change how the death trigger is treated. Remove <code class="literal">DeathTriggerScript</code> from the <span class="strong"><strong>Death Trigger</strong></span> object. Then, go back into <code class="literal">PlayerColliderListener</code> and add the following case to the <code class="literal">switch</code> condition inside <code class="literal">OnTriggerEnter2D</code>:</p><div class="informalexample"><pre class="programlisting">case "DeathTrigger":
    // Player hit the death trigger - kill 'em!
    targetStateListener.onStateChange(PlayerStateController.playerStates.kill);
break;</pre></div><p>So what was the point of creating the death trigger in a different way before? The answer is that we could show you multiple ways to handle 2D collisions. You're welcome!</p></div>