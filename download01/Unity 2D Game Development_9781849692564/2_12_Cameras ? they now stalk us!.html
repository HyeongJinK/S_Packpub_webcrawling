<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Cameras – they now stalk us!</h2></div></div><hr /></div><p>It's one thing for the camera to see what we're doing, but it's another thing entirely for that camera to follow the player. Almost like a hungry stalker, that camera should always know what the player is doing and where they are doing it. It should also take a video of the player at all times to salivate over later, like a stalker. So, let's make that happen.</p><p>We're going to do this by creating a new script component for the camera which will be able to listen to the player's state changes. This is just one way of handling camera movements; however, for the scope of this book, it will be helpful for you if we see the power of using <a id="id62" class="indexterm"></a>
<span class="strong"><strong>events</strong></span> and <a id="id63" class="indexterm"></a>
<span class="strong"><strong>delegates</strong></span>, and learn a bit more about why exactly we love <a id="id64" class="indexterm"></a>
<span class="strong"><strong>state machines</strong></span>.</p><p>Oh sorry! What is a state machine? Wikipedia offers a pretty nice description. However, in quick terms, a state machine (in the context of programming) is a piece of code that performs separate actions based on the current state of an object. For example, a cat has three states—awake, sleeping, and trying to take over the world. The cat's state machine would perform different actions depending on which state the cat is currently in.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note106"></a>Note</h3><p>Chances are that most of you already know what <a id="id65" class="indexterm"></a>
<span class="strong"><strong>lerping</strong></span> is, but for anyone who doesn't—lerping is a way to smoothly transition between two values. The term lerp is actually short for linear interpolation, which is a mathematical method to fit a curve using linear polynomials. Congratulations! You are now 3 IQ points smarter.</p></div><p>Create a new script<a id="id66" class="indexterm"></a> called <code class="literal">CameraController</code> and <a id="id67" class="indexterm"></a>attach it to the object called <span class="strong"><strong>Main Camera</strong></span>, which already exists in your scene. This script is going to look a little similar to the <code class="literal">PlayerStateListener</code> script; however, it does not need to be as complex. Make the script look like the following:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class CameraController : MonoBehaviour
{
public PlayerStateController.playerStatescurrentPlayerState =PlayerStateController.playerStates.idle;
public GameObjectplayerObject = null;
public floatcameraTrackingSpeed = 0.2f;
private Vector3lastTargetPosition = Vector3.zero;
private Vector3currTargetPosition = Vector3.zero;
private floatcurrLerpDistance = 0.0f;
    
    void Start()
    {
//Set the initial camera positioning to prevent any weird jerking 
//around
        Vector3playerPos = playerObject.transform.position;
        Vector3cameraPos = transform.position;
        Vector3startTargPos = playerPos;
        
//Set the Z to the same as the camera so it does not move
        startTargPos.z = cameraPos.z;
        lastTargetPosition = startTargPos;
        currTargetPosition = startTargPos;
        currLerpDistance = 1.0f;
    }
    
    void OnEnable()
    {
        PlayerStateController.onStateChange += onPlayerStateChange;
    }
    
    void OnDisable()
    {
        PlayerStateController.onStateChange -= onPlayerStateChange;
    }
    
void onPlayerStateChange(PlayerStateController.playerStatesnewState)
    {
        currentPlayerState = newState;
    }
    
    void LateUpdate()
    {
// Update based on our current state
        onStateCycle();
        
// Continue moving to the current target position
        currLerpDistance += cameraTrackingSpeed;
        transform.position = Vector3.Lerp(lastTargetPosition, currTargetPosition, currLerpDistance);
    }
    
// Every cycle of the engine, process the current state
    void onStateCycle()
    {
/*We use the player state to determine the current action that the camera should take. Notice that in most cases we are tracking the player - however, in the case of killing or resurrecting, we don't want to track the player.*/

        switch(currentPlayerState)
        {
            case PlayerStateController.playerStates.idle:
                trackPlayer();
            break;
            
            case PlayerStateController.playerStates.left:
                trackPlayer();
            break;
            
            case PlayerStateController.playerStates.right:
                trackPlayer();
            break;
        }
    }
    
    void trackPlayer()
    {
// Get and store the current camera position, and the current 
// player position, in world coordinates
        Vector3currCamPos = transform.position;
        Vector3currPlayerPos = playerObject.transform.position;
        
        if(currCamPos.x == currPlayerPos.x&amp;&amp;currCamPos.y == currPlayerPos.y)
        {
// Positions are the same - tell the camera not to move, then abort.
            currLerpDistance = 1f;
            lastTargetPosition = currCamPos;
            currTargetPosition = currCamPos;
            return;
        }
        
// Reset the travel distance for the lerp
        currLerpDistance = 0f;
        
// Store the current target position so we can lerp from it
  lastTargetPosition = currCamPos;
  
  // Store the new target position
  currTargetPosition = currPlayerPos;
  
  // Change the Z position of the target to the same as the current.
  //We don' want that to change.
  currTargetPosition.z = currCamPos.z;
 }
 
 void stopTrackingPlayer()
 {
  // Set the target positioning to the camera's current position
  // to stop its movement in its tracks
  Vector3 currCamPos = transform.position;
  currTargetPosition = currCamPos;
  lastTargetPosition = currCamPos;
  
  // Also set the lerp progress distance to 1.0f, which will tell the lerping that it is finished.
  // Since we set the target positionins to the camera's current position, the camera will just
  // lerp to its current spot and stop there.
  currLerpDistance = 1.0f;
 }
}</pre></div><p>In the <a id="id68" class="indexterm"></a>
<span class="strong"><strong>Camera Controller (Script)</strong></span> checkbox region in the <span class="strong"><strong>Main Camera</strong></span> component<a id="id69" class="indexterm"></a> within the <span class="strong"><strong>Inspector</strong></span> panel, you'll find the <span class="strong"><strong>Player Object</strong></span> field. If you haven't yet, make sure to drag the <span class="strong"><strong>Player</strong></span> object into the <span class="strong"><strong>Player Object</strong></span> field. This is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692564/graphics/2564OT_02_04.jpg" /></div><p>Now, save your scene by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>S</em></span> or going to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Save Scene</strong></span>, and then play your game. As you move the player left and right, the camera will now move with the player, stalking the player and observing the player—creepy! As you may have already noticed, there is quite a lot of power we can now implement to the camera thanks to the use of both a state machine and events/delegates. With the previous code, not only can we track the player, but we could also implement states that allow the camera to track other objects as needed. The camera will always smoothly transition between the two objects without jumping around.</p><p>Currently, when the player reaches the ledge, they just keep going. Like a Vegas magician earning his bread, the player walks across that huge empty gap like it's nothing. It's high time we brought that player tumbling to the inky darkness below.</p></div>