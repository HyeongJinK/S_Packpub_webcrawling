<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec23"></a>Wait, did I collide with something?</h2></div></div><hr /></div><p>Next, we need to set up some code so that this collider can tell the <code class="literal">Player</code> object that a specific kind of collision happened. Create a new C# script called <code class="literal">PlayerColliderListener</code>, attach it to the <code class="literal">SceneryToggler</code> object, and make it look like the following code snippet:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class PlayerColliderListener : MonoBehaviour
{
    public PlayerStateListener targetStateListener = null;
void OnTriggerEnter2D( Collider2D collidedObject )
    {
switch(collidedObject.tag)
        {
case "Platform":
// When the player lands on a platform, toggle the Landing state.
    targetStateListener.onStateChange(PlayerStateController.playerStates.landing);
        break;
         }
    }
}</pre></div><p>Assign the <code class="literal">Player</code> <a id="id96" class="indexterm"></a>object to the <span class="strong"><strong>SceneryToggler</strong></span> object's <span class="strong"><strong>Target State Listener</strong></span> slot. With this, there is one issue: the state system could get into a flow where a state transition occurs, which takes the current state away from the jump even though the player is still jumping. We need to make sure the jump state is still active while the player is jumping, at least for this game. Therefore, we need to know if the player has landed or not. For that, we'll just use a simple Boolean. This will serve as our check as to whether we have or have not landed. It defaults to true because we can only jump if we have already landed.</p><p>Go back to the <code class="literal">jump</code> case in the method <code class="literal">onStateChange</code> within <code class="literal">PlayerStateListener</code> and wrap it in an <code class="literal">if</code> check with <code class="literal">if(playerHasLanded)</code>. Finally, add a case for landing in <code class="literal">onStateCycle</code>, <code class="literal">onStateChange</code>, <code class="literal">checkForValidStatePair</code>, and <code class="literal">checkIfAbortOnStateCondition</code>. Make each of those methods look like the following code snippet:</p><div class="informalexample"><pre class="programlisting">OnStateCycle:
case PlayerStateController.playerStates.landing:
break;

OnStateChange:
case PlayerStateController.playerStates.landing:
playerHasLanded = true;
break;

checkForValidStatePair:
case PlayerStateController.playerStates.landing:
// The only state that can take over from landing is idle, left or // right movement.
if(    newState == PlayerStateController.playerStates.left
    || newState == PlayerStateController.playerStates.right
    || newState == PlayerStateController.playerStates.idle
  )
returnVal = true;
else
returnVal = false;
break;  </pre></div><p>Now, the player can <a id="id97" class="indexterm"></a>only jump if they have already landed, and the state system can safely transition to and from the jump state.</p><p>There is one more thing to do here. With the preceding code, we can now support the falling state of the player as well. In the <code class="literal">PlayerColliderListener</code> script, add the following function:</p><div class="informalexample"><pre class="programlisting">void OnTriggerExit2D( Collider2D collidedObject)
{
    switch(collidedObject.tag)
    {
        case"Platform":
// When the player leaves a platform, set the state as falling. If //the player actually is not falling, this will get verified by //the PlayerStateListener.
    targetStateListener.onStateChange(PlayerStateController.playerStates.falling);
            break;
}          
}</pre></div><p>Just like <code class="literal">OnTriggerEnter</code>, this will be called whenever the <code class="literal">SceneryToggler</code> object leaves another object. We then check the tag, and if this was a platform, we toggle the falling state of the player. Let's also add the falling state real quick:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In <code class="literal">PlayerStateListener</code>, add the following <code class="literal">switch</code> case in <code class="literal">onStateCycle</code>:</p><div class="informalexample"><pre class="programlisting">case PlayerStateController.playerStates.falling:
break;</pre></div></li><li style="list-style-type: disc"><p>In <code class="literal">PlayerStateListener</code>, add the following <code class="literal">switch</code> case in <code class="literal">onStateChange</code>:</p><div class="informalexample"><pre class="programlisting">case PlayerStateController.playerStates.falling:
break;</pre></div></li><li style="list-style-type: disc"><p>In <code class="literal">PlayerStateListener</code>, inside the <code class="literal">landing</code> case in <code class="literal">checkForValidStatePair,</code> add the following:</p><div class="informalexample"><pre class="programlisting">case playerStateController.playerStates.landing:
// The only state that can take over from landing is idle, //left or right movement.
if(newState == PlayerStateController.playerStates.left
|| newState == PlayerStateController.playerStates.right
|| newState == PlayerStateController.playerStates.idle
  )
    returnVal = true;
else
    returnVal = false;
break;</pre></div></li></ul></div></div>