<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec26"></a>Let's get dangerous</h2></div></div><hr /></div><p>Let's add one more additional feature to our jumping, walking, dying player—the ability to fire a weapon. Yup! It's time to make the player dangerous. If you feel<a id="id105" class="indexterm"></a> the need to apply a lead apron and a hard hat to your person, now would be the time to do it:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Dig up your downloaded assets (available at <a class="ulink" href="http://www.PacktPub.com/support" target="_blank">http://www.PacktPub.com/support</a>—; register to have the files e-mailed directly to you) again and import the image map titled <code class="literal">PlayerBullet.png</code>, which should look like the following screenshot. Use the same image import settings you've been using for all the sprites:</p><div class="mediaobject"><img src="/graphics/9781849692564/graphics/2564OT_02_03.jpg" /></div></li><li><p>Drag-and-drop the <code class="literal">PlayerBullet</code> sprite just like you did with previous sprites into the <span class="strong"><strong>Hierarchy</strong></span> tab.</p></li><li><p>Give it a <span class="strong"><strong>Box Collider 2D</strong></span> component and check the <span class="strong"><strong>Is Trigger</strong></span> property checkbox.</p></li><li><p>Also, attach a <span class="strong"><strong>RigidBody 2D</strong></span> component and set its <span class="strong"><strong>Gravity Scale</strong></span> to <code class="literal">0</code>. Create a new tag called <code class="literal">Player Bullet</code> and set that as the tag for the <span class="strong"><strong>PlayerBullet</strong></span> object.</p></li></ol></div><p>Phew! OK, that <a id="id106" class="indexterm"></a>was quick, but we now have a working bullet object with the base properties. One last thing to do; create a new script called <code class="literal">PlayerBulletController</code>, apply it to the <span class="strong"><strong>PlayerBullet</strong></span> object, and make the script look like the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class PlayerBulletController : MonoBehaviour
{
public GameObject playerObject = null; // Will be populated //automatically when the bullet is created in PlayerStateListener
public float bulletSpeed = 15.0f;

public void launchBullet()
     {
// The local scale of the player object tells us which //direction the player is looking. Rather than programming in extra //variables to store where the player is looking, just check what //already knows that information... the object scale!
float mainXScale = playerObject.transform.localScale.x;
Vector2 bulletForce;
if(mainXScale&lt; 0.0f)
{
// Fire bullet left
bulletForce = new Vector2(bulletSpeed * -1.0f,0.0f);
}
else
   {
// Fire bullet right
bulletForce = new Vector2(bulletSpeed,0.0f);
}
        
        rigidbody2D.velocity = bulletForce;
     }
}</pre></div><p>Notice that we save on extra code and variables by simply checking the horizontal scale of the <code class="literal">Player</code> object to determine which direction they are facing. Handy!</p><p>Now save this as a Prefab called <code class="literal">Player Bullet</code> and delete the current instance of it from the game world. We won't need that one.</p><p>Next, we want to add a new state to the player called <code class="literal">firingWeapon</code>. Open up <span class="strong"><strong>PlayerStateController</strong></span> and add the new state to the <code class="literal">playerStates</code> enum. Simply add it to the end of the enum, as follows:</p><div class="informalexample"><pre class="programlisting">    kill,
    resurrect,
    firingWeapon, // Our new state!
    _stateCount</pre></div><p>There is one <a id="id107" class="indexterm"></a>minor complexity in adding this state: we want the <code class="literal">firingWeapon</code> state to immediately switch back to the previous state. To do this, let's add the ability to store what the previous state was.</p><p>At the beginning of <code class="literal">PlayerStateListener</code>, add the following line of code:</p><div class="informalexample"><pre class="programlisting">private PlayerStateController.playerStates previousState = PlayerStateController.playerStates.idle;</pre></div><p>Next, add support for the code to store the previous state whenever it is changed. At the bottom part of <code class="literal">onStateChange</code> in <code class="literal">PlayerStateListener</code>, modify the code so that it looks like the following:</p><div class="informalexample"><pre class="programlisting">//Store the current state as the previous state
previousState = currentState;</pre></div><p>Finally, assign the new state to the player object:</p><div class="informalexample"><pre class="programlisting">currentState = newState;</pre></div><p>The previous state is now properly stored when we change states—fantastic! Now we are ready to set up the code for the <code class="literal">firingWeapon</code> state. At the beginning of <code class="literal">PlayerStateListener</code>, add the following additional code:</p><div class="informalexample"><pre class="programlisting">public GameObject bulletPrefab = null;</pre></div><p>Be sure to also add the <span class="strong"><strong>Player Bullet</strong></span> Prefab to the Bullet Prefab slot in the <code class="literal">Player</code> object to fill this new property!</p><p>Next, add the proper switch / case check for the <code class="literal">firingWeapon</code> state to <code class="literal">onStateCycle</code>, <code class="literal">onStateChange</code>, <code class="literal">checkForValidStatePair</code>, and <code class="literal">checkIfAbortOnStateCondition</code>. Also, add the new state to <code class="literal">onStateCycle</code> in the script <code class="literal">CameraController</code>. We won't be using this, but it is always best to make sure all of your states in all scripts are the same, just in case you find you want to use it in the future. It's OK to leave all of the cases blank for now.</p><p>Let's add a <a id="id108" class="indexterm"></a>quick transform node that we can use as the spawn point for the bullets. Create a GameObject, name it <code class="literal">BulletSpawnPoint</code>, and make it a child of the <code class="literal">Player</code> object. Assign its position <code class="literal">X: 0.21</code>, <code class="literal">Y: 1.08</code>. It should look a little something like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692564/graphics/2564OT_02_06.jpg" /></div><p>At the beginning of <code class="literal">PlayerStateListener</code>, add the following code:</p><div class="informalexample"><pre class="programlisting">public Transform bulletSpawnTransform;</pre></div><p>Then, apply the <code class="literal">BulletSpawnPoint</code> GameObject to that new property in the <span class="strong"><strong>Inspector</strong></span> panel.</p><p>In the <code class="literal">onStateChange</code> method's case, check in <code class="literal">PlayerStateListener</code> and add the following code to the new <code class="literal">firingWeapon</code> state:</p><div class="informalexample"><pre class="programlisting">// Make the bullet object
GameObject newBullet = (GameObject)Instantiate(bulletPrefab);

// Set up the bullet's starting position
newBullet.transform.position = bulletSpawnTransform.position;
                
// Acquire the PlayerBulletController component on the new object // so we can specify some data
PlayerBulletController bullCon = newBullet.GetComponent&lt;PlayerBulletController&gt;();
                
// Set the player object
bullCon.playerObject = gameObject;
                
// Launch the bullet!
bullCon.launchBullet();
                
// With the bullet made, set the state of the player back to the // current state
onStateChange(currentState);</pre></div><p>With the<a id="id109" class="indexterm"></a> preceding code, we now create the bullet, set its needed properties, and then reset the player back to the previous state, all in one shot. We also need to make sure that the <code class="literal">checkForValidStatePair</code> method allows this to pass. So, go ahead and add the following code inside this method in <code class="literal">PlayerStateListener</code>:</p><div class="informalexample"><pre class="programlisting">PlayerStateController.playerStates.firingWeapon:
returnVal = true;
break;</pre></div><p>We also need to change a few states to allow <code class="literal">firingWeapon</code> to occur while they are active. So, be sure to add the following code to the state comparisons in <code class="literal">checkForValidStatePair</code> for the states of <code class="literal">jump</code>, <code class="literal">landing</code>, and <code class="literal">falling</code>:</p><div class="informalexample"><pre class="programlisting">|| newState == PlayerStateController.playerStates.firingWeapon</pre></div><p>Finally, all we need to do now is set up the code to actually trigger all this to happen whenever the button is clicked. Open up <span class="strong"><strong>PlayerStateController,</strong></span> and in the bottom part of <code class="literal">LateUpdate</code>, add the following code:</p><div class="informalexample"><pre class="programlisting">float firing = Input.GetAxis("Fire1");
if(firing &gt; 0.0f)
{
if(onStateChange != null)onStateChange(PlayerStateController.playerStates.firingWeapon);
}</pre></div><p>With that, the <a id="id110" class="indexterm"></a>player can now fire its weapon! Play the game and press the <code class="literal">Fire1</code> button (by default, it's the <span class="emphasis"><em>Ctrl</em></span> key) and then watch a consistent stream of bullets fire out from the player! However, the player currently fires a burst of bullets on every firing. So, let's add in a quick firing delay. To do this, we will simply make use of our state abort check.</p><p>In <code class="literal">PlayerStateListener</code>, add the following line of code in the <code class="literal">Start</code> method:</p><div class="informalexample"><pre class="programlisting">PlayerStateController.stateDelayTimer[ (int)PlayerStateController.playerStates.firingWeapon] = 1.0f;</pre></div><p>Next, go into <code class="literal">checkIfAbortOnStateCondition</code> at the bottom part of <code class="literal">PlayerStateListener</code> and add the following code in the <code class="literal">firingWeapon</code> check:</p><div class="informalexample"><pre class="programlisting">if(PlayerStateController.stateDelayTimer[ (int)PlayerStateController.playerStates.firingWeapon] &gt;Time.time)
returnVal = true; </pre></div><p>Finally, go into the <code class="literal">onStateChange</code> method in the same script file and add the following line of code to the <code class="literal">firingWeapon</code> state in the <code class="literal">newState</code> switch condition:</p><div class="informalexample"><pre class="programlisting">PlayerStateController.stateDelayTimer[(int)PlayerStateController.playerStates.firingWeapon] = Time.time + 0.25f;</pre></div><p>This will cause a delay of 0.25 seconds (about a quarter of a second) between each shot. Now, bullets have a firing delay to prevent them from streaming out as fast while the player holds down the button. Also, this prevents bursts from occurring when the player just taps the firing key.</p><p>At this point, you may want to tweak the physics property of the bullet so it flies faster or differently. Try playing with the <span class="strong"><strong>Mass</strong></span> field of the bullet's <span class="strong"><strong>Rigidbody 2D</strong></span> component.</p></div>