<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec41"></a>Crown the king</h2></div></div><hr /></div><p>To develop the <a id="id147" class="indexterm"></a>boss battle, we are going to use everything you have learned throughout this book to assemble a single combat event in a 2D world. If you have not cracked your knuckles yet, now would be the time to do that. Always crack your knuckles before doing something awesome—it lets people know to stand back and observe the awesome event as it goes down. This is a great time to be excited. You are near the end of your production. This is the pinnacle of the game, where you have led your player to a final experience.</p><p>Place your animated boss in the scene and name it <code class="literal">Boss</code>. Also, add the <code class="literal">TakeDamageFromPlayerBullet</code> script component to the <code class="literal">Boss</code> object, and make sure the <span class="strong"><strong>Boss</strong></span> object has a <span class="strong"><strong>Polygon Collider 2D</strong></span> component.</p><p>With the collision dealt with, let's set up an event to start the boss battle. We are going to create a counter whose count increases when you kill enemies. After 10 enemies are defeated, the boss will spawn. Create a new script called <code class="literal">BossEventController</code>. Add the new component to the <span class="strong"><strong>Boss</strong></span> object and code it up as shown in the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System.Collections.Generic; // This is needed to support//list objects


public class BossEventController : MonoBehaviour
{
  public delegate void bossEventHandler(int scoreMod);
  public static event bossEventHandler bossDied;
  
  public GameObject inActiveNode = null;
  public GameObject dropToStartNode = null;
  public GameObject dropFXSpawnPoint = null;
  public List&lt;GameObject&gt; dropNodeList =new List&lt;GameObject&gt;();
  public GameObject bossDeathFX = null;
  public GameObject bossDropFX = null;
  public TakeDamageFromPlayerBulletbulletColliderListener = null;
  
  public float MovespeedmoveSpeed = 0.1f;
  public float eventWaitDelay = 3f;
  // Amount of time to wait between each event
  
  public int enemiesToStartBattle = 10;
  
  public enum bossEvents
  {
    inactive = 0,
    fallingToNode,
    waitingToJump,
    waitingToFall,
    jumpingOffPlatform
  }
  
  // Current event to cycle on each Update() pass
  public bossEvents currentEvent = bossEvents.inactive;</pre></div><p>The boss<a id="id148" class="indexterm"></a> is a bit more complex than your average run-of-the-mill red dome on treads. As a result, he will need a number of additional variables to track what's going on. The biggest ones you'll want to pay attention to here are the<a id="id149" class="indexterm"></a> <span class="strong"><strong>event timers</strong></span>, which—as you may expect—control events in the battle sequence based on engine time. The following variables are used to control the timed boss events:</p><div class="informalexample"><pre class="programlisting">  // The node object that the boss will befalling towards.
  private GameObject targetNode = null;
  
  // Amount of time to wait until jumping orfalling again.
  private float timeForNextEvent = 0.0f;
  
  // Target position used for when jumping off a platform.
  private Vector3 targetPosition = Vector3.zero;
  
  // Current health of the boss
  public int health = 20;
  
  // Health to start the boss at whenever the battlebegins
  private int startHealth = 20;
  
  // Used to determine if the boss has been defeated
  private bool isDead = false;
  
  // How many enemies left to kill before the boss isspawned
  private int enemiesLeftToKill = 0;</pre></div><p>Note that in the <a id="id150" class="indexterm"></a>following <code class="literal">OnEnable</code> and <code class="literal">OnDisable</code> functions, we're using all existing events. This reuse is part of their power—events can be continuously reused to check the same actions!</p><div class="informalexample"><pre class="programlisting">  void OnEnable()
  {
    bulletColliderListener.hitByBullet +=hitByPlayerBullet;
    EnemyControllerScript.enemyDied += enemyDied;
  }

  void OnDisable()
  {
    bulletColliderListener.hitByBullet -=hitByPlayerBullet;
    EnemyControllerScript.enemyDied -= enemyDied;
  }

  void Start()
  {
    transform.position = inActiveNode.transform.position;
    enemiesLeftToKill = enemiesToStartBattle;
  }

  void Update()
  {
    switch(currentEvent)
    {
      case bossEvents.inactive:
      // Not doing anything, so nothing to do.
      break;</pre></div><p>You may be asking yourself, as your eyeballs roll over the following case statement, "<span class="emphasis"><em>Yo, mister writer! Why don't we just use one of the Rigidbody 2D things and let the physics engine drop 'em? Eh?</em></span>". The question itself though is fabulous! And I have a fabulous answer for you—physics have chaos.</p><p>So, you <a id="id151" class="indexterm"></a>may think the boss is going to land in a specific position, but certain things may cause it to not happen. Maybe another object collides with it and pushes it off course. Maybe the physics causes it to not stop at the exact position you want. Essentially, this is the safest method—use movement functions to put the boss where you want it to be. If you were working on a big action-oriented game and wanted an enemy to jump a long distance—such as the Handymen in BioShock Infinite—chances are you would shut off the physics for the enemy, move it along an arc, and when it landed, turn the physics back on. Doing all this means there will never be any misses, which is exactly what the following code does:</p><div class="informalexample"><pre class="programlisting">      case bossEvents.fallingToNode:
      if(transform.position.y &gt; targetNode.transform.position.y)
      {
         // Movespeed here is negative,
         //so the object moves downwards
        transform.Translate(new Vector3(0f,-moveSpeed * Time.deltaTime, 0f));
        if(transform.position.y &lt; targetNode.transform.position.y)
        {
          Vector3 targetPos =targetNode.transform.position;
          transform.position = targetPos;
        }
      }
      else
      {
        // Create the 'Hit Ground' smoke FX
        createDropFX();

        timeForNextEvent = 0.0f;
        currentEvent = bossEvents.waitingToJump;
      }
      break;
      case bossEvents.waitingToFall:
      // Boss is waiting to fall to another node
      if(timeForNextEvent == 0.0f)
      {
        timeForNextEvent = Time.time + eventWaitDelay;
      }

      else if(timeForNextEvent &lt; Time.time)
      {
        // Need to find a new node!
        targetNode = dropNodeList[ Random.Range(0,dropNodeList.Count) ];

        // Set the boss position to the sky position of// this node
        transform.position =getSkyPositionOfNode(targetNode);

        // Set the event state
        currentEvent = bossEvents.fallingToNode;
        timeForNextEvent = 0.0f;
      }
      break;

      case bossEvents.waitingToJump:
      // Boss is on a platform and is just waiting to//jump off of it
      if(timeForNextEvent == 0.0f)
      {
        timeForNextEvent = Time.time + eventWaitDelay;
      }
      else if(timeForNextEvent &lt; Time)
      {
        // Build the target position based on the// current node
        targetPosition =getSkyPositionOfNode(targetNode);

        // Set our event state	
        currentEvent = bossEvents.jumpingOffPlatform;
	        timeForNextEvent = 0.0f;

        // Also set the target node to null so we know// to find a random one when it's time to fall// to one again
        targetNode = null;
      }
      break;

      case bossEvents.jumpingOffPlatform:
      if(transform.position.y &lt; targetPosition.y)
      {
        // MovespeedMoveSpeed is positive here, causing// the object to move upwards
        transform.Translate(new Vector3(0f,MovespeedmoveSpeed * Time.deltaTime, 0f));

        if(transform.position.y &gt; targetPosition.y)
          transform.position = targetPosition;
      }
      else
      {
        timeForNextEvent = 0.0f;
        currentEvent = bossEvents.waitingToFall;
      }
      break;
    }
  }

  public void beginBossBattle()
  {
    // Set the first falling node and have the boss// fall towards it
    targetNode = dropToStartNode;
    currentEvent = bossEvents.fallingToNode;

    // Reset various control variables used to track// the boss battle
    timeForNextEvent = 0.0f;
    health = startHealth;
    isDead = false;
  }

  Vector3 getSkyPositionOfNode(GameObject node)
  {
    Vector3 targetPosition =targetNode.transform.position;
    targetPosition.y += 9f;    

    return targetPosition;
  }

  void hitByPlayerBullet()
  {
    health -= 1;

    // If the boss is out of health – kill 'em!
    if(health &lt;= 0)
      killBoss();
  }

  void createDropFX()
  {
    GameObject dropFxParticle =(GameObject)Instantiate(bossDropFX);
    dropFxParticle.transform.position =dropFXSpawnPoint.transform.position;
  }</pre></div><p>Killing any <a id="id152" class="indexterm"></a>enemy, boss or regular, is a little delicate. In the case of our standard tank enemies, we just spawn a particle system and destroy the <code class="literal">Enemy</code> object. In the case of the boss, however, we want to reuse the <span class="strong"><strong>Boss</strong></span> object. Why? So you can learn how to reuse an enemy! You're very welcome.</p><p>So, what we're going to do here is check whether the enemy is dead, and if not, generate an emitter, move the boss, and end the battle, using the following code in the <code class="literal">BossEventController</code> script:</p><div class="informalexample"><pre class="programlisting">  void killBoss()
  {
    if(isDead)
      return;

    isDead = true;


    GameObject deathFxParticle =(GameObject)Instantiate(bossDeathFX);

    // Reposition the particle emitter at the same// position as dropFXSpawnPoint
    deathFxParticle.transform.position =dropFXSpawnPoint.transform.position;

    // Call the bossDied event and give it a score of// 1000.
    if(bossDied != null)
      bossDied(1000);

    transform.position = inActiveNode.transform.position;

    currentEvent = BossEventController.bossEventsinactive;
    timeForNextEvent = 0.0f;
    enemiesLeftToKill = enemiesToStartBattle;
  }

  void enemyDied(int enemyScore)
  {
    if(currentEvent == bossEvents.inactive)
    {
      enemiesLeftToKill -= 1;
      Debug.Log("--- Enemies left to start boss battle:" + enemiesLeftToKill);
      if(enemiesLeftToKill &lt;= 0)
        beginBossBattle();
    }
  }
}</pre></div><p>Now that<a id="id153" class="indexterm"></a> indeed was a bit of code—lots of good stuff in there though, and lots that you should now recognize! Let's go through and review some of the important elements.</p><p>Note that at the very beginning, we create a new event for <code class="literal">bossDied</code>. This is exactly the same as our normal <code class="literal">enemyDied</code> event, which is used to track the change in scores.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip19"></a>Tip</h3><p>This would be a perfect opportunity for you to expand on the boss battle by making use of the existing events that the enemies have. Evoke them to react when the boss dies! Make them angry! Make it so that a swarm of enemies spawn out of anger! Have fun with it because those tanks are mad!</p></div><p>Let's<a id="id154" class="indexterm"></a> inform the <code class="literal">ScoreWatcher</code> script to pay attention to the <code class="literal">bossDied</code> event. Open up <code class="literal">ScoreWatcher</code> and add an event listener to <code class="literal">OnEnable</code>:</p><div class="informalexample"><pre class="programlisting">BossEventController.bossDied += addScore;</pre></div><p>And, of course, be sure to unregister the event in <code class="literal">OnDisable</code>:</p><div class="informalexample"><pre class="programlisting">BossEventController.bossDied -= addScore;</pre></div><p>Now, you can earn points whenever the boss gets killed.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip20"></a>Tip</h3><p>Add an extra event to allow the player to earn points whenever the boss takes damage.</p></div><p>Next, you will notice that we use a bunch of nodes. These nodes are simple—the term node is used here to refer to anything that is locational. A node is nothing more than a GameObject that contains nothing more than a <span class="strong"><strong>Transform</strong></span> section, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849692564/graphics/2564_05_03.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip21"></a>Tip</h3><p>You may have noticed that anywhere we define these nodes in the code, we always define a full GameObject, and from there, we access it with <code class="literal">nodeGameObject.transform.position</code>. Well, that's not entirely needed! You may already know this, but Unity allows you to set a property in the <span class="strong"><strong>Inspector</strong></span> panel with a component on another object! This means you could actually define the nodes as <code class="literal">Transform thisNode;</code> instead of <code class="literal">GameObject thisNode;</code>. If you challenge yourself to modify the code like this, then you can access a node's position by simply using <code class="literal">thisNode.position</code>. Handy!</p></div><p>For the boss, we have defined some initial nodes to be used during its initial drop at the start of the battle, which allows us to control where he goes. This doesn't do much aside from moving the boss to its initial starting point, but it could be expanded to make the boss fly around, jump about, or do whatever you desire.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Tip</h3><p>Need another challenge? We just mentioned giving the boss an introduction sequence. Have a go at it!</p></div><p>Next, we have something new—a <code class="literal">List</code> object called <code class="literal">dropNodeList</code>. A list is essentially a container, like an array. Unlike an array though, you can use functions in a list to quickly search and see if it contains objects, add objects, pops them out, and—the best part—it's way faster than an array while working with numerous objects.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Tip</h3><p>Need to know more about C# object types? Check out the Microsoft Developer Network located online at <a class="ulink" href="http://msdn.microsoft.com/" target="_blank">http://msdn.microsoft.com/</a>. From there, you can get all sorts of resources, including information about object types! Just type something, for example, <code class="literal">List</code>, in the search box, and you'll be educated in no time.</p></div><p>The <code class="literal">dropNodeList</code> object <a id="id155" class="indexterm"></a>allows us to define a bunch of target nodes for the boss to drop to, without needing to know how many nodes there will be. Note that to use the <code class="literal">List</code> object type, we have to add the following code at the beginning of the script file, which you should have already done:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Generic;</pre></div><p>You will now want to add these nodes to the game world. Nodes can simply be a GameObject with nothing more than a <span class="strong"><strong>Transform</strong></span>, or if you want to be able to see them, create a sprite image just for the purpose of displaying them. Create a node for <code class="literal">dropToStartNode</code> and another for <code class="literal">inActiveNode</code>. Place the <code class="literal">dropToStartNode</code> object on the platform you want the boss to first drop towards, and place the <code class="literal">inActiveNode</code> object directly above it, only high above so that it can't be seen in normal gameplay. To make node alignment extra clear, use the boss sprite itself—then there's no question as to where the boss will land! Just be sure to add a quick component that will hide the sprite when the game begins!</p><p>The following screenshot shows how we laid out our nodes:</p><div class="mediaobject"><img src="/graphics/9781849692564/graphics/2564_05_04.jpg" /></div><p>Assign those nodes to the appropriate slots in the <span class="strong"><strong>Inspector</strong></span> panel for the <span class="strong"><strong>Boss</strong></span> object. Create additional nodes for landing points where you want the boss to fall during his attacks, position them around the world, and add each of them to the <span class="strong"><strong>Boss</strong></span> object's <code class="literal">DropNodeList</code>.</p></div>