<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec55"></a>Data persistence in our application</h2></div></div><hr /></div><p>In the previous chapter, we implemented most of the logic of our application. However, every time the user closes the application, all their tasks disappear. This is because our application is not persisting data.</p><p>To make data persistent, we need in some way to store it. The first intuitive way is to store the data locally, which means saving to a file.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec104"></a>PlayerPrefs in Unity</h3></div></div></div><p>Unity offers a quick and easy way to store data persistently by using <code class="literal">PlayerPrefs</code>, a special class where there are functions to save primitives, such as integers or strings. In the following examples, we will work with strings, but the process is the same for all the other primitives.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec44"></a>The Set function</h4></div></div></div><p>It is possible to save the data by using the following line:</p><pre class="programlisting">PlayerPrefs.SetString("Your Key", "Your Value"); &#13;
</pre><p>Basically, it takes a key and a value. The key is important, because we need it when we need to get the value back, maybe in another session (the user used the application, closed it, and re-opened it).</p><p>Therefore, in our case, we need to save every task when the user performs any operation, such as creating a new one or deleting some. The implementation of this is left as an exercise.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip35"></a>Tip</h3><p>Tasks, like classes, are not primitives. Therefore, you need to create a function that uses <code class="literal">PlayerPrefs</code> several times to store just one task by using iterative keys. In addition, you can use this function to save all the tasks from <code class="literal">TaskManager</code>.</p><p>Remember to also store the number of tasks, so your function knows how many tasks with iterative keys it needs to retrieve.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec45"></a>The Get function</h4></div></div></div><p>The sister of the previous function is the <code class="literal">Get</code> function. You can retrieve the value of <code class="literal">PlayerPrefs</code> by using his key as a parameter of the following function:</p><pre class="programlisting">PlayerPrefs.GetString("Your Key"); &#13;
</pre><p>As a result, you get the value, so be sure to store it in a variable. In addition, if the value doesn't exist (there is no value associated with that specific key), you can set a default values with the following line:</p><pre class="programlisting">PlayerPrefs.GetString("Your Key", "Default value"); &#13;
</pre><p>As before, we need to use the same key we have used when we called the <code class="literal">set</code> function.</p><p>In our case, once the user opens the application, all the tasks should be loaded. This can be done by using the get function. Again, the implementation is left as an exercise.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip36"></a>Tip</h3><p>Like before, you can create a function that uses different <code class="literal">PlayerPrefs</code> to get functions to retrieve a task, and create a new task with those features. Then, another function can use the previous to load all the tasks in <code class="literal">TaskManager</code>. Eventually, don't forget to update the graphics too.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec46"></a>Erasing an entry</h4></div></div></div><p>To erase an entry from <code class="literal">PlayerPrefs</code>, we need its key, and then we call the following function:</p><pre class="programlisting">PlayerPrefs.DeleteKey("Your Key"); &#13;
</pre><p>As a result, the value of that key is erased. This might be helpful if we want to clean the extra tasks we stored in the previous section, if the user has erased some of them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec47"></a>Erasing all the data</h4></div></div></div><p>If, for any reason, we want to delete all the data, we can just use the following line:</p><pre class="programlisting">PlayerPrefs.DeleteAll(); &#13;
</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip37"></a>Tip</h3><p>Be careful, since this operation is irreversible. Pay attention to where you place this line in your code.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec105"></a>Saving local data in a custom file</h3></div></div></div><p>If we are not a fan of <code class="literal">PlayerPrefs</code>, a more flexible way is to create a file on our own.</p><p>We can actually encrypt it and decrypt if we wish, and store it where we want. However, doing this includes dealing with streams. They are an advanced topic in programming, and we don't have time to go through them here. Therefore, I suggest you read any book about C# I/O (input/output) operations.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec106"></a>Using a database</h3></div></div></div><p>The last way to have persistent data is to store it in a database. This approach has its own advantages and disadvantages. The main pros are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Device-independent</p></li><li style="list-style-type: disc"><p>Flexible</p></li><li style="list-style-type: disc"><p>Data synchronization</p></li><li style="list-style-type: disc"><p>Multiple users</p></li><li style="list-style-type: disc"><p>Easier analysis of the data</p></li></ul></div><p>On the other hand, the cons are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Requires an Internet connection</p></li><li style="list-style-type: disc"><p>Might be slow and very difficult to implement</p></li></ul></div><p>However, in the next section, we will see a simple solution to connect a database to our application.</p></div></div>