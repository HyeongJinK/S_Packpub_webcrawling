<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec09"></a>Introduction</h2></div></div><hr /></div><p>A key element contributing to the entertainment and enjoyment of most games is the quality of the visual experience, and an important part of this<a id="id0" class="indexterm"></a> is the <span class="strong"><strong>User Interface</strong></span> (<span class="strong"><strong>UI</strong></span>). UI elements involve ways for the user to interact with the game (such as buttons, cursors, text boxes, and so on), as well as ways for the game to present up-to-date information to the user (such as the time remaining, current health, score, lives left, or location of enemies). This chapter is filled with UI recipes to give you a range of examples and ideas for creating game UIs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec12"></a>The big picture</h3></div></div></div><p>Every game is different, and so this chapter attempts to fulfill two key roles. The first aim is to provide step-by-step instructions on how to create a wide<a id="id1" class="indexterm"></a> range of the <span class="strong"><strong>Unity 5</strong></span> UI elements and, where appropriate, associate them with game variables in code. The second aim is to provide a rich illustration of how UI elements can be used for a variety of purposes, so that you can get good ideas about how to make the Unity 5 UI set of controls deliver the particular visual experience and interactions for the games that you are developing.</p><p>The basic <a id="id2" class="indexterm"></a>UI elements can provide static images and text to just make the screen look more interesting. By using scripts, we can change the content of these images and text objects, so that the players' numeric scores can be updated, or we can show stickmen images to indicate how many lives the player has left, and so on. Other UI elements are interactive, allowing users to click on buttons, choose options, enter text, and so on. More sophisticated kinds of UI can involve collecting and calculating data about the game (such as percentage time remaining or enemy hit damage; or the positions and types of key GameObjects in the scene, and their relationship to the location and orientation of the player), and then displaying these values in a natural, graphical way (such as progress bars or radar screens).</p><p>Core GameObjects, components, and concepts relating to Unity UI development include:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Canvas</strong></span>: Every UI element is a child<a id="id3" class="indexterm"></a> to a <span class="strong"><strong>Canvas</strong></span>. There can be multiple <span class="strong"><strong>Canvas</strong></span> GameObjects in a single scene. If a <span class="strong"><strong>Canvas</strong></span> is not already present, then one will automatically be created when a new UI GameObject is created, with that UI object childed to the new <span class="strong"><strong>Canvas</strong></span> GameObject.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>EventSystem</strong></span>: An <span class="strong"><strong>EventSystem</strong></span> GameObject is<a id="id4" class="indexterm"></a> required to manage the interaction events for UI<a id="id5" class="indexterm"></a> controls. One will automatically be created with the first UI element.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Panel</strong></span>: UI objects can be<a id="id6" class="indexterm"></a> grouped together (logically and physically) with UI <span class="strong"><strong>Panels</strong></span>. <span class="strong"><strong>Panels</strong></span> can play several roles, including providing a GameObject parent in the <span class="strong"><strong>Hierarchy</strong></span> for a related group of controls. They can provide a visual<a id="id7" class="indexterm"></a> background image to graphically relate controls on the screen, and they can also have scripted resize and drag interactions added, if desired.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Visual UI</strong></span> controls: The visible UI controls themselves include <span class="strong"><strong>Button</strong></span>, <span class="strong"><strong>Image</strong></span>, <span class="strong"><strong>Text</strong></span>, <span class="strong"><strong>Toggle</strong></span>, and so <a id="id8" class="indexterm"></a>on.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Interaction UI</strong></span> controls: These <a id="id9" class="indexterm"></a>are non-visible components that are added to GameObjects; examples include<a id="id10" class="indexterm"></a> Input Field and Toggle Group.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Rect Transform</strong></span> component: UI GameObjects can exist in a different space from<a id="id11" class="indexterm"></a> that of the 2D and 3D scenes, which cameras render. Therefore, UI GameObjects all have the special <span class="strong"><strong>Rect Transform</strong></span> component, which has some different properties to the scene's GameObject <span class="strong"><strong>Transform</strong></span> component (with its straightforward <span class="emphasis"><em>X</em></span>/<span class="emphasis"><em>Y</em></span>/<span class="emphasis"><em>Z</em></span> position, rotation, and scale properties). Associated with <span class="strong"><strong>Rect Transforms</strong></span> are pivot<a id="id12" class="indexterm"></a> points (reference points for scaling, resizing, and rotations) and anchor points. Read more about these core features below.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Sibling Depth</strong></span>: The bottom-to-top display order (what appears on the top of what) for a UI element is determined initially <a id="id13" class="indexterm"></a>by their sequence in the <span class="strong"><strong>Hierarchy</strong></span>. At designtime, this can be manually set by dragging GameObjects into the desired sequence in the <span class="strong"><strong>Hierarchy</strong></span>. At runtime, we can send messages to the <span class="strong"><strong>Rect Transforms</strong></span> of GameObjects to dynamically change their <span class="strong"><strong>Hierarchy</strong></span><a id="id14" class="indexterm"></a> position (and therefore, the display order), as the game or user interaction demands. This is illustrated in the <span class="emphasis"><em>Organizing images inside panels and changing panel depths via buttons</em></span> recipe in this chapter.</p></li></ul></div><p>The following diagram <a id="id15" class="indexterm"></a>shows how there are four main categories of UI controls, each in a <span class="strong"><strong>Canvas</strong></span> GameObject and interacting via an <span class="strong"><strong>EventSystem</strong></span> GameObject. UI Controls can have their own <span class="strong"><strong>Canvas</strong></span>, or several UI controls can be in the same <span class="strong"><strong>Canvas</strong></span>. The four categories are: static (display-only) and interactive UI controls, non-visible components (such as ones to group a set of mutually exclusive radio buttons), and C# script classes to manage UI control behavior through logic written in the program code. Note that UI controls that are not a child or descendent of a <span class="strong"><strong>Canvas</strong></span> will not work properly, and interactive UI controls will not work properly if the <span class="strong"><strong>EventSystem</strong></span> is missing. Both the <span class="strong"><strong>Canvas</strong></span> and <span class="strong"><strong>EventSystem</strong></span> GameObjects are automatically added to the Hierarchy as soon as the first UI GameObject is added to a scene.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_01_45.jpg" /></div><p>UI <span class="strong"><strong>Rect Transforms</strong></span> represents a rectangular area rather than a single point, which is the case for scene GameObject <span class="strong"><strong>Transforms</strong></span>. <span class="strong"><strong>Rect Transforms</strong></span> describe how a UI element should be positioned and sized relatively to its parent. <span class="strong"><strong>Rect Transforms</strong></span> have a width and height that can be changed without affecting the local scale of the component. When the scale is changed for the <span class="strong"><strong>Rect Transform</strong></span> of a UI element, then this will also scale font sizes and borders on sliced images, and so on. If all four anchors are at the same point, then resizing the <span class="strong"><strong>Canvas</strong></span> will not stretch the <span class="strong"><strong>Rect Transform.</strong></span> It will only affect its position. In this case, we'll see the <span class="strong"><strong>Pos X</strong></span> and <span class="strong"><strong>Pos Y</strong></span> properties, and the <span class="strong"><strong>Width</strong></span> and <span class="strong"><strong>Height</strong></span> of the rectangle. However, if the anchors are not all at the same point, then <span class="strong"><strong>Canvas</strong></span> resizing will result in a stretching of the element's rectangle. So instead of the <span class="strong"><strong>Width</strong></span>, we'll see<a id="id16" class="indexterm"></a> the values for <span class="strong"><strong>Left</strong></span> and <span class="strong"><strong>Right</strong></span>â€”the position of the horizontal sides of the rectangle to the sides of the <span class="strong"><strong>Canvas</strong></span>, where the <span class="strong"><strong>Width</strong></span> will depend on the actual <span class="strong"><strong>Canvas</strong></span> width (and the same for <span class="strong"><strong>Top/Bottom/Height</strong></span>).</p><p>Unity provides a set of preset values for pivots and anchors, making the most common values very quick and easy to assign to an element's <span class="strong"><strong>Rect Transform</strong></span>. The following screenshot shows the 3 x 3 grid that allows you quick choices about left, right, top, bottom, middle, horizontal, and vertical values. Also, the extra column on the right offers horizontal stretch presets, and the extra row at the bottom offers vertical stretch presets. Using the <span class="emphasis"><em>SHIFT</em></span> and <span class="emphasis"><em>ALT</em></span> keys sets the pivot and anchors when a preset is clicked.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_01_03.jpg" /></div><p>The Unity manual provides a very good introduction to the <span class="strong"><strong>Rect Transform.</strong></span> In addition, Ray Wenderlich's two-part <a id="id17" class="indexterm"></a>Unity UI web tutorial also presents a great overview of the <a id="id18" class="indexterm"></a><span class="strong"><strong>Rect Transform</strong></span>, pivots, and anchors. Both parts of Wenderlich's tutorial make great use of animated GIFs to illustrate the effect of different values for pivots and anchors:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://docs.unity3d.com/Manual/UIBasicLayout.html" target="_blank">http://docs.unity3d.com/Manual/UIBasicLayout.html</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://www.raywenderlich.com/78675/unity-new-gui-part-1" target="_blank">http://www.raywenderlich.com/78675/unity-new-gui-part-1</a>
</p></li></ul></div><p>There are three <span class="strong"><strong>Canvas</strong></span> render modes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Screen Space â€“ Overlay</strong></span>: In this<a id="id19" class="indexterm"></a> mode, the UI elements are displayed without any reference to any camera (there is no need for any <span class="strong"><strong>Camera</strong></span> in the scene). The UI elements are presented in front of (overlaying) any sort of camera display of the scene contents.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Screen Space â€“ Camera</strong></span>: In this<a id="id20" class="indexterm"></a> mode, the <span class="strong"><strong>Canvas</strong></span> is treated as a flat plane in the frustum (viewing space) of a <span class="strong"><strong>Camera</strong></span> scene â€”where this plane is always facing the camera. So, any scene objects in front of this plane will be rendered in front of the UI elements on the <span class="strong"><strong>Canvas</strong></span>. The <span class="strong"><strong>Canvas</strong></span> is automatically resized if the screen size, resolution, or<a id="id21" class="indexterm"></a> camera settings are changed.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>World Space</strong></span>: In this mode, the <span class="strong"><strong>Canvas</strong></span> acts as a flat plane in the frustum (viewing space) of a<a id="id22" class="indexterm"></a> <span class="strong"><strong>Camera</strong></span> sceneâ€”but the plane is not made to always face the <span class="strong"><strong>Camera</strong></span>. How the <span class="strong"><strong>Canvas</strong></span> appears is just as with any other objects in the scene, relative to where (if anywhere) in the camera's viewing frustum the <span class="strong"><strong>Canvas</strong></span> plane is located and oriented.</p></li></ul></div><p>In this chapter, we have<a id="id23" class="indexterm"></a> focused on the <span class="strong"><strong>Screen Space â€“ Overlay</strong></span> mode. But all these recipes can equally be used with the other two modes as well.</p><p>Be creative! This chapter aims to act as a launching pad of ideas, techniques, and reusable <span class="strong"><strong>C#</strong></span> scripts for your own projects. Get to know the range of Unity UI elements, and try to work smart. Often, a UI element exists with most of the components that you may need for something in your game, but you may need to adapt it somehow. An example of this can be seen in the recipe that makes a UI Slider non-interactive, instead using it to display a red-green progress bar for the status of a countdown timer. See this in the <span class="emphasis"><em>Displaying a countdown timer graphically with a UI Slider</em></span> recipe.</p></div></div>