<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec84"></a>NPC NavMeshAgent to seek or flee destination while avoiding obstacles</h2></div></div><hr /></div><p>The introduction of Unity's NavMeshAgent has greatly simplified the coding for NPC and enemy agent behaviors. In this recipe, we'll add some wall (scaled cubes) obstacles, and generate a NavMesh, so that Unity knows not to try to walk through the walls. We then add a NavMeshAgent <a id="id878" class="indexterm"></a>component to our NPC GameObject, and tell it to head to a stated destination location by intelligently planning and following a path, while avoiding the wall obstacles.</p><p>In the next screenshot, we<a id="id879" class="indexterm"></a> can see in the <span class="strong"><strong>Scene</strong></span> panel the squares that represent potential points on the path. We can also see lines showing the current temporary direction and destination around the current obstacle.</p><p>When the <span class="strong"><strong>Navigation</strong></span> panel is visible, then the <span class="strong"><strong>Scene</strong></span> panel displays the blue-shaded <span class="emphasis"><em>walkable</em></span> areas, and unshaded, non-walkable areas at the edge of the terrain and around each of the two <span class="emphasis"><em>wall</em></span> objects.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_08_05.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec242"></a>Getting ready</h3></div></div></div><p>This recipe builds upon the player-controlled 3D cube Unity project that you created at the beginning of this chapter. So, make a copy of this project, open it, and then follow the steps for this recipe.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec243"></a>How to do it...</h3></div></div></div><p>To make an <a id="id880" class="indexterm"></a>object seek or flee from a position, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Delete the <span class="strong"><strong>Cube-player</strong></span> GameObject, since we are going to be creating an NPC computer controlled agent.</p></li><li><p>Create a sphere named <span class="strong"><strong>Sphere-arrow</strong></span> that is positioned at (2, 0.5, 2). Scale it as (1,1,1).</p></li><li><p>Create a second sphere named <span class="strong"><strong>Sphere-small</strong></span>. Scale it as (0.5, 0.5, 0.5).</p></li><li><p>Child <span class="strong"><strong>Sphere-small</strong></span> to <span class="strong"><strong>Sphere-arrow</strong></span> and position it at (0, 0, 0.5).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p>
<span class="strong"><strong>Childing</strong></span> refers to making <a id="id881" class="indexterm"></a>one GameObject, in the <span class="strong"><strong>Hierarchy</strong></span> panel, a child of another GameObject. This is done by dragging the object that is to be childed over the object to be the parent. Once completed, the parent-child relationship is indicated visually by all children being right-indented and positioned immediately below their parent in the <span class="strong"><strong>Hierarchy</strong></span> panel. If a parent object is transformed (moved/scaled/rotated), then all its children will also <a id="id882" class="indexterm"></a>be transformed accordingly.</p></div></li><li><p>In the <span class="strong"><strong>Inspector</strong></span> panel, add a new NavMeshAgent to <span class="strong"><strong>Sphere-arrow</strong></span>; choose <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Navigation</strong></span> | <span class="strong"><strong>Nav Mesh Agent</strong></span>.</p></li><li><p>Set the <span class="strong"><strong>Stopping Distance</strong></span> property of <span class="strong"><strong>NavMeshAgent</strong></span> component to <code class="literal">2</code>.</p></li><li><p>Add the<a id="id883" class="indexterm"></a> following C# script class called <code class="literal">ArrowNPCMovement</code> to GameObject <span class="strong"><strong>Sphere-arrow</strong></span>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ArrowNPCMovement : MonoBehaviour {
  public GameObject targetGO;
  private NavMeshAgent navMeshAgent;

  void Start (){
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    HeadForDestintation();
  }

  private void HeadForDestintation (){
    Vector3 destinaton = targetGO.transform.position;
    navMeshAgent.SetDestination (destinaton);
  }
}</pre></div></li><li><p>Ensure that <span class="strong"><strong>Sphere-arrow</strong></span> is selected in the <span class="strong"><strong>Inspector</strong></span> panel for the <code class="literal">ArrowNPCMovement</code> scripted component. Drag <span class="strong"><strong>Capsule-destination</strong></span> over the variable <span class="strong"><strong>Projectile</strong></span> called <span class="strong"><strong>Target GO</strong></span>.</p></li><li><p>Create a 3D cube named <span class="strong"><strong>Cube-wall</strong></span> at (-6, 0, 0), and scale it to (1, 2, 10).</p></li><li><p>Create another 3D cube named <span class="strong"><strong>Cube-wall</strong></span> at (-2, 0, 6), and scale it to (1, 2, 7).</p></li><li><p>Display the <span class="strong"><strong>Navigation</strong></span> panel by choosing <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Navigation</strong></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"></a>Note</h3><p>A great place to <span class="emphasis"><em>dock</em></span> the <span class="strong"><strong>Navigation</strong></span> panel is next to the <span class="strong"><strong>Inspector</strong></span> panel since you will never be using the <span class="strong"><strong>Inspect</strong></span> and <span class="strong"><strong>Navigation</strong></span> panels at the same time.</p></div></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> tab, select both of the <span class="strong"><strong>Cube-wall</strong></span> objects (we select the objects that are <span class="emphasis"><em>not</em></span> supposed to be a part of<a id="id884" class="indexterm"></a> the <span class="strong"><strong>walkable</strong></span> parts of our scene), and then in the <span class="strong"><strong>Navigation</strong></span> panel, check the <span class="strong"><strong>Navigation Static</strong></span> checkbox. Then, click<a id="id885" class="indexterm"></a> on the <span class="strong"><strong>Bake</strong></span> button at the bottom of the <span class="strong"><strong>Navigation</strong></span> panel. When the <span class="strong"><strong>Navigation</strong></span> panel is displayed, you'll see a blue <span class="emphasis"><em>tint</em></span> on the parts of the <span class="strong"><strong>Scene</strong></span> that are walkable. Candidate areas for a <span class="strong"><strong>NavMeshAgent</strong></span> are supposed to be considered as parts of a path to a destination.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_08_06.jpg" /></div></li><li><p>Now run your game. You will see the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject automatically move towards the <span class="strong"><strong>Capsule-destination</strong></span> GameObject, following a path that avoids the two wall objects.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec244"></a>How it works...</h3></div></div></div><p>The <span class="strong"><strong>NavMeshAgent</strong></span> component that we added to GameObject<span class="strong"><strong> Sphere-arrow</strong></span> does most of the work for us. <span class="strong"><strong>NavMeshAgents</strong></span> need 2 things: a destination location to head towards, and a <span class="strong"><strong>NavMesh</strong></span> component of the terrain with walkable/non-walkable areas, so that it can plan a path, avoiding obstacles. We created two obstacles (the <span class="strong"><strong>Cube-wall</strong></span> objects), and these were selected when we created <span class="strong"><strong>NavMesh</strong></span> for this scene in the <span class="strong"><strong>Navigation</strong></span> panel.</p><p>The location for our NPC object to travel towards is the position of the <span class="strong"><strong>Capsule-destination</strong></span> GameObject at (-12, 0, 8); but of course, we could just move this object in the <span class="strong"><strong>Scene</strong></span> panel at <a id="id886" class="indexterm"></a><span class="strong"><strong>Design-time</strong></span>, and its new position would be the destination when we run the game.</p><p>The C# script class called <code class="literal">ArrowNPCMovement</code> has two variables: one is a reference to the destination GameObject, and the second is a reference to the NavMeshAgent component of the GameObject in which our instance of the <code class="literal">ArrowNPCMovement</code> class is also a component. When the scene starts, via the <code class="literal">Start()</code> method, the <span class="strong"><strong>NavMeshAgent</strong></span> sibling component is found, and the <code class="literal">HeadForDestination()</code> method is called, which sets the destination of the NavMeshAgent to the position of the destination GameObject.</p><p>Once the NavMeshAgent has a target to head towards, it will plan a path there and will keep moving until it arrives (or gets within the <span class="strong"><strong>Stopping Distance</strong></span> if that parameter has been set to a<a id="id887" class="indexterm"></a> distance greater than zero).</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip10"></a>Tip</h3><p>Ensure that the object with the NavMeshAgent component is selected in the <span class="strong"><strong>Hierarchy</strong></span> panel at runtime to be able to see this navigation data in the <span class="strong"><strong>Scene</strong></span> panel.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec245"></a>There's more...</h3></div></div></div><p>There are some details that you don't want to miss.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec58"></a>Constantly updating the NavMeshAgent destination to Player's character current location</h4></div></div></div><p>Rather than a destination that is fixed when the scene starts, let's allow the <span class="strong"><strong>Capsule-destination</strong></span> object to be moved by the player while the scene is running. In every frame, we'll get our NPC arrow to reset the NavMeshAgent's destination to wherever the <span class="strong"><strong>Capsule-destination</strong></span> has been moved to.</p><p>To allow the user movement<a id="id888" class="indexterm"></a> of the destination object and frame-by-frame updating of NavMeshAgent destination, we need to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add an instance of the C# script class called <code class="literal">PlayerControl</code> as a component of <span class="strong"><strong>Capsule-destination</strong></span>.</p></li><li><p>Update the C# script class called <code class="literal">ArrowNPCMovement</code> so that we call the <code class="literal">HeadForDestintation() </code>method every frame, that is, from <code class="literal">Update()</code>, rather than just once in <code class="literal">Start()</code>:</p><div class="informalexample"><pre class="programlisting">void Start (){
  navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
}

void Update (){
  HeadForDestintation();
}</pre></div></li></ol></div><p>Now, when you run the game, you can use the arrow keys to move the destination location, and the NavMeshAgent will update its paths in each frame, based on the updated <a id="id889" class="indexterm"></a>position of the <span class="strong"><strong>Capsule-destination</strong></span> GameObject.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec59"></a>Constantly update NavMeshAgent destination to flee away from Player's character current location</h4></div></div></div><p>Rather than seeking towards the player's current position, let's make our NPC agent always attempt to flee away <a id="id890" class="indexterm"></a>from the player's location. For example, an enemy with very low-health points might run away, and so gain time to regain its health before fighting again.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_08_10.jpg" /></div><p>To instruct our NavMeshAgent to flee away from the player's location, we need to replace the C# script class called <code class="literal">ArrowNPCMovement</code> with the following:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ArrowNPCMovement : MonoBehaviour {
  public GameObject targetGO;
  private NavMeshAgent navMeshAgent;
  private float runAwayMultiplier = 2;
  private float runAwayDistance;

  void Start(){
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    runAwayDistance = navMeshAgent.stoppingDistance * runAwayMultiplier;
  }

  void Update () {
    Vector3 enemyPosition = targetGO.transform.position;
    float distanceFromEnemy = Vector3.Distance(transform.position, enemyPosition);
    if (distanceFromEnemy &lt; runAwayDistance)
      FleeFromTarget (enemyPosition);
  }

  private void FleeFromTarget(Vector3 enemyPosition){
    Vector3 fleeToPosition = Vector3.Normalize(transform.position - enemyPosition) * runAwayDistance;
    HeadForDestintation(fleeToPosition);
  }

  private void HeadForDestintation (Vector3 destinationPosition){
    navMeshAgent.SetDestination (destinationPosition);
  }
}</pre></div><p>The <code class="literal">Start()</code> method caches a reference to the NavMeshAgent component, and also calculates the <code class="literal">runAwayDistance</code> variable to be twice the NavMeshAgent's stopping distance (although this can be changed by changing the value of the <code class="literal">runAwayMultiplier</code> variable accordingly). When the distance to the enemy is less than the value of this variable, then we'll instruct the computer-controlled object to flee in the opposite direction.</p><p>The <code class="literal">Update()</code> method <a id="id891" class="indexterm"></a>calculates whether the distance to the enemy is within the <code class="literal">runAwayDistance</code>, and if so, it calls the <code class="literal">FleeFromTarget(…)</code> method that passes the location of the enemy as a parameter.</p><p>The <code class="literal">FleeFromTarget(…)</code> method calculates a point that is the <code class="literal">runAwayDistance</code> Unity units away from the Player's<a id="id892" class="indexterm"></a> cube, in a direction that is directly away from the computer-controlled object. This is achieved by subtracting the enemy position vector from the current transform's position. Finally, the <code class="literal">HeadForDestintation(…)</code> method is called, passing the flee-to position, which results in the NavMeshAgent being told to set the location as its new destination.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"></a>Note</h3><p>The Unity units are arbitrary, since they are just numbers in a computer. However, in most cases, it simplifies things to think of distances in terms of meters (1 Unity unit = 1 meter), and mass in terms of kilograms (1 Unity unit  = 1 kilogram). Of course, if your game is based on a microscopic world, or a pan-galatic space travel and more, then you need to decide what each Unity unit corresponds to for your game context. For <a id="id893" class="indexterm"></a>more discussion of units in Unity, check out the <a class="ulink" href="http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487" target="_blank"> http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487</a> link.</p></div><p>As the following<a id="id894" class="indexterm"></a> screenshot illustrates, the NavMeshAgent plans a path to the position to flee towards:</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_08_17.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec60"></a>Create a mini point-and-click game</h4></div></div></div><p>Another way to<a id="id895" class="indexterm"></a> choose the destination for our <span class="strong"><strong>Sphere-arrow</strong></span> GameObject is by the user clicking on an object on the screen, and then the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject moving to the location of the clicked object.</p><p>To allow the user to select the destination objects with point-and-click, we need to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Remove the <code class="literal">ArrowNPCMovement</code> component from the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject.</p></li><li><p>Create some target objects, such as a black cube, a blue sphere, and a green cylinder. Note that, to be a target, each object needs to have a collider component in order to receive the <code class="literal">OnMouseOver</code> event messages (when creating primitives objects from the Unity menu <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>3D Object</strong></span>, the colliders are automatically created).</p></li><li><p>Add an<a id="id896" class="indexterm"></a> instance of the following C# script class called <code class="literal">ClickMeToSetDestination</code> to each of the GameObjects that you wish to be a clickable target:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ClickMeToSetDestination : MonoBehaviour {
  private NavMeshAgent playerNavMeshAgent;
  private MeshRenderer meshRenderer;
  private bool mouseOver = false;

  private Color unselectedColor;

  void Start (){
    meshRenderer = GetComponent&lt;MeshRenderer&gt;();
    unselectedColor = meshRenderer.sharedMaterial.color;

    GameObject playerGO = GameObject.FindGameObjectWithTag("Player");
    playerNavMeshAgent = playerGO.GetComponent&lt;NavMeshAgent&gt;();
  }

  void Update (){
    if (Input.GetButtonDown("Fire1") &amp;&amp; mouseOver)
      playerNavMeshAgent.SetDestination(transform.position);
  }

  void OnMouseOver (){
    mouseOver = true;
    meshRenderer.sharedMaterial.color = Color.yellow;
  }

  void OnMouseExit (){
    mouseOver = false;
    meshRenderer.sharedMaterial.color = unselectedColor;
  }
}</pre></div></li></ol></div><p>Now, while running the game, when your mouse is over one of the three objects, that object will be highlighted yellow. If you click on the mouse button when the object is highlighted, the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject will make its way up to (but stopping just before) the clicked <a id="id897" class="indexterm"></a>object.</p></div></div></div>