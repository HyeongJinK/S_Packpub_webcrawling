<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec114"></a>Reducing the number of enabled objects by disabling objects whenever possible</h2></div></div><hr /></div><p>
<span class="strong"><strong>Optimization principal 1</strong></span>: Minimize the number of active and enabled objects in a scene.</p><p>Sometimes, we <a id="id1213" class="indexterm"></a>may not want to completely remove an object, but we can identify times when a scripted component of an object can be safely disabled. If a <code class="literal">MonoBehaviour</code> script is disabled, then Unity no longer needs to send the object messages, such as <code class="literal">Update()</code>and <code class="literal">FixedUpdate()</code>, for each frame.</p><p>For example, if a <span class="strong"><strong>Non-Player Character</strong></span> (<span class="strong"><strong>NPC</strong></span>) should only demonstrate some behavior when the player <a id="id1214" class="indexterm"></a>can see that character, then we only need to be executing the behavior logic when the NPC is visible—the rest of the time, we can safely disable the scripted component.</p><p>Unity provides the very useful events <code class="literal">OnBecameInvisible()</code> and <code class="literal">OnBecameVisible()</code>, which inform an object when it moves out of and into the visible area for one or more cameras in the scene.</p><p>This recipe illustrates the following rule of thumb: if an object has no reason to be doing actions when it cannot be seen, then we should disable that object while it cannot be seen.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_11_16.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec356"></a>Getting ready</h3></div></div></div><p>For this recipe, we have prepared a package named <code class="literal">unity4_assets_handyman_goodDirt</code> containing the <code class="literal">3rdPersonController</code> handyman and Terrain material <code class="literal">goodDirt</code>. The package is in the <code class="literal">1362_11_07</code> folder.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec357"></a>How to do it...</h3></div></div></div><p>To disable objects to reduce<a id="id1215" class="indexterm"></a> computer processing workload requirements, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new Unity project, importing the provided Unity package <code class="literal">unity4_assets_handyman_goodDirt</code>.</p></li><li><p>Create a new <span class="strong"><strong>Terrain </strong></span>(size <span class="strong"><strong>20 x 20</strong></span>, located at <span class="strong"><strong>-10, 0, -10</strong></span>) and texture-paint it with <span class="strong"><strong>GoodDirt</strong></span> (which you'll find in the <span class="strong"><strong>Standard Assets</strong></span> folder from your import of the <span class="strong"><strong>Terrain Assets</strong></span> package).</p></li><li><p>Add a <span class="strong"><strong>3rdPersonController</strong></span> at (<span class="strong"><strong>0, 1, 0</strong></span>).</p></li><li><p>Create a new <span class="strong"><strong>Cube</strong></span> just in front of your <span class="strong"><strong>3rdPersonController</strong></span> (so it is visible in the <span class="strong"><strong>Game</strong></span> panel when you start running the game).</p></li><li><p>Add the following C# script class <code class="literal">DisableWhenNotVisible</code> to your <span class="strong"><strong>Cube</strong></span>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class DisableWhenNotVisible : MonoBehaviour {
  private GameObject player;

  void Start(){
    player = GameObject.FindGameObjectWithTag("Player");
  }

  void OnBecameVisible() {
    enabled = true;
    print ("cube became visible again");
  }

  void OnBecameInvisible() {
    enabled = false;
    print ("cube became invisible");
  }

  void Update(){
    //do something, so we know when this script is NOT doing something!
    float d = Vector3.Distance( transform.position, player.transform.position);
    print(Time.time + ": distance from player to cube = " + d);
  }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec358"></a>How it works...</h3></div></div></div><p>When visible, the scripted <code class="literal">DisableWhenNotVisible</code> component of <span class="strong"><strong>Cube</strong></span> recalculates and displays the distance from itself to the <span class="strong"><strong>3rdPersonController</strong></span> object's transform, via the variable <code class="literal">player</code> in the <code class="literal">Update()</code> method for each frame. However, when this object receives the message <code class="literal">OnBecameInvisible()</code>, the object sets its <code class="literal">enabled</code> property to <code class="literal">false</code>. This results in Unity no longer sending <code class="literal">Update()</code>messages to the <code class="literal">GameObject</code>, so the distance calculation in <code class="literal">Update()</code> is no longer performed; thus, reducing the game's processing workload. Upon receiving the message <code class="literal">OnBecameVisible()</code>, the <code class="literal">enabled</code> property is set back<a id="id1216" class="indexterm"></a> to <code class="literal">true</code>, and the object will then receive <code class="literal">Update()</code> messages for each frame. Note that you can see the scripted component become disabled by seeing the blue <span class="emphasis"><em>tick</em></span> in its <span class="strong"><strong>Inspector</strong></span> checkbox disappear if you have the <span class="strong"><strong>Cube</strong></span> selected in the <span class="strong"><strong>Hierarchy</strong></span> when running the game.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_11_17.jpg" /></div><p>The preceding screenshot shows our <span class="strong"><strong>Console</strong></span> text output, logging how the user must have turned away from the cube at 6.9 seconds after starting the game (and so the cube was no longer visible); then, at 9.4 seconds, the user turned so that they could see the cube again, causing it to be re-enabled.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec359"></a>There's more...</h3></div></div></div><p>Some details you don't want to miss:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec93"></a>Note – viewable in Scene panel still counts as visible!</h4></div></div></div><p>Note that even if the <span class="strong"><strong>Game</strong></span> panel is not showing (rendering) an object, if the object is visible in a <span class="strong"><strong>Scene</strong></span> panel, then it will still be considered visible. Therefore, it is recommended that <a id="id1217" class="indexterm"></a>you hide/close the <span class="strong"><strong>Scene</strong></span> panel when testing this recipe, otherwise it may be that the object does only becomes non-visible when the game stops running.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec94"></a>Another common case – only enable after OnTrigger()</h4></div></div></div><p>Another common <a id="id1218" class="indexterm"></a>situation is that we only want a scripted component to be active if the player's character is nearby (within some minimum distance). In these situations, a sphere collider (with <span class="strong"><strong>Is Trigger</strong></span> checked) can be set up on the object to be disabled/enabled (continuing our example, this would be on our <span class="strong"><strong>Cube</strong></span>), and the scripted component can be enabled only when the player's character enters that sphere. This can be implemented by replacing the <code class="literal">OnBecameInvisible()</code> and  <code class="literal">OnBecameVisible()</code> methods with the <code class="literal">OnTriggerEnter()</code> and <code class="literal">OnTriggerExit()</code> methods as follows:</p><div class="informalexample"><pre class="programlisting">void OnTriggerEnter(Collider hitObjectCollider) {
  if (hitObjectCollider.CompareTag("Player")){
    print ("cube close to Player again");
    enabled = true;
  }
}

void OnTriggerExit(Collider hitObjectCollider) {
  if (hitObjectCollider.CompareTag("Player")){
    print ("cube away from Player");
    enabled = false;
  }
}</pre></div><p>The following screenshot illustrates a large sphere collider having been created around the cube, with its <span class="strong"><strong>Trigger</strong></span> enabled:</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_11_18.jpg" /></div><p>Many computer games (such as <span class="emphasis"><em>Half Life</em></span>) use environmental design such as corridors to optimize memory usage by loading and unloading different parts of the environment. For example, when<a id="id1219" class="indexterm"></a> a player hits a corridor trigger, environment objects load and unload. See the following for more information about such techniques:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://gamearchitect.net/Articles/StreamingBestiary.html" target="_blank">http://gamearchitect.net/Articles/StreamingBestiary.html</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://cie.acm.org/articles/level-design-optimization-guidelines-for-game-artists-using-the-epic-games/" target="_blank">http://cie.acm.org/articles/level-design-optimization-guidelines-for-game-artists-using-the-epic-games/</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://gamedev.stackexchange.com/questions/33016/how-does-3d-games-work-so-fluent-provided-that-each-meshs-size-is-so-big" target="_blank">http://gamedev.stackexchange.com/questions/33016/how-does-3d-games-work-so-fluent-provided-that-each-meshs-size-is-so-big</a>
</p></li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec360"></a>See also</h3></div></div></div><p>Refer to the following recipes in this chapter for more information:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Reducing the number of objects by destroying objects at a death time</em></span>
</p></li><li style="list-style-type: disc"><p>
<span class="emphasis"><em>Reducing the number of active objects by making objects inactive whenever possible</em></span>
</p></li></ul></div></div></div>