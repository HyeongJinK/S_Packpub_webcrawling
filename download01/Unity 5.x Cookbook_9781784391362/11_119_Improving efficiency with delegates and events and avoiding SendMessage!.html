<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec116"></a>Improving efficiency with delegates and events and avoiding SendMessage!</h2></div></div><hr /></div><p>
<span class="strong"><strong>Optimization principal 2</strong></span>: Minimize actions requiring Unity to perform "reflection" over objects and searching of all current scene objects.</p><p>When events <a id="id1224" class="indexterm"></a>can be based on visibility, distance, or <a id="id1225" class="indexterm"></a>collisions, we can use such events as <code class="literal">OnTriggerExit</code> and <code class="literal">OnBecomeInvisible</code>, as described in some of the previous recipes. When events can be based on time periods, we can use coroutines, as described in other recipes in this chapter. However, some events are unique to each game situation, and C# offers several methods of broadcasting user-defined event messages to scripted objects. One approach is the <code class="literal">SendMessage(…)</code> method, which, when sent to a GameObject, will check every <code class="literal">Monobehaviour</code> scripted component and execute the named method if its parameters match. However, this involves an<a id="id1226" class="indexterm"></a> inefficient technique known as <span class="strong"><strong>reflection</strong></span>. C# offers another event message approach known<a id="id1227" class="indexterm"></a> as <span class="strong"><strong>delegates and events</strong></span>, which we describe and implement in this recipe. Delegates and events work in a similar way to <code class="literal">SendMessage(…)</code>, but are much more efficient since Unity maintains a defined list of which objects are <span class="emphasis"><em>listening</em></span> to the broadcast events. <code class="literal">SendMessage(…)</code> should be avoided if performance is important, since it means that Unity has to analyze each scripted object (<span class="emphasis"><em>reflect over</em></span> the object) to see whether there is a public method corresponding to the message that has been sent; this is much slower than using delegates and events.</p><p>Delegates and events implement<a id="id1228" class="indexterm"></a> the <span class="strong"><strong>publish-subscribe design pattern</strong></span> (<span class="strong"><strong>pubsub</strong></span>). This is also known as the <a id="id1229" class="indexterm"></a><span class="strong"><strong>observer</strong></span> design pattern. Objects can subscribe one of their methods to receive a particular type of event message from a particular publisher. In this recipe, we'll have a manager class that will publish new events when UI buttons are clicked. We'll create some UI objects, some of which <span class="strong"><strong>subscribe</strong></span> to the color change events, so that each time a color change event is published, subscribed UI objects receive the event message and change their color accordingly. C# publisher objects don't have to worry about how many objects subscribe to them at any point in time (it could be none or 1,000!); this is known as <span class="strong"><strong>loose coupling</strong></span>, since it allows different code components to be written (and maintained) independently and is a desirable feature of object-oriented code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec364"></a>How to do it...</h3></div></div></div><p>To implement<a id="id1230" class="indexterm"></a> delegates and events, follow<a id="id1231" class="indexterm"></a> these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new 2D project.</p></li><li><p>Add the following C# script class <span class="strong"><strong>ColorManager</strong></span> to the <span class="strong"><strong>Main Camera</strong></span>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ColorManager : MonoBehaviour {
  public void BUTTON_ACTION_make_green(){
    PublishColorEvent(Color.green);
  }

  public void BUTTON_ACTION_make_blue(){
    PublishColorEvent(Color.blue);
  }

  public void BUTTON_ACTION_make_red(){
    PublishColorEvent(Color.red);
  }

  public delegate void ColorChangeHandler(Color newColor);
  public static event ColorChangeHandler onChangeColor;

  private void PublishColorEvent(Color newColor){
    // if there is at least one listener to this delegate
    if(onChangeColor != null){
      // broadcast change color event
      onChangeColor(newColor);
    }
  }
}</pre></div></li><li><p>Create two UI <span class="strong"><strong>Image</strong></span> objects and two UI <span class="strong"><strong>Text</strong></span> objects. Position one <span class="strong"><strong>Image</strong></span> and <span class="strong"><strong>Text</strong></span> object to the lower left of the screen and position the other to the lower right of the screen. Make the text on the lower left read <span class="strong"><strong>Not listening</strong></span>, and make the text on the right of the screen read <span class="strong"><strong>I am listening</strong></span>. For good measure, add a <span class="strong"><strong>Slider</strong></span> UI object in the top right of the screen.</p></li><li><p>Create three UI buttons in the top left of the screen, named <span class="strong"><strong>Button-GREEN</strong></span>, <span class="strong"><strong>Button-BLUE</strong></span>, and<a id="id1232" class="indexterm"></a> <span class="strong"><strong>Button-RED</strong></span>, with corresponding text reading <code class="literal">make things &lt;color=green&gt;GREEN&lt;/color&gt;</code>, <code class="literal">make things &lt;color=blue&gt;BLUE&lt;/color&gt;</code>, and <code class="literal">make things &lt;color=red&gt;RED&lt;/color&gt;</code>.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_11_22.jpg" /></div></li><li><p>Attach<a id="id1233" class="indexterm"></a> the following C# script class <code class="literal">ColorChangeListenerImage</code> to both the lower-right <span class="strong"><strong>Image</strong></span> and also the <span class="strong"><strong>Slider</strong></span>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class ColorChangeListenerImage : MonoBehaviour {
  void OnEnable() {
    ColorManager.onChangeColor += ChangeColorEvent;
  }

  private void OnDisable(){
    ColorManager.onChangeColor -= ChangeColorEvent;
  }

  void ChangeColorEvent(Color newColor){
    GetComponent&lt;Image&gt;().color = newColor;
  }
}</pre></div></li><li><p>Attach the following C# script class <code class="literal">ColorChangeListenerText</code> to the <span class="strong"><strong>I am listening Text</strong></span> UI object:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class ColorChangeListenerText : MonoBehaviour {
  void OnEnable() {
    ColorManager.onChangeColor += ChangeColorEvent;
  }

  private void OnDisable(){
    ColorManager.onChangeColor -= ChangeColorEvent;
  }

  void ChangeColorEvent(Color newColor){
    GetComponent&lt;Text&gt;().color = newColor;
  }
}</pre></div></li><li><p>With button-<span class="strong"><strong>GREEN</strong></span> selected in the <span class="strong"><strong>Hierarchy</strong></span>, add a new <span class="strong"><strong>On Click()</strong></span> event for this button, dragging the <span class="strong"><strong>Main Camera</strong></span> as the target GameObject and selecting public<a id="id1234" class="indexterm"></a> function <code class="literal">BUTTON_ACTION_make_green()</code>. Do the same for the <span class="strong"><strong>BLUE</strong></span> and <span class="strong"><strong>RED</strong></span> buttons with functions <code class="literal">BUTTON_ACTION_make_blue()</code> and <code class="literal">BUTTON_ACTION_make_red()</code> respectively.</p></li><li><p>Run the game. When you click a change color button, the three UI objects on the right of the screen show all changes to the corresponding color, while the two UI objects at the bottom left of the screen remain in the default <span class="strong"><strong>White</strong></span> color.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec365"></a>How it works...</h3></div></div></div><p>First, let's consider what we want to happen—we want the right-hand <span class="strong"><strong>Image</strong></span>, <span class="strong"><strong>Slider</strong></span>, and <span class="strong"><strong>Text</strong></span> objects to change their color when they receive an event message <code class="literal">OnChangeColor()</code> with a new color argument.</p><p>This is achieved<a id="id1235" class="indexterm"></a> by each object having an instance of the appropriate <code class="literal">ColorChangeListener</code> class that subscribes their <code class="literal">OnChangeColor()</code> method to listen for color change events published from the <code class="literal">ColorManager</code> class. Since both the <span class="strong"><strong>Image</strong></span> and <span class="strong"><strong>Slider</strong></span> objects have an image component whose color will change, they have scripted components of our C# class <code class="literal">ColorChangeListenerImage</code>, while the <span class="strong"><strong>Text</strong></span> object needs a different class since it is the color of the text component whose color is to be changed (so we add an instance of C# scripted component <code class="literal">ColorChangeListenerText</code> to the <span class="strong"><strong>Text</strong></span> UI object). So, as we can see, different objects may respond to receiving the same event messages in ways appropriate to each different object.</p><p>Since our scripted objects may be disabled and enabled at different times, each time a scripted <code class="literal">ColorChangeListener</code> object is enabled (such as when its GameObject parent is instantiated), its <code class="literal">OnChangeColor()</code> method is added (<code class="literal">+=</code>) to the list of those subscribed to listen for color change events, likewise each time <code class="literal">ColorChangeListenerImage/Text</code> objects are disabled, those methods are removed (<code class="literal">-=</code>) from the list of event subscribers.</p><p>When a <code class="literal">ColorChangeListenerImage/Text</code> object receives a color change message, its subscribed <code class="literal">OnChangeColor()</code> method is executed and the color of the appropriate component is changed to the received <code class="literal">Color</code> value (<code class="literal">green</code>/<code class="literal">red</code>/<code class="literal">blue</code>).</p><p>The <code class="literal">ColorManager</code><a id="id1236" class="indexterm"></a> class has a public class (static) variable <code class="literal">changeColorEvent</code>, which defines an <span class="emphasis"><em>event</em></span> to which Unity maintains a dynamic list of all the subscribed object methods. It is to this event that <code class="literal">ColorChangeListenerImage/Text</code> objects register or deregister their methods.</p><p>The <code class="literal">ColorManager</code> class displays three buttons to the user to change all listening objects to a specific color: green, red, and blue. When a button is clicked, the <code class="literal">changeColorEvent</code> is told to publish a new event, passing a<a id="id1237" class="indexterm"></a> corresponding <code class="literal">Color</code> argument to all subscribed object methods.</p><p>The <code class="literal">ColorManager</code> class declares a <span class="emphasis"><em>Delegate</em></span> named <code class="literal">ColorChangeHandler</code>. Delegates define the return type (in this case, <code class="literal">void</code>) and argument <span class="emphasis"><em>signature</em></span> of methods that can be delegated (subscribed) to an event. In this case, methods must have the argument signature of a single parameter of type <code class="literal">Color</code>. Our <code class="literal">OnChangeColor()</code> method in classes <code class="literal">ColorChangeListenerImage/Text</code> match this argument signature and so are permitted to subscribe to the <code class="literal">changeColorEvent</code> in the <code class="literal">ColorManager</code> class.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p>Note: An easy to<a id="id1238" class="indexterm"></a> understand video about Unity delegates and events can be found at <a class="ulink" href="http://www.youtube.com/watch?v=N2zdwKIsXJs" target="_blank">http://www.youtube.com/watch?v=N2zdwKIsXJs</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec366"></a>See also</h3></div></div></div><p>Refer to the <span class="emphasis"><em>Cache GameObject and component references to avoid expensive lookups</em></span> recipe in this chapter for more information.</p></div></div>