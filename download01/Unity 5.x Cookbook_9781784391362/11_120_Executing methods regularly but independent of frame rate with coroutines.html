<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec117"></a>Executing methods regularly but independent of frame rate with coroutines</h2></div></div><hr /></div><p>
<span class="strong"><strong>Optimization principal 3</strong></span>: Call methods as few times as possible.</p><p>While it is very simple to put logic into <code class="literal">Update()</code> and have it regularly executed for each frame, we can improve game performance by executing logic as rarely as possible. So, if we can get away with only checking for a situation every 5 seconds, then great performance savings can be made to move that logic out of <code class="literal">Update()</code>.</p><p>A <span class="strong"><strong>coroutine</strong></span> is a function that <a id="id1239" class="indexterm"></a>can suspend its execution until a <code class="literal">yield</code> action has completed. One kind of yield action simply waits for a given number of seconds. In this recipe, we use coroutines and yield to show how a method can be only executed every 5 seconds; this could be useful for NPCs to decide whether they should randomly <span class="emphasis"><em>wake up</em></span> or perhaps choose a new location to start moving toward.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_11_23.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec367"></a>How to do it...</h3></div></div></div><p>To implement <a id="id1240" class="indexterm"></a>methods at regular intervals independent of the frame rate, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following C# script class <code class="literal">TimedMethod</code> to the <span class="strong"><strong>Main Camera</strong></span>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class TimedMethod : MonoBehaviour {
  private void Start() {
    StartCoroutine(Tick());
  }

  private IEnumerator Tick() {
    float delaySeconds = 5.0F;
    while (true) {
      print("tick " + Time.time);
      yield return new WaitForSeconds(delaySeconds);
    }
  }
}</pre></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec368"></a>How it works...</h3></div></div></div><p>When the <code class="literal">Start()</code> message is received, the <code class="literal">Tick()</code> method is started as a coroutine. The <code class="literal">Tick()</code> method sets the delay between executions (variable <code class="literal">delaySeconds</code>) to 5 seconds. An infinite loop is then started, where the method does its actions (in this case, just printing out the time); finally, a <code class="literal">yield</code> instruction is executed, which causes the method to suspend execution for the given delay of 5 seconds. After the yield instruction has completed, the<a id="id1241" class="indexterm"></a> loop will continue executing once again and so on. What is important to understand when working with coroutines is that the method will <span class="emphasis"><em>resume executing</em></span> from the same state it yielded.</p><p>You may have noticed that <span class="emphasis"><em>there are no</em></span> <code class="literal">Update()</code> <span class="emphasis"><em>or</em></span> <code class="literal">FixedUpdate()</code> <span class="emphasis"><em>methods at all</em></span>. So, although our game has logic being regularly executed, in this example, there is no logic that has to be executed every frameâ€”fantastic!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec369"></a>There's more...</h3></div></div></div><p>Some details you don't want to miss:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch11lvl3sec95"></a>Have different actions happening at different intervals</h4></div></div></div><p>Coroutines can be used to have different kinds of logic being executed at different regular intervals. So, logic that needs frame-by-frame execution goes into <code class="literal">Update()</code>, and logic that works fine once <a id="id1242" class="indexterm"></a>or twice a second might go into a coroutine with a 0.5-second delay; logic that can get away with less occasional updating can go into another coroutine with a 2- or 5-second delay, and so on. Effective and noticeable performance improvements can be found by carefully analyzing (and testing) different game logic to identify the <span class="emphasis"><em>least frequent execution</em></span> that is still acceptable.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec370"></a>See also</h3></div></div></div><p>Refer to the next recipe for more information.</p></div></div>