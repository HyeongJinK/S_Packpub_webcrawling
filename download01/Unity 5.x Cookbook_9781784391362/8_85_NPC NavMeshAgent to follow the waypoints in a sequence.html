<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec85"></a>NPC NavMeshAgent to follow the waypoints in a sequence</h2></div></div><hr /></div><p>Waypoints <a id="id898" class="indexterm"></a>are often used as a guide to make autonomously moving NPCs and enemies follow a path in a general way (but be able to respond with other directional behaviors, such as flee or seek, if friends/predators/prey are sensed nearby). The waypoints are arranged in a sequence, so that when the character reaches, or gets close to a waypoint, it will then select the next waypoint in the sequence as the target location to move towards. This recipe demonstrates an arrow object moving towards a waypoint, and then, when it gets close enough, it will choose the next waypoint in the sequence as the new target destination. When the last waypoint has been reached, it again starts heading towards the first waypoint.</p><p>Since Unity's NavMeshAgent has simplified coding NPC behavior, our work in this recipe becomes basically finding the position of the next waypoint, and then telling the NavMeshAgent that this waypoint is its new destination.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_08_08.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec246"></a>Getting ready</h3></div></div></div><p>This recipe<a id="id899" class="indexterm"></a> builds upon the player-controlled 3D cube Unity project that you created at the beginning of this chapter. So, make a copy of this project, open it, and then follow the steps for this recipe.</p><p>For this recipe, we have prepared the yellow brick texture image that you need in a folder named <code class="literal">Textures</code> in the <code class="literal">1362_08_06</code> folder<code class="literal">.</code>
</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec247"></a>How to do it...</h3></div></div></div><p>To instruct an object to follow a sequence of waypoints, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Delete the <span class="strong"><strong>Cube-player</strong></span> GameObject, since we are going to be creating an NPC computer controlled agent.</p></li><li><p>Create a sphere named <span class="strong"><strong>Sphere-arrow</strong></span>, position at (2, 0.5, 2), and scale it as (1,1,1).</p></li><li><p>Create a second sphere named <span class="strong"><strong>Sphere-small</strong></span>, and scale it as (0.5, 0.5, 0.5).</p></li><li><p>Child <span class="strong"><strong>Sphere-small</strong></span> to <span class="strong"><strong>Sphere-arrow</strong></span>, and then position it at (0, 0, 0.5).</p></li><li><p>In the <span class="strong"><strong>Inspector,</strong></span> add a new NavMeshAgent to <span class="strong"><strong>Sphere-arrow</strong></span>, and then choose <span class="strong"><strong>Add Component</strong></span> | <span class="strong"><strong>Navigation</strong></span> | <span class="strong"><strong>NavMeshAgent</strong></span>.</p></li><li><p>Set the <span class="strong"><strong>Stopping Distance</strong></span> property of the <span class="strong"><strong>NavMeshAgent</strong></span> component to <code class="literal">2</code>.</p></li><li><p>Display the <span class="strong"><strong>Navigation</strong></span> panel by choosing <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Navigation</strong></span>.</p></li><li><p>Click on the <span class="strong"><strong>Bake</strong></span> button at the bottom of the <span class="strong"><strong>Navigation</strong></span> panel. When the <span class="strong"><strong>Navigation</strong></span> panel is displayed, you'll see a blue <span class="emphasis"><em>tint</em></span> on the parts of the <span class="strong"><strong>Scene</strong></span> panel that are walkable, which will be all parts of the terrain, except near the edges.</p></li><li><p>Add an<a id="id900" class="indexterm"></a> instance of the following C# script class called <code class="literal">ArrowNPCMovement</code> to the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ArrowNPCMovement : MonoBehaviour {
  private GameObject targetGO = null;
  private WaypointManager waypointManager;
  private NavMeshAgent navMeshAgent;

  void Start (){
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    waypointManager = GetComponent&lt;WaypointManager&gt;();
    HeadForNextWayPoint();
  }

  void Update (){
    float closeToDestinaton = navMeshAgent.stoppingDistance * 2;
    if (navMeshAgent.remainingDistance &lt; closeToDestinaton){
      HeadForNextWayPoint ();
    }
  }

  private void HeadForNextWayPoint (){
    targetGO = waypointManager.NextWaypoint (targetGO);
    navMeshAgent.SetDestination (targetGO.transform.position);
  }
}</pre></div></li><li><p>Create a new capsule object named <span class="strong"><strong>Capsule-waypoint-0</strong></span> at (-12, 0, 8), and give it the <span class="strong"><strong>waypoint</strong></span> tag.</p></li><li><p>Copy <span class="strong"><strong>Capsule-waypoint -0,</strong></span> name the copy as <span class="strong"><strong>Capsule-waypoint -3,</strong></span> and position this copy at (8, 0, -8).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note42"></a>Note</h3><p>We are going to add some intermediate waypoints numbered 1 and 2 later on. This is why our second waypoint here is numbered 3, in case you were wondering.</p></div></li><li><p>Add the<a id="id901" class="indexterm"></a> following C# script class called <code class="literal">WaypointManager</code> to the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;

public class WaypointManager : MonoBehaviour {
  public GameObject wayPoint0;
  public GameObject wayPoint3;

  public GameObject NextWaypoint(GameObject current){
    if(current == wayPoint0)
      return wayPoint3;
    else
      return wayPoint0;
  }
}</pre></div></li><li><p>Ensure that <span class="strong"><strong>Sphere-arrow </strong></span>is selected in the <span class="strong"><strong>Inspector</strong></span> for the <code class="literal">WaypointManager</code> scripted component. Drag <span class="strong"><strong>Capsule-waypoint-0</strong></span> and <span class="strong"><strong>Capsule-waypoint-3</strong></span> over the public variable projectile called <span class="strong"><strong>Way Point 0 </strong></span>and<span class="strong"><strong> Way Point 3, </strong></span>respectively.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_08_07.jpg" /></div></li><li><p>Display the Navigation panel by choosing <span class="strong"><strong>Window | Navigation</strong></span>.</p></li><li><p>Click on the <span class="strong"><strong>Bake</strong></span> button at the bottom of the <span class="strong"><strong>Navigation</strong></span> panel. When the <span class="strong"><strong>Navigation</strong></span><a id="id902" class="indexterm"></a> panel is displayed, you'll see a blue <span class="emphasis"><em>tint</em></span> on the parts of the <span class="strong"><strong>Scene</strong></span> that are <span class="emphasis"><em>walkable</em></span>, which will be all the parts of the terrain, except near the edges.</p></li><li><p>Now, run your game. The arrow object will first move towards one of the waypoint capsules, then when it gets close to it, it will slow down, turn around, head towards the other waypoint capsule, and keep doing that continuously.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec248"></a>How it works...</h3></div></div></div><p>The <span class="strong"><strong>NavMeshAgent</strong></span> component that we added to the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject does most of the work for us. <span class="strong"><strong>NavMeshAgents</strong></span> need two things: a destination location to head towards, and a NavMesh, so that it can plan a path, avoiding obstacles.</p><p>We created two possible waypoints to be the location for our NPC to move towards: <span class="strong"><strong>Capsule-waypoint-0</strong></span> and <span class="strong"><strong>Capsule-waypoint-3</strong></span>.</p><p>The C# script class called <code class="literal">WaypointManager</code> has one job — to return a reference to the next waypoint that our NPC should head towards. There are two variables: <code class="literal">wayPoint0</code> and <code class="literal">wayPoint3</code> that reference to the two waypoint GameObjects in our scene. The <code class="literal">NextWaypoint(…)</code> method takes a single parameter named <code class="literal">current</code>, which is a reference to the current waypoint that the object was moving towards (or null). This method's task is to return a reference to the <span class="strong"><strong>next</strong></span> waypoint that the NPC should travel towards. The logic for this method is simple—if <code class="literal">current</code> refers to <code class="literal">waypoint0</code>, then we'll return <code class="literal">waypoint3</code>, otherwise we'll return <code class="literal">waypoint0</code>. Note that if we pass this <code class="literal">null</code> method, then we'll get <code class="literal">waypoint0</code> back (so, it is our default first waypoint).</p><p>The C# script class called <code class="literal">ArrowNPCMovement</code> has three variables: one is a reference to the destination GameObject named <code class="literal">targetGO</code>. The second is a reference to the <code class="literal">NavMeshAgent</code> component of the GameObject in which our instance of the class called <code class="literal">ArrowNPCMovement</code> is also a component. The third variable called <code class="literal">WaypointManager</code> is a reference to the sibling scripted component, an instance of our <code class="literal">WaypointManager</code> script class.</p><p>When the scene starts, via the <code class="literal">Start()</code>method, the <span class="strong"><strong>NavMeshAgent</strong></span> and <code class="literal">WaypointManager</code> sibling components are found, and the <code class="literal">HeadForDestination()</code>method is called.</p><p>The <code class="literal">HeadForDestination()</code> method first sets the variable called <code class="literal">targetGO</code> to refer to the GameObject<a id="id903" class="indexterm"></a> that is returned by a call to <code class="literal">NextWaypoint(…)</code> of the scripted component called <code class="literal">WaypointManager</code> (that is, <code class="literal">targetGO</code> is set to refer to either <span class="strong"><strong>Capsule-waypoint-0</strong></span> or <span class="strong"><strong>Capsule-waypoint-3</strong></span>). Next, it instructs the <code class="literal">NavMeshAgent</code> to make its destination the position of the <code class="literal">targetGO</code> GameObject.</p><p>Each frame method called <code class="literal">Update()</code> is called. A test is made to see if the distance from the NPC arrow object is close to the destination waypoint. If the distance is smaller than twice the <span class="emphasis"><em>stopping distance</em></span>, set in our <code class="literal">NavMeshAgent</code>, then a call is made to <code class="literal">WaypointManager</code>.<code class="literal">NextWaypoint(…)</code> to update our target destination to be the next waypoint in the sequence.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec249"></a>There's more...</h3></div></div></div><p>There are some details that you don't want to miss.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec61"></a>More efficient to avoid using NavMeshes for waypoints</h4></div></div></div><p>NavMeshes are far<a id="id904" class="indexterm"></a> superior to waypoints, since a location in a general area (not a specific point) can be used, and the path finding the algorithm will automatically find the shortest route. For a succinct recipe (such as the above), we can<a id="id905" class="indexterm"></a> simplify the implementation of waypoints using NavMeshes for calculating movements for us. However, for optimized, real-world games the most common way to move from one waypoint to the next is via linear interpolation, or by implementing Craig Reynold's Seek algorithm (for details follow the link listed in the Conclusion section, at the end of this chapter).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec62"></a>Working with arrays of waypoints</h4></div></div></div><p>Having a separate C# script class called <code class="literal">WaypointManager</code> to simply swap between <span class="strong"><strong>Capsule-waypoint-0</strong></span> and <span class="strong"><strong>Capsule-waypoint-3</strong></span> may have seemed to be a heavy duty and over-engineering task, but this was actually a very good move. An object of the script class called <code class="literal">WaypointManager</code> has the job of returning the <span class="emphasis"><em>next</em></span> waypoint. It is now very straightforward to add a more sophisticated approach of having an array of waypoints, without us having to change any code in the script class called <code class="literal">ArrowNPCMovement</code>. We can choose a random <a id="id906" class="indexterm"></a>waypoint to be the next destination (see the <span class="emphasis"><em>Choosing destinations – find nearest (or a random) spawnpoint</em></span> recipe). Or, we can have an array of waypoints, and choose the next one in the sequence.</p><p>To improve our game to work with an array of waypoints in the sequence to be followed, we need to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Copy <span class="strong"><strong>Capsule-waypoint-0</strong></span>, name the copy as <span class="strong"><strong>Capsule-waypoint-1</strong></span>, and position this copy at (0, 0, 8).</p></li><li><p>Make four more copies (named <span class="strong"><strong>Capsule-waypoint-1</strong></span>, <span class="strong"><strong>2, 4</strong></span>, <span class="strong"><strong>5</strong></span>), and position them as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Capsule-waypoint-1</strong></span>: Position = (-2, 0, 8)</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Capsule-waypoint-2</strong></span>: Position = (8, 0, 8)</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Capsule-waypoint-4</strong></span>: Position = (-2, 0, -8)</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Capsule-waypoint-5</strong></span>: Position = (-12, 0, -8)</p></li></ul></div></li><li><p>Replace the C# script class called <code class="literal">WaypointManager</code> with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using System;

public class WaypointManager : MonoBehaviour {
  public GameObject[] waypoints;

  public GameObject NextWaypoint (GameObject current)
  {
    if( waypoints.Length &lt; 1)
      Debug.LogError ("WaypointManager:: ERROR - no waypoints have been added to array!");

    int currentIndex = Array.IndexOf(waypoints, current);
    int nextIndex = ((currentIndex + 1) % waypoints.Length);
    return waypoints[nextIndex];
  }
}</pre></div></li><li><p>Ensure that <span class="strong"><strong>Sphere-arrow</strong></span> is selected. In the <span class="strong"><strong>Inspector</strong></span> panel for the <code class="literal">WaypointManager</code> scripted component set the size of the <code class="literal">Waypoints</code> array to <code class="literal">6</code>. Now, drag in all the six capsule waypoint objects called as <code class="literal">Capsule-waypoint</code>-<code class="literal">0</code>/<code class="literal">1</code>/<code class="literal">2</code>/<code class="literal">3</code>/<code class="literal">4</code>/<code class="literal">5</code>.</p></li><li><p>Run the game. Now, the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject will first move towards the waypoint 0 (top left, and then follow the sequence around the terrain).</p></li><li><p>Finally, you can make it look as if the Sphere is following a yellow brick road. Import the provided yellow brick texture, add this to your terrain, and paint the texture an oval-shaped path between the waypoints. You may also uncheck the Mesh Rendered component for each waypoint capsule, so that the user does not see any of the way points, but just the arrow object following<a id="id907" class="indexterm"></a> the yellow brick path</p></li></ol></div><p>In the <code class="literal">NextWaypoint(…)</code> method, first we check in case the array is empty, in which case an error is logged. Next, the array index for the current waypoint GameObject is found (if present in the array). Finally, the array index for the next waypoint is calculated using a modulus operator to support a cyclic sequence, returning to the beginning of the array after the last element has been visited.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec63"></a>Increased flexibility with a WayPoint class</h4></div></div></div><p>Rather than forcing a GameObject to follow a single rigid sequence of locations, we can make things more flexible by defining a <code class="literal">WayPoint</code> class, whereby each waypoint GameObject has an array<a id="id908" class="indexterm"></a> of possible destinations, and each of these has its own array and so on. In this way<a id="id909" class="indexterm"></a> a <span class="strong"><strong>di-graph</strong></span> (<span class="strong"><strong>directed graph</strong></span>) can be implemented, of which a linear sequence is just one possible instance.</p><p>To improve our game to work with a di-graph of waypoints, do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Remove the scripted <code class="literal">WayPointManager</code> component from the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject.</p></li><li><p>Replace the C# script class called <code class="literal">ArrowNPCMovement</code> with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ArrowNPCMovement : MonoBehaviour {
  public Waypoint waypoint;
  private bool firstWayPoint = true;
  private NavMeshAgent navMeshAgent;

  void Start (){
    navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();
    HeadForNextWayPoint();
  }

  void Update () {
    float closeToDestinaton = navMeshAgent.stoppingDistance * 2;
    if (navMeshAgent.remainingDistance &lt; closeToDestinaton){
      HeadForNextWayPoint ();
    }
  }

  private void HeadForNextWayPoint (){
    if(firstWayPoint)
      firstWayPoint = false;
    else
      waypoint = waypoint.GetNextWaypoint();

    Vector3 target = waypoint.transform.position;
    navMeshAgent.SetDestination (target);
  }
}</pre></div></li><li><p>Create a new C# script class called <code class="literal">WayPoint</code> with the following code:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Waypoint: MonoBehaviour {
  public Waypoint[] waypoints;

  public Waypoint GetNextWaypoint () {
    return waypoints[ Random.Range(0, waypoints.Length) ];
  }
}</pre></div></li><li><p>Select all the six GameObjects called <span class="strong"><strong>Capsule-waypoint -0</strong></span>/<span class="strong"><strong>1</strong></span>/<span class="strong"><strong>2</strong></span>/<span class="strong"><strong>3</strong></span>/<span class="strong"><strong>4</strong></span>/<span class="strong"><strong>5,</strong></span> and add to them a scripted instance of C# class called <code class="literal">WayPoint</code>.</p></li><li><p>Select the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject and add to it a scripted instance of C# class called <code class="literal">WayPoint</code>.</p></li><li><p>Ensure that the <span class="strong"><strong>Sphere-arrow</strong></span> GameObject is selected: in the <span class="strong"><strong>Inspector</strong></span> panel for the <code class="literal">ArrowNPCMovement</code> scripted component drag <span class="strong"><strong>Capsule-waypoint-0</strong></span> into the <span class="strong"><strong>Waypoint</strong></span> public variable slot.</p></li><li><p>Now, we need to link <span class="strong"><strong>Capsule-waypoint-0</strong></span> to <span class="strong"><strong>Capsule-waypoint-1</strong></span>, <span class="strong"><strong>Capsule-waypoint-1</strong></span> to <span class="strong"><strong>Capsule-waypoint -2</strong></span>, and so on. Select <span class="strong"><strong>Capsule-waypoint-0</strong></span>, set its <code class="literal">Waypoints</code> array size to <code class="literal">1</code>, and drag in <span class="strong"><strong>Capsule-waypoint-1</strong></span>. Next, select <span class="strong"><strong>Capsule-waypoint-1</strong></span>, set its <span class="strong"><strong>Waypoints</strong></span> array size to 1, and drag in <span class="strong"><strong>Capsule-waypoint-2</strong></span>. Do the following until you finally link <span class="strong"><strong>Capsule-waypoint-5</strong></span> back to <span class="strong"><strong>Capsule-waypoint-0</strong></span>.</p></li></ol></div><p>You now have a much more flexible game architecture, allowing GameObjects to randomly select one of several different paths at each waypoint reached. In this final recipe variation, we have implemented a waypoint sequence, since each waypoint has an array of just one linked <a id="id910" class="indexterm"></a>waypoint. However, if you change the array size to 2 or more, you will then be creating a graph of linked waypoints, adding random variations in the sequence of waypoints that a computer controlled character follows for any given run of your game.</p></div></div></div>