<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec96"></a>Introduction</h2></div></div><hr /></div><p>For some projects, it works fine to <a id="id1016" class="indexterm"></a>use the <span class="strong"><strong>Inspector</strong></span> window to manually assign imported assets to the component slots, and then build and play the game with no further changes. However, there are also many times when external data of some kind can add flexibility and features to a game. For example, it might add updateable or user-editable content; it can allow memory of user preferences and achievements between scenes, and even game-playing sessions. Using code to read local or Internet file contents at runtime can help file organization and separation of tasks between game programmers and the content designers. Having an arsenal of different assets and long-term game memory techniques means providing a wide range of opportunities to deliver a rich experience to players and developers alike.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec285"></a>The big picture</h3></div></div></div><p>Before getting on with the recipes, let's step back and have a quick review of the role of the asset files and the Unity game building and running process. The most straightforward way to work with assets is to import them into a Unity project, use the <span class="strong"><strong>Inspector</strong></span> window to<a id="id1017" class="indexterm"></a> assign the assets to the components in the <span class="strong"><strong>Inspector</strong></span>, and then build and play the game.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_10_01.jpg" /></div><p>Standalone executables offer another possible workflow, which is the adding of files into the <code class="literal">Resources</code> folder of the game after it has been built. This will support game media asset developers being able to provide the final version of assets after development and building has been completed.</p><p>However, another option is to use<a id="id1018" class="indexterm"></a> the <code class="literal">WWW</code> class to dynamically read assets from the web at runtime; or perhaps, for communication with a high score or multiplayer server, and sending and receiving information and files.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_10_02.jpg" /></div><p>When loading/saving<a id="id1019" class="indexterm"></a> data either locally or via the web interface, it is important to keep in mind the data types that can be used. When writing C# code, our variables can be of any type permitted by the language, but when communicated by the web interface, or to a local <a id="id1020" class="indexterm"></a>storage using Unity's <code class="literal">PlayerPrefs</code> class, we are restricted in the types of data that we can work with. Unity's <code class="literal">WWW</code> class permits three file types (text files, binary audio clips, and binary image textures), but, for example, for 2D UIs we sometimes need Sprite images and not Textures, so that we have provided in this chapter a C# method to create a Sprite from a Texture. When using the <code class="literal">PlayerPrefs</code> class, we are limited to saving and loading integers, floats, and strings. Similarly, when communicating with a web server using the URL encoded data, we are restricted to whatever we can place into strings (we include a PHP web-based high score recipe, where the user scores can be loaded and saved via such a method).</p><p>Finally, managing Unity project <a id="id1021" class="indexterm"></a>source code with an online <span class="strong"><strong>Distributed Version Control System</strong></span> (<span class="strong"><strong>DVCS</strong></span>) like Git and GitHub opens up new workflows for the continuous integration of code updates to the working builds. Unity Cloud will <span class="emphasis"><em>pull</em></span> the updated source code projects from your online repository, and then build the game for designated versions of Unity and the deployment devices. Developers will get e-mails to confirm the build success, or to list the reasons for any build failure. The final two recipes in this chapter show you how to manage your code with Git and GitHub, and<a id="id1022" class="indexterm"></a> use Unity Cloud to build projects for <a id="id1023" class="indexterm"></a>multiple <a id="id1024" class="indexterm"></a>devices.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>
<span class="strong"><strong>Acknowledgement</strong></span>: Thanks<a id="id1025" class="indexterm"></a> to the following<a id="id1026" class="indexterm"></a> for <a id="id1027" class="indexterm"></a>publishing <span class="emphasis"><em>Creative Commons (BY 3.0)</em></span> licensed icons: <span class="strong"><strong>Elegant Themes</strong></span>, <span class="strong"><strong>Picol</strong></span>, <span class="strong"><strong>Freepik</strong></span>, <span class="strong"><strong>Yannick</strong></span>, <span class="strong"><strong>Google</strong></span>, <a class="ulink" href="http://www.flaticon.com" target="_blank">www.flaticon.com</a>.</p></div></div></div>