<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec20"></a>Displaying a radar to indicate the relative locations of objects</h2></div></div><hr /></div><p>A radar displays the<a id="id96" class="indexterm"></a> locations of other objects relative to the player, usually based on a circular display, where the center represents the player, and each graphical 'blip' indicates how far away and what relative direction objects are<a id="id97" class="indexterm"></a> to the player. Sophisticated radar displays will display different categories of objects with different colored or shaped 'blip' icons.</p><p>In the screenshot, we can see 2 red square 'blips', indicating the relative position of the 2 red cube GameObjects tagged <code class="literal">Cube</code> near the player, and a yellow circle 'blip' indicating the relative position of the yellow sphere GameObject tagged <code class="literal">Sphere</code>. The green circle radar background image gives the impression of an aircraft control tower radar or something similar.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_01_21.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec48"></a>Getting ready</h3></div></div></div><p>For this recipe, we<a id="id98" class="indexterm"></a> have prepared the images that you need in a folder named <code class="literal">Images</code> in <code class="literal">1362_01_11</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec49"></a>How to do it...</h3></div></div></div><p>To create a radar to<a id="id99" class="indexterm"></a> show the relative positions of the objects, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new 3D project by importing the following standard assets:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Environment</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Characters</strong></span>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Cameras</strong></span>
</p></li></ul></div></li><li><p>Create a terrain by navigating to the <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Terrain</strong></span> menu.</p></li><li><p>Size the terrain 20 x 20, positioned at (-10, 0, -10)—so that its center is at (0, 0, 0), as shown in the following figure:</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_01_47.jpg" /></div></li><li><p>Texture<a id="id100" class="indexterm"></a> paint your<a id="id101" class="indexterm"></a> terrain with the <span class="strong"><strong>SandAlbedo</strong></span> option, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_01_48.jpg" /></div></li><li><p>From the <span class="strong"><strong>Standard Assets</strong></span> folder in the <span class="strong"><strong>Project</strong></span> panel, drag the prefab <span class="strong"><strong>ThirdPersonController</strong></span> into the scene and position it at (0, 1, 0).</p></li><li><p>Tag this <span class="strong"><strong>ThirdPersonController</strong></span> GameObject called <span class="strong"><strong>Player</strong></span>.</p></li><li><p>Remove the <span class="strong"><strong>Main Camera</strong></span> GameObject.</p></li><li><p>From the <span class="strong"><strong>Standard Assets</strong></span> folder in the <span class="strong"><strong>Project</strong></span> panel, drag the prefab <span class="strong"><strong>Multi-PurposeCameraRig</strong></span> into the scene.</p></li><li><p>With <span class="strong"><strong>Multi-PurposeCameraRig</strong></span> selected in the <span class="strong"><strong>Hierarchy</strong></span>, drag the <span class="strong"><strong>ThirdPersonController</strong></span> GameObject into the <span class="strong"><strong>Target</strong></span> property of the <span class="strong"><strong>Auto Cam (Script)</strong></span> public<a id="id102" class="indexterm"></a> variable in the <span class="strong"><strong>Inspector</strong></span> tab, as shown in the following screenshot: </p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_01_22.jpg" /></div></li><li><p>Import the provided folder known as <code class="literal">Images</code>.</p></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> panel, add a <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>RawImage</strong></span> GameObject to the scene named <span class="strong"><strong>RawImage-radar</strong></span>.</p></li><li><p>Ensure that<a id="id103" class="indexterm"></a> the <span class="strong"><strong>RawImage-radar</strong></span> GameObject is selected in the <span class="strong"><strong>Hierarchy </strong></span>panel. From your <span class="strong"><strong>Project</strong></span> <code class="literal">Images</code> folder, drag the <code class="literal">radarBackground</code> image into the <span class="strong"><strong>Raw Image (Script)</strong></span> public property <span class="strong"><strong>Texture</strong></span>.</p></li><li><p>Now, in <span class="strong"><strong>Rect Transform</strong></span> position <span class="strong"><strong>RawImage-radar</strong></span> at the top-left part using the <span class="strong"><strong>Anchor Presets</strong></span> item. Then set the width and height to 200 pixels.</p></li><li><p>Create another new UI <span class="strong"><strong>RawImage</strong></span> named <span class="strong"><strong>RawImage-blip</strong></span>. Assign the <code class="literal">yellowCircleBlackBorder</code> texture. Tag the <span class="strong"><strong>Blip</strong></span> GameObject.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> panel, create a new empty prefab named <span class="strong"><strong>blip-sphere</strong></span>, and drag the <span class="strong"><strong>RawImage-blip</strong></span> GameObject into this prefab to store all its properties.</p></li><li><p>Now, change the texture of <span class="strong"><strong>RawImage-blip</strong></span> to <code class="literal">redSquareBlackBorder</code>.</p></li><li><p>In the Project panel, create a new empty prefab named <span class="strong"><strong>blip-cube</strong></span>, and drag the <span class="strong"><strong>RawImage-blip</strong></span> GameObject into this prefab to store all its properties. </p></li><li><p>Delete the <span class="strong"><strong>RawImage-blip</strong></span> GameObject from the <span class="strong"><strong>Hierarchy</strong></span> panel.</p></li><li><p>Create a C# script class called <code class="literal">Radar,</code> containing the following code, and add an instance as a<a id="id104" class="indexterm"></a> scripted <a id="id105" class="indexterm"></a>component to the <span class="strong"><strong>RawImage-radar</strong></span> GameObject:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class Radar : MonoBehaviour{
  public float insideRadarDistance = 20;
  public float blipSizePercentage = 5;

  public GameObject rawImageBlipCube;
  public GameObject rawImageBlipSphere;

  private RawImage rawImageRadarBackground;
  private Transform playerTransform;
  private float radarWidth;
  private float radarHeight;
  private float blipHeight;
  private float blipWidth;

  void Start (){
    playerTransform = GameObject.FindGameObjectWithTag("Player").transform;
    rawImageRadarBackground = GetComponent&lt;RawImage&gt;();

    radarWidth = rawImageRadarBackground.rectTransform.rect.width;
    radarHeight = rawImageRadarBackground.rectTransform.rect.height;

    blipHeight = radarHeight * blipSizePercentage/100;
    blipWidth = radarWidth * blipSizePercentage/100;
  }

  void Update (){
    RemoveAllBlips();
    FindAndDisplayBlipsForTag("Cube", rawImageBlipCube);
    FindAndDisplayBlipsForTag("Sphere", rawImageBlipSphere);
  }

  private void FindAndDisplayBlipsForTag(string tag, GameObject prefabBlip){
    Vector3 playerPos = playerTransform.position;
    GameObject[] targets = GameObject.FindGameObjectsWithTag(tag);

    foreach (GameObject target in targets) {
      Vector3 targetPos = target.transform.position;
      float distanceToTarget = Vector3.Distance(targetPos, playerPos);
      if( (distanceToTarget &lt;= insideRadarDistance) ){
        Vector3 normalisedTargetPosiiton = NormalisedPosition(playerPos, targetPos);
        Vector2 blipPosition = CalculateBlipPosition(normalisedTargetPosiiton);
        DrawBlip(blipPosition, prefabBlip);
      }
    }
  }

  private void RemoveAllBlips(){
    GameObject[] blips = GameObject.FindGameObjectsWithTag("Blip");
    foreach (GameObject blip in blips)
      Destroy(blip);
  }

  private Vector3 NormalisedPosition(Vector3 playerPos, Vector3 targetPos){
  float normalisedyTargetX = (targetPos.x - playerPos.x)/insideRadarDistance;
    float normalisedyTargetZ = (targetPos.z - playerPos.z)/insideRadarDistance;
    return new Vector3(normalisedyTargetX, 0, normalisedyTargetZ);
  }

  private Vector2 CalculateBlipPosition(Vector3 targetPos){
    // find angle from player to target
    float angleToTarget = Mathf.Atan2(targetPos.x, targetPos.z) * Mathf.Rad2Deg;

    // direction player facing
    float anglePlayer = playerTransform.eulerAngles.y;

    // subtract player angle, to get relative angle to object
    // subtract 90
    // (so 0 degrees (same direction as player) is UP)
    float angleRadarDegrees =  angleToTarget - anglePlayer - 90;

    // calculate (x,y) position given angle and distance
    float normalisedDistanceToTarget = targetPos.magnitude;
    float angleRadians = angleRadarDegrees * Mathf.Deg2Rad;
    float blipX = normalisedDistanceToTarget * Mathf.Cos(angleRadians);
    float blipY = normalisedDistanceToTarget * Mathf.Sin(angleRadians);

    // scale blip position according to radar size
    blipX *= radarWidth/2;
    blipY *= radarHeight/2;

    // offset blip position relative to radar center
    blipX += radarWidth/2;
    blipY += radarHeight/2;

    return new Vector2(blipX, blipY);
  }

  private void DrawBlip(Vector2 pos, GameObject blipPrefab){
    GameObject blipGO = (GameObject)Instantiate(blipPrefab);
    blipGO.transform.SetParent(transform.parent);
    RectTransform rt = blipGO.GetComponent&lt;RectTransform&gt;();
    rt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Left, pos.x, blipWidth);
    rt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Top, pos.y, blipHeight);
  }
}</pre></div></li><li><p>Create two cubes—tagged <span class="strong"><strong>Cube</strong></span>, textured with a red image called <span class="strong"><strong>icon32_square_red</strong></span>. Position<a id="id106" class="indexterm"></a> each away<a id="id107" class="indexterm"></a> from the player's character. </p></li><li><p>Create a sphere—tagged <span class="strong"><strong>Sphere</strong></span>, textured with a red image called <span class="strong"><strong>icon32_square_yellow</strong></span>. Position this away from the cubes and the player's character.</p></li><li><p>Run your game. You will see two red squares and one yellow circle on the radar, showing the relative positions of the red cubes and yellow sphere. If you move too far away, then the blips will disappear.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>This radar script scans 360 degrees all around the player, and only considers straight line distances in the X-Z plane. So, the distances in this radar are not affected by any height difference between the player and target GameObjects. The script can be adapted to ignore targets whose height is more than some threshold different to the player's height. Also, as presented, this recipe radar <span class="emphasis"><em>sees</em></span> through everything, even if there are obstacles between the player and the target. The recipe can be extended to not show <a id="id108" class="indexterm"></a>obscured targets through the user of the ray-casting techniques. See the Unity scripting reference for more details about ray-casting at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Physics.Raycast.html" target="_blank">http://docs.unity3d.com/ScriptReference/Physics.Raycast.html</a>.</p></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec50"></a>How it works...</h3></div></div></div><p>A radar background<a id="id109" class="indexterm"></a> is displayed on the screen. The center of this circular image represents the position of the player's character. You have created two prefabs; one for red square images to represent each red cube found within the radar distance, and one for yellow circles to represent yellow sphere GameObjects.</p><p>The <code class="literal">Radar</code> C# script class has been added to the radar UI Image GameObject. This class defines four public variables:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">insideRadarDistance</code>: This value defines the maximum distance that an object may be from the player to still be included on the radar (objects further than this distance will not be displayed on the radar).</p></li><li style="list-style-type: disc"><p>
<code class="literal">blipSizePercentage</code>: This public variable allows the developer to decide how large each 'blip' will be, as a proportion of the radar's image.</p></li><li style="list-style-type: disc"><p>
<code class="literal">rawImageBlipCube</code> and <code class="literal">rawImageBlipSphere</code>: These are references to the prefab UI <span class="strong"><strong>RawImages</strong></span> that are to be used to visually indicate the relative distance and position of cubes and spheres on the radar.</p></li></ul></div><p>Since there is a lot happening in the code for this recipe, each method will be described in its own section.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec09"></a>The Start() method</h4></div></div></div><p>The <code class="literal">Start()</code> method caches a reference to the <span class="strong"><strong>Transform</strong></span> component of the player's character (tagged as <span class="strong"><strong>Player</strong></span>). This allows the scripted object to know about the position of the Player's character in <a id="id110" class="indexterm"></a>each frame. Next, the width and height of the radar image are cached—so, the relative positions for 'blips' can be <a id="id111" class="indexterm"></a>calculated, based on the size of this background radar image. Finally, the size of each blip (width and height) is calculated, using the <code class="literal">blipSizePercentage</code> public variable.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec10"></a>The Update() method</h4></div></div></div><p>The <code class="literal">Update()</code> method calls<a id="id112" class="indexterm"></a> the <code class="literal">RemoveAllBlips()</code> method, which removes any old <span class="strong"><strong>RawImage</strong></span> UI GameObjects of cubes and spheres that<a id="id113" class="indexterm"></a> might currently be displayed.</p><p>Next, the <code class="literal">FindAndDisplayBlipsForTag(…)</code>method is called twice. First, for the objects tagged <span class="strong"><strong>Cube</strong></span>, to be represented on the radar with the <code class="literal">rawImageBlipCube</code> prefab and then again for objects tagged <span class="strong"><strong>Sphere</strong></span>, to be represented on the radar with the <code class="literal">rawImageBlipSphere</code> prefab. As you might expect, most of the hard work for the radar is to be performed by the <code class="literal">FindAndDisplayBlipsForTag(…)</code> method.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec11"></a>The FindAndDisplayBlipsForTag(…) method</h4></div></div></div><p>This method inputs two parameters: the string tag for the objects to be searched for; and a reference to the <span class="strong"><strong>RawImage</strong></span> prefab to be displayed on the radar for any such tagged objects within the range.</p><p>First, the current<a id="id114" class="indexterm"></a> position of the player's character is retrieved from the cached player transform variable. Next, an array is constructed, referring to all GameObjects in the scene that have the provided tag. This array of GameObjects is looped through, and for each GameObject, the <a id="id115" class="indexterm"></a>following actions are performed:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The position of the target GameObject is retrieved</p></li><li style="list-style-type: disc"><p>The distance from this target position to the player's position is calculated, and if this distance is within the range (less than or equal to <code class="literal">insideRadarDistance</code>), then three steps are now required to get the blip for this object to appear on the radar:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The normalized position of the target is calculated by calling <code class="literal">NormalisedPosition(…)</code>
</p></li><li style="list-style-type: disc"><p>The position of the blip on the radar is then calculated from this normalized position by calling <code class="literal">CalculateBlipPosition(…)</code>
</p></li><li style="list-style-type: disc"><p>Finally, the <span class="strong"><strong>RawImage</strong></span> blip is displayed by calling <code class="literal">DrawBlip(…)</code> and passing<a id="id116" class="indexterm"></a> the blip position and the reference to the <span class="strong"><strong>RawImage</strong></span> prefab that is to be<a id="id117" class="indexterm"></a> created there</p></li></ul></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec12"></a>The NormalisedPosition(…) method</h4></div></div></div><p>The <code class="literal">NormalisedPosition(…)</code> method inputs the player's character position and the target GameObject position. It has the goal of outputting the relative position of the target to the player, returning a Vector3 object with a triplet of <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>, and <span class="emphasis"><em>Z</em></span> values. Note that since the radar is only 2D, we<a id="id118" class="indexterm"></a> ignore the <span class="emphasis"><em>Y</em></span>value of target GameObjects. So, the <span class="emphasis"><em>Y</em></span>value of the Vector3 object returned by this method will always be 0. So, for example, if a target was at exactly the same location as the player, the returned <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>, <span class="emphasis"><em>Z</em></span> Vector3 object would be (0, 0, 0).</p><p>Since we know<a id="id119" class="indexterm"></a> that the target GameObject is no further from the player's character than <code class="literal">insideRadarDistance</code>, we can calculate a value in the -1 … 0 … +1 range for the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> axis by finding the distance on each axis from the target to the player, and then dividing it by <code class="literal">insideRadarDistance</code>. An <span class="emphasis"><em>X</em></span> value of -1 means that the target is fully to the left of the player (at a distance that is equal to <code class="literal">insideRadarDistance</code>), and +1 means it is fully to the right. A value of 0 means that the target has the same <span class="emphasis"><em>X</em></span> position as the player's character. Likewise, for -1 … 0 … +1 values in the <span class="emphasis"><em>Z-axis</em></span> (this axis represents how far, in front or behind us an object, is located, which will be mapped to the vertical axis in our radar).</p><p>Finally, this method constructs and returns a new Vector3 object, with the calculated <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z </em></span>normalized values, and a <span class="emphasis"><em>Y</em></span> value of zero.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>
<span class="strong"><strong>The normalized position</strong></span>
</p><p>A <span class="emphasis"><em>normalized</em></span> value is one that has been simplified in some way, so the context has been abstracted away. In<a id="id120" class="indexterm"></a> this recipe, what we are interested in is where an object is relative to the player. So, our normal form is to get a value of the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> position of a target in the -1 to +1 range for each axis. Since we are only considering GameObject within out <code class="literal">insideRadarDistance</code> value, we can map these normalized target positions directly onto the location of the radar image in our UI.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec13"></a>The CalculateBlipPosition(…) method</h4></div></div></div><p>First, we<a id="id121" class="indexterm"></a> calculate <code class="literal">angleToTarget</code>: the angle from (0, 0, 0) to our normalized target position.</p><p>Next, we calculate <code class="literal">anglePlayer</code>: the angle the player's character is facing. This recipe makes use of the <span class="strong"><strong>yaw</strong></span> angle of the rotation, which is the rotation about the <span class="emphasis"><em>Y-axis</em></span>—that is, the direction that a character <a id="id122" class="indexterm"></a>controller is facing. This can be found in the <span class="emphasis"><em>Y</em></span> component of a GameObject's <code class="literal">eulerAngles</code> component of its transform. You can imagine looking from above and down at the character controller, and see what direction they are facing—this is just what we are trying to display graphically with<a id="id123" class="indexterm"></a> the compass.</p><p>Our desired radar angle (the <code class="literal">angleRadarDegrees</code> variable) is calculated by subtracting the player's direction angle from the angle between target and player, since a radar displays the relative angle from the direction that the player is facing, to the target object. In mathematics, an angle of zero indicates an <span class="emphasis"><em>east</em></span> direction. To correct this, we need to also subtract 90 degrees from the angle.</p><p>The angle is then<a id="id124" class="indexterm"></a> converted into radians, since this is required for the Unity trigonometry methods. We then multiply the <code class="literal">Sin()</code> and <code class="literal">Cos()</code> results by our normalized distances to calculate the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> values respectively (see the following figure):</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_01_46.jpg" /></div><p>Our final position values need to be expressed as pixel lengths, relative to the center of the radar. So, we multiply our <code class="literal">blipX</code> and <code class="literal">blipY</code> values by half the width and the height of the radar; note that we multiply only with half the width, since these values are relative to the center of the radar.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"></a>Note</h3><p>Note: In this figure, alpha is the angle between player and target object, 'a' is the adjacent side, 'h' is the hypotenuse and 'o' is the side opposite the angle.</p></div><p>We then add half the width and height of the radar image to the <code class="literal">blipX</code>/<code class="literal">Y</code> values. So, these values are now positioned relative to the center.</p><p>Finally a new <span class="strong"><strong>Vector2</strong></span> object is created and returned, passing back these final calculated <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> pixel values for<a id="id125" class="indexterm"></a> the position of our blip icon.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec14"></a>The DrawBlip() method</h4></div></div></div><p>The <code class="literal">DrawBlip()</code> method takes the input parameters of the position of the blip (as a <code class="literal">Vector2</code> <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span> pair), and the reference<a id="id126" class="indexterm"></a> to the <span class="strong"><strong>RawImage</strong></span> prefab to be created at that location on the radar.</p><p>A new GameObject is<a id="id127" class="indexterm"></a> created from the prefab, and is parented to the radar GameObject (of which the scripted object is also a component). A reference is retrieved to the <span class="strong"><strong>Rect Transform</strong></span> of the new <span class="strong"><strong>RawImage</strong></span> GameObject that has been created for the 'blip'. Calls to the Unity <span class="strong"><strong>RectTransform</strong></span> method, <code class="literal">SetInsetAndSizeFromParentEdge(…),</code> result in the blip GameObject being positioned at the provided horizontal and vertical locations over the radar image, regardless of where in the <span class="strong"><strong>Game</strong></span> panel the background radar image has been located.</p></div></div></div>