<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec107"></a>Introduction</h2></div></div><hr /></div><p>The first three recipes in this chapter provide some ideas for adding some extra features to your game (pausing, slow motion, and securing online games). The next two recipes then present ways to manage complexity in your games through managing states and their transitions.</p><p>The rest of the recipes in this chapter provide examples of how to investigate and improve the efficiency and performance of your game. Each of these optimization recipes begins by stating an optimization principle that it embodies.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec332"></a>The big picture</h3></div></div></div><p>Before getting on with<a id="id1163" class="indexterm"></a> the recipes, let's step back and think about the different parts of Unity games and how their construction and runtime behavior can impact on game performance.</p><p>Games are made up of several different kinds of components:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Audio assets</p></li><li style="list-style-type: disc"><p>2D and 3D graphical assets</p></li><li style="list-style-type: disc"><p>Text and other file assets</p></li><li style="list-style-type: disc"><p>Scripts</p></li></ul></div><p>When a game is running, there are many competing processing requirements for your CPU and GPU, including:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Audio processing</p></li><li style="list-style-type: disc"><p>Script processing</p></li><li style="list-style-type: disc"><p>2D physics processing</p></li><li style="list-style-type: disc"><p>3D physics processing</p></li><li style="list-style-type: disc"><p>Graphical rendering</p></li><li style="list-style-type: disc"><p>GPU processing</p></li></ul></div><p>One way to reduce the complexity of graphical computations and to improve frame rates is to use simpler models whenever possible—this is the reduction of the <span class="strong"><strong>Level Of Detail</strong></span> (<span class="strong"><strong>LOD</strong></span>). The general strategy is to identify situations where a simpler model will not degrade the user's experience. Typically, situations include where a model is only taking up a small part of the screen (so less detail in the model will not change what the user sees), when objects are moving very fast across the screen (so the user is unlikely to have time to notice less detail), or where we are sure the users' visual focus is elsewhere (for example, in a car racing game, the user is not looking at the quality of the trees but on the road ahead). We provide a LOD recipe, <span class="emphasis"><em>Improving performance with LOD groups</em></span>, in this chapter.</p><p>Unity's draw call batching may actually be <span class="emphasis"><em>more efficient</em></span> than you or your team's 3D modelers are at reducing the triangle/vertex geometry. So, it may be that by manually simplifying a 3D model, you have removed Unity's opportunity to apply its highly effective vertex reduction algorithms; then, the geometric complexity may be larger for a small model than for a larger model, and so a smaller model may lead to a lower game performance! One<a id="id1164" class="indexterm"></a> recipe presents advice collected from several sources and the location of tools to assist in different strategies to try to reduce draw calls and improve graphical performance.</p><p>We will present several recipes allowing you to analyze actual processing times and frame rates, so that you can collect data to confirm whether your design decisions are having the desired efficiency improvements.</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p><span class="emphasis"><em>"You have a limited CPU budget and you have to live with it"</em></span></p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution"><span class="emphasis"><em>Joachim Ante, Unite-07</em></span></span></td></tr></table></div><p>At the end of the day, the best <span class="emphasis"><em>balance</em></span> of heuristic strategies for your particular game project can only be discovered by an investment of time and hard work, and some form of profiling investigation. Certain strategies (such as caching to reduce component reflection lookups) should perhaps be standard practice in all projects, while other strategies may require <span class="emphasis"><em>tweaking</em></span> for each unique game and level, to find which approaches work effectively to improve efficiency, frame rates, and, most importantly, the user experience when playing the game.</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"Premature Optimization is the root of all evil"</em></span></p><p><span class="emphasis"><em>Donald Knuth, "Structured Programming With Go To Statements". Computing Surveys, Vol 6, No 4, December 1974</em></span></p></blockquote></div><p>Perhaps, the core strategy to take away from this chapter is that there are many parts of a game that are candidates for possible optimization, and you should drive the actual optimizations you finally implement for a particular game based on the evidence you gain by profiling its performance.</p></div></div>