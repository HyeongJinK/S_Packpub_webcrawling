<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec82"></a>Choosing destinations – find the nearest (or a random) spawn point</h2></div></div><hr /></div><p>Many games make use of spawn points and waypoints. This recipe demonstrates two very common examples of spawning—the choosing of either a random spawn point, or the nearest one to<a id="id857" class="indexterm"></a> an object of interest (such as the Player's character), and then the instantiation of an object at that chosen point.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec234"></a>Getting ready</h3></div></div></div><p>This recipe builds upon the previous recipe. So, make a copy of this project, open it, and then follow the next steps.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec235"></a>How to do it...</h3></div></div></div><p>To find a random <a id="id858" class="indexterm"></a>spawn point, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a <span class="strong"><strong>Sphere</strong></span> sized as (1,1,1) at (2,2,2) position, and apply the <code class="literal">m_red</code> Material.</p></li><li><p>Create a new Prefab named <code class="literal">Prefab-ball</code>, and drag your <span class="strong"><strong>Sphere</strong></span> into it (and then delete the <span class="strong"><strong>Sphere</strong></span> from the <span class="strong"><strong>Hierarchy</strong></span> panel).</p></li><li><p>Create a new capsule object named <code class="literal">Capsule-spawnPoint</code> at (3, 0.5, 3), give it the tag as <code class="literal">Respawn</code> (this is one of the default tags that Unity provides).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p>For testing, we'll leave these Respawn points visible. For the final game, we'll then uncheck the Mesh Rendered of each Respawn GameObject, so that they are not visible to the Player.</p></div></li><li><p>Make<a id="id859" class="indexterm"></a> several copies of your <span class="strong"><strong>Capsule-spawnPoint</strong></span> by moving them to different locations on the terrain.</p></li><li><p>Add an<a id="id860" class="indexterm"></a> instance of the following C# script class called <code class="literal">SpawnBall</code> to the <span class="strong"><strong>Cube-the player</strong></span> GameObject:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class SpawnBall : MonoBehaviour {
  public GameObject prefabBall;
  private SpawnPointManager spawnPointManager;
  private float destroyAfterDelay = 1;
  private float testFireKeyDelay = 0;

  void Start (){
    spawnPointManager = GetComponent&lt;SpawnPointManager&gt; ();
    StartCoroutine("CheckFireKeyAfterShortDelay");
  }

  IEnumerator CheckFireKeyAfterShortDelay () {
    while(true){
      yield return new WaitForSeconds(testFireKeyDelay);
      // having waited, now we check every frame
      testFireKeyDelay = 0; 
      CheckFireKey();
    }
  }

  private void CheckFireKey() {
    if(Input.GetButton("Fire1")){
      CreateSphere();
      // wait half-second before alling next spawn
      testFireKeyDelay = 0.5f;
    }
  }

  private void CreateSphere(){
    GameObject spawnPoint = spawnPointManager.RandomSpawnPoint ();
    GameObject newBall = (GameObject)Instantiate (prefabBall, spawnPoint.transform.position, Quaternion.identity);
    Destroy(newBall, destroyAfterDelay);
  }
}</pre></div></li><li><p>Add an<a id="id861" class="indexterm"></a> instance of the following C# script class called <code class="literal">SpawnPointManager</code> to the <code class="literal">Cube-player</code> GameObject:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class SpawnPointManager : MonoBehaviour {
  private GameObject[] spawnPoints;

  void Start() {
    spawnPoints = GameObject.FindGameObjectsWithTag("Respawn");
  }

  public GameObject RandomSpawnPoint (){
    int r = Random.Range(0, spawnPoints.Length);
    return spawnPoints[r];
  }
}</pre></div></li><li><p>Ensure<a id="id862" class="indexterm"></a> that <span class="strong"><strong>Cube-player</strong></span> is selected in the <span class="strong"><strong>Inspector</strong></span> for the <code class="literal">SpawnBall</code> scripted component. Then, drag <span class="strong"><strong>Prefab-ball</strong></span> over the public variable projectile called <span class="strong"><strong>Prefab Ball</strong></span>.</p></li><li><p>Now, run your game. When you click on the mouse (fire) button, a sphere will be instantiated randomly to one of the capsule locations.</p><div class="mediaobject"><img src="/graphics/9781784391362/graphics/1362OT_08_04.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec236"></a>How it works...</h3></div></div></div><p>The <span class="strong"><strong>Capsule-spawnPoint</strong></span> objects<a id="id863" class="indexterm"></a> represent candidate locations, where we might wish to create an instance of our ball Prefab. When our <code class="literal">SpawnPointManager</code> object, inside the <span class="strong"><strong>Cube-player</strong></span> GameObject, receives the <code class="literal">Start()</code> message, the <span class="strong"><strong>respawns</strong></span> GameObject array is set to the array, which is returned from the call to <code class="literal">FindGameObjectsWithTag("Respawn")</code>. This creates an array of all the objects in the scene with the tag called <code class="literal">Respawn</code> — that is, all our <span class="strong"><strong>Capsule-spawnPoint</strong></span> objects.</p><p>When our<a id="id864" class="indexterm"></a> <code class="literal">SpawnBall</code> object GameObject <span class="strong"><strong>Cube-player</strong></span> receives the <code class="literal">Start()</code> message, it sets the <code class="literal">spawnPointManager</code> variable to be a reference to its sibling <code class="literal">SpawnPointManager</code> script component. Next, we start the <span class="strong"><strong>coroutine</strong></span> method called <a id="id865" class="indexterm"></a>
<code class="literal">CheckFireKeyAfterShortDelay()</code>.</p><p>The <code class="literal">CheckFireKeyAfterShortDelay()</code> method uses a typical Unity coroutine technique that goes into an infinite loop using a delay controlled by the value of the <code class="literal">testFireKeyDelay</code> variable. The delay is to make Unity wait before calling <code class="literal">CheckFireKey()</code> to test if the user wants a new sphere to be spawned.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip09"></a>Tip</h3><p>Coroutines are an advanced technique, where execution inside the method can be paused, and resumed from the same point. The <code class="literal">Yield</code> command temporarily halts the execution of code in the method, allowing Unity to go off and execute code in the other GameObjects and undertake physics and rendering work and more. They are perfect for situations where, at regular intervals, we wish to check whether something has happened (such as testing for the Fire key, or whether a response message has been received from an Internet request and so on).</p><p>Learn more<a id="id866" class="indexterm"></a> about the Unity coroutines at <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html" target="_blank">http://docs.unity3d.com/Manual/Coroutines.html</a>.</p></div><p>The <code class="literal">SpawnBall</code> method <code class="literal">CheckFireKey()</code> tests whether, at that instant, the user is pressing the <span class="strong"><strong>Fire</strong></span> button. If the <span class="strong"><strong>Fire</strong></span> button is pressed, then the <code class="literal">CreateSphere()</code>method is called. Also, the <code class="literal">testFireKeyDelay</code> variable is set to 0.5. This ensures that we won't test the <span class="strong"><strong>Fire</strong></span> button again for half a second.</p><p>The<a id="id867" class="indexterm"></a> <code class="literal">SpawnBall</code> method <code class="literal">CreateSphere()</code>assigns variable <code class="literal">spawnPoint</code> to the <code class="literal">GameObject</code> returned by a call to the <code class="literal">RandomSpawnpoint(…)</code> method of our <code class="literal">spawnPointManager</code>. Then it creates a new instance of <code class="literal">prefab_Ball</code> (via the public variable) at the same position as the <code class="literal">spawnPoint</code> GameObject.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec237"></a>There's more...</h3></div></div></div><p>There are some details that you don't want to miss.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec56"></a>Choosing the nearest spawn point</h4></div></div></div><p>Rather than just choosing a random spawn point, let's search through array spawnpoints, and choose the closest one to our player.</p><p>To find the nearest<a id="id868" class="indexterm"></a> spawn point, we need to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Add the following method to the C# script class called <code class="literal">SpawnPointManager</code>:</p><div class="informalexample"><pre class="programlisting">public GameObject NearestSpawnpoint (Vector3 source){
  GameObject nearestSpawnPoint = spawnPoints[0];
  Vector3 spawnPointPos = spawnPoints[0].transform.position;
  float shortestDistance = Vector3.Distance(source, spawnPointPos);

  for (int i = 1; i &lt; spawnPoints.Length; i++){
    spawnPointPos = spawnPoints[i].transform.position;
    float newDist = Vector3.Distance(source, spawnPointPos);
    if (newDist &lt; shortestDistance){
      shortestDistance = newDist;
      nearestSpawnPoint = spawnPoints[i];
    }
  }

  return nearestSpawnPoint;
}</pre></div></li><li><p>We now need to change the first line in the C# class called <code class="literal">SpawnBall</code> so that the <code class="literal">spawnPoint</code> variable is set by a call to our new method called <code class="literal">NearestSpawnpoint(…)</code>:</p><div class="informalexample"><pre class="programlisting">private void CreateSphere(){
  GameObject spawnPoint = spawnPointManager.NearestSpawnpoint(transform.position);

  GameObject newBall = (GameObject)Instantiate (prefabBall, spawnPoint.transform.position, Quaternion.identity);
  Destroy(newBall, lifeDuration);
}</pre></div></li></ol></div><p>In the <code class="literal">NearestSpawnpoint(…)</code> method, we set <code class="literal">nearestSpawnpoint</code> to the first (array index 0) GameObject in the array as our default. We then loop through the rest of the array (array index 1 up to <code class="literal">spawnPoints.Length</code>). For each GameObject in the array, we test to see if its distance is less than the shortest distance so far, and if it is, then we update the shortest<a id="id869" class="indexterm"></a> distance, and also set <code class="literal">nearestSpawnpoint </code>to the current element. When the array has been searched, we return the GameObject that the <code class="literal">nearestSpawnpoint</code> variable refers to.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec57"></a>Avoiding errors due to an empty array</h4></div></div></div><p>Let's make our code a little <a id="id870" class="indexterm"></a>more robust, so that it can cope with the issue of an empty <code class="literal">spawnPoints</code> array—that is, when there are no objects tagged <span class="strong"><strong>Respawn</strong></span> in the scene.</p><p>To cope with the no objects tagged <span class="strong"><strong>Respawn</strong></span> we need to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Improve our <code class="literal">Start()</code> method in the C# script class called <code class="literal">SpawnPointManager</code>, so that an ERROR is logged if the array of objects tagged <span class="strong"><strong>Respawn</strong></span> is empty:</p><div class="informalexample"><pre class="programlisting">public GameObject NearestSpawnpoint (Vector3 source){
void Start() {
  spawnPoints = GameObject.FindGameObjectsWithTag("Respawn");

  // logError if array empty
  if(spawnPoints.Length &lt; 1) Debug.LogError ("SpawnPointManagaer - cannot find any objects tagged 'Respawn'!");
}</pre></div></li><li><p>Improve the <code class="literal">RandomSpawnPoint()</code> and <code class="literal">NearestSpawnpoint()</code>methods in the C# script class called <code class="literal">SpawnPointManager</code>, so that they still return a GameObject even if the array is empty:</p><div class="informalexample"><pre class="programlisting">public GameObject RandomSpawnPoint (){
  // return current GameObject if array empty
  if(spawnPoints.Length &lt; 1) return null;

// the rest as before ...</pre></div></li><li><p>Improve the<a id="id871" class="indexterm"></a> <code class="literal">CreateSphere()</code>method in the C# class called <code class="literal">SpawnBall</code>, so that we only attempt to instantiate a new GameObject if the <code class="literal">RandomSpawnPoint()</code> and <code class="literal">NearestSpawnpoint()</code>methods have returned a non-null object reference:</p><div class="informalexample"><pre class="programlisting">private void CreateSphere(){
  GameObject spawnPoint = spawnPointManager.RandomSpawnPoint ();

  if(spawnPoint){
    GameObject newBall = (GameObject)Instantiate (prefabBall, spawnPoint.transform.position, Quaternion.identity);
    Destroy(newBall, destroyAfterDelay);
  }
}</pre></div></li></ol></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec238"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The same techniques and code can be used for selecting spawn points or waypoints. Refer to the <span class="emphasis"><em>NPC NavMeshAgent control to follow waypoints in sequence</em></span> recipe in this chapter for more information about waypoints.</p></li></ul></div></div></div>