<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec28"></a>Developing an optimized application and game</h2></div></div><hr /></div><p>Performance<a id="id304" class="indexterm"></a> is a critical factor for games and applications, and for a fast-paced action game, it becomes the key point. For those features where fast Physics combined with fully animated characters and a 3D world are required, performance optimization is the most important factor. Any game or application <a id="id305" class="indexterm"></a>needs 60 frames per seconds of performance, and so we will need to optimize our game for target devices to achieve that.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec28"></a>Checking performance</h3></div></div></div><p>
<span class="strong"><strong>Unity Profiler</strong></span> is the first thing that we should use to check the performance of a game or application. Profiler is a great tool that comes with Unity Pro, using which we determine where <a id="id306" class="indexterm"></a>any<a id="id307" class="indexterm"></a> frame rate issues are coming from.</p><p>Profiler<a id="id308" class="indexterm"></a> uses a graph to show the CPU usage while we play the game. Profiler is divided in categorizes such as <span class="strong"><strong>Rendering</strong></span>, <span class="strong"><strong>Scripts</strong></span>, <span class="strong"><strong>Physics</strong></span>, <span class="strong"><strong>Garbage</strong></span> <span class="strong"><strong>Collector</strong></span>, <span class="strong"><strong>VSync</strong></span>, and others. This is how it looks:</p><div class="mediaobject"><img src="/graphics/9781783553693/graphics/3693OT_07_01.jpg" /></div><p>Now, let's see how we handle optimization during the Physics implementation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec29"></a>Moving static colliders</h3></div></div></div><p>To make less expensive performance, we should avoid moving static colliders. You learned in previous<a id="id309" class="indexterm"></a> chapters that a static collider is a game object with a collider component on it; however, it does not have a Rigidbody component. Moving static colliders is one of the top causes of performance issues in Unity games and it is expensive. If we need to create them with codes, we should add the collider and Physic Materials <span class="emphasis"><em>after</em></span> its positioning.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec30"></a>Mesh Colliders</h3></div></div></div><p>
<span class="strong"><strong>Mesh Colliders</strong></span>
<a id="id310" class="indexterm"></a> are slow compared to the <a id="id311" class="indexterm"></a>primitive Box/Sphere Collider. A sphere has many more vertices than a cube but the uniform distance from the center makes the calculation <a id="id312" class="indexterm"></a>much easier in comparison to the many individual triangles. Mesh colliders have a much higher performance overhead than primitive colliders.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec31"></a>The complex collider shape</h3></div></div></div><p>To get better performance for more complex shapes, we should combine primitive colliders. Let's have a look at an example. If we have a parent object with a Box Collider and <a id="id313" class="indexterm"></a>Rigidbody component, we should add child objects with just a Box Collider. The collision for an entire object will have one multipart object. Rather than having several objects linked together, we can add more child objects with Rigidbodies and colliders and use joints to connect them to the parent object. As shown in the following screenshot, we used a Capsule Collider for the complex object:</p><div class="mediaobject"><img src="/graphics/9781783553693/graphics/3693OT_07_02.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec32"></a>Rigidbodies</h3></div></div></div><p>Less use of Rigidbodies and materials saves performance. Again, the use of interpolation and <a id="id314" class="indexterm"></a>extrapolation on Rigidbodies is discouraged all together. The total amount of Physics calculation depends on the number of nonsleeping Rigidbodies and colliders in the scene and the complexity of the colliders. We should handle performance by reducing calculation as much as possible.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec33"></a>Joints</h3></div></div></div><p>We cannot use multiple basic joints on one game object as it is not supported, but we can use <a id="id315" class="indexterm"></a>multiple configurable joints, which helps a lot in performance optimization. Rather than having a network of joint objects, we should use configurable joints wherever possible to avoid unnecessary memory consumption.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec34"></a>The Cloth component</h3></div></div></div><p>The use<a id="id316" class="indexterm"></a> of multiple Cloth components in one game is very expensive so should minimize the use of multiple Cloth components.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec35"></a>Lower timestep</h3></div></div></div><p>A lower frame rate gives breathing room and helps in memory optimization. I personally find<a id="id317" class="indexterm"></a> a 0.03 fixed timestep with a maximum of about 0.05 to be good for better performance. We can reduce the time spent on Physics updates by adjusting the fixed timestep setting. Increasing the timestep will reduce the CPU overhead but sometimes, the accuracy of Physics gets affected.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec36"></a>Precalculation</h3></div></div></div><p>Precalculation<a id="id318" class="indexterm"></a> during development can be very important to achieve high performance and make certain effects possible. Taking the approach of calculating as much as possible at the start of execution can have a great impact on performance.</p><p>Apart from Physics-based performance optimizations, there are other factors too that we should use to optimize our game or app. Let's have a few examples.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec37"></a>Optimizing graphics</h3></div></div></div><p>Performance optimization depends upon how fast we can render by GPU, which is mostly <a id="id319" class="indexterm"></a>limited by the number of pixels rendered and by the memory bandwidth. The CPU performance is also limited by the amount of draw calls processed. We can use GPU Profiler to find out how much time and how many draw calls are in the scene. To save rendering time, we should remove as many draw calls as possible.</p><p>As shown in the following screenshot, by clicking on <span class="strong"><strong>Stats</strong></span>, we can see the <span class="strong"><strong>Statistics</strong></span> window:</p><div class="mediaobject"><img src="/graphics/9781783553693/graphics/3693OT_07_03.jpg" /></div><p>To <a id="id320" class="indexterm"></a>improve CPU performance, we should take into account the following points:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>For high performance, don't use more than a few hundred draw calls per frame while draw call counts vary for older devices</p></li><li style="list-style-type: disc"><p>By combining nearby objects into single meshes, we can reduce draw calls</p></li><li style="list-style-type: disc"><p>By using automatically Unity's draw call batching, we can reduce draw calls</p></li><li style="list-style-type: disc"><p>Using fewer different materials enables better batching of meshes</p></li><li style="list-style-type: disc"><p>By <a id="id321" class="indexterm"></a>using a textures atlas where possible, we can reduce draw calls</p></li></ul></div><p>To improve GPU performance, we should note the following points:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>By reducing the texture quality in the <span class="strong"><strong>Quality</strong></span> settings, we can make the game run faster; we limit memory bandwidth by applying this</p></li><li style="list-style-type: disc"><p>We can reduce shader complexity using mobile GPUs and <a id="id322" class="indexterm"></a>avoid alpha-testing <a id="id323" class="indexterm"></a>shader.</p></li><li style="list-style-type: disc"><p>Use texture compression or 16-bit textures</p></li><li style="list-style-type: disc"><p>Reduce the texture size</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec38"></a>Script call optimization for an iOS build</h3></div></div></div><p>To make a big impact on project completion, from the initial phase of project, we should use slow <a id="id324" class="indexterm"></a>but safe option of <span class="strong"><strong>Script Call Optimization</strong></span>. Using this unhandled exception will crash the Unity build but if handled, we can get a higher performance at the end of the project. To apply this, navigate to the <span class="strong"><strong>Player</strong></span> setting and select <span class="strong"><strong>iOS</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781783553693/graphics/3693OT_07_04.jpg" /></div><p>There are some simple rules for handling performance such as:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Pixel lights are too expensive, so we should avoid them to get high performance</p></li><li style="list-style-type: disc"><p>Keep <a id="id325" class="indexterm"></a>your draw call count low because graphics rendering is CPU expensive</p></li><li style="list-style-type: disc"><p>We should mark the objects that don't move as static</p></li><li style="list-style-type: disc"><p>For moving objects, try to keep the vertex count below 300</p></li><li style="list-style-type: disc"><p>We should avoid instantiating or destroying objects in runtime as the memory is slow</p></li><li style="list-style-type: disc"><p>Avoid alpha because it rejects pixels on iOS devices and it is slow; use alpha blend instead</p></li></ul></div></div></div>