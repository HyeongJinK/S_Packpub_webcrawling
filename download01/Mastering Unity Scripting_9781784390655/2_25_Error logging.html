<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec30"></a>Error logging</h2></div></div><hr /></div><p>When you compile and build your game to distribute to testers, whether they're collected together in an office or scattered across the globe, you'll need a way to record errors and exceptions as and when they happen during gameplay. One way to do this is through logfiles. Logfiles are human-readable text files that are generated on the local computer by the game at runtime, and they record the details of errors as they occur, if any occur at all. The amount of information<a id="id167" class="indexterm"></a> you record is a matter for careful consideration, as logging too much detail can obfuscate the file and too little can render the file useless. However, once a balance is reached the tester will be able to send you the log for inspection, and this will, hopefully, allow you to quickly pin-point errors in your code and repair them effectively, that is without introducing new errors! There are many ways to implement logging behavior in Unity. One way is using the native <code class="literal">Application</code> class to receive exception notifications by way of delegates. Consider the following code sample 2-7:</p><div class="informalexample"><pre class="programlisting"> 01 //------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
<span class="strong"><strong> 04 using System.IO;</strong></span>
 05 //------------------------------------------------
 06 public class ExceptionLogger : MonoBehaviour 
 07 {
 08      //Internal reference to stream writer object
 09      private System.IO.StreamWriter SW;
 10 
 11      //Filename to assign log
 12      public string LogFileName = "log.txt";
 13 
 14      //------------------------------------------------
 15      // Use this for initialization
 16      void Start () 
 17      {
 18             //Make persistent
 19             DontDestroyOnLoad(gameObject);
 20 
 21      //Create string writer object

 22       SW = new System.IO.StreamWriter(Application.persistentDataPath + "/" + LogFileName);

 23 
 24      Debug.Log(Application.persistentDataPath + "/" + LogFileName);

 25       }
 26       //------------------------------------------------
 27      //Register for exception listening, and log exceptions
 28      void OnEnable() 
 29      {
<span class="strong"><strong> 30            Application.RegisterLogCallback(HandleLog);</strong></span>
 31      }
 32      //------------------------------------------------
 33      //Unregister for exception listening
 34      void OnDisable() 
 35      {
 <span class="strong"><strong>36           Application.RegisterLogCallback(null);</strong></span>
 37      }
 38       //------------------------------------------------
 39       //Log exception to a text file

 <span class="strong"><strong>40       void HandleLog(string logString, string stackTrace, LogType type)</strong></span>

 41      {
 42      //If an exception or error, then log to file
 43      if(type == LogType.Exception || type == LogType.Error)
 44             {

 45 <span class="strong"><strong>                 SW.WriteLine</strong></span>("Logged at: " + System.DateTime.Now.ToString() + " - Log Desc: " + logString + " - Trace: " + stackTrace + " - Type: " + type.ToString());

 46             }
 47       }
 48       //------------------------------------------------
 49       //Called when object is destroyed
 50       void OnDestroy()
 51       {
 52             //Close file
 53             SW.Close();
 54       }
 55       //------------------------------------------------
 56 }
 57 //------------------------------------------------</pre></div><p>The following <a id="id168" class="indexterm"></a>are the comments for code sample 2-7:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 22</strong></span>: A new <code class="literal">StreamWriter</code> object is created to write debug strings to a file on the computer. The file is created inside <code class="literal">Application.persistentDataPath</code>; this points to a system location that is always writable.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 30</strong></span>: The <code class="literal">Application.RegisterLogCallBack</code> method is invoked with a function reference to <code class="literal">HandleLog</code> as an argument. This relies on delegates. In short, a reference to the <code class="literal">HandleLog</code> function is passed, and this will be called when an error or exception occurs that allows us to write details to a logfile.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 45</strong></span>: The <code class="literal">WriteLine</code> method of <code class="literal">StreamWriter</code> is called to print textual data to the logfile when an error occurs. The error information is provided by Unity through the <code class="literal">HandleLog</code> arguments: <code class="literal">logString</code>, <code class="literal">stackTrace</code>, and <code class="literal">LogType</code>. The <code class="literal">StreamWriter</code> class is part of the Mono Framework, which is an open source implementation of the Microsoft NET Framework. More information on <code class="literal">StreamWriter</code> can<a id="id169" class="indexterm"></a> be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/system.io.streamwriter%28v=vs.110%29.aspx</a>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Tip</h3><p>One of the quickest ways to test out your error logger is to create a divide by zero error. Don't forget to insert a <code class="literal">Debug.Log (Application.persistentDataPath);</code> line somewhere in your code to print the logfile path to the <span class="strong"><strong>Console</strong></span> window. This can help you quickly find the logfile on your system via Windows Explorer or Mac Finder. Note that the <code class="literal">persistentDataPath</code> variable is used as opposed to an absolute path, because it varies from operating system to operating system.</p></div></li></ul></div><p>The following<a id="id170" class="indexterm"></a> screenshot shows how to print errors to a text-based logfile:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_02_09.jpg" /><div class="caption"><p>Printing errors to a text-based logfile can make debugging and bug fixing easier</p></div></div><p>What are delegates in C#? Imagine that you're able to create a variable and assign it a function reference instead of a regular value. Having done this, you can invoke the variable just like a function to call the referenced function at a later time. You can even reassign the variable to reference a new and different function later. This, in essence, is how delegates work. If you're familiar with C++, delegates are practically equivalent to the function pointers. Thus, delegates are special types that can reference and invoke functions. They're ideal to create extensible callback systems and event notifications. For example, by keeping a list or array of delegate types, potentially, many different classes can register themselves as listeners for callbacks by adding themselves to the list. More information on C# can be<a id="id171" class="indexterm"></a> found at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/ms173171.aspx" target="_blank">http://msdn.microsoft.com/en-gb/library/ms173171.aspx</a>. Consider the following code sample 2-8 for an example of the delegate usage in C# with Unity:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//---------------------------------------------------
public class DelegateUsage : MonoBehaviour 
{
 //Defines delegate type: param list
 public delegate void EventHandler(int Param1, int Param2);
//---------------------------------------------------
//Declare array of references to functions from Delegate type - max 10 events

public EventHandler[] EH = new EventHandler[10];
//---------------------------------------------------
/// &lt;summary&gt;
/// Awake is called before start. Will add my Delegate HandleMyEvent to list
/// &lt;/summary&gt;
void Awake()
{
    //Add my event (HandleMyEvent) to delegate list
    EH[0] = HandleMyEvent;
}
//---------------------------------------------------
/// &lt;summary&gt;
/// Will cycle through delegate list and call all events
/// &lt;/summary&gt;
 void Start()
 {
    //Loop through all delegates in list
    foreach(EventHandler e in EH) 
    {
          //Call event here, if not null
          if(e!=null)
               e(0,0); //This calls the event
    }
 }
//---------------------------------------------------
/// &lt;summary&gt;
/// This is a sample delegate event. Can be referenced by Delegate Type EventHandler
/// &lt;/summary&gt;
/// &lt;param name="Param1"&gt;Example param&lt;/param&gt;
/// &lt;param name="Param2"&gt;Example param&lt;/param&gt;
 void HandleMyEvent (int Param1, int Param2)
 {
    Debug.Log ("Event Called");
 }
//---------------------------------------------------</pre></div></div>