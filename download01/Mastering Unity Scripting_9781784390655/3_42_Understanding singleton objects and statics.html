<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec46"></a>Understanding singleton objects and statics</h2></div></div><hr /></div><p>Some classes are<a id="id284" class="indexterm"></a> fundamentally different from others in the way they should be instantiated. Most classes define a template for a collection of properties and behaviors that might be<a id="id285" class="indexterm"></a> instantiated many times in a scene as <code class="literal">GameObjects</code>. An enemy class can be used to instantiate many enemy objects, a power-up class for many power-up objects, and so on. However, some classes such as <code class="literal">GameManager</code>, <code class="literal">HighScoreManager</code>, <code class="literal">AudioManager</code>, or <code class="literal">SaveGameManager</code> are intended to exist as a lone entity, one that consolidates a unified set of behaviors. In short, there should only ever be one instance of the class at any one time and never more than one. To have more than one instance would either be nonsensical or damage the object's authority and usefulness in some way. These kinds of objects are known as singletons. Singletons are often persistent objects that survive across scenes, though they need not be. The only essential ingredient in a singleton (which makes it what it is) is that there cannot be more than one instance of the class in memory at any one time. Let's now create a singleton object in the context of making a sample <code class="literal">GameManager</code> class.</p><p>Practically, every game has a <code class="literal">GameManager</code> or <code class="literal">GameController</code> class; and these are almost always singleton objects that persist. The <code class="literal">GameManager</code> is essentially responsible for all high-level functionality in a game. It must determine whether a game is paused, whether the win condition has been satisfied, and have a reliable way of knowing what's happening in the game at any one time, among others. Consider the sample beginnings of a <code class="literal">GameManager</code> in the following code sample 3-13:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//-----------------------------------------
//Sample Game Manager class
public class GameManager : MonoBehaviour
{
  //-----------------------------------------
  //High score
  public int HighScore = 0;

  //Is game paused
  public bool IsPaused = false;

  //Is player input allowed
  public bool InputAllowed = true;
  //-----------------------------------------
  // Use this for initialization
  void Start ()
  {
    //Make game manager persistent
    DontDestroyOnLoad(gameObject);
  }
  //-----------------------------------------
}
//-----------------------------------------</pre></div><p>This object will<a id="id286" class="indexterm"></a> persist across scenes, but how can it (or any class like it) become a singleton<a id="id287" class="indexterm"></a> object? The following code sample 3-14 demonstrates how:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------
04 //Sample Game Manager class - Singleton Object
05 public class GameManager : MonoBehaviour
06 {
07   //-----------------------------------------
08   //C# Property to get access to singleton instance
09   //Read only - only has get accessor
10 <span class="strong"><strong>  public static GameManager Instance</strong></span>
11   {
12     //return reference to private instance
13 <span class="strong"><strong>    get</strong></span>
14     {
15       return instance;
16     }
17   }
18
19   //-----------------------------------------
20 <span class="strong"><strong>  private static GameManager instance = null;</strong></span>
21   //-----------------------------------------
22   //High score
23   public int HighScore = 0;
24
25   //Is game paused
26   public bool IsPaused = false;
27
28   //Is player input allowed
29   public bool InputAllowed = true;
30   //-----------------------------------------
31   // Use this for initialization
32   void Awake ()
33   {
34     //Check if existing instance of class exists in scene
35     //If so, then destroy this instance
36 <span class="strong"><strong>    if(instance)</strong></span>
37 <span class="strong"><strong>    {</strong></span>
38 <span class="strong"><strong>      DestroyImmediate(gameObject);</strong></span>
39 <span class="strong"><strong>      return;</strong></span>
40 <span class="strong"><strong>    }</strong></span>
41
42 <span class="strong"><strong>    //Make this active and only instance</strong></span>
43 <span class="strong"><strong>    instance = this;</strong></span>
44
45     //Make game manager persistent
46     DontDestroyOnLoad(gameObject);
47   }
48   //-----------------------------------------
49 }
50 //-----------------------------------------</pre></div><p>The following are the<a id="id288" class="indexterm"></a>  comments on the code sample 3-14:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 10-20</strong></span>: A private member <code class="literal">instance</code> is added to the <code class="literal">Manager</code> class, which is declared as <code class="literal">static</code>. This means the variable is shared across all instances of the class if there are multiple instances, as opposed to being a variable whose value is specific to each instance. This allows each new instance, when created, to <a id="id289" class="indexterm"></a>determine whether there is any existing instance of the class in memory. This variable is made publically accessible too via the <code class="literal">Instance</code> property, which only has a <code class="literal">get</code> member to make it read-only.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 36-43</strong></span>: Here, in the <code class="literal">Awake</code> event (called at object creation), the instance variable is checked to see whether any valid instance of the class exists in the current scene<a id="id290" class="indexterm"></a> already. If it does, then the current object is deleted, because only one instance of this class is allowed and already exists. This means the <code class="literal">GameManager</code> will persist across scene changes, and there will always be only<a id="id291" class="indexterm"></a>  one original instance of the object in the scene.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note21"></a>Note</h3><p>
<span class="strong"><strong>Awake versus Start</strong></span>
</p><p>The <code class="literal">GameManager</code> class uses the <code class="literal">Awake</code> function, as opposed to <code class="literal">Start</code>, in code sample 3-12. The difference between <code class="literal">Start</code> and <code class="literal">Awake</code> is as follows:</p><p>
<code class="literal">Awake</code> is always called before <code class="literal">Start</code>.</p><p>
<code class="literal">Awake</code> is always called at object creation. <code class="literal">Start</code> is called on the first frame in which the <code class="literal">GameObject</code> becomes active. If a <code class="literal">GameObject</code> starts the scene deactivated, then <code class="literal">Start</code>
<a id="id292" class="indexterm"></a> will not be called until the object is activated. For objects that are activated by default, <code class="literal">Start</code> is called at the beginning of the scene, after the <code class="literal">Awake</code> event.</p><p>If you need to cache <a id="id293" class="indexterm"></a>component references into local variables of a class, such as the Transform component in <code class="literal">ThisTransform</code>, then use the <code class="literal">Awake</code> event rather than <code class="literal">Start</code>. During the <code class="literal">Start</code> event, the assumption should be that all local references to objects are already valid.</p></div><p>The great benefit of having a global, static <code class="literal">Instance</code> property for <code class="literal">GameManager</code> is that it becomes instantly and directly accessible to any other script file, without the need for any local variables or object references. This means every class has instant access to all <code class="literal">GameManager</code> properties and can call upon high-order game functionality. For example, to set the game score variable on the <code class="literal">GameManager</code> from a different class, the following code sample 3-15 can be used:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//-------------------------------------------
public class ScoreSetter : MonoBehaviour
{
  //-------------------------------------------
  // Use this for initialization
  void Start ()
  {
    //Set score on GameManager
    GameManager.Instance.HighScore = 100;
  }
  //-------------------------------------------
}
//-------------------------------------------</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip21"></a>Tip</h3><p>More<a id="id294" class="indexterm"></a> information on<a id="id295" class="indexterm"></a> singleton objects can be found online at <a class="ulink" href="http://unitypatterns.com/singletons/" target="_blank">http://unitypatterns.com/singletons/</a>.</p></div></div>