<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec28"></a>Overriding the ToString method</h2></div></div><hr /></div><p>The following code sample 2-3 demonstrates the convenience of the <code class="literal">ToString</code> method when used in conjunction with the <code class="literal">Debug.Log</code> debugging. <code class="literal">ToString</code> lets you convert an object to a human-readable string that can be output to <span class="strong"><strong>Console</strong></span>. In C#, every class inherits the <code class="literal">ToString</code> method<a id="id153" class="indexterm"></a> by default. This means that using inheritance and polymorphism, you can override the <code class="literal">ToString</code> method of your class that customizes it as required and produce a more readable and accurate debug string that represents your class members. Consider the following code sample 2-4 that overrides <code class="literal">ToString</code>. If you get into the habit of overriding <code class="literal">ToString</code> for every class you make, your classes will become easier to debug:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//--------------------------------------------
//Sample enemy Ogre class
public class EnemyOgre : MonoBehaviour 
{
//--------------------------------------------
//Attack types for OGRE
public enum AttackType {PUNCH, MAGIC, SWORD, SPEAR};
 
//Current attack type being used
public AttackType CurrentAttack = AttackType.PUNCH;
 
//Health
public int Health = 100;
 
//Recovery Delay (after attacking)
public float RecoveryTime = 1.0f;
 
//Movement speed of Ogre - metres per second
public float Speed = 1.0f;
 
//Name of Ogre
public string OgreName = "Harry";
//--------------------------------------------
//Override ToString method
<span class="strong"><strong>public override string ToString ()</strong></span>
{
    //Return a string representing the class

          return <span class="strong"><strong>string.Format</strong></span> ("***Class EnemyOgre*** OgreName: {0} | Health: {1} | Speed: {2} | CurrentAttack: {3} | RecoveryTime: {4}", 
          OgreName, Health, Speed, CurrentAttack, RecoveryTime);
}
	
//--------------------------------------------
void Start()
{
 
            Debug.Log (ToString());
}
   //--------------------------------------------
}
//--------------------------------------------</pre></div><p>The output of the <a id="id154" class="indexterm"></a>preceding code can be seen in the <span class="strong"><strong>Console</strong></span> window, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_02_05.jpg" /><div class="caption"><p>Overriding the ToString method to customize debug messages for a class</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>
<span class="strong"><strong>String.Format</strong></span>
</p><p>Line 30 of the code sample 2-3 uses the <a id="id155" class="indexterm"></a>
<code class="literal">String.Format</code> function to build a complete string. This function is useful when you need to make one long string that includes both literal statements and variable values, which could be different types. By inserting the tokens <code class="literal">{0}, {1}, {2}…</code> inside the string argument, the <code class="literal">Format</code> function will <a id="id156" class="indexterm"></a>substitute them for the subsequent function arguments in the order in which they are provided; that is, <code class="literal">String.Format</code> will concatenate your string argument at the location of the tokens, with string versions of your function arguments. Thus, the string <code class="literal">{0}</code> will be replaced with <code class="literal">OgreName.ToString()</code>. For more information on <code class="literal">String.Format</code>, see the <a id="id157" class="indexterm"></a>online documentation at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/system.string.format%28v=vs.110%29.aspx</a>.</p></div><p>You can section off and isolate blocks of code between the release and debug versions that allow you to run debug-specific code when specific flags are enabled. When debugging games, for example, you'll frequently develop two sets or variations of code: the release code and the debug code. Imagine a common scenario where to find and resolve a bug in the code, you resort to inserting the <code class="literal">Debug.Log</code> statements that print out the values of variables and states of classes. You might even insert additional lines, such as <code class="literal">if</code> statements and <a id="id158" class="indexterm"></a>loops, to test out alternative scenarios and explore how objects react. After amending the code for a while, the problem seems repaired, so you remove the additional debug code and continue testing as you did earlier. However, later, you discover that the problem has returned, or a similar one has arisen. So now you wish you'd kept the debug code after all, because it'd be useful again. You might promise yourself that next time, you'll simply comment out the debug code as opposed to deleting it entirely. This will let you simply remove the commenting should the code be needed again. However, of course, having to comment and uncomment code is also tedious, especially if there're many lines, and they are scattered across multiple files and parts of files. You can, however, resolve this problem and similar ones using custom global defines. In essence, a global define is a special preprocessor flag that you can enable or disable to conditionally compile or exclude blocks of your code. By setting the flag to <code class="literal">true</code>, Unity will automatically compile one version of your code, and by setting it to <code class="literal">false</code>, Unity will compile the other version. This will allow you to maintain two versions or variations of your code in only one set of source files: one for debug and one for release. Let's see this in practice in Unity. Consider the following code sample 2-5:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class CubeScript : MonoBehaviour 
05 {
06 // Use this for initialization
07 void Start ()
08 {
<span class="strong"><strong>09        #if SHOW_DEBUG_MESSAGES</strong></span>
10        //runs ONLY if the Define SHOW_DEBUG_MESSAGES is active
11        Debug.Log ("Pos: " + transform.position.ToString());
12       #endif
13 
14       //runs because it's outside the #if #endif block
15        Debug.Log ("Start function called");
16 }
17 }</pre></div><p>Lines 09–12 feature the core functionality using the preprocessor directives <code class="literal">#if</code> and <code class="literal">#endif</code> conditional. This conditional is not executed at runtime like a regular <code class="literal">if</code> statement, but at compile time. At compile time, Unity will decide whether the global define <code class="literal">SHOW_DEBUG_MESSAGES</code> is specified or active. If, and only if, it is, then lines 10 and 11 will be compiled, otherwise the compiler will ignore these lines, treating them as comments. Using this feature, you can isolate all debug code within an <code class="literal">#if #endif</code> block that checks for a debug define and activates and deactivates the code on the basis of the <code class="literal">SHOW_DEBUG_MESSAGES</code> define, which applies project-wide to all source files. The question that then remains is how is the define set. To set the global define, navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span> from the application menu. Then, enter the define name in the <span class="strong"><strong>Scripting Define Symbols</strong></span> field, making sure that you press the <span class="emphasis"><em>Enter</em></span> key after entering the name to <a id="id159" class="indexterm"></a>confirm the change, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_02_06.jpg" /><div class="caption"><p>Adding global custom defines from the Unity Editor, which lets you conditionally compile code</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>
<span class="strong"><strong>Removing defines and adding multiple defines</strong></span>
</p><p>Simply entering the name of your global define in the <span class="strong"><strong>Scripting Define Symbols</strong></span> field is<a id="id160" class="indexterm"></a> enough for it to take effect and apply across your code. You can delete the name to remove the define, but you can also prefix the name with <code class="literal">/</code> (for example, <code class="literal">/SHOW_DEBUG_MESSAGE</code>) to disable the define, thus making it <a id="id161" class="indexterm"></a>easier to re-enable it later. You can also add multiple defines, separating each with the semicolon symbol (for example, <code class="literal">DEFINE1;DEFINE2;DEFINE3…</code>).</p></div></div>