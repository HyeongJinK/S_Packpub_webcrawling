<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec19"></a>Classes and polymorphism</h2></div></div><hr /></div><p>To illustrate <a id="id95" class="indexterm"></a>polymorphism in C#, let's start by considering the following code sample 1-12. This sample doesn't demonstrate polymorphism immediately<a id="id96" class="indexterm"></a> but represents the start of a scenario where polymorphism will be useful, as we'll see. Here, a basic skeleton class is defined for a potential <a id="id97" class="indexterm"></a>
<span class="strong"><strong>non-player character</strong></span> (<span class="strong"><strong>NPC</strong></span>) in a generic RPG game. The class is intentionally not comprehensive and features basic variables that only mark the starting point for a character. The most important thing here is that the class features a <code class="literal">SayGreeting</code> function, which should be invoked when the player engages the NPC in conversation. It displays a generic welcome message to <span class="strong"><strong>Console</strong></span> as follows:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyCharacter
05 {
06 public string CharName = "";
07 public int Health = 100;
08 public int Strength = 100;
09 public float Speed = 10.0f;
10 public bool isAwake = true;
11 
12     //Offer greeting to the player when entering conversation
<span class="strong"><strong>13     public virtual void SayGreeting()</strong></span>
14     {
15         Debug.Log ("Hello, my friend");
16     }
17 }</pre></div><p>The first problem to arise relates to the diversity and believability of the <code class="literal">MyCharacter</code> class if we try imagining how it'd really work in a game. Specifically, every character instantiated from <code class="literal">MyCharacter</code> will offer exactly the same greeting when <code class="literal">SayGreeting</code> is invoked: men, women, orcs, and everybody. They'll all say the same thing, namely, <code class="literal">"Hello, my friend"</code>. This is neither believable nor desirable. Perhaps, the most elegant solution would <a id="id98" class="indexterm"></a>be to just add a public string variable to the class, thus allowing customization over the message printed. However, to illustrate polymorphism clearly, let's try a different solution. We could create several additional classes instead, all derived from <code class="literal">MyCharacter</code>, one for each new NPC type and each offering a unique greeting from a <code class="literal">SayGreeting</code> function. This is possible with <code class="literal">MyCharacter</code>, because <code class="literal">SayGreeting</code> has been declared using the virtual keyword (line 13). This allows derived<a id="id99" class="indexterm"></a> classes to override the behavior of <code class="literal">SayGreeting</code> in the <code class="literal">MyCharacter</code> class. This means<a id="id100" class="indexterm"></a> the <code class="literal">SayGreeting</code> function in derived classes will replace the behavior of the original function in the base class. Such a solution might look similar to the code sample 1-13:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-------------------------------------------
04 public class MyCharacter
05    {
06    public string CharName = "";
07    public int Health = 100;
08 public int Strength = 100;
09 public float Speed = 10.0f;
10 public bool isAwake = true;
11 
12 //Offer greeting to the player when entering conversation
13 public virtual void SayGreeting()
14 {
15        Debug.Log ("Hello, my friend");
16 	}
17 }
18 //-------------------------------------------
19 public class ManCharacter: <span class="strong"><strong>MyCharacter</strong></span>
20 {
<span class="strong"><strong>21 public override void SayGreeting()</strong></span>
22 {
23        Debug.Log ("Hello, I'm a man");
24 }
25 }
26 //-------------------------------------------
27 public class WomanCharacter: <span class="strong"><strong>MyCharacter</strong></span>
28 {
<span class="strong"><strong>29 public override void SayGreeting()</strong></span>
30 {
31        Debug.Log ("Hello, I'm a woman");
32 }
33 }
34 //-------------------------------------------
35 public class OrcCharacter: <span class="strong"><strong>MyCharacter</strong></span>
36 {
<span class="strong"><strong>37 public override void SayGreeting()</strong></span>
38 {
39        Debug.Log ("Hello, I'm an Orc");
40 }
41 }
42 //-------------------------------------------</pre></div><p>With this code, some improvement is made, that is, different classes are created for each NPC type, namely, <code class="literal">ManCharacter</code>, <code class="literal">WomanCharacter</code>, and <code class="literal">OrcCharacter</code>. Each offers a different greeting in the <code class="literal">SayGreeting</code> function. Further, each NPC inherits all the common behaviors from the shared base class <code class="literal">MyCharacter</code>. However, a technical problem regarding type<a id="id101" class="indexterm"></a> specificity arises. Now, imagine creating a tavern location inside which there are many NPCs of the different types defined, so far, all enjoying a tankard of grog. As the player<a id="id102" class="indexterm"></a> enters the tavern, all NPCs should offer their unique greeting. To achieve this functionality, it'd be great if we could have a single array of all NPCs and simply call their <code class="literal">SayGreeting</code> function from a loop, each offering their own greeting. However, it seems, initially, that we cannot do this. This is because all elements in a single array must be of the same data type, such as <code class="literal">MyCharacter[]</code> or <code class="literal">OrcCharacter[]</code>. We cannot mix types for the same array. We could, of course, declare multiple arrays for each NPC type, but this feels awkward and doesn't easily allow for the seamless creation of more NPC types after the array code has been written. To solve this problem, we'll need a specific and dedicated solution. This is where polymorphism comes to the rescue. Refer to the<a id="id103" class="indexterm"></a> following sample 1-14, which defines a new <code class="literal">Tavern</code> class in <a id="id104" class="indexterm"></a>a completely separate script file:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class Tavern : MonoBehaviour 
05 {
06 //Array of NPCs in tavern
07 public MyCharacter[] Characters = null;
08 //-------------------------------------------------------
09 // Use this for initialization
10 void Start () {
11 
12       //New array - 5 NPCs in tavern
13       Characters = new MyCharacter[5];
14 
15        //Add characters of different types to array MyCharacter
16        Characters[0] = new ManCharacter();
17        Characters[1] = new WomanCharacter();
18        Characters[2] = new OrcCharacter();
19        Characters[3] = new ManCharacter();
20        Characters[4] = new WomanCharacter();
21 
22        //Now run enter tavern functionality
23        EnterTavern();
24 }
25 //-------------------------------------------------------
26 //Function when player enters Tavern
27 public void EnterTavern()
28 {
29       //Everybody say greeting
30       foreach(MyCharacter C in Characters)
31       {
32              //call SayGreeting in derived class
33              //Derived class is accessible via base class
34             C.SayGreeting();
35       }
36 }
37 //-------------------------------------------------------
38 }</pre></div><p>The following are the comments for code sample 1-14:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 07</strong></span>: To keep track of all NPCs in the tavern, regardless of the NPC type, a single array (<code class="literal">Characters</code>) of type <code class="literal">MyCharacter</code> is declared.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 16-20</strong></span>: The <code class="literal">Characters</code> array is populated with multiple NPCs of different types. This works because, though they are of different types, each NPC derives from the same base class.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 27</strong></span>: The <code class="literal">EnterTavern</code> function is called at level startup.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 34</strong></span>: A <code class="literal">foreach</code> loop cycles through all NPCs in the <code class="literal">Characters</code> array, calling the <code class="literal">SayGreeting</code> function. The result is shown in the following screenshot. The unique<a id="id105" class="indexterm"></a> messages for each NPC are printed instead of the generic message defined in the base class. Polymorphism<a id="id106" class="indexterm"></a> allows the overridden method in the derived classes to be called instead.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_01_11.jpg" /><div class="caption"><p>Polymorphism produces a backwards transparency between data types that share a common lineage</p></div></div></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip12"></a>Tip</h3><p>More information<a id="id107" class="indexterm"></a> on polymorphism in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-GB/library/ms173152.aspx" target="_blank">http://msdn.microsoft.com/en-GB/library/ms173152.aspx</a>.</p></div></div>