<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec40"></a>Summary</h2></div></div><hr /></div><p>This chapter considered the process of debugging, which is centrally about finding and removing errors from your game. There are many methods to achieve this end, especially in Unity. Specifically, the methods considered here included the <code class="literal">Debug.Log</code> statement, perhaps the simplest of all debugging methods. Using this technique, <code class="literal">Debug.Log</code> statements are inserted into your code in critical lines, and these print diagnostic messages to Unity's <span class="strong"><strong>Console</strong></span>. Next, we looked at is custom defines: using them, you can section off and isolate blocks of your code between the release and debug versions; this allows you to run debug-specific code when specific flags are enabled. Then, we looked at error logging. This chapter demonstrated how to create an error logger class that integrates with native Unity's application class, using delegates. We also saw the profiler; the Unity profiler is a pro-only feature that gives us a high-level statistical insight into how processing is distributed over time and system resources. In addition, we explored in-editor debugging and visual debugging to gain a clearer visual insight into our scene, and factors that affect object behavior. Finally, we saw MonoDevelop debugging, which does not require us to edit our code. These include breakpoints, tracepoints, steps, and watches. Next up, we'll explore how to work with <code class="literal">GameObjects</code>.</p></div>