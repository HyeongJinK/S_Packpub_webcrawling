<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec85"></a>C# attributes and reflection</h2></div></div><hr /></div><p>From this point forward in the chapter, all editor extensions will rely heavily on the concepts of attributes and reflection. These concepts are not specific to Unity but refer to more general ideas in <a id="id613" class="indexterm"></a>computer science, programming, and to their application in languages such as C# as well as in the .NET framework. Before proceeding to the<a id="id614" class="indexterm"></a> next editor extension, let's consider attributes and the related concept<a id="id615" class="indexterm"></a> of reflection using the<a id="id616" class="indexterm"></a> example of the <code class="literal">Range</code> attribute, which is native to Unity. Consider the following line of code:</p><div class="informalexample"><pre class="programlisting">public float MyNumber = 0;</pre></div><p>This public variable will be displayed in the Object Inspector with an edit field that allows the user to type in any valid floating point number thereby setting the value of <code class="literal">MyNumber</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_08_05.jpg" /><div class="caption"><p>Entering in floating point values from the Object Inspector</p></div></div><p>This code works fine and is suitable in many cases, but there are times when it's preferable to<a id="id617" class="indexterm"></a> validate the numerical entry to within a range, clipping the numbers between a minimum and maximum. You can do this in the code using the <a id="id618" class="indexterm"></a>
<code class="literal">Mathf.Clamp</code> function but you<a id="id619" class="indexterm"></a> can also validate the entry using an attribute. You can attach a <code class="literal">Range</code> attribute to the floating point variable (<code class="literal">MyNumber</code>) to display a slider instead of an edit box, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> [Range(0f,1f)]</strong></span>
public float MyNumber = 0;</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip55"></a>Tip</h3><p>More information on attributes <a id="id620" class="indexterm"></a>can be found in the online Unity documentation at <a class="ulink" href="http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes" target="_blank">http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes</a>.</p></div><p>When this code is compiled, the <code class="literal">MyNumber</code> variable displays differently in the Object Inspector, honoring the numerical range between <code class="literal">0</code> and <code class="literal">1</code>, as shown in the following screenshot. Notice that all numbers provided to the <code class="literal">Range</code> attribute as arguments must be explicit values known at compile time and not expressions, which depend on variables that can vary at runtime. All attribute values must be known at compile time.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_08_06.jpg" /><div class="caption"><p>Using attributes to customize inspector display</p></div></div><p>So how do attributes work? In short, attributes are a form of metadata; they work like tags. Programmers can attach an attribute to a class, variable, or a method to associate data with it, which<a id="id621" class="indexterm"></a> is known to the compiler. The attribute itself is entirely descriptive because it does nothing; it's simply data. The importance of attributes arises because all the code based on .NET (or Mono) has the ability to step outside itself and become self-conscious, that is, the ability to look at all the classes and data types and instances <a id="id622" class="indexterm"></a>contained inside the program. For each object in the program, its metadata (attributes) can be queried and examined. This ability of a program to "look at itself from the outside" is known as reflection as it's like looking in a mirror. Of course, the program does not see itself in reverse or in distorted terms but rather as it truly is, including all its metadata. To give a quick example of reflection, try out the following code sample 8-2. This code will cycle through all the custom-made classes in your Unity application across all source files. Notice it doesn't just list all the instances of classes in the scene but all classes themselves (that is, the blueprints, metaphorically speaking):</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 using System.Reflection;
04 using System;
05 
06 public class MyTestScript : MonoBehaviour 
07 {
08 // Use this for initialization
09 void Start () 
10 {
11        //List all classes in assembly
12 foreach(Type t in Assembly.GetExecutingAssembly().GetTypes())

13        {
14              Debug.Log (t.Name);
15        }
16 }
17 }</pre></div><p>The following are the <a id="id623" class="indexterm"></a>comments for code sample 8-2:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 03-04</strong></span>: Both the namespaces <code class="literal">System</code> and <code class="literal">System.Reflection</code> should be included as they feature all classes and objects necessary for performing reflection in .NET.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 12</strong></span>: This <code class="literal">foreach</code> loop cycles through all classes (types) in the active assembly (that is, the compiled code, including all your custom made script files).</p></li></ul></div><p>You can take the concept of reflection even further. For example, having listed all types from code sample 8-2, you can even list the methods, properties, and variables (<code class="literal">Fields</code>) for a type. Refer to the following<a id="id624" class="indexterm"></a> code sample 8-3 that, given a specific type as an argument, will list all its public member variables:</p><div class="informalexample"><pre class="programlisting"> //Function to list all public variables for class t
 public void ListAllPublicVariables(Type t)
 {
    //Loop through all public variables
    foreach(FieldInfo FI in t.GetFields(BindingFlags.Public | BindingFlags.Instance)
    {
         //Print name of variable
         Debug.Log (FI.Name);
    }
 }</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip56"></a>Tip</h3><p>More information on <a id="id625" class="indexterm"></a>bitwise operations, as used in this code sample, can be found online at <a class="ulink" href="http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx" target="_blank">http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx</a>.</p></div><p>Most crucially, however, you can list the attributes assigned to a type too. This lets you query a type for its metadata and examine its properties at runtime as shown in the following code sample 8-4:</p><div class="informalexample"><pre class="programlisting">01 public void ListAllAttributes(Type t)
02 {
03 foreach(Attribute attr in t.GetCustomAttributes(true))
04 {
05        //List the type of attribute found
06        Debug.Log (attr.GetType());
07 }
08 }</pre></div><p>The code sample 8-4 demonstrates that all attribute data can be retrieved for a given data type in the code at runtime. This means data types and variables may have metadata associated with them, which can be retrieved and used to further influence how the objects should be<a id="id626" class="indexterm"></a> handled. This is powerful for editor plugins because by creating our own custom-defined attributes that can be attached to data types and member variables, we can integrate our code with the Unity Editor without making its logical or runtime structure<a id="id627" class="indexterm"></a> invalid. That is, we can tag variables in code with attributes to customize how they appear in the Unity Editor without invalidating or affecting it in terms of its logic or structure at runtime. Next, we'll see how to create custom attributes to customize the editor.</p></div>