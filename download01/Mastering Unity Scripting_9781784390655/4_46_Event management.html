<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec49"></a>Event management</h2></div></div><hr /></div><p>Event-driven programming can make our lives a lot easier. But no sooner than we accept events into the design <a id="id300" class="indexterm"></a>do we come across a string of new problems that require a thoroughgoing resolution. Specifically, we saw in the code sample 4-2 how C# properties for health and ammo are used to validate and detect for relevant changes and then to raise events (such as <code class="literal">OnDead</code>) where appropriate. This works fine in principle, at least when the enemy must be notified about events that happen to itself. However, what if an enemy needed to know about the death of another enemy or needed to know when a specified number of other enemies had been killed? Now, of course, thinking about this specific case, we could go back to the enemy class in the code sample 4-2 and amend it to call an <code class="literal">OnDead</code> event not just for the current instance but for all other enemies using functions such as <code class="literal">SendMessage</code>, as we've seen in the previous chapters. But this doesn't really solve our problem in the general sense. In fact, let's state the ideal case straight away; we want every object to optionally listen for every type of event and to be notified about them as and when they happen, just as easily as if the event had happened to them. So the question that we face now is about how to code an optimized system to<a id="id301" class="indexterm"></a> allow easy event management like this. In short, we need an <code class="literal">EventManager</code> class that allows objects to listen to specific events. This system relies on three central concepts, as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">EventListener</code>: A listener refers to any object that wants to be notified about an event when it happens, even its own events. In practice, almost every object will be a listener for<a id="id302" class="indexterm"></a> at least one event. An<a id="id303" class="indexterm"></a> enemy, for example, may want notifications about low health and low ammo among others. In this case, it's a listener for at least two separate events. Thus, whenever an object expects to be told when an event happens, it becomes a listener.</p></li><li style="list-style-type: disc"><p>
<code class="literal">EventPoster</code>: In contrast to listeners, when an object detects that an event has occurred, it must<a id="id304" class="indexterm"></a> announce or post a public notification about it that allows all other listeners to be notified. In the code sample 4-2, the <a id="id305" class="indexterm"></a>enemy class detects the <code class="literal">Ammo</code> and <code class="literal">Health</code> events using properties and then calls the internal events, if required. But to be a true poster in this sense, we require that the object must raise events at a global level.</p></li><li style="list-style-type: disc"><p>
<code class="literal">EventManager</code>: Finally, there's an overarching singleton <code class="literal">EventManager</code> object that persists <a id="id306" class="indexterm"></a>across levels and is globally accessible. This <a id="id307" class="indexterm"></a>object effectively links listeners to posters. It accepts notifications of events sent by posters and then immediately dispatches the notifications to all appropriate listeners in the form of events.</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec25"></a>Starting event management with interfaces</h3></div></div></div><p>The first or original <a id="id308" class="indexterm"></a>entity in the event handling system is the listenerâ€”the thing that should be notified about specific events as and when they happen. Potentially, a listener could be any kind of object <a id="id309" class="indexterm"></a>or any kind of class; it simply expects to be notified about specific events. In short, the listener will need to register itself with the <code class="literal">EventManager</code> as a listener for one or more specific events. Then, when the event actually occurs, the listener should be notified directly by a function call. So, technically, the listener raises a type-specificity issue for the <code class="literal">EventManager</code> about how the manager should invoke an event on the listener if the listener could potentially be an object of any type. Of course, this issue can be worked around, as we've seen, using either <code class="literal">SendMessage</code> or <code class="literal">BroadcastMessage</code>. Indeed, there are event handling systems freely available online, such as <code class="literal">NotificationCenter</code> that rely on these functions. However, in this chapter, we'll avoid them using<a id="id310" class="indexterm"></a> interfaces and use polymorphism instead, as both <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> rely heavily on reflection (information <a id="id311" class="indexterm"></a>on reflection is covered later in <a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Customizing the Unity Editor</em></span>). Specifically, we'll create an interface from which all listener objects derive.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Tip</h3><p>More information on the freely available <code class="literal">NotificationCenter</code> (C# version) is available from the Unity wiki at <a class="ulink" href="http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter" target="_blank">http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter</a>.</p></div><p>In C#, an interface is like a hollow abstract base class. Like a class, an interface brings together a collection of methods and functions into a single template-like unit. But, unlike a class, an interface only allows you to define function prototypes such as the name, return type, and arguments for a function. It doesn't let you define a function body. The reason being that an interface simply defines the total set of functions that a derived class will have. The derived class may implement the functions however necessary, and the interface simply exists so that other objects can invoke the functions via polymorphism without knowing the specific type of each derived class. This makes interfaces a suitable candidate to create a <code class="literal">Listener</code> object. By defining a <code class="literal">Listener</code> interface from which all objects will be derived, every object has the ability to be a listener for events.</p><p>The following code sample 4-3 demonstrates a sample <code class="literal">Listener</code> interface:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------------------------
04 //Enum defining all possible game events
05 //More events should be added to the list
<span class="strong"><strong>06 public enum EVENT_TYPE {GAME_INIT, </strong></span>
<span class="strong"><strong>07                                 GAME_END,</strong></span>
<span class="strong"><strong>08                                 AMMO_EMPTY,</strong></span>
<span class="strong"><strong>09                                 HEALTH_CHANGE,</strong></span>
<span class="strong"><strong>10                                 DEAD};</strong></span>
11 //-----------------------------------------------------------
12 //Listener interface to be implemented on Listener classes
<span class="strong"><strong>13 public interface IListener</strong></span>
14 {
15 //Notification function invoked when events happen
<span class="strong"><strong>16 void OnEvent(EVENT_TYPE Event_Type, Component Sender, Object Param = null);</strong></span>

17 }
18 //-----------------------------------------------------------</pre></div><p>The following are the comments on the code sample 4-3:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 06-10</strong></span>: This enumeration should define a complete list of all possible game events that could be raised. The sample code lists only five game events: <code class="literal">GAME_INIT</code>, <code class="literal">GAME_END</code>, <code class="literal">AMMO_EMPTY</code>, <code class="literal">HEALTH_CHANGE</code>, and <code class="literal">DEAD</code>. Your game will presumably have many more. You don't actually need to use enumerations for encoding events; you could just use integers. But I've used enumerations to improve event readability in code.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 13-17</strong></span>: The <code class="literal">Listener</code> interface is defined as <code class="literal">IListener</code> using the C# interfaces. It supports just one event, namely <code class="literal">OnEvent</code>. This function will be inherited by <a id="id312" class="indexterm"></a>all derived classes and will be invoked by the manager whenever an event occurs for which the listener is registered. Notice that <code class="literal">OnEvent</code> is simply a function prototype; it has no body.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Tip</h3><p>More information on C# interfaces can be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/ms173156.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/ms173156.aspx</a>.</p></div></li></ul></div><p>Using the <code class="literal">IListener</code> interface, we now have the ability to make a listener from any object using only class inheritance; that is, any object can now declare itself as a listener and potentially receive events. For example, a new <code class="literal">MonoBehaviour</code> component can be turned into a listener<a id="id313" class="indexterm"></a> with the following code sample 4-4. This code, as in the previous chapters, uses multiple inheritance, that is, it inherits from two classes. More information on multiple inheritance can be found at <a class="ulink" href="http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp" target="_blank">http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp</a>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
 using System.Collections;
 
 public class MyCustomListener : MonoBehaviour, IListener
 {
    // Use this for initialization
    void Start () {}
    // Update is called once per frame
    void Update () {}
    //---------------------------------------
    //Implement OnEvent function to receive Events 
<span class="strong"><strong>    public void OnEvent(EVENT_TYPE Event_Type, Component Sender, Object Param = null)</strong></span>
    {
    }
    //---------------------------------------
 }</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec26"></a>Creating an EventManager</h3></div></div></div><p>Any object can now be turned into a listener, as we've seen. But still the listeners must register themselves <a id="id314" class="indexterm"></a>with a manager object of some kind. Thus, it is the duty of the manager to call the events on the listeners when the events actually happen. Let's now turn to the manager itself and its implementation details. The <a id="id315" class="indexterm"></a>manager class will be called <code class="literal">EventManager</code>, as shown in the following code sample 4-5. This class, being a persistent singleton object, should be attached to an empty <code class="literal">GameObject</code> in the scene where it will be directly accessible to every other object through a static instance property. More on this class and its usage is considered in the subsequent comments:</p><div class="informalexample"><pre class="programlisting">001 using UnityEngine;
002 using System.Collections;
<span class="strong"><strong>003 using System.Collections.Generic;</strong></span>
004 //-----------------------------------
005 //Singleton EventManager to send events to listeners
006 //Works with IListener implementations
007 public class EventManager : MonoBehaviour
008 {
009      #region C# properties
010 //-----------------------------------
011     //Public access to instance
012     public static EventManager Instance
013       {
014             get{return instance;}
015             set{}
016       }
017    #endregion
018 
019    #region variables
020       // Notifications Manager instance (singleton design pattern)
021    private static EventManager instance = null;
022 
023      //Array of listeners (all objects registered for events)
<span class="strong"><strong>024      private Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt; Listeners = new Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt;();</strong></span>

025     #endregion
026 //-----------------------------------------------------------
027     #region methods
028      //Called at start-up to initialize
029     void Awake()
030     {
031             //If no instance exists, then assign this instance
032             if(instance == null)
033            {
034                   instance = this;
035                   DontDestroyOnLoad(gameObject); 
036            }
037             else
038                   DestroyImmediate(this);
039      }
040//-----------------------------------------------------------
041      /// &lt;summary&gt;
042      /// Function to add listener to array of listeners
043      /// &lt;/summary&gt;
044      /// &lt;param name="Event_Type"&gt;Event to Listen for&lt;/param&gt;
045     /// &lt;param name="Listener"&gt;Object to listen for event&lt;/param&gt;
<span class="strong"><strong>046     public void AddListener(EVENT_TYPE Event_Type, IListener Listener)</strong></span>
047     {
048            //List of listeners for this event
049            List&lt;IListener&gt; ListenList = null;
050 
051            // Check existing event type key. If exists, add to list
052            if(Listeners.TryGetValue(Event_Type, out ListenList))
053            {
054                   //List exists, so add new item
055                   ListenList.Add(Listener);
056                   return;
057            }
058 
059            //Otherwise create new list as dictionary key
060            ListenList = new List&lt;IListener&gt;();
061            ListenList.Add(Listener);
062            Listeners.Add(Event_Type, ListenList); 
063      }
064 //-----------------------------------------------------------
065       /// &lt;summary&gt;
066       /// Function to post event to listeners
067       /// &lt;/summary&gt;
068       /// &lt;param name="Event_Type"&gt;Event to invoke&lt;/param&gt;
069       /// &lt;param name="Sender"&gt;Object invoking event&lt;/param&gt;
070       /// &lt;param name="Param"&gt;Optional argument&lt;/param&gt;
<span class="strong"><strong>071       public void PostNotification(EVENT_TYPE Event_Type, Component Sender, Object Param = null)</strong></span>

072       {
073            //Notify all listeners of an event
074 
075            //List of listeners for this event only
076            List&lt;IListener&gt; ListenList = null;
077 
078            //If no event exists, then exit 
079            if(!Listeners.TryGetValue(Event_Type, out ListenList))
080                    return;
081 
082             //Entry exists. Now notify appropriate listeners
083             for(int i=0; i&lt;ListenList.Count; i++)
084             {
085                   if(!ListenList[i].Equals(null)) 
<span class="strong"><strong>086                   </strong></span>
<span class="strong"><strong>ListenList[i].OnEvent(Event_Type, Sender, Param);</strong></span>
087             }
088      }
089 //-----------------------------------------------------------
090      //Remove event from dictionary, including all listeners
091      public void RemoveEvent(EVENT_TYPE Event_Type)
092      {
093            //Remove entry from dictionary
094            Listeners.Remove(Event_Type);
095      }
096 //-----------------------------------------------------------
097       //Remove all redundant entries from the Dictionary
098      public void RemoveRedundancies()
099      {
100             //Create new dictionary
101             Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt; TmpListeners = new Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt;();

102 
103             //Cycle through all dictionary entries
104             foreach(KeyValuePair&lt;EVENT_TYPE, List&lt;IListener&gt;&gt; Item in Listeners)

105             {
106                   //Cycle all listeners, remove null objects
107                   for(int i = Item.Value.Count-1; i&gt;=0; i--)
108                   {
109                         //If null, then remove item
110                         if(Item.Value[i].Equals(null))
111                                 Item.Value.RemoveAt(i);
112                   }
113 
114            //If items remain in list, then add to tmp dictionary
115                    if(Item.Value.Count &gt; 0)
116                          TmpListeners.Add (Item.Key, Item.Value);
117             }
118 
119             //Replace listeners object with new dictionary
120             Listeners = TmpListeners;
121       }
122 //-----------------------------------------------------------
123       //Called on scene change. Clean up dictionary
124       void OnLevelWasLoaded()
125       {
126            RemoveRedundancies();
127       }
128 //-----------------------------------------------------------
129      #endregion
130 }</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"></a>Tip</h3><p>More information on the<a id="id316" class="indexterm"></a> <code class="literal">OnLevelWasLoaded</code> event can be found at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html</a>.</p></div><p>The following are<a id="id317" class="indexterm"></a> the comments on the code sample 4-5:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 003</strong></span>: Notice the addition of the <code class="literal">System.Collections.Generic</code> namespace giving us access<a id="id318" class="indexterm"></a> to additional mono classes, including the <code class="literal">Dictionary</code> class. This class will be used throughout the <code class="literal">EventManager</code> class. More information on mono and its classes are explained later in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Working with Mono</em></span>. In short, the <code class="literal">Dictionary</code> class is a special kind of 2D array that allows us to store a database of values based on key-value pairing. More information on the <code class="literal">Dictionary</code> class <a id="id319" class="indexterm"></a>can be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx</a>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 007</strong></span>: The <code class="literal">EventManager</code> class is derived from <code class="literal">MonoBehaviour</code> and should be attached to an empty <code class="literal">GameObject</code> in the scene where it will exist as a persistent singleton.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 024</strong></span>: A private member variable <code class="literal">Listeners</code> is declared using a <code class="literal">Dictionary</code> class. This structure maintains a hash-table array of key-value pairs, which can be looked up and searched like a database. The key-value pairing for the <code class="literal">EventManager</code> class takes the form of <code class="literal">EVENT_TYPE</code> and <code class="literal">List&lt;Component&gt;</code>. In short, this means that a list of event types can be stored (such as <code class="literal">HEALTH_CHANGE</code>), and for each type there could be none, one, or more components that are listening and which should be notified when the event occurs. In effect, the <code class="literal">Listeners</code> member is the primary data structure on which the <code class="literal">EventManager</code> relies to maintain who is listening for what. For more detailed<a id="id320" class="indexterm"></a> information on the Mono Framework and common classes within it, refer to <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Working with Mono</em></span>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 029-039</strong></span>: The <code class="literal">Awake</code> function is responsible for the singleton functionality, that is, to make the <code class="literal">EventManager</code> class into a singleton object that persists across scenes. For more information on persistent singletons, refer to <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Singletons, Statics, GameObjects, and the World</em></span>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 046-063</strong></span>: The <code class="literal">AddListener</code> method of <code class="literal">EventManager</code> should be called by a <code class="literal">Listener</code> object once for each event for which it should listen. The method accepts two arguments: the event to listen for (<code class="literal">Event_Type</code>) and a reference to the listener object itself (derived from <code class="literal">IListener</code>), which should be <a id="id321" class="indexterm"></a>notified if and when the event happens. The <code class="literal">AddListener</code> function is responsible for accessing the <code class="literal">Listeners</code> dictionary and generating a new key-value pair to store the connection between the event and the listener.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 071-088</strong></span>: The <a id="id322" class="indexterm"></a>
<code class="literal">PostNotification</code> function can be called by any object, whether a listener or not, whenever an event is detected. When called, the <code class="literal">EventManager</code> cycles all matching entries in the dictionary, searching for all listeners connected to the current event, and notifies them by invoking the <code class="literal">OnEvent</code> method through the <code class="literal">IListener</code> interface.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 098-127</strong></span>: The final methods for the <code class="literal">EventManager</code> class are responsible for maintaining data integrity of the <code class="literal">Listeners</code> structure when a scene change occurs and the <code class="literal">EventManager</code> class persists. Although the <code class="literal">EventManager</code> class persists across scenes, the listener objects themselves in the <code class="literal">Listeners</code> variable may not do so. They may get destroyed on scene changes. If so, scene changes will invalidate some listeners, leaving the <code class="literal">EventManager</code> with invalid entries. Thus, the <code class="literal">RemoveRedundancies</code> method is called to find and eliminate all invalid entries. The <code class="literal">OnLevelWasLoaded</code> event is invoked automatically by Unity whenever a scene change occurs.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"></a>Note</h3><p>
<span class="strong"><strong>Dictionaries</strong></span>
</p><p>The great thing about<a id="id323" class="indexterm"></a> dictionaries is not just their access speed as a dynamic array (which is comparatively fast) but also the way you work with them through object types and the array subscript operator. In a typical array, every element must be <a id="id324" class="indexterm"></a>accessed by its numerical and integer index, such as <code class="literal">MyArray[0]</code> and <code class="literal">MyArray[1]</code>. But with dictionaries, the<a id="id325" class="indexterm"></a> case is different. Specifically, you can access elements using objects of <code class="literal">EVENT_TYPE</code>, which represents the key part of the key-value pair, for example, <code class="literal">MyArray[EVENT_TYPE.HEALTH_CHANGE]</code>. For more information on dictionaries, see the<a id="id326" class="indexterm"></a> official Microsoft documentation at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx</a>.</p></div></div></div>