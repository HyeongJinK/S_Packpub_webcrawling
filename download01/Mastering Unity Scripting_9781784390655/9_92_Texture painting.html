<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec93"></a>Texture painting</h2></div></div><hr /></div><p>There are many practical scenarios where it's necessary to paint pixels onto textures at runtime. Sometimes, the <a id="id679" class="indexterm"></a>need itself will be trivial, such as displaying a decal texture (such as a foot print or written message) in front of another surface using alpha transparency. In these cases, you can simply workaround the issue with an alpha cut out plane positioned in front of another plane as the background. However, there are times when your needs are more complex, and you actually need to resort to true texture painting. For example, in a street-fighting game, blood splatters from punches and other attacks will fall to the ground and surrounding scenery, and you want to it remain as part of the environment texture. Another example might be a casual make-up artist game where the gamer must paint blusher or eye shadow onto a face mesh.</p><p>Here, you don't simply want to paint textured quads in front of the mesh as separate objects to create the appearance of textured decals. Instead, you really need to paint a source texture (such as a brush) onto a destination texture as applied to a mesh. Here, the painting does not just happen between two independent textures but with a mesh and its UV mapping intervening between them. In other words, a source texture must be applied or projected onto a mesh surface in the scene, and then, the brush pixels must be unprojected back onto the destination texture through the mesh UV mapping. This ensures that the brush pixels are painted to the correct place within the destination texture, as shown in the following screenshot. This method, therefore, allows any source texture of any size to be painted onto any 3D surface and its destination texture of any size via UV mapping.</p><p>In this section, we'll explore<a id="id680" class="indexterm"></a> how this is achieved practically and effectively. Before getting started, however, it should be mentioned that texture painting in this way should be pursued as a last resort when alternative methods (such as cut out quads) are not adequate. This is because true texture painting is computationally expensive.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_11.jpg" /><div class="caption"><p>Real-time painting of textured brushes onto other textures via a mesh and its UV mapping</p></div></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip65"></a>Tip</h3><p>A complete texture painting project can be found in the book's companion files (code bundle).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec55"></a>Step 1 – creating a texture blending shader</h3></div></div></div><p>First, let's<a id="id681" class="indexterm"></a> recognize the two-layer approach<a id="id682" class="indexterm"></a> that's ideal here. First, we have the brush source texture itself, which will be painted onto a destination texture when the user clicks on a mesh in the scene, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_12.jpg" /><div class="caption"><p>The brush texture, where black is transparent (alpha)</p></div></div><p>Then, we have the destination texture applied to the mesh onto which the brush strokes should be overlaid <a id="id683" class="indexterm"></a>when painted, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_13.jpg" /><div class="caption"><p>Destination texture onto which brushes should be painted</p></div></div><p>However, we don't usually want the painted brush strokes overwriting or changing the original destination texture during the paint operation. This is because the destination texture could be applied to multiple objects in the scene (at least in theory), and overwriting or changing the pixels of the original will result in its effects being propagated to all objects using the texture.</p><p>Instead, it'd be better to separate the paint effects onto a separate texture with a transparent background, which is layered over the destination texture via a custom material. This creates a true separation between the destination texture and the paint effects, even though in appearance, it appears as one consolidated texture. To achieve this effect, a custom shader must be written, as shown in the following code sample 9-4. This shader blends a top<a id="id684" class="indexterm"></a> texture (with alpha transparency) on top of a background texture:</p><div class="informalexample"><pre class="programlisting">01 Shader "TextureBlender"
02 {
03     Properties
04     {
05     _Color ("Main Color", Color) = (1,1,1,1)
06     _MainTex ("Base (RGB) Trans (A)", 2D) = "white" {}
07     _BlendTex ("Blend (RGB)", 2D) = "white"
08     }
09     
10     SubShader
11     {
12 Tags { "Queue"="Geometry-9" "IgnoreProjector"="True" "RenderType"="Transparent" }

13     Lighting Off
14     LOD 200
15     Blend SrcAlpha OneMinusSrcAlpha
16     
17     CGPROGRAM
18            #pragma surface surf Lambert
19            uniform fixed4 _Color;
20            uniform sampler2D _MainTex;
21            uniform sampler2D _BlendTex;
22 
23            struct Input 
24            {
25              float2 uv_MainTex;
26            };
27 
28            void surf (Input IN, inout SurfaceOutput o) 
29            {
30                  fixed4 c1 = tex2D( _MainTex, IN.uv_MainTex );
31                  fixed4 c2 = tex2D( _BlendTex, IN.uv_MainTex );
32 
33                  fixed4 main = c1.rgba * (1.0 - c2.a);
34                  fixed4 blendedoutput = c2.rgba * c2.a;
35 
36 o.Albedo = (main.rgb + blendedoutput.rgb) * _Color;

37                  o.Alpha = main.a + blendedoutput.a;
38            }
39     ENDCG
40     }
41     Fallback "Transparent/VertexLit"
42 }</pre></div><p>Once the shader is coded and saved, it appears as a selectable shader type for any material you create via the <span class="strong"><strong>Material</strong></span> panel in the Object Inspector. This shader should be used for any object onto which details must be painted, as shown in the following screenshot. The <code class="literal">_MainTex</code> slot refers to the background texture onto which details must be overlaid but which must also be preserved from any true edits. The <code class="literal">_BlendTex</code> slot refers to the texture<a id="id685" class="indexterm"></a> to be overlaid onto <code class="literal">_MainTex</code>, which preserves its alpha transparency. Typically, this slot will be populated at runtime from script by generating an alpha transparent texture to receive brush strokes, as we'll soon see.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_14.jpg" /><div class="caption"><p>A custom shader is created to blend the top-most texture onto the bottom-most texture</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec56"></a>Step 2 – creating a texture painting script</h3></div></div></div><p>We've<a id="id686" class="indexterm"></a> now created a<a id="id687" class="indexterm"></a> shader that accepts two textures as input (the top and bottom textures) and blends the top over the bottom; this allows alpha transparency. This results in a Photoshop-layer style effect. This allows us to separate texture painting onto a top texture while preserving the pixels of the original background below it, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_15.jpg" /><div class="caption"><p>Creating a texture painting script</p></div></div><p>Before moving further, however, we must first edit the brush texture asset we plan on using via Object<a id="id688" class="indexterm"></a> Inspector. Specifically, select the brush texture from the <span class="strong"><strong>Project</strong></span> panel in the Unity Editor <a id="id689" class="indexterm"></a>and change <span class="strong"><strong>Texture Type</strong></span> to <span class="strong"><strong>Advanced</strong></span>. Enable the checkbox for <span class="strong"><strong>Read/Write Enabled</strong></span>; this allows the texture to be accessed using texture-editing functions.</p><p>In addition, enable <span class="strong"><strong>Alpha is Transparency</strong></span> and disable <span class="strong"><strong>Generate Mip Maps</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_16.jpg" /><div class="caption"><p>Configuring textures for texture painting</p></div></div><p>Now, we'll need to create a texture-painting script that allows us to paint the brush texture, using the <a id="id690" class="indexterm"></a>mouse, onto a 3D object in the scene via its UV <a id="id691" class="indexterm"></a>coordinates. The script is shown in the following code sample 9-5:</p><div class="informalexample"><pre class="programlisting">001 //-----------------------------------------------------------
002 using UnityEngine;
003 using System.Collections;
004 //-----------------------------------------------------------
005 public class TexturePainter : MonoBehaviour 
006 {
007       //Square texture with alpha
<span class="strong"><strong>008        public Texture2D BrushTexture = null;</strong></span>
009 
010       //Width and height of destination texture
011       public int SurfaceTextureWidth = 512;
012       public int SurfaceTextureHeight = 512;
013 
014      //Reference to painting surface texture
<span class="strong"><strong>015       public Texture2D SurfaceTexture = null;</strong></span>
016 
017      //Reference to material for destination texture 
<span class="strong"><strong>018      public Material DestMat = null;</strong></span>
019      //-------------------------------------------------
020      // Use this for initialization
021      void Start () 
022      {
023            //Create destination texture
024       SurfaceTexture = new Texture2D(SurfaceTextureWidth, SurfaceTextureHeight, TextureFormat.RGBA32, false);

025 
<span class="strong"><strong>026             //Fill with black pixels (transparent; alpha=0)</strong></span>
<span class="strong"><strong>027             Color[] Pixels = SurfaceTexture.GetPixels();</strong></span>
<span class="strong"><strong>028             for(int i=0; i&lt;Pixels.Length; i++)</strong></span>
<span class="strong"><strong>029                    Pixels[i] = new Color(0,0,0,0);</strong></span>
<span class="strong"><strong>030             SurfaceTexture.SetPixels(Pixels);</strong></span>
<span class="strong"><strong>031             SurfaceTexture.Apply();</strong></span>
032 
033            //Set as renderer main texture
034            renderer.material.mainTexture = SurfaceTexture;
035 
036            //If destination material, set blend texture 
037           //Used with custom shader
<span class="strong"><strong>038              if(DestMat)</strong></span>
<span class="strong"><strong>039       DestMat.SetTexture("_BlendTex", SurfaceTexture);</strong></span>
040       }
041       //--------------------------------------------------
042       // Update is called once per frame
043       void Update () 
044       {
045            //If mouse button down, then start painting
046            if(Input.GetMouseButtonDown(0))
047            {
048                   //Get hit of mouse cursor
049                   RaycastHit hit;
050 
051                   //Convert screen point to ray in scene
052      if (!Physics.Raycast(<span class="strong"><strong>Camera.main.ScreenPointToRay</strong></span>(Input.mousePosition), out hit))
053                          return;
054 
055                   //Get hit collider
056                   Renderer renderer = hit.collider.renderer;
057        MeshCollider Collide = hit.collider as MeshCollider;

058       if (renderer == null || renderer.sharedMaterial == null || renderer.sharedMaterial.mainTexture == null || Collide == null)
059                         return;
060 
061                   //Get UV Coords of hit surface
062                   Vector2 pixelUV = <span class="strong"><strong>hit.textureCoord;</strong></span>
063       pixelUV.x *= renderer.material.mainTexture.width;
064       pixelUV.y *= renderer.material.mainTexture.height;
065 
066       //Update coords to texture middle (align brush texture center to cursor)
067                   pixelUV.x -= BrushTexture.width/2;
068                   pixelUV.y -= BrushTexture.height/2;
069 
070             //Clamp pixel values between 0 and width
071      pixelUV.x = Mathf.Clamp(pixelUV.x, 0, renderer.material.mainTexture.width);

072      pixelUV.y = Mathf.Clamp(pixelUV.y, 0, renderer.material.mainTexture.height);
073 
074             //Paint onto destination texture
075      <span class="strong"><strong>PaintSourceToDestTexture</strong></span>(BrushTexture, renderer.material.mainTexture as Texture2D, (int)pixelUV.x, (int)pixelUV.y);
076             }
077      }
078      //--------------------------------------------------
079      //Paint source text to destination
080      //Will paint a brush texture onto a destination texture 
081      public static void PaintSourceToDestTexture(Texture2D Source, Texture2D Dest, int Left, int Top)
082       {
083             //Get source pixels
084             Color[] SourcePixels = Source.GetPixels();
085 
086             //Get dest pixels
087             Color[] DestPixels = Dest.GetPixels();
088 
089             for(int x=0; x&lt;Source.width; x++)
090             {
091                     for(int y=0; y&lt;Source.height; y++)
092                    {
093                         //Get source pixel
094      Color Pixel = GetPixelFromArray(SourcePixels, x, y, Source.width);

095 
096                          //Get offset in destination
097                          int DestOffsetX = Left + x;
098                          int DestOffsetY = Top + y;
099 
100      if(DestOffsetX &lt; Dest.width &amp;&amp; DestOffsetY &lt; Dest.height)

101      SetPixelInArray(DestPixels, DestOffsetX, DestOffsetY, Dest.width, Pixel, true);
102                    }
103            }
104 
105            //Update destination texture
106            Dest.SetPixels(DestPixels);
107            Dest.Apply();
108      }
109      //-------------------------------------------------------
110       //Reads color from pixel array
111       public static Color GetPixelFromArray(Color[] Pixels, int X, int Y, int Width)
112       {
113             <span class="strong"><strong>return Pixels[X+Y*Width];</strong></span>
114       }
115       //------------------------------------------------
116       //Sets color in pixel array
117        public static void SetPixelInArray(Color[] Pixels, int X, int Y, int Width, Color NewColor, bool Blending=false)
118       {
119             if(!Blending)
120                   <span class="strong"><strong>Pixels[X+Y*Width]</strong></span> = NewColor; 
121             else
122             {
123      //Here we blend the color onto existing surface, preserving alpha transparency

124      Color C = <span class="strong"><strong>Pixels[X+Y*Width]</strong></span> * (1.0f - NewColor.a);

125                   Color Blend = NewColor * NewColor.a;
126 
127                   Color Result = C + Blend;
128                    float Alpha = C.a + Blend.a;
129 
130       Pixels[X+Y*Width] = new Color(Result.r, Result.g, Result.b, Alpha);

131             }
132      }
133      //-------------------------------------------------
134 }
135 //-----------------------------------------------------------</pre></div><p>The following are the<a id="id692" class="indexterm"></a> comments for code sample 9-5:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 008</strong></span>: The public variable in this line maintains a reference to a valid texture asset to be used as the brush graphic during paint operations. For each mouse click, this texture <a id="id693" class="indexterm"></a>will be "laid down" or painted onto the variable <code class="literal">SurfaceTexture</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 015</strong></span>: <code class="literal">SurfaceTexture</code> will reference a dynamically generated texture filled, by default, with transparent pixels, which will reveal any texture layered beneath. This texture will accept all brush strokes during a paint operation. In short, this texture will be fed into the <code class="literal">TextureBlender</code> shader as the <code class="literal">_BlendTex</code> variable.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 026-031</strong></span>: A new texture is generated during the <a id="id694" class="indexterm"></a>
<code class="literal">Start</code> function. The texture is in the RGBA32 format, which supports an alpha channel. The <code class="literal">SetPixels</code> function<a id="id695" class="indexterm"></a> is used to batch fill (flood fill) the texture with pixels of the same color. More information on the <code class="literal">GetPixels</code> and <code class="literal">SetPixels</code> functions are considered later.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 046</strong></span>: In the<a id="id696" class="indexterm"></a> <code class="literal">Update</code> function, mouse clicks are detected to initiate the texture-painting functionality.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 048-059</strong></span>: If a mouse button is pressed, the function should paint the brush texture onto the destination. <code class="literal">Physics.Raycast</code> is called in line 52 to determine several<a id="id697" class="indexterm"></a> things, such as to see whether a mesh object in the scene was hit by the ray. For this to work properly, the object should feature a <code class="literal">Collider</code> component.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 062-072</strong></span>: If a collision was detected, the UV coordinates of the hit location should be<a id="id698" class="indexterm"></a> retrieved through the <code class="literal">textureCoord</code> variable of the <code class="literal">RaycastHit</code> structure. More information on this variable can be found online in the <a id="id699" class="indexterm"></a>Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html" target="_blank">http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html</a>. This member, is only valid if the intersected mesh has <code class="literal">MeshCollider</code>, as opposed to other collider types, such as <code class="literal">BoxCollider</code> or <code class="literal">CapsuleCollider</code>. However, this means that any object used as a texture-painting destination should feature a <code class="literal">MeshCollider</code> component, since it contains UV data. Lines 63–72 then convert the UV coordinates into absolute pixel positions, centering the brush source texture at the position of the cursor. The result of this code is to clearly identify a position on the source brush texture that should be the pivot or origin point, and to establish a pixel <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> coordinate location at which the source texture should be painted into the destination texture.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 075</strong></span>: Finally, the <code class="literal">PaintSourceToDestTexture</code> function is called to perform the paint operation itself.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 081</strong></span>: The <a id="id700" class="indexterm"></a>
<code class="literal">PaintSourceToDestTexture</code> function accepts four arguments: <code class="literal">Source</code>, <code class="literal">Dest</code>, <code class="literal">Left</code>, and <code class="literal">Top</code>. On the basis of these, the <code class="literal">Source</code> texture is painted onto the <code class="literal">Dest</code> at the positions <code class="literal">Left</code> and <code class="literal">Top</code>. This function is declared as static, which means that no instance of this class needs to be declared.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 084-087</strong></span>: The first step in the texture-painting process is to retrieve all pixels in both the <code class="literal">Source</code> and <code class="literal">Dest</code> textures. This is achieved using the <code class="literal">GetPixels</code> function. More information on <a id="id701" class="indexterm"></a>
<code class="literal">GetPixels</code> can be found online in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html" target="_blank">http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html</a>. Now, although each image is visually a two-dimensional array of pixels, the returned array from <code class="literal">GetPixels</code> is in fact linear (one-dimensional). This is the reason for both the <code class="literal">GetPixelFromArray</code> and <code class="literal">SetPixelFromArray</code> functions, which convert pixel <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> positions into linear array indices.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 89-101</strong></span>: Here, each pixel is retrieved from the <code class="literal">Source</code> texture and painted onto the destination. This checks to ensure that the brush texture is painted with the destination bounds and allows clipping, if required. This is necessary because a brush mark could, in principle, be made close to the texture edge; in this case, only a part of the brush would actually be painted onto the destination, as some pixels would be "cut off". Pixels are retrieved from the <code class="literal">Source</code> texture with <code class="literal">GetPixelFromArray</code>, and destination pixels are set with <code class="literal">SetPixelInArray</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 106-107</strong></span>: Finally, the destination pixels are pushed back to the destination texture buffer, and the <code class="literal">Apply</code> function is called to confirm the operation. Unity also<a id="id702" class="indexterm"></a> supports a <a id="id703" class="indexterm"></a>
<code class="literal">SetPixel</code> function (singular) as opposed to <code class="literal">SetPixels</code> (plural). However, <code class="literal">SetPixels</code> results in better performance as it repeats the calling of <code class="literal">SetPixel</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 111-114</strong></span>: The<a id="id704" class="indexterm"></a> <code class="literal">GetPixelFromArray</code> function accepts an array of pixel data as well as the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates of a pixel and the pixel width of the texture data. On the basis of this, it returns a linear index into the pixel array where you can find the pixel color value.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 117-131</strong></span>: The<a id="id705" class="indexterm"></a> <code class="literal">SetPixelInArray</code> function changes the color of a pixel in a linear array. The method of <a id="id706" class="indexterm"></a>change is determined by the argument <code class="literal">Blending</code>. If <code class="literal">Blending</code> is set to <code class="literal">false</code>, the source pixel would simply replace the destination pixel. If <code class="literal">Blending</code> is <code class="literal">true</code>, the source pixel would be blended or layered onto the destination pixel that preserves the alpha transparency. <code class="literal">Blending</code> should be set to <code class="literal">true</code> when painting alpha-transparent brushes onto the target texture to allow for the accumulation and blending of color values.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec57"></a>Step 3 – setting up texture painting</h3></div></div></div><p>Now that we have a<a id="id707" class="indexterm"></a> working shader, texture-painting script, and configured textures, we'll take a step-by-step run-through of configuring texture painting in Unity. Start from an empty project, including only our shader, texture painting script, and two configured textures: a background texture and a brush texture, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_17.jpg" /><div class="caption"><p>Starting a texture-painting project</p></div></div><p>Configure the brush texture from the <span class="strong"><strong>Project</strong></span> panel to a small size (such as <code class="literal">32 x 32</code>) and set its <span class="strong"><strong>Format</strong></span> to <span class="strong"><strong>RGBA 32 bit</strong></span> for alpha<a id="id708" class="indexterm"></a> transparency, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_18.jpg" /><div class="caption"><p>Configuring a brush texture</p></div></div><p>Create a new material using the <span class="strong"><strong>TextureBlender</strong></span> shader and assign the background texture to the <code class="literal">MainTexture</code> slot, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_19.jpg" /><div class="caption"><p>Creating a new material from our TextureBlender shader</p></div></div><p>Add a new <span class="strong"><strong>Quad</strong></span>, <span class="strong"><strong>Plane</strong></span>, or <span class="strong"><strong>Mesh</strong></span> to the scene and remove its collider, if any. This object will receive the final painted output, although the click detection will occur on a duplicate mesh. I am keeping the final <a id="id709" class="indexterm"></a>output mesh and the click-detection mesh separate to allow the destination mesh to have other collider types or components if required.</p><p>Once the Quad has been added, assign the custom material to it with the <span class="strong"><strong>TextureBlender</strong></span> shader, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_20.jpg" /><div class="caption"><p>Adding a new Quad</p></div></div><p>Duplicate <span class="strong"><strong>Quad</strong></span>, add <span class="strong"><strong>Mesh Collider</strong></span>, disable <span class="strong"><strong>Mesh Renderer</strong></span>, and assign an empty diffuse material to it. This mesh will not render, but will detect mouse clicks and perform the paint operation.</p><p>In <a id="id710" class="indexterm"></a>addition, add the <code class="literal">TexturePainter</code> script to the object and assign the <span class="strong"><strong>Brush Texture</strong></span> field to the brush texture itself and the <span class="strong"><strong>Dest Mat</strong></span> field to the <span class="strong"><strong>Custom_Mat</strong></span> material from the <span class="strong"><strong>Project</strong></span> panel, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_21.jpg" /><div class="caption"><p>Creating a click detection quad</p></div></div><p>Now, run the application<a id="id711" class="indexterm"></a> and start clicking on your mesh. When you do, paint strokes will be applied to the texture and display on the viewport, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_09_22.jpg" /><div class="caption"><p>Texture painting completed</p></div></div></div></div>