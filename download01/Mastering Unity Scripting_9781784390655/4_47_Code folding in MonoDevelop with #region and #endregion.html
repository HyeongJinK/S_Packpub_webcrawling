<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec50"></a>Code folding in MonoDevelop with #region and #endregion</h2></div></div><hr /></div><p>The two preprocessor <a id="id327" class="indexterm"></a>directives <code class="literal">#region</code> and <code class="literal">#endregion</code> (in combination with the code folding feature) can be highly useful for improving the readability<a id="id328" class="indexterm"></a> of your code and also for improving the speed<a id="id329" class="indexterm"></a> with which<a id="id330" class="indexterm"></a> you can navigate the source file. They add organization and structure to your source code without affecting its<a id="id331" class="indexterm"></a> validity or execution. Effectively, <code class="literal">#region</code> marks the top of a code block and <code class="literal">#endregion</code> marks<a id="id332" class="indexterm"></a> the end. Once a region is marked, it becomes foldable, that is, it becomes<a id="id333" class="indexterm"></a> collapsible using the <code class="literal">MonoDevelop</code> code editor, provided the code folding feature is enabled. Collapsing a region of code is useful for hiding it from view, which allows you to concentrate on reading other areas relevant to your needs, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_04_01.jpg" /><div class="caption"><p>Enabling code folding in MonoDevelop</p></div></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip25"></a>Tip</h3><p>To enable <a id="id334" class="indexterm"></a>code folding in <code class="literal">MonoDevelop</code>, select <span class="strong"><strong>Options</strong></span> in <span class="strong"><strong>Tools</strong></span> from the application menu. This displays the <span class="strong"><strong>Options</strong></span> window. From<a id="id335" class="indexterm"></a> here, choose the <a id="id336" class="indexterm"></a>
<span class="strong"><strong>General</strong></span> tab in<a id="id337" class="indexterm"></a> the <span class="strong"><strong>Text Editor</strong></span> option and<a id="id338" class="indexterm"></a> click on<a id="id339" class="indexterm"></a> <span class="strong"><strong>Enable code folding</strong></span> as well as <span class="strong"><strong>Fold #regions by default</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec27"></a>Using EventManager</h3></div></div></div><p>Now, let's see how to put the <code class="literal">EventManager</code> class to work in a practical context from the perspective of listeners and posters in a single scene. First, to listen for an event (any event) a listener must<a id="id340" class="indexterm"></a> register itself with the <code class="literal">EventManager</code> singleton instance. Typically, this will happen once and at the earliest opportunity, such as the <code class="literal">Start</code> function. Do not use the <code class="literal">Awake</code> function; this is reserved for an object's internal initialization as opposed to the functionality that reaches out beyond the <a id="id341" class="indexterm"></a>current object to the states and setup of others. See the following code sample 4-6 and notice that it relies on the <code class="literal">Instance</code> static property to retrieve a reference to the active <code class="literal">EventManager</code> singleton:</p><div class="informalexample"><pre class="programlisting">//Called at start-up
void Start()
{
//Add myself as listener for health change events
<span class="strong"><strong>EventManager.Instance.AddListener(EVENT_TYPE.HEALTH_CHANGE, this);</strong></span>
}</pre></div><p>Having registered listeners for one or more events, objects can then post notifications to <code class="literal">EventManager</code> as<a id="id342" class="indexterm"></a> events are detected, as shown in the <a id="id343" class="indexterm"></a>following code sample 4-7:</p><div class="informalexample"><pre class="programlisting">public int Health
{
get{return _health;}
set
{
   //Clamp health between 0-100
   _health = Mathf.Clamp(value, 0, 100);

   //Post notification - health has been changed <span class="strong"><strong>EventManager.Instance.PostNotification(EVENT_TYPE.HEALTH_CHANGE, this, _health);</strong></span>
}
}</pre></div><p>Finally, after a notification is posted for an event, all the associated listeners are updated automatically through <code class="literal">EventManager</code>. Specifically, <code class="literal">EventManager</code> will call the <code class="literal">OnEvent</code> function of each listener, giving listeners the opportunity to parse event data and respond where needed, as shown in the following code sample 4-8:</p><div class="informalexample"><pre class="programlisting">//Called when events happen
public void OnEvent(EVENT_TYPE Event_Type, Component Sender, object Param = null)
{
//Detect event type
switch(Event_Type)
{
    case EVENT_TYPE.HEALTH_CHANGE:
         OnHealthChange(Sender, (int)Param);
    break;
}
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Tip</h3><p>For a demonstration on using <code class="literal">EventManager</code>, see the <code class="literal">events</code> folder project in the code bundle of this chapter.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec28"></a>Alternative with delegates</h3></div></div></div><p>Interfaces are an efficient and trim way of implementing an event handling system, but they are not the only way. We can also use a C# feature, known as delegates. Essentially, we can create a function and store a<a id="id344" class="indexterm"></a> reference to it inside a variable. This variable allows you to treat functions as a reference type variable. That is, with delegates, you<a id="id345" class="indexterm"></a> can store references to functions, which can then be used later to invoke the function itself. Other languages, such as C++, offer a similar behavior through function pointers. By implementing the event system using delegates, we eliminate the need for interfaces. Consider the following code sample 4-7, which is an alternative implementation of <code class="literal">EventManager</code> using delegates. Relevant code changes are highlighted to help illustrate the differences between the interface and delegate implementations. Apart from minor changes to accommodate the delegate types, all other functions remained unchanged, as shown here:</p><div class="informalexample"><pre class="programlisting">001 using UnityEngine;
002 using System.Collections;
003 using System.Collections.Generic;
004 //-----------------------------------------------------------
<span class="strong"><strong>005 //Enum defining all possible game events</strong></span>
<span class="strong"><strong>006 //More events should be added to the list</strong></span>
<span class="strong"><strong>007 public enum EVENT_TYPE {GAME_INIT, </strong></span>
<span class="strong"><strong>008       GAME_END,</strong></span>
<span class="strong"><strong>009       AMMO_CHANGE,</strong></span>
<span class="strong"><strong>010        HEALTH_CHANGE,</strong></span>
<span class="strong"><strong>011        DEAD};</strong></span>
012 //-----------------------------------------------------------
013 //Singleton EventManager to send events to listeners
014 //Works with delegate implementations
015 public class EventManager : MonoBehaviour
016 {
017       #region C# properties
018 //-----------------------------------------------------------
019      //Public access to instance
020      public static EventManager Instance
021      {
022             get{return instance;}
023             set{}
024      }
025      #endregion
026 
027      #region variables
028      //Notifications Manager instance (singleton design pattern)
029      private static EventManager instance = null;
030 
031      // Declare a delegate type for events
<span class="strong"><strong>032      public delegate void OnEvent(EVENT_TYPE Event_Type, Component Sender, object Param = null);</strong></span>

033 
034       //Array of listener objects
035       private Dictionary&lt;EVENT_TYPE, List&lt;<span class="strong"><strong>OnEvent</strong></span>&gt;&gt; Listeners = new Dictionary&lt;EVENT_TYPE, List&lt;<span class="strong"><strong>OnEvent</strong></span>&gt;&gt;();

036       #endregion
037 //-----------------------------------------------------------
038      #region methods
039      //Called at start-up to initialize
040      void Awake()
041      {
042            //If no instance exists, then assign this instance
043           if(instance == null)
044            {
045                   instance = this;
046                   DontDestroyOnLoad(gameObject); 
047            }
048            else
049                   DestroyImmediate(this);
050      }
051 //-----------------------------------------------------------
052      /// &lt;summary&gt;
053      /// Add listener-object to array of listeners
054      /// &lt;/summary&gt;
055      /// &lt;param name="Event_Type"&gt;Event to Listen for&lt;/param&gt;
056      /// &lt;param name="Listener"&gt;Object to listen for event&lt;/param&gt;
057     public void AddListener(EVENT_TYPE Event_Type, OnEvent Listener)

058     {
059             //List of listeners for this event
060             List&lt;<span class="strong"><strong>OnEvent</strong></span>&gt; ListenList = null;
061 
062            // Check existing event. If one exists, add to list
063           if(Listeners.TryGetValue(Event_Type, out ListenList))
064            {
065                   //List exists, so add new item
066                   ListenList.Add(Listener);
067                   return;
068             }
069 
070            //Otherwise create new list as dictionary key
071            ListenList = new List&lt;OnEvent&gt;();
072            ListenList.Add(Listener);
073            Listeners.Add(Event_Type, ListenList); 
074      }
075 //-----------------------------------------------------------
076       /// &lt;summary&gt;
077       /// Function to post event to listeners
078       /// &lt;/summary&gt;
079       /// &lt;param name="Event_Type"&gt;Event to invoke&lt;/param&gt;
080       /// &lt;param name="Sender"&gt;Object invoking event&lt;/param&gt;
081       /// &lt;param name="Param"&gt;Optional argument&lt;/param&gt;
082       public void PostNotification(EVENT_TYPE Event_Type, Component Sender, object Param = null)

083       {
084             //Notify all listeners of an event
085 
086             //List of listeners for this event only
087             List&lt;<span class="strong"><strong>OnEvent</strong></span>&gt; ListenList = null;
088 
089             //If no entry exists, then exit 
090            if(!Listeners.TryGetValue(Event_Type, out ListenList))
091                   return;
092 
093            //Entry exists. Now notify appropriate listeners
094            for(int i=0; i&lt;ListenList.Count; i++)
095             {
096                 if(!ListenList[i].Equals(null)) 
097                         <span class="strong"><strong>ListenList[i](Event_Type, Sender, Param);</strong></span>
098            }
099      }
100 //-----------------------------------------------------------
101       //Remove event from dictionary, including all listeners
102       public void RemoveEvent(EVENT_TYPE Event_Type)
103       {
104            //Remove entry from dictionary
105            Listeners.Remove(Event_Type);
106       }
107 //-----------------------------------------------------------
108       //Remove all redundant entries from the Dictionary
109       public void RemoveRedundancies()
110       {
111             //Create new dictionary
112             Dictionary&lt;EVENT_TYPE, List&lt;OnEvent&gt;&gt; TmpListeners = new Dictionary&lt;EVENT_TYPE, List&lt;<span class="strong"><strong>OnEvent</strong></span>&gt;&gt;();

113 
114            //Cycle through all dictionary entries
115            foreach(KeyValuePair&lt;EVENT_TYPE, List&lt;<span class="strong"><strong>OnEvent</strong></span>&gt;&gt; Item in Listeners)

116            {
117                   //Cycle through all listeners
118                   for(int i = Item.Value.Count-1; i&gt;=0; i--)
119                   {
120                        //If null, then remove item
121                       if(Item.Value[i].Equals(null))
122                            Item.Value.RemoveAt(i);
123                   }
124 
125                  //If items remain, then add to tmp dictionary
126                  if(Item.Value.Count &gt; 0)
127                       TmpListeners.Add (Item.Key, Item.Value);
128            }
129 
130            //Replace listeners with new dictionary
131            Listeners = TmpListeners;
132      }
133 //-----------------------------------------------------------
134      //Called on scene change. Clean up dictionary
135      void OnLevelWasLoaded()
136      {
137              RemoveRedundancies();
138      }
139 //-----------------------------------------------------------
140       #endregion
141 }</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip27"></a>Tip</h3><p>More information on <a id="id346" class="indexterm"></a>C# delegates can be found in the Microsoft documentation at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx" target="_blank">http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx</a>.</p></div><p>The following are<a id="id347" class="indexterm"></a> the comments on the code sample 4-7:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 005-011</strong></span>: Here, the event type enumeration has been shifted into the <code class="literal">EventManager</code> file from the original <code class="literal">IListener</code> class. Since the delegate implementation avoids the need for interfaces and for <code class="literal">IListener</code> specifically, the enumeration can be shifted to the manager source file.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 032</strong></span>: The public member <code class="literal">OnEvent</code> is declared as a delegate type. Notice that the declaration is hybrid insofar as it combines variable declaration style with a function prototype. This specifies the function prototype that may be assigned to the delegate variable; any function with that structure can be assigned from any class or any script file. Thus, the <code class="literal">OnEvent</code> function becomes a delegate type, and this is used in the next statement creating the internal dictionary.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 035</strong></span>: The<a id="id348" class="indexterm"></a> private dictionary listeners is declared, and for each event type, an array of delegates (instead of interfaces) is stored; each delegate refers to a function that should be invoked when the event occurs.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 097</strong></span>: Critically, the<a id="id349" class="indexterm"></a> <code class="literal">PostNotification</code> function is called on <code class="literal">EventManager</code> to invoke all the delegates (listener functions) when an event occurs. This happens at line 097 with the statement <code class="literal">ListenList[i](Event_Type, Sender, Param);</code>. This invokes the delegate just like a function, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_04_02.jpg" /><div class="caption"><p>Exploring the EventManager projects</p></div></div></li></ul></div><p>The preceding screenshot shows the <code class="literal">EventManager</code> projects.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip28"></a>Tip</h3><p>To see the <code class="literal">EventManager</code> delegate implementation in action, see the <code class="literal">events_delgateversion</code> folder project in code bundle of this chapter.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec29"></a>MonoBehaviour events</h3></div></div></div><p>To close this chapter, let's consider some of the events Unity offers us already for working with event-driven programming. The <code class="literal">MonoBehaviour</code> class already exposes a wide range of events that are<a id="id350" class="indexterm"></a> called automatically under <a id="id351" class="indexterm"></a>specific conditions. These functions or events begin with the prefix <code class="literal">On</code> and include events such as <code class="literal">OnGUI</code>, <code class="literal">OnMouseEnter</code>, <code class="literal">OnMouseDown</code>, <code class="literal">OnParticleCollision</code>, and others. This section considers some details for common event types.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip29"></a>Tip</h3><p>The full list of <code class="literal">MonoBehaviour</code> events <a id="id352" class="indexterm"></a>can be found in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec30"></a>Mouse and tap events</h3></div></div></div><p>One set of useful<a id="id353" class="indexterm"></a> events is the mouse-input and touch-input set of events. These include<a id="id354" class="indexterm"></a> <code class="literal">OnMouseDown</code>, <code class="literal">OnMouseEnter</code>, and <code class="literal">OnMouseExit</code>. In the earlier versions of Unity, these events were only triggered for mouse-specific events and not touch input. But more recently, touch input has been mapped to<a id="id355" class="indexterm"></a> them; meaning that a tap will now<a id="id356" class="indexterm"></a> register by default as a mouse event. To clarify, <code class="literal">OnMouseDown</code> is called once when a mouse button is pressed down while the cursor is hovering on an<a id="id357" class="indexterm"></a> object. The event is not, however, called repeatedly until the button is released. Likewise, <code class="literal">OnMouseEnter</code> is called once when a cursor first hovers over an object without having exited and <code class="literal">OnMouseExit</code> is called when the cursor hovers away from an object it has previously entered. The success of these events depends on an object having a collider component attached to approximate its volume within which mouse events are detected. This means that none of the mouse events will fire without a collider attached to the object.</p><p>However, there are occasions when <code class="literal">MouseEvents</code> will not fire, even with a collider attached, because other objects (with colliders) are obscuring the objects you need to click on based on the current view from the active camera. That is, the clickable objects are in the background. You can, of course, solve the issue (at least in many cases) by simply assigning the foreground objects to an <code class="literal">IgnoreRaycast</code> layer making them immune from physics raycast operations.</p><p>To assign an object to an <code class="literal">IgnoreRaycast</code> layer, just select the object in the scene and then click on the <span class="strong"><strong>Layer</strong></span> dropdown in the Object Inspector, assigning the object to the <span class="strong"><strong>Ignore Raycast</strong></span> layer, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_04_03.jpg" /><div class="caption"><p>Assigning objects to the Ignore Raycast layer</p></div></div><p>But even this just isn't feasible sometimes. Often you'll need multiple cameras and many objects with colliders, and they'll sometimes obscure objects you want to select or adjust according to mouse<a id="id358" class="indexterm"></a>  input events. In these cases, you may need to manually handle mouse input events. The following code sample 4-8 achieves these,<a id="id359" class="indexterm"></a> invoking specific mouse events manually on the basis of input. In essence, this code uses the <code class="literal">Raycast</code> system to redirect manually detected input events to the <code class="literal">MonoBehaviour</code> mouse events. This code uses<a id="id360" class="indexterm"></a> <span class="strong"><strong>Coroutines</strong></span> too; considered after the code sample:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
 using System.Collections;
 //---------------------
 public class ManualMouse : MonoBehaviour
 {
    //---------------------
    //Get collider attached to this object
    private Collider Col = null;
    //---------------------
    //Awake function - called at start up
    void Awake()
    {
         //Get collider
         Col = GetComponent&lt;Collider&gt;();
    }
    //---------------------
    //Start Coroutine
    void Start()
    {
          StartCoroutine(UpdateMouse());
   }
   //---------------------
   public IEnumerator UpdateMouse()
   {
         //Are we being intersected
         bool bIntersected = false;
 
         //Is button down or up
         bool bButtonDown = false;
 
         //Loop forever
         while(true)
         {
         //Get mouse screen position in terms of X and Y
         //You may need to use a different camera Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
         RaycastHit hit;
 
               //Test ray for collision against this collider
               if (Col.Raycast(ray, out hit, Mathf.Infinity))
               {
   //Object was interesected  if(!bIntersected) SendMessage("OnMouseEnter", SendMessageOptions.DontRequireReceiver);
 
                       bIntersected = true;
 
               //Test for mouse events
               if(!bButtonDown &amp;&amp; Input.GetMouseButton(0))
{
bButtonDown = true; SendMessage("OnMouseDown", SendMessageOptions.DontRequireReceiver);
}

                if(bButtonDown &amp;&amp; !Input.GetMouseButton(0))
{
bButtonDown = false; SendMessage("OnMouseUp", SendMessageOptions.DontRequireReceiver);
}
                }
                else
                {
                      //Was previously entered and now leaving
                      if(bIntersected) SendMessage("OnMouseExit", SendMessageOptions.DontRequireReceiver);
 
                      bIntersected = false;
                      bButtonDown = false;
                }
 
                //Wait until next frame
                yield return null;
           }
    }
    //---------------------
 }
 //---------------------</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"></a>Note</h3><p>
<span class="strong"><strong>Coroutines</strong></span>
</p><p>Coroutines are a special kind of function. They behave like threads insofar as they appear to run in<a id="id361" class="indexterm"></a> parallel or asynchronously to the main game loop, that is, once you execute them, they seem to run in the background. Execution doesn't pause or wait until the function is completed as it does with traditional functions. This makes<a id="id362" class="indexterm"></a> Coroutines great for creating asynchronous-looking behaviors. Technically, all Coroutines must return a type of <code class="literal">IEnumerator</code>, contain at least one yield statement in their body, and must<a id="id363" class="indexterm"></a> be launched with the <code class="literal">StartCoroutine</code> function. The yield statement is a special statement that suspends execution of the Coroutine until its condition is met. The statement yield return new <code class="literal">WaitForSeconds(x)</code> will pause execution for <code class="literal">x</code> seconds, resuming after the interval at the next line. In contrast, the statement yield returned <code class="literal">null</code> will suspend execution for the current frame, resuming execution at the next line on the next frame. More information<a id="id364" class="indexterm"></a> on Coroutines and their use can be found in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html" target="_blank">http://docs.unity3d.com/Manual/Coroutines.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec31"></a>Application focus and pausing</h3></div></div></div><p>Three additional <code class="literal">MonoBehaviour</code> events are notable for causing confusion or surprise about their operation. They are: <code class="literal">OnApplicationPause</code>, <code class="literal">OnApplicationFocus</code>, and <code class="literal">OnApplicationQuit</code>.</p><p>
<code class="literal">OnApplicationQuit</code> is sent<a id="id365" class="indexterm"></a> to all objects in the scene just before the game exits but<a id="id366" class="indexterm"></a> before the scene and its<a id="id367" class="indexterm"></a> contents are effectively destroyed. If the game is being tested in the editor, then <a id="id368" class="indexterm"></a>
<code class="literal">OnApplicationQuit</code> is called when playback is stopped. Significantly, however, <code class="literal">OnApplicationQuit</code> may not be called for iOS devices, which usually don't quit or exit applications but rather suspend them while<a id="id369" class="indexterm"></a> users do other things, which allows them to return and resume from where they left off. If you need or want to receive <code class="literal">OnApplicationQuit</code> events on suspension, you'll need to enable the relevant option from the <span class="strong"><strong>Player Settings</strong></span> window. To access this, navigate to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span> from the application menu and then from the Object Inspector, expand the <span class="strong"><strong>Other Settings</strong></span> tab for the iOS builds and enable the <span class="strong"><strong>Exit on Suspend</strong></span> checkbox, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_04_04.jpg" /><div class="caption"><p>Enabling the exit on suspend option for iOS</p></div></div><p>
<code class="literal">OnApplicationFocus</code> is an event sent to all objects in the scene when the game loses focus, typically when the<a id="id370" class="indexterm"></a> game window is deactivated on desktop computers during multitask operations. This can be a significant in-game <a id="id371" class="indexterm"></a>event, especially for multiplayer games where action and events in a shared world continue, even when one or more of the players are not actively participating. In these cases, you may need to pause or resume specific behaviors or fade-in or fade-out game music.</p><p>
<code class="literal">OnApplicationPause</code> is an<a id="id372" class="indexterm"></a> ambiguous event<a id="id373" class="indexterm"></a> because the concept of a pause in Unity is not clearly defined. There<a id="id374" class="indexterm"></a> are, I believe, two distinct kinds of pauses, namely, an ultimate and relative pause. The ultimate kind is where every activity and every event in a game is totally suspended; in this state, there is no passing of time and nothing can move forward. The relative kind, in contrast, is the most common. Here, the game is self-conscious or aware of being in a paused state; it halts some events, such as in-world events, but allows other events to continue such as GUI interaction and user input, which can unpause the game. The <code class="literal">OnApplicationPause</code> event refers to the first kind of pause and not the latter. This event will be called when several conditions are met. These are considered in the next sections.</p><p>First, <code class="literal">OnApplicationPause</code> will only be called on the desktop if the <span class="strong"><strong>Run In Background</strong></span> option is not enabled in the <span class="strong"><strong>Player Settings</strong></span> tab, under the <span class="strong"><strong>Resolution</strong></span> group, as shown in the following screenshot. This option, when disabled, will automatically pause a desktop game whenever the window focus is lost. This means <code class="literal">OnApplicationPause</code> will follow an <code class="literal">OnApplicationFocus</code> event.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_04_05.jpg" /><div class="caption"><p>Disabling the Run In Background option</p></div></div><p>In iOS, <code class="literal">OnApplicationPause</code> <a id="id375" class="indexterm"></a>will be called whenever the application is minimized or pushed into the background.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip30"></a>Tip</h3><p>Do not rely on the <code class="literal">OnApplicationPause</code> event for creating your own relative pause functionality. To achieve this, use the <code class="literal">Time.timeScale</code> variable or code a more comprehensive system in which you have selective control over which elements are paused.</p></div></div></div>