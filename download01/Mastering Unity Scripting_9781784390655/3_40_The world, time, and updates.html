<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec44"></a>The world, time, and updates</h2></div></div><hr /></div><p>A Unity scene represents a collection of finite <code class="literal">GameObjects</code> inside the same 3D space and that also share the same timeframe. Every game needs to establish a unified concept of time to achieve synchronized animation and change, because animation means change over time. In Unity, the<a id="id265" class="indexterm"></a> <code class="literal">Time</code> class is available for reading and understanding time and its passing in script. Working with this class is therefore a critical skill for the creation of predictable and consistent motion in your games. More on this shortly.</p><p>Every game has a frame rate, which is defined in<a id="id266" class="indexterm"></a> <span class="strong"><strong>frames per second</strong></span> (<span class="strong"><strong>FPS</strong></span>). This rate is viewable from the <span class="strong"><strong>Stats</strong></span> panel in the <span class="strong"><strong>Game</strong></span> tab. The FPS tells you how many times in 1 second Unity is able to loop or iterate through your game code to draw a new render from the cameras to the screen. Each iteration is called a <span class="strong"><strong>frame</strong></span>. The<a id="id267" class="indexterm"></a> frame rate varies dramatically over time and across different computers. It's influenced by the power of your computer, other processes that might be running, and by how much content it needs to render in the current frame, among other factors. This means you can <a id="id268" class="indexterm"></a>never rely on FPS being consistent over time or the same across different computers; there'll often be a different number of FPS. Have a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_03_06.jpg" /><div class="caption"><p>FPS is important for the creation of time-based behavior and animations</p></div></div><p>To approximate the concept of a frame, Unity offers three class events that every <code class="literal">MonoBehaviour</code> class can implement to perform functionality that must continually update or change over time. These events have already been seen, but now, we'll consider them in more depth, specifically <code class="literal">Update</code>, <code class="literal">FixedUpdate</code> and <code class="literal">LateUpdate</code>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">Update</code>: The<a id="id269" class="indexterm"></a> <code class="literal">Update</code> event is called <span class="emphasis"><em>once</em></span> per frame for every active component on every active <code class="literal">GameObject</code> in the scene. If an object is deactivated by the <code class="literal">MonoBehaviour.SetActive</code> method, then <code class="literal">Update</code> events will not be called for that object until it is activated. In short, the <code class="literal">Update</code> event most accurately represents the concept of a frame in Unity, so it's useful for performing repetitive behaviors or functionality that must be updated and monitored over time, such as player input events, keyboard presses, and mouse clicks. Note that the order in which <code class="literal">Update</code> events are invoked across all components for each frame is not guaranteed; that is, you cannot be sure whether the <code class="literal">Update</code> function on object X will be called before that on object Y during any one frame.</p></li><li style="list-style-type: disc"><p>
<code class="literal">FixedUpdate</code>: Like <code class="literal">Update</code>, this<a id="id270" class="indexterm"></a> event is typically called multiple times per frame. However, its calling pattern is regular and normalized, with fixed time intervals between each call. The most common use of <code class="literal">FixedUpdate</code> is to work with Unity physics. If you need to update the velocity or properties of a Rigidbody component over time, then <code class="literal">FixedUpdate</code> rather than <code class="literal">Update</code> would be the place to do it.</p></li><li style="list-style-type: disc"><p>
<code class="literal">LateUpdate</code>: This is called on each frame, like <code class="literal">Update</code>. However, <code class="literal">LateUpdate</code> is <a id="id271" class="indexterm"></a>always called after <code class="literal">Update</code> and <code class="literal">FixedUpdate</code>. This means that when <code class="literal">LateUpdate</code> is called, you can be sure that <code class="literal">Update</code> and <code class="literal">FixedUpdate</code> have already been called for every object on the current frame. This makes <code class="literal">LateUpdate</code> a useful place to update camera movement, especially third-person cameras, ensuring that the camera always follows objects at their latest positions on the current frame.</p></li></ul></div><p>The details of <code class="literal">Update</code>, <code class="literal">FixedUpdate</code> and <code class="literal">LateUpdate</code>, in combination with the concepts of time and FPS, have significant implications on how you should or should not code your games when creating motion over time. Specifically, two main guidelines emerge, and these are considered over the next two subsections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>Rule #1 – frames are precious</h3></div></div></div><p>Frames should occur many<a id="id272" class="indexterm"></a> times per second; if they don't, your game will look laggy and broken. On each frame, an <code class="literal">Update</code> event is called once for every active <code class="literal">MonoBehaviour</code> in the scene. This means the computational complexity (and performance) of your scenes on each frame<a id="id273" class="indexterm"></a> depends, in large measure, on what you do inside <code class="literal">Update</code> events. More functionality demands more processing time and workload, either for the CPU or GPU. For large scenes with many objects and components, it would be easy then for things to get out of hand if you don't reduce the workload inside <code class="literal">Update</code> functions by careful code planning. It's important, therefore, to think of <code class="literal">Update</code> events or any regularly called frame-based events as precious. In short, you should only put code inside them when you really need to, such as to read player input or observe cursor movement. It's helpful to start thinking of event-driven programming, as this can help you seriously reduce the workload inserted inside <code class="literal">Update</code> functions. The next chapter considers event-driven programming and event systems.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>Rule #2 – motion must be relative to time</h3></div></div></div><p>As you cannot guarantee<a id="id274" class="indexterm"></a> the frequency of frames (frame rate differs over time and across computers), then you need to code motion and change very carefully to achieve a consistent experience for the gamer. Consider the simple case of moving a cube object in the scene smoothly over time. One way (a bad way) to create<a id="id275" class="indexterm"></a> motion will be as shown in the following code sample 3-10:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Mover : MonoBehaviour
{
  //Amount to move cube per frame
  public float AmountToMove = 1.0f;

  // Update is called once per frame
  void Update ()
  {
    //Move cube along x axis
    transform.localPosition += new Vector3(AmountToMove,0,0);
  }
}</pre></div><p>This code is effective insofar as it will move the attached object by the variable <code class="literal">AmountToMove</code> on each frame. The problem is that it's frame-rate dependent. Now, because frames are inconsistent over time and across computers, each user will ultimately receive a different experience; specifically, they'll see the cube moving at different speeds. This is bad <a id="id276" class="indexterm"></a>because we simply cannot predict how the game will run for any specific user. To fix this, we need to map motion to time as opposed to frames. Frames are variable, but time is constant; one second is exactly that. To achieve this, we can use the <code class="literal">deltaTime</code> variable, which is part of the <code class="literal">Time</code> class. See the following code sample 3-11. This is an amended version of sample 3-10.</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Mover : MonoBehaviour
{
  //Speed of cube
  public float Speed = 1.0f;

  // Update is called once per frame
  void Update ()
  {
    //Move cube along forward direction by speed
<span class="strong"><strong>    transform.localPosition += transform.forward * Speed * Time.deltaTime;</strong></span>
  }
}</pre></div><p>The <code class="literal">deltaTime</code> variable is a floating-point value and always expresses how much time, in seconds, has elapsed since<a id="id277" class="indexterm"></a> the previous <code class="literal">Update</code> function was called. A value of 0.5, for example, means half a second has elapsed since the previous frame and so on. This is useful because <code class="literal">deltaTime</code> can act as a multiplier. By multiplying a speed variable by <code class="literal">deltaTime</code> on each frame, we can know how far an object should move because <span class="emphasis"><em>distance = speed x time</em></span>. Thus, <code class="literal">deltaTime</code> gives us frame-rate independence for object motion.</p></div></div>