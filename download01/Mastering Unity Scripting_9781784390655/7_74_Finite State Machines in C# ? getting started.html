<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec76"></a>Finite State Machines in C# – getting started</h2></div></div><hr /></div><p>Now that the FSM for animation is completed, we should turn our attention to an FSM in C# that governs the<a id="id565" class="indexterm"></a> behavior of the enemy as well as initiates our triggers in the Mecanim graph to play the appropriate animations (walk and run) at the right time. To begin the implementation, add the following public enumeration to the top <a id="id566" class="indexterm"></a>of the <code class="literal">AI_Enemy.cs</code> script file, as shown in the following code sample 7-1. This enumeration defines all the possible states in the FSM for the enemy, and each state is assigned its unique string hash code; that is, the <code class="literal">IDLE</code> state is assigned the value of <code class="literal">2081823275</code>, which is the hash code for the string <code class="literal">IDLE</code>, and so on. This will be important later to work with Mecanim and specifically to initiate triggers. You can retrieve the hash code for a string using the <code class="literal">StringToHash</code> function<a id="id567" class="indexterm"></a> of the <code class="literal">Animator</code> class, as shown here:</p><div class="informalexample"><pre class="programlisting">//Define possible states for enemy
public enum AI_ENEMY_STATE {IDLE = 2081823275,
                            PATROL=207038023,
                            CHASE= 1463555229,
                            ATTACK=1080829965,
                            SEEKHEALTH=-833380208};</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip52"></a>Tip</h3><p>More information<a id="id568" class="indexterm"></a> can be found online at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html" target="_blank">http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html</a>.</p></div><p>On the basis of the enumeration <code class="literal">AI_ENEMY_STATE</code>, the <code class="literal">AI_Enemy</code> class will maintain a public variable <code class="literal">CurrentState</code>, which expresses the active state of the enemy object right now. This variable will change over time as the states change, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">//Current state of enemy
public AI_ENEMY_STATE CurrentState = AI_ENEMY_STATE.IDLE;</pre></div><p>Like most objects, the class <code class="literal">AI_Enemy</code> features an<a id="id569" class="indexterm"></a> <code class="literal">Awake</code> function to retrieve cached component references to other components, including the <code class="literal">NavMeshAgent</code> and the local <code class="literal">Transform</code>, as well as to <a id="id570" class="indexterm"></a>other objects in the scene, such as the <code class="literal">Player</code> object. These references will be used elsewhere in the script, as shown in the<a id="id571" class="indexterm"></a> following code sample 7-2:</p><div class="informalexample"><pre class="programlisting">//Get Animator
ThisAnimator = GetComponent&lt;Animator&gt;();
 
//Get Navigation Mesh Agent
ThisAgent = GetComponent&lt;NavMeshAgent&gt;();
 
//Get Transform Component
ThisTransform = transform;
 
//Get Player Transform
PlayerTransform = GameObject.FindGameObjectWithTag("Player").transform;
 
//Get Collider
ThisCollider = GetComponent&lt;BoxCollider&gt;();</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip53"></a>Tip</h3><p>This code uses cached variables: <code class="literal">ThisAnimator</code>, <code class="literal">ThisTransform</code>, <code class="literal">ThisAgent</code>, and <code class="literal">ThisCollider</code>. This lets us retrieve immediate and direct references to attached components at level startup, which saves us from having to call C# property functions (<code class="literal">get</code> and <code class="literal">set</code>) every time we need access to an object. Thus, <code class="literal">This.Transform</code> carries a greater performance overhead than the optimized, cached variable, <code class="literal">ThisTransform</code>.</p></div><p>Each state in the FSM will be coded as a separate Coroutine, one Coroutine per state. The Coroutine will loop infinitely and exclusively as long as the state is active, defining all behaviors for the enemy in that state. The primary job of the state machine is to select and initiate the<a id="id572" class="indexterm"></a> appropriate state under the correct conditions. Let's start by<a id="id573" class="indexterm"></a> creating the <code class="literal">Idle</code> state—the default or normal state for the enemy.</p></div>