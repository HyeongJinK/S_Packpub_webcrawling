<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec55"></a>Camera rendering and postprocessing</h2></div></div><hr /></div><p>The official Unity documentation<a id="id408" class="indexterm"></a> concerning camera rendering and postprocessing is comparatively sparse. However, this should not be taken as an indication that there's little to be said <a id="id409" class="indexterm"></a>on the subject. On the contrary, Unity cameras and objects offer extensive flexibility over how the scene is rendered. These topics fall under the umbrella term of postprocessing. Specifically, this refers to all the additional edits and amendments made to a camera's rendered output that is not included as part of the normal render. This includes blur effects, color adjustments, fish-eye effects, and so on. It should be said here that access to these features is included only in the professional version of Unity and not in the free version. For this reason, free users will not be able to follow along and complete this section. However, for professional version users, there is a wide range of camera-rendering features available, as shown in the following screenshot. This section considers them by creating a camera change system in which one camera will cross-fade smoothly into another. By cross-fade, I don't simply mean that one<a id="id410" class="indexterm"></a> camera will cut to another, which (incidentally) can be <a id="id411" class="indexterm"></a>achieved by changing a camera's depth field, as higher-order cameras are rendered above lower-order cameras. I rather mean that the rendered output of the first camera will gradually dissolve in opacity to reveal the output of the second camera. So, let's get started.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_05_07.jpg" /><div class="caption"><p>Creating a scene with multiple cameras</p></div></div><p>Start the project with a scene that contains two separate areas or regions, as shown in the preceding screenshot. The sample project is included in the book's companion files (code bundle) inside the <code class="literal">Cameras</code> folder of this chapter. Each region of the scene should be assigned a separate camera; this makes a total of two cameras in the scene, and each camera component should be disabled. This will prevent the cameras from rendering themselves automatically. Here, we'll be rendering the cameras manually; this will allow the render from each camera to be composited and faded on top of the other.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip32"></a>Tip</h3><p>For each camera, the <code class="literal">AudioListener</code> component was removed, because a Unity scene can have only one <code class="literal">AudioListener</code> active at any one time.</p></div><p>Next, create a third camera tagged as <code class="literal">MainCamera</code> at the scene's origin and set with a culling mask of nothing, making<a id="id412" class="indexterm"></a> sure that the camera is active but can render nothing. This<a id="id413" class="indexterm"></a> will represent the central main scene camera that composites together renders from all other cameras, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_05_08.jpg" /><div class="caption"><p>Creating a third main camera for rendering</p></div></div><p>Now, the scene should have three cameras: two separate and disabled cameras at different locations (cameras <span class="strong"><strong>X</strong></span> and <span class="strong"><strong>Y</strong></span>), and one main camera at the scene's origin (camera <span class="strong"><strong>Z</strong></span>). On this basis, the following code sample 5-9 can be assigned to camera <span class="strong"><strong>Z</strong></span>, and this allows fading between cameras <span class="strong"><strong>X</strong></span> and <span class="strong"><strong>Y</strong></span> when Space bar is pressed:</p><div class="informalexample"><pre class="programlisting">001 //Class to fade from camera 0 to 1, and back from 1 to 0
002 //This class assumes there are only two scene cameras
003 //---------------------------------------
004 using UnityEngine;
005 using System.Collections;
006 //---------------------------------------
007 public class CameraFader : MonoBehaviour
008 {
009       //---------------------------------------
010       //All cameras in the scene to be composited
011       public Camera[] Cameras;
012 
013      //Color to multiply with render)
014      public Color[] CamCols = null;
015 
016      //Fade in/out time in seconds 
017       public float FadeTime = 2.0f;
018 
019       //Material used as shader to final render
020       public Material Mat = null;
021       //---------------------------------------
022       // Use this for initialization
023       void Start () 
024       {
025             //Assign render textures to each camera
026             foreach(Camera C in Cameras)
<span class="strong"><strong>027                    C.targetTexture = new RenderTexture(Screen.width, Screen.height, 24); //Create texture</strong></span>

028       }
029       //---------------------------------------
030       //Called once per frame after the camera has 
031       //finished rendering but before the render is shown
032       //Companion function: OnPreRender
<span class="strong"><strong>033        void OnPostRender()</strong></span>
034       {
035            //Define screen rect
036            Rect ScreenRct = new Rect(0,0,Screen.width,Screen.height);
037 
038            //Source Rect
039            Rect SourceRect = new Rect(0,1,1,-1);
040 
041            //Render each camera to their target texture
042            for(int i = 0; i&lt;Cameras.Length; i++)
043             {
044                   //Render camera
045                   Cameras[i].Render();
046 
047                   //Draw textures to screen using camera
048                   GL.PushMatrix();
049                   GL.LoadPixelMatrix();
050                   Graphics.DrawTexture(ScreenRct, Cameras[i].targetTexture, SourceRect, 0,0,0,0, CamCols[i]); 
051                   GL.PopMatrix(); //Reset matrix
052            }
053       }
054       //---------------------------------------
055       //This function is called after OnPostRender
056       //And when final pixels are to be shown on screen
057       //src = current render from camera
058       //dst = texture to be shown on screen
059       void OnRenderImage(RenderTexture src, RenderTexture dst)
060       {
061             //Now push final pixels to screen with Mat
062             Graphics.Blit(src, dst, Mat);
063       }
064       //---------------------------------------
065       //Lerp color over period TotalTime
066      //Fade alpha for topmost rendered camera CamCols[1]
067      public IEnumerator Fade(Color From, Color To, float TotalTime)

068      {
069           float ElapsedTime = 0f;
070 
071            //Loop while total time is not met
072            while(ElapsedTime &lt;= TotalTime)
073             {
074                   //Update color
075                   CamCols[1] = Color.Lerp(From, To, ElapsedTime/TotalTime);
076 
077                  //Wait until next frame
078                  yield return null;
079 
080                 //Update Time
081                 ElapsedTime += Time.deltaTime;
082             }
083 
084            //Apply final color
085             CamCols[1] = Color.Lerp(From, To, 1f);
086     }
087       //---------------------------------------
088       //Sample for testing camera functionality
089       //Press space bar to fade in and out between cameras
090       void Update()
091       {
092             //Fade camera in or out when space is pressed
093             if(Input.GetKeyDown(KeyCode.Space))
094             {
095                   StopAllCoroutines();
096 
097                   //Should we fade out or in
098                   if(CamCols[1].a &lt;= 0f)
099                          StartCoroutine(Fade(CamCols[1], new Color(0.5f,0.5f,0.5f,1f), FadeTime)); //Fade in

100                    else
101                           StartCoroutine(Fade(CamCols[1], new Color(0.5f,0.5f,0.5f,0f), FadeTime)); //Fade out

102            }
103       }
104       //---------------------------------------
105 }</pre></div><p>The following are comments in code sample 5-9:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 011-020</strong></span>: The <code class="literal">CamerFader</code> class is responsible for cross fading between <code class="literal">Camera[0]</code> and <code class="literal">Camera[1]</code>. To achieve this, several variables are created. The <code class="literal">Cameras</code> array maintains a list of cameras: two cameras in this case. The <code class="literal">CamCols</code> array is linked to <code class="literal">Cameras</code>. It describes the color by which the render from<a id="id414" class="indexterm"></a> the camera will be multiplied; this allows the alpha value to make the render transparent. The <code class="literal">FadeTime</code> variable defines the total time in seconds for a camera fade in one direction, either fade-out<a id="id415" class="indexterm"></a> or fade-in. Finally, the <code class="literal">Mat</code> variable references any valid material that will be applied to the final render from the main camera, that is, the pixels of the completed render, including everything composited from all the other cameras.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 023-038</strong></span>: The <code class="literal">Start</code> method creates <code class="literal">RenderTexture</code> for each camera that assigns the texture to its <code class="literal">TargetTexture</code> member. In essence, this means each camera is assigned an internal texture to which its render is locally composited.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 033-052</strong></span>: The <code class="literal">OnPostRender</code> event is called automatically by Unity for any active camera objects in the scene, once for each frame and after the camera has completed its render as normal. It gives the object an opportunity to render additional cameras or elements on top of the normal rendered data. Here, the <code class="literal">Render</code> method of each camera in the <code class="literal">Cameras</code> array is called; this method manually renders the camera, not directly on screen but to its render texture. Once rendered to the texture, the <code class="literal">Graphics.DrawTexture</code> function draws <code class="literal">RenderTexture</code> for each camera onto the screen in the order of the array, one atop the other. Notice that each <code class="literal">DrawTexture</code> call multiplies the <code class="literal">CamCols</code> color to the texture; this also factors in the alpha component for transparency.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 059-063</strong></span>: Like <code class="literal">OnPostRender</code>, the <code class="literal">OnRenderImage</code> event is called automatically on active camera objects by Unity, once per frame. It's called after <code class="literal">OnPostRender</code> and just before the camera render is presented on screen. This event provides two arguments, namely, <code class="literal">src</code> and <code class="literal">dst</code>. The <code class="literal">src</code> argument is a<a id="id416" class="indexterm"></a> reference to a render texture that contains the completed<a id="id417" class="indexterm"></a> render from the camera, which was output from <code class="literal">OnPostRender</code>, and the <code class="literal">dst</code> argument reference defines the render texture that will be shown on screen when the <code class="literal">OnRenderImage</code> event completes. In short, this function gives us an opportunity to edit the pixels of the render either manually in code or via shader. Here, the <code class="literal">Graphics.Blit</code> function is called to copy the source to the destination render texture using the shader associated with the material reference <code class="literal">Mat</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 067-085</strong></span>: <code class="literal">Fade</code> is a <code class="literal">CoRoutine</code> that transitions a <code class="literal">From</code> color to a <code class="literal">To</code> color over the time (<code class="literal">TotalTime</code>). This <code class="literal">CoRoutine</code> method is used to transition the alpha of a camera color between <code class="literal">0</code> and <code class="literal">1</code>, which refer to transparent and opaque, respectively.</p></li></ul></div><p>The following screenshot shows the cross-fading camera effect:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_05_09.jpg" /><div class="caption"><p>Cross-fading cameras</p></div></div></div>