<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec74"></a>Starting an NPC agent</h2></div></div><hr /></div><p>Now, let's create an AI agent for the level, something that can interact with the player. First, the agent needs a<a id="id545" class="indexterm"></a> physical mesh representation in the scene. For this, I used the <code class="literal">Constructor</code> mesh, which is part of the Unity <span class="strong"><strong>Character Controllers</strong></span> package imported earlier. Drag-and-drop this from the <span class="strong"><strong>Project</strong></span> panel into the scene and then remove any animator component that might be created, as shown in the following screenshot. The animations will be important, but a custom-made animator controller will be created later.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_10.jpg" /><div class="caption"><p>Adding a constructor mesh for the enemy character</p></div></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip51"></a>Tip</h3><p>Remember that we're not using the third-person controller prefab; it's just the constructor mesh alone.</p></div><p>Next, add a <code class="literal">NavMeshAgent</code> component to the object by navigating to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Navigation</strong></span> | <span class="strong"><strong>Nav Mesh Agent</strong></span>. This allows the object to work with the navigation mesh, and it is able to find and travel paths when instructed. Set both the <span class="strong"><strong>Radius</strong></span> and <span class="strong"><strong>Height</strong></span> values of the component to<a id="id546" class="indexterm"></a> match the dimensions of the mesh. Set the <span class="strong"><strong>Stopping Distance</strong></span> to <code class="literal">2</code>; this controls how close to a destination that the player should reach before stopping, as shown in the following screenshot. Of course, for your own projects, the <span class="strong"><strong>Stopping Distance</strong></span> value will probably need to be edited.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_11.jpg" /><div class="caption"><p>Configuring a NavMeshAgent component for pathfinding</p></div></div><p>Now, add a <code class="literal">Rigidbody</code> component and enable the <span class="strong"><strong>Is Kinematic</strong></span> checkbox, as shown in the following screenshot. This allows the object to enter trigger volumes and be a part of the physics system by both <a id="id547" class="indexterm"></a>causing and receiving physics events. However, with <span class="strong"><strong>Is Kinematic</strong></span> checked, Unity will not override the object's transformation (position, rotation, and scale). This allows the <code class="literal">NavMeshAgent</code> exclusively to control the movement of the character.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_12.jpg" /><div class="caption"><p>Configuring a Rigidbody component for physics</p></div></div><p>Now, add a <code class="literal">BoxCollider</code> component to the object and enable the <span class="strong"><strong>Is Trigger</strong></span> checkbox to convert it into a trigger volume, that is, a volume that allows physical objects to pass through as opposed to blocking them. This will be used by the AI to approximate an agent's field of view or viewing area. It will follow the agent, and only other objects entering its field are classified as worthy of further consideration. To size the volume to the agent's field of view, use the <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> size fields, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_13.jpg" /><div class="caption"><p>Using a BoxCollider component to configure the field of view for an enemy agent</p></div></div><p>Finally, create a new C# script file, <code class="literal">AI_Enemy.cs</code>, in the project to define the enemy intelligence. This script will encapsulate the complete AI for the enemy character and will be developed over the course of this chapter. Once the file is initially created, attach it to the enemy object<a id="id548" class="indexterm"></a> in the scene. We're now ready to jump into the AI coding and graph building! We'll start by creating FSMs and their attendant states that specify how the enemy should behave.</p></div>