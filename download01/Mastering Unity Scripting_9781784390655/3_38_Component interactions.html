<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec42"></a>Component interactions</h2></div></div><hr /></div><p>We've seen the anatomy of a <code class="literal">GameObject</code> as a collection of components and nothing more. This raises logistical issues about how components should interact and communicate with <a id="id232" class="indexterm"></a>each other. Each component is effectively implemented as a self-contained script file, separate from any other component, yet a component must often interact with others. Specifically, you'll often need to access variables and call functions on other components on the same <code class="literal">GameObject</code>, and you might even need to do this on every frame. This section explores such intercomponent communication.</p><p>One way to call functions on other components is to use <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code>, as shown in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Unity C# Refresher</em></span>. These functions are type agnostic. Specifically, they're functions we might call anywhere in the script to invoke methods by names on <span class="emphasis"><em>all</em></span> other components attached to the same object, regardless of their type. These functions don't care about the component type at all. This makes both <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> convenient to use. However, the problem with them is twofold. First, they're an all or nothing affair; we might call a function by name on all components or on none at all. We can't pick and choose which component the message is dispatched to, because it's always dispatched to them all. Second, both methods (<code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code>) rely internally on reflection, which can cause performance issues when used often, such as by calling these functions in <code class="literal">Update</code> events or, even worse, in <code class="literal">OnGUI</code> events. For these reasons, seek to use alternative methods wherever practically possible. Let's consider these in the following sections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec14"></a>GetComponent</h3></div></div></div><p>If you need direct access to a specific and single component on an object and you know its data type, try using<a id="id233" class="indexterm"></a> <code class="literal">GetComponent</code> as shown in the following code sample 3-1. This function gives you access to the<a id="id234" class="indexterm"></a> first component of a matching type attached to a <code class="literal">GameObject</code>. Once you get a reference to it, you can access the component like any regular object, setting and getting its public variables and invoking its methods:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------------------
04 public class MyCustomComponent : MonoBehaviour
05 {
06   //Reference to transform of object
07   private Transform ThisTransform = null;
08 //-----------------------------------------------------
09   // Use this for initialization
10   void Start ()
11   {
12     //Get cached reference to transform
13     ThisTransform = GetComponent&lt;Transform&gt;();
14   }
15 //-----------------------------------------------------
16   // Update is called once per frame
17   void Update ()
18   {
19     //Update position

20     if(ThisTransform !=null) {ThisTransform.localPosition += Time.deltaTime * 10.0f * ThisTransform.forward;}

21   }
22 //-----------------------------------------------------
23 }
24 //-----------------------------------------------------</pre></div><p>The following are the comments on the code sample 3-1:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 07 and 13</strong></span>: The variable <code class="literal">ThisTransform</code> is declared as private. This variable is assigned a reference to the Transform component attached to the <code class="literal">GameObject</code>, and it achieves this inside the <code class="literal">Start</code> event using the <code class="literal">GetComponent</code> function. In the case of accessing the Transform component specifically, we could also have used an inherited <code class="literal">transform</code> property, such as <code class="literal">ThisTransform= transform;</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 20</strong></span>: Here, the <code class="literal">ThisTransform</code> variable<a id="id235" class="indexterm"></a> is used directly to set the <code class="literal">localPosition</code> of the <code class="literal">GameObject</code>. Again, for the Transform component specifically, we could also have used <code class="literal">transform.localPosition</code>. However, this <a id="id236" class="indexterm"></a>approach internally invokes an extra function call, because the member <code class="literal">transform</code> is a C# property and not a standard variable. More on properties can be found in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Unity C# Refresher</em></span>. For this reason, using <code class="literal">GetComponent</code> inside a <code class="literal">Start</code> or <code class="literal">Awake</code> event to retrieve a component reference to a private class variable is typically one of the most efficient ways to access external components, especially if the component must be accessed regularly, such as inside an <code class="literal">Update</code> function.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>
<span class="strong"><strong>localPosition versus position</strong></span>
</p><p>The Transform<a id="id237" class="indexterm"></a> component exposes two main position members: <code class="literal">position</code> and <code class="literal">localPosition</code>. Setting either of these will change an object's position in specific and distinct ways. The position member always defines an object's position in world space as a measure from the world origin. Setting this variable in script, therefore, might not correspond to the numbers you actually see for the Transform component in the Object Inspector when the object is selected. If your object is a child of another<a id="id238" class="indexterm"></a> object that's not positioned to the world origin, for example, then Unity would offset the object's local position away from its parent, by however much is necessary, to position it at the world space location that is specified. The <code class="literal">localPosition</code> member, in contrast, corresponds directly to the <code class="literal">position</code> value shown for the Transform component in the Object Inspector. Specifically, it specifies the position of an object as a measured offset away from its parent location or else from the world origin if the object has no parent. In the latter case, both the <code class="literal">position</code> and <code class="literal">localPosition</code> members will be identical.</p><p>More information on the <a id="id239" class="indexterm"></a>
<code class="literal">GetComponent</code> function can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html" target="_blank">http://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html</a>.</p><p>You can also access the Unity documentation from the MonoDevelop <span class="strong"><strong>Help</strong></span> menu, by navigating to <span class="strong"><strong>Help</strong></span> | <span class="strong"><strong>Unity API Reference</strong></span>.</p></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec15"></a>Getting multiple components</h3></div></div></div><p>Occasionally, you'll want to retrieve multiple components in a list: sometimes, a list of all components and<a id="id240" class="indexterm"></a> sometimes, a list matching only<a id="id241" class="indexterm"></a> a specific type. You can get this using the <code class="literal">GetComponents</code> function. See the following code sample 3-2. As with the <code class="literal">GetComponent</code> function, it's good practice to call <code class="literal">GetComponents</code> during one-off events such as <code class="literal">Start</code> and <code class="literal">Awake</code> as opposed to frequent events such as <code class="literal">Update</code>:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------------------
04 public class MyCustomComponent : MonoBehaviour
05 {
06   //Reference to all components as array
07   private Component[] AllComponents = null;
08   //-----------------------------------------------------
09   // Use this for initialization
10   void Start ()
11   {
12     //Gets a list of all components attached to this object
13     AllComponents = GetComponents&lt;Component&gt;();
14
15     //Loops through each and list it to the console
16     foreach(Component C in AllComponents)
17     {
18       //Print to console
19       Debug.Log (C.ToString());
20     }
21   }
22 }
23 //-----------------------------------------------------</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"></a>Note</h3><p>
<span class="strong"><strong>More on Components</strong></span>
</p><p>Unity offers additional variations on<a id="id242" class="indexterm"></a> the <code class="literal">GetComponent</code> and <code class="literal">GetComponents</code> functions that facilitate interobject communication and not just communication between components in the same object. These functions include <code class="literal">GetComponentsInChildren</code> to retrieve an accumulative list of all components in all children and also <code class="literal">GetComponentsInParent</code> to retrieve all components in an object's parent.</p><p>More information on the <code class="literal">GetComponents</code> function can be found in the online Unity<a id="id243" class="indexterm"></a> documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Component.GetComponents.html" target="_blank">http://docs.unity3d.com/ScriptReference/Component.GetComponents.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec16"></a>Components and messages</h3></div></div></div><p>The <code class="literal">GetComponent</code> family <a id="id244" class="indexterm"></a>of functions work well and should meet almost all your needs for intercomponent communication. They certainly perform better than either <code class="literal">SendMessage</code> or <code class="literal">BroadcastMessage</code> when used appropriately. Yet, there are situations where it'd be ideal if, given a <code class="literal">GameObject</code>, you could invoke a method with <code class="literal">SendMessage</code> on <span class="emphasis"><em>only one</em></span> component as opposed to all, without having to know anything about the component type in advance. Now, you could achieve this behavior to some extent using delegates<a id="id245" class="indexterm"></a> and interfaces (covered in the next chapter). However, here we'll consider the <code class="literal">SendMessage</code> approach. One scenario where this would be especially useful is for the creation of extendable behaviors. For example, perhaps your game has many enemy types and you need to leave open the possibility of adding more, all of which could be implemented in different ways. Yet, despite their differences, all enemies will need to save their data to a persistent file when the game is saved. It'd then be useful for the enemy to handle an <code class="literal">OnSave</code> function, which will be implemented by a specific component. This is fine, but you want the<a id="id246" class="indexterm"></a> <code class="literal">OnSave</code> function on that component alone to be called by the <code class="literal">SendMessage</code> system. You don't want the method invoked for other components on the object, in case they too handle a function <code class="literal">OnSave</code> that you don't want called inadvertently. In short, you can achieve this using the <code class="literal">Invoke</code> method. Consider the following code sample 3-3:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------------------
04 public class MyCustomComponent : MonoBehaviour
05 {
06   //Reference to component on which function must be called
07   <span class="strong"><strong>public MonoBehaviour Handler = null;</strong></span>
08
09   //-----------------------------------------------------
10   // Use this for initialization
11   void Start ()
12   {
13     //Call function immediately
14 <span class="strong"><strong>    Handler.Invoke("OnSave",0.0f);</strong></span>
15   }
16 }
17 //-----------------------------------------------------</pre></div><p>The following are the comments on the code sample 3-3:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 07</strong></span>: This class features a public reference variable <code class="literal">Handler</code>. Using this field, you can drag-and-drop any component via the Object Inspector into the <code class="literal">Handler</code> slot. This represents the component to which a message will be dispatched. Notice that its class type is <code class="literal">MonoBehaviour</code> or any class derived from this. This means type agnosticism is achieved and we don't need to know the object type in advance.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 14</strong></span>: The <code class="literal">Invoke</code> method of <code class="literal">MonoBehaviour</code> is called to run any method of matching name. The second floating point argument specifies the time in seconds, after which the function should be invoked. A time of 0 specifies immediate invoking.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip17"></a>Tip</h3><p>More information <a id="id247" class="indexterm"></a>on the <code class="literal">Invoke</code> function can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.html</a>.</p></div></li></ul></div></div></div>