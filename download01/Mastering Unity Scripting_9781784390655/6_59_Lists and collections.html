<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec61"></a>Lists and collections</h2></div></div><hr /></div><p>Perhaps, the most common task when programming games is to <a id="id445" class="indexterm"></a>store lists of data. The nature of this data varies tremendously: high scores, player stats, enemy stats, inventory items, weapons, power-ups, level lists, and more. Wherever possible, choose static arrays to hold data due to their speed and efficiency. Static arrays were considered in detail in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Unity C# Refresher</em></span>. In short, static arrays are created ahead of time, and their maximum capacity is fixed from the outset. Items can be added and removed from them at runtime, but their total size can never change. If their maximum capacity is not<a id="id446" class="indexterm"></a> utilized, then space would be wasted. Static arrays, as their name implies, are an excellent choice for storing lists of data that remain constant, such as all levels in the game, all weapons that can possibly be collected, all power-ups that can possibly be collected, and so on.</p><p>However, you'll often need dynamic arrays, which can grow and shrink in capacity to exactly accommodate the data you need as it changes, such as when enemies are spawned and destroyed, inventory items come and go, weapons are collected and discarded, and so on. The Mono Framework offers many classes to maintain lists of data. The three main classes are <code class="literal">List</code>, <code class="literal">Stack</code>, and <code class="literal">Dictionary</code>. Each of these is useful for a specific purpose.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec40"></a>The List class</h3></div></div></div><p>If you need an <a id="id447" class="indexterm"></a>unordered, sequential list<a id="id448" class="indexterm"></a> of items of any single data type, that is, a list that grows and shrinks to match the size of the stored data, then the <code class="literal">List</code> class is ideal. <code class="literal">List</code> is especially good to add and remove<a id="id449" class="indexterm"></a> items and sequentially iterating through all stored items. In addition, the <code class="literal">List</code> objects are editable from the Unity Object Inspector. The following code sample 6-1 uses a sample C# file <code class="literal">Using_List.cs</code>:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
<span class="strong"><strong>03 using System.Collections.Generic;</strong></span>
04 //----------------------------------------
05 //Sample enemy class for holding enemy data
<span class="strong"><strong>06 [System.Serializable]</strong></span>
07 public class Enemy
08 {
09 public int Health = 100;
10 public int Damage = 10;
11 public int Defense = 5;
12 public int Mana = 20;
13 public int ID = 0;
14 }
15 //----------------------------------------
16 public class Using_List : MonoBehaviour 
17 {
18 //----------------------------------------
19 //List of active enemies in the scene
<span class="strong"><strong>20 public List&lt;Enemy&gt; Enemies = new List&lt;Enemy&gt;();</strong></span>
21 //----------------------------------------
22 // Use this for initialization
23 void Start () 
24 {
25        //Add 5 enemies to the list
26        for(int i=0; i&lt;5; i++)
<span class="strong"><strong>27              Enemies.Add (new Enemy()); //Add method inserts item to end of the list</strong></span>
28 
29        //Remove 1 enemy from start of list (index 0)
<span class="strong"><strong>30        Enemies.RemoveRange(0,1);</strong></span>
31 
32        //Iterate through list 
<span class="strong"><strong>33        foreach (Enemy E in Enemies)</strong></span>
34        {
35              //Print enemy ID
36              Debug.Log (E.ID);
37        }
38 }
39 }
40 //----------------------------------------</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip38"></a>Tip</h3><p>More details on using <code class="literal">List</code> can be found in the book's companion files (code bundle) at <code class="literal">Chapter06\Collections</code>. You can also see the <code class="literal">List</code> class reference documentation in<a id="id450" class="indexterm"></a> the MSDN at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx</a>.</p></div><p>The following are the comments for code sample 6-1:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 03</strong></span>: To use the <code class="literal">List</code> class, you must include the <code class="literal">System.Collections.Generic</code> namespace.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 06</strong></span>: If your list data type is declared as a <code class="literal">System.Serializable</code> class, then the list would be shown in the Object Inspector.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 20</strong></span>: You can declare and initialize a new list instance in just one statement inside the class members' declaration.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 27</strong></span>: New objects are immediately added to the end of the list using the <code class="literal">Add</code> method.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 30</strong></span>: Items can be removed using several methods. <code class="literal">RemoveRange</code> lets you delete several consecutive items from the list. Other removal methods include <code class="literal">Remove</code>, <code class="literal">RemoveAll</code>, and <code class="literal">RemoveAt</code>.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 33</strong></span>: You can cycle through all items in a list using a <code class="literal">foreach</code> loop.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 27-33</strong></span>: Generally, don't add or remove items to or from a list while looping through it.</p></li></ul></div><p>The following screenshot shows the <code class="literal">List</code> class in the Object Inspector:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_06_02.jpg" /><div class="caption"><p>Viewing the List class in the Object Inspector</p></div></div><p>The <code class="literal">List</code> class supports several methods to remove items either individually or collectively, and these are intended to be used outside list iterations (loops). However, there are times when it's convenient, or seems simplest, to remove items while iterating through a loop, such as<a id="id451" class="indexterm"></a> when you need to remove each item after processing it. A classic case is when you need to delete all reference type objects in the scene, such as enemies, while also removing their entry in the array to avoid null references. Item removal in a loop, however, can cause problems, because it's easy for an iterator to lose track of where it is and where it should go within the array as the total item count changes during the loop. To loop and remove in one process, you should traverse the array backwards from the end to the start, as opposed to forwards, as shown in the following code sample 6-2:</p><div class="informalexample"><pre class="programlisting"> //Remove all items from a loop 
 void RemoveAllItems()
 {
    //Traverse list backwards
<span class="strong"><strong>    for(int i = Enemies.Count-1; i&gt;=0; i--)</strong></span>
    {
         //Call function on enemy before removal
         Enemies[i].MyFunc();
 
        //Remove this enemy from list
        <span class="strong"><strong>Enemies.RemoveAt(i);</strong></span>
    }
 }</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec41"></a>The Dictionary class</h3></div></div></div><p>The <code class="literal">List</code> class is, perhaps, one of the<a id="id452" class="indexterm"></a> most useful classes in the Mono Framework for in-memory data storage. However, let's not forget the <code class="literal">Dictionary</code> class (similar to the <code class="literal">std::map</code> class in C++). This class is especially useful when <a id="id453" class="indexterm"></a>you need more than just a simple list of items. If you need to search for and get instant access to specific elements based on a key value, then the <code class="literal">Dictionary</code> class is essential. For each item in the list, you must save a corresponding key or ID that uniquely identifies the item from all others. The <code class="literal">Dictionary</code> class then allows you to get instant access to this item, based solely on its key. This makes the <code class="literal">Dictionary</code> class useful as a true dictionary for word games, for example, if you need to look up the meaning or score-value of specific words in a large dictionary or database of words. The word itself would be the key, and the word definition would be the value.</p><p>Now, of course, you can replicate this kind of behavior using multiple <code class="literal">List</code> objects instead of the <code class="literal">Dictionary</code> class. However, the <code class="literal">Dictionary</code> class is extremely fast in terms of performance, almost lightning fast. You can store vast quantities of data inside the dictionary at very little performance cost. This makes them highly valuable for a quick data lookup from key values, as shown in the following code sample 6-3;</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
<span class="strong"><strong>03 using System.Collections.Generic; </strong></span>
04 
05 public class Using_Dictionary : MonoBehaviour 
06 {
07 //Database of words. &lt;Word, Score&gt; key-value pair
<span class="strong"><strong>08 public Dictionary&lt;string, int&gt; WordDatabase = new Dictionary&lt;string, int&gt;();</strong></span>

09 
10 // Use this for initialization
11 void Start () 
12 {
13        //Create some words
14        string[] Words = new string[5];
15        Words[0]="hello";
16        Words[1]="today";
17        Words[2]="car";
18        Words[3]="vehicle";
19        Words[4]="computers";
20 
21        //add to dictionary with scores 
22        foreach(string Word in Words)
23             WordDatabase.Add(Word, Word.Length);
24  
25       //Pick word from list using key value
26       //Uses array syntax! 
27       Debug.Log ("Score is: " + <span class="strong"><strong>WordDatabase["computers"].ToString()</strong></span>);

28 }
29 }</pre></div><p>The following are the <a id="id454" class="indexterm"></a>comments for code sample 6-3:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 03</strong></span>: As with the <code class="literal">List</code> class, you must include the <code class="literal">System.Collections.Generic</code> namespace</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 08</strong></span>: Here, the dictionary is declared and created in one line; unlike the <code class="literal">List</code> class, <code class="literal">Dictionary</code> does not appear in the Unity Object Inspector</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Lines 13-23</strong></span>: The <code class="literal">Dictionary</code> class is populated using the <code class="literal">Add</code> method</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 27</strong></span>: Elements in the <code class="literal">Dictionary</code> class are accessed much like arrays, except by specifying each element using its key data instead of an array index</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"></a>Tip</h3><p>More details on using <code class="literal">Dictionary</code> can be found in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Event-driven Programming</em></span>, when considering event-driven programming with an <code class="literal">EventManager</code>.</p></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec42"></a>The Stack class</h3></div></div></div><p>If you're making a card game <a id="id455" class="indexterm"></a>where players should pick the top<a id="id456" class="indexterm"></a> card from a deck, if you need an undo history, if you're coding customized path finding, or if you're creating a complex spell-casting system or even a Tower of a <a id="id457" class="indexterm"></a>Hanoi puzzle game (<a class="ulink" href="http://en.wikipedia.org/wiki/Tower_of_Hanoi" target="_blank">http://en.wikipedia.org/wiki/Tower_of_Hanoi</a>), the chances are high that you'll need a stack somewhere along the line. A stack is a special kind of list based on<a id="id458" class="indexterm"></a> the <span class="strong"><strong>Last in, first out</strong></span> (<span class="strong"><strong>LIFO</strong></span>) model. The concept is about stacking. You can push items into the list, and these stack up one atop the other in a vertical tower, with the most recently pushed item always at the top. Then, you can pop items from the top of the stack (remove them from the array) one by one. The order in which you pop items is always the inverse of the order in which they were pushed.</p><p>This is why <code class="literal">Stack</code> is especially useful for the undo or rewind functionality. Refer to the following code sample 6-4 for an example on how to use <code class="literal">Stack</code>:</p><div class="informalexample"><pre class="programlisting"> using UnityEngine;
 using System.Collections;
 using System.Collections.Generic;
 //------------------------------------------
 [System.Serializable]
 public class PlayingCard
 {
    public string Name;
    public int Attack;
    public int Defense;
 }
 //------------------------------------------
 public class Using_Stack : MonoBehaviour 
 {
    //------------------------------------------
   //Stack of cards
   public Stack&lt;PlayingCard&gt; CardStack = new Stack&lt;PlayingCard&gt;();
   //------------------------------------------
    // Use this for initialization
    void Start () 
   {
         //Create card array
         PlayingCard[] Cards = new PlayingCard[5];
 
        //Create cards with sample data
        for(int i=0; i&lt;5; i++)
        {
                Cards[i] = new PlayingCard();
                Cards[i].Name = "Card_0" + i.ToString();
                Cards[i].Attack = Cards[i].Defense = i * 3;
  
                //Push card onto stack
                CardStack.Push(Cards[i]);
          }
 
          //Remove cards from stack while(CardStack.Count &gt; 0)
          {
                PlayingCard PickedCard = CardStack.Pop();
 
                //Print name of selected card
                Debug.Log (PickedCard.Name);
          }
   }
   //------------------------------------------
 }
 //------------------------------------------</pre></div></div></div>