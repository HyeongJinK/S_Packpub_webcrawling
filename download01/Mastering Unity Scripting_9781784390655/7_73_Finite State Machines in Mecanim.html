<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec75"></a>Finite State Machines in Mecanim</h2></div></div><hr /></div><p>From this point onwards, we'll <a id="id549" class="indexterm"></a>concentrate mainly on coding AI for the enemy character both in C# and in terms of visual coding for a Mecanim graph. Mecanim refers<a id="id550" class="indexterm"></a> to the Unity's Animation System (<a class="ulink" href="http://docs.unity3d.com/Manual/MecanimAnimationSystem.html" target="_blank">http://docs.unity3d.com/Manual/MecanimAnimationSystem.html</a>). In the upcoming sections, we'll piece together a complete class that looks at and discusses specific sections of code, and the <a id="id551" class="indexterm"></a>full class source code will be pieced together as we go along. It can be viewed in the completed project in the <code class="literal">AI_Enemy.cs</code> file.</p><p>To start, let's examine FSMs conceptually. When thinking about the enemy character, we can observe in them a specific set of behaviors. The enemy begins the scene by standing idle and then proceeds to wander around on patrol. During their patrol, they might see the player character. If they do so, they'll chase the player until the player comes into attack range. When the player enters attack range, they'll attack the player. Now, the only exception to these rules is if the enemy sustains serious health damage that brings them close to death. On reaching critical levels like this, the enemy will, instead of acting aggressively, flee and search for a health-restore potion until their health level is returned to normal.</p><p>In summarizing the enemy behavior sets like this, we've identified a number of discrete and critical states for enemy intelligence. These are idle, patrol, chase, attack, and flee. The enemy can be in one and only one of these states at any one time, and each state determines how the enemy will behave. To implement this logic, we can use an FSM design. This refers not to a specific class or object type (such as <code class="literal">MonoBehaviour</code> or <code class="literal">ScriptableObject</code>) but rather to a design pattern, a way of coding. An FSM begins with a finite set of states (idle, patrol, chase, and so on, as mentioned earlier) and then manages how the states are connected to one another logically. This determines when and how one state changes to another. The enemy for our situation here will depend, in fact, on two-state machines under the hood: one in C# code and the other in a Mecanim animator graph. The latter controls only the animation that should play for the enemy mesh during each state. Let's build the Mecanim graph first.</p><p>Right-click on the <span class="strong"><strong>Project</strong></span> panel and create a new <span class="strong"><strong>Animator Controller</strong></span> asset. Open the asset inside the <span class="strong"><strong>Animator</strong></span> window that is accessible by selecting the <span class="strong"><strong>Animator</strong></span> option in <span class="strong"><strong>Window</strong></span> from the application main menu, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_14.jpg" /><div class="caption"><p>Accessing the animation graph</p></div></div><p>The<a id="id552" class="indexterm"></a> Mecanim animator graph defines all the possible animation states for the mesh, and these should correspond to the enemy states already outlined, namely, idle, patrol, chase, attack, and flee. To <a id="id553" class="indexterm"></a>configure the animations for these <a id="id554" class="indexterm"></a>states, select the <span class="strong"><strong>Constructor</strong></span> mesh asset in the <span class="strong"><strong>Project</strong></span> panel and make all animations loopable by enabling the <span class="strong"><strong>Loop Time</strong></span> and <span class="strong"><strong>Loop Pose</strong></span> checkboxes in the Object Inspector, as shown in the following screenshot. This prevents the character animations from stopping after playing only once:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_15.jpg" /><div class="caption"><p>Preparation of animation assets for a Mecanim FSM</p></div></div><p>Now, let's add animation states to the graph, one animation per state. For the <span class="strong"><strong>Idle</strong></span> state, the idle animation should play. For the <span class="strong"><strong>Patrol</strong></span> state, the walk animation should play as the character should be walking around. For the <span class="strong"><strong>Chase</strong></span> and <span class="strong"><strong>Flee</strong></span> states, the run animation should play, and<a id="id555" class="indexterm"></a> for the <span class="strong"><strong>Attack</strong></span> state, the jump animation should play. The <span class="strong"><strong>Constructor</strong></span> model lacks a dedicated animation for<a id="id556" class="indexterm"></a> attacks, so (for this sample) the jump animation will suffice as an attack animation.</p><p>Go ahead and add these to the graph by dragging-and-dropping each animation from the <span class="strong"><strong>Project</strong></span> panel into the Graph Editor, and name each state as appropriate, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_16.jpg" /><div class="caption"><p>Building an FSM in the Animator window</p></div></div><p>In addition to the standard animation states added so far, let's add an additional empty state too. This will be the initial and default state of the enemy; this state plays no animation and<a id="id557" class="indexterm"></a> represents, effectively, a stateless state until we explicitly put the enemy into a specific state at level startup. To create an empty<a id="id558" class="indexterm"></a> and default state, right-click on the empty space inside the Graph Editor and choose the <span class="strong"><strong>Empty</strong></span> option in <span class="strong"><strong>Create State</strong></span> from the context menu (rename it appropriately to <code class="literal">Start</code> or <code class="literal">Init</code>), and then make it the default state by right-clicking on the state and choosing <span class="strong"><strong>Set As Default</strong></span>, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_17.jpg" /><div class="caption"><p>Setting the empty node as the default state</p></div></div><p>The graph now features one animation per state for the character, but the states are not connected; each<a id="id559" class="indexterm"></a> state is isolated. Specifically, there's no logic that governs the conditions by which one state <a id="id560" class="indexterm"></a>moves to another. To fix this, create five new triggers using the <span class="strong"><strong>Parameters</strong></span> box in the bottom-left corner of the Mecanim window. A trigger variable is a special Boolean type that Unity will automatically reset to <code class="literal">false</code>; every time it's made <code class="literal">true</code>, it allows behaviors to be initiated once, such as state changes. The triggers, as we'll see, can be accessed in C# code.</p><p>For now, create five triggers: <span class="strong"><strong>Idle</strong></span>, <span class="strong"><strong>Patrol</strong></span>, <span class="strong"><strong>Chase</strong></span>, <span class="strong"><strong>Attack</strong></span>, and <span class="strong"><strong>SeekHealth</strong></span>, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_18.jpg" /><div class="caption"><p>Creating a Trigger variable for each animation state</p></div></div><p>With both the states and triggers created, the connection between the states in the graph can now be defined more precisely. Specifically, the <span class="strong"><strong>Idle</strong></span> state should change to the <span class="strong"><strong>Patrol</strong></span> state when<a id="id561" class="indexterm"></a> the trigger <span class="strong"><strong>Patrol</strong></span> is activated, the <span class="strong"><strong>Patrol</strong></span> to the <span class="strong"><strong>Chase</strong></span> state when trigger <span class="strong"><strong>Chase</strong></span> is activated, the <span class="strong"><strong>Chase</strong></span> state to the <span class="strong"><strong>Attack</strong></span> state <a id="id562" class="indexterm"></a>when trigger <span class="strong"><strong>Attack</strong></span> is activated, and so on. In addition, there's a two-way linkage between most states: <span class="strong"><strong>Patrol</strong></span> can transition to <span class="strong"><strong>Chase</strong></span> (such as when the enemy sees the player) and <span class="strong"><strong>Chase</strong></span> can transition back to <span class="strong"><strong>Patrol</strong></span> (when the enemy loses sight of the player). To create connections between states, right-click on a state, select <span class="strong"><strong>Make Transition</strong></span> from the context menu, and then click on the destination state to which a connection should be made.</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_19.jpg" /><div class="caption"><p>Setting the condition for a state transition</p></div></div><p>The graph now defines a complete animation state machine (FSM) for an enemy object. Attaching this to<a id="id563" class="indexterm"></a> the enemy object in the scene is<a id="id564" class="indexterm"></a> simple.</p><p>Add an <span class="strong"><strong>Animator</strong></span> component to the object and then drag-and-drop the <span class="strong"><strong>Animator</strong></span> controller from the <span class="strong"><strong>Project</strong></span> panel into the <span class="strong"><strong>Controller</strong></span> field on the <span class="strong"><strong>Animator</strong></span> component, as shown here:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_20.jpg" /><div class="caption"><p>Attaching Animator to an enemy object</p></div></div></div>