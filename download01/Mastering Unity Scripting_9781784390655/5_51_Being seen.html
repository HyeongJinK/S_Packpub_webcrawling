<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec53"></a>Being seen</h2></div></div><hr /></div><p>There are many occasions during gameplay when questions of object visibility arise, some actual and some hypothetical. Concerning<a id="id382" class="indexterm"></a> the actual occasion, there are several questions we could ask, including whether object X is visible to camera Y right now, whether object X is visible to any camera right now, or when does object X become visible or nonvisible to a specific camera or to any camera. With regard to hypotheticals, we would ask whether object X would be visible if camera Y were moved to position Z. In the actual occasion case, we're concerned with the real visibility of objects for the current frame, based on the positions of all cameras, and concerning hypotheticals, we're concerned with what would be the case if a camera were moved to a specific position. Both these cases are important for games. Knowing whether objects (such as enemy characters) are really visible to the camera is important to define behavior and AI. This is because when objects are not visible, there are many behaviors and calculations we could suspend to save the processing workload. Further, knowing whether an object would become visible if the camera were moved is helpful because it lets us anticipate which objects, if any, will enter visibility for the next frame so that we can prepare them ahead of time. Now, before moving on to consider how these questions can be answered in script, it's worth considering the visibility in its narrowest sense.</p><p>In terms of visibility, there are two main concepts: frustum and occlusion. Each perspective camera has a viewing frustum, as we saw earlier; this frustum is a trapezoidal volume extended outwards from the camera lens and contains a region defined by field of view and clipping plane distance properties. The frustum, in essence, mathematically defines the horizons of a<a id="id383" class="indexterm"></a> camera—the region of a scene that the camera can potentially observe right now. The word, potentially, is significant, because even when an active and visible object is within the camera frustum, it doesn't necessarily mean that it's visible to the camera. This is because objects within the frustum can occlude others also inside the frustum; that is, nearer objects can obscure or conceal objects behind them either fully or partially. For this reason, true visibility tests involve at least two processes: first, determining whether an object is in the frustum, and second, determining whether it is occluded or not. Only if an object passes both tests can it be classified as visible to the camera, and even then, only on the assumption that an object is not concealed or rendered invisible by custom shaders or other postprocess effects. In short, there are many reasons why true visibility testing is an intricate process, but here, I'll take the two-stage test as good enough for most purposes.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec32"></a>Detecting the object visibility</h3></div></div></div><p>Perhaps, the simplest and more<a id="id384" class="indexterm"></a> direct visibility test for objects in Unity is determining when an object becomes visible and invisible to any camera. The two companion events, <code class="literal">OnBecameVisible</code> and <code class="literal">OnBecameInvisible</code>, are called automatically on any object with a renderer component, including <code class="literal">MeshRenderer</code> and <code class="literal">SkinnedMeshRenderer</code>. It's not, of course, called on empty game objects even if they fall within the view of the camera, as they (technically speaking) contain no visible parts, despite all parts being spatially located. You can handle these events, as shown in the following code sample 5-2:</p><div class="informalexample"><pre class="programlisting"> //----------------------------------------------
 using UnityEngine;
 using System.Collections;
 //----------------------------------------------
 public class ViewTester : MonoBehaviour 
 {
    //----------------------------------------------
   void OnBecameVisible()
    {
          Debug.Log ("Became Visible");
    }
    /----------------------------------------------
    void OnBecameInvisible()
    {
          Debug.Log ("Became Invisible");
    }
    //----------------------------------------------
 }
 //----------------------------------------------</pre></div><p>There are several important caveats worth noting with the events <code class="literal">OnBecameVisible</code> and <code class="literal">OnBecameInvisible</code>. First, visibility here only means that an object has come within the camera frustum; thus, it can still be <a id="id385" class="indexterm"></a>occluded by other, nearer objects, and so, it might not be truly visible at all. Second, the events pertain to all cameras and not to specific cameras. <code class="literal">OnBecameVisible</code> is called once to tell you that the object, while previously not visible, has now entered the frustum of at least one camera. Likewise, <code class="literal">OnBecameInvisible</code> is called once and tells you that the object, while previously visible, has now left the frustum of all cameras. Finally, and rather unhelpfully, these functions also include the visibility of the scene camera. This means that if you're testing your game with the <span class="strong"><strong>Scene</strong></span> tab open and visible and the object is visible to you in the <span class="strong"><strong>Scene</strong></span> tab, this will count as being visible. In short, the methods <code class="literal">OnBecameVisible</code> and <code class="literal">OnBecameInvisible</code> would be useful only if your behavior depends on the total visibility or invisibility in the scene, where visibility just corresponds to the frustum's presence. In other words, these events are a great place to toggle behaviors such as AI behaviors that depend on visibility, for example, NPC panic behaviors and other kinds of NPC-to-NPC interactions.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip31"></a>Tip</h3><p>More information on the functions <code class="literal">OnBecameVisible</code> and <code class="literal">OnBecameInvisible</code> can be <a id="id386" class="indexterm"></a>found online in the Unity<a id="id387" class="indexterm"></a> documentation at <a class="ulink" href="http://docs.unity3d.com/ ScriptReference/MonoBehaviour.OnBecameVisible.html" target="_blank">http://docs.unity3d.com/
ScriptReference/MonoBehaviour.OnBecameVisible.html</a> and <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnBecameInvisible.html" target="_blank">http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnBecameInvisible.html</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec33"></a>More on the object visibility</h3></div></div></div><p>Another check that's important, besides<a id="id388" class="indexterm"></a> testing when an object enters and leaves camera visibility, is to test whether an object is visible right now to a specific camera. Unlike <code class="literal">OnBecameVisible</code> and <code class="literal">OnBecameInvisible</code>, which were called on a one-off basis when an object enters or leaves the frustum, this kind of test is about the current state of an object that assumes no prior knowledge of it. To achieve this, the <code class="literal">OnWillRenderObject</code> event can be used. This event is called continuously on an object, once per frame for each camera to which it is visible as long as the object is visible to that camera. "Visible" here is taken to mean "within the camera frustum". Again, no occlusion testing<a id="id389" class="indexterm"></a> is applied. Refer to the following code sample 5-3, and notice that inside this event, the <code class="literal">Camera.current</code> member can be used to retrieve a reference to the camera to which the object is currently visible, including the scene view camera:</p><div class="informalexample"><pre class="programlisting">   void OnWillRenderObject()
   {
        Debug.Log (Camera.current.name);
   }</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec34"></a>Frustum testing – renderers</h3></div></div></div><p>There are many times when the Unity native camera events, as we saw earlier, are not sufficient for your visibility and <a id="id390" class="indexterm"></a>frustum-testing requirements. Specifically, you might simply want to test whether just one specific camera can see a renderer, whether an invisible object would be seen if it were visible, whether a specified<a id="id391" class="indexterm"></a> point in space is seen by the camera, or whether a camera would see a specific object if it were moved to a new location. All of these cases can be important visibility tests in different situations, and all of them require some degree of manual testing. To meet these camera visibility needs, we'll need to code more intensively. The functions in the following sections will be compiled together as static functions in a dedicated <code class="literal">CamUtility</code> class. Let's start by creating a function to test whether a specific renderer component is within the frustum of a specific <code class="literal">Camera</code> object, as shown in the following code sample 5-4:</p><div class="informalexample"><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //---------------------------------------------------------
04 public class CamUtility
05 {
06 //---------------------------------------------------------
07 //Function to determine whether a renderer is within frustum of a specified camera
08 //Returns true if renderer is within frustum, else false
09 public static bool IsRendererInFrustum(Renderer Renderable, Camera Cam)

10 {
11        //Construct frustum planes from camera
12        //Each plane represents one wall of frustrum
13        Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Cam);

14 
15       //Test whether renderable is within frustum planes
16       return GeometryUtility.TestPlanesAABB(planes, Renderable.bounds);

17 }
18 //---------------------------------------------------------
19 }</pre></div><p>From lines 10–17, the <code class="literal">GeometryUtility</code> class is used to generate an array of plane objects that describe the camera frustum. Planes are to 3D space what lines are to 2D space; they mark out a flat, imaginary <a id="id392" class="indexterm"></a>surface in 3D. The frustum planes are a collection of six planes that are rotated and aligned in 3D space to represent the <a id="id393" class="indexterm"></a>complete trapezoidal camera frustum. This array is then used by the <code class="literal">TestPlanesAABB</code> function, <span class="strong"><strong>Axially Aligned Bounding Box</strong></span> (<span class="strong"><strong>AABB</strong></span>), which<a id="id394" class="indexterm"></a> determines whether the collision boundary of a mesh renderer exists inside the frustum as defined by the planes.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec35"></a>Frustum testing – points</h3></div></div></div><p>Of course, you don't always <a id="id395" class="indexterm"></a>want to test renderers for visibility. Instead, you might simply want to test for a point. This might be for two main reasons. First, you might want to know whether an object, such as a particle or a gun target location, is actually visible. Second, you might not only want to know <a id="id396" class="indexterm"></a>whether a point is visible but also where in the screen space; this will be rendered by the camera. The following code sample 5-5 will do this. It will test whether a point is within the camera frustum, and if so, it would further return where the point would be rendered on screen in a normalized viewport space (between 1-0).</p><div class="informalexample"><pre class="programlisting"> //---------------------------------------------------------
 //Determines if point is within frustum of camera
 //Returns true if point is within frustum, else false
 //The out param ViewPortLoc defines the location 
 
public static bool IsPointInFrustum(Vector3 Point, Camera Cam, out Vector3 ViewPortLoc)
    {
         //Create new bounds with no size
         Bounds B = new Bounds(Point, Vector3.zero);
 
        //Construct frustum planes from camera
        //Each plane represents one wall of frustrum

         Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Cam);
 
        //Test whether point is within frustum planes
        bool IsVisible = GeometryUtility.TestPlanesAABB(planes, B);
        //Assign viewport location
        ViewPortLoc = Vector3.zero;
 
       //If visible then get viewport location of point
       if(IsVisible)
                ViewPortLoc = Cam.WorldToViewportPoint(Point);
 
         return IsVisible;
    }
    //---------------------------------------------------------</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec36"></a>Frustum testing – occlusion</h3></div></div></div><p>As mentioned earlier, visibility in its strictest sense is primarily a two-stage and not a one-stage process. All visibility testing so far has consisted only of checking for an object's presence within the frustum <a id="id397" class="indexterm"></a>of a camera. Typically, this is enough, and it should always be preferred. However, sometimes, it's really not enough, because even among objects within the frustum, it's possible for one object to occlude another, as nearer objects can conceal objects further away, either fully or partially. This, in itself, is not always a problem though, because more often than not, the main interest in determining object visibility is simply to know whether the camera is near enough for a set of performance-intensive behaviors (such as AI behaviors) to be enabled. The aim is not truly visibility<a id="id398" class="indexterm"></a> testing, but to know whether the camera is close enough. In these cases, it doesn't matter whether the objects are occluded; it only matters whether they are in the frustum. Yet, occasionally, occlusion matters, such as when displaying GUI elements or pop-up notifications as the player looks at specific objects. In these cases, occlusion is important, because GUI elements should not pop up for objects on the other side of a wall, for example. Sometimes, you can even get around these situations with an inventive use of colliders, triggers, and careful object placement, and sometimes, there's really no choice but to further filter objects in the frustum with occlusion testing. Now, occlusion testing among objects within the frustum is a deep subject that can, via some implementations, have a significant performance overhead. For this reason, one of the best methods is to use a simple <code class="literal">Physics.LineCast</code> method call to determine whether an imaginary line drawn between the camera and destination object is intersected by other colliders. This method usually works well, but its limitations should be recognized. First, it assumes that all visible objects have colliders; any exceptions to this rule will not be detected by the<a id="id399" class="indexterm"></a> <code class="literal">LineCast</code> method. Second, as colliders only approximate the bounds of a mesh and do not wrap around the mesh vertex for vertex, it's possible for the <code class="literal">LineCast</code> method to fail when meshes have internal holes, as the surrounding collider will <a id="id400" class="indexterm"></a>prevent <code class="literal">LineCast</code> from penetrating them. Finally, meshes with transparent materials that reveal objects behind<a id="id401" class="indexterm"></a> them will always fail the <code class="literal">LineCast</code> method. Consider the following code sample 5-6:</p><div class="informalexample"><pre class="programlisting">    //---------------------------------------------------------
    //Function to determine whether an object is visible
    public static bool IsVisible(Renderer Renderable, Camera Cam)
    {
         //If in frustrum then cast line
         if(CamUtility.IsRendererInFrustum(Renderable, Cam))
               return 

//Is direct line between camera and object?
!Physics.Linecast(Renderable.transform.position, Cam.transform.position);
         return false; //No line found or not in frustum
    }
    //---------------------------------------------------------</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec37"></a>Camera vision – front and back</h3></div></div></div><p>In some games, such as <a id="id402" class="indexterm"></a>RTS games or casual games, the camera horizon (or far clipping plane) does not have so great a significance, because the camera always sees everything that is in front of it. In these cases, when objects are outside the <a id="id403" class="indexterm"></a>frustum, they are only outside in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> planes but not in the local <span class="emphasis"><em>z</em></span> axis; that is, the hidden objects are only hidden because the camera is not directly looking at them. However, when the camera is appropriately orientated, objects can never be too far away in the distance to be seen beyond the far clipping plane. In situations like these, visibility tests can often be reduced to faster and simpler orientation tests. Thus, the question changes from, "Is the object within the frustum and not occluded?" to "Is the object in front of the camera or is it behind?" Here, the answer we need is different; the question is not one of visibility but of orientation, whether the camera and its subject are so oriented that the subject is in front of the camera or behind it. To test for this, the vector dot product can be used. The dot product accepts two vectors as input and reduces them to a single dimensional, numerical value as output. This value describes the angular relationship between the two input vectors. In the following code sample 5-7, the <code class="literal">CamFieldView</code> class can be attached to a camera, and it detects whether the camera can see a target object, that is, whether the target object is within a limited field of view in front of the camera:</p><div class="informalexample"><pre class="programlisting"> using UnityEngine;
 using System.Collections;
 //-------------------------------------------------
 public class CamFieldView : MonoBehaviour 
 {
    //-------------------------------------------------
    //Field of view (degrees) in which can see in front of us
    //Measure in degrees from forward vector (left or right)
    public float AngleView = 30.0f;
 
    //Target object for seeing
    public Transform Target = null;
 
    //Local transform
    private Transform ThisTransform = null;
    //-------------------------------------------------
    // Use this for initialization
    void Awake () 
    {
         //Get local transform
         ThisTransform = transform;
    }
    //-------------------------------------------------
     // Update is called once per frame
     void Update ()
    {
         //Update view between camera and target
         Vector3 Forward = ThisTransform.forward.normalized;
         Vector3 ToObject = (Target.position - ThisTransform.position).normalized;
 
         //Get Dot Product
         float DotProduct = Vector3.Dot(Forward, ToObject);
         float Angle = DotProduct * 180f;
 
         //Check within field of view
        if(Angle &gt;= 180f-AngleView)
         {
                  Debug.Log ("Object can be seen");
         }
    }
    //-------------------------------------------------
 }
 //-------------------------------------------------</pre></div></div></div>