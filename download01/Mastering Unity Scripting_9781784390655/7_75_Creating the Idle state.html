<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec77"></a>Creating the Idle state</h2></div></div><hr /></div><p>The enemy object begins in the <code class="literal">Idle</code> state (a "doing nothing" state), which is primarily transitional. In this <a id="id574" class="indexterm"></a>state, the enemies stand where they are, playing the idle animation. The state is entered once at scene startup, but we'll also return to it when exiting some other states, as an intermediary step before moving onto a new state. Effectively, in this state, the enemy should always play the idle animation just once and then leave the state when the animation is completed. The enemy can further move to the <code class="literal">Patrol</code> state automatically, where they begin searching the scene for the player. This involves a two-step process. First, we'll need to start playing the idle animation as the <code class="literal">Idle</code> state begins. Second, we'll need to be notified when the idle animation has completed, to initiate a change to the <code class="literal">Patrol</code> state. Refer to the following code sample 7-3 for the <code class="literal">Idle</code> state:</p><div class="informalexample"><pre class="programlisting">01 //--------------------------------------------------
02 //This coroutine runs when object is in idle state
03 public IEnumerator State_Idle()
04 {
05       //Set current state
06       CurrentState = AI_ENEMY_STATE.IDLE;
07 
08       //Activate idle state with Mecanim
09       ThisAnimator.SetTrigger((int) AI_ENEMY_STATE.IDLE);
10 
11       //Stop nav mesh agent movement 
12        ThisAgent.Stop();
13  
14       //Loop forever while in idle state
15       while(CurrentState == AI_ENEMY_STATE.IDLE)
16        {
17              //Check if we can see player
18              if(CanSeePlayer)
19              {
20                    // can see player?, chase to attack
21                    StartCoroutine(State_Chase());
22                    yield break;
23               }
24 
25              //Wait for next frame
26              yield return null;
27        }
28 }
29 //--------------------------------------------------</pre></div><p>The following are the comments for code sample 7-3:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 03</strong></span>: <code class="literal">State_Idle</code> is coded as a Coroutine. For more information on Coroutines, see the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html" target="_blank">http://docs.unity3d.com/Manual/Coroutines.html</a>. In short, a Coroutine<a id="id575" class="indexterm"></a> works like an asynchronous function (as a code block that runs in the background, parallel to other functions). For this reason, the infinite loop in line 15 will not cause a crash because a Coroutine runs like a separate thread. Coroutines always return type <code class="literal">IEnumerator</code> and always feature a yield statement somewhere within their body.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 09</strong></span>: The<a id="id576" class="indexterm"></a> animator <a id="id577" class="indexterm"></a>
<code class="literal">SetTrigger</code> function is called in this line; it passes the hash code for the string <code class="literal">Idle</code> as an argument to set the <code class="literal">Idle</code> trigger in the Mecanim graph, initiating a playback of the idle animation. This links the C# FSM to the Mecanim FSM. Notice that in line 12, the <code class="literal">Stop</code> function is called for the <code class="literal">NavMeshAgent</code> component to stop any movement that the object might have been performing. This is because while the idle animation is playing, the enemy should not be moving.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 15</strong></span>: Here, the<a id="id578" class="indexterm"></a> <code class="literal">State_Idle</code> function enters an infinite loop; that is, it'll loop frame by frame as long as the enemy is in an <code class="literal">Idle</code> state. While the <code class="literal">Idle</code> state is active, everything within the loop executes every frame that allows the object to update and change its behavior over time.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Line 18</strong></span>: One exit condition for the <code class="literal">Idle</code> state, other than waiting for the idle animation to complete, is if the player is seen in the interim. Player visibility is determined by the Boolean variable <code class="literal">CanSeePlayer</code> (the details of line of sight are considered later). If <code class="literal">CanSeePlayer</code> is <code class="literal">true</code>, the <code class="literal">Chase</code> state is activated using the<a id="id579" class="indexterm"></a> <code class="literal">StartCoroutine</code> function, and the <code class="literal">Idle</code> state is terminated with a call to yield break.</p></li></ul></div><p>The <code class="literal">Idle</code> state, as implemented so far, loops infinitely and never changes to another state unless the player is seen. However, the <code class="literal">Idle</code> state should only be temporary; the idle animation should play once and then notify us of its completion. To achieve this playback notification, we can use Animation Events. To configure this, select the <span class="strong"><strong>Constructor</strong></span> character mesh in the <span class="strong"><strong>Project</strong></span> panel and open the <span class="strong"><strong>Animation</strong></span> tab to examine the idle animation in the Object Inspector. From here, open the <span class="strong"><strong>Events</strong></span> tab, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_21.jpg" /><div class="caption"><p>Expanding the Events tab in the Object Inspector</p></div></div><p>Then, double-click <a id="id580" class="indexterm"></a>on the animation timeline at time <span class="strong"><strong>1</strong></span> (at the end) to insert a function call at that time. This sends a message to the enemy object when the animation completes, as shown in the following screenshot. For this purpose, I've coded a method <code class="literal">OnIdleAnimCompleted</code> inside the <code class="literal">AI_Enemy</code> class:</p><div class="mediaobject"><img src="/graphics/9781784390655/graphics/0655OT_07_22.jpg" /><div class="caption"><p>Calling a function at animation end</p></div></div><p>The function <code class="literal">OnIdleAnimCompleted</code> is called automatically by Unity when the idle animation completes. The following<a id="id581" class="indexterm"></a> code sample 7-4 shows how this method is implemented:</p><div class="informalexample"><pre class="programlisting">   //Event called when Idle animation is completed
   public void OnIdleAnimCompleted()
   {
         //Stop active Idle state
         StopAllCoroutines();
<span class="strong"><strong>         StartCoroutine(State_Patrol());</strong></span>
   }</pre></div></div>