<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec19"></a>Behavior trees</h2></div></div><hr /></div><p>The <span>behavior</span><a id="id288183608" class="indexterm"></a> tree is another pattern used to represent and control the logic behind AI agents. Behavior trees have become popular for applications in AAA games such as <span class="emphasis"><em>Halo</em></span> and <span class="emphasis"><em>Spore</em></span>. Previously, we briefly covered FSMs. They provide a very simple yet efficient way to define the possible behaviors of an agent, based on the different states and transitions between them. However, FSMs are considered difficult to scale as they can get unwieldy fairly quickly and require a fair amount of manual setup. We need to add many states and hardwire many transitions in order to support all the scenarios we want our agent to consider. So, we need a more scalable approach when dealing with large problems. This is where behavior trees come in.</p><p>Behavior trees are a collection of nodes organized in a hierarchical order, in which nodes are connected to parents rather than states connected to each other, resembling branches on a tree, hence the name.</p><p>The basic elements of <span>behavior</span><a id="id288562521" class="indexterm"></a> trees are task nodes, whereas states are the main elements for FSMs. There are a few different tasks such as Sequence, Selector, and Parallel Decorator. It can be a bit daunting to track what they all do. The best way to understand this is to look at an example. Let's break the following transitions and states down into tasks, as shown in the following figure:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/8725b811-6255-46f8-83af-4b03531e2cc2.jpg" /></div><p>Let's look at a Selector task for this behavior tree. Selector tasks are represented by a circle with a question mark inside. The selector will evaluate each child in order, from left to right. First, it'll choose to attack the player; if the <span class="strong"><strong>Attack</strong></span> task returns a success, the Selector task is done and will go back to the parent node, if there is one. If the <span class="strong"><strong>Attack</strong></span> task fails, it'll try the <span class="strong"><strong>Chase</strong></span> task. If the <span class="strong"><strong>Chase</strong></span> task fails, it'll try the <span class="strong"><strong>Patrol</strong></span> task. The following figure shows the basic structure of this tree concept:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/3d2c5259-afa6-4a95-b5fe-bb11587f123a.png" /></div><p>Test is one of the tasks in the <span>behavior</span><a id="id288563756" class="indexterm"></a> tree. The following diagram shows the use of Sequence tasks, denoted by a rectangle with an arrow inside it. The root selector may choose the first Sequence action. This Sequence action's first task is to check whether the player character is close enough to attack. If this task succeeds, it'll proceed with the next task, which is to attack the player. If the <span class="strong"><strong>Attack</strong></span> task also returns successfully, the whole sequence will return as a success, and the selector will be done with this behavior and will not continue with other Sequence tasks. If the proximity check task fails, the Sequence action will not proceed to the <span class="strong"><strong>Attack</strong></span> task, and will return a failed status to the parent selector task. Then the selector will choose the next task in the sequence, <span class="strong"><strong>Lost or Killed Player?</strong></span> The following figure demonstrates this sequence:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/d5a717a4-f964-4e49-ba0d-8ae474fb5040.jpg" /></div><p>The other two common components are parallel tasks and decorators. A parallel task will execute all of its child tasks at the same time, while the Sequence and Selector tasks only execute their child tasks one by one. Decorator is another type of task that has only one child. It can change the behavior of its own child's tasks including whether to run its child's task or not, how many times it should run, and so on. We'll study how to implement a basic behavior tree system in Unity in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Behavior Trees</em></span>.</p></div>