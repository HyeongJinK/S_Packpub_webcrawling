<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec55"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we dug into how a behavior tree works, and then we looked at each individual type of node that can make up a behavior tree. We also learned the different scenarios where some nodes would be more helpful than others. After looking at some off-the-shelf solutions available in the Unity asset store, we applied this knowledge by implementing our own basic behavior tree framework in C# and explored its inner workings. With the knowledge and the tools out of the way, we created a sample behavior tree using our framework to test the concepts learned throughout the chapter. We then went on to explore the implementation of <span class="emphasis"><em>HomeRock</em></span>, a sample card game that showcases an AI opponent. This knowledge prepares us to harness the power of behavior trees in games and take our AI implementations to the next level.</p><p>In the next chapter, <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Using Fuzzy Logic to Make Your AI Seem Alive</em></span>, we'll look at new ways to add complexity and functionality to the concepts we've learned in this chapter, modifying behavior trees and FSMs, which we covered in <a class="link" href="#" linkend="ch02">Chapter 2</a><span class="emphasis"><em>,</em></span><span class="emphasis"><em>Finite State Machines and You</em></span>, via the concept of fuzzy logic.</p><p> </p><p> </p></div>