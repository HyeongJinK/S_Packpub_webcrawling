<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec40"></a>A* Pathfinding</h2></div></div><hr /></div><p>Next up, we'll  implement the A* algorithm in a Unity <span>environment</span><a id="id288183632" class="indexterm"></a> using C#. The A* Pathfinding algorithm is widely used in games and interactive applications even though there are other algorithms, such as Dijkstra's algorithm, because of its simplicity and effectiveness. We've briefly covered this algorithm previously, in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>The Basics of AI in Games</em></span>, but let's review the algorithm again from an implementation perspective.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec27"></a>Revisiting the A* algorithm</h3></div></div></div><p>We briefly touched on the A* algorithm earlier in the book, so let's <span>review</span><a id="id288559441" class="indexterm"></a> the basics before we dive into our implementation. For starters, we need to create a grid-based representation of our map. The best option for this is a 2D array. This grid and all of its associated data will be contained in our <code class="literal">GridManager</code> class. The <code class="literal">GridManager</code> class will contain a list of <code class="literal">Node</code> objects that represent each cell in our grid. The nodes themselves will contain some additional data about themselves, such as their heuristic cost and whether or not they are an obstacle node.</p><p>We'll also need to keep two lists—our open list, that is, our list of nodes to explore, and our closed list, which will contain nodes we've already visited. We'll implement these in our <code class="literal">PriorityQueue</code> class, which provides some additional helper functionality.</p><p>In essence, our A* algorithm, implemented in the <code class="literal">AStar</code> class, must do the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Begin at the starting node and put it in the open list.</li><li>As long as the open list has some nodes in it, we'll perform the following processes:
<div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Pick the first node from the open list and keep it as the current node. (This is assuming that we've sorted the open list and the first node has the least cost value, which will be mentioned at the end of the code.)</li><li>Get the neighboring nodes of this current node that are not obstacle types, such as a wall or canyon, that can't be passed through.</li><li>For each neighbor node, check if this neighbor node is already in the closed list. If not, we'll calculate the total cost (<code class="literal">F</code>) for this neighbor node using the following formula:</li></ol></div></li></ol></div><pre class="programlisting">F = G + H</pre><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>In the preceding formula, <code class="literal">G</code> is the total cost from the start node to this node and <code class="literal">H</code> is the total cost from this node to the final target node.</li><li>Store this cost data in the neighbor node object. Also, store the current node as the parent node as well. Later, we'll use this parent node data to trace back the actual path.</li><li>Put this neighbor node in the open list. Sort the open list in ascending order, ordered by the total cost to reach the target node.</li><li>If there are no more neighbor nodes to process, put the current node in the closed list and remove it from the open list.</li><li>Go back to step 2 using the next node in the open list.</li></ol></div></li></ol></div><p>Once you have completed this process, your current node should be in the target goal node position, but only if there's an obstacle-free path to reach the goal node from the start node. If it is not at the goal node, there's no available path to the target node from the current node position. If there's a valid path, all we have to do now is trace back from the current node's parent node until we reach the start node again. This will give us a path list of all the nodes that we chose during our pathfinding process, ordered from the target node to the start node. We then just reverse this path list, since we want to know the path from the start node to the target goal node.</p><p>This is a general overview of the algorithm we're going to implement in Unity using C#. So, let's get started.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec28"></a>Implementation</h3></div></div></div><p>In order to get started with A*, we'll have to take the <span>concepts</span><a id="id288562524" class="indexterm"></a> and apply them as concrete implementations in the code. In our sample code, we break the A* system into a few key components: the <code class="literal">Node</code>, <code class="literal">GridManager</code>, <code class="literal">PriorityQueue</code>, and <code class="literal">AStart</code> classes.</p><p>Let's break down what each class does in the following few sections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec5"></a>The Node class</h4></div></div></div><p>We can think of the <code class="literal">Node</code> class as a container for all of the relevant information about each tile in our grid. We store <span>information</span><a id="id288563738" class="indexterm"></a> about things such as the cost of the node, the parent of the node, and its position:</p><pre class="programlisting">using UnityEngine;
using System;

public class Node : IComparable
{
    //Total cost so far for the node
    public float gCost;
    //Estimated cost from this node to the goal node
    public float hCost;
    //Is this an obstacle node
    public bool bObstacle;
    //Parent of the node in the linked list
    public Node parent;
    //Position of the node in world space
    public Vector3 position; 

    public Node()
    {
        hCost = 0.0f;
        gCost = 1.0f;
        bObstacle = false;
        parent = null;
    }

    public Node(Vector3 pos)
    {
        hCost = 0.0f;
        gCost = 1.0f;
        bObstacle = false;
        parent = null;

        position = pos;
    }

    public void MarkAsObstacle()
    {
        bObstacle = true;
    }

    //IComparable Interface method implementation
    public int CompareTo(object obj)
    {
        Node node = (Node)obj;
        if (hCost &lt; node.hCost) 
        {
            return -1;
        }
        if (hCost &gt; node.hCost) 
        {
            return 1;
        }
        return 0;
    }
}</pre><p>In code, we represent our G and H costs as <code class="literal">gCost</code> and <code class="literal">hCost</code>, respectively. G refers to the cost from the start node to this node, and H refers to the estimated cost from this node to the end node. Depending on how comfortable you get with A*, you might consider renaming them something a bit more descriptive. In our example, we want to adhere as closely as possible to the <span class="emphasis"><em>on paper</em></span> version of the names of concepts, for the purpose of explaining the C# implementation.</p><p>The class provides a simple constructor that takes no arguments, and one overload that takes in a position, which prepopulates the position field with the passed-in value. There's nothing too fancy here. </p><p>You may have noticed that our class implements the <code class="literal">IComparable</code> interface, which requires us to implement the <code class="literal">CompareTo()</code> method to satisfy the interface contract requirements. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>You can think of an interface as a contract. On its own, it does nothing. You cannot implement any logic in an interface. By inheriting from an interface, you're simply agreeing to implement all the methods with the provided signatures in the implementing class. That way, any other class that wants to call a given method from an interface on your class can assume that the method exists.</p></div><p>The actual implementation of the method compares the given node to this node based on their <code class="literal">hCost</code>. We'll take a look at its usage later on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec6"></a>Establishing the priority queue</h4></div></div></div><p>We represent our open and closed list using the <code class="literal">PriorityQueue</code> class. This approach allows us to <span>implement</span><a id="id288566560" class="indexterm"></a> some helper methods for our own convenience. The <code class="literal">PriorityClass.cs</code> file looks like this:</p><pre class="programlisting">using System.Collections;

public class PriorityQueue 
{
    private ArrayList nodes = new ArrayList();

    public int Length
    {
        get { return nodes.Count; }
    }

    public bool Contains(object node)
    {
        return nodes.Contains(node);
    }

    public Node GetFirstNode()
    {
        if (nodes.Count &gt; 0)
        {
            return (Node)nodes[0];
        }
        return null;
    }

    public void Push(Node node)
    {
        nodes.Add(node);
        nodes.Sort();
    }

    public void Remove(Node node)
    {
        nodes.Remove(node);
        nodes.Sort();
    }
}</pre><p>There isn't much of note in this code, but the <code class="literal">Sort()</code> method in particular is interesting. Remember the <code class="literal">CompareTo()</code> method in the <code class="literal">Node</code> class? The <code class="literal">ArrayList.Sort()</code> actually relies on the implementation of <code class="literal">CompareTo()</code> in the node class to sort the array. More specifically, it will sort according to the node's <code class="literal">hCost</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec7"></a>Setting up our grid manager</h4></div></div></div><p>The <code class="literal">GridManager</code> class does a lot of the heavy lifting in <span>terms</span><a id="id288568563" class="indexterm"></a> of arranging and visualizing our grid. Compared to some of the code we've seen so far in this book, it's a fairly lengthy class, since it provides several helper methods. Pop open the <code class="literal">GridManager.cs</code> class to follow along:</p><pre class="programlisting"> [SerializeField]
 private int numberOfRows = 20;
 [SerializeField]
 public int numberOfColumns = 20;
 [SerializeField]
 public float gridCellSize = 2;
 [SerializeField]
 public bool showGrid = true;
 [SerializeField]
 public bool showObstacleBlocks = true;

 private Vector3 origin = new Vector3();
 private GameObject[] obstacleList;
 private Node[,] nodes { get; set; } </pre><p>We start off by setting up some variables. We specify how many rows and columns are in our grid, and we specify their size (in world units). There isn't much else of note here, but we should point out that the <code class="literal">Node[,]</code> syntax indicates that we are initializing a 2D array of <code class="literal">nodes</code>, which makes sense, since a grid is a 2D array itself.</p><p>In our <code class="literal">Awake</code> method, we see the following line:</p><pre class="programlisting">obstacleList = GameObject.FindGameObjectsWithTag("Obstacle");</pre><p>This simply initializes the <code class="literal">obstacleList</code> game object array by finding things tagged as <code class="literal">"Obstacle"</code>. <code class="literal">Awake</code> then calls two setup methods: <code class="literal">InitializeNodes()</code> and <code class="literal">CalculateObstacles()</code>:</p><pre class="programlisting">private void InitializeNodes() 
{
    nodes = new Node[numberOfColumns, numberOfRows];

    int index = 0;
    for (int i = 0; i &lt; numberOfColumns; i++) 
    {
        for (int j = 0; j &lt; numberOfRows; j++) 
        {
            Vector3 cellPosition = GetGridCellCenter(index);
            Node node = new Node(cellPosition);
            nodes[i, j] = node;
            index++;
        }
    }
}</pre><p>The names of these methods are to the point, so as you may have guessed, <code class="literal">InitializeNodes()</code> initializes our nodes, and does so by populating the <code class="literal">nodes</code> 2D array. This code invokes a helper method, <code class="literal">GetGridCellCenter()</code>, which we'll look at later on, but the approach is fairly straightforward. We loop through the 2D array, column by column and row by row, and we create nodes spaced apart according to the grid size:</p><pre class="programlisting">private void CalculateObstacles()
{
    if (obstacleList != null &amp;&amp; obstacleList.Length &gt; 0)
    {
        foreach (GameObject data in obstacleList)
        {
            int indexCell = GetGridIndex(data.transform.position);
            int column = GetColumnOfIndex(indexCell);
            int row = GetRowOfIndex(indexCell);

            nodes[row, column].MarkAsObstacle();
        }
    }
}</pre><p>The <code class="literal">CalculateObstacles()</code> method simply runs through the list of obstacles we initialized during <code class="literal">Awake</code>, determines which grid slot the obstacle occupies, and marks the node at that grid slot as an obstacle using <code class="literal">MarkAsObtacle()</code>.</p><p>The <code class="literal">GridManager</code> class has a few helper methods to traverse the grid and get the grid cell data. The following is a list of some of them with brief descriptions of what they do. The implementation is simple, so we won't go into the details:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">GetGridCellCenter</code>: Given an index for a cell, it returns the center position (in world space) of that cell.</li><li style="list-style-type: disc"><code class="literal">GetGridCellPositionAtIndex</code>: Returns the origin position of the cell (the corner). Used as a helper for <code class="literal">GetGridCellCenter</code>.</li><li style="list-style-type: disc"><code class="literal">GetGridIndex</code>: Given a position (as a <code class="literal">Vector3</code> in world space), it returns the cell closest to the position.</li><li style="list-style-type: disc"><code class="literal">GetRowOfIndex</code> and <code class="literal">GetColumnOfIndex</code>: Just as the names say, they return the row or column of the cell at the given index. For example, in a 2 x 2 grid, the cell at index 2 (starting from 0), would be in row 2, column 1.</li></ul></div><p>Next, we have some methods that help with figuring out the neighbors to a given node:</p><pre class="programlisting">public void GetNeighbors(Node node, ArrayList neighbors)
{
    Vector3 neighborPosition = node.position;
    int neighborIndex = GetGridIndex(neighborPosition);

    int row = GetRowOfIndex(neighborIndex);
    int column = GetColumnOfIndex(neighborIndex);

    //Bottom
    int leftNodeRow = row - 1;
    int leftNodeColumn = column;
    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);

    //Top
    leftNodeRow = row + 1;
    leftNodeColumn = column;
    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);

    //Right
    leftNodeRow = row;
    leftNodeColumn = column + 1;
    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);

    //Left
    leftNodeRow = row;
    leftNodeColumn = column - 1;
    AssignNeighbor(leftNodeRow, leftNodeColumn, neighbors);
}

// Check the neighbor. If it's not an obstacle, assign the neighbor.
private void AssignNeighbor(int row, int column, ArrayList neighbors)
{
    if (row != -1 &amp;&amp; column != -1 &amp;&amp; row &lt; numberOfRows &amp;&amp; column &lt; numberOfColumns)
    {
        Node nodeToAdd = nodes[row, column];
        if (!nodeToAdd.bObstacle)
        {
            neighbors.Add(nodeToAdd);
        }
    } 
}</pre><p>First, we have <code class="literal">GetNeighbors()</code>, which uses the given node's position in the grid to figure out which cells are to the bottom, top, right, and left of it. It assigns the node as a neighbor using <code class="literal">AssignNeighbor()</code>, which does some validation, such as checking that the potential neighbor is within bounds (of the array), and that the neighbor is not marked as an obstacle.</p><p>Lastly, we have <code class="literal">OnDrawGizmos()</code> and <code class="literal">DebugDrawGrid()</code>, which display the grid of the size we specified in our scene view for debugging. Next up, the meat and potatoes. We tie it all together with our <code class="literal">AStar</code> class.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec8"></a>Diving into our A* implementation</h4></div></div></div><p>The <code class="literal">AStar</code> class is the actual implementation of the A* algorithm. This is where the <span>magic</span><a id="id288573789" class="indexterm"></a> happens. The code in the <code class="literal">AStar.cs</code> file looks like this:</p><pre class="programlisting">using UnityEngine;
using System.Collections;

public class AStar
{
    public static PriorityQueue closedList;
    public static PriorityQueue openList;

    private static ArrayList CalculatePath(Node node)
    {
        ArrayList list = new ArrayList();
        while (node != null)
        {
            list.Add(node);
            node = node.parent;
        }
        list.Reverse();
        return list;
    }


    /// Calculate the estimated Heuristic cost to the goal 
    private static float EstimateHeuristicCost(Node curNode, Node goalNode)
    {
        Vector3 vecCost = curNode.position - goalNode.position;
        return vecCost.magnitude;
    }

    // Find the path between start node and goal node using A* Algorithm
    public static ArrayList FindPath(Node start, Node goal)
    {
        openList = new PriorityQueue();
        openList.Push(start);
        start.gCost = 0.0f;
        start.hCost = EstimateHeuristicCost(start, goal);

        closedList = new PriorityQueue();
        Node node = null;
        GridManager gridManager = GameObject.FindObjectOfType&lt;GridManager&gt;();
        if(gridManager == null) {
            return null;
        }

        while (openList.Length != 0)
        {
            node = openList.GetFirstNode();

            if (node.position == goal.position)
            {
                return CalculatePath(node);
            }

            ArrayList neighbors = new ArrayList();
            gridManager.GetNeighbors(node, neighbors);

            //Update the costs of each neighbor node.
            for (int i = 0; i &lt; neighbors.Count; i++)
            {
                Node neighborNode = (Node)neighbors[i];

                if (!closedList.Contains(neighborNode))
                { 
                  //Cost from current node to this neighbor node
                  float cost = EstimateHeuristicCost(node, neighborNode); 

                  //Total Cost So Far from start to this neighbor node
                  float totalCost = node.gCost + cost;

                  //Estimated cost for neighbor node to the goal
                  float neighborNodeEstCost = EstimateHeuristicCost(neighborNode, goal); 

                  //Assign neighbor node properties
                  neighborNode.gCost = totalCost;
                  neighborNode.parent = node;
                  neighborNode.hCost = totalCost + neighborNodeEstCost;

                  //Add the neighbor node to the open list if we haven't already done so.
                  if (!openList.Contains(neighborNode))
                  {
                      openList.Push(neighborNode);
                  }
                }
            } 
            closedList.Push(node);
            openList.Remove(node);
        }

        //We handle the scenario where no goal was found after looping thorugh the open list
        if (node.position != goal.position)
        {
            Debug.LogError("Goal Not Found");
            return null;
        }

        //Calculate the path based on the final node
        return CalculatePath(node);
    }
}</pre><p>There is quite a bit to go over here, so let's break it down, step by step:</p><pre class="programlisting"> public static PriorityQueue closedList;
 public static PriorityQueue openList;</pre><p>We start off by declaring our open and closed lists, which will contain visited and non-visited nodes, respectively:</p><pre class="programlisting">private static float EstimateHeuristicCost(Node currentNode, Node goalNode)
{
    Vector3 cost= currentNode.position - goalNode.position;
    return cost.magnitude;
}</pre><p>In the preceding code, we implement a method called <code class="literal">EstimateHeuristicCost</code> to calculate the cost between the two given nodes. The calculation is simple. We just find the direction vector <span>between</span><a id="id288573826" class="indexterm"></a> the two by subtracting one position vector from another. The magnitude of this resultant vector gives the direct distance from the current node to the goal node.</p><p>Next, we have our <code class="literal">FindPath</code> method, which does most of the work:</p><pre class="programlisting">  public static ArrayList FindPath(Node start, Node goal)
  {
      openList = new PriorityQueue();
      openList.Push(start);
      start.gCost = 0.0f;
      start.hCost = EstimateHeuristicCost(start, goal);

      closedList = new PriorityQueue();
      Node node = null;

      GridManager gridManager = GameObject.FindObjectOfType&lt;GridManager&gt;();
      if(gridManager == null) {
          return null;
      }</pre><p>It initializes our open and closed lists. At first, we'll only have the starting node in our <code class="literal">openList</code>. We also initialize the <code class="literal">gCost</code>, which is zero, because the distance to the starting node (itself) is zero. We then assign the <code class="literal">hCost</code> using the <code class="literal">EstimateHeuristicCost()</code> method we just discussed.</p><p>We'll need a reference to our <code class="literal">GridManager</code> going forward, so we get it using <code class="literal">FindObjectOfType()</code> and do some null checking. Next, we begin processing the open list:</p><pre class="programlisting">   while (openList.Length != 0)
   {
       node = openList.GetFirstNode();

       if (node.position == goal.position)
       {
           return CalculatePath(node);
       }

       ArrayList neighbors = new ArrayList();
       gridManager.GetNeighbors(node, neighbors);

       //Update the costs of each neighbor node.
       for (int i = 0; i &lt; neighbors.Count; i++)
       {
           Node neighborNode = (Node)neighbors[i];

           if (!closedList.Contains(neighborNode))
           { 
               //Cost from current node to this neighbor node
               float cost = EstimateHeuristicCost(node, neighborNode); 

               //Total Cost So Far from start to this neighbor node
               float totalCost = node.gCost + cost;

               //Estimated cost for neighbor node to the goal
               float neighborNodeEstCost = EstimateHeuristicCost(neighborNode, goal); 

               //Assign neighbor node properties
               neighborNode.gCost = totalCost;
               neighborNode.parent = node;
               neighborNode.hCost = totalCost + neighborNodeEstCost;

               //Add the neighbor node to the open list if we haven't already done so.
               if (!openList.Contains(neighborNode))
               {
                   openList.Push(neighborNode);
               }
             }
         } 
         closedList.Push(node);
         openList.Remove(node);
     }

     //We handle the scenario where no goal was found after looping thorugh the open list
     if (node.position != goal.position)
     {
         Debug.LogError("Goal Not Found");
         return null;
     }

     //Calculate the path based on the final node
     return CalculatePath(node);
 }</pre><p>This code implementation resembles the  A* algorithm that we have previously discussed. This would be a good time to brush up on it.</p><p>In plain English, the preceding code can be <span>described</span><a id="id288566402" class="indexterm"></a> as following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Get the first node of our <code class="literal">openList</code>. Keep in mind that our <code class="literal">openList</code> is always sorted after a new node is added so that the first node is always the node with the lowest estimated cost to the goal node.</li><li>Check whether the current node is already at the goal node. If so, exit the <code class="literal">while</code> loop and build the <code class="literal">path</code> array.</li><li>Create an array list to store the neighboring nodes of the current node being processed. Use the <code class="literal">GetNeighbors()</code> method to retrieve the neighbors from the grid.</li><li>For every node in the <code class="literal">neighbors</code> array, we check whether it's already in the <code class="literal">closedList</code>. If not, we calculate the cost values, update the node properties with the new cost values as well as the parent node data, and put it in <code class="literal">openList</code>.</li><li>Push the current node to <code class="literal">closedList</code> and remove it from <code class="literal">openList</code>. Rinse and repeat.</li></ol></div><p>If there are no more nodes in the <code class="literal">openList</code>, our current node should be at the target node if there's a valid path available. Then, we just call the <code class="literal">CalculatePath()</code> method with the current node as the argument. The <code class="literal">CalcualtePath()</code> method looks like this:</p><pre class="programlisting">private static ArrayList CalculatePath(Node node) 
{ 
    ArrayList list = new ArrayList(); 
    while (node != null) 
    { 
      list.Add(node); 
      node = node.parent; 
    } 
    list.Reverse(); 
    return list; 
} </pre><p>The <code class="literal">CalculatePath</code> method traces through each node's parent node object and builds an array list. This gives us an array list with nodes from the target node to the start node. Since we want a path array from the start node to the target node, we just call the <code class="literal">Reverse</code> method. And that's it! With our algorithm and helper classes out of the way, we can move on to our test script, which ties it all together. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec9"></a>Implementing a TestCode class</h4></div></div></div><p>Now that we have the A* algorithm implemented via our <code class="literal">AStar</code> class (and the associated helper classes), we actually implement it using the <code class="literal">TestCode</code> class. The <code class="literal">TestCode.cs</code> file <span>looks</span><a id="id288320296" class="indexterm"></a> like this:</p><pre class="programlisting">using UnityEngine;
using System.Collections;

public class TestCode : MonoBehaviour 
{
    private Transform startPosition;
    private Transform endPosition;

    public Node startNode { get; set; }
    public Node goalNode { get; set; }

    private ArrayList pathArray;

    private GameObject startCube;
    private GameObject endCube;

    private float elapsedTime = 0.0f;
    public float intervalTime = 1.0f; 
    private GridManager gridManager;</pre><p>We declare our variables here, and once again set up a variable to hold a reference to our <code class="literal">GridManager</code>. Then, the <code class="literal">Start</code> method does some initialization and fires off our <code class="literal">FindPath()</code> method, as shown in this code:</p><pre class="programlisting">
  private void Start () 
  {
      gridManager = FindObjectOfType&lt;GridManager&gt;();
      startCube = GameObject.FindGameObjectWithTag("Start");
      endCube = GameObject.FindGameObjectWithTag("End");

      //Calculate the path using our AStart code.
      pathArray = new ArrayList();
      FindPath();
  }

  private void Update () 
  {
      elapsedTime += Time.deltaTime;

</pre><pre class="programlisting">      if(elapsedTime &gt;= intervalTime)
      {
          elapsedTime = 0.0f;
          FindPath();
      }
  }</pre><p>In the <code class="literal">Update</code> method, we check for the path at intervals, which is a brute force approach to refreshing the path if the goal moves at runtime. You may want to consider implementing this code using an event to avoid unnecessary overhead in every frame (or interval, in this case).  The <code class="literal">FindPath()</code> method called in <code class="literal">Start</code> looks like this:</p><pre class="programlisting">private void FindPath()
{
    startPosition = startCube.transform;
    endPosition = endCube.transform;

    startNode = new Node(gridManager.GetGridCellCenter(gridManager.GetGridIndex(startPosition.position)));
    goalNode = new Node(gridManager.GetGridCellCenter(gridManager.GetGridIndex(endPosition.position)));

    pathArray = AStar.FindPath(startNode, goalNode);
}</pre><p>First, it takes the positions of our start and end game objects. Then, it creates new <code class="literal">Node</code> objects using the helper methods <code class="literal">GridManager</code> and <code class="literal">GetGridIndex</code> to calculate their respective row and column index positions inside the grid. With those necessary values ready to go, we just call the <code class="literal">AStar.FindPath</code> method with the start node and goal node, and store the <span>returned</span><a id="id288320361" class="indexterm"></a> array list in the local <code class="literal">pathArray</code> variable.</p><p>Next, we implement the <code class="literal">OnDrawGizmos</code> method to draw and visualize the path found:</p><pre class="programlisting">private void OnDrawGizmos()
{
    if (pathArray == null) 
    {
        return;
    }

    if (pathArray.Count &gt; 0)
    {
        int index = 1;
        foreach (Node node in pathArray)
        {
            if (index &lt; pathArray.Count)
            {
                Node nextNode = (Node)pathArray[index];
                Debug.DrawLine(node.position, nextNode.position, Color.green);
                index++;
            }
        };
    }
}</pre><p>We look through our <code class="literal">pathArray</code> and use the <code class="literal">Debug.DrawLine</code> method to draw the lines connecting the nodes from the <code class="literal">pathArray</code>. With this, we'll be able to see a green line connecting the nodes from start to end, forming a path, when we run and test our game.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec10"></a>Testing it in the sample scene</h4></div></div></div><p>The <span>sample</span><a id="id288320402" class="indexterm"></a> scene looks like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/828b7a39-70e9-4534-8e6b-0fc59638d6d6.png" /></div><p>Our sample scene with the pathfinding grid drawn over it</p><p>As you can see in the preceding screenshot, there is a red starting node, a green goal node, a plane, and some light grey obstacles.</p><p>The following screenshot is a snapshot of our scene hierarchy:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/abc4b063-d524-4c41-98c4-862b4a2534d9.png" /></div><p>There are a few things to note in the preceding screenshot (and yes, you can ignore the <strong class="userinput"><code>Directional light</code></strong>, as it's just here to make our scene look pretty). First, we have grouped all of our obstacles under a parent <code class="literal">Obstacles</code> transform. Second, we have separate game objects for our <code class="literal">TestCode</code> class and our <code class="literal">GridManager</code> class as children under the <code class="literal">Scripts</code> game object. As you saw in the code sample earlier, there are some fields exposed in the <code class="literal">GridManager</code>, which should look like the following screenshot in our sample scene:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/497ff961-7ec9-4371-b6f4-4917fe8b4137.png" /></div><p>As you can see in the previous screenshot, we have <strong class="userinput"><code>Show Grid</code></strong> ticked to true. This will enable us to see the grid in the scene view.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec11"></a>Testing all the components</h4></div></div></div><p>Now that we've looked at how <span>everything</span><a id="id288566649" class="indexterm"></a> is wired up, hit the play button and observe how a path will be drawn from our start node to our goal node, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/c890d519-6816-408b-ae1a-78d0ac837cac.png" /></div><p>Since we're checking for the path at intervals inside the <code class="literal">Update</code> loop, we can move the goal node in play mode, and see the path updated. The following screenshot shows the new path after moving our goal node to a different location:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/60d3b2dc-2b5d-4841-b33f-599985419fe1.png" /></div><p>As you can see, since the goal is closer, so is the most optimal path to reach it. In a little more than a nutshell, that is A*. A very powerful algorithm can be distilled down to a few classes totaling a few hundred lines of code (with most of it due to formatting and commenting). </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec29"></a>A* vs IDA*</h3></div></div></div><p>In <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>The Basics of AI in Games</em></span>, we mentioned some of the differences between A* and IDA*. Now that you've implemented A*, you can see that the A* implementation keeps a <span>few</span><a id="id288566699" class="indexterm"></a> things in memory—the path array, the open list, and the closed list. At different points in the implementation, you may allocate more or less memory as you iterate through your lists. In this regard, A* is greedier than IDA*, but keep in mind that in most cases, on <span>modern</span><a id="id288566708" class="indexterm"></a> hardware, this is not an issue—even with much larger grids than ours. </p><p>The IDA* approach only looks at the the current iteration's adjacent/neighbor spots, and because it keeps no record of the visited nodes, it may end up visiting the same node multiple times. In similar circumstances, this means a much lower memory overhead than the faster A* version.</p><p>While the point can be argued, it is this humble author's opinion that IDA* is not a relevant pattern in modern game development—even on resource-conscious applications, such as mobile games. In other fields, one could make a stronger case for the iterative deepening approach, but, fortunately, even aging mobile devices have copious amounts of memory relative to the needs of the 99% of games that will implement some sort of pathfinding.</p></div></div>