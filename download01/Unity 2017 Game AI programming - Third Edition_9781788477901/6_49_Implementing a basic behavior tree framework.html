<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec52"></a>Implementing a basic behavior tree framework</h2></div></div><hr /></div><p>While a fully-fledged implementation of a <span>behavior</span><a id="id288183624" class="indexterm"></a> tree with a GUI and its many node types and variations is outside the scope of this book, we can certainly focus on the core principles to get a solid grasp of what the concepts we've covered in this chapter look like in action. Provided with this chapter is the basic framework for a behavior tree. Our example will focus on simple logic to highlight the functionality of the tree, rather than muddy up the example with complex game logic. The goal of our example is to make you feel comfortable with what can seem like an intimidating concept in game AI, and give you the necessary tools to build your own tree and expand upon the provided code if you do so.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec43"></a>Implementing a base Node class</h3></div></div></div><p>There is a base functionality that needs to go into <span>every</span><a id="id288570093" class="indexterm"></a> node. Our simple framework will have all the nodes derived from a base abstract <code class="literal">Node.cs</code> class. This class will provide said base functionality or at least the signature to expand upon that functionality:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
[System.Serializable] 
public abstract class Node { 
 
    /* Delegate that returns the state of the node.*/ 
    public delegate NodeStates NodeReturn(); 
 
    /* The current state of the node */ 
    protected NodeStates m_nodeState; 
 
    public NodeStates nodeState { 
        get { return m_nodeState; } 
    } 
 
    /* The constructor for the node */ 
    public Node() {} 
 
    /* Implementing classes use this method to evaluate the desired set of conditions */ 
    public abstract NodeStates Evaluate(); 
 
} </pre><p>The class is fairly simple. Think of <code class="literal">Node.cs</code> as a blueprint for all the other node types to be built upon. We begin with the <code class="literal">NodeReturn</code> delegate, which is not implemented in our example, but the next two fields are. However, <code class="literal">m_nodeState</code> is the state of a node at any given point. As we learned earlier, it will be either <code class="literal">FAILURE</code>, <code class="literal">SUCCESS</code>, or <code class="literal">RUNNING</code>. The <code class="literal">nodeState</code> value is simply a getter for <code class="literal">m_nodeState</code> since it is protected and we don't want any other area of the code directly setting <code class="literal">m_nodeState</code> inadvertently.</p><p>Next, we have an empty constructor, for the sake of being explicit, even though it is not being used. Lastly, we have the meat and potatoes of our <code class="literal">Node.cs</code> class—the <code class="literal">Evaluate()</code> method. As we'll see in the classes that implement <code class="literal">Node.cs</code>, <code class="literal">Evaluate()</code> is where the magic happens. It runs the code that determines the state of the node.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec44"></a>Extending nodes to selectors</h3></div></div></div><p>To create a selector, we simply expand upon the <span>functionality</span><a id="id288319796" class="indexterm"></a> that we described in the <code class="literal">Node.cs</code> class:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
using System.Collections.Generic; 
 
public class Selector : Node { 
    /** The child nodes for this selector */ 
    protected List&lt;Node&gt; m_nodes = new List&lt;Node&gt;(); 
 
 
    /** The constructor requires a lsit of child nodes to be  
     * passed in*/ 
    public Selector(List&lt;Node&gt; nodes) { 
        m_nodes = nodes; 
    } 
 
    /* If any of the children reports a success, the selector will 
     * immediately report a success upwards. If all children fail, 
     * it will report a failure instead.*/ 
    public override NodeStates Evaluate() { 
        foreach (Node node in m_nodes) { 
            switch (node.Evaluate()) { 
                case NodeStates.FAILURE: 
                    continue; 
                case NodeStates.SUCCESS: 
                    m_nodeState = NodeStates.SUCCESS; 
                    return m_nodeState; 
                case NodeStates.RUNNING: 
                    m_nodeState = NodeStates.RUNNING; 
                    return m_nodeState; 
                default: 
                    continue; 
            } 
        } 
        m_nodeState = NodeStates.FAILURE; 
        return m_nodeState; 
    } 
}</pre><p>As we learned earlier in the chapter, selectors are composite nodes: this means that they have one or more child nodes. These child nodes are stored in the <code class="literal">m_nodes List&lt;Node&gt;</code> variable. Although it's conceivable that one could extend the functionality of this class to allow adding more child nodes after the class has been instantiated, we initially provide this list via the constructor.</p><p>The next portion of the code is a bit more interesting as it shows us a real implementation of the concepts we learned earlier. The <code class="literal">Evaluate()</code> method runs through all of its child nodes and evaluates each one individually. As a failure doesn't necessarily mean a failure for the entire selector, if one of the children returns <code class="literal">FAILURE</code>, we simply continue on to the next one. Inversely, if any child returns <code class="literal">SUCCESS</code>, then we're all set; we can set this node's state accordingly and return that value. If we make it through the entire list of child nodes and none of them have returned <code class="literal">SUCCESS</code>, then we can essentially determine that the entire selector has failed and we assign and return a <code class="literal">FAILURE</code> state.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec45"></a>Moving on to sequences</h3></div></div></div><p>Sequences are very similar in their implementation, but as you might have <span>guessed</span><a id="id288319843" class="indexterm"></a> by now, the <code class="literal">Evaluate()</code> method behaves differently:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
using System.Collections.Generic; 
 
public class Sequence : Node { 
    /** Children nodes that belong to this sequence */ 
    private List&lt;Node&gt; m_nodes = new List&lt;Node&gt;(); 
 
    /** Must provide an initial set of children nodes to work */ 
    public Sequence(List&lt;Node&gt; nodes) { 
        m_nodes = nodes; 
    } 
 
    /* If any child node returns a failure, the entire node fails. Whence all  
     * nodes return a success, the node reports a success. */ 
    public override NodeStates Evaluate() { 
        bool anyChildRunning = false; 
         
        foreach(Node node in m_nodes) { 
            switch (node.Evaluate()) { 
                case NodeStates.FAILURE: 
                    m_nodeState = NodeStates.FAILURE; 
                    return m_nodeState;                     
                case NodeStates.SUCCESS: 
                    continue; 
                case NodeStates.RUNNING: 
                    anyChildRunning = true; 
                    continue; 
                default: 
                    m_nodeState = NodeStates.SUCCESS; 
                    return m_nodeState; 
            } 
        } 
        m_nodeState = anyChildRunning ? NodeStates.RUNNING : NodeStates.SUCCESS; 
        return m_nodeState; 
    } 
} </pre><p>The <code class="literal">Evaluate()</code> method in a sequence will need to return true for all the child nodes, and if any one of them fails during the process, the entire sequence fails, which is why we check for <code class="literal">FAILURE</code> first and set and report it accordingly. A <code class="literal">SUCCESS</code> state simply means we get to live to fight another day, and we continue on to the next child node. If any of the child nodes are determined to be in the <code class="literal">RUNNING</code> state, we report that as the state for the node, and then the parent node or the logic driving the entire tree can evaluate it again.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec46"></a>Implementing a decorator as an inverter</h3></div></div></div><p>The structure of <code class="literal">Inverter.cs</code> is a bit different, but it <span>derives</span><a id="id288319883" class="indexterm"></a> from <code class="literal">Node</code>, just like the rest of the nodes. Let's take a look at the code and spot the differences:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
public class Inverter : Node { 
    /* Child node to evaluate */ 
    private Node m_node; 
 
    public Node node { 
        get { return m_node; } 
    } 
 
    /* The constructor requires the child node that this inverter decorator 
     * wraps*/ 
    public Inverter(Node node) { 
        m_node = node; 
    } 
 
    /* Reports a success if the child fails and 
     * a failure if the child succeeds. Running will report 
     * as running */ 
    public override NodeStates Evaluate() { 
        switch (m_node.Evaluate()) { 
            case NodeStates.FAILURE: 
                m_nodeState = NodeStates.SUCCESS; 
                return m_nodeState; 
            case NodeStates.SUCCESS: 
                m_nodeState = NodeStates.FAILURE; 
                return m_nodeState; 
            case NodeStates.RUNNING: 
                m_nodeState = NodeStates.RUNNING; 
                return m_nodeState; 
        } 
        m_nodeState = NodeStates.SUCCESS; 
        return m_nodeState; 
    } 
}</pre><p>As you can see, since a decorator only has one child, we don't have <code class="literal">List&lt;Node&gt;</code>, but rather a single node variable, <code class="literal">m_node</code>. We pass this node in via the constructor (essentially requiring it), but there is no reason you couldn't modify this code to provide an empty constructor and a method to assign the child node after instantiation.</p><p>The <code class="literal">Evalute()</code> implementation implements the behavior of an inverter that we described earlier in the chapter: when the child evaluates as <code class="literal">SUCCESS</code>, the inverter reports a <code class="literal">FAILURE</code>, and when the child evaluates as <code class="literal">FAILURE</code>, the inverter reports a <code class="literal">SUCCESS</code>. The <code class="literal">RUNNING</code> state is reported normally.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec47"></a>Creating a generic action node</h3></div></div></div><p>Now we arrive at <code class="literal">ActionNode.cs</code>, which is a generic leaf node to pass in some logic via a delegate. You are free to implement leaf nodes in any way that fits your logic, as long as it <span>derives</span><a id="id288319975" class="indexterm"></a> from <code class="literal">Node</code>. This particular example is equal parts flexible and restrictive. It's flexible in the sense that it allows you to pass in any method matching the delegate signature, but is restrictive for this very reason—it only provides one delegate signature that doesn't take in any arguments:</p><pre class="programlisting">using System; 
using UnityEngine; 
using System.Collections; 
 
public class ActionNode : Node { 
    /* Method signature for the action. */ 
    public delegate NodeStates ActionNodeDelegate(); 
 
    /* The delegate that is called to evaluate this node */ 
    private ActionNodeDelegate m_action; 
 
    /* Because this node contains no logic itself, 
     * the logic must be passed in in the form of  
     * a delegate. As the signature states, the action 
     * needs to return a NodeStates enum */ 
    public ActionNode(ActionNodeDelegate action) { 
        m_action = action; 
    } 
 
    /* Evaluates the node using the passed in delegate and  
     * reports the resulting state as appropriate */ 
    public override NodeStates Evaluate() { 
        switch (m_action()) { 
            case NodeStates.SUCCESS: 
                m_nodeState = NodeStates.SUCCESS; 
                return m_nodeState; 
            case NodeStates.FAILURE: 
                m_nodeState = NodeStates.FAILURE; 
                return m_nodeState; 
            case NodeStates.RUNNING: 
                m_nodeState = NodeStates.RUNNING; 
                return m_nodeState; 
            default: 
                m_nodeState = NodeStates.FAILURE; 
                return m_nodeState; 
        } 
    } 
} </pre><p>The key for making this node work is the <code class="literal">m_action</code> delegate. For those familiar with C++, a delegate in C# can be thought of as a function pointer of sorts. You can also think of a delegate as a variable containing (or more accurately, pointing to) a function. This allows you to set the function to be called at runtime. The constructor requires you to pass in a method matching its signature, and is expecting that method to return a <code class="literal">NodeStates</code> enum. That method can implement any logic you want, as long as these conditions are met. Unlike other nodes we've implemented, this one doesn't fall through to any state outside of the switch itself, so it defaults to a <code class="literal">FAILURE</code> state. You may choose to default to a <code class="literal">SUCCESS</code> or <code class="literal">RUNNING</code> state, if you so wish, by modifying the default return.</p><p>You can easily expand on this class by deriving from it or simply making the changes to it that you need. You can also skip this generic action node altogether and implement one-off versions of specific leaf nodes, but it's good practice to reuse as much code as possible. Just remember to derive from <code class="literal">Node</code> and implement the required code!</p></div></div>