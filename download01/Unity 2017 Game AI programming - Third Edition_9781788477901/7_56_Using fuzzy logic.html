<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec58"></a>Using fuzzy logic</h2></div></div><hr /></div><p>Once you understand the simple concepts behind <span>fuzzy</span><a id="id288183624" class="indexterm"></a> logic, it's easy to start thinking of the many, many ways in which it can be useful. In reality, it's just another tool in our belt, and each job requires different tools.</p><p>Fuzzy logic is great at taking some data, evaluating it in a similar way to how a human would (albeit in a much simpler way), and then translating the data back to information that is usable by the system.</p><p>Fuzzy logic controllers have several real-world use cases. Some are more obvious than others, and while these are by no means one-to-one comparisons to our usage in game AI, they serve to illustrate a point:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Heating ventilation and air conditioning (HVAC) systems</strong></span>: The temperature example when talking about fuzzy logic is not only a good theoretical approach to explaining fuzzy logic, but also a very common real-world example of fuzzy logic controllers in action.</li><li style="list-style-type: disc"><span class="strong"><strong>Automobiles</strong></span>: Modern automobiles come equipped with very sophisticated computerized systems, from the air conditioning system (again), to fuel delivery, to automated braking systems. In fact, putting computers in automobiles has resulted in far more efficient systems than the old binary systems that were sometimes used.</li><li style="list-style-type: disc"><span class="strong"><strong>Your smartphone</strong></span>: Ever notice how your screen dims and brightens depending on how much ambient light there is? Modern smartphone operating systems look at ambient light, the color of the data being displayed, and the current battery life to optimize screen brightness.</li><li style="list-style-type: disc"><span class="strong"><strong>Washing machines</strong></span>: Not my washing machine necessarily, as it's quite old, but most modern washers (from the last 20 years) make some use of <span>fuzzy</span><a id="id288559459" class="indexterm"></a> logic. Load size, water dirtiness, temperature, and other factors are taken into account from cycle to cycle to optimize water use, energy consumption, and time.</li></ul></div><p>If you take a look around your house, there is a good chance you'll find a few interesting uses of fuzzy logic, and I mean besides your computer, of course. While these are neat uses of the concept, they're not particularly exciting or game-related. I'm partial to games involving wizards, magic, and monsters, so let's look at a more relevant example.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec56"></a>Implementing a simple fuzzy logic system</h3></div></div></div><p>For this example, we're going to use my <span>good</span><a id="id288559476" class="indexterm"></a> friend, Bob, the wizard. Bob lives in an RPG world, and he has some very powerful healing magic at his disposal. Bob has to decide when to cast this magic on himself based on his remaining <span class="strong"><strong>health points</strong></span> (<span class="strong"><strong>HPs</strong></span>).</p><p>In a binary system, Bob's decision-making process might look like this:</p><pre class="programlisting">if(healthPoints &lt;= 50)  
{ 
  CastHealingSpell(me); 
}</pre><p>We see that Bob's health can be in one of two states—above 50, or not. Nothing wrong with that, but let's have a look at what the fuzzy version of this same scenario might look like, starting with determining Bob's health status:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/c937ea30-7d2d-48fe-8384-e2591d9e6cf6.png" /></div><p>A typical function representing fuzzy values</p><p></p><p>Before the panic sets in upon seeing charts and values that may not quite mean anything to you right away, let's dissect what we're looking at. Our first impulse might be to try to map the probability that Bob will cast a healing spell to how much health he is missing. That would, in simple terms, just be a linear function. Nothing really fuzzy about that—it's a linear relationship, and while it is a step above a binary decision in terms of complexity, it's still not truly fuzzy.</p><p>Enter the concept of a membership function. It's key to our system, as it allows us to determine how true a statement is. In this example, we're not simply looking at raw values to determine whether or not Bob should cast his spell; instead, we're breaking it up into logical chunks of information for Bob to use in order to determine what his course of action should be.</p><p>In this example, we're comparing three <span>statements</span><a id="id288319998" class="indexterm"></a> and evaluating not only how true each one is, but which is the most true:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Bob is in a critical condition</li><li style="list-style-type: disc">Bob is hurt</li><li style="list-style-type: disc">Bob is healthy</li></ul></div><p>If you're into official terminology, we call this determining the degree of membership to a set. Once we have this information, our agent can determine what to do with it next.</p><p>At a glance, you'll notice it's possible for two statements to be true at a time. Bob can be in a critical condition and hurt. He can also be somewhat hurt and a little bit healthy. You're free to pick the thresholds for each, but, in this example, let's evaluate these statements as per the preceding graph. The vertical value represents the degree of truth of a statement as a normalized float (0 to 1):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">At 0 percent health, we can see that the critical statement evaluates to 1. It is absolutely true that Bob is critical when his health is gone.</li><li style="list-style-type: disc">At 40 percent health, Bob is hurt, and that is the truest statement.</li><li style="list-style-type: disc">At 100 percent health, the truest statement is that Bob is healthy.</li></ul></div><p>Anything outside of these absolutely true <span>statements</span><a id="id288320033" class="indexterm"></a> is squarely in fuzzy territory. For example, let's say Bob's health is at 65 percent. In that same chart, we can visualize it like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/c9ae719a-9c34-4421-8c05-c142e38fa61f.png" /></div><p>Bob's health at 65 percent</p><p></p><p>The vertical line drawn through the chart at <span class="strong"><strong>65</strong></span> represents Bob's health. As we can see, it intersects both sets, which means that Bob is a little bit hurt, but he's also kind of healthy. At a glance, we can tell, however, that the vertical line intercepts the <span class="strong"><strong>Hurt</strong></span> set at a higher point in the graph. We can take this to mean that Bob is more hurt than he is healthy. To be specific, Bob is 37.5 percent hurt, 12.5 percent healthy, and 0 percent critical. Let's take a look at this in code; open up our <code class="literal">FuzzySample</code> scene in Unity. The hierarchy will look like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/cd9441e8-2691-4f14-a943-2b0f15f3922e.png" /></div><p>The hierarchy setup in our sample scene</p><p>The important game object to look at is <code class="literal">Fuzzy Example</code>. This <span>contains</span><a id="id288320120" class="indexterm"></a> the logic that we'll be looking at. In addition to that, we have our <code class="literal">Canvas</code> containing all of the labels and the input field and button that make this example work. Lastly, there's the Unity-generated <code class="literal">EventSystem</code> and <code class="literal">Main Camera</code>, which we can disregard. There isn't anything special going on with the setup for the scene, but it's a good idea to become familiar with it, and you are encouraged to poke around and tweak it to your heart's content after we've looked at why everything is there and what it all does.</p><p>With the <code class="literal">Fuzzy Example</code> game object selected, the inspector will look similar to the following image:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/b4e21686-aaa2-4f0b-849c-c03da49a7bc6.png" /></div><p>The Fuzzy Example game object inspector</p><p>Our sample implementation is not necessarily something you'll take and implement in your game as it is, but it is meant to illustrate the previous points in a clear manner. We use Unity's <code class="literal">AnimationCurve</code> for each different set. It's a quick and easy way to visualize the very same lines in our earlier graph.</p><p>Unfortunately, there is no straightforward way to plot all the lines in the same graph, so we use a separate <code class="literal">AnimationCurve</code> for each set. In the preceding screenshot, they are labeled <strong class="userinput"><code>Critical</code></strong>, <strong class="userinput"><code>Hurt</code></strong>, and <strong class="userinput"><code>Healthy</code></strong>. The neat thing about these curves is that they come with a built-in method to evaluate them at a given point (<span class="emphasis"><em>t</em></span>). For us, <span class="emphasis"><em>t</em></span> does not represent time, but rather the amount of health Bob has.</p><p>As in the preceding graph, the Unity <span>example</span><a id="id288320187" class="indexterm"></a> looks at a HP range of 0 to 100. These curves also provide a simple user interface for editing the values. You can simply click on the curve in the inspector. That opens up the curve editing window. You can add points, move points, change tangents, and so on, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/8776ecbf-a804-4e09-a339-a943f12b898a.png" /></div><p>Unity's curve editor window</p><p>Our example focuses on triangle-shaped sets. That is, linear graphs for each set. You are by no means restricted to this shape, though it is the most common. You could use a bell curve or a <span>trapezoid</span><a id="id288566414" class="indexterm"></a>, for that matter. To keep things simple, we'll stick to the triangle.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>You can learn more about Unity's <code class="literal">AnimationCurve</code> editor at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/AnimationCurve.html" target="_blank"><span>http://docs.unity3d.com/ScriptReference/AnimationCurve.html</span></a>.</p></div><p>The rest of the fields are just references to the <span>different</span><a id="id288566439" class="indexterm"></a> UI elements used in code that we'll be looking at later in this chapter. The names of these variables are fairly self-explanatory, however, so there isn't much guesswork to be done here.</p><p>Next, we can take a look at how the scene is set up. If you play the scene, the game view will look something similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/c9bf949b-458c-4073-81bf-3da9c08dacb5.png" /></div><p>A simple UI to demonstrate fuzzy values</p><p>We can see that we have three distinct groups, representing each question from the "Bob, the wizard" example. How healthy is Bob, how hurt is Bob, and how critical is Bob? For each set, upon evaluation, the value that starts off as <span class="strong"><strong>0 true</strong></span> will dynamically adjust to represent the actual degree of membership.</p><p>There is an input box in which you can type a percentage of health to use for the test. No fancy controls are in place for this, so be sure to enter a value from 0 to 100. For the sake of consistency, let's enter a value of <code class="literal">65</code> into the box and then press the <strong class="userinput"><code>Evaluate!</code></strong> button.</p><p>This will run some code, look at the curves, and <span>yield</span><a id="id288566480" class="indexterm"></a> the exact same results we saw in our graph earlier. While this shouldn't come as a surprise (the math is what it is, after all), there are fewer things more important in game programming than testing your assumptions, and sure enough, we've tested and verified our earlier statement.</p><p>After running the test by hitting the <strong class="userinput"><code>Evaluate!</code></strong> button, the game scene will look similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/2f1b5b7e-927a-49eb-8a0a-45e8199cf361.png" /></div><p>This is how Bob is doing at 65 percent health
</p><p>Again, the values turn out to be 0.125 (or 12.5 percent) healthy and 0.375 (or 37.5 percent) hurt. At this point, we're still not doing anything with this data, but let's take a look at the code that's handling everything:</p><pre class="programlisting">using UnityEngine; 
using UnityEngine.UI; 
using System.Collections; 
 
public class FuzzySample1 : MonoBehaviour { 
    private const string labelText = "{0} true"; 
    public AnimationCurve critical; 
    public AnimationCurve hurt; 
    public AnimationCurve healthy; 
 
    public InputField healthInput; 
 
    public Text healthyLabel; 
    public Text hurtLabel; 
    public Text criticalLabel; 
 
    private float criticalValue = 0f; 
    private float hurtValue = 0f; 
    private float healthyValue = 0f; </pre><p>We start off by declaring some variables. The <code class="literal">labelText</code> is simply a constant we use to plug into our label. We replace <code class="literal">{0}</code> with the real value.</p><p>Next, we declare the three <code class="literal">AnimationCurve</code> variables that we mentioned earlier. Making these public or otherwise accessible from the inspector is key to being able to edit them visually (though it is possible to construct curves by code), which is the whole point of using them.</p><p>The following four variables are just references to UI <span>elements</span><a id="id288566528" class="indexterm"></a> that we saw earlier in the screenshot of our inspector, and the last three variables are the actual float values that our curves will evaluate into:</p><pre class="programlisting">    private void Start () { 
        SetLabels(); 
    } 
 
    /* 
     * Evaluates all the curves and returns float values 
     */ 
    public void EvaluateStatements() { 
        if (string.IsNullOrEmpty(healthInput.text)) { 
            return; 
        } 
        float inputValue = float.Parse(healthInput.text); 
         
        healthyValue = healthy.Evaluate(inputValue); 
        hurtValue = hurt.Evaluate(inputValue); 
        criticalValue = critical.Evaluate(inputValue); 
 
        SetLabels(); 
    } </pre><p>The <code class="literal">Start()</code> method doesn't require much explanation. We simply update our labels here so that they initialize to something other than the default text. The <code class="literal">EvaluateStatements()</code> method is much more interesting. We first do some simple null checking for our input string. We don't want to try and parse an empty string, so we return out of the function if it is empty. As mentioned earlier, there is no check in place to validate that you've input a numerical value, so be sure not to accidentally input a non-numerical value or you'll get an error.</p><p>For each of the <code class="literal">AnimationCurve</code> variables, we call the <code class="literal">Evaluate(float t)</code> method, where we replace <code class="literal">t</code> with the parsed value we get from the input field. In the example we ran, that value would be <code class="literal">65</code>. Then, we update our labels once again to display the values we got. The code looks similar to this:</p><pre class="programlisting">    /* 
     * Updates the GUI with the evluated values based 
     * on the health percentage entered by the 
     * user. 
     */ 
    private void SetLabels() { 
        healthyLabel.text = string.Format(labelText, healthyValue); 
        hurtLabel.text = string.Format(labelText, hurtValue); 
        criticalLabel.text = string.Format(labelText, criticalValue);         
    } 
} </pre><p>We simply take each label and replace the text with a formatted version of our <code class="literal">labelText</code> constant that replaces the <code class="literal">{0}</code> with the real value.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec57"></a>Expanding the sets</h3></div></div></div><p>We discussed this topic in detail earlier, and it's <span>important</span><a id="id288566755" class="indexterm"></a> to understand that the values that make up the sets in our example are unique to Bob and his pain threshold. Let's say we have a second wizard, Jim, who's a bit more reckless. For him, critical might be below 20 percent, rather than 40 percent as it is for Bob. This is what I like to call a "happy bonus" from using fuzzy logic. Each agent in the game can have different rules that define their sets, but the system doesn't care. You could predefine these rules or have some degree of randomness determine the limits, and every single agent would behave uniquely and respond to things in their own way.</p><p>In addition, there is no reason to limit our sets to just three. Why not four or five? To the fuzzy logic controller, all that matters is that you determine what truth you're trying to arrive at, and how you get there; it doesn't care how many different sets or possibilities exist in that system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec58"></a>Defuzzifying the data</h3></div></div></div><p>Yes, that's a real (sort of) word. We've started with <span>some</span><a id="id288566772" class="indexterm"></a> crisp rules, which, in the context of fuzzy logic, means clear-cut, hard-defined data, which we then fuzzified (again, a sort of real word) by assigning membership functions to sets. The last step of the process is to defuzzify the data and make a decision. For this, we use simple Boolean operations, such as the following:</p><pre class="programlisting">IF health IS critical THEN cast healing spell </pre><p>Now, at this point, you may be saying, "Hold on a second. That looks an awful lot like a binary controller," and you'd be correct. So why go through all the trouble? Remember what we said earlier about ambiguous information? Without a fuzzy controller, how does our agent understand what it means to be critical, hurt, or healthy, for that matter? These are abstract concepts that mean very little on their own to a computer.</p><p>By using fuzzy logic, we're now able to use these vague terms, infer something from them, and do concrete things; in this case, cast a healing spell. Furthermore, we're able to allow each agent to determine what these vague terms mean to them on an individual level, allowing us not only to achieve unpredictability on an individual level, but even amongst several similar agents.</p><p>The process is described best in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/88790b4c-c13d-4be9-a182-7f19d61d404c.png" /></div><p>The fuzzy logic controller flow</p><p>At the end of the day, they are still computers, so we're <span>bound</span><a id="id288566840" class="indexterm"></a> to the most basic thing computers understand, 0s and 1s:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">We start with crisp data, that is, concrete, hard values that tell us something very specific.</li><li style="list-style-type: disc">The fuzzification step is where we get to decide the abstract or ambiguous data that our agent will need to make a decision.</li><li style="list-style-type: disc">During the inference step, our agent gets to decide what that data means. The agent gets to determine what is "true" based on a provided set of rules, meant to mimic the nuance of human decision-making.</li><li style="list-style-type: disc">The defuzzification step takes this human-friendly data and converts it into simple, computer-friendly information.</li><li style="list-style-type: disc">We end with crisp data, ready for our wizard agent to use.</li></ul></div></div></div>