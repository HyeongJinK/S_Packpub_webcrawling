<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec39"></a>Following a path</h2></div></div><hr /></div><p>Before diving into A*, which is a procedural approach to pathfinding, we'll implement a more rudimentary waypoint-based system. While more advanced techniques, such as the aforementioned A* method or Unity's NavMesh, will often be the preferred method for pathfinding, looking at a simpler, more pure version will help set the foundation for understanding more complex pathfinding approaches. Not only that, but there are many scenarios in which a waypoint-based system will be more than enough, and will allow more fine-tuned control over your AI agent's behavior. </p><p>In this example, we'll create a path, which is made up of <span>individual</span><a id="id288183610" class="indexterm"></a> waypoints. For our purposes, a waypoint is simply a point in space with an X, Y, and Z value; we can simply use a <code class="literal">Vector3</code> to represent this data. By making a serialized array of <code class="literal">Vector3</code> in our script, we'll be able to edit the points in the inspector without much fuss. If you want to challenge yourself and tweak this system to be a bit more user-friendly, you may want to consider using an array of game objects instead, and using their position (a <code class="literal">Vector3</code> ) instead. For demonstration purposes, the example provided will stick to the <code class="literal">Vector3</code> array. After setting up some points in our array, we want to end up with a path that looks like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/42f588cd-de79-4fef-8968-447eccfa11bc.png" /></div><p>An object path</p><p>In the preceding screenshot, we use some debug lines to draw the connections between waypoints. Don't worry, there isn't any magic happening here. By using Unity's debug features, we can visualize the path we'll be having our agent traverse. Let's deconstruct our <code class="literal">Path.cs</code> script to see how we achieve this.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec22"></a>The path script</h3></div></div></div><p>Here is our <code class="literal">Path.cs</code> script, which is responsible for <span>managing</span><a id="id288319795" class="indexterm"></a> our waypoints:</p><pre class="programlisting">using UnityEngine;

public class Path: MonoBehaviour
{
    [SerializeField]
    private Vector3[] waypoints;

    public bool isDebug = true;
    public float radius = 2.0f;

    public float PathLength {
        get { return waypoints.Length; }
    }

    public Vector3 GetPoint(int index)
    {
        return waypoints[index];
    }

    private void OnDrawGizmos()
    {
        if (!isDebug) {
            return;
        }

        for (int i = 0; i &lt; waypoints.Length; i++)
        {
            if (i + 1 &lt; waypoints.Length)
            {
                Debug.DrawLine(waypoints[i], waypoints[i + 1], Color.red);
            }
        }
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip11"></a>Note</h3><p>The <code class="literal">SerializeField</code> property can be used to force Unity to serialize a private field, and display it in the inspector.</p></div><p>Our waypoints' <code class="literal">Vector3</code> array is the collection of <span>waypoints</span><a id="id288319819" class="indexterm"></a> in the path mentioned earlier. To initialize the waypoints, we must add the script to a game object in our scene. In the sample scene, we simply create an empty game object and attach the <code class="literal">Path.cs</code> script to it. For the sake of clarity, we've also renamed our game object to <code class="literal">Path</code>. With the <code class="literal">Path</code> game object ready to go, we can assign the path values in the inspector. The sample values look like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/0650c03c-5196-4ee8-8c22-ee9478e9a421.png" /></div><p>Path values provided in the sample project</p><p>The values in the screenshot here are arbitrary, and can be tweaked to your liking. You just need to make sure you have at least two waypoints along your path. </p><p>The <code class="literal">PathLength</code> property simply returns the length of our waypoint array. It provides a public getter for our private field, and is later used by another script. The <code class="literal">radius</code> variable allows us to define the tolerance for our pathfinding. Rather than expecting our agent to be at the precise location of our waypoint, we'll use a radius to determine when the agent is <span class="emphasis"><em>close enough</em></span> to consider the waypoint visited. The <code class="literal">GetPoint</code> method is a simple helper to get a waypoint from the array at a given index. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"></a>Note</h3><p>It is common and proper practice to make fields <code class="literal">private</code> by default, especially when the data contained is integral to the functionality of the class. In our case, the waypoint order, array size, and more should not be modified at runtime, so we ensure that external classes can only get data from them by using helper methods and properties, and protect them from external changes by making them private.</p></div><p>Finally, we use <code class="literal">OnDrawGizmos</code>, which is a <code class="literal">MonoBehaviour</code> method that Unity automatically calls for us, to draw debug information in the scene view in the editor. We can toggle this functionality on and off by setting the value of <code class="literal">isDebug</code> to <code class="literal">true</code> or <code class="literal">false</code>, respectively.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec23"></a>Using the path follower</h3></div></div></div><p>Next, we'll set up our agent to follow the <span>path</span><a id="id288319933" class="indexterm"></a> defined in the previous section. We'll use a simple cube in the example, but feel free to use any art you want. Let's take a closer look at the <code class="literal">Pathing.cs</code> script provided in the sample code:</p><pre class="programlisting">public class Pathing : MonoBehaviour 
{
    [SerializeField]
    private Path path;
    [SerializeField]
    private float speed = 20.0f;
    [SerializeField]
    private float mass = 5.0f;
    [SerializeField]
    private bool isLooping = true;

    private float currentSpeed;
    private int currentPathIndex = 0;
    private Vector3 targetPoint;
    private Vector3 direction;
    private Vector3 targetDirection;</pre><p>The first group of fields are variables we want serialized so that they can be set via the inspector. <code class="literal">path</code> is a reference to the <code class="literal">Path</code> object we created earlier; we can simply drag and drop the component from the <code class="literal">path</code> game object into this field. <code class="literal">speed</code> and <code class="literal">mass</code> are used to calculate the movement of the agent along the path. <code class="literal">isLooping</code> is used to determine whether or not we should loop around the path. When true, the agent will reach the last waypoint, then go to the first waypoint on the path and start over. Once the values are all assigned, the inspector should look something like this: </p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/1eb7f508-f4e9-4cb5-bf10-b5ca3571e6cd.png" /></div><p>The pathfinding script inspector with its default values</p><p>Our <code class="literal">Start</code> method handles the initialization for some of the remaining private fields—<code class="literal">direction</code> and <code class="literal">targetPoint</code>:</p><pre class="programlisting">private void Start () 
    {
        // Initialize the direction as the agent's current facing direction
        direction = transform.forward; 
        // We get the firt point along the path
        targetPoint = path.GetPoint(currentPathIndex);
  }</pre><p> Our <code class="literal">Update</code> method does a few things for us. First, it does some boilerplate null safety checks, it updates the speed of the agent, checks whether the target has been reached, calls the <code class="literal">SetNextTarget</code> method to determine the next target point, and finally, applies the direction and rotation changes as needed:</p><pre class="programlisting">  private void Update () 
  {
        if(path == null) {
            return;
        }

        currentSpeed = speed * Time.deltaTime;

        if(TargetReached())
        {
            if (!SetNextTarget()) {
                return;
            }
        }

        direction += Steer(targetPoint);
        transform.position += direction; //Move the agent according to the direction
        transform.rotation = Quaternion.LookRotation(direction); //Rotate the agent towards the desired direction
  }</pre><p>To keep things nice and readable, we moved some of the <span>functionality</span><a id="id288320014" class="indexterm"></a> out of the <code class="literal">Update</code> method. <code class="literal">TargetReached</code> is fairly straightforward. It uses the radius of <code class="literal">path</code> to determine if the agent is <span class="emphasis"><em>close enough</em></span> to the target waypoint, as you can see here:</p><pre class="programlisting">private bool TargetReached() 
{
    return (Vector3.Distance(transform.position, targetPoint) &lt; path.radius);
}</pre><p>The <code class="literal">SetNextTarget</code> method is a bit more interesting.  As you can see, it returns a <code class="literal">bool</code>. If we haven't reached the end of the array, it'll just increment the value, but if the method is unable to set the next point, because we've reached the end of the array, and <code class="literal">isLooping</code> is false, it returns false. If you go back to our <code class="literal">Update</code> method for a moment, you'll see that when this happens, we simply return out of <code class="literal">Update</code> and do nothing. This is because we've reached the end of the road, and there is nowhere else for our agent to go. In the same scenario, but with <code class="literal">isLooping == true</code> evaluating to true, we reset our next target point to the first in the array (0):</p><pre class="programlisting">private bool SetNextTarget() 
{
    bool success = false;
    if (currentPathIndex &lt; path.PathLength - 1) {
        currentPathIndex++;
        success = true;
    } 
    else 
    {
        if(isLooping) 
        {
            currentPathIndex = 0;
            success = true;
        } 
        else 
        {
            success = false;
        }
    }
    targetPoint = path.GetPoint(currentPathIndex);
    return success;
}</pre><p>The <code class="literal">Steer</code> method uses the given target point and does some calculations to get the new direction and rotation. By subtracting the target point (<span class="emphasis"><em>b</em></span>) from the current position (<span class="emphasis"><em>a</em></span>), we get a vector for the direction from <span class="emphasis"><em>a</em></span> to <span class="emphasis"><em>b</em></span>. We normalize that vector, then apply the current speed to determine how far to move this frame along the new <code class="literal">targetDirection</code>.  Lastly, we use the mass to ease the acceleration between our <code class="literal">targetDirection</code> and our current direction, and return that value as <code class="literal">acceleration</code>:</p><pre class="programlisting">public Vector3 Steer(Vector3 target)
{
    // Subtracting vector b - a gives you the direction from a to b. 
    targetDirection = (target - transform.position);
    targetDirection.Normalize(); 
    targetDirection*= currentSpeed;

    Vector3 steeringForce = targetDirection - direction; 
    Vector3 acceleration = steeringForce / mass;
    return acceleration;
}</pre><p>When you run the scene, the agent cube will follow the path as expected. If you toggle <code class="literal">isLooping</code> off, the agent will reach the final waypoint and stop there, but if you leave it on, the agent will loop around the path infinitely. Try tweaking the various settings to see how it affects the outcome.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec24"></a>Avoiding obstacles</h3></div></div></div><p>Next, we'll look at an <span>obstacle</span><a id="id288566758" class="indexterm"></a> avoidance mechanic. To get started, pop open the <span>same</span><a id="id288566764" class="indexterm"></a> scene, named <code class="literal">ObstacleAvoidance</code>. The sample scene is quite straightforward. Aside from the camera and directional light, there is a plane with a series of blocks that will act as our obstacles, a cube that will act as our agent, and a canvas containing some instructional text. The scene will look like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/bb674b8c-9939-454d-8893-a1fcbb2239a7.png" /></div><p>The sample scene setup</p><p>The hierarchy for the preceding scene pictures looks like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/76a6e67a-70ba-455f-b51e-1462b2b05a01.png" /></div><p><span><span>The organized hierarchy</span></span></p><p>It is worth noting that this <code class="literal">Agent</code> object is not a pathfinder. As such, if we set too many walls up, our <code class="literal">Agent</code> might have a hard time finding the target. Try a few wall setups and see how our <code class="literal">Agent</code> performs.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec25"></a>Adding a custom layer</h3></div></div></div><p>Our mechanic relies on raycasting to detect obstacles. Rather than just assuming <span>every</span><a id="id288566824" class="indexterm"></a> single object is an obstacle, we specifically use a layer named <strong class="userinput"><code>Obstacles</code></strong> and filter out everything else. This is not a default layer in Unity, so we have to set it up manually. The sample project already has this set up for you, but if you wanted to add your own layer, you could access the layer setup window in two different ways. The first is through the menus—<strong class="userinput"><code>Edit</code></strong> | <span class="strong"><strong><strong class="userinput"><code>Project Settings</code></strong></strong></span> | <strong class="userinput"><code>Tags and Layers—</code></strong>and the second method is by selecting the layer dropdown in the hierarchy and selecting <strong class="userinput"><code>Add Layer...</code></strong>.The following screenshot shows the menu's location in the upper-right corner of the inspector:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/6833bc67-25d1-4b20-af26-76b54fd465d3.png" /></div><p>Selecting the <strong class="userinput"><code>Tags and Layers</code></strong> menu through the menu shown in the preceding screenshot, or through Unity's menu bar, will open up a window where you can freely add, edit, or remove layers (and tags, but we're not interested in those at the moment). Let's add <code class="literal">Obstacles</code> in the 8th slot, as shown in this screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/9ca29389-92c7-434f-8b35-d88685610b8b.png" /></div><p>Creating a new layer</p><p>You should save the project after you make any changes to the settings, but there is no dedicated save button for layers specifically. You can now assign the layer in the same dropdown in the <span>inspector</span><a id="id288566918" class="indexterm"></a> as the one we just used, as <span>depicted</span><a id="id288566926" class="indexterm"></a> in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/744fab92-2cd6-4db7-949f-56f6ea58fc37.png" /></div><p>Assigning our new layer</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>Layers are most commonly used by cameras to render a part of the scene, and by lights to illuminate only some parts of the scene. But they can also be used by raycasting to selectively ignore colliders or create collisions. You can learn more about this at <a class="ulink" href="https://docs.unity3d.com/Manual/Layers.html" target="_blank"><span>http://docs.unity3d.com/Documentation/Components/Layers.html</span>.</a></p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec26"></a>Obstacle avoidance</h3></div></div></div><p>Now that our scene is set up, let's take a look at our <span>avoidance</span><a id="id288566999" class="indexterm"></a> behavior script. It contains all the logic for driving our agent, and applies the avoidance to the movement of the agent. In the sample project, take a look at the <code class="literal">Avoidance.cs</code> script:</p><pre class="programlisting">using UnityEngine;

public class Avoidance : MonoBehaviour 
{
    [SerializeField]
    private float movementSpeed = 20.0f;
    [SerializeField]
    private float rotationSpeed = 5.0f;
    [SerializeField]
    private float force = 50.0f;
    [SerializeField]
    private float minimumAvoidanceDistance = 20.0f;
    [SerializeField]
    private float toleranceRadius = 3.0f;

    private float currentSpeed;
    private Vector3 targetPoint;
    private RaycastHit mouseHit;
    private Camera mainCamera;
    private Vector3 direction;
    private Quaternion targetRotation;
    private RaycastHit avoidanceHit;
    private Vector3 hitNormal;

    private void Start () 
    {
        mainCamera = Camera.main;
        targetPoint = Vector3.zero;
    }</pre><p>You'll find some familiar field names in the preceding code snippet. Values such as movement speed, rotation speed, tolerance radius, and more are similar to values we used in our waypoint system. Similarly, we use the <code class="literal">SerializeField</code> attribute to expose our private fields in the inspector for easy editing and assignment, while protecting our values from being tampered with by external objects at runtime. In the <code class="literal">Start</code> method, we simply initialize some values. For example, we cache a reference to our <code class="literal">Camera.main</code> here so that we don't have to do the lookup every single time we need a reference to it. Next, let's look at the <code class="literal">Update</code> method:</p><pre class="programlisting">  private void Update () 
  {
        CheckInput();
        direction = (targetPoint - transform.position);
        direction.Normalize();

        //Apply obstacle avoidance
        ApplyAvoidance(ref direction);

        //Don't move the agent when the target point is reached
        if(Vector3.Distance(targetPoint, transform.position) &lt; toleranceRadius) {
            return;
        }

        currentSpeed = movementSpeed * Time.deltaTime;

        //Rotate the agent towards its target direction 
        targetRotation = Quaternion.LookRotation(direction);
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed *                   Time.deltaTime);

        //Move the agent forard
        transform.position += transform.forward * currentSpeed;
    }</pre><p>Right off the bat, we call <code class="literal">CheckInput()</code>, which looks like this:</p><pre class="programlisting">private void CheckInput() 
{
    if (Input.GetMouseButtonDown(0)) 
    {
        var ray = mainCamera.ScreenPointToRay(Input.mousePosition);
        if (Physics.Raycast(ray, out mouseHit, 100.0f)) {
            targetPoint = mouseHit.point;
        }
    }
}</pre><p>We check whether the user has clicked the left mouse button (by default, it is the button mapped to "<code class="literal">0</code>"). If so, we check for a physics raycast originating from the main camera, shooting to the position of the mouse. If we get a positive hit, we simply assign the hit point from <code class="literal">mouseHit</code> to be our new <code class="literal">targetPoint</code>. This is where our agent will attempt to move to. Back to <code class="literal">Update</code>, we have the following lines, right after our <code class="literal">CheckInput()</code> method:</p><pre class="programlisting">direction = (targetPoint - transform.position);
direction.Normalize();

//Apply obstacle avoidance
ApplyAvoidance(ref direction);</pre><p>We calculate the direction to our target point, in the same way we did in our <code class="literal">Pathing.cs</code> script, and we normalize that vector so that it has a magnitude of no more than 1. Next, we modify that direction and apply avoidance, by sending that direction vector to our <code class="literal">ApplyAvoidance()</code> method, which looks like this:</p><pre class="programlisting">private void ApplyAvoidance(ref Vector3 direction)
{
    //Only detect layer 8 (Obstacles)
    //We use bitshifting to create a layermask with a value of 
    //0100000000 where only the 8th position is 1, so only it is active.
    int layerMask = 1 &lt;&lt; 8;

    //Check that the agent hit with the obstacles within it's minimum distance to avoid
    if (Physics.Raycast(transform.position, transform.forward, out avoidanceHit, minimumAvoidanceDistance, layerMask))
    {
        //Get the normal of the hit point to calculate the new direction
        hitNormal = avoidanceHit.normal;
        hitNormal.y = 0.0f; //Don't want to move in Y-Space

        //Get the new directional vector by adding force to agent's current forward vector
        direction = transform.forward + hitNormal * force;
    }
}</pre><p>Before digging into the preceding code, it's important to understand how Unity handles masking layers. As we mentioned earlier, we want our raycast to only hit the layers we care about, in this case, our <code class="literal">Obstacles</code> layer. If you were observant, you might have noticed our layer's array has 32 slots, from index 0 to 31. We put our <code class="literal">Obstacles</code> layer on slot 8 (index 9). The reason for this is that Unity represents the layers using a 32-bit int, and each bit represents one of the slots, from right to left. Let's break that down visually.</p><p>Let's say we want to represent a layer mask, where only the first slot (the first bit) is active. In this case, we'd assign the bit a value of 1. It would look like this:</p><pre class="programlisting">0000 0000 0000 0000 0000 0000 0000 0001</pre><p>And if you're still solid on your computer science fundamentals, you'll remember, that in binary, that value translates to an int value of 1. Let's say you have a mask that only has the first four slots/indices selected. That would like like this:</p><pre class="programlisting">0000 0000 0000 0000 0000 0000 0000 1111</pre><p>Once again, converting from binary, it gives us an int value of <span class="emphasis"><em>15 (1 + 2+ 4 + 8)</em></span>.</p><p>In our script, we want a mask with only the 9th position active, which would look like this:</p><pre class="programlisting">0000 0000 0000 0000 0000 0001 0000 0000</pre><p>Again, doing the math, we know that the int value for that mask is 256. But doing the math manually is inconvenient. Luckily, C# provides some operators to manipulate bits. This line in the preceding code does just that:</p><pre class="programlisting">int layerMask = 1 &lt;&lt; 8;</pre><p>It uses a bit shift operator—the left-shift operator, specifically—to create our mask. The way it works is fairly straightforward: it takes an int operand (the int value on the left-hand side of the expression) with a value of 1, then shifts that bit representation to the left eight times. It looks something like this:</p><pre class="programlisting">0000 0000 0000 0000 0000 0000 0000 0001 //Int value of 1
                              &lt;&lt;&lt;&lt; &lt;&lt;&lt;&lt; //Shift left 8 times
0000 0000 0000 0000 0000 0001 0000 0000 //Int value of 256</pre><p>As you can see, bitwise operators are helpful, and though they don't always lead to very readable code, they're very handy in situations like this one.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>You can also find a good discussion on using layermasks on Unity3D online. The question-and-answer site can be found at <a class="ulink" href="http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html" target="_blank"><span>http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html</span></a>. Alternatively, you may consider using <code class="literal">LayerMask.GetMask()</code>, which is Unity's built-in method for dealing with named layers.</p></div><p>With that out of the way, let's go back to the rest of our <code class="literal">ApplyAvoidance()</code> code. After creating the layer mask, the following lines look like this:</p><pre class="programlisting">//Check that the agent hit with the obstacles within it's minimum distance to avoid
if (Physics.Raycast(transform.position, transform.forward, out avoidanceHit, minimumAvoidanceDistance,     layerMask))
{
    //Get the normal of the hit point to calculate the new direction
    hitNormal = avoidanceHit.normal;
    hitNormal.y = 0.0f; //Don't want to move in Y-Space

    //Get the new direction vector by adding force to agent's current forward vector
    direction = transform.forward + hitNormal * force;
}</pre><p>Once again, we use a raycast, but this time, the origin is the position of the agent, and the direction is its forward vector. You'll also notice that we use an overload of the <code class="literal">Physics.Raycast()</code> method that takes our <code class="literal">layerMask</code> as an argument, meaning our raycast will only hit objects in our obstacles layer. When a hit does occur, we get the normal of the surface we hit and calculate the new direction vector.</p><p>The last bit of our <code class="literal">Update</code> function looks like this:</p><pre class="programlisting">//Don't move the agent when the target point is reached
if(Vector3.Distance(targetPoint, transform.position) &lt; toleranceRadius) {
    return;
}

currentSpeed = movementSpeed * Time.deltaTime;

//Rotate the agent towards its target direction 
targetRotation = Quaternion.LookRotation(direction);
transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed *                   Time.deltaTime);

//Move the agent forard
transform.position += transform.forward * currentSpeed;</pre><p>Again, you may recognize some of this code, as it's very similar to the code used in the <code class="literal">Pathing.cs</code> script. If we've come within the acceptable radius of our destination, we do nothing. Otherwise, we rotate the agent and move it forward.</p><p>In the sample scene, you can find an <code class="literal">Agent</code> game object with the <code class="literal">Avoidance.cs</code> script attached. The inspector with all the values assigned will look like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/e608b46d-da49-4451-a5d5-402cb7f3c429.png" /></div><p>Agent inspector view</p><p>Try tweaking the values to see what kinds of results you can get. Simply hit play and click around the scene to tell your agent to move. You may notice that, even though the agent is intelligently avoiding the obstacles, it won't always take the most efficient route to its target destination. That's where A* comes in.</p></div></div>