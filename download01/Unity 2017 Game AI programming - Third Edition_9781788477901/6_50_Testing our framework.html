<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec53"></a>Testing our framework</h2></div></div><hr /></div><p>The framework that we just reviewed is <span>nothing</span><a id="id288183608" class="indexterm"></a> more than this. It provides us with all the functionality we need to make a tree, but we have to make the actual tree ourselves. For the purposes of this book, a somewhat manually constructed tree is provided.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec48"></a>Planning ahead</h3></div></div></div><p>Before we set up our tree, let's look at what we're trying to accomplish. It is often helpful to visualize a tree before implementing it. Our tree will count up from zero to a specified value. Along the way, it will check whether certain conditions are met for that value and report its state accordingly. The <span>following</span><a id="id288319756" class="indexterm"></a> diagram illustrates the basic hierarchy for our tree:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/df073027-0a34-4e58-8407-0637aeacc799.png" /></div><p>For our tests, we will use a three-tier tree, including the root node:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Node 1</strong></span>: This is our root node. It has children, and we want to be able to return a success if any of the children are a success, so we'll implement it as a selector.</li><li style="list-style-type: disc"><span class="strong"><strong>Node 2a</strong></span>: We'll implement this node using an <code class="literal">ActionNode</code>.</li><li style="list-style-type: disc"><span class="strong"><strong>Node 2b</strong></span>: We'll use this node to demonstrate how our inverter works.</li><li style="list-style-type: disc"><span class="strong"><strong>Node 2c</strong></span>: We'll run the same <code class="literal">ActionNode</code> from node <span class="strong"><strong>2a</strong></span> again, and see how that affects our tree's evaluation.</li><li style="list-style-type: disc"><span class="strong"><strong>Node 3</strong></span>: Node <span class="strong"><strong>3</strong></span> happens to be the lone node in the third tier of the tree. It is the child of the <span class="strong"><strong>2b</strong></span> decorator node. This means that if it reports <code class="literal">SUCCESS</code>, <span class="strong"><strong>2b</strong></span> will report a <code class="literal">FAILURE</code>, and vice versa.
</li></ul></div><p>At this point, we're still a bit vague on the implementation details, but the preceding diagram will help us to visualize our tree as we implement it in code. Keep it handy for reference as we go through the code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec49"></a>Examining our scene setup</h3></div></div></div><p>We've now looked at the basic structure of <span>our</span><a id="id288562485" class="indexterm"></a> tree, and before we jump in and dig into the actual code implementation, let's look at our scene setup. The following screenshot shows our hierarchy; the nodes are highlighted for emphasis:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/c3281216-0777-449a-94c2-eb41c90efbda.png" /></div><p>The setup is quite simple. There is a quad with a world-space canvas, which is simply to display some information during the test. The nodes highlighted in the preceding screenshot will be referenced in the code later, and we'll be using them to visualize the status of each individual node. The actual scene looks something like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/88635d17-aa17-4056-836c-5a0ae56bee72.png" /></div><p>Our actual layout mimics the diagram we created earlier</p><p></p><p>As you can see, we have one node or box representing each of the nodes that we laid out in our planning phase. These are referenced in the actual test code and will be changing colors according to the state that is returned.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec50"></a>Exploring the MathTree code</h3></div></div></div><p>Without further ado, let's have a look at the code driving <span>our</span><a id="id288562546" class="indexterm"></a> test. This is <code class="literal">MathTree.cs</code>:</p><pre class="programlisting">using UnityEngine; 
using UnityEngine.UI; 
using System.Collections; 
using System.Collections.Generic; 
 
public class MathTree : MonoBehaviour { 
    public Color m_evaluating; 
    public Color m_succeeded; 
    public Color m_failed; 
 
    public Selector m_rootNode; 
 
    public ActionNode m_node2A; 
    public Inverter m_node2B; 
    public ActionNode m_node2C; 
    public ActionNode m_node3; 
 
    public GameObject m_rootNodeBox; 
    public GameObject m_node2aBox; 
    public GameObject m_node2bBox; 
    public GameObject m_node2cBox; 
    public GameObject m_node3Box; 
 
    public  int m_targetValue = 20; 
    private int m_currentValue = 0; 
 
    [SerializeField] 
    private Text m_valueLabel; </pre><p>The first few variables are simply used for debugging. The three color variables are the colors we'll be assigning to our node boxes to visualize their state. By default, <code class="literal">RUNNING</code> is yellow, <code class="literal">SUCCESS</code> is green, and <code class="literal">FAILED</code> is red. This is pretty standard stuff; let's move along.</p><p>We then declare our actual nodes. As you can see, <code class="literal">m_rootNode</code> is a selector, as we mentioned earlier. Notice that we do not assign any of the node variables yet, since we have to pass in some data to their constructors.</p><p>We then have the references to the boxes we saw in our scene. These are just game objects that we drag and drop into the inspector (we'll have a look at that after we inspect the code).</p><p>We then have a couple of <code class="literal">int</code> values, which <span>will</span><a id="id288563767" class="indexterm"></a> make more sense as we look at the logic, so we'll skip over these. Lastly, we have a unity UI Text variable that will display some values for us during the test.</p><p>Let's get into the initialization of our actual nodes:</p><pre class="programlisting">    /* We instantiate our nodes from the bottom up, and assign the children 
     * in that order */ 
   void Start () { 
        /** The deepest-level node is Node 3, which has no children. */ 
        m_node3 = new ActionNode(NotEqualToTarget); 
 
        /** Next up, we create the level 2 nodes. */ 
        m_node2A = new ActionNode(AddTen); 
 
        /** Node 2B is a selector which has node 3 as a child, so we'll pass  
         * node 3 to the constructor */ 
        m_node2B = new Inverter(m_node3); 
 
        m_node2C = new ActionNode(AddTen); 
 
        /** Lastly, we have our root node. First, we prepare our list of children 
         * nodes to pass in */ 
        List&lt;Node&gt; rootChildren = new List&lt;Node&gt;(); 
        rootChildren.Add(m_node2A); 
        rootChildren.Add(m_node2B); 
        rootChildren.Add(m_node2C); 
 
        /** Then we create our root node object and pass in the list */ 
        m_rootNode = new Selector(rootChildren); 
 
        m_valueLabel.text = m_currentValue.ToString(); 
 
        m_rootNode.Evaluate(); 
 
        UpdateBoxes(); 
   }</pre><p>For the sake of organization, we declare our nodes from the bottom of the tree to the top of the tree, or the root node. We do this because we cannot instantiate a parent without passing in its child nodes, so we have to instantiate the child nodes first. Notice that <code class="literal">m_node2A</code>, <code class="literal">m_node2C</code>, and <code class="literal">m_node3</code> are action nodes, so we pass in delegates (we'll look at these methods next). Then, <code class="literal">m_node2B</code>, being a selector, takes in a node as a child, in this case <code class="literal">m_node3</code>. After we've declared these tiers, we throw all the tier 2 nodes into a list because our tier 1 node, the root node, is a selector that requires a list of children to be instantiated.</p><p>After we've instantiated all of our nodes, we kick off the process and begin evaluating our root node using its <code class="literal">Evaluate()</code> method. The <code class="literal">UpdateBoxes()</code> method simply updates the <code class="literal">box</code> game objects that we declared earlier with the appropriate colors; we'll look at that later on in this section:</p><pre class="programlisting">private void UpdateBoxes() { 
        /** Update root node box */ 
        if (m_rootNode.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_rootNodeBox); 
        } else if (m_rootNode.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_rootNodeBox); 
        } 
 
        /** Update 2A node box */ 
        if (m_node2A.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_node2aBox); 
        } else if (m_node2A.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_node2aBox); 
        } 
 
        /** Update 2B node box */ 
        if (m_node2B.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_node2bBox); 
        } else if (m_node2B.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_node2bBox); 
        } 
 
        /** Update 2C node box */ 
        if (m_node2C.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_node2cBox); 
        } else if (m_node2C.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_node2cBox); 
        } 
 
        /** Update 3 node box */ 
        if (m_node3.nodeState == NodeStates.SUCCESS) { 
            SetSucceeded(m_node3Box); 
        } else if (m_node3.nodeState == NodeStates.FAILURE) { 
            SetFailed(m_node3Box); 
        } 
    } </pre><p>There is not a whole lot to discuss here. Do notice that, because we set this tree up manually, we check each node individually and get its <code class="literal">nodeState</code> and set the colors using the <code class="literal">SetSucceeded</code> and <code class="literal">SetFailed</code> methods. Let's move on to the meaty part of the class:</p><pre class="programlisting">private NodeStates NotEqualToTarget() {         
        if (m_currentValue != m_targetValue) { 
            return NodeStates.SUCCESS; 
        } else { 
            return NodeStates.FAILURE; 
        } 
    } 
 
    private NodeStates AddTen() { 
        m_currentValue += 10; 
        m_valueLabel.text = m_currentValue.ToString(); 
        if (m_currentValue == m_targetValue) { 
            return NodeStates.SUCCESS; 
        } else { 
            return NodeStates.FAILURE; 
        } 
    } </pre><p>First, we have <code class="literal">NotEqualToTarget()</code>, which is the method we passed into our decorator's child action node. We're essentially setting ourselves up for a double negative here, so try to follow along. This method returns a success if the current value is <span class="emphasis"><em>not</em></span> equal to the target value, and returns false otherwise. The parent inverter decorator will then evaluate to the opposite of what this node returns. So, if the value is not equal, the inverter node will fail; otherwise, it will succeed. If you're feeling a bit lost at this point, don't worry. It will all make sense when we see this in action.</p><p>The next method is the <code class="literal">AddTen()</code> method, which is the method passed into our other two action nodes. It does exactly what the name implies—it adds 10 to our <code class="literal">m_currentValue</code> variable, then checks whether it's equal to our <code class="literal">m_targetValue</code>, and evaluates as <code class="literal">SUCCESS</code> if so, and <code class="literal">FAILURE</code> if not.</p><p>The last few methods are self-explanatory so we will not go over them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec51"></a>Executing the test</h3></div></div></div><p>Now that we have a pretty good idea of <span>how</span><a id="id288319770" class="indexterm"></a> the code works, let's see it in action. First things first, however. Let's make sure our component is properly set up. Select the <strong class="userinput"><code>Tree</code></strong> game object from the hierarchy, and its inspector should look similar to this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/226dba19-1d15-49b8-99ba-c9ed4672e6ef.png" /></div><p>The default settings for the component</p><p>As you can see, the state colors and box references have already been assigned for you, as well as the <code class="literal">m_valueLabel</code> variable. The <code class="literal">m_targetValue</code> variable has also been assigned for you via code. Make sure to leave it at (or set it to) 20 before you hit play. Play the scene, and you'll see your boxes lit up, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/d5d1aee6-7950-478f-95d9-72515b2a2bd2.png" /></div><p>The boxes lit up, indicating the result of each node's evaluation
</p><p>As we can see, our root node evaluated to <code class="literal">SUCCESS</code>, which is <span>what</span><a id="id288319819" class="indexterm"></a> we intended, but let's examine why, one step at a time, starting at tier 2:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Node 2A</strong></span>: We started with <code class="literal">m_currentValue</code> at <code class="literal">0</code>, so upon adding <code class="literal">10</code> to it, it's still not equal to our <code class="literal">m_targetValue</code> (<code class="literal">20</code>) and it fails. Thus, it is red.</li><li style="list-style-type: disc"><span class="strong"><strong>Node 2B</strong></span>: As it evaluates its child, once again, <code class="literal">m_currentValue</code> and <code class="literal">m_targetValue</code> are not equal. This returns <code class="literal">SUCCESS</code>. Then, the inverter logic kicks in and reverses this response so that it reports <code class="literal">FAILURE</code> for itself. So, we move on to the last node.</li><li style="list-style-type: disc"><span class="strong"><strong>Node 2C</strong></span>: Once again, we add <code class="literal">10</code> to <code class="literal">m_currentValue</code>. It then becomes <code class="literal">20</code>, which is equal to <code class="literal">m_targetValue</code>, and evaluates as <code class="literal">SUCCESS</code>, so our root node is successful as a result.</li></ul></div><p>The test is simple, but it illustrates the concepts clearly. Before we consider the test a success, let's run it one more time, but change <code class="literal">m_targetValue</code> first. Set it to <code class="literal">30</code> in the inspector, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/3a6cdbb5-0bc8-4964-a759-351c8c64af80.png" /></div><p>The updated value is highlighted</p><p>A small change, to be sure, but it will change how the entire tree evaluates. Play the scene again, and we will end up with the set of nodes lit up, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/c49c68dc-e721-40e2-ad11-fc29ff0c7ce3.png" /></div><p>A clearly different result from our first test
</p><p>As you can see, all but one of the child nodes of our root failed, so it reports <code class="literal">FAILURE</code> for itself. Let's look at why:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Node 2A</strong></span>: Nothing really changes here from our original example. Our <code class="literal">m_currentValue</code> variable starts at <code class="literal">0</code> and ends up at <code class="literal">10</code>, which is not equal to our <code class="literal">m_targetValue</code> of <code class="literal">30</code>, so it fails.</li><li style="list-style-type: disc"><span class="strong"><strong>Node 2B</strong></span>: This evaluates its child once more, and because the child node reports <code class="literal">SUCCESS</code>, it reports <code class="literal">FAILURE</code> for itself, and we move on to the next node.</li><li style="list-style-type: disc"><span class="strong"><strong>Node 2C</strong></span>: Once again, we add <code class="literal">10</code> to our <code class="literal">m_currentValue</code> variable, adding up to <code class="literal">20</code>, which, after having changed the <code class="literal">m_targetValue</code> variable, no longer evaluates to <code class="literal">SUCCESS</code>.</li></ul></div><p>The current implementation of the nodes will have unevaluated nodes default to <code class="literal">SUCCESS</code>. This is because of our enum order, as you can see in <code class="literal">NodeState.cs</code>:</p><pre class="programlisting">public enum NodeStates { 
    SUCCESS, 
    FAILURE, 
    RUNNING, 
} </pre><p>In our enum, <code class="literal">SUCCESS</code> is the first enumeration, so if a node never gets evaluated, the default value is never changed. If you were to change the <code class="literal">m_targetValue</code> variable to <code class="literal">10</code>, for example, all the nodes would light up to green. This is simply a by-product of our test implementation and doesn't actually reflect any design issues with our nodes. Our <code class="literal">UpdateBoxes()</code> method updates all the boxes whether they were evaluated or not. In this example, node <span class="strong"><strong>2A</strong></span> would immediately evaluate as <code class="literal">SUCCESS</code>, which, in turn, would cause the root node to report <code class="literal">SUCCESS</code>, and neither node <span class="strong"><strong>2B</strong></span>, <span class="strong"><strong>2C</strong></span>, nor <span class="strong"><strong>3</strong></span> would be evaluated at all, having no effect on the evaluation of the tree as a whole.</p><p>You are highly encouraged to play with this test. Change the root node implementation from a selector to a sequence, for example. By simply changing <code class="literal">public Selector m_rootNode;</code> to <code class="literal">public Sequence m_rootNode;</code> and <code class="literal">m_rootNode = new Selector(rootChildren);</code> to <code class="literal">m_rootNode = new Sequence(rootChildren);</code>, you can test a completely different set of functionality.</p></div></div>