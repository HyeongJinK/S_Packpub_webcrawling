<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec26"></a>Creating the enemy tank</h2></div></div><hr /></div><p>Let's go ahead and create an animator <span>controller</span><a id="id288183627" class="indexterm"></a> in your assets folder. This will be your enemy tank's state machine. Call it <code class="literal">EnemyFsm</code>.</p><p>This state machine will drive the tank's basic actions. As described earlier in our example, the enemy can patrol, chase, and shoot the player. Let's go ahead and set up our state machine. Select the <code class="literal">EnemyFsm</code> asset and open up the <strong class="userinput"><code>Animator</code></strong> window.</p><p>Now, we'll go ahead and create three <span>empty</span><a id="id288566873" class="indexterm"></a> states that will conceptually and functionally represent our enemy tank's states. Name them <code class="literal">Patrol</code>, <code class="literal">Chase</code>, and <code class="literal">Shoot</code>. Once they are created and named, we'll want to make sure we have the correct default state assigned. At the moment, this will vary depending on the order in which you created and named the states, but we want the <strong class="userinput"><code>Patrol</code></strong> state to be the default state, so right-click on it and select <strong class="userinput"><code>Set as Layer Default State</code></strong>. Now it is colored orange and the <strong class="userinput"><code>Entry</code></strong> state is connected to it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec14"></a>Choosing transitions</h3></div></div></div><p>At this point, we have to make some <span>design</span><a id="id288319783" class="indexterm"></a> and logic decisions regarding the way our states will flow into each other. When we map out these transitions, we also want to keep in mind the conditions that trigger the transitions to make sure they are logical and work from a design-standpoint. Out in the wild, when you're applying these techniques on your own, different factors will play into how these transitions are handled. In order to best illustrate the topic at hand, we'll keep our transitions simple and logical:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Patrol</strong></span>: From patrol, we can transition into chasing. We will use a chain of conditions to choose which state we'll transition into, if any. Can the enemy tank see the player? If yes, we go to the next step; if not, we continue with patrolling.</li><li style="list-style-type: disc"><span class="strong"><strong>Chase</strong></span>: From this state, we'll want to continue to check whether the player is within sight to continue chasing, close enough to shoot, or completely out of sight—that would send us back into the <strong class="userinput"><code>Patrol</code></strong> state.</li><li style="list-style-type: disc"><span class="strong"><strong>Shoot</strong></span>: As earlier, we'll want to check our range for shooting and then the line of sight to determine whether or not we can chase to get within the range.</li></ul></div><p>This particular example has a simple and clean set of transition rules. If we <span>connect</span><a id="id288319816" class="indexterm"></a> our states accordingly, we'll end up with a graph looking more or less similar to this one:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/cbbd7966-bdcf-469c-ac21-cdfb78ae3560.png" /></div><p>Keep in mind that the placement of the nodes is entirely up to you, and it does not affect the functionality of the state machine in any way. You can try to place your nodes in a way that keeps them organized so that you can track your transitions visually.</p><p>Now that we have our states mapped out, let's assign some behaviors to them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Making the cogs turn</h3></div></div></div><p>This is the part I'm sure you've been waiting for. I know, I've kept you waiting, but for good reason. As we now get ready to dive into the coding, we do so with a good understanding of the logical connection <span>between</span><a id="id288319846" class="indexterm"></a> the states in our FSM. Without further ado, select our <strong class="userinput"><code>Patrol</code></strong> state. In the hierarchy, you'll see a button labeled <strong class="userinput"><code>Add Behaviour</code></strong>. Clicking this gives you a context menu very similar to the <strong class="userinput"><code>Add Component</code></strong> button on regular game objects, but as we mentioned before, this button creates the oh-so-unique state machine behaviors.</p><p>Go ahead and name this behavior <code class="literal">TankPatrolState</code>. Doing so <span>creates</span><a id="id288319870" class="indexterm"></a> a script of the same name in your project and attaches it to the state we created it from. You can open this script via the project window, or by double-clicking on the name of the script in the inspector. What you'll find inside will look similar to this:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
public class TankPatrolState : StateMachineBehaviour { 
 
   // OnStateEnter is called when a transition starts and the state machine starts to evaluate this state 
   //override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
 
   // OnStateUpdate is called on each Update frame between OnStateEnter and OnStateExit callbacks 
   //override public void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
 
   // OnStateExit is called when a transition ends and the state machine finishes evaluating this state 
   //override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
 
   // OnStateMove is called right after Animator.OnAnimatorMove(). Code that processes and affects root motion should be implemented here 
   //override public void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
 
   // OnStateIK is called right after Animator.OnAnimatorIK(). Code that sets up animation IK (inverse kinematics) should be implemented here. 
   //override public void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) { 
   // 
   //} 
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip5"></a>Note</h3><p><strong class="userinput"><code>Downloading the example code</code></strong>
You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com" target="_blank">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support" target="_blank">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.<strong class="userinput"><code></code></strong></p></div><p>Before we begin, uncomment each method. Let's break it down step by step. Unity <span>creates</span><a id="id288319904" class="indexterm"></a> this file for you, but all the methods are commented out. Essentially, the commented code acts as a guide. Much like the methods provided for you in a <code class="literal">MonoBehaviour</code>, these methods are called for you by the underlying logic. You don't need to know what's going on behind the scenes to use them; you simply have to know when they are called to leverage them. Luckily, the commented code provides a brief description of when each method is called, and the names are fairly descriptive themselves. There are two methods here we don't need to worry about, <code class="literal">OnStateIK</code> and <code class="literal">OnStateMove</code>, which are animation messages, so go ahead and delete them and save the file.</p><p>To reiterate what's stated in the code's comments, the following things happen:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">OnStateEnter</code> is called when you enter the state, as soon as the
transition starts</li><li style="list-style-type: disc"><code class="literal">OnStateUpdate</code> is called on each frame, after the <code class="literal">MonoBehaviors</code> update</li><li style="list-style-type: disc"><code class="literal">OnStateExit</code> is called after the transition out of the state is finished</li></ul></div><p>The following two states, as we mentioned, are animation-specific, so we do not use those for our purposes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">OnStateIK</code> is called just before the IK system gets updated; this is an animation and rig-specific concept</li><li style="list-style-type: disc"><code class="literal">OnStateMove</code> is used on avatars that are set up to use root motion</li></ul></div><p>Another important piece of information to note is the parameters passed into these methods:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">animator</code> parameter is a reference to the animator that contains this animator controller, and therefore this state machine. By extension, you can fetch a reference to the game object that the animator controller is on, and from there, you can grab any other components attached to it. Remember, the state machine behavior exists only as an asset, and does not exist in the class, meaning this is the best way to get references to runtime classes, such as mono behaviors.</li><li style="list-style-type: disc">The animator state info provides information about the state you're currently in; however, the uses for this are primarily focused on animation state information, so it's not as useful for our application.</li><li style="list-style-type: disc">Lastly, we have the layer index, which is an integer telling us which layer within the state machine our state is in. The base layer is index zero, and each layer above that is a higher number.</li></ul></div><p>Now that we understand the basics of state machine behavior, let's get the rest of our components in order. Before we can actually see these behaviors in action, we have to go back to our state machine and add some parameters that will drive the states.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec1"></a>Setting conditions</h4></div></div></div><p>We will need to provide our enemy tank with a few <span>conditions</span><a id="id288319981" class="indexterm"></a> to transitions states. These are the actual parameters that will drive the functionality.</p><p>Let's begin with the <strong class="userinput"><code>Patrol</code></strong> state. In order for our enemy tank to go from <strong class="userinput"><code>Patrol</code></strong> to <strong class="userinput"><code>Shoot</code></strong>, we need to be in range of the player; in other words, we'll be checking the distance between the enemy and the player, which is best represented by a float value. So, in your <strong class="userinput"><code>Parameters</code></strong> panel, add a float and name it <code class="literal">distanceFromPlayer</code>. We can also use this parameter to determine whether or not to go into the <strong class="userinput"><code>Chase</code></strong> state.</p><p>The <strong class="userinput"><code>Shoot</code></strong> state and the <strong class="userinput"><code>Chase</code></strong> state will share a common condition, which is whether or not the player is visible. We'll determine this via a simple raycast, which will, in turn, tell us whether the player was in the line of sight or not. The best parameter for this is a Boolean, so create a Boolean and call it <code class="literal">isPlayerVisible</code>. Leave the parameter unchecked, which means false.</p><p>Now we'll assign the <span>conditions</span><a id="id288320025" class="indexterm"></a> via the transition connectors' inspector. To do this, simply select a connector. When selected, the inspector will display some information about the current transition and, most importantly, the conditions, which show up as a list. To add a condition, simply click on the <strong class="userinput"><code>+</code></strong> (plus) sign:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/2beb5e7f-acfa-42c1-8a6d-8e8e3fb8f746.png" /></div><p>Let's tackle each transition one by one:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Patrol</code></strong> to <strong class="userinput"><code>Chase</code></strong><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>distanceFromPlayer</code></strong> &lt; <strong class="userinput"><code>5</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>isPlayerVisible</code></strong> == <strong class="userinput"><code>true</code></strong></li></ul></div></li></ul></div><div class="mediaobject"><img src="/graphics/9781788477901/graphics/e8304179-b779-4edb-940a-7a4f97d16929.png" /></div><p>The Patrol to Chase transition conditions
</p><p>Chase to patrol gets a bit more interesting as we have two <span class="emphasis"><em>separate</em></span> conditions that can trigger a transition. If we were to simply add two <span>conditions</span><a id="id288566945" class="indexterm"></a> to that transition, both would have to be evaluated to true in order for the transition to occur. But we want to check whether the player is out of range or out of sight. Luckily, we can have multiple transitions between the same two states. Simply add another transition connection as you normally would. Right-click on the <strong class="userinput"><code>Chase</code></strong> state and then make a transition to the <strong class="userinput"><code>Patrol</code></strong> state. You'll notice that you now have two transitions listed at the top of the inspector. In addition, your transition connection indicator shows multiple arrows instead of just one to indicate that there are multiple transitions between these two states. Selecting each transition in the inspector will allow you to give each one separate conditions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Chase</code></strong> to <strong class="userinput"><code>Patrol</code></strong> (<span>A</span>)
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>distanceFromPlayer</code></strong> &gt; <strong class="userinput"><code>5</code></strong></li></ul></div></li><li style="list-style-type: disc"><strong class="userinput"><code>Chase</code></strong> to <strong class="userinput"><code>Patrol</code></strong> (B)
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>isPlayerVisible</code></strong> == <strong class="userinput"><code>false</code></strong></li></ul></div></li><li style="list-style-type: disc"><strong class="userinput"><code>Chase</code></strong> to <strong class="userinput"><code>Shoot</code></strong><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>distanceFromPlayer</code></strong> &lt; <strong class="userinput"><code>3</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>isPlayerVisible</code></strong> == <strong class="userinput"><code>true</code></strong></li></ul></div></li><li style="list-style-type: disc"><strong class="userinput"><code>Shoot</code></strong> to <strong class="userinput"><code>Chase</code></strong><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>distanceFromPlayer</code></strong> &gt; <strong class="userinput"><code>3</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>distanceFromPlayer</code></strong> &lt; <strong class="userinput"><code>5</code></strong></li><li style="list-style-type: disc"><strong class="userinput"><code>isPlayerVisible</code></strong> == <strong class="userinput"><code>true</code></strong></li></ul></div></li><li style="list-style-type: disc"><strong class="userinput"><code>Shoot</code></strong> to <strong class="userinput"><code>Patrol</code></strong> (A)
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>distanceFromPlayer</code></strong> &gt; <strong class="userinput"><code>6</code></strong></li></ul></div></li><li style="list-style-type: disc"><strong class="userinput"><code>Shoot</code></strong> to <strong class="userinput"><code>Patrol</code></strong> (B)
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>isPlayerVisible</code></strong> == <strong class="userinput"><code>false</code></strong></li></ul></div></li></ul></div><p>We now have our states and transitions set. Next, we need to create the script that will drive these values. All we need to do is set the values, and the state machine will handle the rest.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec2"></a>Driving parameters via code</h4></div></div></div><p>Before going any further, we'll need a few <span>things</span><a id="id288567168" class="indexterm"></a> from the assets we imported earlier in the chapter. For starters, go ahead and open the <code class="literal">DemoScene</code> for this chapter. You'll notice the scene is fairly stripped down and only contains an environment prefab and some waypoint transforms. Go ahead and drop the <code class="literal">EnemyTankPlaceholder</code> prefab into the scene.</p><p>You may notice a few components that you may or may not be familiar with on the <code class="literal">EnemyTank</code>. We'll get a chance to thoroughly explore <code class="literal">NavMesh</code> and <code class="literal">NavMeshAgent</code> in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Finding Your Way</em></span>, but for now, these are necessary <span>components</span><a id="id288567202" class="indexterm"></a> to make the whole thing work. What you will want to focus on is the <code class="literal">Animator</code> component which will house the state machine (animator controller) we created earlier. Go ahead and drop the state machine into the empty slot before continuing.</p><p>We will also need a placeholder for the player. Go ahead and drop in the <code class="literal">PlayerTankPlaceholder</code> prefab as well. We won't be doing much with this for now. As with the enemy tank placeholder prefab, the player tank placeholder prefab has a few components that we can ignore for now. Simply place it in the scene and continue.</p><p>Next, you'll want to add a new component to the <code class="literal">EnemyTankPlaceholder</code> game object—the <code class="literal">TankAi.cs</code> script, which is located in the <code class="literal">Chapter 2</code> scripts folder. If we open up the script, we'll find this inside it:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
public class TankAi : MonoBehaviour { 
    // General state machine variables 
    private GameObject player; 
    private Animator animator; 
    private Ray ray; 
    private RaycastHit hit; 
    private float maxDistanceToCheck = 6.0f; 
    private float currentDistance; 
    private Vector3 checkDirection; 
 
    // Patrol state variables 
    public Transform pointA; 
    public Transform pointB; 
    public NavMeshAgent navMeshAgent; 
     
    private int currentTarget; 
    private float distanceFromTarget; 
    private Transform[] waypoints = null; 
 
    private void Awake() { 
        player = GameObject.FindWithTag("Player"); 
        animator = gameObject.GetComponent&lt;Animator&gt;(); 
        pointA = GameObject.Find("p1").transform; 
        pointB = GameObject.Find("p2").transform; 
        navMeshAgent = gameObject.GetComponent&lt;NavMeshAgent&gt;(); 
        waypoints = new Transform[2] { 
            pointA, 
            pointB 
        }; 
        currentTarget = 0; 
        navMeshAgent.SetDestination(waypoints[currentTarget].position); 
    } 
 
    private void FixedUpdate() { 
        //First we check distance from the player  
        currentDistance = Vector3.Distance(player.transform.position, transform.position); 
        animator.SetFloat("distanceFromPlayer", currentDistance); 
 
        //Then we check for visibility 
        checkDirection = player.transform.position - transform.position; 
        ray = new Ray(transform.position, checkDirection); 
        if (Physics.Raycast(ray, out hit, maxDistanceToCheck)) { 
            if(hit.collider.gameObject == player){ 
                animator.SetBool("isPlayerVisible", true); 
            } else { 
                animator.SetBool("isPlayerVisible", false); 
            } 
        } else { 
            animator.SetBool("isPlayerVisible", false); 
        } 
 
        //Lastly, we get the distance to the next waypoint target 
        distanceFromTarget = Vector3.Distance(waypoints[currentTarget].position, transform.position); 
        animator.SetFloat("distanceFromWaypoint", distanceFromTarget); 
    } 
 
    public void SetNextPoint() { 
        switch (currentTarget) { 
            case 0: 
                currentTarget = 1; 
                break; 
            case 1: 
                currentTarget = 0; 
                break; 
        } 
        navMeshAgent.SetDestination(waypoints[currentTarget].position); 
    } 
}</pre><p>We have a series of variables that are required to run this script, so we'll run through what they're for in order:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">GameObject player</code>: This is a reference to the player placeholder prefab we dropped in earlier.</li><li style="list-style-type: disc"><code class="literal">Animator animator</code>: This is the animator for our enemy tank, which contains the state machine we created.</li><li style="list-style-type: disc"><code class="literal">Ray ray</code>: This is simply a declaration for a ray that we'll use in a raycast test on our <code class="literal">FixedUpdate</code> loop.</li><li style="list-style-type: disc"><code class="literal">RaycastHit hit</code>: This is a declaration for the hit information we'll receive from our raycast test.</li><li style="list-style-type: disc"><code class="literal">Float maxDistanceToCheck</code>: This number coincides with the value we set in our transitions inside the state machine earlier. Essentially, we are saying that we're only checking as far as this distance for the player. Beyond that, we can assume that the player is out of range.</li><li style="list-style-type: disc"><code class="literal">Float currentDistance</code>: This is the current distance between the player and the enemy tanks.</li></ul></div><p>You'll notice we skipped a few variables. Don't worry, we'll come back to cover these later. These are the variables we'll be using for our <strong class="userinput"><code>Patrol</code></strong> state.</p><p>Our <code class="literal">Awake</code> method handles fetching the references to our player and animator variables. You can also declare the preceding variables as public or prefix them with the <code class="literal">[SerializeField]</code> attribute and set them via the inspector.</p><p>The <code class="literal">FixedUpdate</code> method is fairly straightforward; the first part gets the distance between the position of the player and the enemy tank. The part to pay special attention to is <code class="literal">animator.SetFloat("distanceFromPlayer", currentDistance)</code>, which passes the information from this script into the parameter we defined earlier for our state machine. The same is true for the preceding section of the code, which passes in the hit result of the raycast as a Boolean. Lastly, it sets the <code class="literal">distanceFromTarget</code> variable, which we'll be using for the <strong class="userinput"><code>Patrol</code></strong> state in the next section.</p><p>As you can see, none of the code concerns itself with how or why the state machine will handle transitions; it merely passes in the information the state machine needs, and the state machine handles the rest. Pretty cool, right?</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec3"></a>Making our enemy tank move</h4></div></div></div><p>You may have noticed in addition to the variables we didn't cover yet, that our <span>tank</span><a id="id288573214" class="indexterm"></a> has no logic in place for moving. This can be easily handled with a substate machine, which is a state machine within a state. This may sound confusing at first, but we can easily break down the <strong class="userinput"><code>Patrol</code></strong> state into substates. In our example, the <strong class="userinput"><code>Patrol</code></strong> state will be in one of the two substates—moving to the current waypoint or finding the next waypoint. A waypoint is essentially a destination for our agent to move toward. In order to make these changes, we'll need to go into our state machine again.</p><p>First, create a substate by clicking on an empty area on the canvas and then selecting <strong class="userinput"><code>Create Sub-State Machine</code></strong>. Since we already have our original <strong class="userinput"><code>Patrol</code></strong> state and all the connections that go with it, we can just drag and drop our <strong class="userinput"><code>Patrol</code></strong> state into our newly-created substate to merge the two. As you drag the <strong class="userinput"><code>Patrol</code></strong> state over the substate, you'll notice a plus sign appears by your cursor; this means you're adding one state to the other. When you drop the <strong class="userinput"><code>Patrol</code></strong> state in, the new substate will absorb it. Substates have a unique look: they are six-sided rather than rectangular. Go ahead and rename the substate to <code class="literal">Patrol</code>:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/19cf4a82-1909-4a38-a3b3-5b90a3806c74.png" /></div><p>To enter a substate, simply double-click on it. Think of it as going a level lower into the substate. The window will look fairly similar, but you will notice a few things—your <strong class="userinput"><code>Patrol</code></strong> state is connected to a node called <strong class="userinput"><code>(<strong class="userinput"><code>Up) Base Layer</code></strong></code></strong>, which essentially is the connection from this level to the upper level that the substate machine sits on. The <strong class="userinput"><code>Entry</code></strong> state connects directly to the <strong class="userinput"><code>Patrol</code></strong> state.</p><p>Unfortunately, this is not the functionality we want, as it's a closed <span>loop</span><a id="id288573316" class="indexterm"></a> that doesn't allow us to get in and out of the state into the individual waypoint states we need to create; so let's make some changes. First, we'll change the name of the substate to <code class="literal">PatrolEntry</code>. Next, we need to assign some transitions. When we enter this <strong class="userinput"><code>Entry</code></strong> state, we want to decide whether to continue moving to the current waypoint, or to find a new one. We'll represent each of the outcomes as a state, so create two states, <code class="literal">MovingToTarget</code> and <code class="literal">FindingNewTarget</code>, then create transitions from the <strong class="userinput"><code>PatrolEntry</code></strong> state to each one of the new states. Likewise, you'll want to create a transition between the two new states, meaning a transition from the <code class="literal">MovingToTarget</code> state to the <code class="literal">FindingNewTarget</code> state and vice versa. Now, add a new float parameter called <code class="literal">distanceFromWaypoint</code> and set up your conditions like this:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>PatrolEntry</code></strong> to <strong class="userinput"><code>MovingToTarget</code></strong>:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>distanceFromWaypoint</code></strong> &gt; <strong class="userinput"><code>1</code></strong></li></ul></div></li><li style="list-style-type: disc"><strong class="userinput"><code>PatrolEntry</code></strong> to <strong class="userinput"><code>FindingNewTarget</code></strong>:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>distanceFromWaypoint</code></strong> &lt; <strong class="userinput"><code>1</code></strong></li></ul></div></li><li style="list-style-type: disc"><strong class="userinput"><code>MovingToTarget</code></strong> to <strong class="userinput"><code>FindingNewTarget</code></strong>:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>distanceFromWaypoint</code></strong> &lt; <strong class="userinput"><code>1</code></strong></li></ul></div></li></ul></div><p>You're probably wondering why we didn't assign the transition rule from the <strong class="userinput"><code>FindingNewTarget</code></strong> state to the <strong class="userinput"><code>MovingToTarget</code></strong> state. This is because we'll be executing some code via state machine behavior and then automatically going into the <strong class="userinput"><code>MovingToTarget</code></strong> state without requiring any conditions. Go ahead and select the <strong class="userinput"><code>FindingNewTarget</code></strong> state and add a behavior and call it <code class="literal">SelectWaypointState</code>.</p><p>Open up the new script and remove all the methods, except for <code class="literal">OnStateEnter</code>. Add the following functionality to it:</p><pre class="programlisting">TankAi tankAi = animator.gameObject.GetComponent&lt;TankAi&gt;();
tankAi.SetNextPoint();</pre><p>What we're doing here is getting a reference to our <code class="literal">TankAi</code> script and calling its <code class="literal">SetNextPoint()</code> method. Simple enough, right?</p><p>Lastly, we need to redo our outgoing connections. Our new states don't have transitions out of this level, so we need to add one, using the exact same conditions that our <strong class="userinput"><code>PatrolEntry</code></strong> state has, to the <strong class="userinput"><code>(Up</code></strong><strong class="userinput"><code>)</code></strong><strong class="userinput"><code>Base Layer</code></strong> state. This is where <strong class="userinput"><code>Any State</code></strong> comes in handy—it allows us to transition from any state to another state, regardless of individual transition connections, so that we don't have to add transitions from each state to the <strong class="userinput"><code>(Up) Base Layer</code></strong> state; we simply add it once to the <strong class="userinput"><code>Any State</code></strong>, and we're set! Add a transition from the <strong class="userinput"><code>Any State</code></strong> to the <strong class="userinput"><code>PatrolEntry</code></strong> state and use the same conditions the <strong class="userinput"><code>Entry</code></strong> state has to the <strong class="userinput"><code>(Up) Base Layer</code></strong> state. This is a workaround for not being able to connect directly from the <strong class="userinput"><code>Any State</code></strong> to the (<strong class="userinput"><code>Up) Base Layer</code></strong> state.</p><p>When you're done, your substate machine <span>should</span><a id="id288573624" class="indexterm"></a> look similar to this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/fe1053ae-6c24-4a61-aadc-1604126b06b5.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec4"></a>Testing</h4></div></div></div><p>Now, all we have to do is hit play and watch our <span>enemy</span><a id="id288573684" class="indexterm"></a> tank patrol back and forth between the two provided waypoints. If we place the player in the editor, in the enemy tank's path, we'll see the transition happen in the animator, out of the <strong class="userinput"><code>Patrol</code></strong> state and into the <strong class="userinput"><code>Chase</code></strong> state, and when we move the player out of range, back into the <strong class="userinput"><code>Patrol</code></strong> state. You'll notice our <strong class="userinput"><code>Chase</code></strong> and <strong class="userinput"><code>Shoot</code></strong> states are not fully fleshed out yet. This is because we'll be implementing these states via concepts we'll cover in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Implementing Sensors</em></span>, and <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Finding Your Way</em></span>.</p></div></div></div>