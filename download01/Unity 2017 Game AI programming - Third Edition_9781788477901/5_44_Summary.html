<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec48"></a>Summary</h2></div></div><hr /></div><p>In this chapter, we learned how to implement a flocking behavior system. We implemented it using custom direction vectors to control the boids' movement that we calculated by applying Craig Reynolds' three main flocking concepts—alignment, coherence, and separation. We then applied our flocking behavior to the flying objects, but you can apply the techniques in these examples to implement other character behaviors, such as fish shoaling, insects swarming, or land animals herding. You'll only have to implement different leader movement behaviors, such as limiting movement along the <span class="emphasis"><em>y</em></span> axis for characters that can't move up and down. For a 2D game, we would just freeze the <span class="emphasis"><em>y</em></span> position. For 2D movement along uneven terrain, we would have to modify our script to not put any forces in the <span class="emphasis"><em>y</em></span> direction. </p><p>We also took a look at crowd simulation and even implemented our own version of it using Unity's NavMesh system, which we first learned about in <a class="link" href="#" linkend="ch04"><span>Chapter 4</span></a>, <span class="emphasis"><em>Finding Your Way</em></span>. We learned how to visualize our agents' behavior and decision-making process.</p><p>In the next chapter, we'll look at the behavior tree pattern and learn to implement our own version of it from scratch.</p></div>