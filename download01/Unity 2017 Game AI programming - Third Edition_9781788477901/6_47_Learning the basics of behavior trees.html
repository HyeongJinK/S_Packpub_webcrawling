<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec50"></a>Learning the basics of behavior trees</h2></div></div><hr /></div><p>Behavior trees got their <span>name</span><a id="id288183624" class="indexterm"></a> from their hierarchical, branching system of nodes with a common parent, known as the root. As you've surely learned by now from reading this book, behavior trees too mimic the real thing they are named after—in this case, trees and their branching structure. If we were to visualize a behavior tree, it would look something like the following figure:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/200d874e-ce5e-483b-8a64-774a9d90fc3d.png" /></div><p>A basic tree structure</p><p>Of course, behavior trees can be <span>made</span><a id="id288572872" class="indexterm"></a> up of any number of nodes and child nodes. The nodes at the very end of the hierarchy are referred to as leaf nodes, just like a tree. Nodes can represent behaviors or tests. Unlike state machines, which rely on transition rules to traverse through them, a BT's flow is defined strictly by each node's order within the larger hierarchy. A BT begins evaluating from the top of the tree (based on the preceding visualization), then continues through each child, which, in turn, runs through each of its children until a condition is met or the leaf node is reached. BTs always begin evaluating from the root node.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec42"></a>Understanding different node types</h3></div></div></div><p>The names of the different types of node may vary <span>depending</span><a id="id288572887" class="indexterm"></a> on who you ask, and even nodes themselves are sometimes referred to as tasks. While the complexity of a tree is dependent entirely upon the needs of the AI, the high-level concepts about how BTs work are fairly easy to understand if we look at each component individually. The following is true for each node regardless of what type of node we're referring to. A node will always return one of the following states:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Success</strong></span>: The condition the node was checking for has been met.</li><li style="list-style-type: disc"><span class="strong"><strong>Failure</strong></span>: The condition the node was checking for was not, and will not, be met.</li><li style="list-style-type: disc"><span class="strong"><strong>Running</strong></span>: The validity of the condition the node is checking for has not been determined. Think of this as our "please wait" state.</li></ul></div><p>Due to the potential complexity of a BT, most implementations are asynchronous, which, at least for Unity, means that evaluating a tree will not block the game from continuing other operations. The evaluation process of the various nodes in a BT can take several frames, if necessary. If you had to evaluate several trees on any number of agents at a time, you can imagine how it would negatively affect the performance of the program to have to wait for each of them to return a true or false to the root node. This is why the "<span>running</span>" state is important.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec12"></a>Defining composite nodes</h4></div></div></div><p>Composite nodes are called so as they <span>have</span><a id="id288319968" class="indexterm"></a> one or more children. Their state is based entirely upon the result of evaluating their children, and while their children are being evaluated, they will be in a "running" state. There are a couple of composite node types, which are mostly defined by how their children are evaluated:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Sequences</strong></span>: The defining characteristic of a <span>sequence</span><a id="id288319985" class="indexterm"></a> is that the entire sequence of children needs to complete successfully in order for it to evaluate as a success itself. If any of the children at any step of the sequence return false, the sequence itself will report a failure. It is important to note that, in general, sequences are executed from left to right.</li></ul></div><p> </p><p>The following figures show a successful <span>sequence</span><a id="id288319997" class="indexterm"></a> and a failed sequence, respectively:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/1fd56e97-1f55-4674-a456-3568dc24b091.png" /></div><p>A successful sequence node</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/acc205e8-d189-4c80-84b7-7e6b71450f94.png" /></div><p>An unsuccessful sequence node</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Selectors</strong></span>: By comparison, selectors are much more forgiving parents to their children nodes. If any one of the children nodes in a selector <span>sequence</span><a id="id288320073" class="indexterm"></a> returns true, the selector says, "eh, good enough!" and returns true immediately, without evaluating any more of its children. The only way a selector node will return false is if all of its children are evaluated and none of them return a success.</li></ul></div><p>Of course, each composite node type has its use depending on the situation. You can think of the different types of sequence nodes as "and" and "or" conditionals.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec13"></a>Understanding decorator nodes</h4></div></div></div><p>The biggest difference <span>between</span><a id="id288320090" class="indexterm"></a> a composite node and a <span>decorator</span><a id="id288320099" class="indexterm"></a> node is that a decorator can have exactly one child, and one child only. At first, this may seem unnecessary as you would, in theory, be able to get the same functionality by containing the condition in the node itself rather than relying on its child, but the decorator node is special in that it essentially takes the state returned by the child and evaluates the response based on its own parameters. A decorator can even specify how its children are evaluated and how often they are evaluated. These are some common decorator types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Inverter</strong></span>: Think of the <span>inverter</span><a id="id288320117" class="indexterm"></a> as a NOT modifier. It takes the opposite of the state returned by its child. For example, if the child returns TRUE, the decorator evaluates as FALSE, and vice versa. This is the equivalent of having the <code class="literal">!</code> operator in front of a Boolean in C#.</li><li style="list-style-type: disc"><span class="strong"><strong>Repeater</strong></span>: This repeats the <span>evaluation</span><a id="id288320134" class="indexterm"></a> of the child a specified (or infinite) number of times until it evaluates as either TRUE or FALSE as determined by the decorator. For example, you may want to wait indefinitely until a certain condition is met, such as "having enough energy" before a character uses an attack.</li><li style="list-style-type: disc"><span class="strong"><strong>Limiter</strong></span>: This simply limits the <span>number</span><a id="id288320148" class="indexterm"></a> of times a node will be evaluated to avoid getting an agent stuck in an awkward infinite behavior loop. This decorator, in contrast to the repeater, can be used to make sure a character only tries to, for example, kick the door open so many times before giving up and trying something else.</li></ul></div><p>Some decorator nodes can be used for debugging and testing your trees, for example:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Fake state</strong></span>: This always evaluates true or false as specified by the decorator. This is very helpful for asserting certain behavior in your agent. For example, you can also have the decorator maintain a fake "running" state indefinitely to see how other agents around it will behave.</li><li style="list-style-type: disc"><span class="strong"><strong>Breakpoint</strong></span>: Just like a breakpoint in code, you can have this node fire off logic to notify you via debug logs or other methods that the node has been reached.</li></ul></div><p>These types are not monolithic archetypes that are mutually exclusive. You can combine these types of nodes to suit your needs. Just be careful not to combine too much functionality into one decorator to the point where it may be more efficient or convenient to use a sequence node instead.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec14"></a>Describing the leaf node</h4></div></div></div><p>We briefly covered leaf nodes earlier in the <span>chapter</span><a id="id288320182" class="indexterm"></a> to make a point about the <span>structure</span><a id="id288320188" class="indexterm"></a> of a BT, but leaf nodes, in reality, can be just about any sort of behavior. They are magical in the sense that they can be used to describe any sort of logic your agent can have. A leaf node can specify a walk function, shoot command, or kick action. It doesn't matter what it does or how you decide to have it evaluate its states, it just has to be the last node in its own hierarchy and return any of the three states a node can return.</p></div></div></div>