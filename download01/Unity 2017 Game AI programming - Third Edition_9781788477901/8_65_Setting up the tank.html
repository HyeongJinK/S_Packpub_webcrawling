<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec66"></a>Setting up the tank</h2></div></div><hr /></div><p>The example project also includes a prefab for the tank, which is <span>simply</span><a id="id288183624" class="indexterm"></a> called (you guessed it) <code class="literal">Tank</code>, inside the <code class="literal">Prefabs</code> folder.</p><p>The tank itself is a simple agent with one goal: reach the end of the maze. As mentioned earlier, the player has to help the tank out along the way by activating its abilities to keep it safe from oncoming fire from the towers.</p><p>By now, you should be fairly familiar with the components you'll encounter along the way, except for the <code class="literal">Tank.cs</code> component attached to the prefab. Let's take a look at the code to figure out what's going on behind the scenes:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
public class Tank : MonoBehaviour { 
    [SerializeField] 
    private Transform goal; 
    private NavMeshAgent agent; 
    [SerializeField] 
    private float speedBoostDuration = 3; 
    [SerializeField] 
    private ParticleSystem boostParticleSystem; 
    [SerializeField] 
    private float shieldDuration = 3f; 
    [SerializeField] 
    private GameObject shield; 
 
    private float regularSpeed = 3.5f; 
    private float boostedSpeed = 7.0f; 
    private bool canBoost = true; 
    private bool canShield = true; </pre><p>There are a number of values that we want to be able to tweak easily, so we declare the corresponding variables first. Everything from the duration of our abilities to the effects associated with them is set here first:</p><pre class="programlisting">    private bool hasShield = false; 
private void Start() { 
        agent = GetComponent&lt;NavMeshAgent&gt;(); 
        agent.SetDestination(goal.position); 
    } 
 
    private void Update() { 
        if (Input.GetKeyDown(KeyCode.B)) { 
            if (canBoost) { 
                StartCoroutine(Boost()); 
            } 
        } 
        if (Input.GetKeyDown(KeyCode.S)) { 
            if (canShield) { 
                StartCoroutine(Shield()); 
            } 
        } 
    } </pre><p>Our <code class="literal">Start</code> method <span>simply</span><a id="id288319936" class="indexterm"></a> does some setup for our tank; it grabs the <code class="literal">NavMeshAgent</code> component and sets its destination to be equal to our goal variable. We will discuss that in more detail soon.</p><p>We use the <code class="literal">Update</code> method to catch the input for our abilities. We've mapped <code class="literal">B</code> to <code class="literal">boost</code> and <code class="literal">S</code> to <code class="literal">shield</code>. As these are timed abilities, much like the towers' ability to shoot, we implement these via coroutines:</p><pre class="programlisting">private IEnumerator Shield() { 
        canShield = false; 
        shield.SetActive(true); 
        float shieldCounter = 0f; 
        while (shieldCounter &lt; shieldDuration) { 
            shieldCounter += Time.deltaTime; 
            yield return null; 
        } 
        canShield = true; 
        shield.SetActive(false); 
    } 
 
    private IEnumerator Boost() { 
        canBoost = false; 
        agent.speed = boostedSpeed; 
        boostParticleSystem.Play(); 
        float boostCounter = 0f; 
        while (boostCounter &lt; speedBoostDuration) { 
            boostCounter += Time.deltaTime; 
            yield return null; 
        } 
        canBoost = true; 
        boostParticleSystem.Pause(); 
        agent.speed = regularSpeed; 
    }</pre><p>The two abilities' logic is very similar. The <code class="literal">shield</code> enables and disables the <code class="literal">shield</code> game object, which we define in a variable in the inspector, and after an amount of time equal to <code class="literal">shieldDuration</code> has passed, we turn it off and allow the player to use the <code class="literal">shield</code> again.</p><p>The main difference in the <code class="literal">Boost</code> code is that rather than enabling and disabling a game object, the <code class="literal">boost</code> calls <code class="literal">Play</code> on a particle system we assign via the inspector and also sets the <span>speed</span><a id="id288559478" class="indexterm"></a> of our <code class="literal">NavMeshAgent</code> to double the original value, before resetting it at the end of the ability's duration.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Note</h3><p>Can you think of other abilities you'd give the tank? This is a very straightforward pattern that you can use to implement new abilities in your own variant of the project. You can also add additional logic to customize the shield and boost abilities here.</p></div><p>The sample scene already has an instance of the tank in it with all the variables properly set up. The inspector for the tank in the sample scene looks similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/9dc18399-1263-4ac5-84f2-07df32a2bb15.png" /></div><p>Inspector with the tank instance selected</p><p>As you can see in the preceding screenshot, we've assigned the <code class="literal">Goal</code> variable to a transform with the same name, which is located in the scene at the end of the maze we've set up. We can also tweak the duration of our abilities here, which is set to <strong class="userinput"><code>3</code></strong> by default. You can also swap out the art for the abilities, be it the particle system used in the boost or the game object used for the shield.</p><p>The last bit of code to look at is the code driving the camera. We want the camera to follow the player, but only along its <code class="literal">z</code> value, horizontally down the track. The code to achieve this looks similar to this:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
public class HorizontalCam : MonoBehaviour { 
    [SerializeField] 
    private Transform target; 
 
    private Vector3 targetPositon; 
 
    private void Update() { 
        targetPositon = transform.position; 
        targetPositon.z = target.transform.position.z; 
        transform.position = Vector3.Lerp(transform.position, targetPositon, Time.deltaTime); 
    } 
} </pre><p>As you can see, we simply set the target position of the camera equal to its current position on all axes, but we then assign the <span class="emphasis"><em>z</em></span> axis of the target position to be the same as our target's, which, if you look in the inspector, has been set to the transform of the tank. We then use linear interpolation (<code class="literal">Vector3.Lerp</code>) to smoothly translate the camera from its current position to its target position every frame.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec67"></a>Bonus tank abilities</h3></div></div></div><p>The sample project also includes three bonus <span>tank</span><a id="id288562525" class="indexterm"></a> abilities for you to play with. Of course, you are highly encouraged to modify these abilities or implement your own custom rules, but for the sake of spicing up the example a bit, all you have to do is add the component for each ability you want to add to the tank prefab.</p><p>The b<span>onus abilities are</span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Hulk mode</strong></span>: Your tank grows in size for a set amount of time. Want a challenge? Implement a health and armor system similar to our <span class="emphasis"><em>HomeRock</em></span> example from <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Behavior Trees, </em></span>and have the buff be represented visually by this ability!</li><li style="list-style-type: disc"><span class="strong"><strong>Shrink mode</strong></span>: It's the opposite of hulk mode, duh! Your tank shrinks for a set period of time. If you're feeling up to the task, try implementing a stealth system where turrets are unable to detect your tank while it's in shrink mode. </li><li style="list-style-type: disc"><span class="strong"><strong>Time warp, or as I like to call it, DMV mode</strong></span>: This ability sloooows down time to a crawl. If you want a real challenge, try implementing a selective weapon system, where the turrets could try to outsmart you by using a faster projectile to counter your time warp mode!</li></ul></div><p>Where you take the abilities system is up to you. It's always fun to see what different directions readers take their own versions of these samples. If you have a cool twist on this or any of the previous samples, share them with the author via Twitter (<code class="literal">@ray_barrera</code>).</p></div></div>