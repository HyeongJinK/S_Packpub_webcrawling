<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec47"></a>Using crowds</h2></div></div><hr /></div><p>Crowd simulations are far less cut-and-dried. There really isn't any <span class="emphasis"><em>one</em></span> way to implement them in a general sense. While not a strict definition, the term "crowd simulation" generally refers to simulating <span>crowds</span><a id="id288319745" class="indexterm"></a> of humanoid agents navigating an area while avoiding each other and the environment. Like flocks, the use of crowd simulations has been widely used in films. For example, the epic armies of Rohan, Gondor, and Mordor battling one another in <span class="emphasis"><em>The Lord of the Rings</em></span> were completely procedurally generated using the crowd simulation software <span class="strong"><strong>Massive</strong></span>, which was created for use in the film. While the use of crowd algorithms is not as widespread in video games as in films, certain genres rely on the concept more than others. Real-time strategy games often involve armies of characters moving in unison across the screen, and many sandbox games simulate dense cities with many agents on-screen going about their day while avoiding each other, the player, and even traffic.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec39"></a>Implementing a simple crowd simulation</h3></div></div></div><p>Our implementation will be quick, simple, and effective, and it will focus on using Unity's NavMesh feature. Thankfully, NavMesh will handle much of the heavy lifting for us. Our sample Crowds scene has a simple walking surface with a NavMesh baked onto it, a couple of targets, and two teams of capsules, as shown in the <span>following</span><a id="id288320389" class="indexterm"></a> screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/ac85258a-61c8-45d5-855e-f2edfa79c16a.png" /></div><p>The classic scenario: red versus blue</p><p>In the preceding screenshot, we can see that our red and blue targets are opposite their teams: red and blue, respectively. Your guess is as good as mine as to why the blue and red clans just can't get along, but it'll work for our sample, so I'm just going to let them do their thing. The setup is straightforward. Each capsule has a <code class="literal">CrowdAgent.cs</code> component attached to it, and when you hit play, each agent will head towards their target while avoiding each other and the oncoming capsules from the opposite team. Once they reach their destination, they will gather around the target.</p><p>This setup takes our example from <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Finding Your Way </em></span>and takes it to the next level. Now we have large groups of agents that are not only navigating to a target location, but doing so while avoiding large groups of agents at the same time. As you can see, Unity's NavMesh handles these interactions beautifully. The system is efficient and very robust.</p><p>While the game is running, you can even select a single capsule or a group of them in the editor to see their behavior visualized. As long as you have the navigation window active, you'll be able to see some <span>debugging</span><a id="id288562528" class="indexterm"></a> information about your NavMesh and the agents on it, as you can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/d1c8d446-d013-4c96-9cf8-a1a7c2f79db4.jpg" /></div><p>The debug view from an agent's perspective</p><p>It's worth checking this out in the editor to really get an idea of how this looks in motion, but we've labeled a few key elements in the preceding screenshot:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>This is the destination arrow that points toward the <code class="literal">NavMeshAgent</code> destination, which for this little guy is <code class="literal">RedTarget</code>. All this arrow cares about is where the destination is, regardless of the direction the agent is facing or moving toward.</li><li>This arrow is the heading arrow. It shows the actual direction the agent is moving in. The direction of the agent takes into account several factors, including the position of its neighbors, space on the NavMesh, and the destination.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>This debug menu allows you to show a few different things. In our case, we enabled <strong class="userinput"><code>Show Avoidance</code></strong> and <strong class="userinput"><code>Show Neighbours</code></strong>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Speaking of avoidance, this cluster of squares, ranging from dark to light and floating over the agents, represents the areas to avoid between our agent and the destination. The darker squares indicate areas that are densely populated by other agents or blocked by the environment, while the lighter-white squares indicate areas that are safe to walk through. Of course, this is a dynamic display, so watch it change as you play in the editor.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec40"></a>Using the CrowdAgent component</h3></div></div></div><p>The <code class="literal">CrowdAgent</code> component is incredibly simple, but gets the job done. As <span>mentioned</span><a id="id288563779" class="indexterm"></a> earlier, Unity does most of the heavy lifting for us. The following code gives our <code class="literal">CrowdAgent</code> a destination:</p><pre class="programlisting">using UnityEngine; 
using System.Collections; 
 
[RequireComponent(typeof(NavMeshAgent))] 
public class CrowdAgent : MonoBehaviour 
{         
    public Transform target; 
 
    private NavMeshAgent agent; 
 
    void Start () 
    { 
        agent = GetComponent&lt;NavMeshAgent&gt;(); 
        agent.speed = Random.Range(4.0f, 5.0f); 
        agent.SetDestination(target.position); 
    } 
}</pre><p>The script requires a component of type <code class="literal">NavMeshAgent</code>, which it assigns to the <code class="literal">agent</code> variable on <code class="literal">Start()</code>. We then set its speed randomly between two values for some added visual variety in our simulation. Lastly, we set its destination to be the position of the target marker. The target marker is assigned via the inspector, as you can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/48ae80ba-bb5f-4155-9e74-c3fd7ff028f9.png" /></div><p>The inspector settings for the NavMeshAgent</p><p>The preceding screenshot illustrates a red capsule's <code class="literal">CrowdAgent</code> component with <strong class="userinput"><code>RedTarget (Transform)</code></strong> set as its <strong class="userinput"><code>Target</code></strong>. For fun, you can try setting different targets. Since the only requirement is that it be of type <code class="literal">Transform</code>, you could even set another agent as the target!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec41"></a>Adding some fun obstacles</h3></div></div></div><p>Without having to do anything else in our code, we can make a few <span>changes</span><a id="id288568619" class="indexterm"></a> to our scene layout and enable a few components provided by Unity to dramatically alter the behavior of our agents. In our <code class="literal">CrowdsObstacles</code> scene, we've added a few walls to the environment, creating a maze-like layout for our red and blue teams of capsules to traverse, as you can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/c1c70ac6-6769-411d-b443-c64f489bab44.png" /></div><p>Let the games begin!
</p><p>The fun part about this example is that, because of the randomized speed of each agent, the results will be totally different each time you run the game. As the agents move through the environment, they'll be blocked by teammates or opposing agents and will be forced to re-route and find the quickest route to their target. Of course, this concept is not new to us, as we saw <code class="literal">NavMeshAgent</code> avoiding obstacles in <a class="link" href="#" linkend="ch04"><span>Chapter 4</span></a>, <span class="emphasis"><em>Finding Your Way</em></span>, except that we have many, many more agents in this scenario. To add a bit more fun to the example, we've also added a simple up-down animation to one of the walls and a <code class="literal">NavMeshObstacle</code> component, which looks something like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/3a39c8ea-40ce-4a2b-a266-6b5142371a2e.png" /></div><p>NavMeshObstacle looks a bit different in Unity 2017
</p><p>Note that our obstacle does not need to be set to <strong class="userinput"><code>Static</code></strong> when we are <span>using</span><a id="id288572888" class="indexterm"></a> this component. Our obstacle is mostly box-like, so we leave the default <strong class="userinput"><code>Shape</code></strong> setting as <strong class="userinput"><code>Box</code></strong> (<strong class="userinput"><code>Capsule</code></strong> is another choice). The <strong class="userinput"><code>Size</code></strong> and <strong class="userinput"><code>Center</code></strong> options let us move the outline of our shape around and resize it, but the default settings fit our shape perfectly, which is what we want, so let's leave that alone. The next option, <strong class="userinput"><code>Carve</code></strong>, is important. It essentially does exactly what it says; it carves a space out of the NavMesh, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/8b86e6ef-8d07-44ea-baae-a39ebde48977.jpg" /></div><p>The same obstacle at two different points of its up-down animation</p><p>The left screenshot shows the space carved out when the obstacle is on the surface, while the NavMesh is connected in the right screenshot when the obstacle is raised off the surface. We can leave <strong class="userinput"><code>Time to Stationary</code></strong> and <strong class="userinput"><code>Move Threshold</code></strong> as they are, but we do want to make sure that <strong class="userinput"><code>Carve Only Stationary</code></strong> is turned off. This is because our obstacle is moving, and if we didn't tick this box, it would not carve out the space from the NavMesh, and our agents would be trying to move through the obstacle whether it was up or down, which is not the behavior we are after in this case.</p><p>As the obstacle moves up and down and the mesh is carved out and reconnected, you'll notice the agents changing their heading. With the navigation debug options enabled, we can also see a very interesting visualization of everything going on with our agents at any given moment. It may seem a bit cruel to mess with our poor agents like this, but we're doing it for science!</p><p>The following screenshot gives us a glimpse into the chaos and disorder we're subjecting our poor agents to:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/97bfb41c-02d1-449c-a5fc-1dbe1bb8272f.jpg" /></div><p> </p><p> </p><p>I'm secretly rooting for the blue team</p></div></div>