<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec41"></a>Navigation mesh</h2></div></div><hr /></div><p>Next, we'll learn how to use Unity's built-in <span>navigation</span><a id="id288183608" class="indexterm"></a> mesh generator that can make pathfinding for AI agents a lot easier. Early in the Unity 5.x cycle, NavMesh was made available to all users, including personal edition licensees, whereas it was previously a Unity Pro-only feature. Before the release of 2017.1, the system was upgraded to allow a component-based workflow, but as it requires an additional downloadable package that, at the time of writing is only available as a preview, we will stick to the default scene-based workflow. Don't worry, the concepts carry over, and when the final <span>implementation</span><a id="id288183629" class="indexterm"></a> eventually makes its way to 2017.x, there shouldn't be drastic changes.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Note</h3><p>For more information on Unity's NavMesh component system, head over to GitHub: <a class="ulink" href="https://github.com/Unity-Technologies/NavMeshComponents" target="_blank">https://github.com/Unity-Technologies/NavMeshComponents</a>.</p></div><p>Now, we will dive in and explore all that this system has to offer. AI pathfinding needs a representation of the scene in a particular format; we've seen that using a 2D grid (array) for A* Pathfinding on a 2D map. AI agents need to know where the obstacles are, especially the static obstacles. Dealing with collision avoidance between dynamically moving objects is another subject, primarily known as steering behaviors. Unity has a built-in tool for generating a NavMesh that represents the scene in a context that makes sense for our AI agents to find the optimum path to the target. Pop open the demo project and navigate to the NavMesh scene to get started.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec30"></a>Inspecting our map</h3></div></div></div><p>Once you have the demo scene, NavMesh, open, it should look <span>something</span><a id="id288320286" class="indexterm"></a> like this screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/08555e87-82bb-448f-8b6f-4ac42e3d56cf.png" /></div><p>A scene with obstacles and slopes</p><p>This will be our sandbox to explain and test the NavMesh system functionality. The general setup is similar to an RTS (real-time strategy) game. You control the blue tank. Simply click at a location to make the tank move to that location. The yellow indicator is the current target location for the tank.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec31"></a>Navigation Static</h3></div></div></div><p>The first thing to point out is that you need to mark any <span>geometry</span><a id="id288566612" class="indexterm"></a> in the scene that will be baked into the NavMesh as <strong class="userinput"><code>Navigation Static</code></strong>. You may have encountered this elsewhere, such as in Unity's light-mapping system, for example. Setting game objects as static is easy. You can easily toggle the <code class="literal">Static</code> flag on for all purposes (navigation, lighting, culling, batching and so on), or you can use the dropdown to specifically select what you want. The toggle is found in the top-right corner of the inspector for the selected object(s). Look at this screenshot for a general idea of what you're looking for:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/f150af53-8805-4c8f-845a-04e674cdc0d8.png" /></div><p>The Navigation Static property</p><p>You can do this on a per-object basis, or, if you have a nested hierarchy of game objects in your hierarchy, you can apply the setting to the parent and Unity will prompt you to apply it to all children.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec32"></a>Baking the navigation mesh</h3></div></div></div><p>The navigation settings for the <span>navigation</span><a id="id288320321" class="indexterm"></a> mesh are applied via the <strong class="userinput"><code>Navigation</code></strong> window on a scene-wide basis. You can open the window by navigating to <span class="strong"><strong><strong class="userinput"><code>Window</code></strong></strong></span> | <strong class="userinput"><code>Navigation</code></strong> in the menu bar. Like any other window, you can detach it to be free-floating, or you can dock it. Our screenshots show it docked as a tab next to the hierarchy, but you can place this window anywhere you please.</p><p>With the window open, you'll notice four separate tabs. It'll look something like this screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/14c734b6-1cff-47ef-acbf-3f9f22fde399.png" /></div><p>The Navigation window</p><p>In our case, the preceding screenshot shows the <strong class="userinput"><code>Bake</code></strong> tab selected, but your editor might have one of the other tabs selected by default.</p><p>Let's take a look at each tab, starting from the left and <span>working</span><a id="id288320362" class="indexterm"></a> our way to the right, starting with the <strong class="userinput"><code>Agents</code></strong> tab, which looks like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/4b68c9c3-c62a-448d-85e1-84080b6a458f.png" /></div><p>The Agents tab</p><p>If you're working on a different project, you may find that some of these settings are different than what we set them to in the sample project from which the preceding screenshot was taken. At the top of the tab, you can see a list where you can add additional agent types by pressing the "<strong class="userinput"><code>+</code></strong>" button. You can remove any of these additional agents by selecting it and pressing the "<strong class="userinput"><code>-</code></strong>" button. The window provides a nice visual of what the various settings do as you tweak them. Let's take a look at what each setting does:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Name</strong></span>: The name of the agent type to be displayed in the <strong class="userinput"><code>Agent Types</code></strong> dropdown.</li><li style="list-style-type: disc"><span class="strong"><strong>Radius</strong></span>: Think of it as the agent's "personal space". Agents will try to avoid getting too cozy with other agents based on this value, as it uses it for avoidance.</li><li style="list-style-type: disc"><span class="strong"><strong>Height</strong></span>: As you may have guessed, it dictates the height of the agent, which it can use for vertical avoidance (passing under things, for example).</li><li style="list-style-type: disc"><span class="strong"><strong>Step Height</strong></span>: This value determines how high of an obstacle the agent can climb over.
</li><li style="list-style-type: disc"><span class="strong"><strong>Max Slope</strong></span>: As we'll see in the coming section, this value determines the max angle up which an agent can climb. This can be used to make steep areas of the map inaccessible to the agent.</li></ul></div><p>Next, we have the <strong class="userinput"><code>Areas</code></strong> tab, which looks like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/2c12bdd8-a12b-4540-81f4-b5663b3bee0a.png" /></div><p>As you can see in the preceding screenshot, Unity provides some default area types that cannot be edited: <strong class="userinput"><code>Walkable</code></strong>, <strong class="userinput"><code>Not Walkable</code></strong>, and <strong class="userinput"><code>Jump</code></strong>. In addition to naming and creating new areas, you can assign default costs to these areas.</p><p>Areas serve two purposes: making areas accessible or <span>inaccessible</span><a id="id288319844" class="indexterm"></a> per agent, and marking areas as less desirable in terms of navigation cost. For example, you may have an RPG where demon enemies cannot enter areas marked as "holy ground." You could also have areas of your map marked something like "marsh" or "swamp," which your agent could avoid based on the cost.</p><p>The third tab, <strong class="userinput"><code>Bake</code></strong>, is probably the most important. It allows you to create the actual NavMesh for your scene. You'll recognize some of the settings. The <strong class="userinput"><code>Bake</code></strong> tab looks like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/2db96c50-b108-4eaa-aec9-06c66388ed87.png" /></div><p>The Bake tab</p><p>The agent size settings in this tab dictate how agents interact with the environment, whereas the settings in the <strong class="userinput"><code>Agents</code></strong> tab dictate how they interact with other agents and moving objects, but they control the same parameters, so we'll skip those here. The <strong class="userinput"><code>Drop Height</code></strong> and <strong class="userinput"><code>Jump Distance</code></strong> control how far an agent can "jump" to reach a portion of the NavMesh that is not directly connected to the one the agent is currently on. We'll go over this in more detail up ahead, so don't sweat it if you're not quite sure what that means yet.</p><p>There are also some advanced settings that are generally <span>collapsed</span><a id="id288319888" class="indexterm"></a> by default. Simply click the drop-down triangle by the <strong class="userinput"><code>Advanced</code></strong> heading to unfold these options. You can think of the <strong class="userinput"><code>Manual Voxel Size</code></strong> setting as the "quality" setting. The smaller the size, the more detail you can capture in the mesh. The <strong class="userinput"><code>Min Region Area</code></strong> is used to skip baking platforms or surfaces below the given threshold. The <strong class="userinput"><code>Height Mesh</code></strong> gives you more detailed vertical data when baking the mesh. For example, it will help preserve the proper placement of your agent when climbing up stairs.</p><p>The <strong class="userinput"><code>Clear</code></strong> button will clear any NavMesh data for the scene, and the <strong class="userinput"><code>Bake</code></strong> button will create the mesh for your scene. The process is fairly fast. As long as you have the window selected, you'll be able to see the NavMesh generated by the <strong class="userinput"><code>Bake</code></strong> button in your scene view. Go ahead and hit the <strong class="userinput"><code>Bake</code></strong> button to see the results. In our sample scene, you should end up with something that looks like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/e6e18294-8176-4c3a-8ad3-c20df82e9b0a.png" /></div><p>The blue areas represent the NavMesh. We'll revisit this up ahead. For now, let's move on to the final tab, the <strong class="userinput"><code>Object</code></strong> tab, which looks like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/65ba03fe-2889-4864-96cf-5541eedf7339.png" /></div><p>The three buttons pictured in the preceding screenshot, <strong class="userinput"><code>All</code></strong>, <strong class="userinput"><code>Mesh Renderers</code></strong>, and <strong class="userinput"><code>Terrains</code></strong>, act as filters for your scene. These are helpful when working in complex scenes with lots of objects in the hierarchy. Selecting an option will filter out that type in your hierarchy to make them easier to select. You can use this when digging through your scene looking for objects to mark as navigation static.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec33"></a>Using the NavMesh agent</h3></div></div></div><p>Now that we have our scene set up with a NavMesh, we need a <span>way</span><a id="id288319971" class="indexterm"></a> for our agent to use this information. Luckily for us, Unity provides a <strong class="userinput"><code>Nav Mesh Agent</code></strong> component we can throw onto our character. The sample scene has a game object named <code class="literal">Tank</code> with the component already attached to it. Take a look at it in the hierarchy, and it should look like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/4bccdc00-0871-4cd4-b513-4ae184eebf8c.png" /></div><p>There are quite a few settings here, and we won't go over all of them, since they're fairly self-explanatory and you can find the full descriptions in the official Unity documentation, but let's point out a few key things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Agent Type</code></strong>: Remember the <strong class="userinput"><code>Agents</code></strong> tab in the <strong class="userinput"><code>Navigation</code></strong> window? The agent types you define there will be selectable here.</li><li style="list-style-type: disc"><strong class="userinput"><code>Auto Traverse Off Mesh Link</code></strong>: We'll get into Off Mesh Links up ahead, but this setting allows the agent to automatically use that feature.</li><li style="list-style-type: disc"><strong class="userinput"><code>Area Mask</code></strong>: The areas you set up in the <strong class="userinput"><code>Areas</code></strong> tab of the <strong class="userinput"><code>Navigation</code></strong> window will be selectable here.</li></ul></div><p>That's it. The component handles 90% of the heavy lifting for you: placement on the path, pathfinding, obstacle avoidance, and so on. The only thing you need to do is provide the agent with a target destination. Let's look at that next.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec34"></a>Setting a destination</h3></div></div></div><p>Now that we've set up our AI agent, we need a <span>way</span><a id="id288566615" class="indexterm"></a> to tell it where to go. Our sample project provides a script named <code class="literal">Target.cs</code> that does just that.  </p><p>This is a simple class that does three things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Shoots a ray from the camera origin to the mouse world position using a ray</li><li style="list-style-type: disc">Updates the marker position</li><li style="list-style-type: disc">Updates the destination property of all the NavMesh agents</li></ul></div><p>The code is fairly straightforward. The entire class looks like this:</p><pre class="programlisting">using UnityEngine;
using UnityEngine.AI;

public class Target : MonoBehaviour
{
    private NavMeshAgent[] navAgents;
    public Transform targetMarker;

    private void Start ()
    {
      navAgents = FindObjectsOfType(typeof(NavMeshAgent)) as NavMeshAgent[];
    }

    private void UpdateTargets ( Vector3 targetPosition )
    {
      foreach(NavMeshAgent agent in navAgents) 
      {
        agent.destination = targetPosition;
      }
    }

    private void Update ()
    {
        if(GetInput()) 
        {
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            RaycastHit hitInfo;

            if (Physics.Raycast(ray.origin, ray.direction, out hitInfo)) 
            {
                Vector3 targetPosition = hitInfo.point;
                UpdateTargets(targetPosition);
                targetMarker.position = targetPosition;
            }
        }
    }

    private bool GetInput() 
    {
        if (Input.GetMouseButtonDown(0)) 
        {
            return true;
        }
        return false;
    }

    private void OnDrawGizmos() 
    {
        Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * 5, Color.red);
    }
}</pre><p>There are a few things happening here. In the <code class="literal">Start</code> method, we initialize our <code class="literal">navAgents</code> array by using the <code class="literal">FindObjectsOfType()</code> method.</p><p>The <code class="literal">UpdateTargets()</code> method runs through our <code class="literal">navAgents</code> array and sets their target destination to the given <code class="literal">Vector3</code>. This is really the key to making it work. You can use any mechanism you wish to actually get the target destination, and all you need to do to get the agent to move there is set the <code class="literal">NavMeshAgent.destination</code> field; the agent will do the rest.</p><p>Our sample uses a click-to-move approach, so whenever the player clicks, we shoot a ray from the camera into the world towards the mouse cursor, and if we hit something, we assign that hit position as the new <code class="literal">targetPosition</code> for the agent. We also set the target marker accordingly for easy in-game visualization of the target destination.</p><p>To test it out, make sure you baked the NavMesh as described in the previous section, then enter play mode, and select any area on the map. If you go click-happy, you may notice there are some areas your agent <span class="emphasis"><em>can't </em></span>reach—the top of the red cubes, the top-most platform, and the platform towards the bottom of the screen. </p><p>In the case of the red cubes, they're too far up. The ramp <span>leading</span><a id="id288566686" class="indexterm"></a> up to the top-most platform is too steep, as per our <strong class="userinput"><code>Max Slope</code></strong> settings, and the agent can't climb up to it. The following screenshots illustrate how the <strong class="userinput"><code>Max Slope</code></strong> settings affect the NavMesh:</p><p> </p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/7a9a068d-9659-4811-913a-57236d176f04.png" /></div><p>NavMesh with the max slope value set to 45</p><p>If you <span>tweak</span><a id="id288566718" class="indexterm"></a> the <strong class="userinput"><code>Max Slope</code></strong> to something like <strong class="userinput"><code>51</code></strong>, then hit the <strong class="userinput"><code>Bake</code></strong> button again to re-bake the NavMesh, it will yield results like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/cac66fc6-298d-47b9-b4f1-771dfad98aa9.png" /></div><p>NavMesh with the max slope value set to 51
</p><p>As you can see, you can tweak your level design to make entire areas inaccessible by foot with a simple value tweak. An example where this would be helpful is if you had a platform or ledge that you need a rope, ladder, or elevator to get to. Maybe even a special skill, such as the ability to climb? I'll let your imagination do the work and think of all the fun ways to use this.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec35"></a>Making sense of Off Mesh Links</h3></div></div></div><p>You may have noticed that our scene features two gaps. The first one is accessible to our agent, but the one near the bottom of the screen is too far away. This is not completely arbitrary. Unity's <span class="strong"><strong>Off Mesh Links </strong></span>effectively bridge the gap between segments of the NavMesh that are not connected. You can see these links in the editor, as <span>shown</span><a id="id288566763" class="indexterm"></a> in the next screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/e0f4e1ff-fd13-47f2-8588-d65a02da6a90.png" /></div><p>The blue circles with the connecting lines are links</p><p>There are two ways that Unity can generate these links. The first we've already covered. Remember the <strong class="userinput"><code>Jump Distance</code></strong> value in the <strong class="userinput"><code>Bake</code></strong> tab of the <strong class="userinput"><code>Navigation</code></strong> window? Unity will automatically use that value to generate the links for us when baking the NavMesh. Try tweaking the value in our test scene to 5 and re-baking. Notice how, now, the platforms are linked? That's because the meshes are within the newly-specified threshold.</p><p>Set the value back to 2 and re-bake. Now, let's look at the second method. Create spheres that will be used to connect the two platforms. Place them roughly as <span>shown</span><a id="id288566795" class="indexterm"></a> in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/357bd526-5ea5-4c58-a7de-854552c2b768.png" /></div><p>You may already see where this is going, but let's walk through the process to get these connected. In this case, I've named the sphere on the right <code class="literal">start</code>, and the sphere on the left <code class="literal">end</code>. You'll see why in a second. Next up, add the <strong class="userinput"><code>Off Mesh Link </code></strong>component on the platform on the right (relative to the preceding screenshot). You'll notice the component has <code class="literal">start</code> and <code class="literal">end</code> fields. As you may have guessed, we're going to drop the spheres we created earlier into their respective slots—the start sphere in the <code class="literal">start</code> field, and the end sphere in the <code class="literal">end</code> field. Our inspector will look something like this:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/da7c5254-2301-4107-a26d-1890647a3ba1.png" /></div><p>The <strong class="userinput"><code>Cost Override</code></strong> value kicks in when you set it to a positive number. It will apply a cost multiplier to using this link, as opposed to, potentially, a more cost-effective route to the target.</p><p>The <strong class="userinput"><code>Bi Directional</code></strong> value allows the agent to <span>move</span><a id="id288566960" class="indexterm"></a> in both directions when set to true. You can turn this off to create one-way links in your level design. The <strong class="userinput"><code>Activated</code></strong> value is just what it says. When set to false, the agent will ignore this link. You can turn it on and off to create gameplay scenarios where the player has to hit a switch to activate it, for example. </p><p>You don't have to re-bake to enable this link. Take a look at your NavMesh and you'll see that it looks like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/70d809bd-e567-4a00-91bb-7a145f80b031.png" /></div><p>As you can see, the smaller gap is still automatically connected, and now we have a new link generated by our <strong class="userinput"><code>Off Mesh Link</code></strong> component between the two spheres. Enter play mode and click on the far platform, and, as expected, the agent can now navigate to the detached platform, as you can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788477901/graphics/377b568b-6187-4b1b-a57b-717cb1b08b9d.png" /></div><p>In your own levels, you may need to tweak these settings to get the exact results you expect, but combining these features gives you a lot of power out-of-the-box. You can have a simple game up and running fairly quickly using Unity's NavMesh feature.</p></div></div>