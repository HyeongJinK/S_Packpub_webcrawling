<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec30"></a>Shader programming – Ambient and Specular light</h2></div></div><hr /></div><p>In this step, we<a id="id485" class="indexterm"></a> will add Ambient and Specular light to<a id="id486" class="indexterm"></a> our shader script as well as <a id="id487" class="indexterm"></a>create <a id="id488" class="indexterm"></a>our custom lighting models.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p>The<a id="id489" class="indexterm"></a> custom lighting model is basically the function that will be used to calculate our surface shader, which is the output of the <code class="literal">surf()</code> function's interaction with the lights.</p><p>The <code class="literal">surf()</code> function<a id="id490" class="indexterm"></a> is the function that will take any UVs or data we need as input and fill in the output structure <code class="literal">SurfaceOutput</code> (the predefined structure, such as <code class="literal">Albedo</code>, <code class="literal">Normal</code>, <code class="literal">Emission</code>, <code class="literal">Specular</code>, <code class="literal">Gloss</code>, and <code class="literal">Alpha</code>). </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec61"></a>Engage thrusters</h3></div></div></div><p>Let's get started. Go to <span class="strong"><strong>MonoDevelop</strong></span>, open the <span class="strong"><strong>MyShader</strong></span> file, and go to the <code class="literal">Properties</code> section and add the highlighted script:</p><div class="informalexample"><pre class="programlisting">Properties {
<span class="strong"><strong>  _AmbientColor ("Ambient Color", Color) = (0.5, 0.5, 0.5, 1.0)</strong></span>
<span class="strong"><strong>  _SpecularColor ("Specular Color", Color) = (0.17, 0.42, 0.75, 1.0)</strong></span>
<span class="strong"><strong>  _Shininess ("Shininess", Range (0.01, 1)) = 0.078125</strong></span>
  _MainTex ("Diffuse (RGBA)", 2D) = "white" {}
  _BumpMap ("Bumpmap", 2D) = "bump" {}
}</pre></div><p>Next, go to the <code class="literal">SubShader</code> section and modify it as well as add the following highlighted code:</p><div class="informalexample"><pre class="programlisting">SubShader {
  Tags { "RenderType"="Opaque" }
<span class="strong"><strong>  LOD 400</strong></span>
  CGPROGRAM 
  #pragma surface surf Lambert
<span class="strong"><strong>  fixed4 _AmbientColor;</strong></span>
<span class="strong"><strong>  fixed4 _SpecularColor;</strong></span>
<span class="strong"><strong>  half _Shininess;</strong></span>
  sampler2D _MainTex; 
  sampler2D _BumpMap;

  struct Input { 
    float2 uv_MainTex; 
    float2 uv_BumpMap; 
  };

  void surf (Input IN, inout SurfaceOutput o) { 
<span class="strong"><strong>    fixed4 c = tex2D (_MainTex, IN.uv_MainTex); </strong></span>
<span class="strong"><strong>    o.Albedo = c.rgb * _AmbientColor.rgb; </strong></span>
<span class="strong"><strong>    o.Alpha = c.a * _AmbientColor.a;</strong></span>
<span class="strong"><strong>    o.Specular = _Shininess;</strong></span>
<span class="strong"><strong>    o.Gloss = c.a;</strong></span>
    o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
  } 
  ENDCG 
}</pre></div><p>Basically, we<a id="id491" class="indexterm"></a> just added three properties for<a id="id492" class="indexterm"></a> Ambient as well as Specular color and shininess. Then, in the <code class="literal">surf()</code> function, we changed <code class="literal">half4</code> to <code class="literal">fixed4</code> to increase the performance <a id="id493" class="indexterm"></a>by reducing the precision of our texture. We also<a id="id494" class="indexterm"></a> multiplied <code class="literal">c.rgb</code> with <code class="literal">_AmbientColor.rgb</code> and <code class="literal">c.a</code> with <code class="literal">_AmbientColor.a</code>. This will add the color value from the <code class="literal">_AmbientColor</code> properties with our main texture. Then, we passed <code class="literal">_Shininess</code> to <code class="literal">o.Specular</code> and <code class="literal">c.a</code> to <code class="literal">o.Gloss</code> to control the amount of gloss on our model.</p><p>If we open the diffuse texture in Photoshop and go to the alpha channel, we will see the black and white color area, which is used to specify the amount of glossiness on our character. As we can see in the following screenshot, the armor path is white and the character skin is almost black:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_19.jpg" /></div><p>We will add our custom lighting, which will show the Specular and Ambient color similar to 3D Studio Max, which uses the gray color as the base color.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip19"></a>Tip</h3><p>The good thing about using the gray color as the base color is that we can add more brightness to our main texture such as Specular and Ambient light.</p></div><p>We can go to the end of the <code class="literal">surf()</code> function, and before <code class="literal">ENDCG</code>, add the following highlighted code:</p><div class="informalexample"><pre class="programlisting">void surf (Input IN, inout SurfaceOutput o) { 
  …
}
  
<span class="strong"><strong>inline fixed4 LightingRampSpecular (SurfaceOutput s, fixed3 lightDir, fixed3 viewDir, fixed atten) {</strong></span>
<span class="strong"><strong>  //Ambient</strong></span>
<span class="strong"><strong>  fixed3 ambient = s.Albedo * _AmbientColor.rgb;</strong></span>
<span class="strong"><strong>  //Diffuse</strong></span>
<span class="strong"><strong>  fixed NdotL = saturate(dot (s.Normal, lightDir));</strong></span>
<span class="strong"><strong>  fixed3 diffuse = s.Albedo * _LightColor0.rgb * NdotL;</strong></span>
<span class="strong"><strong>  //Specular</strong></span>
<span class="strong"><strong>  fixed3 h = normalize (lightDir + viewDir);</strong></span>
<span class="strong"><strong>  float nh = saturate(dot (s.Normal, h));</strong></span>
<span class="strong"><strong>  float specPower = pow (nh, s.Specular * 128) * s.Gloss;</strong></span>
<span class="strong"><strong>  fixed3 specular = _LightColor0.rgb * specPower * _SpecularColor.rgb;</strong></span>
<span class="strong"><strong>  //Result</strong></span>
<span class="strong"><strong>  fixed4 c;</strong></span>
<span class="strong"><strong>  c.rgb = (ambient + diffuse + specular) * (atten * 2);</strong></span>
<span class="strong"><strong>  c.a = s.Alpha + (_LightColor0.a * _SpecularColor.a * specPower* atten);</strong></span>
<span class="strong"><strong>  return c;</strong></span>
<span class="strong"><strong>}</strong></span>

ENDCG </pre></div><p>Next, go<a id="id495" class="indexterm"></a> to <a id="id496" class="indexterm"></a>the <code class="literal">#pragma surface surf Lambert</code> line and change it to<a id="id497" class="indexterm"></a> the <a id="id498" class="indexterm"></a>following code:</p><div class="informalexample"><pre class="programlisting">#pragma surface surf RampSpecular</pre></div><p>We can now go back to Unity and click on <span class="strong"><strong>Play</strong></span> to see our result with the specular reflection, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_20.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec62"></a>Objective complete – mini debriefing</h3></div></div></div><p>In this step, we first added the new properties, <code class="literal">_AmbientColor</code>, <code class="literal">_SpecularColor</code>, and <code class="literal">_Shininess</code>, which will be used to calculate in our custom lighting models function to get the specular reflection. </p><p>Next, we<a id="id499" class="indexterm"></a> increased <code class="literal">LOD</code> to <code class="literal">400</code> because we wanted <a id="id500" class="indexterm"></a>to increase the LOD for our custom<a id="id501" class="indexterm"></a> lighting model that will calculate the specular lighting.</p><p>Next, in <a id="id502" class="indexterm"></a>the <code class="literal">surf()</code> function, we changed the first line from <code class="literal">half4 c = tex2D (_ MainTex, IN.uv_MainTex);</code> to <code class="literal">fixed4 c = tex2D (_MainTex, IN.uv_MainTex);</code> to increase the performance of our shader. As the return value from the <code class="literal">tex2D()</code> function is the color value (R,G,B,A), which has a range from <code class="literal">0</code> to <code class="literal">1</code>, it will be expensive to use <code class="literal">half</code> or <code class="literal">float</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip20"></a>Tip</h3><p>What are the <code class="literal">half</code> and <code class="literal">fixed</code> parameters for? When we are writing a shader in Cg/HLSL, there are three types of parameters that we can use: <code class="literal">fixed</code>, <code class="literal">half</code>, and <code class="literal">float</code>. These parameters determine the precision of computations. The parameter <code class="literal">fixed</code> is low precision (11 bits, should be in the range of -2.0 to +2.0, and has a precision value of 1/256), <code class="literal">half</code> is medium precision (16 bits, in the range of -60000 to +60000, and 3.3 decimal digits of precision), and <code class="literal">float</code> is high precision (32 bits and similar to float on the computer architecture).</p><p>The reference is taken from <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/SL-ShaderPerformance.html" target="_blank">http://docs.unity3d.com/Documentation/Components/SL-ShaderPerformance.html</a>.</p><p>However, it follows a trend wherein the more precision we have, the more calculation we need. If we use <code class="literal">float</code> every time for our shader, it will cause the game to slow down. So, if we want to improve the performance of our game, we should use the lowest precision possible while still having enough output. It's the task of the programmer to decide which aspects need to be precise and which do not.</p></div><p>Then, in the <code class="literal">surf()</code> function, we also multiplied <code class="literal">c.rgb</code> with <code class="literal">_AmbientColor.rgb</code> and <code class="literal">c.a</code> with <code class="literal">_AmbientColor.a</code>, which will get passed to <code class="literal">o.Albedo</code> and <code class="literal">o.Alpha</code>, respectively. This will add the color value from the <code class="literal">_AmbientColor</code> properties with our main<a id="id503" class="indexterm"></a> texture. Then, we passed <code class="literal">_Shininess</code> to <code class="literal">o.Specular</code> and <code class="literal">c.a</code> to <code class="literal">o.Gloss</code> to control the amount of gloss on our model.</p><p>Next, we <a id="id504" class="indexterm"></a>created our custom lighting function, which<a id="id505" class="indexterm"></a> is <code class="literal">inline half4 LightingRampSpecular (SurfaceOutput s, half3 lightDir, half3 viewDir, half atten)</code>. This function passes four parameters, surface output, light direction, view direction, and light attenuation, which we will use to calculate the output for our shader. Then, we<a id="id506" class="indexterm"></a> changed <code class="literal">#pragma surface surf</code> from <code class="literal">Lambert</code> to <code class="literal">RampSpecular</code>, which means that we changed our lighting calculated from the built-in <code class="literal">Lambert</code> model to <code class="literal">RampSpecular</code> in our custom lighting function, <code class="literal">LightingRampSpecular</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p>Why is the name of this function not <code class="literal">RampSpecular</code>? First, we call this function by using <code class="literal">#pragma surface surf RampSpecular</code>, but to have this function working properly, we need to add <code class="literal">Lighting</code> as a prefix to the name of our custom lighting function so that Unity will know that this function is a custom lighting function. This is how surface shaders are set up in Unity. You can find out more detail on this from <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html" target="_blank">http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html</a>.</p></div><p>In the <code class="literal">LightingRampSpecular()</code> function, we first got the ambient color value by getting <code class="literal">s.Albedo</code>, which is the <code class="literal">o.Albedo</code> parameter from the <code class="literal">surf()</code> function, and then multiplied <code class="literal">s.Albedo</code> by <code class="literal">_AmbientColor.rgb</code>, where <code class="literal">_AmbientColor</code> is the color information from the <code class="literal">Properties</code> section at the beginning of our code. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"></a>Note</h3><p>The <code class="literal">fixed</code>, <code class="literal">half</code>, and <code class="literal">float</code> parameters in Cg/HLSL can contain one, two, three, or four values of floating numbers such as <code class="literal">1.0</code>, <code class="literal">(1.0, 1.0)</code>, <code class="literal">(1.0, 1.0, 1.0)</code> or <code class="literal">(1.0, 1.0, 1.0, 1.0)</code> by calling it <code class="literal">fixed</code>, <code class="literal">fixed2</code>, <code class="literal">fixed3</code>, <code class="literal">fixed4</code>; <code class="literal">half</code>, <code class="literal">half2</code>, <code class="literal">half3</code>, <code class="literal">half4</code>; or <code class="literal">float</code>, <code class="literal">float2</code>, <code class="literal">float3</code>, <code class="literal">float4,</code> respectively. We can also access the value in these parameters by using <code class="literal">(x, y, z, w)</code> or <code class="literal">(r, g, b, a)</code>. For example, if you have <code class="literal">fixed4 color = (1.0, 0.5, 0.3, 0.8);</code> and you want to create another parameter that will contain only three values <code class="literal">(1.0, 0.5, 0.3)</code> from <code class="literal">fixed4 color</code>, you can name it like the following: <code class="literal">fixed3 newColor = color.rgb;</code>. However, if you want the <code class="literal">newColor</code> value equal to <code class="literal">(0.5, 1.0, 0.3)</code>, you can name it <code class="literal">fixed3 newColor = color.grb;</code>.</p></div><p>Then, we calculated the diffuse color by getting the dot product of the surface normal of the object, <code class="literal">s.Normal</code>, and we passed <code class="literal">o.Normal</code> from the <code class="literal">surf()</code> function and the light direction <code class="literal">fixed NdotL = dot (s.Normal, lightDir);</code>. Then, we used this value to multiply it <a id="id507" class="indexterm"></a>with the <a id="id508" class="indexterm"></a>object <a id="id509" class="indexterm"></a>diffuse texture, <code class="literal">s.Albedo</code>,<code class="literal"> </code>and <a id="id510" class="indexterm"></a>light color, <code class="literal">_LightColor0.rgb</code>, which is similar to the <code class="literal">Lambert</code> model.</p><p>Next, we calculated the specular color by first getting the normalize vector of the light direction and view direction using the following line of code:</p><div class="informalexample"><pre class="programlisting">fixed3 h = normalize (lightDir + viewDir);</pre></div><p>In <code class="literal">float nh = saturate(dot (s.Normal, h));</code>, we calculated the dot product of the surface normal and normalize vector and made sure that the returned number isn't greater than <code class="literal">1</code> or lower than <code class="literal">0</code> by using <code class="literal">saturate()</code>.</p><p>Then, we used <code class="literal">nh</code> to calculate the specular power by powering it with the <code class="literal">s.Specular</code> and <code class="literal">s.Gloss</code> properties using the following line of code:</p><div class="informalexample"><pre class="programlisting">float specPower = pow (nh, s.Specular * 128) * s.Gloss;</pre></div><p>Next, we got the specular color by multiplying the light color, specular power, and the specular color properties using the following line of code:</p><div class="informalexample"><pre class="programlisting">_LightColor0.rgb * specPower * _ SpecularColor.rgb;</pre></div><p>This is similar to the Blinn-Phong model.</p><p>In the last step, we added ambient, diffuse, and specular together and doubled the lighting attenuation value to get a smooth specular effect:</p><div class="informalexample"><pre class="programlisting">c.rgb = (ambient + diffuse + specular) * (atten * 2);.</pre></div><p>This way, we get the result that the default color is gray, and then we can adjust the color from white to black the way we want as the following screenshot shows (this shader is similar to the standard materials in 3D Studio Max):</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_21.jpg" /></div><p>The <a id="id511" class="indexterm"></a>major<a id="id512" class="indexterm"></a> part <a id="id513" class="indexterm"></a>of the code is in the Cg/HLSL language, so you <a id="id514" class="indexterm"></a>might not be familiar with it. However, you can still get an idea of how it works by trying to see more examples and taking a look at the Cg/HLSL language at <a class="ulink" href="https://developer.nvidia.com/content/cg-tutorial-appendix-e-cg-standard-library-functions" target="_blank">https://developer.nvidia.com/content/cg-tutorial-appendix-e-cg-standard-library-functions</a>.</p><p>We can also see an<a id="id515" class="indexterm"></a> example of the custom lighting model from <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderExamples.html" target="_blank">http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderExamples.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec63"></a>Classified intel</h3></div></div></div><p>How exactly do the surface shaders work?</p><p>First, we get<a id="id516" class="indexterm"></a> the parameters from the <code class="literal">Input struct</code>, and <a id="id517" class="indexterm"></a>these parameters will get passed to the <code class="literal">SurfaceOutput struct</code> inside the <code class="literal">surf()</code> function. Then, the return value of<a id="id518" class="indexterm"></a> the <code class="literal">SurfaceOutput struct</code> will go to the lighting model<a id="id519" class="indexterm"></a> function to calculate both the vertex and pixel (fragment) shaders. </p><p>Lastly, the result from the lighting model function will be passed to the frame buffer, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_22.jpg" /></div></div></div>