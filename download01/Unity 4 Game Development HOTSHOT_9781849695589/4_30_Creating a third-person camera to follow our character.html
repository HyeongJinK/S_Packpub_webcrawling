<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec38"></a>Creating a third-person camera to follow our character</h2></div></div><hr /></div><p>From the last section, we<a id="id662" class="indexterm"></a> got a controllable character with<a id="id663" class="indexterm"></a> animation, but the camera isn't actually following the character at all. So, in this section, we will create the third-person camera to follow our character.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec79"></a>Engage thrusters</h3></div></div></div><p>Now, we will create the script to control our character:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We will create the <span class="strong"><strong>CameraControl</strong></span> script that will control our entire menu; go to <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Javascript</strong></span> (for Unity JavaScript users) or <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>C#</strong></span> (for C# users), name it <code class="literal">CameraControl</code>, double-click on it to launch <span class="strong"><strong>MonoDevelop</strong></span>, and then we will get our hands dirty with the code.</p></li><li><p>Open the <span class="strong"><strong>CameraControl</strong></span> script file and type in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Unity JavaScript user:</strong></span>

#pragma strict
@script RequireComponent (CharacterControl)
var smoothTime : float = 0.1f;
var maxSpeed : float = 150.0f;
var heightSmoothTime : float = 0.1f;
var distance : float = 2.5f;
var height : float = 0.75f;
private var _heightVelocity : float = 0.0f;
private var _angleVelocity : float = 0.0f;
private var _velocity : Vector3;
private var _targetTransform : Transform;
private var _cameraTransform : Transform;
private var _maxRotation : float;
private var _characterControl : CharacterControl;
private var _targetHeight : float = Mathf.Infinity;
private var _centerOffset : Vector3 = Vector3.zero;


<span class="strong"><strong>// C# user:</strong></span>
using UnityEngine;
using System.Collections;
[RequireComponent(typeof(CharacterControl))]
public class CameraControl : MonoBehaviour {
  public float smoothTime = 0.1f;
  public float maxSpeed = 150.0f;
  public float heightSmoothTime = 0.1f;
  public float distance = 2.5f;
  public float height = 0.75f;
  float _heightVelocity = 0.0f;
  float _angleVelocity = 0.0f;
  Vector3 _velocity;
  Transform _targetTransform;
  Transform _cameraTransform;
  float _maxRotation;
  CharacterControl _characterControl;
  float _targetHeight = Mathf.Infinity;
  Vector3 _centerOffset = Vector3.zero;
  …
}</pre></div><p>Using the <a id="id664" class="indexterm"></a>preceding code, we <a id="id665" class="indexterm"></a>created all the variables required for this script.</p></li><li><p>Next, we will start creating the first function, <code class="literal">Awake()</code>, using the following code to get<a id="id666" class="indexterm"></a> the camera<a id="id667" class="indexterm"></a> transform and the <span class="strong"><strong>CharacterController</strong></span> component:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Unity JavaScript user:</strong></span>

function Awake () {
  _cameraTransform = Camera.main.transform;
  _targetTransform = transform;
  _characterControl = GetComponent.&lt;CharacterControl&gt;();
}

<span class="strong"><strong>// C# user:</strong></span>

void Awake () {
  _cameraTransform = Camera.main.transform;
  _targetTransform = transform;
  _characterControl = GetComponent&lt;CharacterControl&gt;();
}</pre></div></li><li><p>Then, we create the <code class="literal">Start()</code> function as follows, to get the center position of the target, which is the character we are pointing at:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Unity JavaScript user:</strong></span>

function Start () {
  var collider : Collider = _targetTransform.collider;
  _centerOffset = collider.bounds.center - _targetTransform.position;
}

<span class="strong"><strong>// C# user:</strong></span>
void Start () {
  Collider collider = _targetTransform.collider;
  _centerOffset = collider.bounds.center - _targetTransform.position;
}</pre></div></li><li><p>Next, we will create the <code class="literal">AngleDistance()</code> function to get the angle distance between the current angle and target; let's add the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Unity JavaScript user:</strong></span>

function AngleDistance  ( a : float, b : float) : float {
  a = Mathf.Repeat(a, 360);
  b = Mathf.Repeat(b, 360);
  return Mathf.Abs(b - a);
}

<span class="strong"><strong>// C# user:</strong></span>
float AngleDistance  (float a, float b) {
  a = Mathf.Repeat(a, 360);
  b = Mathf.Repeat(b, 360);
  return Mathf.Abs(b - a);
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note59"></a>Note</h3><p>
<code class="literal">Mathf.Repeat(t,l)</code> is the <a id="id668" class="indexterm"></a>function that we can use to loop the <code class="literal">t</code> value but not higher than <code class="literal">l</code> and not lower than <code class="literal">0</code>.</p><p>
<code class="literal">Mathf.Abs(n)</code> is<a id="id669" class="indexterm"></a> the function that will return the absolute number <code class="literal">n</code>.</p><p>For more details, visit the following websites:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.Repeat.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Mathf.Repeat.html</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.Abs.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Mathf.Abs.html</a>
</p></li></ul></div></div></li><li><p>Then, we<a id="id670" class="indexterm"></a> need to create<a id="id671" class="indexterm"></a> the <code class="literal">SetupRotation()</code> function to update the rotation of our camera. Type in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Unity JavaScript user:</strong></span>

function SetUpRotation ( centerPos : Vector3 ) {
  var cameraPos : Vector3 = _cameraTransform.position; 
  var offsetToCenter : Vector3 = centerPos - cameraPos;
  var yRotation : Quaternion = Quaternion.LookRotation(new Vector3(offsetToCenter.x, offsetToCenter.y + height, offsetToCenter.z));
  var relativeOffset : Vector3 = Vector3.forward * distance + Vector3.down * height;
  _cameraTransform.rotation = yRotation * Quaternion.LookRotation(relativeOffset);
}

<span class="strong"><strong>// C# user:</strong></span>
void SetUpRotation ( Vector3 centerPos ) {
  Vector3 cameraPos = _cameraTransform.position;
  Vector3 offsetToCenter = centerPos - cameraPos;
  Quaternion yRotation = Quaternion.LookRotation(new Vector3(offsetToCenter.x, offsetToCenter.y + height, offsetToCenter.z));
  Vector3 relativeOffset = Vector3.forward * distance + Vector3.down * height;
  _cameraTransform.rotation = yRotation * Quaternion.LookRotation(relativeOffset);
  
}</pre></div></li><li><p>Next, we will <a id="id672" class="indexterm"></a>create<a id="id673" class="indexterm"></a> the <code class="literal">LateUpdate()</code> function to update the camera position and rotation after all the objects have their <code class="literal">Update()</code> functions called. So, let's add the following code:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note60"></a>Note</h3><p>The <code class="literal">LateUpdate()</code> function<a id="id674" class="indexterm"></a> will be called after the <code class="literal">Update()</code> function<a id="id675" class="indexterm"></a> has been called. This function will make sure that all the calculation in the <code class="literal">Update()</code> function is finished before we start the <code class="literal">LateUpdate()</code> function. We use the <code class="literal">LateUpdate()</code> function for the camera calculation because we don't want the target position of the camera to lerp (linear interpolation) or get affected by any concurrent physics or location calculations. It should be calculated after the character's orientation and position has been determined in <code class="literal">Update()</code>.</p><p>For more details on <a id="id676" class="indexterm"></a>this function, refer to <a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.LateUpdate.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.LateUpdate.html</a>.</p></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Unity JavaScript user:</strong></span>

function LateUpdate () {
  var targetCenter : Vector3 = _targetTransform.position + _centerOffset;
  var originalTargetAngle : float = _targetTransform.eulerAngles.y;
  var currentAngle : float = _cameraTransform.eulerAngles.y;
  var targetAngle : float = originalTargetAngle;
  if (AngleDistance (currentAngle, targetAngle) &gt; 160 &amp;&amp; _characterControl.IsMoveBackward) {
    targetAngle += 180;
  }
  currentAngle = Mathf.SmoothDampAngle(currentAngle, targetAngle, _angleVelocity, smoothTime, maxSpeed);  
  _targetHeight = targetCenter.y + height;
  var currentHeight : float = _cameraTransform.position.y;
  currentHeight = Mathf.SmoothDamp (currentHeight, _targetHeight, _heightVelocity, heightSmoothTime);
  var currentRotation : Quaternion = Quaternion.Euler (0, currentAngle, 0);
  _cameraTransform.position = targetCenter;
  _cameraTransform.position += currentRotation * Vector3.back * distance;
  var newCameraPos : Vector3 = _cameraTransform.position;
  newCameraPos.y = currentHeight;
  _cameraTransform.position = newCameraPos;  
  SetUpRotation(targetCenter);
}

<span class="strong"><strong>// C# user:</strong></span>
void LateUpdate () {
  Vector3 targetCenter = _targetTransform.position + _centerOffset;
  float originalTargetAngle = _targetTransform.eulerAngles.y;
  float currentAngle = _cameraTransform.eulerAngles.y;
  float targetAngle = originalTargetAngle;  
  if (AngleDistance (currentAngle, targetAngle) &gt; 160 &amp;&amp; _characterControl.IsMoveBackward) {
    targetAngle += 180;
  }
  currentAngle = Mathf.SmoothDampAngle(currentAngle, targetAngle, ref _angleVelocity, smoothTime, maxSpeed);  
  _targetHeight = targetCenter.y + height;  
  float currentHeight = _cameraTransform.position.y;
  currentHeight = Mathf.SmoothDamp (currentHeight, _targetHeight, ref _heightVelocity, heightSmoothTime);
  Quaternion currentRotation = Quaternion.Euler (0, currentAngle, 0);  
  _cameraTransform.position = targetCenter;
  _cameraTransform.position += currentRotation * Vector3.back * distance;
  Vector3 newCameraPos = _cameraTransform.position;
  newCameraPos.y = currentHeight;
  _cameraTransform.position = newCameraPos;  
  SetUpRotation(targetCenter);
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note61"></a>Note</h3><p>
<code class="literal">Mathf.SmoothDampAngle()</code> is the <a id="id677" class="indexterm"></a>function that gradually changes the angle given in degrees towards the target angle over time.</p><p>
<code class="literal">Mathf.SmoothDamp()</code> is the <a id="id678" class="indexterm"></a>function that gradually changes the value towards the target value over time.</p><p>For more details, visit the<a id="id679" class="indexterm"></a> following websites:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.SmoothDampAngle.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Mathf.SmoothDampAngle.html</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/Mathf.SmoothDamp.html" target="_blank">http://docs.unity3d.com/Documentation/ScriptReference/Mathf.SmoothDamp.html</a>
</p></li></ul></div></div></li><li><p>Finally, we <a id="id680" class="indexterm"></a>will go <a id="id681" class="indexterm"></a>back to the Unity editor and drag-and-drop the <span class="strong"><strong>CameraControl</strong></span> script that we just created on <span class="strong"><strong>Heroine_animate</strong></span> in the <span class="strong"><strong>Hierarchy</strong></span> view. Then, we can click on the play button to see the result.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec80"></a>Objective complete – mini debriefing</h3></div></div></div><p>In this section, we created a third-person camera script to follow our character. This script also allows us to set the distance from our character and the height of our camera position by using some code from the built-in third-person camera script and adapting it to match our character.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec81"></a>Classified intel</h3></div></div></div><p>Why do we need the <code class="literal">LateUpdate()</code> function<a id="id682" class="indexterm"></a> instead of the <code class="literal">Update()</code> function<a id="id683" class="indexterm"></a> in this script? Well, we use it to guarantee that the player position is already updated when we are performing the camera calculations. If we perform the calculation in the <code class="literal">Update()</code> function, the camera position might be calculated before the player position is updated. This will result in jitter.</p><p>We can also explain it this way: we wait for the input from the user and then get the direction in which the character will move from the <code class="literal">Update()</code> function. Then, we use the position of the character as the target position that our camera will follow and calculate the camera position in the <code class="literal">LateUpdate()</code> function. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note62"></a>Note</h3><p>What's the difference between <code class="literal">Update()</code>, <code class="literal">LateUpdate()</code>, and <code class="literal">FixedUpdate()</code> functions? <code class="literal">Update()</code> is <a id="id684" class="indexterm"></a>called for every frame. <code class="literal">LateUpdate()</code> is <a id="id685" class="indexterm"></a>also called for every frame but after all the <code class="literal">Update()</code> functions have been called. <code class="literal">FixedUpdate()</code> is called<a id="id686" class="indexterm"></a> for every fixed frame rate, which means that no matter how our game is running, slow or fast, the <code class="literal">FixedUpdate()</code> function will always call at the same rate. For example, if our game is slow, the <code class="literal">FixedUpdate()</code> function gets called more than once before calling the <code class="literal">Update()</code> function.</p><p>The following link is useful for <code class="literal">Update()</code> and <code class="literal">FixedUpdate()</code>: <a class="ulink" href="http://answers.unity3d.com/questions/10993/whats-the-difference-between-update-and-fixedupdat.html" target="_blank">http://answers.unity3d.com/questions/10993/whats-the-difference-between-update-and-fixedupdat.html</a>.</p></div><p>This way, we will be able to <a id="id687" class="indexterm"></a>track each movement of our <a id="id688" class="indexterm"></a>character and the camera will follow the direction smoothly without any jitter, as we can see in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_04_38.jpg" /></div></div></div>