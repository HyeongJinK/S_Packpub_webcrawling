<div class="appendix" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="appD"></a>Appendix D. Shaders and Cg/HLSL Programming</h2></div></div></div><p>This appendix presents a brief overview of the structure of surface shaders and Cg/HLSL programming.</p><p>Shaders in Unity can be written in one of the following three different ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Surface shaders</strong></span>: These will probably be the best option if your shader needs<a id="id1364" class="indexterm"></a> to be affected by the lights and shadows. These <a id="id1365" class="indexterm"></a>shaders also make it easy to write complex shaders in a compact way—it's a higher level of abstraction for interaction with Unity's lighting pipeline. Most surface shaders automatically support forward and deferred lighting (the exception is some very custom lighting models), which allows your shader to efficiently interact with many real-time lights. You write surface shaders in a couple of lines of Cg/HLSL, and a lot more code gets autogenerated from that.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip49"></a>Tip</h3><p>Do not use the surface shaders if the shaders have anything to do with lights, such as image effects or special-effects shaders (glowing effect and so on), because<a id="id1366" class="indexterm"></a> surface shaders will do the lighting calculations<a id="id1367" class="indexterm"></a> for no reason.</p></div></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Vertex and fragment shaders</strong></span>: These are your best option to write the image <a id="id1368" class="indexterm"></a>effect or special-effect shaders. They will<a id="id1369" class="indexterm"></a> be required if your shader doesn't need to interact<a id="id1370" class="indexterm"></a> with lighting or you need some very <a id="id1371" class="indexterm"></a>exotic effects that the surface shaders can't handle. Shader programs written in this way are the most flexible way to create the effect you need (even surface shaders are automatically converted to a bunch of vertex and fragment shaders), but that comes with more work: you have to write more code, and it's difficult to make it interact with lighting. These shaders are written in Cg/HLSL as well.</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Fixed function shaders</strong></span>: These need to be written for old hardware that doesn't support programmable shaders. You will probably want to write fixed<a id="id1372" class="indexterm"></a> function shaders as an <span class="emphasis"><em>n</em></span>th fallback to <a id="id1373" class="indexterm"></a>your fancy fragment or surface shaders to make sure that your game still renders something sensible when it is run on an old hardware or simpler mobile platforms. Fixed function shaders are entirely written in a language called <span class="strong"><strong>ShaderLab</strong></span>, which<a id="id1374" class="indexterm"></a> is similar to Microsoft's FX files or NVIDIA's CgFX.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip50"></a>Tip</h3><p>This is also a good option if your shader doesn't need a fancy effect such as a 2D game on mobile. This could save your time so that you can write a shader that supports old and new hardware.</p></div></li></ul></div><p>Regardless of which type you choose, the actual code of the shader code will always be wrapped in ShaderLab, which is used to organize the shader structure. It looks like the following code:</p><div class="informalexample"><pre class="programlisting">Shader "MyShader" {     
<span class="strong"><strong>    Properties {         </strong></span>
<span class="strong"><strong>      // All properties go here</strong></span>
<span class="strong"><strong>       _MyTexture ("My Texture", 2D) = "white" { } </strong></span>
<span class="strong"><strong>  }</strong></span>
  SubShader {         
       //  Choose your written style        
       //  - surface shader or         
       //  - vertex and fragment shader or         
       //  - fixed function shader    
  }   
  SubShader {         
  // Optional - A simpler version of the SubShader above that can run   on older graphics cards   
  } 
}</pre></div><p>However, we will only talk about the surface shaders that we used in <a class="link" href="#" linkend="ch03">Project 3</a>, <span class="emphasis"><em>Shade Your Hero/Heroine</em></span>, of this book.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note97"></a>Note</h3><p>For more<a id="id1375" class="indexterm"></a> information about other shader types, visit the following URLs:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>ShaderLab</strong></span>: <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/SL-Shader.html" target="_blank">http://docs.unity3d.com/Documentation/Components/SL-Shader.html</a>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Vertex </strong></span><a id="id1376" class="indexterm"></a>
<span class="strong"><strong>and fragment shaders</strong></span>: <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/SL-ShaderPrograms.html" target="_blank">http://docs.unity3d.com/Documentation/Components/SL-ShaderPrograms.html</a>
</p></li></ul></div></div></div>