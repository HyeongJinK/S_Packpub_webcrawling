<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec83"></a>StartCoroutine</h2></div></div><hr /></div><p>
<code class="literal">StartCoroutine</code> starts a <code class="literal">coroutine</code>.</p><p>The execution <a id="id1324" class="indexterm"></a>of <code class="literal">coroutine</code> can be paused at any point using the <code class="literal">yield</code> statement. The <code class="literal">yield return</code> value specifies when <code class="literal">coroutine</code> is resumed. <code class="literal">Coroutines</code> are <a id="id1325" class="indexterm"></a>excellent when modeling behavior over several frames. <code class="literal">Coroutines</code> have virtually no performance overhead. The <code class="literal">StartCoroutine()</code> function<a id="id1326" class="indexterm"></a> always returns a value immediately; therefore, you can yield the result. This will wait until <code class="literal">coroutine</code> has finished execution.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip44"></a>Tip</h3><p>When using JavaScript, it is not necessary to use <code class="literal">StartCoroutine</code>; the compiler will do this for you. However, when writing C# code, you must call <code class="literal">StartCoroutine</code>. (For more details, refer to <a class="link" href="#" linkend="appC">Appendix C</a>, <span class="emphasis"><em>Major Differences Between C# and Unity JavaScript</em></span>.)</p></div><p>In the following example, we will show how to invoke a <code class="literal">coroutine</code> and continue executing the function in parallel:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// JavaScript user:</strong></span>

function Start() {
  // Starting = 0.0
  Debug.Log ("Starting = " + Time.time);
  // StartCoroutine WaitAndPrint (In JavaScript, you can also useWaitAndPrint(5.0) which will get the same result.
  StartCoroutine(WaitAndPrint(5.0)); 
  // Before WaitAndPrint = 5.0
  Debug.Log ("Before WaitAndPrint = " + Time.time);
}

function WaitAndPrint(waitTime : float) {
    //Suspend execution for 5 seconds 
    yield WaitForSeconds(waitTime);
    // WaitAndPrint = 5.0
    Debug.Log ("WaitAndPrint = " + Time.time);
}


<span class="strong"><strong>// C# user:</strong></span>

void Start() {
  // Starting = 0.0
  Debug.Log ("Starting = " + Time.time);
  StartCoroutine(WaitAndPrint(5.0f)); 
  // Before WaitAndPrint = 5.0
  Debug.Log ("Before WaitAndPrint = " + Time.time);
}

IEnumerator WaitAndPrint(float  waitTime) {
    //Suspend execution for 5 seconds 
    yield return new WaitForSeconds(waitTime);
    // WaitAndPrint = 5.0
    Debug.Log ("WaitAndPrint = " + Time.time);
}</pre></div><p>The <a id="id1327" class="indexterm"></a>following example will wait until the <code class="literal">WaitAndPrint()</code> function has finished its execution and then continue executing the rest of the code in the <code class="literal">Start()</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// JavaScript user:</strong></span>

function Start() {
  // Starting = 0.0
  Debug.Log ("Starting = " + Time.time);
  // StartCoroutine WaitAndPrint (In JavaScript, you can also useyield WaitAndPrint(5.0) which will get the same result.
  yield StartCoroutine(WaitAndPrint(5.0)); 
  // Done WaitAndPrint = 5.0
  Debug.Log ("Done WaitAndPrint = " + Time.time);
}

function WaitAndPrint(waitTime : float) {
    //Suspend execution for 5 seconds 
    yield WaitForSeconds(waitTime);
    // WaitAndPrint = 5.0
    Debug.Log ("WaitAndPrint = " + Time.time);
}


<span class="strong"><strong>// C# user:</strong></span>

IEnumerator Start() {
  // Starting = 0.0
  Debug.Log ("Starting = " + Time.time);
  yield return StartCoroutine(WaitAndPrint(5.0f)); 
  // Done WaitAndPrint = 5.0
  Debug.Log ("Done WaitAndPrint = " + Time.time);
}

IEnumerator WaitAndPrint(float  waitTime) {
    //Suspend execution for 5 seconds 
    yield return new WaitForSeconds(waitTime);
    // WaitAndPrint = 5.0
    Debug.Log ("WaitAndPrint = " + Time.time);
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec153"></a>Using StartCoroutine with method name (string)</h3></div></div></div><p>In most <a id="id1328" class="indexterm"></a>cases, you want to use the <code class="literal">StartCoroutine</code> variation at the start of a code. However, <code class="literal">StartCoroutine</code> using a string <a id="id1329" class="indexterm"></a>method name allows you to use <code class="literal">StopCoroutine</code> with a specific method name.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip45"></a>Tip</h3><p>The downside is that the string version has a higher runtime overhead to start <code class="literal">coroutine</code>, and you can pass only one parameter.</p></div><p>In the following example, we will see how to invoke <code class="literal">coroutine</code> using a string name and stop it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// JavaScript user:</strong></span>

function Start() {
  // Start Coroutine DoSomething
  StartCoroutine("DoSomething", 5.0); 
  //  Wait for 2 seconds
  yield WaitForSeconds(2.0);
  // Stop Coroutine DoSomething
  StopCoroutine("DoSomething");
}

function DoSomething (someParameter : float) {
  while (true) {
        // DoSomething Loop
        Debug.Log ("DoSomething Loop = " + Time.time);
     // Yield execution of this coroutine and return to the main loop until next frame
           yield;
  }
}


<span class="strong"><strong>// C# user:</strong></span>

IEnumerator Start() {
  // Start Coroutine DoSomething
  StartCoroutine("DoSomething", 5.0f); 
  //  Wait for 2 seconds
  yield return new WaitForSeconds(2.0f);
  // Stop Coroutine DoSomething
  StopCoroutine("DoSomething");
}

IEnumerator DoSomething (float  someParameter) {
  while (true) {
      // DoSomething Loop
      Debug.Log ("DoSomething Loop = " + Time.time);
  // Yield execution of this coroutine and return to the main 
  loop until next frame
      yield return null;
  }
}</pre></div></div></div>