<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec29"></a>Shader programming – Diffuse and Bump (normal) maps</h2></div></div><hr /></div><p>In this <a id="id396" class="indexterm"></a>first step, we will import <code class="literal">Chapter3.unitypackage</code> (which is already included in the FBX model and textures) and create<a id="id397" class="indexterm"></a> a shader program, which will include <a id="id398" class="indexterm"></a>all the<a id="id399" class="indexterm"></a> properties that we can edit from the <span class="strong"><strong>Material Inspector</strong></span>. We will start by assigning the Diffuse and Bump (normal) maps. Then, we will use the built-in lighting models, <code class="literal">Lambert</code> and <code class="literal">BlinnPhong</code>, which are located in the <code class="literal">Lighting.cginc</code> file inside the Unity application, to see our result.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note27"></a>Note</h3><p>
<span class="strong"><strong>Lambert</strong></span> or <a id="id400" class="indexterm"></a>diffuse reflection will cause all closed polygons to reflect light equally in all directions when rendered. This algorithm is named after Johann Heinrich Lambert, who invented it. </p><p>
<span class="strong"><strong>Blinn-Phong</strong></span><a id="id401" class="indexterm"></a> or Blinn-Phong reflection is a shading model that is a modification of the Phong reflection model and was developed by Jim Blinn.</p><p>The <span class="strong"><strong>Phong</strong></span> reflection model is a shading model that includes a model for the reflection<a id="id402" class="indexterm"></a> of light from surfaces. It also has a compatible method of estimating pixel colors using the interpolation of surface normals across rasterized (or bitmap) polygons. This was developed by Bui Tuong Phong. </p><p>The references used are as follows: </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<a class="ulink" href="http://www.opengl-redbook.com" target="_blank">http://www.opengl-redbook.com</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://en.wikipedia.org/wiki/Lambertian_reflectance" target="_blank">http://en.wikipedia.org/wiki/Lambertian_reflectance</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://en.wikipedia.org/wiki/Phong_shading" target="_blank">http://en.wikipedia.org/wiki/Phong_shading</a>
</p></li><li style="list-style-type: disc"><p>
<a class="ulink" href="http://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model" target="_blank">http://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model</a>
</p></li></ul></div><p>We can find <code class="literal">Lighting.cginc</code> from the following locations:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>For Windows</strong></span>: <code class="literal">{unity install path}/Data/CGIncludes/Lighting.cginc</code>
</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>For Mac</strong></span>: <code class="literal">/Applications/Unity/Unity.app/Contents/CGIncludes/Lighting.cginc</code>
</p></li></ul></div></div><p>The <a id="id403" class="indexterm"></a>following screenshot shows an example <a id="id404" class="indexterm"></a>of the <code class="literal">Lambert</code> and <code class="literal">BlinnPhong</code> lighting<a id="id405" class="indexterm"></a> models <a id="id406" class="indexterm"></a>and how they are different from each other. We will see that the Blinn-Phong is shiny, but the Lambert is matte.</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_03.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec57"></a>Prepare for lift off</h3></div></div></div><p>Now, we can start <a id="id407" class="indexterm"></a>the shader programming by implementing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Let's create a new project named <code class="literal">Shader</code>, similar to that in the last project, and click on the <span class="strong"><strong>Create Project</strong></span> button, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_04.jpg" /></div></li><li><p>Import<a id="id408" class="indexterm"></a> the <a id="id409" class="indexterm"></a>assets <a id="id410" class="indexterm"></a>package <a id="id411" class="indexterm"></a>by going to <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Import Package</strong></span> | <span class="strong"><strong>Custom Package…</strong></span>, choose <code class="literal">Chapter3.unityPackage</code>, which we downloaded earlier, and then click on the <span class="strong"><strong>Import</strong></span> button in the pop-up window, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_05.jpg" /></div><p>Wait until it's done, and you will see the <span class="strong"><strong>FBX</strong></span>, <span class="strong"><strong>Materials</strong></span>, and <span class="strong"><strong>Textures</strong></span> folders, as we can see in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_06.jpg" /></div></li><li><p>Next, double-click on the <span class="strong"><strong>Shader</strong></span> scene, as shown in the preceding screenshot, to open the scene that we will work on in this project. When <a id="id412" class="indexterm"></a>you double-click <a id="id413" class="indexterm"></a>on the <span class="strong"><strong>Shader</strong></span> scene, Unity<a id="id414" class="indexterm"></a> will bring up the pop up and<a id="id415" class="indexterm"></a> ask whether we want to save the current <a id="id416" class="indexterm"></a>scene or not, similar to what we saw in the last project. Just click on the <span class="strong"><strong>Don't save</strong></span> button to open up the <span class="strong"><strong>Shader</strong></span> scene.</p></li><li><p>Then, go to the <span class="strong"><strong>FBX</strong></span> folder and click on <span class="strong"><strong>Heroine</strong></span> in this folder to bring up its <span class="strong"><strong>Inspector</strong></span> view. In the <span class="strong"><strong>Inspector</strong></span> view, we will see three tabs: <span class="strong"><strong>Model</strong></span>, <span class="strong"><strong>Rig</strong></span>, and <span class="strong"><strong>Animations</strong></span>. In the <span class="strong"><strong>Model</strong></span> tab, we will make sure that <span class="strong"><strong>Scale Factor</strong></span> is set to <code class="literal">1</code>. This is to make sure that our model size matches the physics calculation in Unity.</p></li><li><p>Next, in the <span class="strong"><strong>Rig</strong></span> and <span class="strong"><strong>Animations</strong></span> tabs, we set <span class="strong"><strong>Animation Type</strong></span> in the <span class="strong"><strong>Rig</strong></span> tab to <span class="strong"><strong>None</strong></span> and uncheck the <span class="strong"><strong>Import Animation</strong></span> option in the <span class="strong"><strong>Animations</strong></span> tab, as we don't have any animation in this model; so, we don't need <a id="id417" class="indexterm"></a>to attach it<a id="id418" class="indexterm"></a> to our model, as we<a id="id419" class="indexterm"></a> can see in the following screenshot (we will take a look at the <span class="strong"><strong>Rig</strong></span> and <span class="strong"><strong>Animations</strong></span> tabs in the next<a id="id420" class="indexterm"></a> project):</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_07.jpg" /></div></li><li><p>
<span class="strong"><strong>Scale Factor</strong></span> can be set to rescale the whole <span class="strong"><strong>FBX</strong></span> file. In Unity, the Physics Engine is scaled as 1 unit equals 1 meter. So, we can set <a id="id421" class="indexterm"></a>the model scale to match Unity's Physics Engine to get an accurate result when we use the physics calculation.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip17"></a>Tip</h3><p>Our model height is around 1.7 meters, so it is about 1.7 units in Unity. We can also measure the model by using the cube game object in Unity, which is 1 x 1 x 1 unit, or turn on the grid to measure the model size related to Unity's unit scale:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_08.jpg" /></div></div></li><li><p>Then, go<a id="id422" class="indexterm"></a> to the <span class="strong"><strong>Textures</strong></span> folder and click on <span class="strong"><strong>Normal</strong></span> to bring up its <span class="strong"><strong>Inspector</strong></span> view. In<a id="id423" class="indexterm"></a> the<a id="id424" class="indexterm"></a> <span class="strong"><strong>Inspector</strong></span> view, change <span class="strong"><strong>Texture Type</strong></span> to <span class="strong"><strong>Normal Map</strong></span>, check <span class="strong"><strong>Generate from Grayscale</strong></span>, set the <span class="strong"><strong>Bumpiness</strong></span> to <code class="literal">0.07</code>, and click <a id="id425" class="indexterm"></a>on the <span class="strong"><strong>Apply</strong></span> button, as shown<a id="id426" class="indexterm"></a> in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_09.jpg" /></div></li><li><p>We set <span class="strong"><strong>Texture Type</strong></span> to <span class="strong"><strong>Normal map</strong></span>, which can adjust <span class="strong"><strong>Bumpiness</strong></span> and <span class="strong"><strong>Filtering</strong></span> to get the bump effect we want by checking <span class="strong"><strong>Create from Grayscale</strong></span>.</p></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec58"></a>Engage thrusters</h3></div></div></div><p>Now, we will put the 3D model into our scene and start writing our custom shader. Follow <a id="id427" class="indexterm"></a>the ensuing steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, we drag the <span class="strong"><strong>Heroine</strong></span> model in the <span class="strong"><strong>FBX</strong></span> folder from the <span class="strong"><strong>Project</strong></span> view to the <span class="strong"><strong>Hierarchy</strong></span> view.</p></li><li><p>Next, we will click on the <span class="strong"><strong>Heroine</strong></span> model in the <span class="strong"><strong>Hierarchy</strong></span> view to bring its <span class="strong"><strong>Inspector</strong></span> view up. Then, we will go to the <span class="strong"><strong>Inspector</strong></span> view and <a id="id428" class="indexterm"></a>set <a id="id429" class="indexterm"></a>the <a id="id430" class="indexterm"></a>value of <span class="strong"><strong>Y</strong></span> under <span class="strong"><strong>Rotation</strong></span> to <code class="literal">180</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_10.jpg" /></div></li><li><p>If we go to the material component, we will see <span class="strong"><strong>Diffuse</strong></span> applied to the shader in this material, which has two properties, <span class="strong"><strong>Main Color</strong></span> and <span class="strong"><strong>Base (RGB)</strong></span>. <span class="strong"><strong>Main Color</strong></span> takes the color that we edited and then applies it to our model. <span class="strong"><strong>Base (RGB)</strong></span> takes the texture that is used for our model. Both properties can be edited and adjusted in the Unity editor to get the best look for our model, as shown in the following screenshot: </p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_11.jpg" /></div></li><li><p>Now, we will start coding by going to <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Shader</strong></span> and naming it <code class="literal">MyShader</code>. Then, we double-click or right-click on it and choose <span class="strong"><strong>Sync MonoDevelop Project</strong></span> to open <span class="strong"><strong>MonoDevelop</strong></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note29"></a>Note</h3><p>The <span class="strong"><strong>Sync MonoDevelop Project</strong></span> step might not work if we haven't set <span class="strong"><strong>MonoDevelop</strong></span> as our default editor. (This was discussed in the first project.)</p><p>In <a id="id431" class="indexterm"></a>Unity 4.x, we can double-click on the <a id="id432" class="indexterm"></a>shader file and Unity will automatically<a id="id433" class="indexterm"></a> open the shader<a id="id434" class="indexterm"></a> file on <span class="strong"><strong>MonoDevelop</strong></span> for us.</p></div><p>In <span class="strong"><strong>MonoDevelop</strong></span>, you will see the default setup of the shader script, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_12.jpg" /></div><p>On<a id="id435" class="indexterm"></a> the <a id="id436" class="indexterm"></a>other hand, if you create the shader inside <span class="strong"><strong>MonoDevelop</strong></span>, the default setup of the shader script will be different<a id="id437" class="indexterm"></a> from the preceding screenshot and similar<a id="id438" class="indexterm"></a> to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_13.jpg" /></div></li><li><p>Next, go to the first line in the <code class="literal">MyShader.shader</code> file and modify the existing code as follows:</p><div class="informalexample"><pre class="programlisting">Shader "Custom/MyShader (Toon Rim)" { </pre></div></li><li><p>In this line, we change the folder position and name our shader, which will appear in the <span class="strong"><strong>Shader</strong></span> dropdown when we select the <span class="strong"><strong>Shader</strong></span> properties in the object's <span class="strong"><strong>Inspector</strong></span> view.</p></li><li><p>Then, go back to Unity and click on the <span class="strong"><strong>Heroine</strong></span> model in the <span class="strong"><strong>Hierarchy</strong></span> view to bring the <span class="strong"><strong>Inspector</strong></span> view up.</p></li><li><p>In the <span class="strong"><strong>Shader</strong></span> properties in the material component, we will click on the small arrow on the right-hand side to bring up the dropdown and then go to <span class="strong"><strong>Custom</strong></span> | <span class="strong"><strong>MyShader (Toon Rim)</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_14.jpg" /></div></li><li><p>Then, we go back to <span class="strong"><strong>MonoDevelop</strong></span> again, go to the next line of the <code class="literal">MyShader.shader</code> file, and start modifying the <code class="literal">Properties</code> section, as follows:</p><div class="informalexample"><pre class="programlisting">Properties { 
  _MainTex ("Diffuse (RGBA)", 2D) = "white" {} 
  _BumpMap ("Bumpmap", 2D) = "bump" {} 
}</pre></div></li><li><p>Then, we<a id="id439" class="indexterm"></a> go to the <code class="literal">SubShader</code> section to modify and <a id="id440" class="indexterm"></a>add <a id="id441" class="indexterm"></a>the following highlighted<a id="id442" class="indexterm"></a> code:</p><div class="informalexample"><pre class="programlisting">SubShader { 
  Tags { "RenderType"="Opaque" } 
  LOD 300 
  CGPROGRAM 
  #pragma surface surf Lambert
  
  sampler2D _MainTex; 
  sampler2D _BumpMap;
  
  struct Input { 
    float2 uv_MainTex; 
<span class="strong"><strong>    float2 uv_BumpMap; </strong></span>
  }; 
  void surf (Input IN, inout SurfaceOutput o) { 
    half4 c = tex2D (_MainTex, IN.uv_MainTex); 
    o.Albedo = c.rgb; 
    o.Alpha = c.a; 
<span class="strong"><strong>    o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap)); </strong></span>
  } 
  ENDCG 
}</pre></div><p>We just take the bump texture to create a normal map by getting the normals from the texture using <code class="literal">UnpackNormal</code> and set it to the normal of <code class="literal">SurfaceOutput (o.Normal)</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note30"></a>Note</h3><p>Normals, or<a id="id443" class="indexterm"></a> surface normals, are a technique used to add details on the surface of the object without using more polygons by faking the lighting of bumps and dents.</p></div></li><li><p>Finally, we go back to Unity and apply the texture to our model. Let's click on the <span class="strong"><strong>Heroine</strong></span> model in the <span class="strong"><strong>Hierarchy</strong></span> view to bring its <span class="strong"><strong>Inspector</strong></span> view up. In the <span class="strong"><strong>Inspector</strong></span> view, we will go to the material component and set the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<span class="strong"><strong>Texture</strong></span>: Drag-and-drop <span class="strong"><strong>Diffuse</strong></span> in the <span class="strong"><strong>Textures</strong></span> folder from the <span class="strong"><strong>Project</strong></span> view<a id="id444" class="indexterm"></a> to this thumbnail</p></li><li style="list-style-type: disc"><p>
<span class="strong"><strong>Bumpmap</strong></span>: Drag-and-drop <span class="strong"><strong>Normal</strong></span> in the <span class="strong"><strong>Textures</strong></span> folder from the <span class="strong"><strong>Project</strong></span> view to this thumbnail</p></li></ul></div><p>You <a id="id445" class="indexterm"></a>will <a id="id446" class="indexterm"></a>see the <span class="strong"><strong>Inspector</strong></span> view, as shown in the following<a id="id447" class="indexterm"></a> screenshot:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_15.jpg" /></div></li><li><p>Now, click on play and behold the result:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_16.jpg" /></div></li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec59"></a>Objective complete – mini debriefing</h3></div></div></div><p>Let's take <a id="id448" class="indexterm"></a>a look at what we did here.</p><p>First, we <a id="id449" class="indexterm"></a>added a new property, <code class="literal">_BumpMap</code>, which is <a id="id450" class="indexterm"></a>used <a id="id451" class="indexterm"></a>to get<a id="id452" class="indexterm"></a> the surface normal of our character's geometry.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note31"></a>Note</h3><p>For more details on surface normals, refer to <a class="ulink" href="http://en.wikipedia.org/wiki/Normal_(geometry)" target="_blank">http://en.wikipedia.org/wiki/Normal_(geometry)</a>.</p></div><p>Properties can be created using the following syntax:</p><div class="informalexample"><pre class="programlisting">name ("display name", property type) = default value</pre></div><p>The components<a id="id453" class="indexterm"></a> of this code snippet are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>
<code class="literal">name</code>: This<a id="id454" class="indexterm"></a> is the name of the property inside the shader script</p></li><li style="list-style-type: disc"><p>
<code class="literal">display</code>: This is<a id="id455" class="indexterm"></a> the name that will be shown in the <span class="strong"><strong>Material Inspector</strong></span>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">property type</code>: This<a id="id456" class="indexterm"></a> is the type of the property that we can use in our shader programming, which can be <code class="literal">Range</code>, <code class="literal">Color</code>, <code class="literal">2D</code>, <code class="literal">Rect</code>, <code class="literal">Cube</code>, <code class="literal">Float</code>, or <code class="literal">Vector</code>
</p></li><li style="list-style-type: disc"><p>
<code class="literal">default</code>: This is<a id="id457" class="indexterm"></a> the default value of our property</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note32"></a>Note</h3><p>Every time you add new properties in the <code class="literal">Properties</code> section, you will need to create the same parameter inside <code class="literal">CGPROGRAM</code> in the <code class="literal">SubShader</code> section, as shown in the following code: </p><div class="informalexample"><pre class="programlisting">Properties { _BumpMap ("Bumpmap", 2D) = "bump" {} } 
SubShader { 
  …
  CGPROGRAM 
  #pragma surface surf Lambert 
  sampler2D _BumpMap; 
  …
  ENDCG 
}</pre></div><p>This is to make sure that our properties can be passed and used in the <code class="literal">CGPROGRAM</code> section.</p><p>We can see more details about this and see what each parameter does at <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/SL-Properties.html" target="_blank">http://docs.unity3d.com/Documentation/Components/SL-Properties.html</a>.</p></div><p>Then, we <a id="id458" class="indexterm"></a>set the <span class="strong"><strong>LOD</strong></span> (<span class="strong"><strong>Level of Detail</strong></span>) for our<a id="id459" class="indexterm"></a> shader to <code class="literal">300</code>. The LOD is the setup that will<a id="id460" class="indexterm"></a> limit our shader to use the maximum graphic details<a id="id461" class="indexterm"></a> of this <code class="literal">SubShader</code> section to the number that we set. We used 300 because<a id="id462" class="indexterm"></a> we have included a bump map in our shader, which is the same number of the Unity built-in setup for the diffuse bump. You can get <a id="id463" class="indexterm"></a>more information on shader LOD at <a class="ulink" href="http://unity3d.com/support/documentation/Components/SL-ShaderLOD.html" target="_blank">http://unity3d.com/support/documentation/Components/SL-ShaderLOD.html</a>.</p><p>We added the <code class="literal">sampler2D</code> <code class="literal">_BumpMap;</code> line, which is the same property that gets passed from the <code class="literal">Properties</code> section:</p><div class="informalexample"><pre class="programlisting">_BumpMap ("Bumpmap", 2D) = "bump" {}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>
<code class="literal">sampler2</code> is<a id="id464" class="indexterm"></a> basically a two-dimensional texture, which is the type of parameter used in Cg/HLSL. We can get more information about the Cg <a id="id465" class="indexterm"></a>parameter from <a class="ulink" href="https://developer.nvidia.com/content/cg-tutorial-chapter-3-parameters-textures-and-expressions" target="_blank">https://developer.nvidia.com/content/cg-tutorial-chapter-3-parameters-textures-and-expressions</a>.</p></div><p>Next, we added <code class="literal">float2 uv_BumpMap</code> in <code class="literal">struct Input {}</code>, which will be used to calculate the color information from <code class="literal">_BumpMap</code>. The <code class="literal">uv_BumpMap</code> parameter is the texture<a id="id466" class="indexterm"></a> coordinate, which is basically similar to <code class="literal">vector2</code>.</p><p>In the <code class="literal">surf()</code> function, we have the following:</p><div class="informalexample"><pre class="programlisting">half4 c = tex2D (_MainTex, IN.uv_MainTex); 
o.Albedo = c.rgb; 
o.Alpha = c.a; 
o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p>
<code class="literal">The</code> <code class="literal">surf(Input IN, inout SurfaceOutput o)</code> function is basically the function that will get the input information from <code class="literal">struct Input {}</code>. Then, we will assign the new parameter to <code class="literal">SurfaceOutput o</code>. This parameter will get passed and used next in the vertex and pixel processor.</p><p>We can get more details on <code class="literal">Input struct</code> and the default parameter of <code class="literal">SurfaceOutput struct</code> at <a class="ulink" href="http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaders.html" target="_blank">http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaders.html</a>.</p></div><p>Talking<a id="id467" class="indexterm"></a> about <code class="literal">SurfaceOutput struct</code>, it is the<a id="id468" class="indexterm"></a> default struct in<a id="id469" class="indexterm"></a> Unity, which <a id="id470" class="indexterm"></a>allows us to pass the parameters easily without creating one.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip18"></a>Tip</h3><p>
<code class="literal">SurfaceOutput</code> <code class="literal">struct</code> is the default struct in Unity, which is located in the <code class="literal">Lighting.cginc</code> file inside the Unity application. We can also create a custom <code class="literal">SurfaceOutput</code> <code class="literal">struct</code> to pass other variables that are not a part of the default struct by creating a new <code class="literal">SurfaceOutputCustom {…}</code> struct and passing it to the <code class="literal">surf()</code> function like <code class="literal">surf (Input IN, inout SurfaceOutputCustom o)</code>.</p></div><p>The <code class="literal">tex2D()</code> function<a id="id471" class="indexterm"></a> will return the color value (<code class="literal">Red</code>, <code class="literal">Green</code>, <code class="literal">Blue</code>, <code class="literal">Alpha</code>) or (<code class="literal">R</code>,<code class="literal">G</code>,<code class="literal">B</code>,<code class="literal">A</code>) from the sample state, <code class="literal">_MainTex</code>, and the texture coordinate, <code class="literal">IN.uv_MainTex</code>, which we will then assign to <code class="literal">o.Albedo</code> and <code class="literal">o.Alpha</code>, respectively. The <code class="literal">o.Albedo</code> parameter<a id="id472" class="indexterm"></a> will store the color information (RGB) and the <code class="literal">o.Alpha</code> parameter will store the alpha information.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>Albedo, or<a id="id473" class="indexterm"></a> the reflection coefficient, is defined as the ratio of the reflected radiation from the surface to the incident radiation upon it. It also refers to the diffuse reflectivity or the reflecting power of a surface.</p><p>More<a id="id474" class="indexterm"></a> information can be found at <a class="ulink" href="http://en.wikipedia.org/wiki/Albedo" target="_blank">http://en.wikipedia.org/wiki/Albedo</a>.</p></div><p>The next line is to get the normal information, which is the vector that contains the position (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span>). Then, we <a id="id475" class="indexterm"></a>used the <code class="literal">tex2D()</code> function to get the color values (R,G,B,A) from the sample state, <code class="literal">_BumpMap</code>, and the texture coordinates from <code class="literal">IN.uv_BumpTex</code>. Then, we used the <code class="literal">UnpackNormal()</code> function to get the normal<a id="id476" class="indexterm"></a> as the result of the <code class="literal">tex2D()</code> function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec60"></a>Classified intel</h3></div></div></div><p>Talking about shader programming, there are a lot of things to get to know and understand, for example, how the shader works. We will take a look at the basic structure of shader programming in Unity. The following diagram explains how shaders work:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_17.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note37"></a>Note</h3><p>The preceding diagram is from Amir Ebrahimi and Aras Pranckevčius, who presented the Shader Programming course at Unite 2008, and it represents how a shader works in Unity. We can get more information from the following website (warning: this presentation might be difficult to understand, as it showed how to create the shader without using any surface shader and it used the old version of Unity): <a class="ulink" href="http://unity3d.com/unite/archive/2008" target="_blank">http://unity3d.com/unite/archive/2008</a>.</p></div><p>Let's get back to the diagram—we can see that the shader file that we are writing works on both the vertex and pixel (fragment) levels. Then, it will show the result to the frame buffer, but what are vertex and pixel shaders? These are the different types of processors in the GPU. First, the vertex processor gets the vertex data, which contains the position and color of each vertex in the 3D model; then, it draws a triangle from these vertices and passes the <a id="id477" class="indexterm"></a>data to the pixel processor. The pixel <a id="id478" class="indexterm"></a>processor will get that <a id="id479" class="indexterm"></a>value and translate it to the per-pixel <a id="id480" class="indexterm"></a>screen. It is similar to taking vector art from Illustrator or Flash and translating it to pixel art in Photoshop. Then, it interpolates color data to each pixel, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781849695589/graphics/5589OT_03_18.jpg" /></div><p>From <a id="id481" class="indexterm"></a>the explanation, we know that we need to deal <a id="id482" class="indexterm"></a>with the vertex and pixel shader<a id="id483" class="indexterm"></a> programming when we want to write a shader program. For <a id="id484" class="indexterm"></a>example, if we want to create a shader, we will need to get the vertex data from our geometry, calculate the data, and pass it out to the pixel level. At the pixel level, we will calculate the color of the geometry, light, and shadow, and then we will get the result.</p><p>However, this can be very complex and repetitive when we have to handle lighting manually. That's why Unity created surface shaders so that we don't have to deal with various types of lightning, rendering, and so on. </p><p>If you check out the <span class="strong"><strong>ShaderLab</strong></span> link in Unity, you will see that there are many things to do, but don't be afraid because we don't need to understand everything that's there to create our custom shader. In the next step, we will create the custom lighting models in surface shaders.</p></div></div>