<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec81"></a>User input</h2></div></div><hr /></div><p>The first and relatively the most simple functionality we can add is the ability to jump. We already have basic physics with gravity working on the <strong class="userinput"><code>Player</code></strong> game object. Before we can make our <strong class="userinput"><code>Player</code></strong> game object jump, we need to know when this should happen. The user always needs some sort of interface in order to interact with the game. On PC and Mac, in most cases, it will be the mouse or keyboard. On mobile devices, it will be the touchscreen.</p><p>Unity gives us a lot of <span class="emphasis"><em>out–of–the–box</em></span> functions we can call to check whether the user is trying to interact through any input. For this game, we will be using the keyboard as our main controller. Now let's take a look how to use our keyboard to interact with the game:</p><pre class="programlisting"><span>if(Input.GetKey(KeyCode.Space))</span></pre><p>As we can see, this is the code that we'll be using to make our keyboard communicate with the game. Here, it says that if we press a key and that key is the space bar, the code that is inside of this statement will run.</p><p>For every key, there are three stages of an input:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"> <code class="literal">Input.GetKey</code> :</li></ul></div><pre class="programlisting">if(Input.GetKey(KeyCode.Space)) </pre><p>This returns <code class="literal">true</code> while the user holds down the key identified by name. Think auto fire.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"> <code class="literal">Input.GetKeyDown</code> :</li></ul></div><pre class="programlisting">if(Input.GetKeyDown(KeyCode.Space)) </pre><p>This returns <code class="literal">true</code> during the frame the user starts pressing down the key identified by name. Until you release the key, the code inside of this statement will continue <span>runnin</span>g.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"> <code class="literal">Input.GetKeyUp</code> :</li></ul></div><pre class="programlisting">if(Input.GetKeyUp(KeyCode.Space)) </pre><p>This returns <code class="literal">true</code> during the frame the user releases the key identified by name. The code will only run the moment you release the key.</p><p>Now that we understand more about the three stages of an input, we can proceed by choosing the keys that will be responsible for jumping, moving forward, and moving backward.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec59"></a>Jump</h3></div></div></div><p>Let's take a look at the Unity <span class="emphasis"><em>Scripting documentation</em></span> and search for <code class="literal">scripting reference for Rigidbody2D.AddForce</code>. This is the way we will apply force to our character. Now we are going to add more code to <code class="literal">PlayerController</code> so it looks more or less like this:</p><div class="mediaobject"><img src="/graphics/9781788478922/graphics/5adf9336-03e2-4f01-b7cb-bdddda326fdd.png" /></div><p>Lots of new code! Let's go through each new line we have added.</p><p>Line 7 should be very easy for you to understand now. It declares the <code class="literal">float</code> type <code class="literal">jumpForce</code> variable. In lines <strong class="userinput"><code>8</code></strong> and <strong class="userinput"><code>12</code></strong>, we will be controlling the character physics in the <code class="literal">PlayerController</code> script, so we need easy access to the <code class="literal">RigidBody2D</code> component on the same game object.</p><p>Have a look at the <strong class="userinput"><code>Scripting Reference</code></strong> for <code class="literal">GameObject.GetComponent</code>. It searches the game object our <code class="literal">PlayerController</code> is attached to for the <code class="literal">Rigidbody2D</code> component and returns it so we can assign the <code class="literal">rigidBody</code> private variable for easy access. <code class="literal">GetComponent</code> must be called at runtime, so we are calling it in the <code class="literal">Awake</code> function. After line <strong class="userinput"><code>12</code></strong>, we can simply say <code class="literal">rigidBody</code>. The <code class="literal">RigidBody2D</code> component will be called on <code class="literal">playerGameObject</code>.</p><p>See how simple the <code class="literal">Jump</code> function is. It's just a simple line saying, "Hey, RigidBody, apply force with the direction up with this jump force." There are a few force modes we can use for other useful stuff; however, impulse makes sense for jumping. We just want to kick the character up and then let him fall back to the ground.</p><p>Go ahead, press <strong class="userinput"><code>Play</code></strong> in Unity, and then press the space bar a few times in the game view. We can see that our character is actually jumping, but something is wrong. We need him to jump higher. Experiment with the jump force in the Inspector to find the right value:</p><div class="mediaobject"><img src="/graphics/9781788478922/graphics/bf248de4-8732-40d2-8107-8df7f53ed4af.png" /></div><p>I think the value <code class="literal">10</code> looks good for the jump height. It's not too high and not too low.</p><p>You probably noticed already that we have an issue. We are applying the jump force every time the space bar is pressed. This is good. However, the character should not jump in the air. If you press the space bar many times quickly, he'll simply fly away. We can fix that by adding a bit more code. The right behavior will be to only jump when the character is on the ground.</p><p>Let's add the following code and edit the <code class="literal">Jump</code> method a little:</p><div class="mediaobject"><img src="/graphics/9781788478922/graphics/11199a3a-25ed-4afa-8574-ac2f986194d8.png" /></div><p>I will make a little exception from the rule: I won't analyze this code from top to bottom. I want to talk about the <code class="literal">IsGrounded</code> function. In programming and math in general, there isn't a simple way of asking the computer whether the character is on the ground or in the air. When developing a game, one of the main things that we should be able to do is break big and complex ideas into simple programmable parts. Let's not talk about the <code class="literal">IsGrounded</code> method yet and focus on line <strong class="userinput"><code>35</code></strong>.</p><p>Search the scripting reference for <code class="literal">Physics2D.Raycast</code> and have a read through. You should see that <code class="literal">Raycast</code> is casting a ray against colliders in the scene. To better exemplify what a <code class="literal">Raycast</code> is, we'll use a simple real<span class="emphasis"><em>–</em></span>life example, a laser pointer. Imagine you are holding the laser pointer and pointing at the floor. This is exactly what are we doing in line <strong class="userinput"><code>35</code></strong>.</p><p>We are basically saying "Hey Unity, shoot the laser down from this <code class="literal">GameObject</code> position and check whether the distance to hit any object on the ground layer is less than 0.2.":</p><div class="mediaobject"><img src="/graphics/9781788478922/graphics/f6415d4b-dac0-4e18-81c7-489d2a3ad034.png" /></div><p>Have a look at this image. The green point represents the origin of the ray we are virtually casting. The blue point is the hit point. The ray distance would be the distance between the origin and the hit point. In this case, we are casting the ray down to a maximum distance of 0.2. I have visualized that distance with an orange line. Looking back at <code class="literal">IsGroundedMethod()</code>, we can see that the method returns <code class="literal">true</code> if the raycast hit happens within a distance of 0.2; otherwise, we return <code class="literal">false</code>.</p><p>Let's look at the parameters in the actual <code class="literal">Raycast</code> function again. <code class="literal">Physics2D.Raycast</code> has lots of different overloads, which means we can pass a few sets of parameters to the method. In this case, we are using an overload with four parameters:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">origin</code></li><li style="list-style-type: disc"><code class="literal">direction</code></li><li style="list-style-type: disc"><code class="literal">distance</code></li><li style="list-style-type: disc"><code class="literal">layerMask</code></li></ul></div><p>We can preview the names and types of the parameters if we hover our mouse for a few seconds above the word <code class="literal">Raycast</code> in the code:</p><div class="mediaobject"><img src="/graphics/9781788478922/graphics/5237f5d2-67f8-4875-8764-6b7601b96ed9.png" /></div><p>We have already covered <code class="literal">origin</code>, <code class="literal">direction</code>, and <code class="literal">distance</code>. Let's briefly talk about <code class="literal">layerMask</code>. We can specify a filter here to detect colliders only on certain layers. This means we can set Unity to make <code class="literal">Raycast</code> work only on specific layers. In this case, we are simply checking whether the <strong class="userinput"><code>Player</code></strong> is grounded or not. So, the wise thing to do is to set <code class="literal">Raycast</code> to work only with objects on the ground layer.</p><p>To make sure everything works as it should, we must create the ground layer:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In Unity, navigate to <strong class="userinput"><code>Edit</code></strong> | <strong class="userinput"><code>Project Settings</code></strong> | <strong class="userinput"><code>Tags &amp; Layers</code></strong> </li><li>In the <strong class="userinput"><code>Inspector</code></strong>, click on the plus sign and then write <code class="literal">Ground</code> next to <strong class="userinput"><code>User Layer</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788478922/graphics/eb959e95-7973-417a-bba9-5d68205bbbd3.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Select the <code class="literal">Floor</code> game object in the hierarchy and click on the <strong class="userinput"><code>Layer</code></strong> menu:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788478922/graphics/ab47c7c9-7ce1-41fa-bfb3-6100127e15bc.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Then set its layer to <strong class="userinput"><code>Ground</code></strong>. Set it up as shown here: </li></ol></div><div class="mediaobject"><img src="/graphics/9781788478922/graphics/c9fccc0c-3af6-4734-9a88-4a26fc935ce6.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>We have the <strong class="userinput"><code>Ground</code></strong><strong class="userinput"><code>Layer</code></strong> set up. Set up the layer mask on the <strong class="userinput"><code>Player</code></strong> game object now. If you save the <strong class="userinput"><code>Player</code></strong> script, you will notice a new public member variable has appeared:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788478922/graphics/9fb35500-3e80-41d6-997e-263f9c6dc79d.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Press <strong class="userinput"><code>Play</code></strong> in Unity and perform a test jump. If everything is done correctly, jumping will work only when Jake is on the ground. We check whether our character is on the ground in line <strong class="userinput"><code>26</code></strong>. If the <code class="literal">IsGrounded()</code> method returns <code class="literal">true</code>, the <code class="literal">Jump</code> method is called; otherwise, we simply ignore the user input.</li></ol></div></div></div>