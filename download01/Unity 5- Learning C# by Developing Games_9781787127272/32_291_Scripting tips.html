<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch32lvl1sec265"></a>Scripting tips</h2></div></div><hr /></div><p>The following tips are useful features to<a id="id1805" class="indexterm"></a> know when scripting.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch32lvl2sec246"></a>General</h3></div></div></div><p>We can modify various templates of new Script, Shader, and Compute Shader files. This can be helpful to remove the empty <a id="id1806" class="indexterm"></a>Update stubs which, as we learned, can cause unnecessary runtime overhead. These files can be found in the following locations:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Windows: <code class="literal">&lt;Unity install&gt;\Editor\Data\Resources\ScriptTemplates\</code></p></li><li style="list-style-type: disc"><p>OSX: <code class="literal">/Applications/Unity/Editor/Data/Resources/ScriptTemplates/</code></p></li></ul></div><p>The recent release of Unity Version 5.1 introduced the <code class="literal">Assert</code> class and allows for assert-based debugging, which some developers are more comfortable with as opposed to exception-based debugging. Check the Unity documentation for more information on Asserts: <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Assertions.Assert.html" target="_blank">http://docs.unity3d.com/ScriptReference/Assertions.Assert.html</a></p><p>Calling <code class="literal">Debug.Break()</code> is functionally equivalent to pausing the Editor during Play Mode, which can be useful for catching awkward graphical behavior, or as a more convenient alternative to the absurd hotkey required to pause the Scene (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>P</em></span>).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch32lvl2sec247"></a>Attributes</h3></div></div></div><p>Attributes are very useful meta-level tags that can be given to almost any target in C#. They are most commonly used on member data (fields) and classes, allowing us to flag them with special properties so that they can be processed differently. Intermediate and advanced Unity developers will find it <a id="id1807" class="indexterm"></a>worthwhile to read the C# documentation on attributes and use their imagination to come up with their own attributes that help accelerate their workflow. There are quite a few attributes built in to the Unity engine that can be exceptionally useful when used in the right place.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note172"></a>Note</h3><p>Advanced users will note that attributes can also be given to enums, delegates, methods, parameters, events, modules, and even assemblies.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch32lvl3sec91"></a>Variable attributes</h4></div></div></div><p>Public variables are fairly dangerous<a id="id1808" class="indexterm"></a> things to add to our components, as anything can come along and change the value at runtime, making it hard to trace bugs, as well as requiring special hand holding to prevent the variable from being given an invalid value. However, <code class="literal">public</code> variables are usually the first way that Unity developers learn to expose variables in the <span class="strong"><strong>Inspector</strong></span> View. In some cases, the <code class="literal">public</code> variable is absolutely intended to be public, but we don't wish it to be seen in the <span class="strong"><strong>Inspector</strong></span>. In such a case, the <code class="literal">[HideInInspector]</code> attribute can be used to hide the variable from the <span class="strong"><strong>Inspector</strong></span>, whenever necessary.</p><p>However, the preferred approach is to make our variables private or protected and allow Editor-based development by exposing values through the <code class="literal">[SerializeField]</code> attribute. This attribute allows private and protected variables to be revealed in the <span class="strong"><strong>Inspector</strong></span> for designers to manipulate, without risking other components accidentally changing the variable at runtime.</p><p>The <code class="literal">[Range]</code> attribute can be added to an integer or floating-point field to convert it into a slider in the <span class="strong"><strong>Inspector</strong></span> View. We can give minimum and maximum values, limiting the range that the value can contain.</p><p>Normally, if a variable is renamed, even if we do a refactor through our IDE (whether its MonoDevelop or Visual Studio) then the values are lost as soon as Unity recompiles the MonoBehaviour and makes the appropriate changes to any instances of the component. However, the <code class="literal">[FormerlySerializedAs]</code> attribute is incredibly helpful if we wish to rename a variable that has been previously serialized, as it will copy the data from the variable named within the attribute into the given variable during compilation time. No more lost data due to renaming stuff!</p><p>Note that it is <span class="emphasis"><em>not</em></span> safe to remove the <code class="literal">[FormerlySerializedAs]</code> attribute after the conversion is completed, unless the variable has been manually changed and resaved since completion. The ".prefab" data file will still contain the old variable name, and so it still needs the <code class="literal">[FormerlySerializedField]</code> attribute to figure out where to place the data the next time the file is loaded (for example, when the Editor is closed and reopened). Thus, this is a<a id="id1809" class="indexterm"></a> helpful attribute, but extended use does tend to clutter up our codebase a lot.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch32lvl3sec92"></a>Class attributes</h4></div></div></div><p>The <code class="literal">[SelectionBase]</code> attribute will <a id="id1810" class="indexterm"></a>mark any GameObject the component is attached to as the root of selection for the Scene View. This is especially useful if we have meshes that are children of other objects, as we might want the parent object to be selected with the first click, instead of the object with the Mesh Renderer component.</p><p>We can use the <code class="literal">[RequireComponent]</code> attribute to force designers to attach vital components to the same GameObject if they attempt to attach this component. This ensures any dependencies that our codebase relies on will be satisfied by designers, without having to write out a whole bunch of documentation for them.</p><p>The <code class="literal">[ExecuteInEditMode]</code> attribute will force the object's <code class="literal">Update()</code>, <code class="literal">OnGUI()</code>, and <code class="literal">OnRenderObject()</code> methods to be called even during Edit Mode. However, there are caveats:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <code class="literal">Update()</code> method is only called if something changes in the Scene</p></li><li style="list-style-type: disc"><p><code class="literal">OnGUI()</code> is only called during Game View events, not for other views such as the Scene View</p></li><li style="list-style-type: disc"><p><code class="literal">OnRenderObject()</code> is called during any repaint event for the Scene and Game Views</p></li></ul></div><p>However, this gives such objects a different set of event hooks and entry points compared to typical Editor scripts, so this attribute still has its uses.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch32lvl2sec248"></a>Logging</h3></div></div></div><p>We can add rich text tags to debug<a id="id1811" class="indexterm"></a> strings. Tags such as <code class="literal">&lt;size&gt;</code>, <code class="literal">&lt;b&gt;</code> (bold), <code class="literal">&lt;i&gt;</code> (italics), and <code class="literal">&lt;color&gt;</code> all work on debug strings. This can be helpful for differentiating the different kinds of log messages and highlighting specific elements.</p><div class="informalexample"><pre class="programlisting">Debug.Log ("&lt;color=red&gt;[ERROR]&lt;/color&gt;This is a &lt;i&gt;very&lt;/i&gt; &lt;size=14&gt;&lt;b&gt;specific&lt;/b&gt;&lt;/size&gt; kind of log message");</pre></div><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_08_07.jpg" /></div><p>The <code class="literal">MonoBehaviour</code> class has a <code class="literal">print()</code> method for convenience, which does the same thing as <code class="literal">Debug.Log()</code>.</p><p>It can help to create a custom logger class, which automatically appends <code class="literal">\n\n</code> to the end of every log message. This will push and hide away the unnecessary <code class="literal">UnityEngine.Debug:Log(Object)</code> clutter that <a id="id1812" class="indexterm"></a>tends to fill the Console window.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch32lvl2sec249"></a>Useful links</h3></div></div></div><p>Unity technologies provide many useful<a id="id1813" class="indexterm"></a> tutorials on the usage of various scripting features, which are primarily targeted at beginner and intermediate-level developers. The tutorials can be found at <a class="ulink" href="https://unity3d.com/learn/tutorials/topics/scripting" target="_blank">https://unity3d.com/learn/tutorials/topics/scripting</a>.</p><p>There's a helpful post on Unity Answers, which provides a reference list that covers many of the different scripting and compilation errors we might run across during development, which can be found at <a class="ulink" href="http://answers.unity3d.com/questions/723845/what-are-the-c-error-messages.html" target="_blank">http://answers.unity3d.com/questions/723845/what-are-the-c-error-messages.html</a>.</p><p><code class="literal">ScriptableObjects</code> are very useful objects and an excellent way of storing game data in a form that does not need to be instantiated at runtime. They work like any other class in that they can contain methods and variables, can be serialized, allow polymorphism, and so on. The only tricky part is they can only be created through scripting, and must be loaded into memory at any time using <code class="literal">Resources.Load()</code>. But this allows us to control which <code class="literal">ScriptableObjects</code> are present in memory at any given time, giving us more control over runtime memory consumption. Explaining the nuances of <code class="literal">ScriptableObjects</code> here would take too much space, but Unity technologies have provided a good introductory<a id="id1814" class="indexterm"></a> examination of <code class="literal">ScriptableObjects</code> in the following tutorial video:</p><p><a class="ulink" href="https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects" target="_blank">https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects</a></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note173"></a>Note</h3><p>Note that, despite the category of the <code class="literal">ScriptableObject</code> video, it's generally considered more of an intermediate-level topic. Beginners would be best served by focusing on becoming comfortable with Prefabs, before turning things on their head through <code class="literal">ScriptableObjects</code> and the important serialization topics that need to be understood.</p></div><p>Nested Coroutines are another interesting and useful area of scripting that is not well documented. But, the following third-party blog post, which covers a lot of the interesting details, should be considered when working with <a id="id1815" class="indexterm"></a>Nested Coroutines:</p><p><a class="ulink" href="http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper" target="_blank">http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper</a></p><p>We can figure out when a particular feature was added to the Unity API by checking the API history page<a id="id1816" class="indexterm"></a> at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/40_history.html" target="_blank">http://docs.unity3d.com/ScriptReference/40_history.html</a>.</p></div></div>