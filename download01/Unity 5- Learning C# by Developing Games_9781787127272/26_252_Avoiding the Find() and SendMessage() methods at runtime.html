<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch26lvl1sec232"></a>Avoiding the Find() and SendMessage() methods at runtime</h2></div></div><hr /></div><p>The <code class="literal">SendMessage()</code> method and family of <code class="literal">GameObject.Find()</code> methods are notoriously expensive, and should be avoided at all costs. The <code class="literal">SendMessage()</code> method is about 2,000 times<a id="id1264" class="indexterm"></a> slower than a simple function call, and the cost of the <code class="literal">Find()</code> method scales very poorly with Scene complexity since it must iterate through every GameObject in the Scene. It is sometimes reasonable to call <code class="literal">Find()</code> during initialization of a Scene, such as <code class="literal">Awake()</code> and <code class="literal">Start()</code>, only for objects that already exists in the Scene. However, using either<a id="id1265" class="indexterm"></a> method for inter-object communication at runtime is likely to generate a very noticeable overhead.</p><p>Relying on <code class="literal">Find()</code> and <code class="literal">SendMessage()</code> type methods is typically symptomatic of poor design, inexperience in programming with C# and Unity, or just plain laziness during prototyping. Their usage has become something of an epidemic among beginner- and intermediate-level projects, such that Unity Technologies feels the need to keep reminding users to avoid using them in a real game, over and over again in their documentation and at their conferences. They only exist as a less <span class="emphasis"><em>programmer-y</em></span> way to introduce new users to inter-object communication, and for some special cases where they can be used in a lazy, but responsible, way.</p><p>To be fair, Unity targets a wide demographic of users, from individual hobbyists, students, and those with delusions of grandeur, to small, mid-sized, and large development teams. This results in an incredibly wide range of software development ability. When you're starting out with Unity, it can be difficult to figure out on your own what you <span class="emphasis"><em>should</em></span> be doing differently, especially given how the Unity engine does not adhere to the design paradigms of many other game engines. It has some foreign and quirky concepts surrounding scenes and prefabs, as well as no <span class="emphasis"><em>god class</em></span> entry points, nor any obvious raw-data storage systems to work with.</p><p>Since we're talking about scripting optimization in this section, let's explore the subject in some detail, discussing some alternative methods for inter-object communication.</p><p>Let's start by examining a worst-case example, which uses both <code class="literal">Find()</code> and <code class="literal">SendMessage()</code> methods, and discover some ways to improve upon it. The following example method attempts to instantiate a given number of enemies from a prefab, and then notifies an <code class="literal">EnemyManager</code> object of their existence:</p><div class="informalexample"><pre class="programlisting">public void SpawnEnemies(int numEnemies) {
  for(int i = 0; i &lt; numEnemies; ++i) {
    GameObject enemy = (GameObject)GameObject.Instantiate(_enemyPrefab, Vector3.zero, Quaternion.identity);
    GameObject enemyManagerObj = GameObject.Find("EnemyManager");
    enemyManagerObj.SendMessage("AddEnemy", enemy, SendMessageOptions.DontRequireReceiver);
  }
}</pre></div><p>Putting method calls inside a loop, which always output to the same result, is a big red flag for poor performance, and when we're dealing with expensive methods such as <code class="literal">Find()</code>, we should <a id="id1266" class="indexterm"></a>always look for ways to call them as few times as possible. Ergo, one improvement we can make is to move the <code class="literal">Find()</code> call outside<a id="id1267" class="indexterm"></a> of the <code class="literal">for</code> loop and cache the result in a local variable to be used within the loop.</p><p>We can also optimize our usage of the <code class="literal">SendMessage()</code> method by replacing it with a <code class="literal">GetComponent()</code> call. This replaces a very costly method with a much gentler variation, achieving effectively the same result.</p><p>This gives us the following:</p><div class="informalexample"><pre class="programlisting">public void SpawnEnemies(int numEnemies) {

  GameObject enemyManagerObj = GameObject.Find("EnemyManager");
  EnemyManagerComponent enemyMgr = enemyManagerObj.GetComponent&lt;EnemyManagerComponent&gt;();

  for(int i = 0; i &lt; numEnemies; ++i) {
    GameObject enemyIcon = (GameObject)GameObject.Instantiate(_enemyPrefab, Vector3.zero, Quaternion.identity);
    enemyMgr.AddEnemy(enemy);
  }
}</pre></div><p>If this method is called during the initialization of the Scene, and we're not overly concerned with loading time, then we can probably consider ourselves finished with our optimization work.</p><p>However, we often need new objects that are instantiated at runtime to find an existing object to communicate with. In this example, we want new enemy objects to register with our <code class="literal">EnemyManagerComponent</code> so that it can do whatever it needs to do to control the enemy objects in our Scene. We would like a reliable and fast way for new objects to find existing objects without unnecessary usage of the <code class="literal">Find()</code> method, due to the overhead involved.</p><p>There are multiple approaches we can take to solving this problem, each with their own benefits <a id="id1268" class="indexterm"></a>and <a id="id1269" class="indexterm"></a> pitfalls:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Static classes</p></li><li style="list-style-type: disc"><p>Singleton Components</p></li><li style="list-style-type: disc"><p>Assign references to pre-existing objects</p></li><li style="list-style-type: disc"><p>A global messaging system</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch26lvl2sec149"></a>Static classes</h3></div></div></div><p>This approach involves<a id="id1270" class="indexterm"></a> creating a class that is globally accessible to the entire codebase at any time. The object stays alive from the moment the application starts, to the moment it is closed. Global <code class="literal">manager</code> classes are often frowned upon, since the name doesn't say much about what it's meant to do, and they can be difficult to debug since changes can occur from anywhere, at any point during runtime. In addition, it is probably the least robust approach when it comes to changing or replacing it at a future date. Despite all of these drawbacks, it is by far the easiest solution to implement, and so we will cover it first.</p><p>The Singleton design pattern is a common way of ensuring that we have a globally-accessible object, and that only one instance ever exists in memory. However, the way that Singletons are <span class="emphasis"><em>primarily</em></span> used (note the qualifier) in Unity projects, can be easily replaced with a simple C# Static class without the need to implement <code class="literal">private</code> constructors, and the unnecessary property access of an <code class="literal">Instance</code> variable. Essentially, implementing a typical Singleton design pattern in C# just takes more code, and time, to achieve the same result as a <code class="literal">static</code> class.</p><p>A <code class="literal">static</code> class that functions in much the same way as our <code class="literal">EnemyManagerComponent</code> is used in the previous example can be defined as follows:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Generic;

public static class EnemyManager {
  static List&lt;GameObject&gt; _enemies;

  public static void AddEnemy(GameObject enemy) {
    _enemies.Add (enemy);
  }

  public static void RollCall() {
    for(int i = 0; i &lt; _enemies.Count; ++i) {
      Debug.Log (string.Format("Enemy \"{0}\" reporting in...", _enemies[i].name));
    }
  }
}</pre></div><p>Note that every member and method has the <code class="literal">static</code> keyword attached, which implies that only one instance of this object will ever reside in memory. Static classes, by definition, do not allow any nonstatic instance members to be defined, as that would imply that we could somehow duplicate the object.</p><p>Static classes can be given a <code class="literal">static</code> constructor, which can be used to initialize member data. A <code class="literal">static</code> constructor can be defined like so, and it is called the moment the class is first accessed (either through a member variable or a member function):</p><div class="informalexample"><pre class="programlisting">static EnemyManager() {
  _enemies = new List&lt;GameObject&gt;();
}</pre></div><p>This type of global class is generally considered to be a cleaner and easier-to-use version of the typical Singleton design pattern in the world of C# development.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch26lvl2sec150"></a>Singleton Components</h3></div></div></div><p>The disadvantage of the <code class="literal">static</code> <a id="id1271" class="indexterm"></a>class approach is that they must inherit from the lowest form of classâ€”Object. This means that static classes cannot inherit from <code class="literal">MonoBehaviour</code> and therefore we cannot make use of any of its Unity-related functionality, including the all-important event callbacks, as well as Coroutines. Also, since there's no object to select, we lose the ability to inspect the object's data at runtime through the Inspector. These are features that we may wish to make use of in our global Singleton classes.</p><p>A common solution to this problem is to implement a "<span class="emphasis"><em>Singleton as a Component</em></span>" class that spawns a GameObject containing itself, and providing static methods to grant global access. Note that, in this case, we must essentially implement the typical Singleton design pattern, with private static instance variables, and a global <code class="literal">Instance</code> method for global access.</p><p>Here is the definition for a <code class="literal">SingletonAsComponent</code> class:</p><div class="informalexample"><pre class="programlisting">public class SingletonAsComponent&lt;T&gt; : MonoBehaviour where T : 
SingletonAsComponent&lt;T&gt; {
  
  private static T __Instance;
  
  protected static SingletonAsComponent&lt;T&gt; _Instance {
      get {
        if(!__Instance) {
              T [] managers = 
              GameObject.FindObjectsOfType(typeof(T)) as T[];
              if (managers != null) {
                  if(managers.Length == 1) {
                      __Instance = managers[0];
                      return __Instance;
                  } else if (managers.Length &gt; 1) {
                      Debug.LogError("You have more than one " + 
                      typeof(T).Name + " in the scene. You only 
                      need 1, it's a singleton!");
                      for(int i = 0; i &lt; managers.Length; ++i) {
                          T manager = managers[i];
                          Destroy(manager.gameObject);
                      }
                  }
              }

              GameObject go = new GameObject(typeof(T).Name, 
              typeof(T));
              __Instance = go.GetComponent&lt;T&gt;();
              DontDestroyOnLoad(__Instance.gameObject);
          }
          return __Instance;
      } 
      set {
          __Instance = value as T;
      }
  }
}</pre></div><p>Since we wish this to be a global and persistent object, we need to call <code class="literal">DontDestroyOnLoad()</code> shortly after the GameObject is created. This is a special function that tells Unity that we wish the object to persist between Scenes for as long as the application is<a id="id1272" class="indexterm"></a> running. From that point onward, when a new scene is loaded, the object will not be destroyed and will retain all of its data.</p><p>This class definition assumes two things. Firstly, because it is using generics to define its behavior, it must be derived from in order to create a concrete class. Secondly, a method will be defined to assign the <code class="literal">_Instance</code> variable and cast it to/from the correct Type.</p><p>For example, the following is all that is needed to successfully generate a new <code class="literal">SingletonAsComponent</code> derived class called <code class="literal">MySingletonComponent</code>:</p><div class="informalexample"><pre class="programlisting">public class MySingletonComponent : SingletonAsComponent&lt;MySingletonComponent&gt; {
  public static MySingletonComponent Instance {
    get { return ((MySingletonComponent)_Instance); }
    set { _Instance = value; }
  }
}</pre></div><p>This class can be used at runtime by having any other object access the <code class="literal">Instance</code> property at any time. If the Component does not already exist in our Scene, then the <code class="literal">SingletonAsComponent</code> base class will instantiate its own GameObject and attach an instance of the derived class to it as a Component. From that point forward, access through the <code class="literal">Instance</code> property will reference the Component that was created.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Tip</h3><p>While it is possible, we should not place our <code class="literal">SingletonAsComponent</code> derived class in a <span class="strong"><strong>Scene</strong></span> Hierarchy. This is because the <code class="literal">DontDestroyOnLoad()</code> method will never be called! This would prevent the Singleton Component's GameObject from persisting when the next Scene is loaded.</p></div><p>Proper cleanup of a Singleton Component can be a little convoluted because of how Unity tears down Scenes. An object's <code class="literal">OnDestroy()</code> method is called whenever it is destroyed during runtime. The same method is called during application shutdown, whereby every Component on every GameObject has its <code class="literal">OnDestroy()</code> method called by Unity. Application shutdown also takes place when we end Play Mode in the Editor and return to Edit Mode. However, destruction of objects occurs in a random order, and we cannot assume that the Singleton Component will be the last object destroyed.</p><p>Consequently, if<a id="id1273" class="indexterm"></a> any object attempts to do anything with the Singleton in the middle of their <code class="literal">OnDestroy()</code> method, then they will be calling the <code class="literal">Instance</code> property. If the Singleton has already been destroyed prior to this moment, then calling <code class="literal">Instance</code> during another object's destruction would create a new instance of the Singleton Component in the middle of application shutdown! This can corrupt our Scene files, as instances of our Singleton Components will be left behind in the Scene. If this happens, then Unity will throw the following error message at us:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_02_10.jpg" /></div><p>The reason some objects may wish to call into our Singleton during destruction is that Singletons often make use of the Observer pattern. This design pattern allows other objects to register/deregister with them for certain tasks, similar to how Unity latches onto callback methods, but in a less automated fashion. We will see an example of this in the upcoming section <span class="emphasis"><em>A global messaging system</em></span>. Objects that are registered with the system during construction will want to deregister with the system during their own shutdown, and the most convenient place to do this is within its <code class="literal">OnDestroy()</code> method. Consequently, such objects are likely to run into the aforementioned problem, where Singletons are accidentally created during application shutdown.</p><p>To solve this problem, we need to make three changes. Firstly, we need to add an additional flag to the Singleton Component, which keeps track of its active state, and disable it at the appropriate times. This includes the Singleton's own destruction, as well as application shutdown (<code class="literal">OnApplicationQuit()</code> is another useful Unity callback for <code class="literal">MonoBehaviours</code>, which is called during this time):</p><div class="informalexample"><pre class="programlisting">private bool _alive = true;
void OnDestroy() { _alive = false; }
void OnApplicationQuit() { _alive = false; }</pre></div><p>Secondly, we <a id="id1274" class="indexterm"></a>should implement a way for external objects to verify the Singleton's current state:</p><div class="informalexample"><pre class="programlisting">public static bool IsAlive {
  get {
    if (__Instance == null)
      return false;
    return __Instance._alive;
  }
}</pre></div><p>Finally, any object that attempts to call into the Singleton during its own <code class="literal">OnDestroy()</code> method, must first verify the state using the <code class="literal">IsAlive</code> property before calling <code class="literal">Instance</code>. For example:</p><div class="informalexample"><pre class="programlisting">public class SomeComponent : MonoBehaviour {
    void OnDestroy() {
    if (MySingletonComponent.IsAlive) {
        MySingletonComponent.Instance.SomeMethod();
    }
  }
}</pre></div><p>This will ensure that nobody attempts to access <code class="literal">Instance</code> during destruction. If we don't follow this rule, then we will run into problems where instances of our Singleton object will be left behind in the Scene after returning to Edit Mode.</p><p>The irony of the Singleton Component approach is that we are using one of Unity's <code class="literal">Find()</code> methods to determine whether or not one of these Singleton Components already exists in the Scene before we attempt to assign the <code class="literal">__Instance</code> reference variable. Fortunately, this will only happen when the Singleton Component is first accessed, but it's possible that the initialization of the Singleton would not necessarily occur during Scene initialization and can therefore cost us a performance spike at a bad moment during gameplay, when this object is first instantiated and <code class="literal">Find()</code> gets called. The workaround for this is to have some god class confirm that the important Singletons are instantiated during Scene initialization by simply calling <code class="literal">Instance</code> on each one.</p><p>The downside to this approach is that if we later decide that we want more than one of these manager classes executing at once, or we wish to separate its behavior to be more modular, then there would be a <span class="emphasis"><em>lot</em></span> of code that needs to change.</p><p>There are further alternatives that we can explore, such as making use of Unity's built-in bridge between script code and the Inspector interface.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch26lvl2sec151"></a>Assigning references to pre-existing objects</h3></div></div></div><p>Another approach to the problem of inter-object communication is to use Unity's built-in serialization systems. Software design purists tend to get a little combative about this feature, since it breaks encapsulation; it makes variables marked <code class="literal">private</code> act in a way that treats them as <code class="literal">public</code>. Even though the value only becomes public with respect to the Unity Inspector and nothing else, this is still enough to wave some red flags.</p><p>However, it is a <a id="id1275" class="indexterm"></a>very effective tool for improving development workflow. This is particularly true when artists, designers, and programmers are all tinkering with the same product, where each has wildly varying levels of computer science and software programming knowledge. Sometimes it's worth bending a few rules in the name of productivity.</p><p>Whenever we create a <code class="literal">public</code> variable, Unity automatically serializes and exposes the value in the Inspector interface when the Component is selected. However, <code class="literal">public</code> variables are dangerous from a software design perspectiveâ€”these variables can be changed through code at any time, which can make it hard to keep track of the variable, and introduce a lot of unexpected bugs.</p><p>As an alternative, we can take any <code class="literal">private</code> or <code class="literal">protected</code> member variable of a class and expose it to the Unity Editor Inspector interface with the <code class="literal">[SerializeField]</code> attribute. This approach is preferred over <code class="literal">public</code> variables, as it gives us more control of the situation. This way, at least we know the variables cannot be changed at runtime via code outside the class (or derived class), and therefore maintain encapsulation from the perspective of script code.</p><p>For example, the following class exposes three <code class="literal">private</code> variables to the Inspector:</p><div class="informalexample"><pre class="programlisting">public class EnemySpawnerComponent : MonoBehaviour {

  [SerializeField] private int _numEnemies;
  [SerializeField] private GameObject _enemyPrefab;
  [SerializeField] private EnemyManagerComponent _enemyManager;

  void Start() {
    SpawnEnemies(_numEnemies);
  }

    void SpawnEnemies(int _numEnemies) {
      for(int i = 0; i &lt; _numEnemies; ++i) {
        GameObject enemy = (GameObject)GameObject.Instantiate(_enemyPrefab, Vector3.zero, Quaternion.identity);
        _enemyManager.AddEnemy(enemy);
      }
    }
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip27"></a>Tip</h3><p>Note that the <code class="literal">private</code> access specifiers shown in the preceding code are redundant keywords in C#, as member variables are always <code class="literal">private</code> unless specified otherwise, but these access specifiers are included for completeness.</p></div><p>Looking at this<a id="id1276" class="indexterm"></a> Component in the <span class="strong"><strong>Inspector</strong></span> view reveals three values, initially given default values of <code class="literal">0</code>, or <code class="literal">null</code>, which can be modified through the Inspector interface:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_02_06.jpg" /></div><p>We can drag and drop a Prefab reference from the Projects window into the <span class="strong"><strong>Enemy Prefab</strong></span> field, or, if we felt so inclined, even a reference to another GameObject that is present in the Scene. Although, given that it's being used like a Prefab in the code, it would be unwise to do this, since we would be cloning a GameObject that might have already undergone changes in the Scene. Prefabs serve the purpose of a blueprint from which to instantiate new GameObjects and should be used as such.</p><p>The <span class="strong"><strong>Enemy Manager</strong></span> field is interesting because it is a Component reference and not a GameObject reference. If a GameObject is dropped into this field, then it will refer to the <span class="emphasis"><em>Component</em></span> on the given object, as opposed to the GameObject that we dragged and dropped into the field. If the given object does not have the expected Component, then nothing will be assigned.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip28"></a>Tip</h3><p>A common usage of the Component reference technique is to obtain references to Components attached to the same GameObject it is attached to. This is an alternative approach to the topic discussed in the section entitled <span class="emphasis"><em>Cache Component References</em></span>, earlier in this chapter.</p></div><p>The danger here is that since Prefabs are essentially GameObjects, Prefabs with the required Component <span class="emphasis"><em>can</em></span> be assigned to these fields, even though we might not wish them to be. Unity loads Prefabs into memory much like GameObjects, and assumes they'll be used in Prefab-like ways; that is, treated as nothing more than blueprints to be instantiated from on an as-needed basis. However, they still count as data stored in memory and can therefore be edited on a whim, making them susceptible to changes that directly affect all future GameObjects instantiated from them.</p><p>To make matters <a id="id1277" class="indexterm"></a>worse, these changes become permanent even if they are made during Play Mode, since Prefabs occupy the same memory space whether Play Mode is active or not. This means that we can accidentally corrupt our Prefabs, if we assign them to the wrong fields. Consequently, this approach is a more team-friendly way of solving the original problem of inter-object communication, but it is not ideal due to all of the risks involved with team members accidentally breaking things or leaving <code class="literal">null</code> references in place.</p><p>It is also important to note that not all objects can be serialized by the Inspector view. Unity can serialize all primitive data types (<code class="literal">ints</code>, <code class="literal">floats</code>, <code class="literal">strings</code>, and <code class="literal">bools</code>), various built-in types such as (<code class="literal">Vector3</code>, <code class="literal">Quaternion</code>, and so on) enums, classes, and structs, as well as arrays and lists of other serializable types. However, it is unable to serialize static fields, read-only values, properties, and dictionaries.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip29"></a>Tip</h3><p>Some Unity developers like to implement pseudo-serialization of dictionaries via two separate lists for keys and values, along with a Custom Editor script, or via a single list of objects, which contain both keys and values. Both of these solutions are a little clumsy, but perfectly valid.</p></div><p>The last solution we will look at will provide a way to hopefully get the best of both worlds by combining ease of implementation, ease of extension, and strict usage that avoids too much human error.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch26lvl2sec152"></a>A global messaging system</h3></div></div></div><p>The final<a id="id1278" class="indexterm"></a> suggested approach to the<a id="id1279" class="indexterm"></a> problem of inter-object communication is to implement a global messaging system that any object can access and send messages through to any object that may be interested in listening to that specific type of message. Objects either send messages or listen for them, and the responsibility is on the listener to decide what messages it is interested in. The message sender can broadcast the message without caring at all who is listening. This approach is excellent for keeping our code modular and decoupled.</p><p>The kinds of message we wish to send can take many forms, such as including data values, references, instructions for listeners, and more, but they should all have a common, basic declaration that our messaging system can use to determine what the message is, and who it is intended for.</p><p>The following is a simple class definition for a <code class="literal">Message</code> object:</p><div class="informalexample"><pre class="programlisting">public class BaseMessage {
  public string name;
  public BaseMessage() { name = this.GetType().Name; }
}</pre></div><p>The <code class="literal">BaseMessage</code> class's constructor caches the Type in a local string property to be used later for <a id="id1280" class="indexterm"></a>cataloguing and distribution purposes. Caching this value is important as each call to <code class="literal">GetType().Name</code> will result in a new string being allocated on the heap, and we want to minimize this as much as possible. Our custom messages must derive from this class, which allows them to add whatever superfluous data they wish, while still maintaining the ability to be sent through our messaging system. Take note that, despite acquiring the Type name during the base class constructor, the <code class="literal">name</code> property will still contain the name of the derived class, not the base class.</p><p>Moving on to our <code class="literal">MessagingSystem</code> class, we should define its features by what kind of requirements we need it to fulfill:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>It should be globally accessible</p></li><li style="list-style-type: disc"><p>Any object (<code class="literal">MonoBehaviour</code> or not) should be able to register/deregister as listeners, to receive specific message types (that is, the Observer pattern)</p></li><li style="list-style-type: disc"><p>Registering objects should provide a method to call when the given message is broadcast</p></li><li style="list-style-type: disc"><p>The system should send the message to all listeners within a reasonable timeframe, but not choke on too many requests at once</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec22"></a>A globally accessible object</h4></div></div></div><p>The first requirement makes the messaging system an excellent candidate for a Singleton object, since<a id="id1281" class="indexterm"></a> we should only ever need one instance of the system. Although, it is wise to think long and hard if this is truly the case before committing to implementing a Singleton. If we later decide that we want multiple instances of this object to exist, then it can be difficult to refactor due to all of the dependencies we will gradually introduce to our codebase as we use the system more and more.</p><p>For this example, we will assume that we are absolutely positive that we will only need one of these systems, and design it accordingly.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec23"></a>Registration</h4></div></div></div><p>Meeting the second and third requirements can be achieved by offering some public methods that allow registration with the messaging system. If we force the listening object to provide<a id="id1282" class="indexterm"></a> us a delegate function to call when the message is broadcast, then this allows listeners to customize which method is called for which message. This can make our codebase much easier to understand, if we name the delegate after the message it is intended to process.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip30"></a>Tip</h3><p>Delegate functions are incredibly useful constructs in C# that allows us to pass local methods around as arguments to other methods, and are typically used for callbacks. Check the<a id="id1283" class="indexterm"></a> MSDN C# Programming Guide for more information on delegates at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms173171.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/ms173171.aspx</a>.</p></div><p>In some cases, we might wish to broadcast a general notification message and have all listeners do something in response, such as an "<span class="emphasis"><em>Enemy Spawned</em></span>" message. Other times, we might be sending a message that specifically targets a single listener amongst a group. For example, we might wish to send an "<span class="emphasis"><em>Enemy Health Value Changed</em></span>" message that is intended for a specific health bar object that is attached to the enemy that was damaged. If we implement a way for listeners to stop message processing early, then we can save a significant number of CPU cycles, if there are many listeners waiting for the same message type.</p><p>The delegate we define should therefore provide a way of retrieving the message via an argument, and return a response that determines whether or not processing for the message should stop when the listener is done with it. The decision on whether to stop processing or not can be achieved by returning a simple Boolean, where <code class="literal">true</code> implies that this listener has handled the message, and processing for the message must stop.</p><p>Here is the definition for the delegate:</p><div class="informalexample"><pre class="programlisting">public delegate bool MessageHandlerDelegate(BaseMessage message);</pre></div><p>Listeners must define a method of this form and pass a reference to it when it registers with the <code class="literal">MessagingSystem</code>, thus providing an entry point for the messaging system to call when the message is broadcast.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec24"></a>Message processing</h4></div></div></div><p>The final<a id="id1284" class="indexterm"></a> requirement for our messaging system is that this object has some kind of timing-based mechanism built in to prevent it from choking on too many messages at once. This means that, somewhere in the process, we will need to make use of <code class="literal">MonoBehaviour</code> event callbacks in order to work during Unity's <code class="literal">Update()</code> and be able to count time.</p><p>This can be achieved with the <code class="literal">static</code> class-based Singleton (which we defined earlier), which would require some other <code class="literal">MonoBehaviour</code>-based god class to call into it, informing it that the Scene has updated. Alternatively, we can use the <code class="literal">SingletonAsComponent</code> to achieve the same thing, but do so independently of any god class. The only difference between the two is whether or not the system is dependent on the control of other objects.</p><p>The <code class="literal">SingletonAsComponent</code> approach is probably the best, since there aren't too many occasions where we wouldn't want this system acting independently, even if much of our game logic depends upon it. For example, even if the game was paused, we wouldn't want the game logic to pause our messaging system. We still want the messaging system to continue receiving and processing messages so that we can, for example, keep UI-related Components communicating with one another while the gameplay is in a paused state.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec25"></a>Implementing the messaging system</h4></div></div></div><p>Let's define our <a id="id1285" class="indexterm"></a>messaging system by deriving from the <code class="literal">SingletonAsComponent</code> class, and provide a method for objects to register with it:</p><div class="informalexample"><pre class="programlisting">using System.Collections.Generic;

public class MessagingSystem : SingletonAsComponent&lt;MessagingSystem&gt; {

  public static MessagingSystem Instance {
    get { return ((MessagingSystem)_Instance); }
    set { _Instance = value; }
  }

  private Dictionary&lt;string,List&lt;MessageHandlerDelegate&gt;&gt; _listenerDict = new Dictionary&lt;string,List&lt;MessageHandlerDelegate&gt;&gt;();

  public bool AttachListener(System.Type type, MessageHandlerDelegate handler) {
    if (type == null) {
      Debug.Log("MessagingSystem: AttachListener failed due to no message type specified");
      return false;
    }

    string msgName = type.Name;

    if (!_listenerDict.ContainsKey(msgName)) {
      _listenerDict.Add(msgName, new List&lt;MessageHandlerDelegate&gt;());
    }

    List&lt;MessageHandlerDelegate&gt; listenerList = _listenerDict[msgName];
    if (listenerList.Contains(handler)) {
      return false; // listener already in list
    }

    listenerList.Add(handler);
    return true;
  }
}</pre></div><p>The _<code class="literal">listenerDict</code> variable is a dictionary of strings mapped to lists of <code class="literal">MessageHandlerDelegates</code>. This dictionary organizes our listener delegates into lists by which message type they wish to listen to. Thus, if we know what message type is being sent, then we can quickly retrieve a list of all delegates that have been registered for that message<a id="id1286" class="indexterm"></a> type. We can then iterate through the list, querying each listener to see if one of them wants to handle it.</p><p>The <code class="literal">AttachListener()</code> method requires two parameters; a message type in the form of a <code class="literal">System.Type</code>, and a <code class="literal">MessageHandlerDelegate</code> to send the message to when it comes through the system.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec26"></a>Message queuing and processing</h4></div></div></div><p>In order to<a id="id1287" class="indexterm"></a> process messages, our <code class="literal">MessagingSystem</code> should <a id="id1288" class="indexterm"></a>maintain a queue of incoming message objects so that we can process them in the order they are broadcasted:</p><div class="informalexample"><pre class="programlisting">private Queue&lt;BaseMessage&gt; _messageQueue = new Queue&lt;BaseMessage&gt;();

public bool QueueMessage(BaseMessage msg) {
  if (!_listenerDict.ContainsKey(msg.name)) {
    return false;
  }
  _messageQueue.Enqueue(msg);
  return true;
}</pre></div><p>The method simply checks if the given message type is present in our dictionary before adding it to the queue. This effectively tests whether or not an object actually cares to listen to the message before we queue it to be processed later. We have introduced a new <code class="literal">private</code> member variable, _<code class="literal">messageQueue</code>, for this purpose.</p><p>Next, we'll add a definition for <code class="literal">Update()</code>. This method will be called regularly by the Unity Engine. Its purpose is to iterate through the current contents of the message queue, one message<a id="id1289" class="indexterm"></a> a time, verify whether or not too much time has<a id="id1290" class="indexterm"></a> passed since we began processing, and if not, pass them along to the next stage in the process:</p><div class="informalexample"><pre class="programlisting">private float maxQueueProcessingTime = 0.16667f;

void Update() {
  float timer = 0.0f;
  while (_messageQueue.Count &gt; 0) {
    if (maxQueueProcessingTime &gt; 0.0f) {
      if (timer &gt; maxQueueProcessingTime)
        return;
    }

    BaseMessage msg = _messageQueue.Dequeue();
    if (!TriggerMessage(msg))
      Debug.Log("Error when processing message: " + msg.name);

    if (maxQueueProcessingTime &gt; 0.0f)
      timer += Time.deltaTime;
  }
}</pre></div><p>The time-based safeguard is in place to make sure that it does not exceed a processing time limit threshold. This prevents the messaging system from freezing our game if too many messages get pushed through the system too quickly. If the total time limit is exceeded, then all message processing will stop, leaving any remaining messages to be processed during the next frame.</p><p>Lastly, we need to define the <code class="literal">TriggerMessage()</code> method, which distributes messages to listeners:</p><div class="informalexample"><pre class="programlisting">public bool TriggerMessage(BaseMessage msg) {
  string msgName = msg.name;
  if (!_listenerDict.ContainsKey(msgName)) {
    Debug.Log("MessagingSystem: Message \"" + msgName + "\" has no listeners!");
    return false; // no listeners for message so ignore it
  }

  List&lt;MessageHandlerDelegate&gt; listenerList = _listenerDict[msgName];

  for(int i = 0; i &lt; listenerList.Count; ++i) {
    if (listenerList[i](msg))
      return true; // message consumed by the delegate
  }
  return true;
}</pre></div><p>This method is the main workhorse of the messaging system. The <code class="literal">TriggerEvent()</code>'s purpose is to<a id="id1291" class="indexterm"></a> obtain the list of listeners for the given message type and give each of them an opportunity<a id="id1292" class="indexterm"></a> to process it. If one of the delegates returns <code class="literal">true</code>, then processing of the current message ceases and the method exits, allowing the <code class="literal">Update()</code> method to process the next message.</p><p>Normally, we would want to use <code class="literal">QueueEvent()</code> to broadcast messages, but <code class="literal">TriggerEvent()</code> can be called instead. This method allows message senders to force their messages to be processed immediately without waiting for the next <code class="literal">Update()</code> event. This bypasses the throttling mechanism, but this might be necessary for messages that need to be sent during critical moments in gameplay, where waiting one additional frame might result in strange-looking behavior.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec27"></a>Implementing a custom message</h4></div></div></div><p>We've created the<a id="id1293" class="indexterm"></a> messaging system, but an example of how to use it would help us wrap our heads around the concept. Let's start by defining a simple message class, which we can use to transmit some data:</p><div class="informalexample"><pre class="programlisting">public class MyCustomMessage : BaseMessage {
  public readonly int _intValue;
  public readonly float _floatValue;
  public MyCustomMessage(int intVal, float floatVal {
    _intValue = intVal;
    _floatValue = floatVal;
  }
}</pre></div><p>Good practice for message objects is to make their member variables <code class="literal">readonly</code>. This ensures that the data cannot be changed after the object's construction. This safeguards the content of our messages against being altered, as they're passed between one listener and another.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec28"></a>Message registration</h4></div></div></div><p>Here's a simple <a id="id1294" class="indexterm"></a>class that registers with the messaging system, requesting to have its <code class="literal">HandleMyCustomMessage()</code> method called whenever a <code class="literal">MyCustomMessage</code> object is broadcast from anywhere in our codebase:</p><div class="informalexample"><pre class="programlisting">public class TestMessageListener : MonoBehaviour {

  void Start() {
    MessagingSystem.Instance.AttachListener(typeof(MyCustomMessage), this.HandleMyCustomMessage);
  }

  bool HandleMyCustomMessage(BaseMessage msg) {
    MyCustomMessage castMsg = msg as MyCustomMessage;
    Debug.Log (string.Format("Got the message! {0}, {1}", castMsg._intValue, castMsg._floatValue));
    return true;
  }
}</pre></div><p>Whenever a <code class="literal">MyCustomMessage</code> object is broadcast (from anywhere!), this listener will retrieve the message through its <code class="literal">HandleMyCustomMessage()</code> method. It can then typecast it into the appropriate derived message type and handle the message in its own unique way. Other classes can register for the same message, and handle it differently through its own custom delegate method (assuming an earlier object didn't return <code class="literal">true</code> from its own delegate).</p><p>We know what type of message will be provided by the <code class="literal">msg</code> argument of the <code class="literal">HandleMyCustomMessage()</code> method, because we defined it during registration through the <code class="literal">AttachListener()</code> call. Due to this, we can be certain that our typecasting is safe, and we can save time by not having to do a <code class="literal">null</code> reference check, although, technically, there is nothing stopping us using the same delegate to handle multiple message types! In these cases, though we would need to implement a way of determining which message object is being passed, and treat it accordingly. The best approach is to define a unique method for each message type in order to keep things appropriately decoupled.</p><p>Note how the <code class="literal">HandleMyCustomMessage</code> method definition matches the function signature of <code class="literal">MessageHandlerDelegate</code>, and that it is being referenced in the <code class="literal">AttachListener()</code> call. This is how we tell the messaging system what method to call when the given message type is broadcast, and how delegates ensure type safety. If the function signature had a different return value or a different list of arguments, then it would be an invalid delegate for the <code class="literal">AttachListener()</code> method, and we would get compiler errors.</p><p>The beautiful part is that we're free to give the delegate method whatever name we want. The most sensible approach is to name the method after the message which it handles. This makes it clear to anyone reading our code what the method is used for and what message object<a id="id1295" class="indexterm"></a> type is required to call it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec29"></a>Message sending</h4></div></div></div><p>Finally, let's implement an<a id="id1296" class="indexterm"></a> example of sending a message so that we can test this system out! Here's a component that will broadcast an instance of our <code class="literal">MyCustomMessage</code> class through the messaging system when the <span class="emphasis"><em>Space Bar</em></span> is pressed:</p><div class="informalexample"><pre class="programlisting">public class TestMessageSender : MonoBehaviour {

  public void Update() {
    if (Input.GetKeyDown (KeyCode.Space)) {
      MessagingSystem.Instance.QueueMessage(new MyCustomMessage(5, 13.355f));
    }
  }
}</pre></div><p>If we add both the <code class="literal">TestMessageSender</code> and <code class="literal">TestMessageListener</code> objects to our Scene and press the <span class="emphasis"><em>Space bar</em></span>, we should see a log message appear in the console, informing us of a successful test:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_02_07.jpg" /></div><p>Our <code class="literal">MessagingSystem</code> Singleton object will be created immediately upon Scene initialization, when the <code class="literal">TestMessageListener</code>'s <code class="literal">Start()</code> method is called and it registers the <code class="literal">HandleMyCustomMessage</code> delegate. No additional effort is required on our part to create the Singleton we need.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec30"></a>Message cleanup</h4></div></div></div><p>Since message objects are <a id="id1297" class="indexterm"></a>classes, they will be created dynamically in heap memory and will be disposed of shortly afterwards when the message has been processed and distributed amongst all listeners. However, as you will learn in <a class="link" href="#" linkend="ch31">Chapter 7</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>, this will eventually result in a garbage collection as heap memory accumulates over time. If our application runs for long enough, it will eventually result in the occasional garbage collection. Therefore, it is wise to use the messaging system sparingly and avoid spamming messages too frequently on every update.</p><p>The more important clean-up operation to consider is deregistration of delegates if an object needs to be destroyed or de-spawned. If we don't handle this properly, then the messaging system will hang on to delegate references that prevent objects from being fully destroyed and freed from memory.</p><p>Essentially, we <a id="id1298" class="indexterm"></a>need to pair every <code class="literal">AttachListener()</code> call with an appropriate <code class="literal">DetachListener()</code> method when the object is destroyed, disabled, or we otherwise decide that we no longer need it to be queried when messages are being sent.</p><p>The following method definition in the <code class="literal">MessagingSystem</code> class will detach a listener for a specific event:</p><div class="informalexample"><pre class="programlisting">public bool DetachListener(System.Type type, MessageHandlerDelegate handler)
  {
    if (type == null) {
      Debug.Log("MessagingSystem: DetachListener failed due to no message type specified");
      return false;
    }

    string msgName = type.Name;

    if (!_listenerDict.ContainsKey(type.Name)) {
      return false;
    }

    List&lt;MessageHandlerDelegate&gt; listenerList = _listenerDict[msgName];
    if (!listenerList.Contains (handler)) {
      return false;
    }

    listenerList.Remove(handler);
    return true;
  }</pre></div><p>Here is an example usage of the <code class="literal">DetachListener()</code> method, added to our <code class="literal">TestMessageListener</code> class:</p><div class="informalexample"><pre class="programlisting">void OnDestroy() {
  if (MessagingSystem.IsAlive) {
    MessagingSystem.Instance.DetachListener(typeof(MyCustomMessage), this.HandleMyCustomMessage);
  }
}</pre></div><p>Note how this definition makes use of the <code class="literal">IsAlive</code> property<a id="id1299" class="indexterm"></a> declared in the <code class="literal">SingletonAsComponent</code> class. This safeguards us against the aforementioned problems during application shutdown, where <a id="id1300" class="indexterm"></a>we cannot guarantee that the Singleton was destroyed last.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch26lvl3sec31"></a>Wrapping up the messaging system</h4></div></div></div><p>Congratulations are in<a id="id1301" class="indexterm"></a> order, as we have finally built a fully functional global messaging system that any and all objects can interface with, to send messages between one another! A useful feature of this approach is that it is MonoBehaviour-agnostic, meaning that the message senders and listeners do not even need to derive from <code class="literal">MonoBehaviour</code> to interface with the messaging system; it just needs to be a class that provides a message type and a delegate function of the matching function signature.</p><p>As far as benchmarking the <code class="literal">MessagingSystem</code> class goes, we should find that if it is capable of processing hundreds, if not thousands of messages in a single frame with minimal CPU overhead (depending on the CPU, of course). The CPU usage is essentially the same whether one message is being distributed to 100 different listeners, 100 messages are distributed to just one listener. It costs about the same either way.</p><p>Even if we're predominantly sending messages during UI or gameplay events, this is probably far more power than we need. So, if it does seem to be causing performance problems, then it's far more likely to be caused by what the listener delegates are <span class="emphasis"><em>doing</em></span> with the message than the messaging system's ability to process those messages.</p><p>There are many ways to enhance the messaging system to provide more useful features we may need in the future, such as:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Allow message senders to suggest a delay (in time or frame count) before a message is processed and distributed</p></li><li style="list-style-type: disc"><p>Allow message listeners to define a priority for how urgently it should receive messages compared to other listeners waiting for the same message typeâ€”a way of skipping to the front of the queue if it registered later than other listeners</p></li><li style="list-style-type: disc"><p>Implement some safety checks to handle situations where a listener gets added to the list of message listeners for a particular message, while a message of that type is still being processedâ€”C# will throw an enumeration exception at us since the delegate list will be changed by <code class="literal">AttachListener()</code>,while it is still being iterated through in <code class="literal">TriggerEvent()</code></p></li></ul></div><p>At this point, we have probably explored messaging systems enough, so these tasks will be left as an academic exercise for you to undertake, if you become comfortable using this solution in your games.</p><p>Let's explore<a id="id1302" class="indexterm"></a> some further techniques that we can use to improve performance through scripting.</p></div></div></div>