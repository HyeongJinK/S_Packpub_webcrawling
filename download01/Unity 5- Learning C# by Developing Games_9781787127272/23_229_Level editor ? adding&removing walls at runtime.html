<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch23lvl1sec212"></a>Level editor â€“ adding/removing walls at runtime</h2></div></div><hr /></div><p>Now that our <a id="id1082" class="indexterm"></a>level editor<a id="id1083" class="indexterm"></a> will be able to load in this data, we now want to have a way to actually modify what we see onscreen. To do this, we'll need to create a GUI interface and functionality for our level editor.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The first thing we need to do is add a variable to keep track of what item we want to spawn:</p><div class="informalexample"><pre class="programlisting">// The object we are currently looking to spawn
private Transform toCreate;</pre></div></li><li><p>Now, we need to initialize this variable inside our <code class="literal">Start</code> function:</p><div class="informalexample"><pre class="programlisting">toCreate = tiles[0];</pre></div></li><li><p>Next, we need to <a id="id1084" class="indexterm"></a>update <a id="id1085" class="indexterm"></a>our <code class="literal">Update</code> function and then explain how it's working, as follows:</p><div class="informalexample"><pre class="programlisting">    void Update()
    {
        // Left click - Create object
        if (Input.GetMouseButton(0) &amp;&amp; GUIUtility.hotControl == 0)
        {
            Vector3 mousePos = Input.mousePosition;

/*
Set the position in the z axis to the
opposite of the camera's so that the position is on the world so ScreenToWorldPoint will give us valid
values.
*/
            mousePos.z = Camera.main.transform.position.z * -1;

            Vector3 pos = Camera.main.ScreenToWorldPoint(mousePos);

            // Deal with the mouse being not exactly on a 
            // block
            int posX = Mathf.FloorToInt(pos.x + .5f);
            int posY = Mathf.FloorToInt(pos.y + .5f);

            Collider[] hitColliders = Physics.OverlapSphere(pos, 0.45f);
            int i = 0;
            while (i &lt; hitColliders.Length)
            {
                if (toCreate.name != hitColliders[i].gameObject.name)
                {
                    DestroyImmediate(hitColliders[i].gameObject);
                }
                else
                {
                    // Already exists, no need to create 
                    // another
                    return;
                }
                i++;
            }

            CreateBlock(tiles.IndexOf(toCreate) + 1, posX, posY);
            
        }

        // Right clicking - Delete object
        if (Input.GetMouseButton(1) &amp;&amp; GUIUtility.hotControl == 0)
        {
            Ray ray = 
            Camera.main.ScreenPointToRay(Input.mousePosition);

            RaycastHit hit = new RaycastHit();

            Physics.Raycast(ray, out hit, 100);

            // If we hit something other than the player
            // we want to destroy it!
            if ((hit.collider != null) &amp;&amp; (hit.collider.name != "Player"))
            {
                Destroy(hit.collider.gameObject);
            }
        }

    }</pre></div><p>You'll note that <a id="id1086" class="indexterm"></a>we used <a id="id1087" class="indexterm"></a>something named <code class="literal">hotControl</code> when we were checking for input. The reason we did this was that whenever a player holds down a mouse button, it becomes "<span class="strong"><strong>hot.</strong></span>" No other controls are allowed to respond to mouse events while some control is "<span class="strong"><strong>hot.</strong></span>"</p><p>Once the user releases their mouse, <code class="literal">hotControl</code> gets set to <code class="literal">0</code> to indicate that other controls can respond to user input, which will be useful when we implement our GUI system, as we don't want to draw something when we're clicking on our mouse button.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note116"></a>Note</h3><p>For more information on <a id="id1088" class="indexterm"></a>
<code class="literal">GUIUtility.hotControl</code>, check out <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GUIUtility-hotControl.html" target="_blank">http://docs.unity3d.com/ScriptReference/GUIUtility-hotControl.html</a>.</p></div><p>A lot of the stuff <a id="id1089" class="indexterm"></a>contained in <a id="id1090" class="indexterm"></a>this code is from reusing a lot of the aspects you learned earlier in the book, back when we did our platformer game. Yet, now we are using the same functions to work with the mouse position in the world and converting it to world space.</p><p>We use the <code class="literal">ScreenToWorldPoint</code> function to convert our mouse position from screenspace into world space with the Z position of the point being the units away from the camera we want the position to be. Because our world is at 0, we want the Z to be negative whatever the camera's Z position is.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note117"></a>Note</h3><p>For more information on <a id="id1091" class="indexterm"></a>
<code class="literal">ScreenToWorldPoint</code> check out <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html" target="_blank">http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html</a>.</p></div><p>We use this information to get the position we want to place the block at. Once we have this, we can just call <code class="literal">Instantiate</code> and create something, but we also need to make sure that we only have one object per tile, so we will use a raycast to determine if that area already has a block, and if it does, we will destroy it:</p></li><li><p>Now that we have all this set, let's save the file and then exit back to the Unity editor and play the game.</p></li><li><p>If you select the <span class="strong"><strong>GameController</strong></span> object, you'll note that the checkbox next to the <span class="strong"><strong>LevelEditor</strong></span> component is unchecked. This is because we disabled it in the <code class="literal">Start</code> function. We will enable it again in code later, but just for demonstration<a id="id1092" class="indexterm"></a> purposes, click <a id="id1093" class="indexterm"></a>on the checkbox to activate it once again. Then, in the <span class="strong"><strong>Game </strong></span>tab, click on the screen and <span class="emphasis"><em>right-click</em></span> on areas in the level. Take a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/B05212_10_02.jpg" /></div></li></ol></div><p>You'll note that now we can draw walls anywhere within our scene and delete anything aside from our player!</p></div>