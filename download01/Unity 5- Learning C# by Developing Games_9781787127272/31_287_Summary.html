<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch31lvl1sec262"></a>Summary</h2></div></div><hr /></div><p>We've covered a humungous amount of theory and language concepts in this chapter, which have hopefully shed some light on how the internals of the Unity Engine and C# language work. These tools try their best to spare us from the burden of complex memory management, but there is still a whole host of concerns we need to keep in mind as we develop our game. Between the compilation processes, multiple memory domains, the complexities of Value types versus Reference types, passing by value versus passing by reference, boxing, object pooling, and various quirks within the Unity API, we have a lot of things to worry about. But, with enough practice, we will learn to overcome them without needing to keep referring to giant tomes such as this!</p><p>This chapter effectively concludes all of the techniques we can bestow that explicitly aim to improve application performance. Workflow optimizations are always useful things to keep in mind, however, as there are a lot of neat little nuances to the Unity Engine that aren't well known or clearly documented, and that only become apparent through experience and community involvement. As such, the next chapter will be full of hints and tips for improving how to manage our project and Scenes more effectively, how to make the most of the Editor, and hopefully save ourselves enough development time to actually implement all of the optimization techniques we've talked about through this entire book.</p></div>