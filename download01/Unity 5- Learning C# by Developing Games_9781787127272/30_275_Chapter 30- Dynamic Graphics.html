<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch30"></a>Chapter 6. Dynamic Graphics</h2></div></div></div><p>There is no question that the rendering system of modern graphics devices is complicated. Even rendering a single triangle to the screen engages many of these components, since GPUs are designed for large amounts of parallelism, as opposed to CPUs, which are designed to handle virtually any computational scenario. Modern graphics rendering is a high-speed dance of processing and memory management that spans software, hardware, multiple memory spaces, multiple languages, multiple processors, multiple processor types, and a large number of special-case features that can be thrown into the mix.</p><p>To make matters worse, every graphics situation we will come across is different in its own way. Running the same application against a different device, even by the same manufacturer, often results in an apples-versus-oranges comparison due to the different capabilities and functionality they provide. It can be difficult to determine where a bottleneck resides within such a complex chain of devices and systems, and it can take a lifetime of industry work in 3D graphics to have a strong intuition about the source of performance issues in modern graphics systems.</p><p>Thankfully, Profiling comes to the rescue once again. If we can gather data about each component, use multiple performance metrics for comparison, and tweak our Scenes to see how different graphics features affect their behavior, then we should have sufficient evidence to find the root cause of the issue and make appropriate changes. So in this chapter, you will learn how to gather the right data, dig just deep enough into the graphics system to find the true source of the problem, and explore various solutions to work around a given problem.</p><p>As you learned in earlier chapters, the CPU and GPU work in tandem to determine what textures, meshes, render states, Shaders, and so on, are needed to render our Scenes at any given moment. We've also covered several techniques to reduce some of the rendering workload through Static and Dynamic Batching, and by manipulating our mesh and texture files through compression and encoding, Mip Mapping, Atlasing, and even some procedural alternatives.</p><p>However, there are still many more topics to cover when it comes to improving rendering performance, so in this chapter we will begin with some general techniques on how to determine whether our rendering is limited by the CPU or by the GPU, and what we can do about either case. We will discuss optimization techniques such as Occlusion Culling and <span class="strong"><strong>Level Of Detail</strong></span> (<span class="strong"><strong>LOD</strong></span>) and provide some<a id="id1534" class="indexterm"></a> useful advice on Shader optimization, as well as large-scale rendering features such as lighting and shadows. Finally, since mobile devices are a common target for Unity projects, we will also cover some techniques that may help improve performance on limited hardware.</p></div>