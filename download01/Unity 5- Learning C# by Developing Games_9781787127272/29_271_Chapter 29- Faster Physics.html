<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch29"></a>Chapter 5. Faster Physics</h2></div></div></div><p>Each of the performance-enhancing suggestions we've explored thus far have been primarily centered on reducing system requirements and avoiding frame rate issues. But at its most fundamental level, seeking peak performance means improving the user experience. This is because every frame rate hiccup, every crash, and every system requirement that is too costly for a given market ultimately detracts from the quality of the product, and leaves us wondering whether we should have tried harder to tweak settings and fix more bugs before release.</p><p>There are certainly opportunities to manipulate Physics Engine behavior that improve all of the aforementioned issues, but Physics Engines also fall into a unique category of having a direct impact on gameplay quality. If important gameplay collision events get missed (such as the player falling through the floor), or the game freezes while it calculates a complex situation, then these have a significant impact on gameplay quality. This often results in pulling the player out of the experience, and it's a coin-toss whether the user finds it inconvenient, obnoxious, or hilarious. Unless our game is specifically targeting the Comedy <a id="id1441" class="indexterm"></a>Physics genre (which, incidentally, has grown in popularity in recent years with games like QWOP and Goat Simulator), these are situations we should strive to avoid.</p><p>For some games, the Physics Engine is used to handle a significant number of tasks during gameplay, from collision <a id="id1442" class="indexterm"></a>detection with other objects and invisible trigger boxes to raycasting and gathering a list of objects in a given region. For example, it is essential in platformer and action games to tune the physics properly; how the player character reacts to input and how the world reacts to the player character can be two of the most important aspects of what makes the game feel responsive and fun. Other games may only use physics for simple gameplay events, interesting spectacles, and other eye-candy, but the more efficiently the Physics System is used, the more of a spectacle that can be created.</p><p>Therefore, in this chapter, we will not only cover ways to reduce CPU spikes, overhead, and memory consumption through Unity's Physics System, but also include ways to alter physics behavior with the aim of improving gameplay quality. In addition, because Unity's Physics Systems<a id="id1443" class="indexterm"></a> are a "black-box", in that we can't do much internal debugging, it can be very tricky to figure out exactly when, where, and why certain physics glitches are plaguing our project, and what we should do to prevent them. As a result, the methods covered in this chapter will include several suggestions on how to reduce instability and problematic physics situations.</p></div>