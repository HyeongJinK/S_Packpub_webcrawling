<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch22lvl1sec204"></a>Enemy movement</h2></div></div><hr /></div><p>As spooky as the character is, right now, it is just a static mesh. It will not come to us to damage us, and we cannot damage it. Let's fix that next using the state machines you've just<a id="id1031" class="indexterm"></a> learned about! Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new script named <code class="literal">EnemyBehaviour</code>.</p><p>We want our enemy to follow the player if they get too close to them; however, they will stay where they are if the player gets far enough away. Finally, if, for some reason, we defeat the enemy, they should no longer run this behavior, and we should kill them. The first step to creating a state machine is to extract the states that the object can be in. In this case, we have three states: <code class="literal">Idle</code>, <code class="literal">Following</code>, and <code class="literal">Death</code>. Just as we discussed in <a class="link" href="#" linkend="ch15">Chapter 2</a>, <span class="emphasis"><em>Creating GUIs</em></span>, using an enumeration is the best tool for the job here as well.</p></li><li><p>Add the following code to the top of the <code class="literal">EnemyBehaviour</code> class:</p><div class="informalexample"><pre class="programlisting">   public enum State 
  {
    Idle,
    Follow,
    Die,
  }

   // The current state the player is in
  public State state;</pre></div><p>Now, depending on the value that the state is currently in, we can do different things. We could use something like the following code:</p><div class="informalexample"><pre class="programlisting">void Update()
{
    if(state == State.Idle)
    {
        //And so on
    }
    else if(state == State.Follow)
    {
        //And so on
    }
    //etc...
}</pre></div><p>But, as I'm sure<a id="id1032" class="indexterm"></a> you can already see, this is incredibly messy. Also, what if we want to do something when we first enter the state? What about when you leave? To fix this issue, let's use a tool we covered earlier, the coroutine function, which will contain the contents for each of our states.</p></li><li><p>Next, we need to add in some additional variables we will use. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">   // The object the enemy wants to follow
  public Transform target; 

  // How fast should the enemy move?
  public float moveSpeed = 3.0f;
  public float rotateSpeed = 3.0f;

  // How close should the enemy be before they follow?
  public float followRange = 10.0f;

  // How far should the target be before the enemy gives up 
   // following? 
  // Note: Needs to be &gt;= followRange
  public float idleRange = 10.0f;</pre></div></li><li><p>Now, we need to add in a coroutine function for each of the possible states, starting with the <code class="literal">Idle</code> state. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">  IEnumerator IdleState () 
  {
    //OnEnter
    Debug.Log("Idle: Enter");
    while (state == State.Idle) 
    {
      //OnUpdate
      if(GetDistance() &lt; followRange)
      {
        state = State.Follow;
      }

      yield return 0;
    }
    //OnEnd
    Debug.Log("Idle: Exit");
    GoToNextState();
  }</pre></div><p>This state will<a id="id1033" class="indexterm"></a> continuously check whether the players are close enough to the target to start following it until its state is no longer <code class="literal">State.Idle</code>. You'll note the two functions we'll need to create later, <code class="literal">GetDistance</code> and <code class="literal">GoToNextState</code>, which we will implement after we finish the other states.</p></li><li><p>Continue with the <code class="literal">Following</code> state, as follows:</p><div class="informalexample"><pre class="programlisting">  IEnumerator FollowState () 
  {
    Debug.Log("Follow: Enter");
    while (state == State.Follow) 
    {
      transform.position = Vector3.MoveTowards(transform.position,
                    target.position, 
                    Time.deltaTime * moveSpeed);

      RotateTowardsTarget();

      if(GetDistance() &gt; idleRange)
      {
        state = State.Idle;
      }

      yield return 0;
    }
    Debug.Log("Follow: Exit");
    GoToNextState();
  }</pre></div><p>This state will move the enemy closer to the player while continuously checking if the target is far enough to go back to <code class="literal">Idle</code>. In addition to the other functions we talked about earlier, we also have a new function named <code class="literal">RotateTowardsTarget</code>, which we will also need to add in.</p></li><li><p>Finish off by<a id="id1034" class="indexterm"></a> adding in the <code class="literal">Die</code> state, as follows:</p><div class="informalexample"><pre class="programlisting">  IEnumerator DieState () 
  {
    Debug.Log("Die: Enter");

    Destroy (this.gameObject);
    yield return 0;
  }</pre></div><p>This state just destroys the object attached to it. Right now, there is no way to get here aside from us setting it in the <span class="strong"><strong>Inspector</strong></span> tab, but it will be useful when we add in damage.</p></li><li><p>Now, we need to add in those functions we talked about earlier. First, let's add in <code class="literal">GetDistance</code> and <code class="literal">RotateTowardsTarget</code>, which are self-explanatory in terms of what they do. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">    public float GetDistance()
  {
    return (transform.position - target.transform.position).magnitude;
  }

  private void RotateTowardsTarget()
  {
    transform.rotation = Quaternion.Slerp(transform.rotation,Quaternion.LookRotation(target.position - 
                           transform.position), 
                           rotateSpeed * Time.deltaTime);
  }</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note109"></a>Note</h3><p>The <code class="literal">Vector3</code> class also has a <code class="literal">Distance</code> function you can use. <code class="literal">Vector3.Distance(transform.position, target.transform.position);</code> will do the same thing as our <code class="literal">GetDistance</code> function does, but knowing the math behind things can be extremely helpful!</p></div></li><li><p>Now, we need to add in the ability to go to another state, as follows:</p><div class="informalexample"><pre class="programlisting">   void GoToNextState () 
  {
    // Find out the name of the function we want to call
    string methodName = state.ToString() + "State";

    // Searches this class for a function with the name of 
    // state + State (for example: idleState)
    System.Reflection.MethodInfo info = GetType().GetMethod(methodName, System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
    StartCoroutine((IEnumerator)info.Invoke(this, null));
  }</pre></div><p>The preceding <a id="id1035" class="indexterm"></a>code is fairly advanced stuff, so it's okay if you do not fully understand it at a glance. For the preceding code, I could have written something like the <code class="literal">Update</code> example I wrote previously, calling the appropriate coroutine based on the state to go to.</p><p>Instead, this code will call the appropriate function with the name of the state plus the word <code class="literal">State</code>. The nice thing about this is that you can now write as many additional states as you want without having to modify this function. All you have to do is add an item to the <code class="literal">State</code> enumerator and then write a function for it with a proper name!</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note110"></a>Note</h3><p>For information on the <code class="literal">GetMethod</code> function and the different kinds of <code class="literal">BindingFlags</code>, you can visit <a class="ulink" href="http://msdn.microsoft.com/en-us/library/05eey4y9(v=vs.110).aspx" target="_blank">http://msdn.microsoft.com/en-us/library/05eey4y9(v=vs.110).aspx</a>.</p></div></li><li><p>Then, we need to start this whole state machine up with the following code:</p><div class="informalexample"><pre class="programlisting">void Start () 
{
  GoToNextState();
}</pre></div></li><li><p>Finally, we need to save our file and exit back to the Unity Editor. Attach the <span class="strong"><strong>Enemy Behaviour</strong></span> script to our <span class="strong"><strong>Ghost_mesh</strong></span> object and set the <span class="strong"><strong>Target</strong></span> property to <a id="id1036" class="indexterm"></a>our <span class="strong"><strong>FPSController</strong></span> object. Take a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/B05212_09_19.jpg" /></div></li><li><p>Save the scene and play the game. Take a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/B05212_09_20.jpg" /></div></li></ol></div><p>As you can see <a id="id1037" class="indexterm"></a>now, you can follow the enemy's current state in the <span class="strong"><strong>Inspector</strong></span> tab, and they will turn and move towards you whenever you get too close!</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch22lvl2sec124"></a>Advanced FSMs</h3></div></div></div><p>This is a good introduction to <a id="id1038" class="indexterm"></a>state machines and what you can use them for, but there is a lot of additional information out there on their uses, such as an abstract version of a state <a id="id1039" class="indexterm"></a>machine at <a class="ulink" href="http://playmedusa.com/blog/a-finite-state-machine-in-c-for-unity3d/" target="_blank">http://playmedusa.com/blog/a-finite-state-machine-in-c-for-unity3d/</a>.</p><p>The <span class="strong"><strong>Asset Store</strong></span> also features Playmaker, which is a fairly popular commercial add-on that creates state machines with a visual editor, making it very easy to add in states. For more information on <a id="id1040" class="indexterm"></a>Playmaker, check out <a class="ulink" href="http://www.hutonggames.com/" target="_blank">http://www.hutonggames.com/</a>.</p></div></div>