<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch26lvl1sec236"></a>Update, Coroutines, and InvokeRepeating</h2></div></div><hr /></div><p>Update is called every<a id="id1318" class="indexterm"></a> frame, but sometimes we hack in ways for the Update to be called less frequently than normal, and perhaps, without realizing it, we create a situation <a id="id1319" class="indexterm"></a>where an empty method is called more often than not:</p><div class="informalexample"><pre class="programlisting">void Update() {
  _timer += Time.deltaTime;
  if (_timer &gt; _aiUpdateFrequency) {
    ProcessAI();
    _timer -= _aiUpdateFrequency;
  }
}</pre></div><p>With this function definition, we are essentially calling an empty function almost every frame. In fact, it is worse than that; we're also performing a Boolean check that almost always returns <code class="literal">false</code>. This is fine if we don't abuse the concept, but as you've learned, having too many of these unnecessary function calls hiding in our Scene can be a sneaky hit on our performance.</p><p>This function is a perfect example of a function we can convert into a Coroutine to make use of their delayed-invocation properties:</p><div class="informalexample"><pre class="programlisting">void Start() {
  StartCoroutine(UpdateAI());
}

IEnumerator UpdateAI() {
  while (true) {
    yield return new WaitForSeconds(_aiUpdateFrequency);
    ProcessAI();
  }
}</pre></div><p>However, this approach has its drawbacks. For one, a Coroutine comes with an additional overhead cost relative to a standard function call (around twice as slow), as well as some heap memory allocations to store the current state in memory until the next time it is invoked. Secondly, once initialized, Coroutines run independent, of the GameObject's <code class="literal">Update()</code> process and will be invoked regardless of whether the GameObject has been disabled or not. Care must be taken before deciding to adopt this approach.</p><p>However, if the situation is appropriate, the benefits of calling nothing during most frames, often outweighs the additional cost during the frames where it is invoked. Indeed, if we aren't performing too <a id="id1320" class="indexterm"></a>many complex things with <code class="literal">yield</code> statements, then we can often create an even simpler version of the method using <code class="literal">InvokeRepeating()</code>, which has a slightly smaller overhead cost (about 1.5 times slower than a standard function call):</p><div class="informalexample"><pre class="programlisting">void Start() {
  InvokeRepeating("ProcessAI", 0f, _aiUpdateFrequency);
}</pre></div><p>Note that <code class="literal">InvokeRepeating</code> is also independent of the GameObject's <code class="literal">Update()</code> method, and will continue to be invoked even if the object is disabled.</p><p>Regardless of <a id="id1321" class="indexterm"></a>which approach we pick, there is an additional riskâ€”having too many methods triggering in the same frame simultaneously. Imagine thousands of these objects that initialized together during Scene initialization. Every time _<code class="literal">aiUpdateFrequency</code> seconds go by, they will all invoke the <code class="literal">ProcessAI()</code> method within the same frame, and cause a huge spike in CPU usage.</p><p>Possible solutions to this problem include:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Generating a new random time to wait each time the timer expires or Coroutine triggers</p></li><li style="list-style-type: disc"><p>Spread out Coroutine initialization so that only a handful of them are started each frame</p></li><li style="list-style-type: disc"><p>Delegate the responsibility of calling updates to some master class that places a limit on the number of invocations that occur each frame</p></li></ul></div><p>Reducing excessive Update definitions to a simple Coroutine can potentially save us a lot of unnecessary overhead, so we should consider converting them whenever we feel it is appropriate. However, we might also consider re-evaluating our solution to the original problem in order to prevent lots of timed events all triggering at the same moment.</p><p>Another approach to optimizing updates is to not use <code class="literal">Update()</code> at all, or more accurately, to only use it once. When Unity calls <code class="literal">Update()</code>, it involves bridging the gap between a GameObject's native and managed representation of the GameObject, which can be a costly task. You will learn more about this native-managed bridge in <a class="link" href="#" linkend="ch31">Chapter 7</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>, but for now, just consider that every callback we rely on Unity to invoke for us comes with a hidden processing cost attached relative to a standard function call.</p><p>We can therefore minimize this overhead by limiting how often it needs to cross the bridge. We can do this by having a god class take care of calling our own custom update-style method across all of our custom Components, in its own definition of <code class="literal">Update()</code>. In fact, many Unity developers prefer this approach right from the start of their projects, as it gives them finer control over when and how updates propagate throughout the system, for things such as menu pausing and cool time manipulation effects.</p><p>All objects wanting to integrate with such a system must have a common entry point. We can achieve this through an interface class. Interfaces essentially set up a contract whereby any class that implements the interface must provide a specific series of methods. In other words, if we know the object implements an interface, then we can be certain about what<a id="id1322" class="indexterm"></a> methods are available. In C#, classes can only derive from a single base class, but they can implement any number of interfaces (this avoids the "deadly diamond of death" problem that C++ programmers may be familiar with).</p><p>The following<a id="id1323" class="indexterm"></a> interface definition will suffice, which only requires the implementing class to define a single method:</p><div class="informalexample"><pre class="programlisting">public interface IUpdateable {
  void OnUpdate(float dt);
}</pre></div><p>Next, we'll define a <code class="literal">MonoBehaviour</code> class, which implements this interface:</p><div class="informalexample"><pre class="programlisting">public class UpdateableMonoBehaviour : MonoBehaviour, IUpdateable {
  public virtual void OnUpdate(float dt) {}
}</pre></div><p>Note that we're naming the method <code class="literal">OnUpdate()</code> rather than <code class="literal">Update()</code>. We're defining a custom version of the same concept, but we want to avoid name collisions with the standard <code class="literal">Update()</code> callback.</p><p>The <code class="literal">OnUpdate()</code> method of the <code class="literal">UpdateableMonoBehaviour</code> class retrieves the current delta time (<code class="literal">dt</code>), to spare us from a bunch of unnecessary <code class="literal">Time.deltaTime</code> calls. We've also made the function <code class="literal">virtual</code>, to allow derived classes to customize it. However, as you know, Unity automatically grabs and invokes methods defined with the name <code class="literal">Update()</code>, but since we're defining our own custom update with a different name, then we need to implement something that will call this method when the time is appropriate; some kind of "GameLogic" god class.</p><p>During the initialization of this Component, we should do something to notify our <code class="literal">GameLogic</code> object of both its existence and its destruction, so that it knows when to start and stop calling its <code class="literal">OnUpdate()</code> function.</p><p>In the following example, we will assume that our <code class="literal">GameLogic</code> class is a Singleton Component, as defined earlier in the section entitled <span class="emphasis"><em>Singleton Components</em></span>, and has appropriate static functions defined for registration and deregistration (although bear in mind that it can just as easily use our messaging system!).</p><p>For MonoBehaviours to hook into this system, the most appropriate place is within <code class="literal">Start()</code> and <code class="literal">OnDestroy()</code>:</p><div class="informalexample"><pre class="programlisting">void Start() {
  GameLogic.Instance.RegisterUpdateableObject(this);
}

void OnDestroy() {
  GameLogic.Instance.DeregisterUpdateableObject(this);
}</pre></div><p>It is best to use the <code class="literal">Start()</code> method for this task, since using <code class="literal">Start()</code> means that we can be certain all other pre-existing Components will have at least had their <code class="literal">Awake()</code> methods called prior to this moment. This way, any critical initialization work will have already been done on the <a id="id1324" class="indexterm"></a>object before we start invoking updates on it.</p><p>Note that, because we're using <code class="literal">Start()</code> in a <code class="literal">MonoBehaviour</code> base class, if we define a <code class="literal">Start()</code> method in a derived class, then it will effectively override the base-class definition and<a id="id1325" class="indexterm"></a> Unity will grab the derived <code class="literal">Start()</code> method as a callback instead. It would, therefore, be wise to implement a virtual <code class="literal">Initialize()</code> method so that derived classes can override it to customize initialization behavior without interfering with the base class's task of notifying the <code class="literal">GameLogic</code> object of our component's existence.</p><p>For example:</p><div class="informalexample"><pre class="programlisting">void Start() {
  GameLogic.Instance.RegisterUpdateableObject(this);
  Initialize();
}

protected virtual void Initialize() {
  // derived classes should override this method for initialization code
}</pre></div><p>We should try to make the process as automatic as possible to spare ourselves having to re-implement these tasks for each new Component we define. As soon as a class inherits from our <code class="literal">UpdateableMonoBehaviour</code> class, then should be secure in the knowledge that its <code class="literal">OnUpdate()</code> method will be called whenever it is appropriate.</p><p>Finally, we need to implement the <code class="literal">GameLogic</code> class. The implementation is pretty much the same whether it is a Singleton Component or a standalone Component, and whether or not it uses the <code class="literal">MessagingSystem</code>. Either way, our <code class="literal">UpdateableMonoBehaviour</code> class must register and deregister as <code class="literal">IUpdateableObject</code> objects, and the <code class="literal">GameLogic</code> class must use its own <code class="literal">Update()</code> callback to iterate through every registered object and call their <code class="literal">OnUpdate()</code> function.</p><p>Here is the class definition for the <code class="literal">GameLogic</code> system:</p><div class="informalexample"><pre class="programlisting">public class GameLogic : SingletonAsComponent&lt;GameLogic&gt; {
  public static GameLogic Instance {
    get { return ((GameLogic)_Instance); }
  set { _Instance = value; }
  }

List&lt;IUpdateableObject&gt; _updateableObjects = new List&lt;IUpdateableObject&gt;();

  public void RegisterUpdateableObject(IUpdateableObject obj) {
    if (!_Instance._updateableObjects.Contains(obj)) {
      _Instance._updateableObjects.Add(obj);
    }
  }

  public void DeregisterUpdateableObject(IUpdateableObject obj) {
    if (_Instance._updateableObjects.Contains(obj)) {
      _Instance._updateableObjects.Remove(obj);
    }
  }

  void Update() {
    float dt = Time.deltaTime;
    for(int i = 0; i &lt; _Instance._updateableObjects.Count; ++i) {
      _Instance._updateableObjects[i].OnUpdate(dt);
    }
  }

}</pre></div><p>If we make sure all<a id="id1326" class="indexterm"></a> of our custom <code class="literal">MonoBehaviours</code> inherit from the <code class="literal">UpdateableMonoBehaviour</code> class, then we've effectively replaced <span class="emphasis"><em>N</em></span> invocations of the <code class="literal">Update()</code> callback with just one <code class="literal">Update()</code> callback, plus <span class="emphasis"><em>N</em></span> virtual function calls. This can save us a large <a id="id1327" class="indexterm"></a>amount of performance overhead, because even though we're calling virtual functions, we're still keeping the overwhelming majority of update behavior inside managed code, and avoiding the native-managed bridge as much as possible.</p><p>Depending on how deep you already are into your current project, such changes can be incredibly daunting, time-consuming, and likely to introduce a lot of bugs as subsystems are updated to make use of a completely different set of dependencies. However, the benefits can outweigh the risks if time is on your side. It would be wise to do some testing on a group of <a id="id1328" class="indexterm"></a>objects in a Scene that is similarly designed to your current Scene files to verify<a id="id1329" class="indexterm"></a> if the benefits outweigh the costs.</p></div>