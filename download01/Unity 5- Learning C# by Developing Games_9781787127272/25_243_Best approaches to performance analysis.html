<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch25lvl1sec224"></a>Best approaches to performance analysis</h2></div></div><hr /></div><p>Good coding practices<a id="id1207" class="indexterm"></a> and project asset management often make finding the root cause of a performance issue relatively simple, at which point the only real problem is figuring out how to improve the code. For instance, if the method only processes a single gigantic <code class="literal">for</code> loop, then it will be a pretty safe assumption that the problem is either with the iteration of the loop or how much work is processed each iteration.</p><p>Of course, a lot <a id="id1208" class="indexterm"></a>of our code, whether we're working individually or in a group setting, is not always written in the cleanest way possible, and we should expect to have to profile some poor coding work from time to time. Sometimes, <span class="emphasis"><em>hack-y</em></span> solutions are inevitable, and we don't always have the time to go back and refactor everything to keep up with our best coding practices.</p><p>It's easy to overlook the obvious when problem solving and performance optimization is just another form of problem solving. The goal is to use Profilers and data analysis to search our codebase for clues about where a problem originates, and how significant it is. It's often very easy to get distracted by invalid data or jump to conclusions because we're being too impatient or missed a subtle clue. Many of us have run into occasions, during software debugging, where we could have found the root cause of the problem much faster if we had simply challenged and verified our earlier assumptions. Always approaching debugging under the belief that the problem is highly complex and technical is a good way to waste valuable time and effort. Performance analysis is no different.</p><p>A checklist of tasks would be helpful to keep us focused on the issue, and not waste time chasing "ghosts". Every project is different and has a different set of concerns and design paradigms, but the following checklist is general enough that it should be able to apply to any Unity project:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Verifying the target Script is present in the Scene</p></li><li style="list-style-type: disc"><p>Verifying the Script appears in the Scene the correct number of times</p></li><li style="list-style-type: disc"><p>Minimizing ongoing code changes</p></li><li style="list-style-type: disc"><p>Minimizing internal distractions</p></li><li style="list-style-type: disc"><p>Minimizing external distractions</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec137"></a>Verifying script presence</h3></div></div></div><p>Sometimes<a id="id1209" class="indexterm"></a> there are things we expect to see, but don't. These are usually easy to note, because the human brain is very good at pattern recognition. If something doesn't match the expected pattern, then it tends to be very obvious. Meanwhile, there are times where we assume something has been happening, but it didn't. These are generally more difficult to notice, because we're often scanning for the first kind of problem. Verification of the intended order of events is critical, or we risk jumping to conclusions, wasting valuable time.</p><p>In the context of Unity, this means it is essential to verify that the script we expect to see the event coming from is actually present in the Scene, and that the method calls happen in the order we intended.</p><p>Script presence can be quickly verified by typing the following into the <span class="strong"><strong>Hierarchy</strong></span> window textbox:</p><div class="informalexample"><pre class="programlisting">t:&lt;monobehaviour name&gt;</pre></div><p>For example, typing <code class="literal">t:mytestmonobehaviour</code> (note: it is not case-sensitive) into the <span class="strong"><strong>Hierarchy</strong></span> textbox will show a shortlist of all GameObjects that currently have a <code class="literal">MyTestMonobehaviour</code> script attached as a Component.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip18"></a>Tip</h3><p>Note that this shortlist feature also includes any GameObjects with Components that <span class="emphasis"><em>derive</em></span> from the given script name.</p></div><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_01_06.jpg" /></div><p>We should also double-check that the GameObjects they are attached to are still enabled, since we may have <a id="id1210" class="indexterm"></a>disabled them during earlier testing, or someone/something has accidentally deactivated the object.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec138"></a>Verifying script count</h3></div></div></div><p>If we<a id="id1211" class="indexterm"></a> assume that a MonoBehaviour, which is causing performance problems, only appears once in our Scene, then we may ignore the possibility that conflicting method invocations are causing a bottleneck. This is dangerous; what if someone created the object twice or more in the Scene file, or we accidentally instantiated the object more than once from code? What we see in the Profiler can be a consequence of the same expensive method being invoked more than once at the same time. This is something we will want to double-check using the same shortlist method as before.</p><p>If we expected only one of the Components to appear in the Scene, but the shortlist revealed more than one, then we may wish to rethink our earlier assumptions about what's causing the bottlenecks. We may wish to write some initialization code that prevents this from ever<a id="id1212" class="indexterm"></a>  happening again, and/or write some custom Editor helpers to display warnings to any level designers who might be making this mistake.</p><p>Preventing casual mistakes like this is essential for good productivity, since experience tells us that, if we don't explicitly disallow something, then someone, somewhere, at some point, for whatever reason, will do it anyway, and cost us a good deal of analysis work.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec139"></a>Minimizing ongoing code changes</h3></div></div></div><p>Making code changes to the application in order to hunt down performance issues is not recommended, as<a id="id1213" class="indexterm"></a> the changes are easy to forget as time wears on. Adding debug logging statements to our code can be tempting, but remember that it costs us time to introduce these calls, recompile our code, <span class="emphasis"><em>and</em></span> remove these calls once our analysis is complete. In addition, if we forget to remove them, then they can cost unnecessary runtime overhead in the final build since Unity's Debug logging can be prohibitively expensive in both CPU and memory.</p><p>One way to combat this problem is to use a source-control tool to differentiate the contents of any modified files, and/or revert them back to their original state. This is an excellent way to ensure that unnecessary changes don't make it into the final version.</p><p>Making use of breakpoints during runtime debugging is the preferred approach, as we can trace the full call stack, variable data, and conditional code paths (for example, <code class="literal">if</code>-<code class="literal">else</code> blocks), without risking any <a id="id1214" class="indexterm"></a>code changes or wasting time on recompilation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec140"></a>Minimizing internal distractions</h3></div></div></div><p>The Unity Editor has its<a id="id1215" class="indexterm"></a> own little quirks and nuances that can leave us confused by certain issues.</p><p>Firstly, if a single frame takes a long time to process, such that our game noticeably freezes, then the Profiler may not be capable of picking up the results and recording them in the Profiler window. This can be especially annoying if we wish to catch data during application/Scene initialization. The upcoming section, <span class="emphasis"><em>Custom CPU Profiling</em></span>, will offer some alternatives to explore to solve this problem.</p><p>One common mistake (that I have admittedly fallen victim to multiple times during the writing of this book) is: if we are trying to initiate a test with a keystroke and we have the Profiler open, we should not forget to click back into the Editor's Game window before triggering the keystroke! If the Profiler is the most recently clicked window, then the Editor will send keystroke events to that, instead of the runtime application, and hence no GameObject will catch the event for that keystroke.</p><p><span class="strong"><strong>Vertical Sync</strong></span> (otherwise known as <a id="id1216" class="indexterm"></a>
<span class="strong"><strong>VSync</strong></span>) is used to match the application's frame rate to the frame rate of the device it is being displayed on (for example, the monitor). Executing the Profiler with this feature enabled will generate a lot of spikes in the CPU usage area under the heading <span class="strong"><strong>WaitForTargetFPS</strong></span>, as the application intentionally slows itself down to match the frame rate of the display. This will generate unnecessary clutter, making it harder to spot the real issue(s). We should make sure to disable the VSync colored box under the CPU Area when we're on the lookout for CPU spikes during performance tests. We can disable the VSync feature entirely by navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Quality</strong></span> and then the subpage for the currently selected build platform.</p><p>We should also ensure that a drop in performance isn't a direct result of a massive number of exceptions and error messages appearing in the Editor console. Unity's <code class="literal">Debug.Log()</code>, and similar methods such as <code class="literal">Debug.LogError()</code>, <code class="literal">Debug.LogWarning()</code>, and so on, are notoriously expensive in terms of CPU usage and heap memory consumption, which can then cause garbage collection to occur and even more lost CPU cycles.</p><p>This overhead is usually unnoticeable to a human being looking at the project in Editor Mode, where most errors come from the compiler or misconfigured objects. But they can be problematic when used during any kind of runtime process; especially during profiling, where we wish to observe how the game runs in the absence of external disruptions. For example, if we are missing an object reference that we were supposed to assign through the Editor and it is being used in an <code class="literal">Update()</code> method, then a single MonoBehaviour could be throwing new exceptions every single update. This adds lots of unnecessary noise to our profiling data.</p><p>Note that we can disable the <span class="strong"><strong>Info</strong></span> or <span class="strong"><strong>Warning</strong></span> checkboxes (shown in the following screenshot) for the<a id="id1217" class="indexterm"></a> project during Play Mode runtime, but it still costs CPU and memory to execute debug statements, even though they are not being rendered. It is often a good practice to keep all of these options enabled, to verify that we're not missing anything important.</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_01_14.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec141"></a>Minimizing external distractions</h3></div></div></div><p>This one is simple<a id="id1218" class="indexterm"></a> but absolutely necessary. We should double-check that there are no background processes eating away CPU cycles or consuming vast swathes of memory. Being low on available memory will generally interfere with our testing, as it can cause more cache misses, hard-drive access for virtual memory page-file swapping, and generally slow responsiveness of the application.</p></div></div>