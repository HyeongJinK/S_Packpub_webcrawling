<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch26lvl1sec234"></a>Consider using distance-squared over distance</h2></div></div><hr /></div><p>It is safe to say that <a id="id1308" class="indexterm"></a>CPUs are relatively good at multiplying floating-point numbers together, but relatively dreadful at calculating square roots from them. Every time we ask a <code class="literal">Vector3</code> to calculate a distance with the <code class="literal">magnitude</code> property or with the <code class="literal">Distance()</code> method, we're asking it to perform a square root calculation (as per the Pythagorean theorem), which can cost a lot of CPU overhead compared to many other types of vector math calculations.</p><p>However, the <code class="literal">Vector3</code> class also offers a <code class="literal">sqrMagnitude</code> property, which is the same as distance, only squared. This lets us perform essentially the same comparison check without the expensive square root included, so long as we also square the value we're trying to compare it against; or, to describe this mathematically, if the magnitude of <span class="emphasis"><em>A</em></span> is less than the magnitude of <span class="emphasis"><em>B</em></span>, then <span class="emphasis"><em>A</em></span>
<span class="emphasis"><em>2</em></span> will be less than <span class="emphasis"><em>B</em></span>
<span class="emphasis"><em>2</em></span>.</p><p>For example, consider code like the following:</p><div class="informalexample"><pre class="programlisting">float distance = (transform.position – other.transform.position).Distance();
if (distance &lt; targetDistance) {
  // do stuff
}</pre></div><p>This can be replaced with the following and achieve a nearly identical result:</p><div class="informalexample"><pre class="programlisting">float distanceSqrd = (transform.position – other.transform.position).sqrMagnitude;
if (distanceSqrd &lt; targetDistance * targetDistance) {
  // do stuff
}</pre></div><p>The reason the result is <span class="emphasis"><em>nearly</em></span> identical is because of floating-point precision. We're likely to lose some of the precision that we would have had from using the square-root values, since the value will be adjusted to an area with a different density of representable numbers; it can land exactly on, or closer to, a more accurate representable number, or, more likely, it will land on a number with less accuracy. As a result, the comparison is not <span class="emphasis"><em>exactly</em></span> the same, but in most cases, it is close enough to be unnoticeable, and the performance gain can be quite significant for each instruction we replace in this manner.</p><p>If this minor precision loss is not important to you, then this performance trick should be considered. However, if precision is very important to you (such as running an accurate large-scale galactic space simulation), then you might want to look elsewhere for performance improvements.</p><p>Note that this technique can be used for <span class="emphasis"><em>any</em></span> square-root calculations; not just for distance. This is<a id="id1309" class="indexterm"></a> simply the most common example you might run across, and bring to light the important <code class="literal">sqrMagnitude</code> property of the <code class="literal">Vector3</code> class—a property which Unity Technologies intentionally exposed for us to make use of in this manner.</p></div>