<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch31lvl1sec260"></a>Prefab pooling</h2></div></div><hr /></div><p>The previous pooling solution is useful for typical classes, but it won't work for special Unity objects, such as GameObject and MonoBehaviour. These objects tend to consume a large chunk of our runtime memory, can cost us a great deal of CPU usage when they're created and destroyed, and tend to risk a large amount of garbage collection at runtime. In other words, the main goal of Prefab pooling is to push the overwhelming majority of object instantiation to<a id="id1742" class="indexterm"></a> Scene initialization, rather than letting them get created at runtime. This can provide some big runtime CPU savings, and avoids a lot of spikes caused by object creation/destruction and garbage collection, at the expense of Scene loading times, and runtime memory consumption. As a result, there are quite a few pooling solutions available on the Asset Store for handling this task, with varying degrees of simplicity, quality, and feature sets.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note163"></a>Note</h3><p>It is often recommended that pooling should be implemented in any game that intends to deploy on mobile devices, due to the greater overhead costs involved in the allocation and deallocation of memory compared to desktop applications.</p></div><p>However, creating a pooling solution is an interesting topic, and building one from scratch is a great way of getting to grips with a lot of important internal Unity Engine behavior. Also, knowing how such a system is built makes it easier to extend if we wish it to meet the needs of our particular game, rather than relying on a prebuilt solution.</p><p>The general idea of Prefab pooling is to create a system that contains lists of active and inactive GameObjects that were all instantiated from the same Prefab reference. The following diagram shows how the system might look after several spawns, despawns, and respawns of various objects derived from four different Prefabs (Orc, Troll, Ogre, and Dragon):</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_07_04.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note164"></a>Note</h3><p>Note that the <span class="strong"><strong>Heap Memory</strong></span> area represents the objects as they exist in memory, while the <span class="strong"><strong>Pooling System</strong></span> area represents references to those objects.</p></div><p>In this example, several instances of each Prefab were instantiated (11 Orcs, 8 Trolls, 5 Ogres, and 1 Dragon). Currently only eleven of these objects are active, while the other fourteen have previously been despawned, and are inactive. Note that the despawned objects still exist in memory, although <a id="id1743" class="indexterm"></a>they are not visible and cannot interact with the game world until they have been respawned. Naturally, this costs us a constant amount of heap memory at runtime in order to maintain the inactive objects, but when a new object is instantiated, we can reuse one of the existing inactive objects, rather than allocating <span class="emphasis"><em>more</em></span> memory in order to satisfy the request. This saves significant runtime CPU costs during object creation and destruction, and avoids garbage collection.</p><p>The following diagram shows the chain of events that needs to occur when a new Orc is spawned:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_07_05.jpg" /></div><p>The first object in the Inactive Orc pool (Orc7) is reactivated and moved into the Active pool. We now have 6 active Orcs, and 5 inactive Orcs.</p><p>The following figure shows the <a id="id1744" class="indexterm"></a>order of events when an <code class="literal">Ogre</code> object is despawned:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_07_06.jpg" /></div><p>This time the object is deactivated and moved from the Active pool into the Inactive pool, leaving us with 1 active Ogre and 4 inactive Ogres.</p><p>Finally, the<a id="id1745" class="indexterm"></a> following diagram shows what happens when a new object is spawned, but there are no inactive objects to satisfy the request:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_07_07.jpg" /></div><p>In this scenario, more memory must be allocated to instantiate the new <code class="literal">Dragon</code> object, since there are no <code class="literal">Dragon</code> objects in its Inactive pool to reuse. Therefore, in order to avoid runtime memory allocations for our GameObjects, it is critical that we know beforehand how many we will need. This will vary depending on the type of object in question, and requires <a id="id1746" class="indexterm"></a>occasional testing and debugging to ensure we have a sensible number of each Prefab instantiated at runtime.</p><p>With all of this in mind, let's create a pooling system for Prefabs!</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch31lvl2sec226"></a>Poolable Components</h3></div></div></div><p>Let's first define an interface for <a id="id1747" class="indexterm"></a>a Poolable Component:</p><div class="informalexample"><pre class="programlisting">public interface IPoolableComponent {
    void Spawned();
    void Despawned();
}</pre></div><p>The approach for <code class="literal">IPoolableComponent</code> will be very different from the approach taken for <code class="literal">IPoolableObject</code>. The objects being created this time are GameObjects, which are a lot trickier to work with than standard objects because of how much of their runtime behavior is already handled through the Unity Engine, and how little access we have to it.</p><p>GameObjects do not give us access to an equivalent <code class="literal">New()</code> method that we can invoke any time the object is created, and we cannot derive from the <code class="literal">GameObject</code> class in order to implement one. GameObjects are created either by placing them in a Scene, or by instantiating them at runtime through <code class="literal">GameObject.Instantiate()</code>, and the only inputs we can apply are an initial position and rotation. Of course, their Components have an <code class="literal">Awake()</code> method we can define, which is invoked the first time the Component is brought to life, but this is merely a compositional objectâ€”it's not the actual parent object we're spawning and despawning.</p><p>So, because we only have control over a GameObject class's Components, it is assumed that the <code class="literal">IPoolableComponent</code> interface is implemented by <span class="emphasis"><em>at least one</em></span> of the Components that is attached to the GameObject we wish to pool.</p><p>The <code class="literal">Spawned()</code> method should be invoked on every implementing Component each time the pooled GameObject is respawned, while the <code class="literal">Despawned()</code> method gets invoked whenever it is despawned. This gives us entry points to control the data variables and behavior during the creation and destruction of the parent GameObject.</p><p>The act of despawning a GameObject is trivial; turn its active flag to <code class="literal">false</code> (through <code class="literal">SetActive()</code>). This disables the Collider and Rigidbody for physics calculations, removes it from the list of renderable objects, and essentially takes care of disabling interactions with all built-in Unity Engine subsystems in a single stroke. The only exception is any Coroutines that are currently invoking on the object, since as we learned earlier in <a class="link" href="#" linkend="ch26">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>, Coroutines are invoked independently of <code class="literal">Update()</code> and GameObject activity. We will therefore need to call <code class="literal">StopCoroutine()</code>, or <code class="literal">StopAllCoroutines()</code> during the despawning of such objects.</p><p>In addition, Components typically hook into our own custom gameplay subsystems as well, and so the <code class="literal">Despawn()</code> method gives our Components the opportunity to take care of any custom cleanup before shutting down. For example, we would probably want to use <code class="literal">Despawn()</code> to deregister the Component from the Messaging System we defined back in <a class="link" href="#" linkend="ch26">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>.</p><p>Unfortunately, successfully respawning the GameObject is a lot more complicated. When we respawn an object, there will be many settings that were left behind when the object was previously active, and these must be reset in order to avoid conflicting behaviors. A common problem with this is Rigidbody velocity. If this value is not explicitly reset before the <a id="id1748" class="indexterm"></a>object is reactivated, then the newly respawned object will continue moving with the same velocity the old version had when it was despawned.</p><p>This problem becomes further complicated by the fact that built-in Components are <code class="literal">sealed</code>, and therefore cannot be derived from. So, to avoid these issues, we can create a custom Component that resets the attached Rigidbody whenever the object is despawned:</p><div class="informalexample"><pre class="programlisting">public class ResetPooledRigidbodyComponent : MonoBehaviour, IPoolableComponent {
    Rigidbody _body;
    public void Spawned() {  }
    public void Despawned() {
        if (_body == null) {
            _body = GetComponent&lt;Rigidbody&gt;();
            if (_body == null) {
                // no Rigidbody!
                return;
            }
        }
        _body.velocity = Vector3.zero; 
        _body.angularVelocity = Vector3.zero;
    }
}</pre></div><p>Note that the best place to perform this task is during despawning, because we cannot be certain in what order the GameObject class's <code class="literal">IPoolableComponent</code> interfaces will have their <code class="literal">Spawned()</code> methods invoked. It is unlikely that another <code class="literal">IPoolableComponent</code> will change the object's velocity during despawning, but it is possible that a different <code class="literal">IPoolableComponent</code> attached to the same object might want to set the Rigidbody's initial velocity to some important value during its own <code class="literal">Spawned()</code> method. Ergo, performing the velocity reset during the <code class="literal">ResetPooledRigidbodyComponent</code> class's <code class="literal">Spawned()</code> method could potentially conflict with other Components and cause some very confusing bugs.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip63"></a>Tip</h3><p>In fact, creating Poolable Components that are not self-contained, and tend to tinker with other Components like this, is one of the biggest dangers of implementing a pooling system. We should minimize such implementations, and routinely verify them when we're trying to debug strange issues in our game.</p></div><p>For the sake of illustration, here<a id="id1749" class="indexterm"></a>  is the definition of a simple Poolable Component that replaces the <code class="literal">TestMessageListener</code> class we defined back in <a class="link" href="#" linkend="ch26">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>. This Component automatically handles some basic tasks every time the object is spawned and despawned:</p><div class="informalexample"><pre class="programlisting">public class PoolableTestMessageListener : MonoBehaviour, IPoolableComponent {
    public void Spawned() {
        MessagingSystem.Instance.AttachListener (typeof(MyCustomMessage), this.HandleMyCustomMessage);
    }

bool HandleMyCustomMessage(BaseMessage msg) {
        MyCustomMessage castMsg = msg as MyCustomMessage;
        Debug.Log (string.Format("Got the message! {0}, {1}", castMsg._intValue, castMsg._floatValue));
        return true;
    }

    public void Despawned() {
        if (MessagingSystem.IsAlive) {
MessagingSystem.Instance.DetachListener(typeof(MyCustomMessage), this.HandleMyCustomMessage);
        }
    }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch31lvl2sec227"></a>The Prefab pooling system</h3></div></div></div><p>Hopefully, we now have an understanding of what we need from our pooling system, so all that's left is to implement it. The requirements<a id="id1750" class="indexterm"></a> are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>It must accept requests to spawn a GameObject from a Prefab, an initial position, and an initial rotation:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If a despawned version already exists, it should respawn the first available one</p></li><li style="list-style-type: disc"><p>If it does not exist, then it should instantiate a new GameObject from the Prefab</p></li><li style="list-style-type: disc"><p>In either case, the <code class="literal">Spawned()</code> method should be invoked on all <code class="literal">IPoolableComponent</code> interfaces attached to the GameObject</p></li></ul></div></li><li style="list-style-type: disc"><p>It must accept requests to despawn a specific GameObject:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If the object is managed by the pooling system, it should deactivate it and call the <code class="literal">Despawned()</code> method on all <code class="literal">IPoolableComponent</code> interfaces attached to the GameObject</p></li><li style="list-style-type: disc"><p>If the object is not managed by the pooling system, it should send an error</p></li></ul></div></li></ul></div><p>The requirements are fairly<a id="id1751" class="indexterm"></a>  straightforward, but the implementation requires some investigation if we wish to make the solution performance-friendly. Firstly, a typical Singleton would be a good choice for the main entry point, since we want this system to be globally accessible from anywhere:</p><div class="informalexample"><pre class="programlisting">public static class PrefabPoolingSystem {
}</pre></div><p>The main task for object spawning involves accepting a Prefab reference, and figuring if we have any despawned GameObjects that were originally instantiated from the same reference. To do this, we will essentially want our pooling system to keep track of two different lists for any given Prefab reference: a list of active (spawned) GameObjects, and a list of inactive (despawned) objects that were instantiated from it. This data would be best abstracted into a separate class, which we will name <code class="literal">PrefabPool</code>.</p><p>In order to maximize the performance of this system (and hence make the largest gains possible, relative to just allocating and deallocating objects from memory all of the time), we will want to use some fast data structures in order to acquire the corresponding <code class="literal">PrefabPool</code> objects whenever a<a id="id1752" class="indexterm"></a> spawn or despawn request comes in.</p><p>Because spawning involves being given a Prefab, we will want one data structure that can quickly map Prefabs to the <code class="literal">PrefabPool</code> that manages them. And because despawning involves being given a GameObject, we will want another data structure that can quickly map spawned GameObjects to the <code class="literal">PrefabPool</code> that originally spawned them. A Dictionary is a good choice for both of these needs.</p><p>Let's define these maps in our pooling system:</p><div class="informalexample"><pre class="programlisting">public static class PrefabPoolingSystem {
    static Dictionary&lt;GameObject,PrefabPool&gt; _prefabToPoolMap = new Dictionary&lt;GameObject,PrefabPool&gt;();
    static Dictionary&lt;GameObject,PrefabPool&gt; _goToPoolMap = new Dictionary&lt;GameObject,PrefabPool&gt;();
}</pre></div><p>Next we'll define what happens when we spawn an object:</p><div class="informalexample"><pre class="programlisting">public static GameObject Spawn(GameObject prefab, Vector3 position, Quaternion rotation) {
    if (!_prefabToPoolMap.ContainsKey (prefab)) {
        _prefabToPoolMap.Add (prefab, new PrefabPool());
    }
    PrefabPool pool = _prefabToPoolMap[prefab];
    GameObject go = pool.Spawn(prefab, position, rotation);
    _goToPoolMap.Add (go, pool);
    return go;
}</pre></div><p>The <code class="literal">Spawn()</code> method will be given a Prefab reference, an initial position, and an initial rotation. We need to figure out which <code class="literal">PrefabPool</code> the Prefab belongs to (if any), ask it to spawn a new GameObject using the data provided, and then return the spawned object to the requestor. We first check our "Prefab-to-Pool" map, to see if a pool already exists for this Prefab. If not, we quickly create one. In either case, we then ask the <code class="literal">PrefabPool</code> to spawn us a new object. The <code class="literal">PrefabPool</code> will either end up respawning an object that was despawned earlier, or instantiate a new one (if there aren't any inactive instances left).</p><p>Either way, this class doesn't particularly care. It just wants the instance generated by the <code class="literal">PrefabPool</code> class so that it can be entered into the "GameObject-to-Pool" map and returned to the requestor.</p><p>For convenience, we can also<a id="id1753" class="indexterm"></a> define an overload which places the object at the world's center (useful for GameObjects that aren't visible, and just need to exist somewhere):</p><div class="informalexample"><pre class="programlisting">public static GameObject Spawn(GameObject prefab) {
    return Spawn (prefab, Vector3.zero, Quaternion.identity);
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note165"></a>Note</h3><p>Note that no actual spawning and despawning are taking place, yet. This task will eventually be handled within the <code class="literal">PrefabPool</code> class.</p></div><p>Despawning involves being given a GameObject, and then figuring out which <code class="literal">PrefabPool</code> is managing it. This could be achieved by iterating through our <code class="literal">PrefabPool</code> classes and checking if they contain the given <code class="literal">GameObject</code>. But if we end up generating a lot of <code class="literal">PrefabPools</code>, then this iterative process can take a while. We will always end up with as many <code class="literal">PrefabPool</code> classes as we have Prefabs (at least so long as we manage all of them through the pooling system). Most projects tend to have dozens, hundreds, if not thousands of different Prefabs.</p><p>So, the GameObject-to-Pool map is maintained to ensure that we always have rapid access to the <code class="literal">PrefabPool</code> that originally spawned the object. It can also be used to quickly verify if the given GameObject is even managed by the pooling system to begin with. Here is the method definition for the despawning method, which takes care of these tasks:</p><div class="informalexample"><pre class="programlisting">public static bool Despawn(GameObject obj) {
    if (!_goToPoolMap.ContainsKey(obj)) {
        Debug.LogError (string.Format ("Object {0} not managed by pool system!", obj.name));
        return false;
    }
    
    PrefabPool pool = _goToPoolMap[obj];
    if (pool.Despawn (obj)) {
        _goToPoolMap.Remove (obj);
        return true;
    }
    return false;
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip64"></a>Tip</h3><p>Note that the <code class="literal">Despawn()</code> method of both <code class="literal">PrefabPoolingSystem</code> and <code class="literal">PrefabPool</code> returns a Boolean that can be used to verify whether or not the object was successfully despawned.</p></div><p>As a result, thanks to the two maps we're maintaining, we can quickly access the <code class="literal">PrefabPool</code> that manages the given reference, and this solution will scale for any number of Prefab that the <a id="id1754" class="indexterm"></a>system manages.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch31lvl2sec228"></a>Prefab pools</h3></div></div></div><p>Now that we have a system that can handle multiple Prefab pools automatically, the only thing left is to define the behavior of the pools. As mentioned previously, we will want the <code class="literal">PrefabPool</code> class to maintain two data structures: one for active (spawned) objects that have been instantiated from the given Prefab and another for inactive (despawned) objects.</p><p>Technically, the <code class="literal">PrefabPoolingSystem</code> class already maintains a map of which Prefab is governed by which <code class="literal">PrefabPool</code>, so<a id="id1755" class="indexterm"></a> we can actually save a little memory by making the <code class="literal">PrefabPool</code> a slave to the <code class="literal">PrefabPoolingSystem</code> class, by not having it keep track of which Prefab it is managing. Consequently, the two data structures are the only member variables the <code class="literal">PrefabPool</code> needs to keep track of.</p><p>However, for each spawned GameObject, it must also maintain a list of all of its <code class="literal">IPoolableComponent</code> references in order to invoke the <code class="literal">Spawned()</code> and <code class="literal">Despawned()</code> methods on them. Acquiring these references can be a costly operation to perform at runtime, so it would be best to cache the data in a simple struct:</p><div class="informalexample"><pre class="programlisting">public struct PoolablePrefabData {
    public GameObject go;
    public IPoolableComponent[] poolableComponents;
}</pre></div><p>This struct will contain a reference to the <code class="literal">GameObject</code>, and the precached list of its <code class="literal">IPoolableComponents</code>.</p><p>Now we can define the member data of our <code class="literal">PrefabPool</code> class:</p><div class="informalexample"><pre class="programlisting">public class PrefabPool {
    Dictionary&lt;GameObject,PoolablePrefabData&gt; _activeList = new Dictionary&lt;GameObject,PoolablePrefabData&gt;();
    Queue&lt;PoolablePrefabData&gt; _inactiveList = new Queue&lt;PoolablePrefabData&gt;();
}</pre></div><p>The data structure for the active list should be a dictionary in order to do a quick lookup for the corresponding <code class="literal">PoolablePrefabData</code> from any given <code class="literal">GameObject</code> reference. This will be useful during object despawning.</p><p>Meanwhile, the inactive data structure is defined as a Queue, but it will work equally well as a List, a Stack, or really any data structure that needs to regularly expand or contract, and where we only need to pop items from one end of the list, since it does not matter which object it is. It only matters that we retrieve one of them. A Queue is useful in this case because we can both retrieve<a id="id1756" class="indexterm"></a> and remove the object from the data structure in a single call.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch31lvl2sec229"></a>Object spawning</h3></div></div></div><p>Let's define what it means to spawn<a id="id1757" class="indexterm"></a> a GameObject in the context of our pooling system: at some point, <code class="literal">PrefabPool</code> will get a request to spawn a GameObject from a given Prefab, at a particular position and rotation. The first thing we should check is whether or not we have any inactive instances of the Prefab. If so, then we can pop the next available one from the Queue and respawn it. If not, then we need to instantiate a new <code class="literal">GameObject</code> from the Prefab using <code class="literal">GameObject.Instantiate()</code>. At this moment, we should also create a <code class="literal">PoolablePrefabData</code> object to store the GameObject reference, and acquire the list of all <code class="literal">IPoolableComponents</code> that are attached to it.</p><p>Either way, we can now activate the GameObject, set its position and rotation, and call the <code class="literal">Spawned()</code> method on all of its <code class="literal">IPoolableComponents</code>. Once the object has been respawned, we can add it to the list of active objects and return it to the requestor.</p><p>Here is the definition of the <code class="literal">Spawn()</code> method that defines this behavior:</p><div class="informalexample"><pre class="programlisting">public GameObject Spawn(GameObject prefab, Vector3 position, Quaternion rotation) {
    PoolablePrefabData data;
    if (_inactiveList.Count &gt; 0) {
         data = _inactiveList.Dequeue();
    } else {
        // instantiate a new object
        GameObject newGO = GameObject.Instantiate(prefab, position, rotation) as GameObject;
        data = new PoolablePrefabData();
        data.go = newGO;
        data.poolableComponents = newGO.GetComponents&lt;IPoolableComponent&gt;();
    }

    data.go.SetActive (true);
    data.go.transform.position = position;
    data.go.transform.rotation = rotation;
    for(int i = 0; i &lt; data.poolableComponents.Length; ++i) {
        data.poolableComponents[i].Spawned ();
    }
    _activeList.Add (data.go, data);

    return data.go;
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch31lvl2sec230"></a>Instance prespawning</h3></div></div></div><p>Because we are using <code class="literal">GameObject.Instantiate()</code> whenever the pool has run out of despawned instances, this system does not completely rid us of runtime object instantiation and hence, heap<a id="id1758" class="indexterm"></a> memory allocation. It's important to prespawn the expected number of instances that we will need during the lifetime of the current Scene, so that we don't need to instantiate more during runtime.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip65"></a>Tip</h3><p>It would be wasteful to prespawn 100 explosion particle effects, if the most we will ever expect to see in the Scene at any given time is three or four. Conversely, spawning too few instances will cause excessive runtime memory allocations, and the goal of this system is to push the majority of allocation to the start of a Scene's lifetime. We need to be careful about how many instances we maintain in memory so that we don't waste more memory space than necessary.</p></div><p>Let's define a method in our <code class="literal">PrefabPoolingSystem</code> class that we can use to quickly prespawn a given number of objects from a Prefab. This essentially involves spawning <span class="emphasis"><em>N</em></span> objects, and then immediately despawning them all:</p><div class="informalexample"><pre class="programlisting">public static void Prespawn(GameObject prefab, int numToSpawn) {
    List&lt;GameObject&gt; spawnedObjects = new List&lt;GameObject&gt;();

    for(int i = 0; i &lt; numToSpawn; i++) {
        spawnedObjects.Add (Spawn (prefab));
    }

    for(int i = 0; i &lt; numToSpawn; i++) {
        Despawn(spawnedObjects[i]);
    }

    spawnedObjects.Clear ();
}</pre></div><p>We would use this method during Scene initialization, to prespawn a collection of objects to use in<a id="id1759" class="indexterm"></a> the level. For example:</p><div class="informalexample"><pre class="programlisting">public class OrcPreSpawner : MonoBehaviour
    [SerializeField] GameObject _orcPrefab; 
    [SerializeField] int _numToSpawn = 20;
    void Start() {
        PrefabPoolingSystem.Prespawn(_orcPrefab, _numToSpawn);
    }
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch31lvl2sec231"></a>Object despawning</h3></div></div></div><p>Finally, there is the act of<a id="id1760" class="indexterm"></a> despawning the objects. As mentioned previously, this primarily involves deactivating the object, but we also need to take care of various bookkeeping tasks and invoking <code class="literal">Despawned()</code> on all of its <code class="literal">IPoolableComponent</code> references.</p><p>Here is the method definition for the <code class="literal">PrefabPool</code> class's <code class="literal">Despawn()</code> method:</p><div class="informalexample"><pre class="programlisting">public bool Despawn(GameObject objToDespawn) {
    if (!_activeList.ContainsKey(objToDespawn)) {
        Debug.LogError ("This Object is not managed by this object pool!");
        return false;
    }

    PoolablePrefabData data = _activeList[objToDespawn];

    for(int i = 0; i &lt; data.poolableComponents.Length; ++i) {
        data.poolableComponents[i].Despawned ();
    }
    data.go.SetActive (false);

    _activeList.Remove (objToDespawn);
    _inactiveList.Enqueue(data);
    return true;
}</pre></div><p>First we verify the object is being managed by the pool, and then we grab the corresponding <code class="literal">PoolablePrefabData</code> in order to access the list of <code class="literal">IPoolableComponent</code> references. Once <code class="literal">Despawned()</code> has been invoked on all of them, we deactivate the object, remove it from the active list, and push it into the inactive queue so that it can be respawned later.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch31lvl2sec232"></a>Prefab pool testing</h3></div></div></div><p>The following class definition allows us to perform a simple hands-on test with the <code class="literal">PrefabPoolingSystem</code> class. It <a id="id1761" class="indexterm"></a>will support three Prefabs, and prespawn five instances during application initialization. We can press the <span class="emphasis"><em>1</em></span>, <span class="emphasis"><em>2</em></span>, or <span class="emphasis"><em>3</em></span> keys to spawn an instance of each type, and then press <span class="emphasis"><em>Q</em></span>, <span class="emphasis"><em>W</em></span>, or <span class="emphasis"><em>E</em></span> to despawn a random instance of each type.</p><div class="informalexample"><pre class="programlisting">public class PoolTester : MonoBehaviour {

    [SerializeField] GameObject _prefab1;
    [SerializeField] GameObject _prefab2;
    [SerializeField] GameObject _prefab3;

    List&lt;GameObject&gt; _go1 = new List&lt;GameObject&gt;();
    List&lt;GameObject&gt; _go2 = new List&lt;GameObject&gt;();
    List&lt;GameObject&gt; _go3 = new List&lt;GameObject&gt;();

    void Start() {
        PrefabPoolSystem_AsSingleton.Prespawn(_prefab1, 5);
        PrefabPoolSystem_AsSingleton.Prespawn(_prefab2, 5);
        PrefabPoolSystem_AsSingleton.Prespawn(_prefab3, 5);
    }

    void Update () {
        if (Input.GetKeyDown(KeyCode.Alpha1)) {SpawnObject(_prefab1, _go1);}
        if (Input.GetKeyDown(KeyCode.Alpha2)) {SpawnObject(_prefab2, _go2);}
        if (Input.GetKeyDown(KeyCode.Alpha3)) {SpawnObject(_prefab3, _go3);}
        if (Input.GetKeyDown(KeyCode.Q)) { DespawnRandomObject (_go1); }
        if (Input.GetKeyDown(KeyCode.W)) { DespawnRandomObject (_go2); }
        if (Input.GetKeyDown(KeyCode.E)) { DespawnRandomObject (_go3); }
    }

    void SpawnObject(GameObject prefab, List&lt;GameObject&gt; list) {
        GameObject obj = PrefabPoolingSystem.Spawn (prefab, Random.insideUnitSphere * 8f, Quaternion.identity);
        list.Add (obj);
    }

    void DespawnRandomObject(List&lt;GameObject&gt; list) {
        if (list.Count == 0) {
            // Nothing to despawn
            return;
        }

        int i = Random.Range (0, list.Count);
        PrefabPoolingSystem.Despawn(list[i]);
        list.RemoveAt(i);
    }
}</pre></div><p>Once we spawn more than five instances of any of the Prefabs, it will need to instantiate a new one in memory, costing us<a id="id1762" class="indexterm"></a> some memory allocation. But, if we observe the Memory Area in the Profiler, while we only spawn and despawn instances that already exist, then we will notice that absolutely no new allocations take place.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch31lvl2sec233"></a>Prefab pooling and Scene loading</h3></div></div></div><p>There is one subtle<a id="id1763" class="indexterm"></a> caveat to this system that has not yet been mentioned: the <code class="literal">PrefabPoolingSystem</code> class will outlast Scene lifetime since it is a static class. This means that, when a new Scene is loaded, the pooling system's dictionaries will attempt to maintain references to any pooled instances from the previous Scene, but Unity forcibly destroys these objects regardless of the fact that we are still keeping references to them (unless they were set to <code class="literal">DontDestroyOnLoad()</code>!), and so the dictionaries will be full of <code class="literal">null</code> references. This would cause some serious problems for the next Scene.</p><p>We should therefore create a method in <code class="literal">PrefabPoolingSystem</code> that resets the pooling system in preparation for this likely event. The following method should be called before a new Scene is loaded, so that it is ready for any early calls to <code class="literal">Prespawn()</code> in the next Scene:</p><div class="informalexample"><pre class="programlisting">public static void Reset() {
    _prefabToPoolMap.Clear ();
    _goToPoolMap.Clear ();
}</pre></div><p>Note that, if we also invoke a garbage collection during Scene transitions, there's no need to explicitly empty the <code class="literal">PrefabPools</code> these dictionaries were referencing. Since these were the only references to the <code class="literal">PrefabPool</code> objects, they will be deallocated during the next garbage collection. If we aren't invoking garbage collection between Scenes, then the <code class="literal">PrefabPool</code> and <code class="literal">PooledPrefabData</code> objects will remain in memory until that time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch31lvl2sec234"></a>Prefab pooling summary</h3></div></div></div><p>We have finally solved the problem of runtime memory allocations for GameObjects and Prefabs but, as a quick<a id="id1764" class="indexterm"></a> reminder, we need to be aware of the following caveats:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>We need to be careful about properly resetting important data in respawned objects (such as Rigidbody velocity)</p></li><li style="list-style-type: disc"><p>We must ensure we don't prespawn too few, or too many, instances of a Prefab</p></li><li style="list-style-type: disc"><p>We should be careful of the order of execution of <code class="literal">Spawned()</code> and <code class="literal">Despawned()</code> methods on <code class="literal">IPoolableComponents</code></p></li><li style="list-style-type: disc"><p>We must call <code class="literal">Reset()</code> on <code class="literal">PrefabPoolingSystem</code> before Scene loading</p></li></ul></div><p>There are several other features we could implement. These will be left as academic exercises if we wish to extend this system in the future:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Any <code class="literal">IPoolableComponents</code> added to the GameObject after initialization will not be invoked. We could fix this by changing <code class="literal">PrefabPool</code> to keep acquiring <code class="literal">IPoolableComponents</code> every time <code class="literal">Spawned()</code> and <code class="literal">Despawned()</code> are invoked, at the cost of additional overhead during spawning/despawning.</p></li><li style="list-style-type: disc"><p><code class="literal">IPoolableComponents</code> attached to children of the Prefab's root will not be counted. This could be fixed by changing <code class="literal">PrefabPool</code> to use <code class="literal">GetComponentsInChildren&lt;T&gt;</code>, at the cost of additional overhead if we're using Prefabs with deep hierarchies.</p></li><li style="list-style-type: disc"><p>Prefab instances that already exist in the Scene will not be managed by the pooling system. We could create a Component that needs to be attached to such objects and that notifies the <code class="literal">PrefabPoolingSystem</code> class of its existence and passes the reference into the corresponding <code class="literal">PrefabPool</code>.</p></li><li style="list-style-type: disc"><p>We could implement a way for <code class="literal">IPoolableComponents</code> to set a priority during acquisition, and directly control the order of execution for their <code class="literal">Spawned()</code> and <code class="literal">Despawned()</code> methods.</p></li><li style="list-style-type: disc"><p>We could add counters that keep track of how long objects have been sitting in the Inactive list relative to total Scene lifetime, and print out the data during shutdown. This could tell us whether or not we're prespawning too many instances of a given Prefab.</p></li><li style="list-style-type: disc"><p>This system will not interact kindly with Prefab instances that set themselves to <code class="literal">DontDestroyOnLoad()</code>. It might be wise to add a Boolean to every <code class="literal">Spawn()</code> call to say whether the object should persist or not, and keep them in a separate data structure that is not cleared out during <code class="literal">Reset()</code>.</p></li><li style="list-style-type: disc"><p>We could change <code class="literal">Spawn()</code> to accept an argument that allows the requestor to pass custom data to the <code class="literal">Spawned()</code> function of <code class="literal">IPoolableObject</code> for initialization purposes. This could <a id="id1765" class="indexterm"></a>use a system similar to how custom message objects were derived from the <code class="literal">BaseMessage</code> class for our Messaging System back in <a class="link" href="#" linkend="ch26">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>.</p></li></ul></div></div></div>