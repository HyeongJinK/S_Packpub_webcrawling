<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch22lvl1sec203"></a>Creating an enemy</h2></div></div><hr /></div><p>Now that we can take<a id="id1022" class="indexterm"></a> pictures, let's create an enemy<a id="id1023" class="indexterm"></a> to take pictures of! We will perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The first step to adding in an enemy is to import the assets required to use it. Inside our <code class="literal">Chapter 9\Art Assets\Ghost Model</code> location, you'll find a series of files. Go ahead and drag and drop the folder into your project.</p></li><li><p>Open up the <span class="strong"><strong>Ghost Model</strong></span> object from the <span class="strong"><strong>Project</strong></span> tab and then select the <code class="literal">Ghost_mesh</code> object. Now, select the object to bring up its properties in the <span class="strong"><strong>Inspector</strong></span> tab. Under <span class="strong"><strong>Scale Factor</strong></span> in the <span class="strong"><strong>Model</strong></span> tab, change the value to <code class="literal">.10</code> to scale the object to 1/10th of its starting size. Then, check <span class="strong"><strong>Generate Colliders</strong></span>, making sure to hit <span class="strong"><strong>Apply</strong></span>.</p></li><li><p>Under the <span class="strong"><strong>Rig</strong></span> tab, confirm the <span class="strong"><strong>Animation Type</strong></span> value to <span class="strong"><strong>None</strong></span>, as this model doesn't have any animations and then click on <span class="strong"><strong>Apply</strong></span> if needed.</p></li><li><p>Now, go <a id="id1024" class="indexterm"></a>somewhere in <a id="id1025" class="indexterm"></a>your world in the <span class="strong"><strong>Scene</strong></span> view, and drag and drop the character onto the screen near your player and terrain. Take a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/B05212_09_17.jpg" /></div></li></ol></div><p>Now, save the<a id="id1026" class="indexterm"></a> project, level <a id="id1027" class="indexterm"></a>and start up the game.</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/B05212_09_18.jpg" /></div><p>And now, the character is displayed and we can see them in the game. Spooky!</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch22lvl2sec123"></a>State machines 101</h3></div></div></div><p>We oftentimes <a id="id1028" class="indexterm"></a>write code to provide the reactive or interactive parts within our simulation (or game world)â€”things such as when you're pressing a button or if you're walking or jumping. If you look at real life, you should note that a lot of things are reactive systems in that same way, such as your mobile phone and toaster. Depending on the stimuli provided to these objects, the state of these objects may change. We describe something that can be in one of the multiple states at a time as a state machine.</p><p>Almost every program that we write is or can be a state machine of some sort because technically, the moment you write an <code class="literal">if</code> statement, you've created code that can be in one of at least two states. However, having a number of <code class="literal">switch</code> and <code class="literal">if</code> statements can quickly get out of hand, making it very hard for people to understand what your code is actually doing. As a programmer, we want to isolate problems and break them down into their simplest parts before jumping in to solve them.</p><p>There are different kinds <a id="id1029" class="indexterm"></a>of state machines, but for this first example, we are going to create a simple <a id="id1030" class="indexterm"></a>
<span class="strong"><strong>Finite State Machine</strong></span> (<span class="strong"><strong>FSM</strong></span>). When I say finite, it means that each of the states is already defined ahead of time. With a finite state machine, we can have different states in which we can process input differently depending on the state.</p><p>For example, if you are on a ladder, you can only move up and down and not to the sides.</p></div></div>