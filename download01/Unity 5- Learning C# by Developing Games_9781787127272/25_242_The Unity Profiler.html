<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch25lvl1sec223"></a>The Unity Profiler</h2></div></div><hr /></div><p>The Unity Profiler is <a id="id1160" class="indexterm"></a>built into the <a id="id1161" class="indexterm"></a>
<span class="strong"><strong>Unity Editor</strong></span> itself, and provides an expedient way of narrowing our search for performance bottlenecks by generating usage and statistics reports on a multitude of <span class="strong"><strong>Unity3D</strong></span> components during<a id="id1162" class="indexterm"></a> runtime:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>CPU usage per component of the Unity3D Engine</p></li><li style="list-style-type: disc"><p>Rendering statistics</p></li><li style="list-style-type: disc"><p>GPU usage on several programmable pipeline steps and stages</p></li><li style="list-style-type: disc"><p>Memory usage and statistics</p></li><li style="list-style-type: disc"><p>Audio usage and statistics</p></li><li style="list-style-type: disc"><p>Physics engine usage and statistics</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note126"></a>Note</h3><p>With the release of<a id="id1163" class="indexterm"></a> <span class="strong"><strong>Unity 5.0</strong></span>, Unity Technologies has made the Profiler available to all developers running the Personal Edition (the new name for the Free Edition).</p><p>Users running the Free Edition of Unity 4 must either upgrade to Unity 5, or purchase a license for Unity 4 Pro Edition.</p></div><p>This additional reporting comes with a price, however. Additional instrumentation flags will be enabled within the compiler, generating runtime logging events and a different level of automated code optimization while the Profiler is in use, which causes some additional CPU and memory overhead at runtime. This profiling cost is not completely negligible, and is likely to cause inconsistent behavior when the Profiler is toggled on and off.</p><p>In addition, we should always avoid using Editor Mode for any kind of profiling and benchmarking purposes due to the overhead costs of the Editor; its interface, and additional memory consumption of various objects and components. It is always better to test our application in a standalone format, on the target device, in order to get a more accurate and realistic data sample.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip11"></a>Tip</h3><p>Users who are already familiar with connecting the Unity Profiler to their applications should skip to the section titled <span class="emphasis"><em>The Profiler window</em></span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec135"></a>Launching the Profiler</h3></div></div></div><p>We will begin <a id="id1164" class="indexterm"></a>with a brief tutorial on how to connect our game to the Unity Profiler within a variety of contexts:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Local instances of the application, either through the Editor or standalone</p></li><li style="list-style-type: disc"><p>Profiling the Editor itself</p></li><li style="list-style-type: disc"><p>Local instances<a id="id1165" class="indexterm"></a> of the <a id="id1166" class="indexterm"></a>application in <span class="strong"><strong>Unity Webplayer</strong></span></p></li><li style="list-style-type: disc"><p>Remote instances of the application on an iOS device (the iPad tablet or the iPhone device)</p></li><li style="list-style-type: disc"><p>Remote instances of the application on an Android device (a tablet or phone device running Android OS)</p></li><li style="list-style-type: disc"><p>We will briefly cover the requirements for setting up the Profiler in each of these contexts.</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl3sec16"></a>Editor or standalone instances</h4></div></div></div><p>The only way<a id="id1167" class="indexterm"></a> to access the Profiler is to launch it through the Unity Editor and <a id="id1168" class="indexterm"></a>connect it to a running instance of our application. This is the case whether we're running our game within the Editor, running a standalone application on the local or remote device, or when we wish to profile the Editor itself.</p><p>To open the Profiler, navigate to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Profiler</strong></span> within the Editor. If the Editor is already running in Play Mode, then we may see reporting data gathering in the Profiler Window:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_01_01.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip12"></a>Tip</h3><p>To profile standalone<a id="id1169" class="indexterm"></a> projects, ensure that the <span class="strong"><strong>Use Development Mode</strong></span> and <span class="strong"><strong>Autoconnect Profiler</strong></span> flags are enabled when the application is built.</p></div><p>Selecting whether to profile an Editor-based instance (through the Editor's Play Mode) or a standalone instance (separately built and running in the background) can be achieved through the <span class="strong"><strong>Active Profiler</strong></span> option<a id="id1170" class="indexterm"></a> in the Profiler window.</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_01_02.jpg" /><div class="caption"><p>The Unity Profiler</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl3sec17"></a>Editor profiling</h4></div></div></div><p>Profiling the Editor itself, such as <a id="id1171" class="indexterm"></a>profiling custom Editor Scripts, can be enabled with the <span class="strong"><strong>Profile Editor</strong></span> option in the Profiler window as shown in the following screenshot. Note that this requires the <span class="strong"><strong>Active Profiler</strong></span> option to be configured to <span class="strong"><strong>Editor</strong></span>.</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_01_12.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl3sec18"></a>The Unity Webplayer connection</h4></div></div></div><p>The Profiler can <a id="id1172" class="indexterm"></a>also connect to an instance of the Unity Webplayer that is currently running in a browser. This enables us to profile our web-based application in a more real-world scenario through the target browser, and test multiple browser types for inconsistencies in behavior.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Ensure that the <span class="strong"><strong>Use Development Mode</strong></span> flag is enabled when the Webplayer application is built.</p></li><li><p>Launch the compiled Webplayer application in a browser and, while it is active in the browser window, hold the <span class="emphasis"><em>Alt</em></span> key (<span class="emphasis"><em>Option</em></span> key on a Mac) and right-click on the Webplayer object within the browser to open the <span class="strong"><strong>Release Channel Selection</strong></span> menu. Then select the <span class="strong"><strong>Development</strong></span> channel, as shown in the<a id="id1173" class="indexterm"></a> following screenshot:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note127"></a>Note</h3><p>Note that changing the <span class="strong"><strong>Release Channel</strong></span> option will restart the Webplayer application.</p></div><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_01_13.jpg" /></div></li><li><p>As shown in the following screenshot, open the Profiler in the Unity Editor within the <span class="strong"><strong>Profiler</strong></span> window, and then navigate to <span class="strong"><strong>Active Profiler</strong></span> | <span class="strong"><strong>WindowsWebPlayer(COMPUTERNAME)</strong></span> or <span class="strong"><strong>Active Profiler</strong></span> | <span class="strong"><strong>OSXWebPlayer(COMPUTERNAME)</strong></span>, depending on the Operating System:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_01_03.jpg" /></div></li></ol></div><p>You should now <a id="id1174" class="indexterm"></a>see reporting data collecting in the Profiler window.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl3sec19"></a>Remote connection to an iOS device</h4></div></div></div><p>The Profiler<a id="id1175" class="indexterm"></a> can also be connected to an active instance of the application running remotely on an iOS device, such as an iPad or iPhone. This can be achieved through a shared WiFi connection. Follow the given steps to connect the Profiler to an Apple device:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note128"></a>Note</h3><p>Note that remote connection to an Apple device is only possible when the Profiler is running on an Apple Mac device.</p></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Ensure that the <span class="strong"><strong>Use</strong></span> <span class="strong"><strong>Development Mode</strong></span> and <span class="strong"><strong>Autoconnect Profiler</strong></span> flags are enabled when the application is built.</p></li><li><p>Connect both the iOS device and Mac to a local or ADHOC WiFi network.</p></li><li><p>Attach the iOS device to the Mac via the USB or the Lightning cable.</p></li><li><p>Begin building the application with the <span class="strong"><strong>Build &amp; Run</strong></span> option as normal.</p></li><li><p>Open the Profiler window in the Unity Editor and select the device under <span class="strong"><strong>Active Profiler</strong></span>.</p></li></ol></div><p>You should now see the iOS device's profiling data gathering in the Profiler window.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip13"></a>Tip</h3><p>The Profiler uses ports 54998 to 55511 to broadcast profiling data. Make sure these ports are available for outbound traffic if there is a firewall on the network</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl3sec20"></a>Remote connection to an Android device</h4></div></div></div><p>There are two different<a id="id1176" class="indexterm"></a> methods for connecting an Android device to the Unity Profiler: either through a WiFi connection or using the <a id="id1177" class="indexterm"></a>
<span class="strong"><strong>Android Debug Bridge</strong></span> (<span class="strong"><strong>ADB</strong></span>) tool. ADB is a suite of debugging tools that comes bundled with the Android SDK.</p><p>Follow the given steps for profiling over a WiFi connection:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Ensure that the <span class="strong"><strong>Use</strong></span> <span class="strong"><strong>Development Mode</strong></span> and <span class="strong"><strong>Autoconnect Profiler</strong></span> flags are enabled when the application is built.</p></li><li><p>Connect both the Android and desktop devices to a local WiFi network.</p></li><li><p>Attach the Android device to the desktop device via the USB cable.</p></li><li><p>Begin building the application with the <span class="strong"><strong>Build &amp; Run</strong></span> option as normal.</p></li><li><p>Open the Profiler window in the Unity Editor and select the device under <span class="strong"><strong>Active Profiler</strong></span>.</p></li></ol></div><p>You should now see the Android device's profiling data gathering in the Profiler Window.</p><p>For ADB profiling, follow the given steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>From the Windows command prompt, run the <code class="literal">adb</code> <code class="literal">devices</code> command, which checks if the device is recognized by ADB (if not, then the specific device drivers for the device may need to be installed and/or USB debugging needs to be enabled on the target device).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note129"></a>Note</h3><p>Note that, if the <code class="literal">adb</code> <code class="literal">devices</code> command isn't found when it is run from the command prompt, then the Android SDK folder may need to be appended onto the Environment's <code class="literal">PATH</code> variable.</p></div></li><li><p>Ensure that the <span class="strong"><strong>Use</strong></span> <span class="strong"><strong>Development Mode</strong></span> and <span class="strong"><strong>Autoconnect Profiler</strong></span> flags are enabled when the application is built.</p></li><li><p>Attach the Android device to the desktop device via the cable (for example, USB).</p></li><li><p>Begin building the application with the <span class="strong"><strong>Build &amp; Run</strong></span> option as normal.</p></li><li><p>Open the Profiler Window in the Unity Editor and select the device under <span class="strong"><strong>Active Profiler</strong></span>.</p></li></ol></div><p>You should now see the Android device's profiling data gathering in the Profiler window.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec136"></a>The Profiler window</h3></div></div></div><p>We will now <a id="id1178" class="indexterm"></a>cover the essential features of the Profiler as they can be found within the interface.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note130"></a>Note</h3><p>Note that this <a id="id1179" class="indexterm"></a>section covers features as they appear in the Unity Profiler within Unity 5. Additional features were added to the Profiler with the release of Unity 5; these may be different, or not exist, in Unity 4's Profiler.</p></div><p>The Profiler window is split into three main areas:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Controls</p></li><li style="list-style-type: disc"><p>Timeline View</p></li><li style="list-style-type: disc"><p>Breakdown View</p></li></ul></div><p>These areas are as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_01_04.jpg" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl3sec21"></a>Controls</h4></div></div></div><p>The top bar contains<a id="id1180" class="indexterm"></a> multiple controls we can use to affect what is<a id="id1181" class="indexterm"></a> being profiled and how deeply in the system data is gathered from. They are:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Add Profiler</strong></span>: By default, the <a id="id1182" class="indexterm"></a>Profiler shows several of Unity's engine components in the Timeline View, but the <span class="strong"><strong>Add Profiler</strong></span> option can be used to add additional items. See the <span class="emphasis"><em>Timeline View</em></span> section for a complete list of components we can profile.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Record</strong></span>: Enabling this option will make the Profiler continuously record profiling data. Note that <a id="id1183" class="indexterm"></a>data can only be recorded if Play Mode is enabled (and not paused) or if <span class="strong"><strong>Profile Editor</strong></span> is enabled.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Deep Profile</strong></span>: Ordinary profiling will only record the time and memory allocations made by any Unity callback methods, such as <code class="literal">Awake()</code>, <code class="literal">Start()</code>, <code class="literal">Update()</code>, <code class="literal">FixedUpdate()</code>, and so on. Enabling <span class="strong"><strong>Deep Profile</strong></span> recompiles our scripts to<a id="id1184" class="indexterm"></a> measure each and every invoked method. This causes an even greater instrumentation cost during runtime and uses significantly more memory since data is being collected for the entire call stack at runtime. As a consequence, Deep Profiling may not even be possible in large projects running on weak hardware, as Unity may run out of memory before testing can even begin!</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Tip</h3><p>Note that Deep Profiling requires the project to be recompiled before profiling can begin, so it is best to avoid toggling the option during runtime.</p></div><p>Because this option measures all methods across our codebase in a blind fashion, it should not be enabled during most of our profiling tests. This option is best reserved for when default profiling is not providing enough detail, or in small test Scenes, which are used to profile a small subset of game features.</p><p>If Deep Profiling is required for larger projects and Scenes, but the <span class="strong"><strong>Deep Profile</strong></span> option is too much of a hindrance during runtime, then there are alternatives that can be found in the upcoming section titled <span class="emphasis"><em>Targeted Profiling of code segments</em></span>.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Profile Editor</strong></span>: This option <a id="id1185" class="indexterm"></a>enables Editor profiling—that is, gathering profiling data for the Unity Editor itself. This is<a id="id1186" class="indexterm"></a> useful in order to profile any custom Editor Scripts we have developed.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip15"></a>Tip</h3><p>Note that <span class="strong"><strong>Active Profiler</strong></span> must be set to the <span class="strong"><strong>Editor</strong></span> option for this feature to work.</p></div></li><li style="list-style-type: disc"><p><span class="strong"><strong>Active Profiler</strong></span>: This drop-down globally<a id="id1187" class="indexterm"></a> offers choices to select the target instance of Unity we wish to profile; this, as we've learned, can be the current Editor application, a local standalone instance of our application, or an instance of our application running<a id="id1188" class="indexterm"></a> on a remote device.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Clear</strong></span>: This clears all <a id="id1189" class="indexterm"></a>profiling data from the Timeline View.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Frame Selection</strong></span>: The <span class="strong"><strong>Frame</strong></span> counter shows how many frames have been profiled, and which frame is currently selected in the Timeline View. There are two buttons to<a id="id1190" class="indexterm"></a> move the currently selected frame forward or backward by one frame, and a third button (the <span class="strong"><strong>Current</strong></span> button) that resets the selected frame to the most recent frame and keeps that position. This will cause the Breakdown View to always show the profiling data for the current frame during runtime profiling.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Timeline View</strong></span>: The<a id="id1191" class="indexterm"></a> Timeline View reveals profiling data that has been collected during runtime, organized by areas depending on which component of the engine was involved.</p><p>Each Area has multiple colored boxes for various subsections of those components. These colored boxes can be toggled to reveal/hide the corresponding data types within the Timeline View.</p><p>Each Area focuses on profiling data for a different component of the Unity engine. When an Area is selected in the Timeline View, essential information for that component will be revealed in the Breakdown View for the currently selected frame.</p><p>The Breakdown View shows very different information, depending on which Area is currently selected.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Tip</h3><p>Areas can be<a id="id1192" class="indexterm"></a> removed from the Timeline View by clicking on the '<span class="strong"><strong>X</strong></span>' at the top right of an Area. Areas can be restored to the Timeline View through the <span class="strong"><strong>Add Profiler</strong></span> option in the Controls bar.</p></div></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch25lvl5sec01"></a><span class="strong"><strong>CPU Area</strong></span></h5></div></div></div><p>This Area<a id="id1193" class="indexterm"></a> shows CPU Usage for multiple Unity subsystems during runtime, such as MonoBehaviour components, cameras, some rendering and physics processes, user interfaces (including the Editor's interface, if we're running through the Editor), audio processing, the Profiler itself, and more.</p><p>There are three ways of displaying CPU Usage data in the Breakdown View:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Hierarchy</p></li><li style="list-style-type: disc"><p>Raw Hierarchy</p></li><li style="list-style-type: disc"><p>Timeline</p></li></ul></div><p>The <span class="strong"><strong>Hierarchy Mode</strong></span> groups similar data elements and global Unity function calls together for convenience—for instance, rendering delimiters, such as <code class="literal">BeginGUI()</code> and <code class="literal">EndGUI()</code> calls are combined together in this Mode.</p><p>The <span class="strong"><strong>Raw Hierarchy Mode</strong></span> will separate global Unity function calls into individual lines. This will tend to make<a id="id1194" class="indexterm"></a> the Breakdown View more difficult to read, but may be helpful if we're trying to count how many times a particular global method has been invoked, or determining if one of these calls is costing more CPU/memory than expected. For example, each <code class="literal">BeginGUI()</code> and <code class="literal">EndGUI()</code> call will be separated into different entries, possibly cluttering the Breakdown View, making it difficult to read.</p><p>Perhaps, the most <a id="id1195" class="indexterm"></a>useful mode for the CPU Area is the <span class="strong"><strong>Timeline Mode</strong></span> option (not to be confused with the main Timeline View). This Mode organizes CPU usage during the current frame by how the call stack expanded and contracted during processing. Blocks at the top of this view were directly called by the Unity Engine (such as the <code class="literal">Start()</code>, <code class="literal">Awake()</code>, or <code class="literal">Update()</code> methods), while blocks underneath them are methods that those methods had called, which can include methods on other Components or objects.</p><p>Meanwhile, the width of a given CPU Timeline Block gives us the relative time it took to process that method compared to other blocks around it. In addition, method calls that consume relatively little processing time, relative to the<a id="id1196" class="indexterm"></a> more <span class="emphasis"><em>greedy</em></span> methods, are shown as gray boxes to keep them out of sight.</p><p>The design of the CPU Timeline Mode offers a very clean and organized way of determining which particular method in the call stack is consuming the most time, and how that processing time measures up against other methods being called during the same frame. This allows us to gauge which method is the biggest culprit with minimal effort.</p><p>For example, let's assume that we are looking at a performance problem in the following screenshot. We can tell, with a quick glance, that there are three methods that are causing a problem, and they each consume similar amounts of processing time, due to having similar widths.</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_01_05.jpg" /></div><p>In this example, the good news is that we have three possible methods through which to find performance<a id="id1197" class="indexterm"></a> improvements, which means lots of opportunities to find code that can be improved. The bad news is that increasing the performance of one method will only improve about one-third of the total processing for that frame. Hence, all three methods will need to be examined and improved in order to minimize the amount of processing time during this frame.</p><p>The CPU Area will be most useful during <a class="link" href="#" linkend="ch26">Chapter 2</a>, <span class="emphasis"><em>Scripting Strategies</em></span>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl4sec03"></a>The GPU Area</h4></div></div></div><p>The <span class="strong"><strong>GPU Area</strong></span> is similar to the<a id="id1198" class="indexterm"></a> CPU Area, except that it shows method calls and processing time as it occurs on the GPU. Relevant Unity method calls in this Area will relate to cameras, drawing, opaque and transparent geometry, lighting and shadows, and so on.</p><p>The GPU Area will be beneficial during <a class="link" href="#" linkend="ch30">Chapter 6</a>, <span class="emphasis"><em>Dynamic Graphics</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl4sec04"></a>The Rendering Area</h4></div></div></div><p>The <span class="strong"><strong>Rendering Area</strong></span> provides<a id="id1199" class="indexterm"></a> rendering statistics, such as the number of SetPass calls, the total number of Batches used to render the scene, the number of Batches saved from Dynamic and Static Batching, memory consumed for Textures, and so on.</p><p>The Rendering Area will be useful in <a class="link" href="#" linkend="ch27">Chapter 3</a>, <span class="emphasis"><em>The Benefits of Batching</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl4sec05"></a>The Memory Area</h4></div></div></div><p>The <span class="strong"><strong>Memory Area</strong></span> allows us<a id="id1200" class="indexterm"></a> to inspect memory usage of the application in the Breakdown View in two different ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Simple Mode</p></li><li style="list-style-type: disc"><p>Detailed Mode</p></li></ul></div><p>The <span class="strong"><strong>Simple Mode</strong></span> provides <a id="id1201" class="indexterm"></a> only a high-level overview of memory consumption of components such as Unity's low-level Engine, the Mono framework (total heap size that will be garbage-collected), Graphics, Audio (FMOD), and even memory used to store data collected by the Profiler.</p><p>The <span class="strong"><strong>Detailed Mode</strong></span> shows<a id="id1202" class="indexterm"></a> memory consumption of individual game objects and components, for both their native and managed representations. It also has a column explaining the reason for that object consuming memory and when it might be de-allocated.</p><p>The Memory Area will be the main focal point of <a class="link" href="#" linkend="ch31">Chapter 7</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl4sec06"></a>The Audio Area</h4></div></div></div><p>The <span class="strong"><strong>Audio Area</strong></span> grants an <a id="id1203" class="indexterm"></a>overview of audio statistics and can be used both to measure CPU usage from the audio system, as well as total memory<a id="id1204" class="indexterm"></a> consumed by <span class="strong"><strong>Audio Sources</strong></span> (for both playing and paused sources) and <a id="id1205" class="indexterm"></a>
<span class="strong"><strong>Audio Clips</strong></span>.</p><p>The Audio Area will come in handy as we explore art assets in <a class="link" href="#" linkend="ch28">Chapter 4</a>, <span class="emphasis"><em>Kickstart Your Art</em></span>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip17"></a>Tip</h3><p>Audio is often overlooked when it comes to performance enhancements, but audio can become of the biggest sources of bottlenecks if it is not managed properly. It's worth performing occasional checks on the Audio system's memory and CPU consumption during development.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch25lvl4sec07"></a>The Physics 3D/2D Area</h4></div></div></div><p>There are two<a id="id1206" class="indexterm"></a> different Physics Areas, one for 3D physics (Nvidia's PhysX) and another for the 2D physics system (Box2D) that was integrated into the Unity Engine in version 4.5. This Area provides various physics statistics such as Rigidbody, Collider, and Contact counts.</p><p>We will be making use of this Area in <a class="link" href="#" linkend="ch29">Chapter 5</a>, <span class="emphasis"><em>Faster Physics</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note131"></a>Note</h3><p>As of the publication of this text, with Unity v5.2.2f1 as the most recent version, the Physics3D Area only provides a handful of items, while the Physics2D Area provides significantly more information.</p></div></div></div></div>