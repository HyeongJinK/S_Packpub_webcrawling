<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch29lvl1sec249"></a>Physics Engine internals</h2></div></div><hr /></div><p>Unity technically features two different Physics Engines: Nvidia PhysX for 3D physics and the Open Source project Box2D for 2D physics. However, their implementation is highly abstracted, and from the perspective of the Unity API, both engines operate in a nearly identical fashion.</p><p>In either case, the more <a id="id1444" class="indexterm"></a>we understand about Unity's Physics System, the more sense we can make of possible performance enhancements. So, first we'll cover some theory about Unity's Physics Engines.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch29lvl2sec173"></a>Physics and time</h3></div></div></div><p>Physics Engines generally operate <a id="id1445" class="indexterm"></a>under the assumption that time is iterating in fixed values of time, and both of Unity's Physics Engines operate in this manner. The Physics Engine will only calculate using very specific values of time, independent<a id="id1446" class="indexterm"></a> of how much time it took to render the previous frame. This<a id="id1447" class="indexterm"></a> is known as the <a id="id1448" class="indexterm"></a>
<span class="strong"><strong>Fixed Update Timestep</strong></span>, and it is set to a value of 20 milliseconds by default, or 50 updates per second.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note144"></a>Note</h3><p>It can be very <a id="id1449" class="indexterm"></a>difficult to generate consistent results for collisions and forces between two different computers if a Physics Engine uses a variable timestep. Such engines tend to generate inconsistent results between multiplayer clients, and during recorded replays.</p></div><p>If too much time has passed between frames (a low frame rate), then the Physics System may update multiple times before rendering begins again. Conversely, if not enough time has passed since the previous render (a high frame rate), then the physics update may be skipped until after the next render call.</p><p>The <code class="literal">FixedUpdate()</code> method represents the moment when the Physics System performs simulation timestep updates. It is one of several important Unity callbacks we can define in a MonoBehaviour script and, in general, <code class="literal">FixedUpdate()</code> is used to define frame-rate-independent behavior. This callback is usually used for calculations such as artificial intelligence (which are also easier to work with if we assume a fixed update frequency), but this is also where we should modify Rigidbody objects during gameplay.</p><p>The following <a id="id1450" class="indexterm"></a>diagram shows an important snippet of the Unity Order of <a id="id1451" class="indexterm"></a>Execution diagram:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_05_03.jpg" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note145"></a>Note</h3><p>The full Order <a id="id1452" class="indexterm"></a>of Execution diagram can be found at: <a class="ulink" href="http://docs.unity3d.com/Manual/ExecutionOrder.html" target="_blank">http://docs.unity3d.com/Manual/ExecutionOrder.html</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch29lvl3sec56"></a>The Fixed Update loop</h4></div></div></div><p>As we can see, <code class="literal">FixedUpdate()</code> is invoked just prior to the Physics System performing its own update and the two <a id="id1453" class="indexterm"></a>are inextricably linked. The process begins with determining whether enough time has passed to begin the next Fixed Update. The outcome will vary depending on how much time has passed since the last Fixed Update.</p><p>If enough time has passed, then the <code class="literal">FixedUpdate()</code> method is invoked globally, and any Coroutines tied to Fixed Updates (that is, yields to <code class="literal">WaitForFixedUpdate()</code>) are handled immediately afterward, followed by physics updates and trigger/collider callbacks.</p><p>If less than 20 ms<a id="id1454" class="indexterm"></a> has gone by since the last Fixed Update, then the current Fixed Update is skipped. At this point, input, gameplay logic, and rendering must take place and complete before Unity performs the next Fixed Update check, and so on, as this process repeats itself during runtime. This design gives both Fixed Updates and the Physics System a higher priority over rendering, but forces the physics simulation into a fixed frame rate.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note146"></a>Note</h3><p>In order to ensure smooth motion during frames where physics updates are skipped, some Physics Engines (including Unity's) interpolate the state between the previous state and the current state based on how much time remains until the next Fixed Update.</p><p>This ensures that, graphically, objects appear to move smoothly during high frame rates, even though they are only being updated every 20 ms.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch29lvl3sec57"></a>Maximum Allowed Timestep</h4></div></div></div><p>It is important to note that if a lot of time has passed since the last Fixed Update (for example, the game froze momentarily), then physics and Fixed Updates will continue to be calculated until they have "caught up" with the current time. For example, if the previous frame took 100 ms to render (for example, a sudden performance spike dropping the game to 10 FPS), then the Physics System will need to update five times. The <code class="literal">FixedUpdate()</code> method will<a id="id1455" class="indexterm"></a> therefore<a id="id1456" class="indexterm"></a> be called five times before <code class="literal">Update()</code> can be called again due to the default Fixed Update Timestep of 20 ms. If, for whatever reason, the processing of these five updates consumes 20 ms or more, then it will need to invoke a sixth update!</p><p>Consequently, it's possible during moments of heavy physics activity that the Physics Engine can take more than 20 ms to complete a physics update, which itself takes another 20 ms, and so on, such that it is never able to escape and allow another frame to render (this is often known as the "spiral of death"). To prevent the Physics Engine from locking up our game during these moments, there is a maximum amount of time that the Physics Engine is allowed to process between each render. This<a id="id1457" class="indexterm"></a> threshold is called the <span class="strong"><strong>Maximum Allowed Timestep</strong></span>, and if the current Fixed Update is taking longer to process than this value, then it will simply stop and forgo further processing until the end of the next render. This design allows the rendering system to at least render the current state, and allow for gameplay logic to make some decisions during rare moments where physics calculation has gone ballistic (pun intended).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch29lvl3sec58"></a>Physics updates and runtime changes</h4></div></div></div><p>When the Physics System processes<a id="id1458" class="indexterm"></a> the next timestep, it must move any active Rigidbody objects, detect any collision, and invoke the collision callbacks on the corresponding objects. It's for exactly this reason that the Unity documentation<a id="id1459" class="indexterm"></a> explicitly warns us to only make changes to Rigidbody objects in <code class="literal">FixedUpdate()</code> and other physics callbacks. These methods are tightly-coupled with the update frequency of the Physics Engine, as opposed to other parts of the game loop, such as <code class="literal">Update()</code>.</p><p>This means that callbacks such as <code class="literal">OnTriggerEnter()</code> are safe places to make Rigidbody changes, while methods such as <code class="literal">Update()</code> and time-based Coroutines are not. Not following this advice could cause unexpected physics behavior as multiple changes are made to the same object before the Physics System is given a chance to catch and process all of them, resulting in some especially confusing gameplay bugs.</p><p>It logically follows that the more time we spend in any given Fixed Update iteration, the less time we have for the next gameplay and rendering pass. Most of the time this results in minor, unnoticeable background processing tasks, as the Physics Engine barely has any work to do, and <code class="literal">FixedUpdate()</code> callbacks have a lot of time to complete their work.</p><p>But, in some games, the Physics Engine could be performing a lot of calculations during each and every Fixed Update. This kind of bottlenecking in physics processing time will affect our rendering frame rate, causing it to plummet as the Physics System is tasked with greater and greater workloads. Essentially, the rendering system will proceed as normal, but whenever it's time for a Fixed Update, then it would be given very little time to generate the current display, causing a sudden stutter. This is in addition to the visual effect of the Physics System stopping early because it hit the Maximum Allowed Timestep. All of this together will generate a poor user experience.</p><p>Hence, to keep a smooth and consistent frame rate, the goal is to free up as much time as we can for rendering by minimizing the amount of time the Physics System takes to process any given timestep. This applies in both the best-case scenario (nothing moving) and worst-case scenario (everything smashing into everything else at once). There are a number of time-related features and values we can tweak within the Physics System to avoid performance pitfalls such as these.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch29lvl2sec174"></a>Static and Dynamic Colliders</h3></div></div></div><p>There is a rather <a id="id1460" class="indexterm"></a>significant namespace conflict <a id="id1461" class="indexterm"></a>with the<a id="id1462" class="indexterm"></a> term "static" in Unity. We have already covered static GameObjects, the various Static <a id="id1463" class="indexterm"></a>subflags, the Static Batching feature, and then there's the use of static variables and classes in C#. Meanwhile, Unity's original physics implementation for 3D objects has its own concept of Static Colliders. Later, when 2D physics was implemented, it kept the same concept of Static Colliders to keep things consistent between them.</p><p>So, with this in mind it is very important to remember that Static Colliders are not objects with the Static flag enabled, since those flags are a Unity Engine concept. Static Colliders are simply colliders that do not have an attached Rigidbody. Meanwhile, colliders with an attached Rigidbody <a id="id1464" class="indexterm"></a>are called Dynamic Colliders.</p><p>The Physics System <a id="id1465" class="indexterm"></a>combines Static Colliders into a <a id="id1466" class="indexterm"></a>different, optimized data structure, which helps to simplify future processing tasks. These objects will not react to impulses applied by objects colliding with them, but will<a id="id1467" class="indexterm"></a> prevent other objects from moving through them. This makes Static Colliders ideal for world barriers and other obstacles that must not move.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch29lvl2sec175"></a>Collision detection</h3></div></div></div><p>There are three settings for <a id="id1468" class="indexterm"></a>collision detection in Unity: <span class="strong"><strong>Discrete</strong></span>, <span class="strong"><strong>Continuous</strong></span>, and <span class="strong"><strong>ContinuousDynamic</strong></span>. The <span class="strong"><strong>Discrete</strong></span> setting effectively teleports objects a small distance every timestep based on their velocity and how much time has passed. After all the objects have been moved, it then performs a bounding-volume check for any overlaps, treats them as collisions, and resolves them based on their physical properties and how they overlap. This method risks collisions being missed if small objects are moving too quickly.</p><p>Both of the continuous collision detection methods work by interpolating objects from their starting and ending positions for the current timestep and checking for any collisions along the way. This reduces the risk of missed collisions and generates a more accurate simulation, at the expense of significantly greater CPU overhead compared to the <span class="strong"><strong>Discrete</strong></span> setting.</p><p>The <span class="strong"><strong>Continuous</strong></span> setting only enables continuous collision detection between the given collider and Static Colliders (recall that Static Colliders are simply colliders without any attached Rigidbody). The same objects will be simultaneously treated as using the <span class="strong"><strong>Discrete</strong></span> setting when it comes to collision detection with other dynamic objects (those with an attached Rigidbody). Meanwhile, the <span class="strong"><strong>ContinuousDynamic</strong></span> setting is slightly different as it enables the same continuous collision detection, but does so between the given collider and all other colliders, both Static and Dynamic.</p><p>The following screenshot shows how the discrete and continuous collision detection methods would work for a pair of small, fast-moving objects:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_05_02.jpg" /></div><p>This is an extreme example for the sake of illustration. In the discrete case, we can see that the objects are "teleporting" a distance around four times their own size in a single timestep, which would typically only happen with very small objects with very high velocities, and is hence<a id="id1469" class="indexterm"></a> very rare if our game is running optimally. In most cases, the distances the objects travel in a single 20 ms timestep are much smaller relative to the size of the object, and so the collision is easily detected.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch29lvl2sec176"></a>Collider types</h3></div></div></div><p>There are five different types of <a id="id1470" class="indexterm"></a>3D Colliders in Unity 5. In order of the lowest performance cost to the greatest, they are: <span class="strong"><strong>Sphere</strong></span>, <span class="strong"><strong>Capsule</strong></span>, <span class="strong"><strong>Cylinder</strong></span>, <span class="strong"><strong>Box</strong></span>, and <a id="id1471" class="indexterm"></a>
<span class="strong"><strong>Mesh</strong></span> Colliders. The first four collider types are considered primitives and <a id="id1472" class="indexterm"></a>maintain consistent shapes, although they can generally be scaled in different <a id="id1473" class="indexterm"></a>directions to meet certain needs. Meanwhile Mesh <a id="id1474" class="indexterm"></a>Colliders can be customized to a particular shape depending on the assigned mesh.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note147"></a>Note</h3><p>There are also three main 2D Colliders: <span class="strong"><strong>Circle</strong></span>, <span class="strong"><strong>Box</strong></span>, and <span class="strong"><strong>Polygon</strong></span>, which are functionally similar to <a id="id1475" class="indexterm"></a>Sphere, Box, and Mesh Colliders in 3D. All <a id="id1476" class="indexterm"></a>of the following information is <a id="id1477" class="indexterm"></a>essentially transferable to the equivalent 2D shape.</p></div><p>In addition, there are two varieties of Mesh Collider: convex and concave. The difference is that a concave <a id="id1478" class="indexterm"></a>shape features at least one <span class="emphasis"><em>internal</em></span> angle (an angle between two edges<a id="id1479" class="indexterm"></a> inside the shape) of greater than 180 degrees. To illustrate this, the following screenshot shows the distinguishing difference between convex and concave shapes:</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_05_05.jpg" /></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip41"></a>Tip</h3><p>An easy way<a id="id1480" class="indexterm"></a> to remember the difference between convex and concave shapes is that a concave shape has at least one "cave" within it.</p></div><p>Both Mesh Collider types <a id="id1481" class="indexterm"></a>use the same Component (a Mesh Collider!), and <a id="id1482" class="indexterm"></a>which type of Mesh Collider gets generated is toggled using the <span class="strong"><strong>Convex</strong></span> checkbox. Enabling this option will allow the object to collide with other Mesh Colliders marked as <span class="strong"><strong>Convex</strong></span>, as well as primitive shapes (Spheres, Boxes, and so on.). In addition, if the <span class="strong"><strong>Convex</strong></span> checkbox is enabled for a Mesh Collider with a concave shape, then the Physics System will automatically simplify the concave shape, generating a collider with the nearest convex shape it can. In the preceding example, if we import the concave mesh on the right, and enable the <span class="strong"><strong>Convex</strong></span> checkbox, it would generate a collider shape closer to the convex mesh on the left.</p><p>In either case, the Physics System will attempt to generate a collider that matches the shape of the attached mesh, with an upper limit of 255 vertices. If the target mesh has more vertices than this, then it will throw an error during generation of the mesh. Note that Concave Mesh Colliders with attached Rigidbody objects are not supported in Unity 5. Concave shapes can only be used as Static Colliders (for example, a collidable object in the world that doesn't move), or Trigger Volumes (for example, an oddly-shaped pool of acid).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch29lvl2sec177"></a>The Collision Matrix</h3></div></div></div><p>The Physics System features<a id="id1483" class="indexterm"></a> a Collision Matrix that defines which objects are allowed to collide with which other objects. Objects that do not fit this matrix are automatically ignored by the Physics <a id="id1484" class="indexterm"></a>System when the time comes to resolve bounding volume overlaps and collisions. This saves on physics processing during collision detection stages, and also allows the objects to move through one another without any collisions taking place.</p><p>The Collision Matrix system works through Unity's Layer system. The matrix represents every possible layer-to-layer combination that might be possible, and enabling a checkbox means that colliders in both of those layers will be checked during the collision detection phase. Note that there's no way to allow only one of the two objects to respond to the collision. If one layer can collide with another, then they must both respond to the collision (with the exception of Static Colliders, which aren't allowed to respond to collisions).</p><p>The Collision Matrix can be accessed through <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Physics</strong></span> (or <span class="strong"><strong>Physics2D</strong></span>) | <span class="strong"><strong>Layer Collision Matrix</strong></span>.</p><p>Note that we are limited to only 32 total layers for our entire project (since the Physics System uses a 32-bit bitmask to determine inter-layer collision opportunities), so we must organize our objects into sensible layers that will extend throughout the entire lifetime of the project. If, for whatever reason, 32 layers are not enough for our project, then we might need to find cunning ways to reuse layers, or remove layers that aren't necessary.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch29lvl2sec178"></a>Rigidbody active and sleeping states</h3></div></div></div><p>Every modern Physics <a id="id1485" class="indexterm"></a>Engine shares a common optimization technique whereby objects that have come to rest have their internal state changed from<a id="id1486" class="indexterm"></a> an active state to a sleeping state. While sleeping, little-to-no processor time will be spent updating the object until it has been awoken by some external force or event.</p><p>The value of measurement that is used to determine "rest" tends to vary between engines; it could be calculated using linear and rotational speed, kinetic energy, momentum, or some other physical property of the Rigidbody. In any case, if an object has not exceeded some threshold value in a short time, then the Physics Engine will assume the object will no longer need to move again until it has undergone a new collision, or a new force has been applied to it. Until then, the sleeping object will maintain its current position.</p><p>In essence, the Physics Engine is automatically culling some processing tasks for objects that have a small amount of kinetic energy. But this does not remove it entirely from the simulation. If a moving Rigidbody approaches the sleeping object, then it must still perform checks to see whether nearby objects have collided with it, which would reawaken the sleeping object, reintroducing it to the simulation for processing. The threshold value for the sleeping state can be modified under <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Sleep Threshold</strong></span>. We <a id="id1487" class="indexterm"></a>can also get a count of the total number of active Rigidbody objects from<a id="id1488" class="indexterm"></a> the Physics area of the Profiler.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch29lvl2sec179"></a>Ray and object casting</h3></div></div></div><p>Another common feature of Physics Engines is the ability to "cast" a ray from one point to another, and gather <a id="id1489" class="indexterm"></a>data about one or more of the objects in its path. It is pretty common to implement important gameplay tasks through casting and bounding-volume checks. Firing guns is typically implemented by performing raycasts from<a id="id1490" class="indexterm"></a> the player to the target location and finding any viable targets in its path (even if it's just a wall).</p><p>We can also obtain a list of targets within an explosion radius, such as from a grenade or fireball, using a <code class="literal">Physics.OverlapSphere()</code> check, and so this is typically how such area-of-effect abilities are implemented.</p><p>We can even cast entire objects forward in space, using <code class="literal">Physics.SphereCast()</code> and <code class="literal">Physics.CapsuleCast()</code>. These methods are often used if we need rays of larger sizes, or we wish to see what would be in the path of a moving character.</p></div></div>