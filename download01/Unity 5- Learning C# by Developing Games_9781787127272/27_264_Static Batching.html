<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch27lvl1sec243"></a>Static Batching</h2></div></div><hr /></div><p>Unity offers a second<a id="id1361" class="indexterm"></a> batching mechanism through Static Batching. The purpose of this feature is to grant us a way to batch nonidentical meshes of any size into a single batch with a similar goal and methodology to Dynamic Batching, but solving the problem for a different set of conditions. The essential difference between the two batching methods is that Static Batching occurs during application initialization, whereas Dynamic Batching takes place at runtime. We therefore have a lot more control over when and where Static Batching takes place.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note141"></a>Note</h3><p>Static Batching is available in all editions of Unity 5, but only in the Pro Edition of Unity 4. Unity 4 Free users will need to upgrade to the Pro Edition to make use of this feature.</p></div><p>The Static Batching<a id="id1362" class="indexterm"></a> system has its own set of requirements:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>As the name implies, the meshes must be flagged as Static</p></li><li style="list-style-type: disc"><p>Additional memory must be set aside for each mesh being statically batched</p></li><li style="list-style-type: disc"><p>The mesh instances can come from any source mesh, but they must share the same Material</p></li></ul></div><p>Let's cover each of these requirements in more detail.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch27lvl2sec158"></a>The Static flag</h3></div></div></div><p>Static Batching can only be <a id="id1363" class="indexterm"></a>applied to objects with the Static flag enabled or, more specifically, the <span class="strong"><strong>Batching Static</strong></span> sub flag (also known as StaticEditorFlags). Clicking on the down arrow next to the <span class="strong"><strong>Static</strong></span> option for a GameObject will reveal a dropdown of these StaticEditorFlags, which can alter the object's behavior for various Static processes.</p><div class="mediaobject"><img src="/graphics/9781787127272/graphics/4939_03_03.jpg" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch27lvl2sec159"></a>Memory requirements</h3></div></div></div><p>The additional memory requirement for Static Batching will vary depending on the amount of replication <a id="id1364" class="indexterm"></a>occurring within the batched meshes. Static Batching works by combining all flagged meshes into a single, large mesh, and passing it into the rendering system through a single Draw Call. If all of the meshes being statically batched are <span class="emphasis"><em>unique</em></span>, then this would cost us no additional memory usage compared to rendering the objects normally, as the same amount of memory space is required to store the meshes.</p><p>However, statically batched duplicates cost us additional memory equal to the number of meshes multiplied by the size of the original mesh. Ordinarily, rendering one, ten, or a million clones of the same object costs us the same amount of memory, because they're all referencing the same mesh data. The only difference is the transform of each object. But, because Static Batching needs to copy the data into a large buffer, complete with its transform data, this referencing is lost, and a new duplicate of the original mesh is copied into the buffer with a hard-coded transform position, regardless of whether the same mesh has already been copied in.</p><p>Therefore, using Static Batching to render 1,000 identical tree objects will cost us 1,000 times more memory than rendering the same objects normally, because each tree must be copied into the Static Batching buffer as a unique set of vertex data. This causes some significant memory consumption and performance issues if Static Batching is not used wisely.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch27lvl2sec160"></a>Material references</h3></div></div></div><p>Finally, we already know about<a id="id1365" class="indexterm"></a> sharing material references as a means of reducing Render State changes, so this requirement is fairly obvious. However, sometimes we're statically batching meshes that require multiple materials. In which case, all meshes using a different material will be grouped together in their own static batch, and again for each unique material being used.</p><p>The downside to this design feature is that, at best, Static Batching can only render all of the static meshes using a number of Draw Calls equal to the number of materials they need. But, the benefit is that we can control which meshes get batched together using different materials, effectively forcing it to start a new static batch through some cunning material duplication. This will become clear after we cover some of the Static Batching system's caveats.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch27lvl2sec161"></a>Static Batching caveats</h3></div></div></div><p>The Static Batching system is not without its drawbacks. Because of how it approaches the batching solution, by combining meshes into a single greater mesh, the Static Batching system <a id="id1366" class="indexterm"></a>has a few caveats that we need to be aware of. These concerns<a id="id1367" class="indexterm"></a> range from minor inconveniences to major drawbacks depending on the Scene:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Draw Call savings are not immediately visible from the <span class="strong"><strong>Stats</strong></span> window until runtime</p></li><li style="list-style-type: disc"><p>Static objects should not be introduced to the Scene at runtime</p></li><li style="list-style-type: disc"><p>Statically batched meshes cannot be moved from their original starting transform</p></li><li style="list-style-type: disc"><p>If any one of the statically batched meshes is visible, then the entire group will be rendered</p></li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch27lvl3sec32"></a>Edit Mode debugging of Static Batching</h4></div></div></div><p>Trying to determine the overall effect<a id="id1368" class="indexterm"></a> that Static Batching is having on our Scene can be a little tricky since nothing is being Statically Batched while in Edit Mode. All of the magic happens during Scene initialization, which can make it difficult to determine what benefits Static Batching is actually providing. This is especially true if we leave implementing this feature until late in the project lifecycle, where we can spend a lot of time launching, tweaking, and relaunching our Scene to ensure we're getting the Draw Call savings we're expecting. Consequently, it is best to start working on Static Batching optimization early in the process of building a new Scene.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch27lvl3sec33"></a>Avoiding instantiating static meshes at runtime</h4></div></div></div><p>New static objects introduced into the Scene will not be automatically combined into any existing batch by the <a id="id1369" class="indexterm"></a>Static Batching system. To do so would cause an enormous runtime overhead between recalculating the mesh and synchronizing with the rendering system, so Unity does not even attempt to do it. This restriction means we should not attempt to dynamically instantiate the statically batched content. All meshes we wish to statically batch should be present in the original Scene file.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note142"></a>Note</h3><p>Dynamic instantiation of objects can be a costly action in its own right. We will cover solutions to that problem in <a class="link" href="#" linkend="ch31">Chapter 7</a>, <span class="emphasis"><em>Masterful Memory Management</em></span>.</p></div><p>As with the previous caveat, statically batched meshes should not be moved after they have been batched, since doing so would generate a tremendous CPU overhead. The Static Batching system has already taken the original data and combined it into a new mesh object. Moving the original meshes is both impossible while the Static flag is enabled, and not even recognized by the Unity system if the flag is disabled and the object's transform is changed.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch27lvl3sec34"></a>Visibility and rendering</h4></div></div></div><p>The final caveat is perhaps the most important. If even a single vertex of a Statically Batched mesh is visible to the<a id="id1370" class="indexterm"></a> Camera, then the whole mesh will be pushed into the rendering system and processed in its entirely. We need to be smart about how we use Static Batching and <a id="id1371" class="indexterm"></a>optimize its usage to prevent us rendering a gigantic mesh each and every frame!</p><p>For example, if we have a Scene with many rooms connected together which all share the same Material, then enabling Static Batching for every room object will cause every single room to be rendered even if only a single room is visible, and even if the player is staring straight into a wall. Such Scenes would fare better using Occlusion Culling (explored in <a class="link" href="#" linkend="ch30">Chapter 6</a>, <span class="emphasis"><em>Dynamic Graphics</em></span>) to prevent nonvisible rooms from being rendered.</p><p>Meanwhile, large outdoor scenes will find it useful to duplicate Materials. This is a useful trick to force similar objects to be statically batched into different groups. Assigning identical, but duplicate Materials to different sections of the world will render them the same; however, they will be grouped separately. This would increase the number of Draw Calls, but allow us to reuse the same Texture, Material, and Shader files for the entire Scene.</p><p>Duplicating Materials can become a bit of a chore from the maintenance perspective, since any changes made to one Material must also be made to the others. Hypothetically, we might think we can accomplish this through Script by attaching a Component that automatically <a id="id1372" class="indexterm"></a>duplicates a Material and assigns it to the mesh during Scene initialization. Unfortunately, Static Batching happens too early in the initialization process for us to intercept through a custom Component such as this, so the task must be done through the Editor (a good opportunity to make use of Editor scripts).</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch27lvl2sec162"></a>Static Batching summary</h3></div></div></div><p>Static Batching is a powerful, but dangerous tool. If we don't use it wisely, we can very easily inflict performance losses <a id="id1373" class="indexterm"></a>via memory consumption and rendering costs on our application. It also takes a good amount of manual tweaking and configuration. However, it does have a significant advantage: it can be used on object sets of any size. There is essentially no limit as far as Static Batching is concerned.</p></div></div>