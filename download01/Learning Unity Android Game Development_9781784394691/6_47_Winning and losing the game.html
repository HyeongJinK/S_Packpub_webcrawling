<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec49"></a>Winning and losing the game</h2></div></div><hr /></div><p>Now that we have the <a id="id357" class="indexterm"></a>ability to move around and reset if we fall off the map, we just need some way to win or lose the game. This particular type of game is <a id="id358" class="indexterm"></a>traditionally tracked by how fast you are able to get from one end of the map to the other. If you fail to reach the end before the timer runs out, it is game over. Let's use these steps to create a finish line and a timer for our game:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We need a new script named <code class="literal">VictoryVolume</code>.</p></li><li><p>It starts with a pair of variables for tracking the messages for our player. The first will be turned on and shown to the player if they reach the end within the time limit. The second will only display if they run out of time:</p><div class="informalexample"><pre class="programlisting">public GameObject victoryText;
public GameObject outOfTimeText;</pre></div></li><li><p>The next variable will track the <code class="literal">Text</code> object in the GUI to display the current amount of time left to complete the level:</p><div class="informalexample"><pre class="programlisting">public Text timer;</pre></div></li><li><p>This variable is for setting how much time, in seconds, is available for a player to complete the level. When adjusting this in the <span class="strong"><strong>Inspector</strong></span> panel for a larger version of the game, it is a good idea to have several people test the level in order to get a feel of how long it takes to complete:</p><div class="informalexample"><pre class="programlisting">public float timeLimit = 60f;</pre></div></li><li><p>Our last variable for the script will simply track whether or not our timer can actually count down. By making it <code class="literal">private</code> and defaulting it to <code class="literal">true</code>, the timer will always start counting from the moment the level loads:</p><div class="informalexample"><pre class="programlisting">private bool countDown = true;</pre></div></li><li><p>The first function for this script is <code class="literal">Awake</code>, which is the best location for initialization. The only thing it does is turn off both of the messages. We will turn on the appropriate one later, based on how our player performs:</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  victoryText.SetActive(false);
  outOfTimeText.SetActive(false);
}</pre></div></li><li><p>To detect when the player has crossed the finish line, we will be using the same <code class="literal">OnTriggerEnter</code> function that we used for the <code class="literal">KillVolume</code> script. Here, however, we will first check to make sure that we are still timing the player. If we are no longer timing them, they must have run out of time and lost. Therefore, we should not let them cross the finish line and win:</p><div class="informalexample"><pre class="programlisting">public void OnTriggerEnter(Collider other) {
  if(countDown) {</pre></div></li><li><p>Next, we turn <a id="id359" class="indexterm"></a>on the text that tells the player that they have won. We have to let them know at some point, so it might as well be now:</p><div class="informalexample"><pre class="programlisting">victoryText.SetActive(true);</pre></div></li><li><p>The next thing the function does is essentially turn the physics off for the monkey ball to stop it from rolling around. By using <code class="literal">attachedRigidbody</code>, we gain access to the <span class="strong"><strong>Rigidbody</strong></span> component, which is the part hooking it into Unity's physics engine that is attached to the object. Then, we set its <code class="literal">isKinematic</code> property to <code class="literal">true</code>, essentially telling it that it will be controlled by the script and <a id="id360" class="indexterm"></a>not by the physics engine:</p><div class="informalexample"><pre class="programlisting">other.attachedRigidbody.isKinematic = true;</pre></div></li><li><p>Finally, the function stops counting the player's time:</p><div class="informalexample"><pre class="programlisting">countDown = false;
}
}</pre></div></li><li><p>The last function for this script is the <code class="literal">Update</code> function, which first checks to make sure that the timer is running:</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(countDown) {</pre></div></li><li><p>It then removes the time since the last frame, from the time remaining to complete the level:</p><div class="informalexample"><pre class="programlisting">timeLimit -= Time.deltaTime;</pre></div></li><li><p>Next, we update the time on screen with the amount of time that remains. The text on the screen must be in the form of a string, or words. A number, such as our remaining time, is not a word, so we use the <code class="literal">ToString</code> function on it to convert it into the right datatype for it to be displayed. Leaving it at that would have been fine, but it would have displayed a bunch of extra decimal places that the player wouldn't have even cared about. Therefore, <code class="literal">0.00</code> is passed to the function. We are telling it what format and how many decimal places we want the number to have when it becomes a word. This makes it more meaningful to our players and much easier to read:</p><div class="informalexample"><pre class="programlisting">timer.text = timeLimit.ToString("0.00");</pre></div></li><li><p>After checking to see whether the player is out of time, we turn on the text that tells them that they have lost and turn off the time display. We also stop counting the time. If they are already out of time, what is the point in counting?</p><div class="informalexample"><pre class="programlisting">if(timeLimit &lt;= 0) {
  outOfTimeText.SetActive(true);
  timer.gameObject.SetActive(false);
  countDown = false;
}
}
}</pre></div></li><li><p>Now, we <a id="id361" class="indexterm"></a>need to return to Unity and make this script <a id="id362" class="indexterm"></a>work. Do this by first creating a new empty<span class="strong"><strong> GameObject</strong></span> and naming it <code class="literal">VictoryPoint</code>.</p></li><li><p>It is going to need three cubes as children. Remember, you can find them by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Cube</strong></span>.</p></li><li><p>The first cube should be positioned at <code class="literal">1</code> for <span class="strong"><strong>X</strong></span>, <code class="literal">1</code> for <span class="strong"><strong>Y</strong></span>, and <code class="literal">0</code> for <span class="strong"><strong>Z</strong></span>. In addition, give it a scale of <code class="literal">0.25</code> for <span class="strong"><strong>X</strong></span>, <code class="literal">2</code> for <span class="strong"><strong>Y</strong></span>, and <code class="literal">0.25</code> for <span class="strong"><strong>Z</strong></span>.</p></li><li><p>The second cube should have all of the same settings as the first one, except for having a position of <code class="literal">-1</code> for <span class="strong"><strong>X</strong></span>, which moves it to the opposite side of the object.</p></li><li><p>The last cube needs a position of <code class="literal">0</code> for <span class="strong"><strong>X</strong></span>, <code class="literal">2.5</code> for <span class="strong"><strong>Y</strong></span>, and <code class="literal">0</code> for <span class="strong"><strong>Z</strong></span>. Its scale needs to be set as <code class="literal">2.25</code> for <span class="strong"><strong>X</strong></span>, <code class="literal">1</code> for <span class="strong"><strong>Y</strong></span>, and <code class="literal">0.25</code> for <span class="strong"><strong>Z</strong></span>. Together, these three cubes give us a basic-looking finish line, which will stand out from the rest of the game board.</p></li><li><p>Next, we are going to need some text objects for the GUI. Create three of them, by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Text</strong></span>.</p></li><li><p>The first should be named <code class="literal">Timer</code>; this will handle the display, showing how much time remains for the player to reach the finish line. It needs to be anchored to the <span class="strong"><strong>top-left</strong></span> with a position of <code class="literal">80</code> for <span class="strong"><strong>Pos X</strong></span> and <code class="literal">-20</code> for <span class="strong"><strong>Pos Y</strong></span>. It also needs a value of <code class="literal">130</code> for <span class="strong"><strong>Width</strong></span> and a value of <code class="literal">30</code> for <span class="strong"><strong>Height</strong></span>. We can also change the default text to <code class="literal">0.00</code> so that we have a better idea of how it will look in the game. A <span class="strong"><strong>Font Size</strong></span> value of <code class="literal">20</code> and <span class="strong"><strong>Alignment</strong></span> of <span class="strong"><strong>left-center</strong></span> will position it well for us.</p></li><li><p>The second text object should be named <code class="literal">Victory</code>; it will display the message shown when the player reaches the finish line. It needs to be anchored in <span class="strong"><strong>middle-center</strong></span> with a position of <code class="literal">0</code> for <span class="strong"><strong>Pos X</strong></span> and <span class="strong"><strong>Pos Y</strong></span>. It needs a value of <code class="literal">200</code> for <span class="strong"><strong>Width</strong></span> and a value of <code class="literal">60</code> for <span class="strong"><strong>Height</strong></span> so that we will have enough space to draw the message. Change the default text to <code class="literal">You Win!</code>, increase <span class="strong"><strong>Font Size</strong></span> to <code class="literal">50,</code> and select <span class="strong"><strong>middle-center</strong></span> for <span class="strong"><strong>Alignment</strong></span> so that we get a nice, big message in the center of the screen.</p></li><li><p>The last text object should be named <code class="literal">OutOfTime</code>; it will display the message when the player fails to reach the end, before the timer runs down. It shares all the same settings as the previous one, except it needs a value of <code class="literal">500</code> for <span class="strong"><strong>Width</strong></span> to fit its larger default text of <code class="literal">You Ran Out Of Time!</code>.</p></li><li><p>Next, we <a id="id363" class="indexterm"></a>need to select <code class="literal">VictoryPoint</code> and give it a <span class="strong"><strong>BoxCollider</strong></span> component, as well as our <code class="literal">VictoryVolume</code> script.</p></li><li><p>The <span class="strong"><strong>BoxCollider</strong></span> component is going to need the <span class="strong"><strong>Is Trigger</strong></span> box to be checked. It needs a value of <code class="literal">0</code> for <span class="strong"><strong>X</strong></span>, <code class="literal">1</code> for <span class="strong"><strong>Y</strong></span>, and <code class="literal">0</code> for <span class="strong"><strong>Z</strong></span> for <span class="strong"><strong>Center</strong></span>. In addition, <span class="strong"><strong>Size</strong></span> should be <code class="literal">1.75</code> for <span class="strong"><strong>X</strong></span>, <code class="literal">2</code> for <span class="strong"><strong>Y</strong></span>, and <code class="literal">0.25</code> for <span class="strong"><strong>Z</strong></span>.</p></li><li><p>Finally, drag each of the text objects that we just created to the appropriate slot on the <span class="strong"><strong>VictoryVolume</strong></span> script component.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_06_07.jpg" /></div></li></ol></div><p>We've just finished putting together a means by which the player can either win or lose the game. If you were to try it out now, you should be able to see the timer tick down in the top-left corner of the screen. When you manage to reach the finish line in time, a nice message is displayed indicating this. If you are not quite as successful in reaching it, a different message is displayed.</p><p>This is the entire <a id="id364" class="indexterm"></a>interface that we will be creating for this game, but it is still awfully bland. Use your skills from what you learned in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Looking Good – The Graphical Interface</em></span> to style the interface. It should look pleasing and exciting, perhaps even monkey-themed. To get extra fancy, you could try to set it up to change <a id="id365" class="indexterm"></a>colors and size as the remaining time approaches zero, giving the player an indication at a glance of where they stand in terms of the time remaining to complete that level.</p><p>The finish line also looks boring, as it is made only out of cubes. Try your hand at creating a new one. It could have some sort of finish line banner across it, like they have in races. Maybe it could be a little more round-looking. If you wanted to get really fancy, you could look at creating a second timer that would exist at the front of the finish line. It would allow the player to look at the world, where most of their focus will be, and know what their remaining time is.</p></div>