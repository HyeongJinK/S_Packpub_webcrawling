<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec55"></a>Characters</h2></div></div><hr /></div><p>Having a <a id="id410" class="indexterm"></a>bunch of generic blocks is just the beginning of this game. Next, we are going to create a few characters to add some life to the game. We are going to need some evil pigs to destroy and some good birds to throw at them.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec43"></a>Creating the enemy</h3></div></div></div><p>Our first<a id="id411" class="indexterm"></a> character will be the enemy pig. On their own, they don't actually do anything. So, they are really just the wooden blocks we made earlier that happen to look like pigs. To make their destruction the goal of the game, however, we <a id="id412" class="indexterm"></a>are going to expand our <code class="literal">LevelTracker</code> script to watch them and trigger a <span class="strong"><strong>Game Over</strong></span> event if they are all destroyed. We will also expand the script to update the score on the screen and make it save the score for later use. Unlike our planks, which are cubes that we can only see one side of, pigs are created as flat textures and are used as sprites by Unity's 2D pipeline. Let's get started with these steps to create the pigs for our <span class="emphasis"><em>Angry Birds</em></span> game:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The pigs are created in a manner similar to that of the wood planks; however, they use a special 2D object called a sprite. A sprite is really just a flat object that always looks at the screen. Most 2D games are made with just a series of sprites for all the objects. You can create one by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>2D Object</strong></span> | <span class="strong"><strong>Sprite</strong></span>. Name it <code class="literal">Pig</code>.</p></li><li><p>To make your new sprite look like a pig, drag the <code class="literal">pig_fresh</code> image from the <span class="strong"><strong>Project</strong></span> panel and drop it into the <span class="strong"><strong>Sprite</strong></span> slot of the <span class="strong"><strong>Sprite Renderer</strong></span> component.</p></li><li><p>Next, add a <span class="strong"><strong>Circle Collider 2D</strong></span> component and a <span class="strong"><strong>Rigidbody 2D</strong></span> component. The <span class="strong"><strong>Circle Collider 2D</strong></span> component works just like the <span class="strong"><strong>Sphere Collider</strong></span> components we have used previously but is optimized for working in a 2D game.</p></li><li><p>Before we can<a id="id413" class="indexterm"></a> use our pigs in the game, we need to update the <code class="literal">Plank</code> script so that it can handle the changing of sprite images as well as materials. So, we open it up and add a variable at the beginning. This variable simply keeps track of which sprite to change to:</p><div class="informalexample"><pre class="programlisting">public Sprite damageSprite;</pre></div></li><li><p>Next, we <a id="id414" class="indexterm"></a>need to add a small part to the end of our <code class="literal">SwapToDamaged</code> function. This <code class="literal">if</code> statement checks whether a sprite is available to change into. If it is, we convert our generic renderer variable into <code class="literal">SpriteRenderer</code> so that we can get access to the <code class="literal">sprite</code> variable on it, and update to our new image:</p><div class="informalexample"><pre class="programlisting">if(damageSprite != null) {
  SpriteRenderer spriteRend = plankRenderer as SpriteRenderer;
  spriteRend.sprite = damageSprite;
}</pre></div></li><li><p>Add the <code class="literal">Plank</code> script to the pig and fill in the <span class="strong"><strong>Plank Renderer</strong></span> slot with the <span class="strong"><strong>Sprite Renderer</strong></span> component. Also, put the <code class="literal">pig_damage</code> image in the <span class="strong"><strong>Damage Sprite</strong></span> slot. By changing this script a little, we will be able to save ourselves a lot of trouble later, when we may perhaps want to track the destruction of more than just pigs.</p></li><li><p>Now, turn the pig into a prefab and add it to your structure. Remember that you need to leave them at zero on the <span class="emphasis"><em>z</em></span> axis, but feel free to adjust their size, health and score values to give them some variety.</p></li><li><p>Next, we need to expand the <code class="literal">LevelTracker</code> script. Open it up and we can add some more code.</p></li><li><p>First, we need to add a line at the very beginning of the script, so we can edit the text displayed in our GUI. Just like we have done previously, add this line at the very top of the script, where the other two lines that begin with <code class="literal">using</code> are:</p><div class="informalexample"><pre class="programlisting">using UnityEngine.UI;</pre></div></li><li><p>We will next add some more variables at the beginning of the script. The first one, as its name suggests, will hold a list of all the pigs in our scene. The next is a flag for signaling that the game has ended. We also have three <code class="literal">Text</code> variables, so we can update the player's score while they are playing, tell them why the game ended, and what their final score was. The last variable will allow you to turn on and turn off the final screen, where we tell the player whether or not they won:</p><div class="informalexample"><pre class="programlisting">public Transform[] pigs = new Transform[0];

private gameOver = false;

public Text scoreBox;
public Text finalMessage;
public Text finalScore;

public GameObject finalGroup;</pre></div></li><li><p>Next, we <a id="id415" class="indexterm"></a>need to add a line to the <code class="literal">Awake</code> function. This simply makes sure that the group of GUI objects that tell the player how the game ended are turned off when the game starts:</p><div class="informalexample"><pre class="programlisting">FinalGroup.SetActive(false);</pre></div></li><li><p>In the <code class="literal">LateUpdate</code> function, we first check whether the game has ended. If it hasn't, we call <a id="id416" class="indexterm"></a>another function to check whether all the pigs have been destroyed. We also update the display of the player's score, both while they are playing and for the game over screen:</p><div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  if(!gameOver) {
    CheckPigs();

    scoreBox.text = "Score: " + score;
    finalScore.text = "Score: " + score;
  }
}</pre></div></li><li><p>Next, we add the <code class="literal">CheckPigs</code> function. This function loops through the list of pigs to see whether they are all destroyed. Should it find one that hasn't been destroyed, it exits the function. Otherwise, the game is flagged as being over and the player is given a message. We also turn off the in-game score and turn on the game over a group of GUI objects:</p><div class="informalexample"><pre class="programlisting">private void CheckPigs() {
  for(int i=0;i&lt;pigs.Length;i++) {
    if(pigs[i] != null) return;
  }

  gameOver = true;
  finalMessage.text = "You destroyed the pigs!";

  scoreBox.gameObject.SetActive(false);
  finalGroup.SetActive(true);
}</pre></div></li><li><p>The <code class="literal">OutOfBirds</code> function<a id="id417" class="indexterm"></a> will be called by the slingshot we are going to create later, when the player runs out of birds to launch at the pigs. If the game has not yet <a id="id418" class="indexterm"></a>ended, the function ends the game and sets an appropriate message for the player. It also turns off the in-game score and turns on the game over a group of GUI objects, just like the previous function:</p><div class="informalexample"><pre class="programlisting">public void OutOfBirds() {
  if(gameOver) return;

  gameOver = true;
  finalMessage.text = "You ran out of birds!";

  scoreBox.gameObject.SetActive(false);
  finalGroup.SetActive(true);
}</pre></div></li><li><p>Finally, we have the <code class="literal">SaveScore</code> function. Here, we use the <code class="literal">PlayerPrefs</code> class. It lets you easily store and retrieve small amounts of data, perfect for our current needs. We just need to provide it with a unique key to save the data under. For this, we use a short string combined with the level's index, as provided by <code class="literal">Application.loadedLevel</code>. Next, we use <code class="literal">PlayerPrefs.GetInt</code> to retrieve the last score that was saved. If there isn't one, the zero that we passed to the function is returned as a default value. We compare the new score with the old score and use <code class="literal">PlayerPrefs.SetInt</code> to save the new score, if it is higher. Finally, the <code class="literal">Application.LoadLevel</code> function can be used to load any other scene in our game. All the scenes you intend to load have to be added to the <span class="strong"><strong>Build Settings</strong></span> window, found in the <span class="strong"><strong>File</strong></span> menu, and can be loaded by using either their name or their index, as shown here:</p><div class="informalexample"><pre class="programlisting">public void SaveScore() {
  string key = "LevelScore" + Application.loadedLevel;
  int previousScore = PlayerPrefs.GetInt(key, 0);
  if(previousScore &lt; score) {
    PlayerPrefs.SetInt(key, score);
  }

  Application.LoadLevel(0);
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>Note that using <code class="literal">PlayerPrefs</code> is by far the easiest method of storing saved information in Unity. However, it is not the most secure. If you have experience changing values in the registry of your computer, you can easily find and make changes to these <code class="literal">PlayerPrefs</code> values from outside the game. This by no means makes it a bad path for storing game information. You should just be aware of it in case you ever make a game and wish to prevent the player from hacking and changing values in their game saves.</p></div></li><li><p>Next, we <a id="id419" class="indexterm"></a>need to create some GUI objects so that our player can see how they are doing in the game. Remember that you can find them by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span>. We are going to need three text objects, a button, and a panel.</p></li><li><p>The first <a id="id420" class="indexterm"></a>text object should be named <code class="literal">Score</code>. It will display the player's points while the level is in progress. Anchor and position it in the top-left corner of the <span class="strong"><strong>Canvas</strong></span> area.</p></li><li><p>The button needs to be a child of the panel. It should be anchored to the center of the screen and positioned just below it. Also, change the text of the button to something meaningful; <code class="literal">Return to Level Select</code> will work well here.</p></li><li><p>For <span class="strong"><strong>On Click</strong></span>, we need to click on the plus sign to add a new event. Select the <code class="literal">SaveScore</code> function of the <code class="literal">LevelTracker</code> script. Otherwise, we will not be able to record the player's high score and leave the level.</p></li><li><p>The last two text objects should also be made children of the panel. Name one of them <code class="literal">Message</code>; it will tell our player why the level ended. The other should be named <code class="literal">FinalScore</code>, displaying the player's score when they are finished. They both need to be anchored to the center of the screen as well. Position the <code class="literal">FinalScore</code> object above the button, and the message above that.</p></li><li><p>Finally, all the pig objects in our scene need to be added to the <code class="literal">LevelTracker</code> script's list by dragging and dropping each pig in the <code class="literal">Pigs</code> value under the <span class="strong"><strong>Inspector</strong></span> window. Also, put each text object into its slot and the panel into the <span class="strong"><strong>Final Group</strong></span> slot.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_07_03.jpg" /></div></li></ol></div><p>We created the pigs <a id="id421" class="indexterm"></a>and <a id="id422" class="indexterm"></a>updated our <code class="literal">LevelTracker</code> script to track them. The pigs are really just like the planks of wood, but they are circles instead of boxes. The updated <code class="literal">LevelTracker</code> script watches for the instance when all the pigs are destroyed and triggers a <span class="strong"><strong>Game Over</strong></span> screen when they are. It also draws the score while the game is being played and saves this score when the level is over.</p><p>Our game doesn't quite<a id="id423" class="indexterm"></a> work yet, but that doesn't mean it has to to look like the defaults that Unity provides. Use your skills from the previous chapters to make<a id="id424" class="indexterm"></a> the interface elements that you have look better. Even just a change in the font will make a world of difference to how our game looks. Perhaps even try changing the background image of <code class="literal">Panel</code>, to add that last bit of flare to our game over screen.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec44"></a>Creating the ally</h3></div></div></div><p>Next, we<a id="id425" class="indexterm"></a> need something to throw at the pigs and their fortifications. Here, we will create the simplest of birds. The red bird is essentially just a rock. It has no special powers and there is nothing particularly special about its code, besides health. You will also notice that the bird is a 3D model, giving it the shadows that the pigs are missing. Let's use these <a id="id426" class="indexterm"></a>steps to create the red bird:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The red bird is another 3D model, so it is set up in a manner similar to that of the planks. Create an empty <span class="strong"><strong>GameObject</strong></span>, naming it <code class="literal">Bird_Red</code>, and add the appropriate model from the <code class="literal">birds</code> model as a child, zeroing out its position and scaling it as needed to make it about a single unit across. The model should be rotated to align it along the <span class="emphasis"><em>x</em></span> axis. If turned a little more toward the camera, the player is able to see the bird's face while still giving the impression of looking down the field of play.</p></li><li><p>Next, give it a <span class="strong"><strong>Circle Collider 2D</strong></span> component and a <span class="strong"><strong>Rigidbody 2D</strong></span> component.</p></li><li><p>Now, we need to create a new script named <code class="literal">Bird</code>. This script will be a base for all our birds, tracking their health and triggering their special powers when appropriate.</p></li><li><p>The script starts with three variables. The first will keep track of the bird's current health. The second is a flag, so the bird will only use its special power once. It is marked as <code class="literal">protected</code> so that all our birds can use it while protecting it from interference from outside sources. The last will hold a reference to our <span class="strong"><strong>Rigidbody</strong></span> component:</p><div class="informalexample"><pre class="programlisting">public float health = 50;
protected bool didSpecial = false;
public Rigidbody2D body;</pre></div></li><li><p>The <code class="literal">Update</code> function does three checks before activating the bird's special power. First, it checks whether it has already been done and then whether the screen has been touched. We can easily check whether any amount of touching has been done in this frame by checking the left mouse button, which Unity triggers <a id="id427" class="indexterm"></a>if we touch our screen. Finally, it checks whether the bird has a <span class="strong"><strong>Rigidbody</strong></span> component and whether it is being controlled by another script:</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(didSpecial) return;
  if(!Input.GetMouseButtonDown(0)) return;
  if(body == null || body.isKinematic) return;

  DoSpecial();
}</pre></div></li><li><p>In the <a id="id428" class="indexterm"></a>case of the red bird, the <code class="literal">DoSpecial</code> function only sets its flag to <code class="literal">true</code>. It is marked as <code class="literal">virtual</code> so that we can override the function for the other birds and make them do some fancy things:</p><div class="informalexample"><pre class="programlisting">protected virtual void DoSpecial() {
  didSpecial = true;
}</pre></div></li><li><p>The <code class="literal">OnCollisionEnter2D</code> function works in a similar way to that of the planks, subtracting health based on the strength of the collision and destroying the bird if it runs out of health:</p><div class="informalexample"><pre class="programlisting">public void OnCollisionEnter2D(Collision2D collision) {
  health -= collision.relativeVelocity.magnitude;
  if(health &lt; 0)
    Destroy(gameObject);
}</pre></div></li><li><p>Return to Unity and add the script to the <code class="literal">Bird_Red</code> object.</p></li><li><p>Complete the bird's creation by turning it into a prefab and deleting it from the scene. The slingshot we will be creating next will handle the creation of the birds when the game starts.</p></li></ol></div><p>We created the red bird. It is set up just like our other physics objects. We also created a script to handle the bird's health. This script will be expanded later when we create the other birds for our game.</p></div></div>