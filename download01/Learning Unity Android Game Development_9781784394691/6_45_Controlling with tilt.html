<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec47"></a>Controlling with tilt</h2></div></div><hr /></div><p>Modern mobile <a id="id339" class="indexterm"></a>devices provide a broad variety of internal sensors to detect and provide information about the surrounding world. Though you may not have thought of them in such a way, you must be certainly very familiar with the <a id="id340" class="indexterm"></a>microphone and speaker that are required for making calls. There is also a Wi-Fi receiver for connecting to the Internet and a camera for taking pictures. In addition, your device almost certainly has a magnetometer, to work with your GPS and provide directions.</p><p>The sensor that we are <a id="id341" class="indexterm"></a>interested in right now is the <span class="strong"><strong>gyroscope</strong></span>. This sensor detects local rotation of the device. In general, it is one of the many sensors in your phone that is used to determine the orientation and movement of the device in the world. We are going to use it to steer our monkey. When the user tilts their device left and right, the monkey will move left and right. When the device is tilted up and down, the monkey will go forward and backward. With these steps, we can create the script that will let us control our monkey in this manner:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To start this off, create a new script and name it <code class="literal">MonkeyBall</code>.</p></li><li><p>Our first variable will hold a reference to the <span class="strong"><strong>Rigidbody</strong></span> component that will be attached to the ball. This is what will allow us to actually make it roll around and collide with the things in the world:</p><div class="informalexample"><pre class="programlisting">public Rigidbody body;</pre></div></li><li><p>The next two variables will let us control how the tilting of the device affects the movement in the game. The first will allow us to get rid of any movements that are too small. This lets us avoid random movements from the environment or a sensor that perhaps isn't entirely accurate. The second will let us scale the tilt input up or down in case the control feels either sluggish and slow or uncontrollably fast:</p><div class="informalexample"><pre class="programlisting">public float minTilt = 5f;
public float sensitivity = 1f;</pre></div></li><li><p>The last variable for now will keep track of how much the device has been tilted. It forces the user to tilt their device back and forth, countering movement if they want to go in the opposite direction:</p><div class="informalexample"><pre class="programlisting">private Vector3 totalRotate = Vector3.zero;</pre></div></li><li><p>Our very first function for this script is nice and short. In order to get input from the gyroscope, we must first turn it on. We will do this in the <code class="literal">Awake</code> function so that we can start tracking it at the very beginning of the game:</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  Input.gyro.enabled = true;
}</pre></div></li><li><p>The next function for our script will be <code class="literal">Update</code>. It starts by grabbing the value of <code class="literal">rotationRate</code> from the gyroscope. This is a value in radians per second, indicating how fast the user has tilted their device along each axis. To make it a little more understandable, we multiply the value of <code class="literal">rotationRate</code> by <code class="literal">Mathf.Rad2Deg</code> to convert it into degrees per second before we store it in a variable:</p><div class="informalexample"><pre class="programlisting">public void Update() {
  Vector3 rotation = Input.gyro.rotationRate * Mathf.Rad2Deg;</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>When <a id="id342" class="indexterm"></a>holding your device with the screen facing you, the <span class="emphasis"><em>x</em></span> axis of your device points to the right. The <span class="emphasis"><em>y</em></span> axis is straight up, at the top of the device and the <span class="emphasis"><em>z</em></span> axis points directly towards you from the center of the screen.</p></div></li><li><p>Next, we make sure that there is enough movement along each axis to actually make our monkey move. By using <code class="literal">Mathf.Abs</code> on each value, we find the absolute value of the axis movement. We then compare it to the minimum amount of tilt that we are looking for. If the movement is too little, we zero it out in our <code class="literal">rotation</code> variable:</p><div class="informalexample"><pre class="programlisting">if(Mathf.Abs(rotation.x) &lt; minTilt) rotation.x = 0;
if(Mathf.Abs(rotation.y) &lt; minTilt) rotation.y = 0;
if(Mathf.Abs(rotation.z) &lt; minTilt) rotation.z = 0;</pre></div></li><li><p>Finally, for our <code class="literal">Update</code> function, we track the new movement by adding it to our <code class="literal">totalRotate</code> variable. To do this properly, we need to rearrange the values. The player expects to be able to tilt the top of their device towards them to go backwards and away to go forwards. This is the <span class="emphasis"><em>x</em></span> axis movement, but it comes in backwards from our device compared to what we need to move the monkey, hence the negative sign before the value. Next, we swap the <span class="emphasis"><em>y</em></span> and <span class="emphasis"><em>z</em></span> axes' rotation because the player is going to expect to tilt their device left and right to go left and right, which is a <span class="emphasis"><em>y</em></span> axis movement. If we applied that to the <span class="emphasis"><em>y</em></span> axis of our monkey, he would just spin in place. So, the movement is treated to be speed per second rather than speed per frame; we have to multiply by <code class="literal">Time.deltaTime</code>:</p><div class="informalexample"><pre class="programlisting">TotalRotate += new Vector3(-rotation.x, rotation.z, -rotation.y) * Time.deltaTime;
}</pre></div></li><li><p>The last function for now is the <code class="literal">FixedUpdate</code> function. When making changes to and dealing with rigidbodies, it is best to do it in <code class="literal">FixedUpdate</code>. The rigidbody is what actually connects us into Unity's physics engine, and it only updates during this function. All we are doing here is adding some torque, or rotational force, to the rigidbody. We use the total that we have been collecting and multiply it by our <code class="literal">sensitivity</code> to give our players the speed of control that they will expect:</p><div class="informalexample"><pre class="programlisting">public void FixedUpdate() {
  body.AddTorque(totalRotate * sensitivity);
}</pre></div></li><li><p>In order to make use of our new script, we need to make some changes to the ball. Start by creating a sphere for us to work with; this can be found by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Sphere</strong></span>. Rename it as <code class="literal">MonkeyBall</code> and position it a little above our <span class="strong"><strong>Ground</strong></span> cube.</p></li><li><p>Next, give it the <code class="literal">Ball.psd</code> texture in a material so that we can see it rotate and not just move. The two-tone nature of the texture will let us easily see it roll around the scene.</p></li><li><p>The <span class="strong"><strong>Rigidbody</strong></span> component can be found by navigating to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Rigidbody</strong></span> at the top of Unity. Add a new <span class="strong"><strong>Rigidbody</strong></span> component.</p></li><li><p>In addition, add our <code class="literal">MonkeyBall</code> script to the sphere and drag the new <span class="strong"><strong>Rigidbody</strong></span> component to the <span class="strong"><strong>Body</strong></span> slot in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>This is the point <a id="id343" class="indexterm"></a>where it is especially important to have <span class="strong"><strong>Unity Remote</strong></span>. With your device attached and <span class="emphasis"><em>Unity Remote</em></span> running, you can hold it up and steer the ball. Feel free to adjust the sensitivity and minimum tilt until you find settings that feel natural to control. Due to the great variety of devices, their hardware, and the architecture used, the rate of tilt can easily differ from one device to the next. However, especially at this stage, you must find settings that work for your device now and worry about what will work for other devices once the game is more complete.</p></li><li><p>If you are having trouble seeing the ball roll around, move the camera so that you have a better view. However, make sure that it continues to point forward along the world's <span class="emphasis"><em>z</em></span> axis.</p></li><li><p>Once all your settings are in place, ensure that you save the scene. Name it <code class="literal">MonkeyBall</code>.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_06_02.jpg" /></div></li></ol></div><p>We made use of the gyroscope to provide you with the steering control of a ball. By measuring how the <a id="id344" class="indexterm"></a>player is tilting his or her device, we are able to add motion to the ball accordingly. By rolling around a simple map, we can fine-tune our controls and make sure everything is working correctly.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec37"></a>Following with the camera</h3></div></div></div><p>To really make the <a id="id345" class="indexterm"></a>player feel like they are controlling the ball, the camera needs to follow it around. This is particularly necessary when the maps and levels become larger and more complex than what can be shown in a single camera shot. The simplest solution would be to just make the camera a child of the ball, but that will make it spin with the ball and our controls will become confusing as well. So, let's use these steps to set up our camera to follow the ball around:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We need to first create a new script and name it <code class="literal">CameraFollow</code>.</p></li><li><p>This script is really simple. It has a single variable to keep track of what is being followed:</p><div class="informalexample"><pre class="programlisting">public Transform ball;</pre></div></li><li><p>The only function in the script is the <code class="literal">LateUpdate</code> function. We use this function because it executes after everything else has had a chance to do their normal update. The only thing the script is going to do is move to the new position of the ball:</p><div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  transform.position = ball.position;
}</pre></div></li><li><p>To make use of <a id="id346" class="indexterm"></a>this script, we need a new empty <span class="strong"><strong>GameObject</strong></span> component. Name it <code class="literal">CameraPivot</code>.</p></li><li><p>Position it at (approximately) the center of the ball. This is the point that will actually move to follow the ball around. At this point, the created <span class="strong"><strong>GameObject</strong></span> doesn't have to be perfectly positioned; it just needs to be close enough so that it's easier to line up the camera.</p></li><li><p>Next, find the <code class="literal">Main Camera</code> in the <span class="strong"><strong>Hierarchy</strong></span> window and make it a child of <code class="literal">CameraPivot</code>.</p></li><li><p>Set the <code class="literal">Main Camera</code> component's <span class="strong"><strong>X</strong></span> position to <code class="literal">0</code>. As long as <span class="strong"><strong>X</strong></span> stays at zero and the camera continues to point relatively forward along the <span class="emphasis"><em>z</em></span> axis, you can freely move it to find a good position from which to observe the ball. Values of <code class="literal">2</code> for the <span class="strong"><strong>Y</strong></span> position, <code class="literal">-2.5</code> for the <span class="strong"><strong>Z</strong></span> position, and <code class="literal">35</code> for the <span class="strong"><strong>X</strong></span> rotation also work well.</p></li><li><p>Next, add the <code class="literal">CameraFollow</code> script to the <code class="literal">CameraPivot</code> object.</p></li><li><p>Finally, drag <code class="literal">MonkeyBall</code> from the scene and drop it on the <span class="strong"><strong>Ball</strong></span> slot of the new <span class="strong"><strong>CameraFollow</strong></span> script component. Then, go try it out!</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_06_03.jpg" /></div></li></ol></div><p>We now have a ball that rolls around and a camera that follows it. The camera is simply updating its position to <a id="id347" class="indexterm"></a>keep pace with the ball, but it works well as an effect. As a player, we will definitely feel that we are taking control of the ball and its motion.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec38"></a>Adding the monkey</h3></div></div></div><p>Now that <a id="id348" class="indexterm"></a>we are close to the ball and following it around, we need something a little more interesting to look at. In this section, we are going to add the monkey to the ball. In addition, to ensure that he isn't being spun around wildly, we will make a new script to keep him upright. Let's do all of that by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new empty<span class="strong"><strong> GameObject</strong></span> and rename it <code class="literal">MonkeyPivot</code>.</p></li><li><p>Make it a child of the <code class="literal">MonkeyBall</code> script and zero out its position.</p></li><li><p>Next, add the monkey to the scene and make it a child of the <code class="literal">MonkeyPivot</code> GameObject.</p></li><li><p>To make it easier to see the monkey inside the ball, we need to make it slightly transparent. Select <code class="literal">MonkeyBall</code> and find the <span class="strong"><strong>Rendering Mode</strong></span> setting on the material at the bottom. By changing it to <span class="strong"><strong>Transparent</strong></span>, we will be able to adjust it.</p></li><li><p>Now, click on the <span class="strong"><strong>Color Picker</strong></span> box to the right of <span class="strong"><strong>Albedo</strong></span> and change the <span class="strong"><strong>A</strong></span> slider, alpha, to <code class="literal">128</code>; this will allow us to now see through the ball.</p></li><li><p>Scale and move the monkey until he fills the center of the ball.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip12"></a>Tip</h3><p>You can also take this opportunity to pose the monkey. If you expand the monkey in the <span class="strong"><strong>Hierarchy</strong></span> <a id="id349" class="indexterm"></a>window, you will be able to see all of the bones that make up his skeleton rig. Giving him a cool pose now will make the game much better for our players later.</p></div><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_06_04.jpg" /></div></li><li><p>Our monkey and the ball are looking really cool right now, until we actually hit play and the monkey spins around dizzily in the ball. We need to open our <code class="literal">MonkeyBall</code> script and fix his spinning antics:</p></li><li><p>First, we need two new variables at the top of the script. The first will keep track of the empty<span class="strong"><strong> GameObject</strong></span> that we created a moment ago. The second will give us the speed for updating the rotation of the monkey. We want it to look like the monkey is moving the ball, so he needs to face the direction in which the ball is moving. The speed here is how fast he will turn to face the right direction:</p><div class="informalexample"><pre class="programlisting">public Transform monkeyPivot;
public float monkeyLookSpeed = 10f;</pre></div></li><li><p>Next, we need a new <code class="literal">LateUpdate</code> function. This double-checks whether the <code class="literal">monkeyPivot</code> variable has actually been filled for the script. If it isn't there, we can't do anything else:</p><div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  if(monkeyPivot != null) {</pre></div></li><li><p>We first need to <a id="id350" class="indexterm"></a>figure out which direction the ball is moving in. The easiest way to do this is to grab <code class="literal">velocity</code> of the <span class="strong"><strong>Rigidbody</strong></span> component, our body variable. It is a <code class="literal">Vector3</code> that indicates how fast and in which direction we are currently moving. Since we do not want our monkey to point up or down, we zero out the <span class="emphasis"><em>y</em></span> axis movement:</p><div class="informalexample"><pre class="programlisting">Vector3 velocity = body.velocity;
velocity.y = 0;</pre></div></li><li><p>Next, we need to figure out which direction the monkey is currently facing. We have used the forward value before, with our tanks. It is simply the direction in 3D space in which we are facing. Again, to avoid looking up or down, we zero out the <span class="emphasis"><em>y</em></span> axis:</p><div class="informalexample"><pre class="programlisting">Vector3 forward = monkeyPivot.forward;
forward.y = 0;</pre></div></li><li><p>To prevent suddenly changing direction as we move and to keep pace with the frame rate, we must calculate a <code class="literal">step</code> variable. This is how much we can rotate this frame, based on our speed and the time that has elapsed since the last frame:</p><div class="informalexample"><pre class="programlisting">float step = monkeyLookSpeed * Time.deltaTime;</pre></div></li><li><p>We then need to find a new direction to face by using <code class="literal">Vector3.RotateTowards</code>. It takes the direction we were facing, followed by the direction we want to face and two speeds. The first speed specifies how much the angle can change in this frame and the second specifies how much the magnitude, or length, of the vector can change. We are not concerned with a change in magnitude, so it is given a zero value:</p><div class="informalexample"><pre class="programlisting">Vector3 newFacing = Vector3.RotateTowards(forward, velocity, step, 0);</pre></div></li><li><p>Finally, the new rotation is calculated using <code class="literal">Quaternion.LookRotation</code> by passing the <code class="literal">newFacing</code> vector to it and applying the result to the monkey's rotation. This will turn the monkey to face in the direction of the movement and keep him from spinning with the ball:</p><div class="informalexample"><pre class="programlisting">monkeyPivot.rotation = Quaternion.LookRotation(newFacing);
}
}</pre></div></li><li><p>To make it <a id="id351" class="indexterm"></a>work, drop the <code class="literal">MonkeyPivot</code> object on the <span class="strong"><strong>Monkey Pivot</strong></span> slot on the <span class="strong"><strong>MonkeyBall</strong></span> script component. The monkey will rotate to face the direction of the ball's movement while staying upright:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_06_05.jpg" /></div></li></ol></div><p>We've just finished adding the monkey to the ball. By giving him a cool pose, the player will be more engaged with it as a character. However, it looks a little weird when the monkey spins wildly <a id="id352" class="indexterm"></a>within the ball, so we updated our script to keep him upright and facing the direction in which the ball is moving. Now, it almost looks as though the monkey is in control of the ball.</p></div></div>