<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec27"></a>Tank import settings</h2></div></div><hr /></div><p>Importing <a id="id154" class="indexterm"></a>any asset into Unity is done by using a default group of settings. Any<a id="id155" class="indexterm"></a> of these settings can be changed from the <span class="strong"><strong>Inspector</strong></span> window. With your new tank selected, we will go over the import settings for a model here:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_01.jpg" /></div><p>We can see in the <a id="id156" class="indexterm"></a>preceding screenshot that the top of the <span class="strong"><strong>Inspector</strong></span> window has three tabs: <span class="strong"><strong>Model</strong></span>, <span class="strong"><strong>Rig</strong></span>, and <span class="strong"><strong>Animations</strong></span>. The <span class="strong"><strong>Model</strong></span> page handles the mesh itself, while <span class="strong"><strong>Rig</strong></span> and <span class="strong"><strong>Animations</strong></span> are for importing animations. For now, we only care <a id="id157" class="indexterm"></a>about the <span class="strong"><strong>Model</strong></span> page, so select it if it is not already selected. Each section of the <span class="strong"><strong>Model</strong></span> page is broken down here.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec19"></a>Meshes</h3></div></div></div><p>The <span class="strong"><strong>Meshes</strong></span> section<a id="id158" class="indexterm"></a> of the previous screenshot has the following options:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="strong"><strong>Meshes</strong></span> section of the <span class="strong"><strong>Import Settings</strong></span> window starts with the <span class="strong"><strong>Scale Factor</strong></span> attribute. This is a value that tells Unity how big the mesh is by default. One generic unit or one meter from your modeling program translates to one unit in Unity. This tank was made in generic units, so the tank's scale factor is one. If you were working in centimeters when making the tank, the scale factor would be 0.01 because a centimeter is a hundredth of a meter.</p></li><li style="list-style-type: disc"><p>The<span class="strong"><strong> File Scale</strong></span> option is the scale used in the modeling program when the model was originally created. It is primarily informational. If you need to adjust the size of the imported model, adjust the <span class="strong"><strong>Scale Factor</strong></span>.</p></li><li style="list-style-type: disc"><p>The next option, <span class="strong"><strong>Mesh Compression</strong></span>, will become important in the final chapter when we go over the optimization of our games. The higher the compression is set to, the smaller will be the size of the file in the game. However, this will start to introduce weirdness in your mesh as Unity works to make it smaller. For now, leave it as <span class="strong"><strong>Off</strong></span>.</p></li><li style="list-style-type: disc"><p>The<span class="strong"><strong> Read/Write Enabled</strong></span> option is useful if you want to make changes to the mesh while the game is playing. This allows you to do some really cool things, such as destructible environments, where your scripts break the meshes into pieces based on where they are being shot. However, it also means that Unity has to keep a copy of the mesh in memory, which could really start to lag a system if it is complex. This is outside the scope of this book, so unchecking this option is a good idea.</p></li><li style="list-style-type: disc"><p>The<span class="strong"><strong> Optimize Mesh</strong></span> option is a good one to leave on, unless you are doing something specific and fancy with the mesh. With this on, Unity does some special 'behind the scenes' magic. In computer graphics and especially Unity, every mesh is ultimately a series of triangles that are drawn on a screen. This option allows Unity to reorder the triangles in the file so that the whole mesh can be drawn faster and more easily.</p></li><li style="list-style-type: disc"><p>The<span class="strong"><strong> Import BlendShapes</strong></span> option allows Unity to make sense of any BlendShapes that might be part of the model. These are animated positions of the vertexes of the model. Usually, they are used for facial animations. The next option, <span class="strong"><strong>Generate Colliders</strong></span>, is a useful one if you're doing complex things with physics. Unity has a set of simple collider shapes that should be used whenever possible because they are easier to process. However, there are situations where they won't quite get the job done; for example, a rubble or a half-pipe where the collision shape is too complex to be made with a series of simple shapes. That is why Unity has a <span class="strong"><strong>Mesh Collider</strong></span> component. With this option checked, a <span class="strong"><strong>Mesh Collider</strong></span> component is added to every mesh in our model. We will be sticking with simple colliders in this chapter, so leave the <span class="strong"><strong>Generate Colliders</strong></span> option off.</p></li><li style="list-style-type: disc"><p>The<span class="strong"><strong> Swap UVs</strong></span> and <span class="strong"><strong>Generate Lightmap UVs</strong></span> options are primarily used when working with<a id="id159" class="indexterm"></a> lighting, especially lightmaps. Unity can handle two sets of UV coordinates on a model. Normally, the first is used for the texture and the second for the lightmap or shadow texture. If they are in the wrong order, <span class="strong"><strong>Swap UVs</strong></span> will change them so that the second set comes first. If you need an unwrap for a lightmap but did not create one, <span class="strong"><strong>Generate Lightmap UVs</strong></span> will create one for you. We are not working with lightmaps in this project, so both of these can remain off.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec20"></a>Normals &amp; Tangents</h3></div></div></div><p>The <span class="strong"><strong>Normals &amp; Tangents</strong></span> section<a id="id160" class="indexterm"></a> of the earlier screenshot has the following options:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The next section of options, <span class="strong"><strong>Normals &amp; Tangents</strong></span>, begins with the <span class="strong"><strong>Normals</strong></span> option. This defines how Unity will hold the normals of your mesh. By default, they are imported from the file; however, there is also the option to make Unity calculate them based on the way the mesh is defined. Otherwise, if we set this option to <span class="strong"><strong>None</strong></span>, Unity will not import the normals. Normals are needed if we want our mesh to be affected by real-time lighting or make use of normal maps. We will be making use of real-time lighting in this project, so leave it set to <span class="strong"><strong>Import</strong></span>.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Tangents</strong></span>, <span class="strong"><strong>Smoothing Angle</strong></span>, and <span class="strong"><strong>Split Tangents</strong></span> options are used if your mesh has a normal map. Tangents are needed to determine how lighting interacts with a normal mapped surface. By default, Unity will calculate these for you. Importing tangents is only possible from a few file types. The smoothing angle, based on the angle between the two faces, dictates whether shading across an edge would be smooth or sharp. The <span class="strong"><strong>Split Tangents</strong></span> option is there to handle a few specific lighting quirks. If lighting is broken by seams, enabling this option will fix it. Normal maps are great for making a low-resolution game look like a high-resolution one. However, because of all the extra files and information needed to use them, they are not ideal for a mobile game. Therefore, we will not be using them in this book and so all of these options can be turned off to save memory.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Keep Quads</strong></span> option <a id="id161" class="indexterm"></a>will allow your models to take advantage of DirectX 11's new tessellation techniques for creating high-detail models from low-detail models and a special displacement map. Unfortunately, it will be a while before mobile devices can support such detail, and even longer before they become commonplace.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec21"></a>Materials</h3></div></div></div><p>The <span class="strong"><strong>Materials</strong></span> section<a id="id162" class="indexterm"></a> of the previous screenshot has the following options:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The last section, <span class="strong"><strong>Materials</strong></span>, defines how Unity should look for materials. The first option, <span class="strong"><strong>Import Materials</strong></span>, allows you to decide whether or not a material should be imported. If it is turned off, a default white material will be applied. This material will not show up anywhere in your project; it is a hidden default. For models that will not have any textures, such as collision meshes, this can be turned off. For our tank and nearly every other case, this should be left on.</p></li><li style="list-style-type: disc"><p>The last two options, <span class="strong"><strong>Material Naming</strong></span> and <span class="strong"><strong>Material Search</strong></span>, work together to name and find the materials for the mesh. Directly below them, there is a text box that describes how Unity will go about searching for the material.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The name of the material being searched for can be the name of the texture used in the modeling program, the name of the material created in the modeling program, or the name of the model and the material. If a texture name cannot be found, the material name will be used.</p></li><li style="list-style-type: disc"><p>By default, Unity does a recursive-up search. This means that we start the search by looking in the <code class="literal">Materials</code> folder, followed by a search for any materials that are in the same folder. We then check the parent folder for matching materials, followed by the folder above that. This continues until we find either the material that has the correct name or we reach the root assets folder.</p></li><li style="list-style-type: disc"><p>Alternatively, we have the options of checking the entire project or only looking in the <code class="literal">Materials</code> folder that is next to our model. The defaults for these options are just fine. In general, they do not need to be changed. They can be easily dealt with, especially for a large project, using the Unity Editor scripting, which will not be covered in this book.</p></li></ul></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec22"></a>The Revert and Apply buttons</h3></div></div></div><p>Next, the screenshot has the <a id="id163" class="indexterm"></a>
<span class="strong"><strong>Revert</strong></span> and <span class="strong"><strong>Apply</strong></span> buttons, which are explained here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Whenever changes are made to the import settings, one of the two buttons,<span class="strong"><strong> Revert</strong></span> or <span class="strong"><strong>Apply</strong></span>, must be chosen. The <span class="strong"><strong>Revert</strong></span> button cancels the changes and switches the import settings back to what they were before changes were made. The <span class="strong"><strong>Apply</strong></span> button confirms the changes and reimports the model with the new settings if these buttons are not selected; Unity will complain with a pop up and force you to make a choice before letting you mess with anything else.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_02.jpg" /></div></li><li style="list-style-type: disc"><p>Finally, we have two types of previews as we can see in the previous screenshot. The <span class="strong"><strong>Imported Object</strong></span> section is a preview of what the object will look like in the <span class="strong"><strong>Inspector</strong></span> window, if we added the object to the <span class="strong"><strong>Scene</strong></span> view and<a id="id164" class="indexterm"></a> selected it. The <span class="strong"><strong>Preview</strong></span> window, the section where we can see the tank model, is what the model will look like in the <span class="strong"><strong>Scene</strong></span> view. You can click and drag the object in this window to rotate it and look at it from different angles. In addition, there is a little blue button in this window. By clicking on this button, you will be able to add labels to the object. Then, these labels will also be searchable in the <span class="strong"><strong>Project</strong></span> window.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>Setting up the tank</h3></div></div></div><p>Now<a id="id165" class="indexterm"></a> that we have imported the tank, we need to set it up. We will be adjusting the arrangement of the tank as well as creating a few scripts.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec28"></a>The tank</h4></div></div></div><p>At this point, the creation of our tank will primarily consist of the creation and arrangement of the tank's components. Using the following steps, we can set up our tank:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start by dragging the tank from the <span class="strong"><strong>Project</strong></span> window to the <span class="strong"><strong>Hierarchy</strong></span> window. You will notice that the name of the tank appears in blue color in the <span class="strong"><strong>Hierarchy</strong></span> window. This is because it is a prefab instance. Any model in your project largely acts like a prefab. However, we want our tank to do more than just sit there; so, being a prefab of a static mesh is not helpful. Therefore, select your tank in the <span class="strong"><strong>Hierarchy</strong></span> window and we will start to make it useful be removing the <span class="strong"><strong>Animator</strong></span> component. To do this, select the gear to the right of the Animator component in the <span class="strong"><strong>Inspector</strong></span> window. From the new drop-down list, select <span class="strong"><strong>Remove Component</strong></span>, as seen in the following screenshot, and it will be removed:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_19.jpg" /></div></li><li><p>If you <a id="id166" class="indexterm"></a>are using the tank that is provided by default, selecting the different parts of it will reveal that all the pivot points are at the base. This will not be useful for making our turret and cannon pivot properly. The easiest way to solve this is by adding new empty <span class="strong"><strong>GameObjects</strong></span> to act as pivot points.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note04"></a>Note</h3><p>Any object in the scene is a <code class="literal">GameObject</code>. Any empty <code class="literal">GameObject</code> is one that only has a <span class="strong"><strong>Transform</strong></span> component.</p></div></li><li><p>At the top of the Unity Editor, <span class="strong"><strong>Create Empty</strong></span> is the first option under the <span class="strong"><strong>GameObject</strong></span> button. It creates the objects that we need. Create two empty GameObjects and position one at the base of the turret and the other at the base of the <a id="id167" class="indexterm"></a>cannon. In addition, rename them as <code class="literal">TurretPivot</code> and <code class="literal">CannonPivot</code> respectively. This can be done with the textbox at the very top of the <span class="strong"><strong>Inspector</strong></span> window if the object is selected.</p></li><li><p>In the <span class="strong"><strong>Hierarchy</strong></span> window, drag <code class="literal">TurretPivot</code> onto <code class="literal">Tank</code>. This changes the parent of <code class="literal">TurretPivot</code> to <code class="literal">Tank</code>. Then, drag the object, that is, the turret mesh, onto <code class="literal">TurretPivot</code>. In the code, we will be rotating the pivot point and not the mesh directly. When a parent object moves or rotates, all of the children objects move with it. When you make this change, Unity will complain about the change to the original hierarchy of the object; it does this just to make sure that it is a change that you want to make and not an accident:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_06.jpg" /></div></li><li><p>As losing the connection to the prefab can potentially break a game, Unity just wants to be sure that we actually want it to happen. So, click on <span class="strong"><strong>Continue</strong></span> and we can finish working with the tank without other complaints from Unity. We also need to make <code class="literal">CannonPivot</code> a child of <code class="literal">TurretPivot</code> and the cannon a child of <code class="literal">CannonPivot</code>.</p></li><li><p>To finish our hierarchy changes, we need to place the camera. Since we want the player to appear as if they are is actually in the tank, the camera should be placed behind and above the tank with a tilt slightly downward to focus on a spot a few tank lengths ahead. Once it is positioned, make it a child of <code class="literal">TurretPivot</code> as well.</p></li></ol></div><p>We have set up the basic structure that our tank will use. By making use of multiple objects in this way, we can control their movements and actions independently from each other. At this point, instead <a id="id168" class="indexterm"></a>of having a rigid tank that only points forward, we can tilt, rotate, and aim each piece independently.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip04"></a>Tip</h3><p>Also, the tank should be centered above the point at which you want the whole thing to pivot around. If yours is not, you can select everything that is under the base tank object in the <span class="strong"><strong>Hierarchy</strong></span> window and move it around.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec29"></a>Keeping score</h4></div></div></div><p>A short script <a id="id169" class="indexterm"></a>for keeping track of a player's score and the addition of a text element will constitute the focus of this short section. The following are the steps for the creation of our script:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The first script that is needed to make our tank work is fairly simple. Create a new script and name it <code class="literal">ScoreCounter</code>. It will, as the name implies, track the score. Create it in the <code class="literal">Scripts</code> folder and clear out the default functions, just like every other script that we have made so far.</p></li><li><p>Just like we did in the previous chapter, since any script that needs access to any of our GUI elements needs an extra line at the very top of the script, add the following line of code right after the line that says <code class="literal">using UnityEngine;</code>. This allows us to use and change the text element we need to display the score:</p><div class="informalexample"><pre class="programlisting">using UnityEngine.UI;</pre></div></li><li><p>The following line of code should look familiar from the previous chapter. First, we define an integer counter. As it is static, other scripts (such as the ones we will create for the targets) will be able to modify this number and give us the score:</p><div class="informalexample"><pre class="programlisting">public static int score = 0;</pre></div></li><li><p>We will then add a variable to store the text element for our interface. It will work like the turn indicator from the previous chapter, giving us a location to update and display the player's score:</p><div class="informalexample"><pre class="programlisting">public Text display;</pre></div></li><li><p>The last bit of code for this script is an <code class="literal">Update</code> function. This function is called automatically by Unity for every single frame. This is the perfect spot for us to put any code and logic that needs to change regularly without the player's direct input. For our purpose, we will update the text element and make certain that it always has the most up-to-date score to display. By adding the score to double quotes, we are changing the number into a word so that it can be used properly by the text element:</p><div class="informalexample"><pre class="programlisting">public void Update() {
  display.text = "" + score;
}</pre></div></li></ol></div><p>That's it for this <a id="id170" class="indexterm"></a>very simple script. It will track our score throughout the game. In addition, instead of doing any of the score increments itself, other scripts will update the counter to give points to the player.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec30"></a>Repeat buttons</h4></div></div></div><p>The buttons<a id="id171" class="indexterm"></a> that we have used so far only perform an action when they are pressed and released. Our players will need to hold down the buttons to control their tank. So, we need to create a repeat button; a button that performs an action as long as it is held down. Follow these steps to create a repeat button:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new script that should be named as <code class="literal">RepeatButton</code>.</p></li><li><p>To give this script access to the parts of Unity that it needs in order to work, just like the previous script, we need to add the following two lines right after the one that says <code class="literal">using UnityEngine;</code>. The first will give us access to the <code class="literal">Selectable</code> class: the one from which all interactive interface elements are derived. The second will let us handle the events that occur when our players interact with our new button:</p><div class="informalexample"><pre class="programlisting">using UnityEngine.UI;
using UnityEngine.EventSystems;</pre></div></li><li><p>Next, we need to update the <code class="literal">public class</code> line of our code. Any normal script that will provide functionality to the objects in our game expands upon the <code class="literal">MonoBehaviour</code> class. We need to change the line to the following, so that our script can instead exist in and expand the functionality of the interface:</p><div class="informalexample"><pre class="programlisting">public class RepeatButton : Selectable {</pre></div></li><li><p>Our script will have a total of four variables. The first allows it to keep track of whether or not it is being pressed:</p><div class="informalexample"><pre class="programlisting">private bool isPressed = false;</pre></div></li><li><p>The next three variables will provide the same functionality as the button did in the previous chapter. For the button, we had to select an object, followed by a function from a specific script, and finally some value to send. Here, we are going to do the same thing. The first variable here keeps track of which object in the scene we are going to interact with. The second will be the name of a function that is on some of the script attached to the object. The last will be a number to send along for the function, and it will provide more specific input:</p><div class="informalexample"><pre class="programlisting">public GameObject target;
public string function = "";
public float value = 0f;</pre></div></li><li><p>The first <a id="id172" class="indexterm"></a>function for this script will override a function provided by the <code class="literal">Selectable</code> class. It is called the moment the player clicks on the button. It is given some information about how and where it was clicked, which is stored in <code class="literal">eventData</code>. The second line just calls the function of the same name on the parent class. The last thing the function does is set our Boolean flag to mark that the button is currently being pressed by the player:</p><div class="informalexample"><pre class="programlisting">public override void OnPointerDown(PointerEventData eventData) {
  base.OnPointerDown(eventData);
  isPressed = true;
}</pre></div></li><li><p>The next function does the exact same thing as the previous function. The main difference is that it is called when the mouse or touch from the player is no longer over the button in the interface. The second difference is that it sets the Boolean to <code class="literal">false</code> because when our player drags their finger off the button, they are no longer pressing it, and we want to stop performing our action in that case:</p><div class="informalexample"><pre class="programlisting">public override void OnPointerExit(PointerEventData eventData) {
  base.OnPointerExit(eventData);
  isPressed = false;
}</pre></div></li><li><p>The following function is like the first two. However, it is called when the button is released:</p><div class="informalexample"><pre class="programlisting">public override void OnPointerUp(PointerEventData eventData) {
  base.OnPointerUp(eventData);
  isPressed = false;
}</pre></div></li><li><p>The final function of this script is again our <code class="literal">Update</code> function. It first checks whether the player is currently pressing this button. It then calls the <code class="literal">SendMessage</code> function on our target object, telling it what function to perform and what number to use. The <code class="literal">SendMessage</code> function is only available for <span class="strong"><strong>GameObject</strong></span> and <span class="strong"><strong>MonoBehviour</strong></span> components. It takes the name of a function and tries to find it on the GameObject to which the message was sent:</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(isPressed) {
    target.SendMessage(function, value);
  }
}</pre></div></li></ol></div><p>Another script done! This <a id="id173" class="indexterm"></a>one allows us to hold buttons rather than be forced to press them repeatedly to move through our game.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec31"></a>Controlling the chassis</h4></div></div></div><p>A normal<a id="id174" class="indexterm"></a> tank rotates in place, and it can easily move forward and back. We will make our tank do this with the creation of a single script. Perform these steps to create our second script for the tank:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The second script is called <code class="literal">ChassisControls</code>. It will make our tank move around. We will create it in the <code class="literal">Scripts</code> folder as well.</p></li><li><p>The first three lines of the script define the variables that the tank will need to move around. We will also be able to change them in the <span class="strong"><strong>Inspector</strong></span> window, in case our tank is too fast or too slow. The first line defines a variable that holds a connection to a <code class="literal">CharacterController</code> component. This component will not only move the tank around easily but it will also allow it to stop by walls and other colliders. The next two lines of code define how fast we move and rotate:</p><div class="informalexample"><pre class="programlisting">public CharacterController characterControl;
public float moveSpeed = 10f;
public float rotateSpeed = 45f;</pre></div></li><li><p>We start the following line of code by defining our <code class="literal">MoveTank</code> function; it needs to be passed a <code class="literal">speed</code> value to dictate how far and in which direction the tank should go. A positive value will make the tank go forward and a negative value will make it go backwards:</p><div class="informalexample"><pre class="programlisting">public void MoveTank(float speed) {</pre></div></li><li><p>In order to move in a three-dimensional space, we need a vector—a value with both direction and magnitude. Therefore, we define a movement vector and set it to the tank's forward direction, multiplied by the tank's speed, and again multiplied by the amount of time that has elapsed since the last frame.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>If you remember from geometry class, 3D space has three axes: x, y, and z. In Unity, the following convention applies: x is to the right, y is up, and z is forward. The transform component holds these values for an object's position, rotation, and scale. We can access the transform component of any object in Unity by calling upon the <code class="literal">transform</code> variable that Unity provides. The <code class="literal">transform</code> component also provides a <code class="literal">forward</code> variable that will give us a vector that points in the direction in which the object is facing.</p></li><li style="list-style-type: disc"><p>In addition, we <a id="id175" class="indexterm"></a>want to move at a regular pace, for example, a certain number of meters per second; therefore, we make use of <code class="literal">Time.deltaTime</code>. This is a value provided by Unity that holds how many seconds it has been since the last frame of the game was drawn on screen. Think of it like a flip book. In order to make it look like a guy is walking across the page, he needs to move slightly on each page. In the case of a game, the pages are not flipped regularly. So, we have to modify our movement by how long it has taken to flip to the new page. This helps us to maintain an even pace.x2</p><div class="informalexample"><pre class="programlisting">Vector3 move = characterControl.transform.forward * speed * Time.deltaTime;</pre></div></li></ul></div></li><li><p>Next, we want to stay on the ground. In general, any character you want to control in a game does not automatically receive all of the physics, such as gravity, that a boulder would. For example, when jumping, you temporarily remove gravity so that the character can go up. That is why the next line of code does a simple implementation of gravity by subtracting the normal speed of gravity and then keeping it in pace with our frame rate:</p><div class="informalexample"><pre class="programlisting">move.y -= 9.8f * Time.deltaTime;</pre></div></li><li><p>Finally, for the <code class="literal">MoveTank</code> function, we actually do the moving. The <code class="literal">CharacterController</code> component has a special <code class="literal">Move</code> function that will move the character but constrain it by collisions. We just need to tell it how far and in which direction we want to move this frame by passing the <code class="literal">move</code> vector to it. This final curly brace, of course, closes off the function:</p><div class="informalexample"><pre class="programlisting">characterControl.Move(move);
}</pre></div></li><li><p>The <code class="literal">RotateTank</code> function also needs a speed value to dictate how fast and in which direction to rotate. We start by defining another vector; however, instead of defining in which direction to move, this one will dictate in which direction to rotate around. In this case, we will be rotating around our up direction. We will then multiply that by our <code class="literal">speed</code> and <code class="literal">Time.deltaTime</code> parameters to move fast enough and keep pace with our frame rate.</p><div class="informalexample"><pre class="programlisting">public void RotateTank(float speed) {
  Vector3 rotate = Vector3.up * speed * Time.deltaTime;</pre></div></li><li><p>The last bit of the function actually does the rotation. The <span class="strong"><strong>Transform</strong></span> component provides a <code class="literal">Rotate</code> function. Rotation, especially in 3D space, can become weird and difficult very quickly. The <code class="literal">Rotate</code> function handles all of that for us; we just need to supply it with the values to apply for rotation. In addition, don't forget the curly brace to close off the function:</p><div class="informalexample"><pre class="programlisting">characterControl.transform.Rotate(rotate);
}</pre></div></li></ol></div><p>We created a script to <a id="id176" class="indexterm"></a>control the movement of our tank. It will use a special <code class="literal">Move</code> function from the <code class="literal">CharacterController</code> component so that our tank can move forwards and backwards. We also used a special <code class="literal">Rotate</code> function provided by the <span class="strong"><strong>Transform</strong></span> component to rotate our tank.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec32"></a>Controlling the turret</h4></div></div></div><p>This <a id="id177" class="indexterm"></a>next script will allow the player to rotate their turret and aim the cannon:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>The last script that we need to create for our tank is <code class="literal">TurretControls</code>. This script will allow players to rotate the turret left and right and tilt the cannon up and down. As with all of the others, create it in the <code class="literal">Scripts</code> folder.</p></li><li><p>The first two variables that we define will hold pointers to the turret and cannon pivots- the empty <code class="literal">GameObjects</code> that we created for our tank. The second set is the speed at which our turret and cannon will rotate. Finally, we have some limit values. If we didn't limit how much our cannon could rotate, it would just spin around and around, passing through our tank. This isn't the most realistic behavior for a tank, so we must put some limits on it. The limits are in the range of 300 because straight ahead is zero degrees and down is 90 degrees. We want it to be in the upward angle, so it is in the range of 300. We can also use 359.9 because Unity will change 360 to zero so that it can continue to rotate:</p><div class="informalexample"><pre class="programlisting">public Transform turretPivot;
public Transform cannonPivot;

public float turretSpeed = 45f;
public float cannonSpeed = 20f;

public float lowCannonLimit = 315f;
public float highCannonLimit = 359.9f;</pre></div></li><li><p>Next is the <code class="literal">RotateTurret</code> function. It works in exactly the same way as the <code class="literal">RotateTank</code> function. However, instead of looking at a <code class="literal">CharacterController</code> component's <code class="literal">transform</code> variable, we act upon the <code class="literal">turretPivot</code> variable:</p><div class="informalexample"><pre class="programlisting">public void RotateTurret(float speed) {
  Vector3 rotate = Vector3.up * speed * Time.deltaTime;
  turretPivot.Rotate(rotate);
}</pre></div></li><li><p>The second <a id="id178" class="indexterm"></a>and last function, <code class="literal">RotateCannon</code>, gets a little more down-and-dirty with rotations. The fault completely lies with the need to put limits on the rotation of the cannon. After opening the function, the first step is to figure out how much we are going to be rotating this frame. We use a float value instead of a vector because we have to set the rotation ourselves:</p><div class="informalexample"><pre class="programlisting">public void RotateCannon(float speed) {
  float rotate = speed * Time.deltaTime;</pre></div></li><li><p>Next, we define a variable that holds our current rotation. We do this because Unity will not let us act on the rotation directly. Unity actually keeps track of rotation as a quaternion. This is a complex method of defining rotations that is beyond the scope of this book. Luckily, Unity gives us access to an x, y, and z method of defining rotations called <code class="literal">EulerAngles</code>. It is a rotation around each of the three axes in 3D space. The <code class="literal">localEulerAngles</code> value of a <span class="strong"><strong>Transform</strong></span> component is the rotation relative to the parent <span class="strong"><strong>GameObject</strong></span>.</p><div class="informalexample"><pre class="programlisting">Vector3 euler = cannonPivot.localEulerAngles;</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note05"></a>Note</h3><p>It is called <code class="literal">EulerAngles</code> because of Leonhard Euler, a Swiss mathematician, who came up with this method of defining rotations.</p></div></li><li><p>Next, we adjust the rotation and apply the limits in one go through the use of the <code class="literal">Mathf.Clamp</code> function. <code class="literal">Mathf</code> is a group of useful mathematical functions. The <code class="literal">clamp</code> function takes a value and makes it no lower and no higher than the other two values passed to the function. So, we first send it our <span class="emphasis"><em>x</em></span> axis rotation, which is the result of subtracting rotate from the current x rotation of <code class="literal">euler</code>. As the positive rotation is clockwise around an axis, we have to subtract our rotation to go up instead of down with a positive value. Next, we pass our lower limit to the <code class="literal">Clamp</code> function, followed by our higher limit: these are the <code class="literal">lowCannonLimit</code> and <code class="literal">highCannonLimit</code> variables that we defined at the top of the script:</p><div class="informalexample"><pre class="programlisting">euler.x = Mathf.Clamp(euler.x – rotate, lowCannonLimit, highCannonLimit);</pre></div></li><li><p>Finally, we have to actually apply the new rotation to our cannon's pivot point. This involves simply setting the <code class="literal">localEulerAngles</code> value of the <span class="strong"><strong>Transform</strong></span> component to the new value. Again, be sure to use the curly brace to close off the function:</p><div class="informalexample"><pre class="programlisting">cannonPivot.localEulerAngles = euler;
}</pre></div></li></ol></div><p>We have now created <a id="id179" class="indexterm"></a>a script that will control the turret of the tank. The player will be able to control the tilt of the cannon and rotation of the turret. This script functioned in a very similar manner to the <code class="literal">ChassisControls</code> script that we created earlier—the difference was in limiting the amount the cannon can tilt.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec33"></a>Putting the pieces together</h4></div></div></div><p>That was the last of the scripts for the moment. We have our tank and our scripts; the next step is to put <a id="id180" class="indexterm"></a>them together:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Now, we need to add the scripts to our tank. Remember how we added our <code class="literal">Tic-tac-toe</code> script to the camera in the last chapter? Start by selecting your tank in the <span class="strong"><strong>Hierarchy</strong></span> window. Before these scripts work, we will first need to add the <code class="literal">CharacterController</code> component to our tank. So, go to the top of the Unity Editor and select <span class="strong"><strong>Component</strong></span>, then select <span class="strong"><strong>Physics</strong></span>, and finally click on the <span class="strong"><strong>Character Controller</strong></span> option.</p><p>You will notice that a green capsule appears on the tank in the <span class="strong"><strong>Scene</strong></span> view as soon as you add the new component. This capsule represents the space that will collide and interact with other colliders. The values on the <span class="strong"><strong>Character Controller</strong></span> component let us control how it interacts with other colliders. For most cases, the defaults for the first four parameters are just fine.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_07.jpg" /></div><p>The parameters in <span class="strong"><strong>Character Controller</strong></span> are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Slope Limit</strong></span>: This attribute shows us how steep an incline the controller can move up.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Step Offset</strong></span>: This attribute shows us how high a step can be before it starts to block movement.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Skin Width</strong></span>: This defines how far another collider can penetrate this controller's collider before it is completely stopped. This is mostly used for squeezing between objects.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Min Move Distance</strong></span>: This attribute is for limiting jitter. It is the minimum amount of movement that has to be applied in a frame before it will actually move.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Center</strong></span>/<span class="strong"><strong>Radius</strong></span>/<span class="strong"><strong>Height</strong></span>: These attributes define the size of the capsule that you see in the <span class="strong"><strong>Scene</strong></span> view. They are used for the collision.</p></li></ul></div></li><li><p>The last<a id="id181" class="indexterm"></a> three values are the most important right now. We need to adjust these values as closely as possible to match our tank's size. Admittedly, the capsule is round and our tank is square, but a <code class="literal">CharacterController</code> component is the easiest way to move a character with collision, and it will be used the most often. Use values of <code class="literal">2.3</code> for the <span class="strong"><strong>Radius</strong></span> attribute and the <span class="strong"><strong>Y</strong></span> portion of the <span class="strong"><strong>Center</strong></span> attribute; everything else can be left as the default values.</p></li><li><p>It is now time to add the scripts to our tank. Do this by selecting the tank in the <span class="strong"><strong>Hierarchy</strong></span> window and dragging the <code class="literal">ChassisControls</code>, <code class="literal">TurretControls</code>, and <code class="literal">ScoreCounter</code> scripts onto the <span class="strong"><strong>Inspector</strong></span> window. This is just as we did in the previous chapters.</p></li><li><p>Next, we need to finish creating the connections that we started in our scripts. Start by clicking the <code class="literal">CharacterController</code> component's name and dragging it to the <span class="strong"><strong>Character Control</strong></span> slot that is on our new <code class="literal">ChassisControls</code> script component. Unity lets us connect object variables in the Unity Editor so that they do not have to be hardcoded.</p></li><li><p>We also need to connect our turret and cannon pivot points. So, click and drag the points from the <span class="strong"><strong>Hierarchy</strong></span> window to the corresponding variable on the <code class="literal">TurretControls</code> script component.</p></li><li><p>Before we can test our game, we need to create a bunch of GUI buttons to actually control our tank. Start by creating a canvas, just like we did in the previous chapter, and one empty GameObject.</p></li><li><p>The empty GameObject needs a <span class="strong"><strong>Rect Transform</strong></span> component, and it needs to be made a child of <code class="literal">Canvas</code>.</p></li><li><p>Rename it<a id="id182" class="indexterm"></a> to <code class="literal">LeftControls</code> and set its anchor to <span class="strong"><strong>bottom left</strong></span>. In addition, set <span class="strong"><strong>Pos X</strong></span> to <code class="literal">75</code>, <span class="strong"><strong>Pos Y</strong></span> to <code class="literal">75</code>, <span class="strong"><strong>Pos Z</strong></span> to <code class="literal">0</code>, <span class="strong"><strong>Width</strong></span> to <code class="literal">150</code>, and <span class="strong"><strong>Height</strong></span> to <code class="literal">150</code> as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_03.jpg" /></div></li><li><p>Next, we need four buttons to be the children of <code class="literal">LeftControls</code>. As in the last chapter, they can be found at the top of the editor by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Button</strong></span>.</p></li><li><p>Rename the four buttons to <code class="literal">Forward</code>, <code class="literal">Back</code>, <code class="literal">Left</code>, and <code class="literal">Right</code>. While you're at it, you can also change their text child to have the relevant text, such as <code class="literal">F</code>, <code class="literal">B</code>, <code class="literal">L</code>, and <code class="literal">R</code>.</p></li><li><p>The button only activates when the player clicks and releases it. Clicking repeatedly just to make the tank move will not work very well. So, click on the gear to the right of each of their <span class="strong"><strong>Button</strong></span> components and select <span class="strong"><strong>Remove Component</strong></span>.</p></li><li><p>Now, add our <code class="literal">RepeatButton</code> script to each. As we extended that <code class="literal">Selectable</code> class, you can see that we have all the same controls over our button that we did on the other buttons.</p></li><li><p>Set the values of <span class="strong"><strong>Width</strong></span> and <span class="strong"><strong>Height</strong></span> of all the four buttons to <code class="literal">50</code>. Their positions become as follows:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col align="left" /><col align="left" /><col align="left" /></colgroup><thead><tr><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Button</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Pos X</p>
</th><th style="border-bottom: 0.5pt solid ; " align="left" valign="bottom">
<p>Pos Y</p>
</th></tr></thead><tbody><tr><td style="" align="left" valign="top">
<p>Forward</p>
</td><td style="" align="left" valign="top">
<p>0</p>
</td><td style="" align="left" valign="top">
<p>50</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Left</p>
</td><td style="" align="left" valign="top">
<p>-50</p>
</td><td style="" align="left" valign="top">
<p>0</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Back</p>
</td><td style="" align="left" valign="top">
<p>0</p>
</td><td style="" align="left" valign="top">
<p>-50</p>
</td></tr><tr><td style="" align="left" valign="top">
<p>Right</p>
</td><td style="" align="left" valign="top">
<p>50</p>
</td><td style="" align="left" valign="top">
<p>0</p>
</td></tr></tbody></table></div><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_04.jpg" /></div></li><li><p>Now that we have our four movement buttons, we need to connect them to our tank. For each of the buttons, drag <code class="literal">Tank</code> from the <span class="strong"><strong>Hierarchy</strong></span> panel and drop it in the <span class="strong"><strong>Target</strong></span> slot in the <span class="strong"><strong>Inspector</strong></span> panel.</p></li><li><p>When we<a id="id183" class="indexterm"></a> next set the <span class="strong"><strong>Function</strong></span> and <span class="strong"><strong>Value</strong></span> slots, spelling is very important. If something is a little bit off, your function will not be found, lots of errors will appear, and the tank will not work. For the <code class="literal">Forward</code> button, set the <span class="strong"><strong>Function</strong></span> slot to <code class="literal">MoveTank</code> and the <span class="strong"><strong>Value</strong></span> slot to <code class="literal">1</code>. The <code class="literal">Back</code> button also needs the value of <code class="literal">MoveTank</code> in the <span class="strong"><strong>Function</strong></span> slot, but it needs a value of <code class="literal">-1</code> in the <span class="strong"><strong>Value</strong></span> slot. The <code class="literal">Left</code> button needs a value of <code class="literal">RotateTank</code> in the <span class="strong"><strong>Function</strong></span> slot and a value of <code class="literal">-1</code> in the <span class="strong"><strong>Value</strong></span> slot. The <code class="literal">Right</code> button needs a value of <code class="literal">RotateTank</code> in the <span class="strong"><strong>Function</strong></span> slot and <code class="literal">1</code> in the <span class="strong"><strong>Value</strong></span> slot.</p></li><li><p>Next, we need to set up our turret controls. Right-click on <code class="literal">LeftControls</code> in the <span class="strong"><strong>Hierarchy</strong></span> window and select <span class="strong"><strong>Duplicate</strong></span> from the new menu. Rename the new copy to <code class="literal">RightControls</code>.</p></li><li><p>This new control set needs an anchor set of <span class="strong"><strong>bottom right</strong></span>, a <span class="strong"><strong>Pos X</strong></span> of <code class="literal">-75</code>, and <span class="strong"><strong>Pos Y</strong></span> of <code class="literal">75</code> (as shown in the following screenshot):</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_05.jpg" /></div></li><li><p>The buttons <a id="id184" class="indexterm"></a>under this set will need to be renamed as <code class="literal">Up</code>, <code class="literal">Down</code>, <code class="literal">Left</code>, and <code class="literal">Right</code>. Their text can be changed to <code class="literal">U</code>, <code class="literal">D</code>, <code class="literal">L</code>, and <code class="literal">R</code> respectively.</p></li><li><p>The <span class="strong"><strong>Function</strong></span> slot of the <code class="literal">Up</code> button should be set to <code class="literal">RotateCannon</code> with the value of the <span class="strong"><strong>Value</strong></span> slot as <code class="literal">1</code>. The <code class="literal">Down</code> button has a <span class="strong"><strong>Function</strong></span> slot value of <code class="literal">RotateCannon</code> and a <span class="strong"><strong>Value</strong></span> slot value of <code class="literal">-1</code>. The <code class="literal">Left</code> button needs <code class="literal">RotateTurret</code> as the value of the <span class="strong"><strong>Function</strong></span> slot with a value of <code class="literal">-1</code> for the <span class="strong"><strong>Value</strong></span> slot. Finally, the <code class="literal">Right</code> button needs a <span class="strong"><strong>Function</strong></span> slot value of <code class="literal">RotateTurret</code> with a <span class="strong"><strong>Value</strong></span> slot value of <code class="literal">1</code>.</p></li><li><p>The last thing to do is to create a new Text element that can be found by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Text</strong></span> and rename it as <code class="literal">Score</code>.</p></li><li><p>Finally, select your <code class="literal">Tank</code> and drag <code class="literal">Score</code> from the <span class="strong"><strong>Hierarchy</strong></span> window to the <span class="strong"><strong>Display</strong></span> slot of the <span class="strong"><strong>Score Counter (Script)</strong></span> component.</p></li><li><p>Save the scene as <code class="literal">TankBattle</code> and try it out.</p></li></ol></div><p>We just finished putting our tank together. Unless you look at the <span class="strong"><strong>Scene</strong></span> view while using the movement controls, it is hard to tell that the tank is moving. The turret controls can be seen in the <span class="strong"><strong>Game</strong></span> view though. Other than not having a point of reference for whether or not our tank is moving, it runs pretty well. The next step and the next section will give us that reference point as we add our city.</p><p>You might notice a quick jump when you first try to tilt the cannon. Such behavior is annoying and makes the game look broken. Try adjusting the cannon to fix it. If you are having trouble with it, take a look at the cannon's starting rotation. It has to do with the way the rotation is clamped every time we try to move it.</p></div></div></div>