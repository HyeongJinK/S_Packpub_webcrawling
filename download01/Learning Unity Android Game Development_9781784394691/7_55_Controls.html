<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec56"></a>Controls</h2></div></div><hr /></div><p>Next, we are <a id="id429" class="indexterm"></a>going to give the player the ability to interact with the game. First, we will create a slingshot to throw the birds. Following that we will create the camera controls. We will even create a nice background effect to round out the look of our game.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec45"></a>Attacking with a slingshot</h3></div></div></div><p>To <a id="id430" class="indexterm"></a>attack the pig fortress, we have our basic bird ammo. We need to create a slingshot to hurl this ammo at the pigs. It will also handle the spawning of the birds at the beginning of the level and automatically reload as birds are used. When the slingshot runs out of birds, it will notify the <code class="literal">LevelTracker</code> script and the game will end. Finally, we will create a script that will keep the physics simulation from going on for too long. We don't want to force the player to sit and watch a pig slowly roll across the screen. So, the script will, after a little while, start damping the movement of the <span class="strong"><strong>Rigidbody</strong></span> components to make them stop rather than keep rolling. To do all of this, we are going to follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To start off with the creation of the slingshot, add the slingshot model to the scene and position it at the origin. Scale it, as necessary, to make it about four units tall. Apply a light brown material to the <code class="literal">Fork</code> model and a dark brown one to the <code class="literal">Pouch</code> model.</p></li><li><p>Next, we need four empty GameObjects. Make them all the children of the <code class="literal">Slingshot</code> object.</p><p>Name the first GameObject <code class="literal">FocalPoint</code> and center it between the forked prongs of the slingshot. This will be the point through which we fire all the birds.</p><p>The second GameObject is <code class="literal">Pouch</code>. First, set its rotation to <code class="literal">0</code> for the <span class="strong"><strong>X</strong></span> axis, <code class="literal">90</code> for the <span class="strong"><strong>Y</strong></span> axis, and <code class="literal">0</code> for the <span class="strong"><strong>Z</strong></span> axis, making the blue arrow point forward along our field of play. Next, make the <code class="literal">pouch</code> model a child of this object, setting its position to <code class="literal">0</code> on the <span class="strong"><strong>X</strong></span> and <span class="strong"><strong>Y</strong></span> axes and <code class="literal">-0.5</code> on the <span class="strong"><strong>Z</strong></span> axis and its rotation to <code class="literal">270</code> for <span class="strong"><strong>X</strong></span>, <code class="literal">90</code> for <span class="strong"><strong>Y</strong></span>, and <code class="literal">0</code> for <span class="strong"><strong>Z</strong></span>. This will make the pouch appear in front of the current bird without having to make a complete pouch model.</p><p>The third GameObject is <code class="literal">BirdPoint</code>; this will position the bird that is being fired. Make it a child of the <code class="literal">Pouch</code> point and set its position to <code class="literal">0.3</code> on the <span class="strong"><strong>X</strong></span> axis and <code class="literal">0</code> for the <span class="strong"><strong>Y</strong></span> and <span class="strong"><strong>Z</strong></span> axes.</p><p>The last GameObject is <code class="literal">WaitPoint</code>; the birds waiting to be fired will be positioned behind this point. Set its position to <code class="literal">-4</code> for the <span class="strong"><strong>X</strong></span> axis, <code class="literal">0.5</code> for the <span class="strong"><strong>Y</strong></span> axis, and <code class="literal">0</code> for the <span class="strong"><strong>Z</strong></span> axis.</p></li><li><p>Next, rotate <a id="id431" class="indexterm"></a>the <code class="literal">Fork</code> model so that we can see both prongs of the fork while it appears to be pointing forward. The values of <code class="literal">270</code> for the <span class="strong"><strong>X</strong></span> axis, <code class="literal">290</code> for the <span class="strong"><strong>Y</strong></span> axis, and <code class="literal">0</code> for the <span class="strong"><strong>Z</strong></span> axis will work well.</p></li><li><p>The <code class="literal">Slingshot</code> script will provide most of the interaction for the player. Create it now.</p></li><li><p>We start this script with a group of variables. The first group will keep a reference to the damper that was mentioned earlier. The second group will keep track of the birds that will be used in the level. Next is a group of variables that will track the current bird that is ready to be fired. Fourth, we have some variables to hold references to the points we created a moment ago. The <code class="literal">maxRange</code> variable is the distance from the focal point to which the player can drag the pouch. The last two variables define how powerfully the bird will be launched:</p><div class="informalexample"><pre class="programlisting">public RigidbodyDamper rigidbodyDamper;

public GameObject[] levelBirds = new GameObject[0];
private Rigidbody2D[] currentBirds;
private int nextIndex = 0;
public Transform waitPoint;
public Rigidbody2D toFireBird;
public bool didFire = false;
public bool isAiming = false;

public Transform pouch;
public Transform focalPoint;
public Transform pouchBirdPoint;

public float maxRange = 3;

public float maxFireStrength = 25;
public float minFireStrength = 5;</pre></div></li><li><p>As with the other scripts, we use the <code class="literal">Awake</code> function for initialization. The <code class="literal">levelBirds</code> variable will hold references to all the bird prefabs that will be used in the level. We start by creating an instance of each one and storing its <span class="strong"><strong>Rigidbody</strong></span> in the <code class="literal">currentBirds</code> variable. The <code class="literal">isKinematic</code> variable is set to <code class="literal">true</code> on each bird's <span class="strong"><strong>Rigidbody</strong></span> component so that it does not move when it is not in use. Next, it readies the first bird to be fired and, finally, it positions the <a id="id432" class="indexterm"></a>remaining birds behind <code class="literal">waitPoint</code>:</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  currentBirds = new Rigidbody2D[levelBirds.Length];
  for(int i=0;i&lt;levelBirds.Length;i++) {
    GameObject nextBird = Instantiate(levelBirds[i]) as GameObject;
    currentBirds[i] = nextBird.GetComponent&lt;Rigidbody2D&gt;();
    currentBirds[i].isKinematic = true;
  }

  ReadyNextBird();
  SetWaitPositions();
}</pre></div></li><li><p>The <code class="literal">ReadyNextBird</code> function first checks whether we have run out of birds. If so, it finds the <code class="literal">LevelTracker</code> script to tell it that there are no birds left to fire. The <code class="literal">nextIndex</code> variable tracks the current location of the birds in the list to be fired by the player. Next, the function stores the next bird in the <code class="literal">toFireBird</code> variable and makes it a child of the <code class="literal">BirdPoint</code> object we created; its position and rotation are zeroed out. Finally, the fire and aim flags are reset:</p><div class="informalexample"><pre class="programlisting">public void ReadyNextBird() {
  if(currentBirds.Length &lt;= nextIndex) {
    LevelTracker tracker = FindObjectOfType(typeof(LevelTracker)) as LevelTracker;
    tracker.OutOfBirds();
    return;
  }

  toFireBird = currentBirds[nextIndex];
  nextIndex++;

  toFireBird.transform.parent = pouchBirdPoint;
  toFireBird.transform.localPosition = Vector3.zero;
  toFireBird.transform.localRotation = Quaternion.identity;

  didFire = false;
  isAiming = false;
}</pre></div></li><li><p>The <code class="literal">SetWaitPositions</code> function uses the position of <code class="literal">waitPoint</code> to position all the remaining birds behind the slingshot:</p><div class="informalexample"><pre class="programlisting">public void SetWaitPositions() {
  for(int i=nextIndex;i&lt;currentBirds.Length;i++) {
    if(currentBirds[i] == null) continue;
    Vector3 offset = Vector3.right * (i – nextIndex) * 2;
    currentBirds[i].transform.position = waitPoint.position – offset;
  }
}</pre></div></li><li><p>The <code class="literal">Update</code> function <a id="id433" class="indexterm"></a>starts by checking whether the player has fired a bird, and watches the <code class="literal">rigidbodyDamper.allSleeping</code> variable to see whether all the physics objects have stopped moving. Once they do, the next bird is readied to be fired. If we have not fired, the aiming flag is checked and the <code class="literal">DoAiming</code> function is called to handle the aiming. If the player is neither aiming nor has just fired a bird, we check for touch input. If the player touches close enough to the focal point, we flag that the player has started aiming:</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(didFire) {
    if(rigidbodyDamper.allSleeping) {
      ReadyNextBird();
      SetWaitPositions();
    }
    return;
  }
  else if(isAiming) {
    DoAiming();
  }
  else {
    if(Input.touchCount &lt;= 0) return;
    Vector3 touchPoint = GetTouchPoint();
    isAiming = Vector3.Distance(touchPoint, focalPoint.position) &lt; maxRange / 2f;
  }
}</pre></div></li><li><p>The <code class="literal">DoAiming</code> function checks whether the player has stopped touching the screen and fires the current bird when they have. If they have not, we position the pouch at the current touch point. Finally, the pouch's position is limited to keep it within the maximum range:</p><div class="informalexample"><pre class="programlisting">private void DoAiming() {
  if(Input.touchCount &lt;= 0) {
    FireBird();
    return;
  }
  
  Vector3 touchPoint = GetTouchPoint();

  pouch.position = touchPoint;
  pouch.LookAt(focalPoint);

  float distance = Vector3.Distance(focalPoint.position, pouch.position);
  if(distance &gt; maxRange) {
    pouch.position = focalPoint.position – (pouch.forward * maxRange);
  }
}</pre></div></li><li><p>The <code class="literal">GetTouchPoint</code> function <a id="id434" class="indexterm"></a>uses <code class="literal">ScreenPointToRay</code> to find out where the player is touching in 3D space. This is similar to when we were touching bananas; however, because this game is 2D, we can just look at the ray's origin and return a zero for its <span class="emphasis"><em>z</em></span> axis value:</p><div class="informalexample"><pre class="programlisting">private Vector3 GetTouchPoint() {
  Ray touchRay = Camera.main.ScreenPointToRay(Input.GetTouch(0).position);
  Vector3 touchPoint = touchRay.origin;
  touchPoint.z = 0;
  return touchPoint;
}</pre></div></li><li><p>Finally, for this script, we have the <code class="literal">FireBird</code> function. This function starts by setting our <code class="literal">didFire</code> flag to <code class="literal">true</code>. Next, it finds out the direction in which the bird needs to be fired by finding the direction from the pouch's position to <code class="literal">focalPoint</code>. It also uses the distance between them to determine the power with which the bird needs to be fired, clamping it between our minimum and maximum strengths. Then, it releases the bird by clearing its parent and setting its <code class="literal">isKinematic</code> flag to <code class="literal">false</code>, after finding its <span class="strong"><strong>Rigidbody</strong></span> component. To launch it, we use the <code class="literal">AddForce</code> function and pass it the direction multiplied by the power. <code class="literal">ForceMode2D.Impulse</code> is also passed to make that the force applied happens once and is immediate. Next, the pouch is positioned at <code class="literal">focalPoint</code>, as if it were actually under tension. Finally, we call <code class="literal">rigidbodyDamper.ReadyDamp</code> to start the damping of the <span class="strong"><strong>Rigidbody</strong></span> component's movement:</p><div class="informalexample"><pre class="programlisting">private void FireBird() {
  didFire = true;

  Vector3 direction = (focalPoint.position – pouch.position).normalized;
  float distance = Vector3.Distance(focalPoint.position, pouch.position);
  float power = distance &lt;= 0 ? 0 : distance / maxRange;
  power *= maxFireStrength;
  power = Mathf.Clamp(power, minFireStrength, maxFireStrength);

  toFireBird.transform.parent = null;
  toFireBird.isKinematic = false;
  toFireBird.AddForce(new Vector2(direction.x, direction.y) * power, ForceMode2D.Impulse);

  pouch.position = focalPoint.position;

  rigidbodyDamper.ReadyDamp();
}</pre></div></li><li><p>Before we can <a id="id435" class="indexterm"></a>make use of the <code class="literal">Slingshot</code> script, we need to create the <code class="literal">RigidbodyDamper</code> script.</p></li><li><p>This script starts with the following six variables. The first two define how long you need to wait before damping movement and how much you need to damp it by. The next two track whether damping can be applied and when it will start. The next is a variable that will be filled with a list of all the rigidbodies that are currently in the scene. Finally, it has the <code class="literal">allSleeping</code> flag that will be set to <code class="literal">true</code> when the movement has stopped:</p><div class="informalexample"><pre class="programlisting">public float dampWaitLength = 10f;
public float dampAmount = 0.9f;
private float dampTime = -1f;
private bool canDamp = false;
private Rigidbody2D[] rigidbodies = new Rigidbody2D[0];

public bool allSleeping = false;</pre></div></li><li><p>The <code class="literal">ReadyDamp</code> function starts by using <code class="literal">FindObjectsOfType</code> to fill the list with all the rigidbodies. The <code class="literal">dampTime</code> flag is set when you need to start damping as the sum of the current time and the wait length. It marks that the script can do its damping and resets the <code class="literal">allSleeping</code> flag. Finally, it uses <code class="literal">StartCoroutine</code> to call the <code class="literal">CheckSleepingRigidbodies</code> function. This is a special way of calling functions to make them run in the background without blocking the rest of the game from running:</p><div class="informalexample"><pre class="programlisting">public void ReadyDamp() {
  rigidbodies = FindObjectsOfType(typeof(Rigidbody2D)) as Rigidbody2D[];
  dampTime = Time.time + dampWaitLength;
  canDamp = true;
  allSleeping = false;

  StartCoroutine(CheckSleepingRigidbodies());
}</pre></div></li><li><p>In the <code class="literal">FixedUpdate</code> function, we<a id="id436" class="indexterm"></a> first check whether we can damp the movement and whether it is time to do it. If it is, we loop through all the rigidbodies, applying our damp to each one's rotational and linear velocity. Those that are kinematic, controlled by scripts, and already sleeping—meaning that they have stopped moving—are skipped:</p><div class="informalexample"><pre class="programlisting">public void FixedUpdate() {
  if(!canDamp || dampTime &gt; Time.time) return;

  foreach(Rigidbody2D next in rigidbodies) {
    if(next != null &amp;&amp; !next.isKinematic &amp;&amp; !next.isSleeping()) {
      next.angularVelocity *= dampAmount;
      next.velocity *= dampAmount;
    }
  }
}</pre></div></li><li><p>The <code class="literal">CheckSleepingRigidbodies</code> function is special and will run in the background. This is made possible by the <code class="literal">IEnumerator</code> flag at the beginning of the function and the <code class="literal">yield return null</code> line in the middle. Together, these allow the function to pause regularly and keep the rest of the game from freezing while it waits for the function to complete. The function starts by creating a check flag and using it to check whether all the rigidbodies have stopped moving. If one is still found to be moving, the flag is set to <code class="literal">false</code> and the function pauses until the next frame, when it will try again. When it reaches the end, because all the rigidbodies are sleeping, it sets the <code class="literal">allSleeping</code> flag to <code class="literal">true</code> so that the slingshot can be made ready for the next bird. It also stops itself from damping while the player is getting ready to fire the next bird:</p><div class="informalexample"><pre class="programlisting">private IEnumerator CheckSleepingRigidbodies() {
  bool sleepCheck = false;

  while(!sleepCheck) {
    sleepCheck = true;
    
    foreach(Rigidbody2D next in rigidbodies) {
      if(next != null &amp;&amp; !next.isKinematic &amp;&amp; !next.IsSleeping()) {
        sleepCheck = false;
        yield return null;
        break;
      }
    }
  }

  allSleeping = true;
  canDamp = false;
}</pre></div></li><li><p>Finally, we have <a id="id437" class="indexterm"></a>the <code class="literal">AddBodiesToCheck</code> function. This function will be used by anything that spawns new physics objects after the player has fired the bird. It starts by creating a temporary list and expanding the current one. Next, it adds all the values from the temporary list to the expanded one. Finally, the list of rigidbodies are added after those of the temporary list:</p><div class="informalexample"><pre class="programlisting">public void AddBodiesToCheck(Rigidbody2D[] toAdd) {
  Rigidbody2D[] temp = rigidbodies;
  rigidbodies = new Rigidbody2D[temp.Length + toAdd.Length];

  for(int i=0;i&lt;temp.Length;i++) {
    rigidbodies[i] = temp[i];
  }
  for(int i=0;i&lt;toAdd.Length;i++) {
    rigidbodies[i + temp.Length] = toAdd[i];
  }
}</pre></div></li><li><p>Return to Unity and add the two scripts to the <code class="literal">Slingshot</code> object. In the <code class="literal">Slingshot</code> script component, connect the references to the <code class="literal">Rigidbody Damper</code> script component and to each of the points. Also, add as many references to the red bird prefab to the <span class="strong"><strong>Level Birds</strong></span> list as you want for the level.</p></li><li><p>To keep objects from rolling back and through the slingshot, add a <span class="strong"><strong>Box Collider 2D</strong></span> component to <code class="literal">Slingshot</code> and position it at the stock of the <code class="literal">Fork</code> model.</p></li><li><p>To finish off the look of the slingshot, we need to create the elastic bands that tie the pouch to the fork. We will do this by first creating the <code class="literal">SlingshotBand</code> script.</p></li><li><p>The script <a id="id438" class="indexterm"></a>starts with two variables, one for the point that the band will end at and one to reference the <code class="literal">LineRenderer</code> variable that will draw it:</p><div class="informalexample"><pre class="programlisting">public Transform endPoint;
public LineRenderer lineRenderer;</pre></div></li><li><p>The <code class="literal">Awake</code> function ensures that the <code class="literal">lineRenderer</code> variable has only two points and sets their initial positions:</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  if(lineRenderer == null) return;
  if(endPoint == null) return;

  lineRenderer.SetVertexCount(2);
  lineRenderer.SetPosition(0, transform.position);
  lineRenderer.SetPosition(1, endPoint.position);
}</pre></div></li><li><p>In the <code class="literal">LateUpdate</code> function, we set the <code class="literal">lineRenderer</code> variable's end position to the <code class="literal">endPoint</code> value. This point will move around with the pouch, so we need to constantly update the renderer:</p><div class="informalexample"><pre class="programlisting">public void LateUpdate() {
  if(endPoint == null) return;
  if(lineRenderer == null) return;

  lineRenderer.SetPosition(1, endPoint.position);
}</pre></div></li><li><p>Return to Unity and create an empty <span class="strong"><strong>GameObject</strong></span>. Name it <code class="literal">Band_Near</code> and make it a child of the <code class="literal">Slingshot</code> object.</p></li><li><p>As children of this new point, create a cylinder and a second empty <span class="strong"><strong>Gameobject</strong></span>, named <code class="literal">Band</code>.</p></li><li><p>Give the cylinder a brown material and position it around the near prong of the slingshot fork. Be sure to remove the <span class="strong"><strong>Capsule Collider</strong></span> component so that it doesn't get in the way. Also, don't be afraid to scale it in order to make it fit the look of the slingshot better.</p></li><li><p>To the <code class="literal">Band</code> object, add a <span class="strong"><strong>Line Renderer</strong></span> component found under <span class="strong"><strong>Effects</strong></span> in the <span class="strong"><strong>Component</strong></span> menu. After positioning it in the center of the cylinder, add the <code class="literal">SlingshotBand</code> script to the object.</p></li><li><p>To the <span class="strong"><strong>Line Renderer</strong></span> component under <span class="strong"><strong>Materials</strong></span>, you can put your brown material in the slot to color the band. Under <span class="strong"><strong>Parameters</strong></span>, set the <span class="strong"><strong>Start Width</strong></span> to <code class="literal">0.5</code> and the <span class="strong"><strong>End Width</strong></span> to <code class="literal">0.2</code> in order to set the size of the line.</p></li><li><p>Next, create another empty <span class="strong"><strong>GameObject</strong></span> and name it <code class="literal">BandEnd_Near</code>. Make it a child of the <code class="literal">Pouch</code> object and position it inside the pouch.</p></li><li><p>Now, connect <a id="id439" class="indexterm"></a>the script's references to its line renderer and end point.</p></li><li><p>To make the second band, duplicate the four objects we just created and position them according to the other prong of the fork. The end point for this band can just be moved back along the <span class="emphasis"><em>z</em></span> axis to keep it out of the way of the birds.</p></li><li><p>Finally, turn the whole thing into a prefab so that it can be easily reused in other levels.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_07_04.jpg" /></div></li></ol></div><p>We created the slingshot that will be used to fire birds. We used techniques that we learned in the<a id="id440" class="indexterm"></a> previous chapter to handle touch input and to track the player's finger while they aim and shoot. If you save your scene and position the camera to look at the slingshot, you will notice that it is complete, if not entirely playable. Birds can be fired at the pig fortress, although we can only see the destruction from within Unity's <span class="strong"><strong>Scene</strong></span> view.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec46"></a>Watching with the camera</h3></div></div></div><p>The game is <a id="id441" class="indexterm"></a>technically playable at this point, but it is kind of hard to see what is going on. Next, we will create a system to control the camera. The system will allow the player to drag the camera to the left and right, follow the bird when it is launched, and return to the slingshot when everything stops moving. There will also be a set of limits to keep the camera from going too far and viewing things we do not want the player to see, such as beyond the edge of the ground or sky we have created for the level. We will only need one, fairly short, script to control and manage our camera. Let's create it with these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To start and to keep everything organized, create a new empty <span class="strong"><strong>GameObject</strong></span> and name it <code class="literal">CameraRig</code>. Also, to keep it simple, set its position to zero on each axis.</p></li><li><p>Next, create three more empty <span class="strong"><strong>GameObjects</strong></span> and name them <code class="literal">LeftPoint</code>, <code class="literal">RightPoint</code>, and <code class="literal">TopPoint</code>. Set their <span class="strong"><strong>Z</strong></span> axis positions to <code class="literal">-5</code>. Position the <code class="literal">LeftPoint</code> object to be in front of the slingshot and <code class="literal">3</code> on the <span class="strong"><strong>Y</strong></span> axis. The <code class="literal">RightPoint</code> object needs to be positioned in front of the pig structure you created. The <code class="literal">TopPoint</code> object can be over the slingshot but needs to be set to <code class="literal">8</code> on the <span class="strong"><strong>Y</strong></span> axis. These three points will define the limits of where our camera can move when being dragged and following the birds.</p></li><li><p>Make all the three points and the <code class="literal">Main Camera</code> object children of the <code class="literal">CameraRig</code> object.</p></li><li><p>Now, we create the <code class="literal">CameraControl</code> script. This script will control all the movement and interaction with the camera.</p></li><li><p>Our variables for this script start with a reference to the slingshot; we need this so that we can follow the current bird when it is fired. The next are the references to the points we just created. The next group of variables control for how long the camera will sit without input before returning to take a look at the slingshot and how fast it will return. The <code class="literal">dragScale</code> variable controls how fast the camera actually moves when the player drags their finger across the screen, allowing you to keep the scene moving with the finger. The last group controls whether the camera can follow the current bird and how fast it can do so:</p><div class="informalexample"><pre class="programlisting">public Slingshot slingshot;
public Transform rightPoint;
public Transform leftPoint;
public Transform topPoint;

public float waitTime = 3f;
private float headBackTime = -1f;
private Vector3 waitPosition;
private float headBackDuration = 3f;

public float dragScale = 0.075f;

private bool followBird = false;
private Vector3 followVelocity = Vector3.zero;
public float followSmoothTime = 0.1f;</pre></div></li><li><p>In the <code class="literal">Awake</code> function, we <a id="id442" class="indexterm"></a>first make certain that the camera is not following a bird and make it wait before heading to take a look at the slingshot. This allows you to initially point the camera to the pig fortress when the level starts and move to the slingshot after giving the player a chance to see what they are up against:</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  followBird = false;
  StartWait();
}</pre></div></li><li><p>The <code class="literal">StartWait</code> function sets the time when it will start to head back to the slingshot and records the position that it is heading back from. This allows you to create a smooth transition:</p><div class="informalexample"><pre class="programlisting">public void StartWait() {
  headBackTime = Time.time + waitTime;
  waitPosition = transform.position;
}</pre></div></li><li><p>Next, we have the <code class="literal">Update</code> function. This function starts by checking whether the slingshot has fired. If it hasn't, it checks whether the player has started aiming, signaling that the bird should be followed and zeroing out the velocity if they have. If they have not started aiming, the <code class="literal">followBird</code> flag is cleared. Next, the function checks whether it should follow and does so if it should, also calling the <code class="literal">StartWait</code> function—in case this is the frame in which the bird is destroyed. If it should not follow the bird, it checks for touch input and drags the camera if it finds any. The wait is again started in case the player removes their finger from this frame. Finally, it checks to see whether the slingshot <a id="id443" class="indexterm"></a>is done firing the current bird and whether it is time to head back. Should both be true, the camera moves back to point at the slingshot:</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(!slingshot.didFire) {
    if(slingshot.isAiming) {
      followBird = true;
      followVelocity = Vector3.zero;
    }
    else {
      followBird = false;
    }
  }

  if(followBird) {
    FollowBird();
    StartWait();
  }
  else if(Input.touchCount &gt; 0) {
    DragCamera();
    StartWait();
  }

  if(!slingshot.didFire &amp;&amp; headBackTime &lt; Time.time) {
    BackToLeft();
  }
}</pre></div></li><li><p>The <code class="literal">FollowBird</code> function starts by making sure that there is a bird to follow, by checking the <code class="literal">toFireBird</code> variable on the <code class="literal">Slingshot</code> script, and stops following if a bird is not found. Should there be a bird, the function then determines a new point to move to, which will look directly at the bird. It then uses the <code class="literal">Vector3.SmoothDamp</code> function to smoothly follow the bird. This function works similar to a spring—the farther away it is from its target position, the faster it moves the object. The <code class="literal">followVelocity</code> variable is used to keep it moving smoothly. Finally, it calls another function to limit the camera's position within the bounding points we set up earlier:</p><div class="informalexample"><pre class="programlisting">private void FollowBird() {
  if(slingshot.toFireBird == null) {
    followBird = false;
    return;
  }

  Vector3 targetPoint = slingshot.toFireBird.transform.position;
  targetPoint.z = transform.position.z;

  transform.position = Vector3.SmoothDamp(transform.position, targetPoint, ref followVelocity, followSmoothTime);
  ClampPosition();
}</pre></div></li><li><p>In the <code class="literal">DragCamera</code> function, we use the <code class="literal">deltaPosition</code> value of the current touch <a id="id444" class="indexterm"></a>to determine how far it has moved since the last frame. By scaling this value and subtracting the vector from the camera's position, the function moves the camera as the player drags across the screen. This function also calls upon the <code class="literal">ClampPosition</code> function to keep the camera's position within the field of play:</p><div class="informalexample"><pre class="programlisting">private void DragCamera() {
  transform.position -= new Vector3(Input.GetTouch(0).deltaPosition.x, Input.GetTouch(0).deltaPosition.y, 0) * dragScale;
  ClampPosition();
}</pre></div></li><li><p>The <code class="literal">ClampPosition</code> function starts by taking the camera's current position. It then clamps the <code class="literal">x</code> position to be between those of the <code class="literal">leftPoint</code> and <code class="literal">rightPoint</code> variables' <code class="literal">x</code> positions. Next, the <code class="literal">y</code> position is clamped between the <code class="literal">leftPoint</code> and <code class="literal">topPoint</code> variables' <code class="literal">y</code> positions. Finally, the new position is reapplied to the camera's transform:</p><div class="informalexample"><pre class="programlisting">private void ClampPosition() {
  Vector3 clamped = transform.position;
  clamped.x = Mathf.Clamp(clamped.x, leftPoint.position.x, rightPoint.position.x);
  clamped.y = Mathf.Clamp(clamped.y, leftPoint.position.y, topPoint.position.y);
  transform.position = clamped;
}</pre></div></li><li><p>Finally, we have the <code class="literal">BackToLeft</code> function. It starts by using the time and our duration variable to determine how much progress the camera will have made to return to the slingshot. It records the camera's current position and uses <code class="literal">Mathf.SmoothStep</code> on both the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes to find a new position that is at an appropriate distance between the <code class="literal">waitPosition</code> variable and the <code class="literal">leftPoint</code> variable. Finally, the new position is applied:</p><div class="informalexample"><pre class="programlisting">private void BackToLeft() {
  float progress = (Time.time – headBackTime) / headBackDuration;
  Vector3 newPosition = transform.position;
  newPosition.x = Mathf.SmoothStep(waitPosition.x, leftPoint.position.x, progress);
  newPosition.y = Mathf.SmoothStep(waitPosition.y, leftPoint.position.y, progress);
  transform.position = newPosition;
}</pre></div></li><li><p>Next, return to Unity and add the new script to the <code class="literal">Main Camera</code> object. Connect the references to the slingshot and each of the points to finish it off.</p></li><li><p>Position the camera to point at your pig fortress and turn the whole rig into a prefab.</p></li></ol></div><p>We created <a id="id445" class="indexterm"></a>a camera rig that will let the player watch all the action as they play the game. The camera will now follow the birds as they are fired from the slingshot and can now be dragged by the player. By keying off the positions of a few objects, this movement is limited to keep the player from seeing things we don't want them to; if the camera is left idle for long enough, it will also return to look at the slingshot.</p><p>Another function of the camera, common to many mobile games, is the pinch-to-zoom gesture. It is such a simple gesture for the user to expect, but it can be complex for us to implement well. Try your hand at implementing it here. You can use <code class="literal">Input.touchCount</code> to detect whether there are two fingers touching the screen. Then, using the <code class="literal">Vector2.Distance</code> function, if you have recorded the distance from the last frame, it is possible to determine whether they are moving toward or away from each other. Once you have determined your zoom direction, just change the camera's <code class="literal">ortographicSize</code> variable to change how much can be seen; be sure to include some limits so that the player can't zoom in or out forever.</p><p>Now that we have all the pieces needed to make a complete level, we need some more levels. We need at least two more levels. You can use the blocks and pigs to create any level you might want. It is a good idea to keep structures centered around the same spot as our first level, giving the player an easier time dealing with them. Also, think about the difficulty of the level while making it so that you end up with an easy, medium, and hard level.</p></div></div>