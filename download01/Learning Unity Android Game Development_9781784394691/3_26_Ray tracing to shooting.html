<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec30"></a>Ray tracing to shooting</h2></div></div><hr /></div><p>Play the<a id="id231" class="indexterm"></a> game now; it is pretty cool. We have our drivable tank and textured city. We even have fancy animated targets. We are just missing one thing: how do we shoot? We need to make one more script and we can shoot targets to our heart's content. Follow these steps to <a id="id232" class="indexterm"></a>create the script and set it up:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, we need to add an empty <code class="literal">GameObject</code> to our tank. Rename it to <code class="literal">MuzzlePoint</code> and make it a child of the cannon's pivot point object. Once this is done, position it at the end of the cannon so that the blue arrow points away from the tank, along the same direction as the cannon. This will be the point where our bullets will come from.</p></li><li><p>We also need something to indicate where we are shooting. The explosions are covered in future chapters, so choose <span class="strong"><strong>Sphere</strong></span> from the <span class="strong"><strong>3D Object</strong></span> menu underneath <span class="strong"><strong>GameObject</strong></span> and rename it to <code class="literal">TargetPoint</code>.</p></li><li><p>Set the sphere's scale to <code class="literal">0.2</code> for each axis and give it a red material. This way, it can be more easily seen without being completely obtrusive. It does not matter where it starts in our scene, our next script will move it around when we shoot.</p></li><li><p>Remove the <code class="literal">SphereCollider</code> component from <code class="literal">TargetPoint</code>. The <code class="literal">SphereCollider</code> has to be removed because we don't want to shoot our own target indicator.</p></li><li><p>Now, create <a id="id233" class="indexterm"></a>a new script and call it <code class="literal">FireControls</code>.</p></li><li><p>This should start to look familiar to you. We start with variables to hold references to our muzzle and targeting objects that we just created.</p><div class="informalexample"><pre class="programlisting">public Transform muzzlePoint;
public Transform targetPoint;</pre></div></li><li><p>The <code class="literal">Fire</code> function starts by defining a variable that will hold the detailed information about what was shot:</p><div class="informalexample"><pre class="programlisting">public void Fire() {
  RaycastHit hit;</pre></div></li><li><p>It is followed by an <code class="literal">if</code> statement that checks the <code class="literal">Physics.Raycast</code> function. The <code class="literal">Raycast</code> function works just like shooting a gun. We start with a position (the muzzle point's position) pointing to a specific direction (forward relative to the muzzle point along that blue axis) and get out what was hit. If we hit something, the <code class="literal">if</code> statement evaluates to <code class="literal">true</code>; otherwise, it is <code class="literal">false</code> and we would skip ahead.</p><div class="informalexample"><pre class="programlisting">if(Physics.Raycast(muzzlePoint.position, muzzlePoint.forward, out hit)) {</pre></div></li><li><p>When we do hit something, we first move our target point to the point that was hit. We then use the <code class="literal">SendMessage</code> function to tell what we hit that it has been hit, the same way we used it in our <code class="literal">RepeatButton</code> script earlier. We use <code class="literal">hit.transform.root.gameObject</code> to get at the GameObject that was hit. We also provide it with a value, <code class="literal">hit.point</code>, to tell the object where it was hit. The <code class="literal">SendMessageOptions.DontRequireReceiver</code> part of the line keeps the function from throwing an error if it is unable to find the desired function. Our targets have the function, but the city walls do not and they would throw an error.</p><div class="informalexample"><pre class="programlisting">targetPoint.position = hit.point;
hit.transform.root.gameObject.SendMessage("Hit", hit.point, SendMessageOptions.DontRequireReceiver);
}</pre></div></li><li><p>The last part of our <code class="literal">Fire</code> function occurs if we didn't hit anything. We send our target point back to the world origin so that the player knows that they missed everything:</p><div class="informalexample"><pre class="programlisting">  else {
    targetPoint.position = Vector3.zero;
  }
}</pre></div></li><li><p>The last thing to add is the <code class="literal">Hit</code> function at the end of our <code class="literal">Target</code> script. We start the function by getting the current state ID, just as we did earlier in the script. However, this<a id="id234" class="indexterm"></a> time we only check against our extended idle ID. If they do not match, we use <code class="literal">return</code> to exit the function early. We do this because we don't want to let the player shoot any targets that are down or in mid-transition. If our state is correct, we continue by telling the animation that we were hit by using the <code class="literal">SetBool</code> function:</p><div class="informalexample"><pre class="programlisting">public void Hit(Vector3 point) {
  int currentStateId = animator.GetCurrentAnimatorStateInfo(0).nameHash;
  if(currentStateId != idleExtendId) return;
  animator.SetBool(wasHitId, true);</pre></div></li><li><p>The rest of the <code class="literal">Hit</code> function figures out on which side the target was hit. To do this, we first have to convert the point that we received from world space into local space. The <code class="literal">InverseTransformPoint</code> function from our <span class="strong"><strong>Transform</strong></span> component does this nicely. We then do a check to see where the shot came from. Due to the way that the target is constructed, if the shot was positive on the <span class="emphasis"><em>x </em></span>axis, it came from behind. Otherwise, it came from the front. Either way, we set the <code class="literal">inTheFront</code> parameter from our state machine to the proper value. Then, we give the player some points by incrementing the static variable that we created in our <code class="literal">ScoreCounter</code> script, way back at the beginning of the chapter:</p><div class="informalexample"><pre class="programlisting">Vector3 localPoint = transform.InverseTransformPoint(point);
if(localPoint.x &gt; 0) {
  animator.SetBool(inTheFrontId, false);
  ScoreCounter.score += 5;
}
else {
  animator.SetBool(inTheFrontId, true);
  ScoreCounter.score += 10;
}
}</pre></div></li><li><p>Next, we need to add the new <code class="literal">FireControls</code> script to the tank. You also need to connect the references to the <code class="literal">MuzzlePoint</code> and <code class="literal">TargetPoint</code> objects.</p></li><li><p>Finally, we need to create a new button to control and trigger this script. So, navigate to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>UI</strong></span> | <span class="strong"><strong>Button</strong></span> and rename the button to <code class="literal">Fire</code>.</p></li><li><p>Next, we need to hit the little plus sign in the bottom right of the button's <span class="strong"><strong>Inspector</strong></span> window and select <code class="literal">Tank</code> for the <span class="strong"><strong>Object</strong></span> slot, exactly like we did for our Tic-tac-toe game. Then, navigate to <span class="strong"><strong>FireControls</strong></span> | <span class="strong"><strong>Fire ()</strong></span> from the function drop down.</p></li></ol></div><p>We have created <a id="id235" class="indexterm"></a>a script that allows us to fire the cannon of our tank. The method of using ray tracing is the simplest and most widely used. In general, bullets fly too fast for us to see them. Ray tracing is like this, that is, it is instantaneous. However, this method does not take gravity, or anything else that might change the direction of a bullet, into account.</p><p>Now that all of the buttons and components are in place, make them look better. Use the skills you gained from the previous chapter to style the GUI and make it look great. Perhaps you could even manage to create a directional pad for the movement.</p></div>