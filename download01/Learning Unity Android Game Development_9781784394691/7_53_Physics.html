<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec54"></a>Physics</h2></div></div><hr /></div><p>In Unity, physics simulation <a id="id393" class="indexterm"></a>primarily focuses on the use of the <a id="id394" class="indexterm"></a>
<span class="strong"><strong>Rigidbody</strong></span> component. When the <span class="strong"><strong>Rigidbody</strong></span> component is attached to any object, it will be taken over by the physics engine. The object will fall with gravity and bump into any object that has a collider. In our scripts, making use of the <code class="literal">OnCollision</code> group of functions and the <code class="literal">OnTrigger</code> group of functions requires a <span class="strong"><strong>Rigidbody</strong></span> component to be attached to at least one of the two interacting objects. However, a <span class="strong"><strong>Rigidbody</strong></span> component can interfere with any specific movement we might cause the object to take. But the <span class="strong"><strong>Rigidbody</strong></span> component can be marked as kinematic, which means that the physics engine will not move it, but it will only move when our script moves it. The <span class="strong"><strong>CharacterController</strong></span> component that we used for our tank is a special, modified <span class="strong"><strong>Rigidbody</strong></span>. In this chapter, we will be making heavy use of the <span class="strong"><strong>Rigidbody</strong></span> component to tie all our birds, blocks, and pigs into the physics engine.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec41"></a>Building blocks</h3></div></div></div><p>For our<a id="id395" class="indexterm"></a> first physics objects, we will create the blocks that the pig castles are built out of. We will be creating three types of blocks: wood, glass, and rubber. With these few simple blocks, we will be able to easily create a large variety<a id="id396" class="indexterm"></a> of levels and structures to be smashed with birds.</p><p>Each of the blocks we will be creating will be largely similar. So, we will start with the basic one, the wooden plank, and expand upon it to create the others. Let's use these steps to create the blocks:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, we will create the plank of wood. To do this, we need another cube. Rename it <code class="literal">Plank_Wood</code>.</p></li><li><p>Set the value of the plank's <span class="strong"><strong>Scale</strong></span> to <code class="literal">0.25</code> for the <span class="strong"><strong>X</strong></span> axis and <code class="literal">2</code> for both the <span class="strong"><strong>Y</strong></span> and <span class="strong"><strong>Z</strong></span> axes. Its scale on the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes defines its size as seen by the player. The scale on the <span class="emphasis"><em>z</em></span> axis helps us ensure that it will be hit by other physics objects in the scene.</p></li><li><p>Next, create a new material using the <code class="literal">plank_wood</code> texture and apply it to the cube.</p></li><li><p>To make this new wooden plank into a physics object suitable for our game, we need to remove the cube's <span class="strong"><strong>Box Collider</strong></span> component and replace it with a <span class="strong"><strong>Box Collider 2D</strong></span> component. Also, add a <span class="strong"><strong>Rigidbody</strong></span> component. Make sure that your plank is selected; go to the menu bar of Unity and navigate to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics 2D</strong></span> | <span class="strong"><strong>Rigidbody 2D</strong></span>.</p></li><li><p>Next, we <a id="id397" class="indexterm"></a>need to make the plank function properly within our game; we need to create a new script and name it <code class="literal">Plank</code>.</p></li><li><p>This script <a id="id398" class="indexterm"></a>begins with a bunch of variables. The first two variables are used to track the health of the plank. We need to separate the total amount of health from the current health, so that we will be able to detect when the object has been reduced to its half-health. At this point, we will make use of our next three variables to change the object's material to one that shows damage. The last variable is used when the object runs out of health and is destroyed. We will use it to increase the player's score:</p><div class="informalexample"><pre class="programlisting">public float totalHealth = 100f;
private float health = 100f;

public Material damageMaterial;
public Renderer plankRenderer;
private bool didSwap = false;

public int scoreValue = 100;</pre></div></li><li><p>For the script's first function, we use <code class="literal">Awake</code> for initialization. We make sure that the object's current health is the same as its total health and the <code class="literal">didSwap</code> flag is set to <code class="literal">false</code>:</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  health = totalHealth;
  didSwap = false;
}</pre></div></li><li><p>Next, we make use of the <code class="literal">OnCollisionEnter2D</code> function, which is just the 2D optimized version of the normal <code class="literal">OnCollisionEnter</code> function used in 3D. This is a special function, triggered by the <span class="strong"><strong>Rigidbody</strong></span> component, that gives us information about what the object collided with and how. We use this information to find <code class="literal">collision.relativeVelocity.magnitude</code>. This is the speed at which the objects collided, and we use this as damage in order to reduce the current health. Next, the function checks to see whether the health has been reduced to half and calls the <code class="literal">SwapToDamaged</code> function if it has. By using the <code class="literal">didSwap</code> flag, we make sure that the function is only called once. Finally, the<a id="id399" class="indexterm"></a> function checks to see whether the health has dropped below zero. If it has, the object is destroyed and we call the <code class="literal">LevelTracker</code> script, which we will soon be making, to add to the player's score:</p><div class="informalexample"><pre class="programlisting">public void OnCollisionEnter2D(Collision2D collision) {
  health -= collision.relativeVelocity.magnitude;

  if(!didSwap &amp;&amp; health &lt; totalHealth / 2f) {
    SwapToDamaged();
  }

  if(health &lt;= 0) {
    Destroy(gameObject);
    LevelTracker.AddScore(scoreValue);
  }
}</pre></div></li><li><p>Finally, for <a id="id400" class="indexterm"></a>the script, we have the <code class="literal">SwapToDamaged</code> function. It starts by setting the <code class="literal">didSwap</code> flag to <code class="literal">true</code>. Next, it checks to make sure that the <code class="literal">plankRenderer</code> and <code class="literal">damageMaterial</code> variables have references to other objects. Ultimately, it uses the <code class="literal">plankRenderer.sharedMaterial</code> value to change the material to the damaged-looking material:</p><div class="informalexample"><pre class="programlisting">public void SwapToDamaged() {
  didSwap = true;
  if(plankRenderer == null) return;

  if(damageMaterial != null) {
    plankRenderer.sharedMaterial = damageMaterial;
  }
}</pre></div></li><li><p>Before we can add our <code class="literal">Plank</code> script to our objects, we need to create the <code class="literal">LevelTracker</code> script that was mentioned earlier. Create it now.</p></li><li><p>This script is fairly short and starts with a single variable. The variable will track the player's score for the level and is static, so it can easily be changed as objects are destroyed, for points:</p><div class="informalexample"><pre class="programlisting">private static int score = 0;</pre></div></li><li><p>Next, we use the <code class="literal">Awake</code> function to make sure the player starts at zero when beginning a level:</p><div class="informalexample"><pre class="programlisting">public void Awake() {
  score = 0;
}</pre></div></li><li><p>Finally, for the script, we add the <code class="literal">AddScore</code> function. This function simply takes the amount of points passed to it and increases the player's score. It is also static, so it can be called by any object in the scene without needing a reference to the script:</p><div class="informalexample"><pre class="programlisting">public static void AddScore(int amount) {
  score += amount;
}</pre></div></li><li><p>Back in <a id="id401" class="indexterm"></a>Unity, we <a id="id402" class="indexterm"></a>need to create a new material using the <code class="literal">plank_wood_damaged</code> texture. This will be the material that the script will swap to.</p></li><li><p>We need to add the <code class="literal">Plank</code> script to our <code class="literal">Plank_Wood</code> object. Connect the <span class="strong"><strong>Damaged Material</strong></span> reference to the new material and the <span class="strong"><strong>Plank Renderer</strong></span> reference to the object's <span class="strong"><strong>Mesh Renderer</strong></span> component.</p></li><li><p>As we create different types of planks, we can adjust the value of <span class="strong"><strong>Total Health</strong></span> to give them different strengths. A value of <code class="literal">25</code> works pretty well for the wood planks.</p></li><li><p>Next, create an empty <span class="strong"><strong>GameObject</strong></span> and rename it <code class="literal">LevelTracker</code>.</p></li><li><p>Add the <code class="literal">LevelTracker</code> script to the object, and it will begin to track the player's score.</p></li><li><p>If you want to see the wood plank in action, position it above the ground and hit the play button. As soon as the game starts, Unity's physics will take over and drop the plank with gravity. If it started out high enough, you will be able to see it switch textures as it loses health.</p></li><li><p>To make the other two planks that we need, select the <code class="literal">Plank_Wood</code> object and press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span> twice to duplicate it. Rename one plank to <code class="literal">Plank_Glass</code> and the other to <code class="literal">Plank_Rubber</code>.</p></li><li><p>Next, create three new materials. One should be purple in color for the rubber plank, one should use the <code class="literal">plank_glass</code> texture for the glass plank, and the last material should use the <code class="literal">plank_glass_damaged</code> texture for when the glass plank is damaged. Apply the new materials to the proper locations for the new planks.</p></li><li><p>As for the health of the new planks, a value of <code class="literal">15</code> for the glass and <code class="literal">100</code> for the rubber will work well.</p></li><li><p>Finally, turn your three planks into prefabs and use them to build a structure for you to knock down. Feel free to scale them in order to make differently sized blocks, but <a id="id403" class="indexterm"></a>leave the <span class="emphasis"><em>z</em></span> axis alone. Also, all of the blocks should be positioned at <code class="literal">0</code> on the <span class="emphasis"><em>z</em></span> axis and your structure should be centered around about <code class="literal">30</code> on the <span class="emphasis"><em>x</em></span> axis.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_07_02.jpg" /></div></li></ol></div><p>We have created the building blocks we needed for the structures that are going to be knocked down in our game. We used a <span class="strong"><strong>Rigidbody</strong></span> component to tie them into the physics engine. Also, we created <a id="id404" class="indexterm"></a>a script that keeps track of their health and swaps to damaged materials when it drops below half. For this game, we are sticking <a id="id405" class="indexterm"></a>to the 2D optimized versions of all the physics components. They work in exactly the same way as the 3D versions, just without the third axis.</p><p>Wood and glass work well as basic blocks. However, if we are going to make harder levels, we need something a little stronger. Try your hand at making a stone block. Create two textures and materials for it to show its pristine and damaged states.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec42"></a>Physics materials</h3></div></div></div><p>Physics materials <a id="id406" class="indexterm"></a>are special types of materials that specifically tell the physics engine how two objects should interact. This does not affect the appearance of an object. It defines the friction and bounciness of a collider. We will use them to give our rubber plank some bounce and the glass plank some slide. With these few steps, we can <a id="id407" class="indexterm"></a>quickly implement physics materials to create a pleasing effect:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Physics materials are created in the same way as everything else, in the <span class="strong"><strong>Project</strong></span> panel. Right-click inside the <span class="strong"><strong>Project</strong></span> panel and navigate to <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Physics2D Material</strong></span>. Create two physics materials and name one of them <code class="literal">Glass</code> and the other <code class="literal">Rubber</code>.</p></li><li><p>Select one of them and take a look at it in the <span class="strong"><strong>Inspector</strong></span> window. The 2D version has only two values (the 3D version has a few extra values, but they are only used in more complex situations):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Friction</strong></span>: This property controls the amount of movement lost when sliding along a surface. A value of zero denotes no friction, such as ice, and a value of one denotes a lot of friction, such as rubber.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Bounciness</strong></span>: This property is how much of an object's energy is reflected when it hits something or is hit by something. Zero means none of the energy is reflected, while a value of one means the object will reflect all of it.</p></li></ul></div></li><li><p>For the <code class="literal">Glass</code> material, set the <span class="strong"><strong>Friction</strong></span> value to <code class="literal">0.1</code> and <span class="strong"><strong>Bounciness</strong></span> to <code class="literal">0</code>. For the <code class="literal">Rubber</code> material, set the <span class="strong"><strong>Friction</strong></span> to <code class="literal">1</code> and <span class="strong"><strong>Bounciness</strong></span> to <code class="literal">0.8</code>.</p></li><li><p>Next, select your <code class="literal">Plank_Glass</code> prefab and take a look at its <span class="strong"><strong>Box Collider 2D</strong></span> component. To apply your new physics materials, simply drag and drop them one by one from the <span class="strong"><strong>Project</strong></span> panel to the <span class="strong"><strong>Material</strong></span> slot. Do the same for your <code class="literal">Plank_Rubber</code> prefab, and any time an object hits one of them, the materials will <a id="id408" class="indexterm"></a>be used to control their interaction.</p></li></ol></div><p>We have created <a id="id409" class="indexterm"></a>a pair of physics materials. They control how two colliders interact when they run into each other. Using these, we are given control over the amount of friction and bounciness that is possessed by any collider.</p></div></div>