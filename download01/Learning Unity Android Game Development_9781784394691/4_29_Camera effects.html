<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec32"></a>Camera effects</h2></div></div><hr /></div><p>There <a id="id236" class="indexterm"></a>are many great camera effects that you should add in order to give your game the last great finishing touch. In this chapter, we will be covering a few options that are easy to add. These will also give our tank game a finished look.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec29"></a>Skyboxes and distance fog</h3></div></div></div><p>When a <a id="id237" class="indexterm"></a>camera renders the frame of a game, it starts by clearing the <a id="id238" class="indexterm"></a>screen. The default camera in Unity does this by coloring everything <a id="id239" class="indexterm"></a>with a gradient, simulating the look of a skybox. All <a id="id240" class="indexterm"></a>of the game's meshes are then drawn on top of this blank screen. While the gradient looks better than a solid color, it is still rather boring for an exciting battle of tanks. Luckily for us, Unity allows us to change the skybox. A skybox is just a fancy word for the series of images that form the background sky of any game. Distance fog works in conjunction with the skybox by easing the visual transition between models and the background.</p><p>The very first thing we need is a new skybox. We can create our own, however, Unity provides us with several excellent ones that will fit our needs just fine. Let's use the following steps to get a skybox now:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>At the top of the Unity Editor, select <span class="strong"><strong>Assets</strong></span> and then click on <span class="strong"><strong>Import Package</strong></span>. About halfway down this list, select <span class="strong"><strong>Skyboxes</strong></span>.</p></li><li><p>After a little bit of processing, a new window will pop up. A package in Unity is just a compressed group of assets that have already been set up in Unity. This window displays the contents and allows you to selectively import them. We want them all, so we just click on <span class="strong"><strong>Import</strong></span> in the bottom-right corner of this window.</p></li><li><p>A new folder, <code class="literal">Standard Assets</code>, will be added to the <span class="strong"><strong>Project</strong></span> window. This contains a folder, <code class="literal">Skyboxes</code>, which contains various skybox materials. Select any one of these. You can see in the <span class="strong"><strong>Inspector</strong></span> window that they are normal materials that make use of the skybox shader. They each have six images, one for each direction of a box.</p></li><li><p>You will also notice that there are warning messages with a <span class="strong"><strong>Fix Now</strong></span> button under each image. This is because all the images were compressed to save import time and space, but the skybox shader needs them in a different format. Just click on the <span class="strong"><strong>Fix Now</strong></span> button each time and Unity will automatically fix it for you. It will also get rid of all of the odd blackness in the material preview.</p></li><li><p>To add a skybox of your choice to the game, first make sure that you have the correct scene loaded. If you do not, simply double-click on the scene in the <span class="strong"><strong>Project</strong></span> window. This is necessary because the settings we are about to change are specific to each scene.</p></li><li><p>Go to the top of the Unity Editor and select <span class="strong"><strong>Edit</strong></span> and then click on <span class="strong"><strong>Scene Render Settings</strong></span>. The new group of settings will appear in the <span class="strong"><strong>Inspector</strong></span> window.</p></li><li><p>At the moment, we are concerned with the value at the top, <span class="strong"><strong>Skybox Material</strong></span>. Just<a id="id241" class="indexterm"></a> drag and drop the new skybox material into<a id="id242" class="indexterm"></a> the <span class="strong"><strong>Skybox Material</strong></span> slot and it will be automatically<a id="id243" class="indexterm"></a> updated. The change can be viewed<a id="id244" class="indexterm"></a> right away in the <span class="strong"><strong>Game</strong></span> and <span class="strong"><strong>Scene</strong></span> windows.</p></li><li><p>To add distance fog, we also adjust this setting in <span class="strong"><strong>Scene Render Settings</strong></span>. To turn it on, simply tick the <span class="strong"><strong>Use Fog</strong></span> checkbox.</p></li><li><p>The next setting, <span class="strong"><strong>Fog Color</strong></span>, allows you to pick a color for the fog. It is good to pick a color that is close to the general color of the skybox.</p></li><li><p>The<span class="strong"><strong> Fog Mode</strong></span> setting is a drop-down list of options that dictate the method that Unity will use to calculate the distance fog. For nearly all cases, the default setting of <span class="strong"><strong>Exponential Squared</strong></span> is suitable.</p></li><li><p>The next three settings, <span class="strong"><strong>Density</strong></span>, <span class="strong"><strong>Start</strong></span>, and <span class="strong"><strong>End</strong></span>, determine how much fog there is and how close it starts. They will only appear for the fog modes that use them. <span class="strong"><strong>Density</strong></span> is used for the <span class="strong"><strong>Exponential</strong></span> and <span class="strong"><strong>Exponential Squared</strong></span> fog modes, while the others are used for the <span class="strong"><strong>Linear</strong></span> fog mode. Settings that put the fog at the edge of sight will, in general, give the best-looking effect. Leave these settings on <span class="strong"><strong>Exponential Squared</strong></span> and choose <code class="literal">0.03</code> for the <span class="strong"><strong>Density</strong></span> in order to get a good look.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_04_01.jpg" /></div></li></ol></div><p>We<a id="id245" class="indexterm"></a> have <a id="id246" class="indexterm"></a>imported several skyboxes and added <a id="id247" class="indexterm"></a>them<a id="id248" class="indexterm"></a> to the scene. The distance fog settings are also turned on and adjusted. Now, our scene has started to look like a real game.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec30"></a>Target indicator</h3></div></div></div><p>Another<a id="id249" class="indexterm"></a> camera effect that is rather interesting is the use <a id="id250" class="indexterm"></a>of multiple cameras. A second camera can be used to make a 3D GUI, a minimap, or perhaps a security camera popup. In the next section, we will be creating a system that will point at targets that are nearby. Using a second camera, we will make the indicators appear above the player's tank.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec38"></a>Creating the pointer</h4></div></div></div><p>We are <a id="id251" class="indexterm"></a>going to start by creating an object that will point at targets. We will be making a prefab that can be used repeatedly. However, you will need to import the <code class="literal">IndicatorSliceMesh.blend</code> starting asset for this chapter, so we have something for the player to see. It is a pie-slice-shaped mesh. Let's perform the following steps to create the pointer:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Once you<a id="id252" class="indexterm"></a> have the mesh imported, add it to the scene.</p></li><li><p>Create an empty <span class="strong"><strong>GameObject</strong></span> component and rename it to <code class="literal">IndicatorSlice</code>.</p></li><li><p>Make the mesh a child of <code class="literal">IndicatorSlice</code> and position it so that it points along the <span class="emphasis"><em>z</em></span> axis of <code class="literal">GameObject</code>, with the small end of the pie slice being at the position of <code class="literal">IndicatorSlice</code>. The <code class="literal">IndicatorSlice</code> GameObject will be centered in our indicator. Each slice that is created will have its <span class="emphasis"><em>z</em></span> axis pointing in the direction of a target, as shown in the following figure:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_04_02.jpg" /></div></li><li><p>Now, we need to create a new script that will control our indicator. Create a new script called <code class="literal">TargetIndicator</code> in the <span class="strong"><strong>Project</strong></span> window.</p></li><li><p>We start off this script with a pair of variables. The first variable will hold a reference to the target that this indicator piece will point at. The indicator is also <a id="id253" class="indexterm"></a>going to grow and shrink, based on how far away the target is. The second variable will control the distance at which the indicator will start to grow:</p><div class="informalexample"><pre class="programlisting">public Transform target;
public float range = 25;</pre></div></li><li><p>The next function will be used to set the <code class="literal">target</code> variable when the indicator piece is created:</p><div class="informalexample"><pre class="programlisting">public void SetTarget(Transform newTarget) {
  target = newTarget;
}</pre></div></li><li><p>The last set of code goes in the <code class="literal">LateUpdate</code> function. The <code class="literal">LateUpdate</code> function is used so that the indicator pieces can point at a target after our tank moves in the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">public void LateUpdate() {</pre></div></li><li><p>We start the function by checking whether the <code class="literal">target</code> variable has a value. If it is null, the indicator slice is destroyed. The <code class="literal">Destroy</code> function can be used to remove any object that exists from the game. The <code class="literal">gameObject</code> variable is automatically provided by the <code class="literal">MonoBehaviour</code> class and holds a reference to the <span class="strong"><strong>GameObject</strong></span> component that the script component is attached to. Destroying this component will also destroy everything that is a child of (or attached to) it:</p><div class="informalexample"><pre class="programlisting">if(target == null) {
  Destroy(gameObject);
  return;
}</pre></div></li><li><p>Next, we determine how far this indicator slice is from its target. By using <code class="literal">Vector3.Distance</code>, we can easily calculate the distance without doing the math ourselves:</p><div class="informalexample"><pre class="programlisting">float distance = Vector3.Distance(transform.position, target.position);</pre></div></li><li><p>This line of code determines the vertical scale, <span class="emphasis"><em>y</em></span> axis, of the slice. It does so by using a bit of carefully applied math and the <code class="literal">Mathf.Clamp01</code> function. This function limits the supplied value to be between zero and one:</p><div class="informalexample"><pre class="programlisting">float yScale = Mathf.Clamp01((range – distance) / range);</pre></div></li><li><p>We use the calculated scale to set the indicator slice's local scale. By adjusting the local scale, we can easily control how big the whole indicator is just by changing the scale of the parent object:</p><div class="informalexample"><pre class="programlisting">transform.localScale = new Vector3(1, yScale, 1);</pre></div></li><li><p>The <code class="literal">transform.LookAt</code> function is just a fancy, automatic way of rotating a GameObject so that its <span class="emphasis"><em>z</em></span> axis points to a specific spot in the world. However, we want all the indicator slices to lie flat on the ground and not point into the air at any targets that might be above us. So, we first collect the target's position. By setting the variable's <code class="literal">y</code> value to the position of the slice, we ensure that the slice remains flat. That last line, of course, closes off the <code class="literal">LateUpdate</code> function:</p><div class="informalexample"><pre class="programlisting">  Vector3 lookAt = target.position;
  lookAt.y = transform.position.y;
  transform.LookAt(lookAt);
}</pre></div></li><li><p>The <a id="id254" class="indexterm"></a>preceding code is the last code for this script. Return to Unity and add the <code class="literal">TargetIndicator</code> script to the <code class="literal">IndicatorSlice</code> object in the scene.</p></li><li><p>To finish off the indicator, create a prefab of it. Do it just like we did for our target objects.</p></li><li><p>Lastly, delete the <code class="literal">IndicatorSlice</code> object from the scene. We will be creating slices dynamically when the game starts. This requires the prefab, but not the one in the scene.</p></li></ol></div><p>We created a prefab of the object we will be using to indicate the direction of targets. The script that was created and attached will rotate each instance of the prefab to point at the targets in the scene. It will also adjust the scale to indicate how far away the targets are from the player.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec39"></a>Controlling the indicator</h4></div></div></div><p>We now<a id="id255" class="indexterm"></a> need to create a script that will control the indicator slices. This will include creating new slices as they are needed. Also, the <span class="strong"><strong>GameObject</strong></span> component it is attached to will act as a center point for the indicator slices, which we just created, to rotate around. Let's perform these steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new script and name it <code class="literal">IndicatorControl</code>.</p></li><li><p>We start off this script with a pair of variables. The first variable will hold a reference to the prefab that was just created. This will allow us to spawn instances of the prefab whenever we desire. The second is a static variable, which means that it can be easily accessed without a reference to the component that exists in the scene. It will be filled when the game starts with a reference to the instance of this script that is in the scene:</p><div class="informalexample"><pre class="programlisting">public GameObject indicatorPrefab;
private static IndicatorControl control;</pre></div></li><li><p>The next function will be used by the targets. Soon, we will be updating the target's script to call this function at the beginning of the game. The function is static, just like the preceding variable:</p><div class="informalexample"><pre class="programlisting">public static void CreateSlice(Transform target) {</pre></div></li><li><p>This<a id="id256" class="indexterm"></a> function starts by checking whether there is a reference to any object in the static variable. If it is empty, equal to <code class="literal">null</code>, <code class="literal">Object.FindObjectOfType</code> is used to fill the variable. By telling it what type of object we want to find, it will search in the game and try to find one. This is a relatively slow process and should not be used often, but we use this process and the variable so that we can always be sure that the system can find the script:</p><div class="informalexample"><pre class="programlisting">if(control == null) {
  control = Object.FindObjectOfType(typeof(IndicatorControl)) as IndicatorControl;
}</pre></div></li><li><p>The second part of the <code class="literal">CreateSlice</code> function checks to make sure that our static variable is not empty. If so, it tells the instance to create a new indicator slice and passes the target to the slice:</p><div class="informalexample"><pre class="programlisting">if(control != null) {
  control.NewSlice(target);
}
}</pre></div></li><li><p>There is one more function for this script: <code class="literal">NewSlice</code>. The <code class="literal">NewSlice</code> function does as its name implies; it will create new indicator slices when called:</p><div class="informalexample"><pre class="programlisting">public void NewSlice(Transform target) {</pre></div></li><li><p>The function first uses the <code class="literal">Instantiate</code> function to create a copy of <code class="literal">indicatorPrefab</code>:</p><div class="informalexample"><pre class="programlisting">GameObject slice = Instantiate(indicatorPrefab) as GameObject;</pre></div></li><li><p>Next, the function makes the new slice a child of the control's transform, so it will stay with us as we move around. By zeroing out the local position of the new slice, we also insure that it will be at the same location as our control:</p><div class="informalexample"><pre class="programlisting">slice.transform.parent = transform;
slice.transform.localPosition = Vector3.zero;</pre></div></li><li><p>The last line of the function uses the slice's <code class="literal">SendMessage</code> function to call the <code class="literal">SetTarget</code> function that we created previously and passes it the desired target object:</p><div class="informalexample"><pre class="programlisting">  slice.SendMessage("SetTarget", target);
}</pre></div></li><li><p>Now that the script is created, we need to use it. Create an empty <span class="strong"><strong>GameObject</strong></span> component and name it <code class="literal">IndicatorControl</code>.</p></li><li><p>The new <span class="strong"><strong>GameObject</strong></span> component needs to be made a child of the tank, followed by having its position set to zero on each axis.</p></li><li><p>Add the<a id="id257" class="indexterm"></a> script we just created to the <code class="literal">IndicatorControl</code> object.</p></li><li><p>Finally, with the GameObject selected, add the reference to the <code class="literal">IndicatorSlice</code> prefab. Do this by dragging the prefab from the <span class="strong"><strong>Project</strong></span> window to the proper slot in the <span class="strong"><strong>Inspector</strong></span> window.</p></li></ol></div><p>We created a script that will control the spawning of our target indicator slices. The <span class="strong"><strong>GameObject</strong></span> component we created at the end will also allow us to control the size of the whole indicator with ease. We are almost done with the target indicator.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec40"></a>Working with a second camera</h4></div></div></div><p>If you <a id="id258" class="indexterm"></a>were to play the game now, it will still look no different. This is because the targets do not make the call yet to create the indicator slices. We will also be adding the second camera in this section as we finish off with the target indicator. These steps will help us do it well:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start by opening the <code class="literal">Target</code> script and adding the following line of code at the end of the <code class="literal">Awake</code> function. This line tells the <code class="literal">IndicatorControl</code> script to create a new indicator slice for this target:</p><div class="informalexample"><pre class="programlisting">IndicatorControl.CreateSlice(transform);</pre></div><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_04_03.jpg" /></div></li><li><p>If you <a id="id259" class="indexterm"></a>play the game now, you can see the indicator in action. However, it is probably too large and certainly appears inside the tank. A bad solution will be to move the <code class="literal">IndicatorControl</code> object until the whole thing appears above the tank. However, when explosions occur and things start flying through the air, they will obscure the target indicator all over again. A better solution is to add a second camera. You can do so now by selecting <span class="strong"><strong>GameObject</strong></span> from the top of the Unity Editor and then clicking on <span class="strong"><strong>Camera</strong></span>.</p></li><li><p>Additionally, make the camera a child of <code class="literal">Main Camera</code>. Be sure to set the new camera's position and rotation values to <code class="literal">0</code>.</p></li><li><p>By default, every camera in Unity is given a variety of components: <span class="strong"><strong>Camera</strong></span>, <span class="strong"><strong>Flare Layer</strong></span>, <span class="strong"><strong>GUI Layer</strong></span>, and <span class="strong"><strong>Audio Listener</strong></span>. Besides the <span class="strong"><strong>Camera</strong></span> component, the others are generally unimportant to every other camera, and there should only be one <span class="strong"><strong>Audio Listener</strong></span> component in the whole of the scene. Remove the excess components from the camera, leaving just the <span class="strong"><strong>Camera</strong></span> component.</p></li><li><p>Before we do anything else with the camera, we need to change the layer that the <code class="literal">IndicatorSlice</code> prefab is on. Layers are used for selective interaction between objects. They are used primarily for physics and rendering. First select the prefab in the <span class="strong"><strong>Project</strong></span> window.</p></li><li><p>At the top of the <span class="strong"><strong>Inspector</strong></span> window is the <span class="strong"><strong>Layer</strong></span> label with a drop-down list that reads <span class="strong"><strong>Default</strong></span>. Click on the drop-down list and select <span class="strong"><strong>Add Layer...</strong></span> from the list.</p></li><li><p>A list<a id="id260" class="indexterm"></a> of layers will now appear in the <span class="strong"><strong>Inspector</strong></span> window. These are all the layers that are used in the game. The first few are reserved for use by Unity; hence, they have been grayed out. The rest are for our use. Click on the input box at the right-hand side of <span class="strong"><strong>User Layer 8</strong></span> and name it <code class="literal">Indicator</code>.</p></li><li><p>Select the <code class="literal">IndicatorSlice</code> prefab again. This time, select the new <span class="strong"><strong>Indicator</strong></span> layer from the <span class="strong"><strong>Layer</strong></span> drop-down list.</p></li><li><p>Unity will ask whether you want to change the layer of all the child objects as well. We want the whole object rendered on this layer, so we need to select <span class="strong"><strong>Yes, change children</strong></span> and we will be able to do so.</p></li><li><p>Now, let's get back to our second camera. Select the camera and take a look at the <span class="strong"><strong>Inspector</strong></span> window.</p></li><li><p>The first attribute of the <span class="strong"><strong>Camera</strong></span> component is <span class="strong"><strong>Clear Flags</strong></span>. This list of options dictate what the camera will fill the background with before drawing all the models in the game. The second camera should not block out everything drawn by the first camera. We select <span class="strong"><strong>Depth only</strong></span> from the <span class="strong"><strong>Clear Flags</strong></span> drop-down list. This means that instead of putting the skybox in the background, it will leave what was already rendered and just draw new things on top.</p></li><li><p>The next attribute, <span class="strong"><strong>Culling Mask</strong></span>, controls which layers are rendered by the camera. The first two options, <span class="strong"><strong>Nothing</strong></span> and <span class="strong"><strong>Everything</strong></span>, are for the quick deselection and selection of all the layers. For this camera, deselect all other layers so that only the <span class="strong"><strong>Indicator</strong></span> layer has a check next to it.</p></li><li><p>The last thing to do is to adjust the scale of <code class="literal">IndicatorControl</code> so that the target indicator is not too large or small.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_04_04.jpg" /></div></li></ol></div><p>We <a id="id261" class="indexterm"></a>created a system to indicate the direction of potential targets. To do this, we used a second camera. By adjusting the layers in the <span class="strong"><strong>Culling Mask</strong></span> attribute, we can make a camera render only a part of the scene. Also, by changing the <span class="strong"><strong>Clear Flags</strong></span> attribute to <span class="strong"><strong>Depth only</strong></span>, the second camera can draw on top of what was drawn by the first camera.</p><p>It is possible to change where the indicator is drawn by moving the camera. If you were to move the <code class="literal">IndicatorControl</code> object instead, it will change how the distance from the targets and the directions to target are calculated. Move and angle the second camera so that there is a more pleasing view of the target indicator.</p><p>When you move the second camera or when you use the boost (from the next section), you will probably notice that the target indicator can still be seen in the tank. Adjust the main camera so that it does not render the target indicator. This is done similarly to how we made the second camera only render the target indicator objects.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec31"></a>Turbo boost</h3></div></div></div><p>The last<a id="id262" class="indexterm"></a> camera effect that we will be looking at in this chapter is a turbo boost. It is going to be a button on the screen that will propel the player forward rapidly for a short amount of time. The camera effect comes in because a simple adjustment to the <span class="strong"><strong>Field of View</strong></span> attribute can make it look as if we are going much faster. A similar method is used in movies to make car chases look even faster than they are.</p><p>We will <a id="id263" class="indexterm"></a>only be making a single script in this section. The script will move the tank in a similar manner to the <code class="literal">ChassisControls</code> script we created in the last chapter. The difference is that we won't have to hold down a button for the boost to work. Let's get to it with these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start by creating a new script and calling it <code class="literal">TurboBoost</code>.</p></li><li><p>To start off the script, we need four variables. The first variable is a reference to the <code class="literal">CharacterController</code> component on the tank. We need this for movement. The second variable is how fast we will be moving while boosting. The third is for how long, in seconds, we will be boosting. The last is used internally for whether or not we can boost and when we should stop:</p><div class="informalexample"><pre class="programlisting">public CharacterController controller;
public float boostSpeed = 50;
public float boostLength = 5;
public float startTime = -1;</pre></div></li><li><p>The <code class="literal">StartBoost</code> function is pretty simple. It checks whether the <code class="literal">startTime</code> variable is less than zero. If it is, the variable is set to the current time as provided by <code class="literal">Time.time</code>. The value of the variable being less than zero means that we are not boosting currently:</p><div class="informalexample"><pre class="programlisting">public void StartBoost() {
  if(startTime &lt; 0)
    startTime = Time.time;
}</pre></div></li><li><p>The last function we are going to use is the <code class="literal">Update</code> function. It begins with a check of <code class="literal">startTime</code> to see whether we are currently boosting. If we are not boosting, the function is exited early. The next line of code checks to make sure that we have our <code class="literal">CharacterController</code> reference. If the variable is empty, then we can't make the tank move:</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(startTime &lt; 0) return;
  if(controller == null) return;</pre></div></li><li><p>The next line of code should look familiar. This is the line that makes the tank move:</p><div class="informalexample"><pre class="programlisting">controller.Move(controller.transform.forward * boostSpeed * Time.deltaTime);</pre></div></li><li><p>Next, check whether we are in the first half-second of the boost. By comparing the current time with the time that was recorded when we started, we can easily figure out for how long we have been boosting:</p><div class="informalexample"><pre class="programlisting">if(Time.time – startTime &lt; 0.5f)</pre></div></li><li><p>If the<a id="id264" class="indexterm"></a> time is right, we transition the camera by<a id="id265" class="indexterm"></a> adjusting the <code class="literal">fieldOfView</code> value. The <code class="literal">Camera.main</code> value is just a reference provided by Unity to the main camera used in the scene. The <code class="literal">Mathf.Lerp</code> function takes a starting value and moves this value toward the goal value based on a third value between zero and one. Using this, the camera's <code class="literal">fieldOfView</code> value is moved toward our goal over the half-second:</p><div class="informalexample"><pre class="programlisting">Camera.main.fieldOfView = Mathf.Lerp(Camera.main.fieldOfView, 130, (Time.time – startTime) * 2);</pre></div></li><li><p>The next piece of code does the same thing as the previous two, except for the last half-second of our boost, and uses the same method to transition the <code class="literal">fieldOfView</code> value back to the default:</p><div class="informalexample"><pre class="programlisting">else if(Time.time – startTime &gt; boostLength – 0.5f)
Camera.main.fieldOfView = Mathf.Lerp(Camera.main.fieldOfView, 60, (Time.time – startTime – boostLength + 0.5f) * 2);</pre></div></li><li><p>The last bit of code checks whether we are done with boosting. If so, <code class="literal">startTime</code> is set to <code class="literal">-1</code> in order to indicate that we can start another boost. That last curly brace, of course, closes off the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">if(Time.time &gt; startTime + boostLength)
  startTime = -1;
}</pre></div></li><li><p>Next, add the script to your tank and connect the <code class="literal">CharacterController</code> reference.</p></li><li><p>We are almost done. We need to create a new button. We can do this just like we have done before. Anchor the button to the bottom-right corner of <span class="strong"><strong>Canvas</strong></span> and position it just above the chassis' movement controls.</p></li><li><p>Last, be sure to select <code class="literal">Tank</code> for the <span class="strong"><strong>OnClick</strong></span> object and navigate to <span class="strong"><strong>Turbo Boost</strong></span> | <span class="strong"><strong>StartBoost ()</strong></span> for the function.</p></li><li><p>Try this out.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_04_05.jpg" /></div></li></ol></div><p>We <a id="id266" class="indexterm"></a>created a turbo boost here. The same method of movement that we<a id="id267" class="indexterm"></a> used in the previous chapter moves the tank here. By adjusting the <span class="strong"><strong>Field of View</strong></span> attribute of the camera, we make it look like the tank is moving even faster.</p><p>You might notice while playing the game that you can turn even when boosting. Try adding a check to the <code class="literal">ChassisControls</code> script in order to lock the controls, at the time of boosting. You need to add a reference to the <code class="literal">TurboBoost</code> script to do this.</p><p>For an additional, extra challenge, try adding a cooldown to the boost. Make it such that the player can't constantly use the boost. Also, try canceling the boost if the tank runs into something. This is a hard one, so here's a hint to start with: take a look at <code class="literal">OnControllerColliderHit</code> in the Unity documentation.</p></div></div>