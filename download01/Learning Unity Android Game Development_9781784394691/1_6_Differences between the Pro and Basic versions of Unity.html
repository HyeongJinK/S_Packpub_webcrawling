<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec12"></a>Differences between the Pro and Basic versions of Unity</h2></div></div><hr /></div><p>Unity comes with two licensing options, Pro and Basic, which<a id="id14" class="indexterm"></a> can be found at <a class="ulink" href="https://store.unity3d.com" target="_blank">https://store.unity3d.com</a>. In<a id="id15" class="indexterm"></a> order to follow the bulk of this book, Unity Basic is all that is required. However, real-time shadows in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Setting the Stage</em></span> – <span class="emphasis"><em>Camera Effects and Lighting</em></span>, and some of the optimization features discussed in <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Optimization</em></span>, will require Unity Pro. If you are not quite ready to spend the 3,000 dollars that is required to purchase a full Unity Pro license with the Android add-on, there are other options. Unity Basic<a id="id16" class="indexterm"></a> is free and comes with a 30-day free trial of Unity Pro. This trial is full and complete, as if you have purchased Unity Pro, the only downside being a watermark in the bottom-right corner of your game stating <span class="strong"><strong>Demo Use Only</strong></span>. It is also possible to upgrade your license at a later date. Where Unity Basic comes with mobile options for free, Unity Pro requires the purchase of Pro add-ons for each of the mobile platforms.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec08"></a>An overview of license comparison</h3></div></div></div><p>License comparisons<a id="id17" class="indexterm"></a> can be found at <a class="ulink" href="http://unity3d.com/unity/licenses" target="_blank">http://unity3d.com/unity/licenses</a>. This section will cover the specific differences between <a id="id18" class="indexterm"></a>Unity Android Pro and Unity Android Basic. We will explore what the features are and how useful each one is in the following points:</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec01"></a>NavMeshes, pathfinding, and crowd simulation</h4></div></div></div><p>This <a id="id19" class="indexterm"></a>feature is Unity's built-in pathfinding system. It allows characters <a id="id20" class="indexterm"></a>to find their way<a id="id21" class="indexterm"></a> from a point to another around your game. Just bake your navigation data in the editor and let Unity take over at runtime. Until recently, this was a Unity Pro only feature. Now the only part of it that is limited in <a id="id22" class="indexterm"></a>Unity Basic is the use of off-mesh links. The <a id="id23" class="indexterm"></a>only time you are going to need<a id="id24" class="indexterm"></a> them is when you want your AI characters to be able to jump across and otherwise navigate around gaps.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec02"></a>LOD support</h4></div></div></div><p><span class="strong"><strong>LOD</strong></span> (short for <span class="strong"><strong>level of detail</strong></span>) lets <a id="id25" class="indexterm"></a>you control how complex a mesh is, based on its distance from the camera. When the camera is close to an object, you can render a complex mesh with a bunch of detail in it. When the camera is far from that object, you can render a simple mesh because all that detail is not going to be seen anyway. Unity Pro provides a built-in system to manage this. However, this is another system that could be created in Unity Basic. Whether or not you are using the Pro version, this is an important feature for game efficiency. By rendering less complex meshes at a distance, everything can be rendered faster, leaving more room for awesome gameplay.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec03"></a>The audio filter</h4></div></div></div><p>Audio filters <a id="id26" class="indexterm"></a>allow you to add effects to audio clips at runtime. Perhaps you created gravel footstep sounds for your character. Your character is running and we can hear the footsteps just fine, when suddenly they enter a tunnel and a solar flare hits, causing a time warp and slowing everything down. Audio filters would allow us to warp the gravel footstep sounds to sound as if they were coming from within a tunnel and were slowed by a time warp. Of course, you could also just have the audio guy create a new set of tunnel gravel footsteps in the time warp sounds, although this might double the amount of audio in your game and limit how dynamic we can be with it at runtime. We either are or are not playing the time warp footsteps. Audio filters would allow us to control how much time warp is affecting our sounds.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec04"></a>Video playback and streaming</h4></div></div></div><p>When dealing with<a id="id27" class="indexterm"></a> complex or high-definition cut scenes, being able to play videos becomes very important. Including them in a build, especially with a mobile target, can require a lot of space. This is where the streaming part of this feature comes in. This feature not only lets us play videos but also lets us stream<a id="id28" class="indexterm"></a> a video from the Internet. There is, however, a drawback to this feature. On mobile platforms, the video has to go through the device's built-in video-playing system. This means that the video can only be played in fullscreen and cannot be used as a texture for effects such as moving pictures on a TV model. Theoretically, you could break your video into individual pictures for each frame and flip through them at runtime, but this is not recommended for build size and video quality reasons.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec05"></a>Fully-fledged streaming with asset bundles</h4></div></div></div><p>Asset bundles <a id="id29" class="indexterm"></a>are a great feature provided by Unity Pro. They allow you to create extra content and stream it to users without ever requiring an update to the game. You could add new characters, levels, or just about any other content you can think of. Their only drawback is that you cannot add more code. The functionality cannot change, but the content can. This is one of the best features of Unity Pro.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec06"></a>The 100,000 dollar turnover</h4></div></div></div><p>This<a id="id30" class="indexterm"></a> one isn't so much a feature as it is a guideline. According to Unity's End User License Agreement, the basic version of Unity cannot be licensed by any group or individual who made $100,000 in the previous fiscal year. This basically means that if you make a bunch of money, you have to buy Unity Pro. Of course, if you are making that much money, you can probably afford it without an issue. This is the view of Unity at least and the reason why there is a 100,000 dollar turnover.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec07"></a>Mecanim – IK Rigs</h4></div></div></div><p>Unity's new <a id="id31" class="indexterm"></a>animation system, <span class="strong"><strong>Mecanim</strong></span>, supports many exciting new features, one of which is <span class="strong"><strong>IK</strong></span> (short form for <span class="strong"><strong>Inverse Kinematics</strong></span>). If you are unfamiliar with the term, IK allows one to define the target point of an animation and let the system figure out how to get there. Imagine you have a cup sitting on a table and a character that wants to pick it up. You could animate the character to bend over and pick it up; but, what if the character is slightly to the side? Or any number of other slight offsets that a player could cause, completely throwing off your animation? It is simply impractical to animate for every possibility. With IK, it hardly matters that the character is slightly off.</p><p>We just define the goal point for the hand and leave the animation of the arm to the IK system. It calculates how the arm needs to move in order to get the hand to the cup. Another fun use is making characters look at interesting things as they walk around a room: a guard could track the nearest person, the player's character could look at things that they can interact with, or a tentacle monster could lash out at the player without all the complex animation. This will be an exciting one to play with.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec08"></a>Mecanim – sync layers and additional curves</h4></div></div></div><p>Sync layers, inside<a id="id32" class="indexterm"></a> Mecanim, allow us to keep multiple sets of animation states in time with each other. Say you have a soldier that you want to animate differently based on how much health he has. When he is at full health, he walks around briskly. After a little damage to his health, the walk becomes more of a trudge. If his health is below half, a limp is introduced into his walk, and when he is almost dead he crawls along the ground. With sync layers, we can create one animation state machine and duplicate it to multiple layers. By changing the animations and syncing the layers, we can easily transition between the different animations while maintaining the state machine.</p><p>The additional curves feature is simply the ability to add curves to your animation. This means we can control various values with the animation. For example, in the game world, when a character picks up its feet for a jump, gravity will pull them down almost immediately. By adding an extra curve to that animation, in Unity, we can control how much gravity is affecting the character, allowing them to actually be in the air when jumping. This is a useful feature for controlling such values alongside the animations, but you could just as easily create a script that holds and controls the curves.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec09"></a>The custom splash screen</h4></div></div></div><p>Though <a id="id33" class="indexterm"></a>pretty self-explanatory, it is perhaps not immediately evident why this feature is specified, unless you have worked with Unity before. When an application that is built in Unity initializes on any platform, it displays a splash screen. In Unity Basic, this will always be the Unity logo. By purchasing Unity Pro, you can substitute for the Unity logo with any image you want.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec10"></a>Real-time spot/point and soft shadows</h4></div></div></div><p>Lights <a id="id34" class="indexterm"></a>and shadows add a lot to the mood of a scene. This feature allows us to go beyond blob shadows and use realistic-looking shadows. This <a id="id35" class="indexterm"></a>is all well and good if you have the processing space for it. However, most mobile devices do not. This feature should also never be used for static scenery; instead, use static lightmaps, which is what they are for.</p><p>However, if you can find a good balance between simple needs and quality, this could be the feature that creates the difference between an alright and an awesome game. If you absolutely must have real-time shadows, the directional light supports them and is the fastest of the lights to calculate. It is also the only type of light available to Unity Basic that supports real-time shadows.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec11"></a>HDR and tone mapping</h4></div></div></div><p><span class="strong"><strong>HDR</strong></span> (short for <span class="strong"><strong>high dynamic range</strong></span>) and <a id="id36" class="indexterm"></a>tone mapping allow us to <a id="id37" class="indexterm"></a>create more realistic lighting effects. Standard rendering uses values from zero to one to represent how much of each color in a pixel is on. This does not allow for a full spectrum of lighting options to be explored. HDR lets the system use values beyond this range and processes them using tone mapping to create better effects, such as a bright morning room or the bloom from a car window reflecting the sun. The downside of this feature is in the processor. The device can still only handle values between zero and one, so converting them <a id="id38" class="indexterm"></a>takes time. Additionally, the more complex the effect, the more time it takes to render it. It would be surprising to see this used well on handheld devices, even in a simple game. Maybe the modern tablets could handle it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec12"></a>Light probes</h4></div></div></div><p>Light probes <a id="id39" class="indexterm"></a>are an interesting little feature. When placed in the world, light probes figure out how an object should be lit. Then, as a character walks around, they tell it how to be shaded. The character is, of course, lit by the lights in the scene, but there are limits on how many lights can shade an object at once. Light probes do all the complex calculations beforehand, allowing for better shading at runtime. Again, however, there are concerns about processing power. Too little power and you won't get a good effect; too much and there will be no processing power left for playing the game.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec13"></a>Lightmapping with global illumination and area lights</h4></div></div></div><p>All <a id="id40" class="indexterm"></a>versions of Unity support lightmaps, allowing for the baking of complex static shadows and lighting effects. With the addition of global illumination and area lights, you can add another touch of realism to your scenes. However, every version of Unity also lets you import your own lightmaps. This means that you could use some other program to render the lightmaps and import them separately.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec14"></a>Static batching</h4></div></div></div><p>This <a id="id41" class="indexterm"></a>feature speeds up the rendering process. Instead of spending time grouping objects for faster rendering on each frame , this allows the system to save the groups generated beforehand. Reducing the number of draw calls is a powerful step towards making a game run faster. That is exactly what this feature does.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec15"></a>Render-to-texture effects</h4></div></div></div><p>This is a fun <a id="id42" class="indexterm"></a>feature, but of limited use. It allows you to use the output from a camera in your game as a texture. This texture could then, in its most simple form, be put onto a mesh and act as a surveillance camera. You could also do some custom post processing, such as removing the color from the world as the player loses their health. However, this option could become very processor-intensive.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec16"></a>Fullscreen post-processing effects</h4></div></div></div><p>This is <a id="id43" class="indexterm"></a>another processor-intensive feature that probably will not make it into your mobile game. However, you can add some very cool effects to your scene, such as adding motion blur when the player is moving really fast or a vortex effect to warp the scene as the ship passes through a warped section of space. One of the best effects is using the bloom effect to give things a neon-like glow.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec17"></a>Occlusion culling</h4></div></div></div><p>This is <a id="id44" class="indexterm"></a>another great optimization feature. The standard camera system renders everything that is within the camera's view frustum, the view space. Occlusion culling lets us set up volumes in the space our camera can enter. These volumes are used to calculate what the camera can actually see from those locations. If there is a wall in the way, what is the point of rendering everything behind it? Occlusion culling calculates this and stops the camera from rendering anything behind that wall.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec18"></a>Deferred rendering</h4></div></div></div><p>If you <a id="id45" class="indexterm"></a>desire the best looking game possible, with highly detailed lighting and shadows, this is a feature of interest for you. Deferred rendering is a multi-pass process for calculating your game's light and shadow detail. This is, however, an expensive process and requires a decent graphics card to fully maximize its use. Unfortunately, this makes it a little outside of our use for mobile games.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec19"></a>Stencil buffer access</h4></div></div></div><p>Custom <a id="id46" class="indexterm"></a>shaders can use the stencil buffer to create special effects by selectively rendering over specific pixels. It is similar to how one might use an alpha channel to selectively render parts of a texture.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec20"></a>GPU skinning</h4></div></div></div><p>This is <a id="id47" class="indexterm"></a>a processing and rendering method by which the calculations for how a character or object appears, when using a skeleton rig, is given to the graphics card rather than getting it done by the central processor. It is significantly faster to render objects in this way. However, this is only supported on DirectX 11 and OpenGL ES 3.0, leaving it a bit out of reach for our mobile games.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec21"></a>Navmesh – dynamic obstacles and priority</h4></div></div></div><p>This<a id="id48" class="indexterm"></a> feature works in conjunction with the pathfinding system. In scripts, we can dynamically set obstacles, and characters will find their way around them. Being able to set priorities means that different types of characters can take different types of objects into consideration when finding their way around. For example, a soldier must go around the barricades to reach his target. The tank, however, could just crash through, should the player desire.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec22"></a>Native code plugins' support</h4></div></div></div><p>If you <a id="id49" class="indexterm"></a>have a custom set of code in the form of a <span class="strong"><strong>Dynamic Link Library</strong></span> (<span class="strong"><strong>DLL</strong></span>), this is the Unity Pro feature you need access to. Otherwise, the native plugins cannot be accessed by Unity for use with your game.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec23"></a>Profiler and GPU profiling</h4></div></div></div><p>This is a very useful feature. The profiler<a id="id50" class="indexterm"></a> provides tons of information about how much load your game puts on the processor. With <a id="id51" class="indexterm"></a>this information, we can get right down into the nitty-gritties and determine exactly how long a script takes to process. Towards the end of the book, though, we will also create a tool to determine how long specific parts of your code take to process.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec24"></a>Script access to the asset pipeline</h4></div></div></div><p>This is <a id="id52" class="indexterm"></a>an alright feature. With full access to the pipeline, there is a lot of custom processing that can be done on assets and builds. The full range of possibilities is beyond the scope of this book. However, you can think of it as something that can make tint all of the imported textures slightly blue.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec25"></a>Dark skin</h4></div></div></div><p>This is <a id="id53" class="indexterm"></a>entirely a cosmetic feature. Its point and purpose are questionable. However, if a smooth, dark-skinned look is what you desire, this is the feature that you want. There is an option in the editor to change it to the color scheme used in Unity Basic. For this feature, whatever floats your boat goes.</p></div></div></div>