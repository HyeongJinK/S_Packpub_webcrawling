<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec41"></a>Being attacked by the enemy</h2></div></div><hr /></div><p>What fun is a game <a id="id322" class="indexterm"></a>without a little conflict; the nagging choice is whether to fight to the death or the doom of the cosmos? Every game needs some form of conflict to drive the player towards seeking a resolution. Our game will become a battle for points. Before, this just involved shooting some targets and getting some points.</p><p>Now, we will make the enemy tank shoot at the player. Every time the enemy scores a hit, we will reduce the player's score by a few points. The enemy will shoot in a similar manner to how the player fires, but we will use some basic AI to control the direction and firing speed and replace the player's input controls. These steps will help us do it:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>We will start this off with a new script called <code class="literal">ShootAtPlayer</code>. Create it in the <code class="literal">Scripts</code> folder.</p></li><li><p>As with all our other scripts, we start this one out with two variables. The first variable will hold the last position of the enemy tank. The tank will not be shooting if it is in motion, so we need to store its last position to see whether it has moved. The second variable will be the maximum speed at which we can move and shoot. If the tank moves faster than this, it will not fire.</p><div class="informalexample"><pre class="programlisting">private Vector3 lastPosition = Vector3.zero;
public float maxSpeed = 1f;</pre></div></li><li><p>The next two variables dictate how long it takes for the tank to ready a shot. It is unrealistic to be shooting at the player in every single frame. So, we use the first variable to adjust the length of time it takes to ready a shot and the second to store when the shot will be ready:</p><div class="informalexample"><pre class="programlisting">public float readyLength = 2f;
private float readyTime = -1;</pre></div></li><li><p>The next variable contains the value of how fast the turret can rotate. While the tank is readying its shot, the turret will not be rotating to point at the player. That gives the player an opportunity to move out of the way. However, we need a speed variable to keep the turret from snapping to face the player after it has finished shooting.</p><div class="informalexample"><pre class="programlisting">public float turretSpeed = 45f;</pre></div></li><li><p>The last three variables here hold references to other parts of the tank. The <code class="literal">turretPivot</code> variable is, of course, the pivot of the turret that we will rotate. The <code class="literal">muzzlePoint</code> variable will be used as the point from where our cannon will be fired. These will be used in the same manner as the ones for the player's tank.</p><div class="informalexample"><pre class="programlisting">public Transform turretPivot;
public Transform muzzlePoint</pre></div></li><li><p>For the first <a id="id323" class="indexterm"></a>function of the script, we will make use of the <code class="literal">Update</code> function. It starts by calling a function that will check to see whether it is possible to fire the cannon. If we can fire, we will perform some checks on our <code class="literal">readyTime</code> variable. If it is less than zero, we have not yet begun to ready our shot and call a function to do so. However, if it is less than the current time, we have finished the preparation and call the function to fire the cannon. If we are unable to fire, we first call a function to clear any preparations and then rotate the turret to face the player.</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(CheckCanFire()) {
    if(readyTime &lt; 0) {
      PrepareFire();
    }
    else if(readyTime &lt;= Time.time) {
      Fire();
    }
  }
  else {
    ClearFire();
    RotateTurret();
  }
}</pre></div></li><li><p>Next, we will create our <code class="literal">CheckCanFire</code> function. The first part of the code checks to see whether we have moved too fast. First, we use <code class="literal">Vector3.Distance</code> to see how far we have moved since the last frame. By dividing the distance by the length of the frame, we are able to determine the speed with which we moved. Next, we update our <code class="literal">lastPosition</code> variable with our current position so that it is ready for the next frame. Finally, we compare the current speed with <code class="literal">maxSpeed</code>. If we moved too fast in this frame, we will be unable to fire and return a result as <code class="literal">false</code>:</p><div class="informalexample"><pre class="programlisting">public bool CheckCanFire() {
  float move = Vector3.Distance(lastPosition, transform.position);
  float speed = move / Time.deltaTime;

  lastPosition = transform.position;

  if(speed &gt; maxSpeed) return false;</pre></div></li><li><p>For the second half of the <code class="literal">CheckCanFire</code> function, we will check to see whether the turret is pointed at the player. First, we will find the direction to the player. By subtracting the second point's location from that of any given point in space, we will get the vector value of the first point with respect to the second point. We will<a id="id324" class="indexterm"></a> then flatten the direction by setting the <code class="literal">y</code> value to <code class="literal">0</code>. This is done because we do not want to be looking up or down at the player. Then, we will use <code class="literal">Vector3.Angle</code> to find the angle between the direction to the player and our turret's forward direction. Finally, we will compare the angle to a low value to determine whether we are looking at the player and return the result:</p><div class="informalexample"><pre class="programlisting">Vector3 targetDir = PlayerPosition.position – turretPivot.position;
targetDir.y = 0;

float angle = Vector3.Angle(targetDir, turretPivot.forward);

return angle &lt; 0.1f;
}</pre></div></li><li><p>The <code class="literal">PrepareFire</code> function is quick and easy. It simply sets our <code class="literal">readyTime</code> variable to the time in the future when the tank would have prepared its shot:</p><div class="informalexample"><pre class="programlisting">public void PrepareFire() {
  readyTime = Time.time + readyLength;
}</pre></div></li><li><p>The <code class="literal">Fire</code> function starts by making sure that we have a <code class="literal">muzzlePoint</code> reference to shoot from:</p><div class="informalexample"><pre class="programlisting">public void Fire() {
  if(muzzlePoint == null) return;</pre></div></li><li><p>The function continues with the creation of a <code class="literal">RaycastHit</code> variable to store the result of our shot. We use <code class="literal">Physics.Raycast</code> and <code class="literal">SendMessage</code>, just as we did in the <code class="literal">FireControls</code> script, to shoot at anything and tell it that we hit it:</p><div class="informalexample"><pre class="programlisting">RaycastHit hit;
if(Physics.Raycast(muzzlePoint.position, muzzlePoint.forward, out hit)) {
  hit.transform.gameObject.SendMessage("RemovePoints", 3, SendMessageOptions.DontRequireReceiver);
}</pre></div></li><li><p>The <code class="literal">Fire</code> function finishes by clearing the fire preparations:</p><div class="informalexample"><pre class="programlisting">ClearFire();
}</pre></div></li><li><p>The <code class="literal">ClearFire</code> function is another quick function. It sets our <code class="literal">readyTime</code> variable to be less than zero, indicating that the tank is not preparing to fire:</p><div class="informalexample"><pre class="programlisting">public void ClearFire() {
  readyTime = -1;
}</pre></div></li><li><p>The last function<a id="id325" class="indexterm"></a> is <code class="literal">RotateTurret</code>. It begins by checking the <code class="literal">turretPivot</code> variable and cancels the function if the reference is missing. This is followed by the finding of a direction that points at the player, just as we did earlier. This direction is flattened by setting the <code class="literal">y</code> axis to <code class="literal">0</code>. Next, we will create the <code class="literal">step</code> variable to specify how much we can move this frame. We use <code class="literal">Vector3.RotateTowards</code> to find a vector that is closer to pointing at our target than the current forward direction. Finally, we use <code class="literal">Quaternion.LookRotation</code> to create a special rotation that points our turret in the new direction.</p><div class="informalexample"><pre class="programlisting">public void RotateTurret() {
  if(turretPivot == null) return;

  Vector3 targetDir = PlayerPosition.position – turretPivot.position;
  targetDir.y = 0;

  float step = turretSpeed * Time.deltaTime;

  Vector3 rotateDir = Vector3.RotateTowards(
    turretPivot.forward, targetDir, step, 0);
  turretPivot.rotation = Quaternion.LookRotation(rotateDir);
}</pre></div></li><li><p>Now, by returning to Unity, create an empty <span class="strong"><strong>GameObject</strong></span> and rename it as <code class="literal">MuzzlePoint</code>. Position <code class="literal">MuzzlePoint</code> like we did for the player, at the end of the cannon.</p></li><li><p>Make <code class="literal">MuzzlePoint</code> a child of the cannon and zero out any <span class="strong"><strong>Y</strong></span> rotation that might be on it in the <span class="strong"><strong>Inspector</strong></span> window.</p></li><li><p>Next, add our new <code class="literal">ShootAtPlayer</code> script to the enemy tank. Additionally, connect the references to the <code class="literal">TurretPivot</code> and <code class="literal">MuzzlePoint</code> variables.</p></li><li><p>Finally, for the enemy tank, hit the <span class="strong"><strong>Apply</strong></span> button in the <span class="strong"><strong>Inspector</strong></span> window to update the prefab.</p></li><li><p>If you play the game <a id="id326" class="indexterm"></a>now, you will see the enemy rotating to point at you, but our score will not decrease. This is because of two reasons. First, the tank is slightly floating. It doesn't matter where in the world you place it; when you play the game, the tank will slightly float. This is because of the way the <code class="literal">NavMeshAgent</code> component functions. The fix is simple; just set <span class="strong"><strong>BaseOffset</strong></span> to <code class="literal">-0.3</code> in the <span class="strong"><strong>Inspector</strong></span> window. This adjusts the system and puts the tank on the ground.</p></li><li><p>The second reason the score isn't changing is because the player is missing a function. To fix this, open the <code class="literal">ScoreCounter</code> script.</p></li><li><p>We will add the <code class="literal">RemovePoints</code> function. Given an amount, this function simply removes that many points from the player's score:</p><div class="informalexample"><pre class="programlisting">public void RemovePoints(int amount) {
  score -= amount;
}</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip11"></a>Tip</h3><p>If your enemy tank is still unable to hit the player, it may be too big and is shooting over the player. Just tilt the tank's cannon down so that when it is shooting at the player, it also points towards the center of the player's tank.</p></div><p>If you take a look at the score counter in the top-right corner, the score will go down when the enemy gets close. Remember, it will not start dropping immediately because the enemy needs to stop moving, to ready the cannon, before they can shoot.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_05_07.jpg" /></div></li></ol></div><p>We gave the enemy the ability <a id="id327" class="indexterm"></a>to attack the player. The new <code class="literal">ShootAtPlayer</code> script first checks to see whether the tank has slowed down and the cannon is trained on the player. If so, it will take regular shots at the player to reduce their score. The player is going to need to keep moving and aim at targets fast if they hope to be left with any points at the end of the game.</p><p>Unless you are paying close attention to your score, it is difficult to tell when you are being shot at. We will be working with explosions in a future chapter, but even so, the player needs some feedback to tell what is going on. Most games will flash a red texture on the screen when the player is hit, whether or not there are any explosions. Try creating a simple texture and drawing it on the screen for half a second when the player is hit.</p></div>