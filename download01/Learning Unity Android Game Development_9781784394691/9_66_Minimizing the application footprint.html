<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec65"></a>Minimizing the application footprint</h2></div></div><hr /></div><p>One of the keys to a <a id="id528" class="indexterm"></a>successful game is the size of the game itself. Many users will quickly uninstall any application that appears to be unnecessarily large. In addition, all of the mobile app stores impose restrictions on how your game will be supplied to users based on the size of the application itself. Becoming familiar with the options that you have for minimizing the size of your game is the key to control how your game will be distributed.</p><p>The first thing to note when working to minimize the footprint is how Unity handles assets as it builds the game. Only assets that are used somewhere in one of the scenes for the build are actually included in the game. If it is not in the scene itself or referenced by an asset that is in the scene, it will not be included. This means you could have test versions of assets, or incomplete versions; as long as they are not referenced, they will not affect the final build size of your game.</p><p>Unity also allows you to<a id="id529" class="indexterm"></a> keep your assets in the format that you need for working on them. When the final build is made, all the assets are converted to an appropriate version for their type. This means that you can keep models in the format that are native to your modeling program, which will be converted to FBX files. Otherwise, you can keep your images as Photoshop files, or any other format in which you work, and they will be converted to JPG or PNG appropriately when the game is built.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec58"></a>Editor log</h3></div></div></div><p>When <a id="id530" class="indexterm"></a>you are finally ready to work with the footprint of your game, it is possible to find out exactly what is causing your game to be larger than desired. In the top-right corner of the <span class="strong"><strong>Console</strong></span> window is a drop-down menu button. Inside this menu is <span class="strong"><strong>Open Editor Log</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_01.jpg" /></div><p>The Editor log<a id="id531" class="indexterm"></a> is the location where Unity outputs information while it is running. This file tracks information about the current version of the Unity Editor, performs any checks done for your license, and contains a bit of information about any assets you have imported. The log will also contain detailed information about the file size and assets included in the game, after it has been built. An example of the Editor log is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_02.jpg" /></div><p>Here, we can see a <a id="id532" class="indexterm"></a>breakdown of the aspects of the final build. Every asset category has a size and percentage of the total build size. We are also supplied with a list of every asset that is actually included in the game, organized by their file size before they are added to the build. This information becomes very useful when you are looking for assets that can be made smaller.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec59"></a>Asset compression</h3></div></div></div><p>Inside the <span class="strong"><strong>Import Settings</strong></span> window for models, textures, and audio, there are options that affect the <a id="id533" class="indexterm"></a>size and quality<a id="id534" class="indexterm"></a> of imported assets. In general, the affected change is a reduction in quality. However, especially when working on a game for the mobile device, asset quality can be reduced well below the levels required for a computer before the difference becomes noticeable on the device. Once you understand the options available for each type of asset, you will be able to make optimal decisions regarding the quality of your game. When working with any of these options, look for a setting that minimizes the size before introduction of undesired artifacts.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec41"></a>Models</h4></div></div></div><p>No matter what program or <a id="id535" class="indexterm"></a>method you use to create your models, ultimately, there is always a list of vertex positions and triangles, with a few references to textures. Most of the file size of a model comes from the list of vertex positions. To make sure that the models in your game are of the highest quality, start in the modeling program of your choice. Delete any and all extra vertexes, faces, and unused objects. Not only will this result in a smaller file when you build your final game, but it will also reduce the import time when you work in the editor.</p><p>The <span class="strong"><strong>Import Settings</strong></span> <a id="id536" class="indexterm"></a>window for models consists of three pages, resulting in more options to adjust the quality. Each page tab corresponds to the relevant part of the model, allowing you to fine-tune each one of them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec42"></a>The Model tab</h4></div></div></div><p>On the <a id="id537" class="indexterm"></a>
<span class="strong"><strong>Model</strong></span> tab, you can influence how the mesh is imported. When it comes to optimizing your use of the models, there are many options here that are key to your success. Once your game looks and plays the way you want it to, you should always have a good look at these settings to see if you can make them work even better:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_03.jpg" /></div><p>The following are<a id="id538" class="indexterm"></a> the various settings in the <span class="strong"><strong>Model</strong></span> tab:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Scale Factor </strong></span>and <span class="strong"><strong>File Scale</strong></span>: These let you control the default visual size of your model. The <span class="strong"><strong>File Scale</strong></span> parameter is how big Unity calculated your model to be when importing it. The <span class="strong"><strong>Scale Factor</strong></span> parameter lets you adjust what additional scaling Unity will apply when it imports your model.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Mesh Compression</strong></span>: This option lets you select how much compression should be applied to the model. The compression effect amounts to combining vertexes to reduce the overall amount of detail that has to be stored for the mesh. This setting is likely to introduce undesired oddities in the mesh, when pushed too far. So, always pick the highest setting that does not introduce any artifacts.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Read/Write Enabled</strong></span>: This option is only useful when you want to manipulate<a id="id539" class="indexterm"></a> the mesh, through the script, while the game is running. If you never touch the mesh with any of your scripts, uncheck this box. Although this will not affect the final build size, it will affect how much memory is required to run your game.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Optimize Mesh</strong></span>: This option causes Unity to reorder the triangles list that describes the model. This option is always a good one to leave checked. The only reason you might want to uncheck it is if you are manipulating the game or mesh based on the specific order of the triangles.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Import BlendShapes</strong></span>: BlendShapes are similar to keyframes in a normal animation, but they work on the mesh detail itself rather than the positions of bones. By unchecking this box, you can save space in your game and project because Unity will not need to calculate and store them.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Generate Colliders</strong></span>: This option is almost always a candidate to leave unchecked. This option will add <span class="strong"><strong>Mesh Collider</strong></span> components to every mesh in your model. These colliders are relatively expensive to calculate when working with physics in your game. If possible, you should always use a group of significantly simpler <span class="strong"><strong>Box Colliders</strong></span> and <span class="strong"><strong>Sphere Colliders</strong></span>.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Swap UVs</strong></span>: Unity supports models that have two sets of UV coordinates. Generally, the first is for normal texture and the second is for any lightmaps that the object has. If you generate your own lightmap UVs, it is possible for Unity to recognize them in the wrong order. Checking this box then forces Unity to change the order in which they are used.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Generate Lightmap UVs</strong></span>: This option should only be used when you are working with objects that need static shadows. If the object does not need it, this will introduce excess vertex information and bloat the asset.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Normals</strong></span>: This option is used to calculate or import normal information. <span class="strong"><strong>Normals</strong></span> are used by materials for determining direction in which a vertex or triangle faces and how lighting should affect it. If the mesh never uses a material that needs the <span class="strong"><strong>Normals</strong></span> information, be sure to set this to <span class="strong"><strong>None</strong></span>.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Tangents</strong></span>: This option is used to calculate or import tangent information. <span class="strong"><strong>Tangents</strong></span> are used by materials to fake details with bump maps and similar special effects. Just as with the <span class="strong"><strong>Normals</strong></span> setting, if you don't need them, don't import them. If <span class="strong"><strong>Normals</strong></span> is set to <span class="strong"><strong>None</strong></span>, this setting will automatically be grayed out and will no longer be imported.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Smoothing Angle</strong></span>: When calculating normals, this option lets you define how close <a id="id540" class="indexterm"></a>the angle between two faces needs to be to be shaded smoothly across their shared edge.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Split Tangents</strong></span>: This causes the tangents of your mesh to be recalculated where there are seams in your UVs. This is used for fixing some lighting irregularities in highly-detailed models.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Keep Quads</strong></span>: Unity normally converts all faces to triangles for rendering. If you are using DirectX 11 for rendering, this option will keep your faces as quads for tessellation.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Import Materials</strong></span>: This option lets you control whether or not new materials will be created when you are importing your models. If this is unchecked, no new models will be created when you are importing.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Material Naming</strong></span>: This lets you control the manner in which the models that are imported will name any new materials that are created.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Material Search</strong></span>: Unity can use a variety of methods for finding a material to use on the model that has already been created. The <span class="strong"><strong>Local Materials Folder</strong></span> option will only look in a folder named <code class="literal">Materials</code> next to where the model is imported. The <span class="strong"><strong>Recursive-Up</strong></span> option will look in the folder of the model, and the root assets folder through parent levels up. The <span class="strong"><strong>Project-Wide</strong></span> option will search your whole project for a material with the right name.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec43"></a>The Rig tab</h4></div></div></div><p>As we can see in the following screenshot, there<a id="id541" class="indexterm"></a> are very few options to adjust for an animation rig:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_04.jpg" /></div><p>There are really only two things to keep in mind when you are working to optimize your animation rig. The first is, if the asset does not animate, then don't import it. By setting <span class="strong"><strong>Animation Type</strong></span> to <span class="strong"><strong>None</strong></span>, Unity will not try to import the rig or any useless animations. The second thing to keep in mind is to remove any unnecessary bones. Once imported to Unity, delete any and all objects from the rig that do not actually have an effect on the animation or character. Unity can convert any inverse kinematics that you might use for animation into forward kinematics, so the guides used for it can be deleted once Unity is launched.</p><p>The <span class="strong"><strong>Optimize Game Object</strong></span> checkbox <a id="id542" class="indexterm"></a>that is there does not actually help in the overall optimization of the game. It simply hides the extra rig objects in the Hierarchy window, so you don't have to deal with them. This checkbox can also be very helpful when dealing with complex rigs in the editor.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec44"></a>The Animations tab</h4></div></div></div><p>As with the <span class="strong"><strong>Rig</strong></span> tab, if the model does not <a id="id543" class="indexterm"></a>animate, do not import animations. Unchecking the <span class="strong"><strong>Import Animation</strong></span> checkbox when you first import the asset will prevent any extra components from being added to your <span class="strong"><strong>GameObject</strong></span> components in Unity. In addition, if any extra animations get added to your final build accidentally, they can quickly make your application oversized. The Animations tab is highlighted in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_05.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Anim.Compression</strong></span>: This option adjusts how Unity handles excess keyframes in your animations. For most situations, the default option works well. The various options available are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Off</strong></span>: This option should only be used if you need a high-precision animation. This is the largest and most costly setting to choose.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Keyframe Reduction</strong></span>: This option will reduce the number of keyframes used by the animation based on the Error settings that follow. Essentially, if a keyframe does not have a noticeable effect upon the animation, it will be ignored.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Optimal</strong></span>: This option does the same as the previous option, but additionally it compresses the file size of the animations. However, at runtime, the animation will still require the same amount of processor resources for calculation as the previous option.</p></li></ul></div></li><li style="list-style-type: disc"><p><span class="strong"><strong>Rotation Error</strong></span>: This option is the difference of the number of degrees between keyframes that will be ignored when performing keyframe reduction.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Position Error</strong></span>: This <a id="id544" class="indexterm"></a>option is the movement distance that will be ignored between keyframes when performing keyframe reduction.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Scale Error</strong></span>: This option is the amount of size adjustment in the animation that will be ignored between keyframes when performing keyframe reduction.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec45"></a>Textures</h4></div></div></div><p>It is hard to imagine a quality game that does<a id="id545" class="indexterm"></a> not have a whole bunch of images in it. Textures have a bunch of options to control how much detail will be preserved when they are used in the game. In general, it is best to select the lowest quality settings that do not introduce noticeable artifacts in the image. In addition, it is best to work with texture sizes that are in a power of two to improve processing speed. Moreover, few processors are commonly able to handle textures that are greater than <code class="literal">1024</code> pixels in size. By putting your images in or below this size, you potentially save a lot of memory and space in your final game.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_06.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Texture Type</strong></span>: This option affects what type of texture the image will be treated as. It is always best to select the type that is most appropriate for the intended use <a id="id546" class="indexterm"></a>of the image. The following options show the various types of textures that can be used:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Texture</strong></span>: This option is the most common and default setting when working with 3D games. This should be used for your normal model textures.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Normal Map</strong></span>: This option is used for special effects such as bump maps. Materials that use this type of texture will also need normal and tangent information from the model's import settings.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Editor GUI and Legacy GUI</strong></span>: Unless you are working with special editor scripts, or other special cases, you will not use this setting. This is very similar to the <span class="strong"><strong>Sprite</strong></span> setting.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Sprite (2D and UI)</strong></span>: This option is the most common and default setting when working with 2D games. This should always be used for your flat 2D characters and UI elements.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Cursor</strong></span>: This setting is not particularly relevant to our Android platform. It allows you to create custom mouse pointers that aren't commonly available for most Android devices.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Cubemap</strong></span>: When you are working with custom reflections or skybox type materials, your images should use this option. This automatically wraps the image around, so it repeats like the edges of a sphere or cube.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Cookie</strong></span>: These textures are used on lights and they change how the light is emitted from the light object, like the ones we used for our tank's headlights.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Lightmap</strong></span>: We worked with Unity's lightmapping system in our Tank Battle game. However, this system won't always work for all situations. So, when you are making custom lightmaps outside of Unity, choose this option.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Advanced</strong></span>: This option gives you full control over all the settings that are concerned with importing images. You will only need this setting if you have a special purpose for your textures or you need precise control over them.</p></li></ul></div></li><li style="list-style-type: disc"><p><span class="strong"><strong>Read/Write Enabled</strong></span>: This checkbox is available when <span class="strong"><strong>Texture Type</strong></span> is set to <span class="strong"><strong>Advanced</strong></span>. This should only be left checked if you plan to manipulate the texture from your scripts while the game is running. If this is unchecked, Unity does not maintain a copy of the data in the CPU, freeing memory for other parts of the game.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Generate Mip Maps</strong></span>: This option is another <span class="strong"><strong>Advanced</strong></span> setting that lets you control the creation of smaller versions of the texture. These are then used when the texture is small on the screen, reducing the amount of processing needed to draw the texture and the object that is using it on the screen.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Filter Mode</strong></span>: This option is available for all of the texture types. It affects how the image will look when you are very close to it. <span class="strong"><strong>Point</strong></span> will make the image look blocky, while <span class="strong"><strong>Bilinear</strong></span> and <span class="strong"><strong>Trilinear</strong></span> will blur the pixels. In general, <span class="strong"><strong>Point</strong></span> is the fastest mode; <span class="strong"><strong>Trilinear</strong></span> is the slowest mode but gives the best-looking effect.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Max Size</strong></span>: This <a id="id547" class="indexterm"></a>option adjusts how large the image can be when it is used in the game. This allows you to work with images that are very large but import them to Unity in an appropriately small size. In general, values greater than <span class="strong"><strong>1024</strong></span> are poor choices, not just because of the increased memory requirement but also since most mobile devices simply cannot handle textures that are any larger. In general, 1024-sized textures should be reserved for your main characters and other highly important objects. A size of 256 works well on mobile devices for objects with medium and low importance. For all of your objects, if you can combine their textures to share a 1024 texture, they will have a smaller impact on your game than if they have small separate textures. Choosing the smallest size possible will have a great effect on the footprint size of the textures in your final build.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Format</strong></span>: This option adjusts how the image would be imported and how much detail each pixel can hold. <span class="strong"><strong>Compressed</strong></span> is the smallest format, while <span class="strong"><strong>Truecolor</strong></span> provides the most detail.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec46"></a>Audio</h4></div></div></div><p>Giving a game quality sound always<a id="id548" class="indexterm"></a> adds a lot to the final size of the game. It is one of the assets that a game cannot do without, but it can be hard to include at a suitable level. When working on the sounds in your audio program, keep them as short as possible to minimize their size. In addition, bear in mind that most of your players will not have the same fancy headphones or speakers to listen to your audio, so quality can be reduced to quite an extent before they notice any difference. The audio import settings all have an effect on either their footprint in the build size or the memory required to run the game.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_07.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Force To Mono</strong></span>: This setting converts multichannel audio into a single channel. While <a id="id549" class="indexterm"></a>most devices are technically capable of playing stereo sounds, they do not always have the multiple speakers required for it to make a difference. Checking this box can significantly reduce the file size of the audio by combining all of the channels into a single, smaller one. Multichannel audio files are used to give the illusion of direction based on which speaker the sound is coming from. This essentially requires separate sound files for each speaker. Mono channel audio files use the same sound file for all speakers and thus require much less data and space in your game.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Load In Background</strong></span> and <span class="strong"><strong>Preload Audio Data</strong></span>: These two settings work together to define when the audio information will be loaded and made ready to be played. The <span class="strong"><strong>Load In Background</strong></span> parameter determines whether the game waits until the file is loaded before loading any other game data. Checking this box is a good idea for long or large files, such as background music. The <span class="strong"><strong>Preload Audio Data</strong></span> parameter determines whether the files should be loaded as soon as possible. Any audio clips that you are going to need right away should have this option checked.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Load Type</strong></span>: This setting affects how much of the system's memory will be used, while the game is running, to handle the loading of audio files. The <span class="strong"><strong>Decompress on Load</strong></span> option uses maximum memory and is best for small, short sounds. The <span class="strong"><strong>Compressed in Memory</strong></span> option only decompresses the file while it is playing, using a medium amount of memory, and is best for medium-sized files. The <span class="strong"><strong>Streaming</strong></span> option means that only the part of the file that is currently being played is stored in the runtime memory. This is like streaming video or music from the Internet. This option is best for large files but should only be used by a few at one time.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Compression Format</strong></span>: This <a id="id550" class="indexterm"></a>determines what sort of data reduction to apply to the audio file to make it small enough to include in the game. The <span class="strong"><strong>PCM</strong></span> format is going to preserve most of the original audio and will be the largest file size as a result. The <span class="strong"><strong>ADPCM</strong></span> format will give you a medium level of compression, but it will also reduce some of the quality as a result. The <span class="strong"><strong>Vorbis</strong></span> format can give you the smallest possible file size, but at the cost of maximum reduction in quality.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Quality</strong></span> and <span class="strong"><strong>Sample Rate Setting</strong></span>: These control the amount of detail that will be preserved when you apply compression from the previous option. If the file size is still too large, you can reduce the overall quality to bring it within acceptable limits. However, reducing quality here comes at the cost of the sound quality. Always seek the lowest setting possible before artifacts are introduced and audible on your target device.</p></li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec60"></a>Player settings</h3></div></div></div><p>Open<a id="id551" class="indexterm"></a> your game's <span class="strong"><strong>Player Settings</strong></span> window<a id="id552" class="indexterm"></a> by going to Unity's toolbar and navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span>. In the platform-specific settings for Android, we have another few options under <span class="strong"><strong>Other Settings</strong></span> that will affect the final size and speed of our game.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec47"></a>Rendering</h4></div></div></div><p>The <span class="strong"><strong>Rendering</strong></span> group of settings<a id="id553" class="indexterm"></a> control how your game will handle drawing your game on the screen. This controls the kind of lighting and shadow calculations that are used. It also allows you to optimize the number of calculations needed to draw the many objects that make up your game's scene. The <span class="strong"><strong>Rendering</strong></span> window<a id="id554" class="indexterm"></a> can be seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_08.jpg" /></div><p>The settings that are seen <a id="id555" class="indexterm"></a>in the <span class="strong"><strong>Rendering</strong></span> window are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Rendering Path</strong></span>: This set of options primarily controls the quality with which lights and shadows are rendered. The options under <span class="strong"><strong>Rendering Path</strong></span> are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Forward</strong></span>: This is going to be your most common setting. It supports real-time shadows from a single directional light. This option is your normal baseline for rendering light in Unity.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Deferred</strong></span>: This is going to give you the highest quality lighting and shadow, but it will cost the most for the system to process it. Not every system is going to be able to support it, and it happens to be a Unity Pro-only feature.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Legacy Vertex Lit</strong></span>: This rendering method is part of the old system. It is also the cheapest method to process. There are no real-time shadows with this method, and the lighting calculations are highly simplified. Older machines and mobile devices will default to this mode.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Legacy Deferred (light prepass)</strong></span>: This method is also part of the old system. The newer <code class="literal">Deferred</code> method is highly improved over this one and in general, this should not be used. You would only need to select this method if you have a special case or need to support a specific platform.</p></li></ul></div></li><li style="list-style-type: disc"><p><span class="strong"><strong>Multithreaded Rendering</strong></span>: The process and series of steps used to run a program is called a thread. It is possible to start many of these threads and make them work<a id="id556" class="indexterm"></a> on different parts of the program at the same time. Unity has utilized this feature of programming to increase the speed and quality of the rendering system. However, it requires a more powerful processor to run effectively.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Static Batching</strong></span>: This is a Unity Pro feature that allows Unity to significantly speed up rendering times by grouping identical objects that have been marked as static in the <span class="strong"><strong>Inspector</strong></span>. For each group, it then renders one object in multiple places rather than rendering each object individually. Potentially, this setting can add some extra girth to your final build size because Unity will need to save extra information about your static objects to make this work.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Dynamic Batching</strong></span>: This works in the same manner as <span class="strong"><strong>Static Batching</strong></span>, but with two major differences. First, it is available to both Unity Pro and Basic users. Second, it groups objects that are not marked as static.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>GPU Skinning</strong></span>: This setting is less applicable for older mobile devices, and it is used more for the newest of mobile devices and other systems that have both a CPU and GPU. This allows the calculations that are normally done on meshes, that animate and are deformed by bones, to take place on the GPU instead of the CPU. This will free up resources for processing other parts of your game and giving your players the best experience possible.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec48"></a>Optimization</h4></div></div></div><p>The <span class="strong"><strong>Optimization</strong></span> group of settings<a id="id557" class="indexterm"></a> allows you to adjust how Unity will compile your project and the assets involved. Each setting<a id="id558" class="indexterm"></a> should be given careful consideration when you approach the final build of your game. Altogether, these settings have the potential to make a huge difference in how well your game runs. The <span class="strong"><strong>Optimization</strong></span> window is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_09.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Api Compatibility Level</strong></span>: This setting determines which set of the .NET functions to include in the final build. The <span class="strong"><strong>.Net 2.0</strong></span> option will include all of the available<a id="id559" class="indexterm"></a> functions, making the largest footprint. The <span class="strong"><strong>.Net 2.0 Subset</strong></span> option is a smaller portion of the functions and includes only the functions that your programming is most likely to use. Unless you need some special functionality, the <span class="strong"><strong>.Net 2.0 Subset</strong></span> option should always be the option that you choose.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Prebake Collision Meshes</strong></span>: This box saves time when you load your levels, by moving the physics calculations from the scene load to the game build. It means your build size will be large but the processing speed will be reduced.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Preload Shaders</strong></span>: When a mesh uses a new shader that has not yet been used in the game scene, the system needs to process and calculate how that shader will render objects. This box will process that information when the scene starts and avoid potential stalls in your game while it tries to do the calculations.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Preloaded Assets</strong></span>: This option does the same thing as the previous one, but for assets and prefabs instead of shaders. When you first instantiate an object, it needs to be loaded into memory. This will change it so that all of the assets in this list are loaded when the scene starts.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Stripping Level</strong></span>: This setting is a Unity Pro only feature. It allows you to reduce the size of your final build by removing all of the excess code before compiling it. System functions are grouped into what are called libraries for easy reference. The <span class="strong"><strong>Strip Assemblies</strong></span> option removes the unused libraries from the final build. The <span class="strong"><strong>Use micro mscorlib</strong></span> option performs the same function as the previous option but utilizes a minimized form of the libraries. While significantly smaller, this library possesses fewer functions for your code to use. However, unless your game is complex, this should not make a difference.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Enable Internal Profiler</strong></span>: This option lets you retrieve information about how your game is running on a device. It does introduce a little bit of overhead to<a id="id560" class="indexterm"></a> process the information while your game is running, but the effect is less than what Unity Editor introduces. The information can be retrieved using the <code class="literal">adb logcat</code> command in the command prompt.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Optimize Mesh Data</strong></span>: This setting will remove extra information from all of your meshes that are not being used by any materials that are applied to them. This includes <span class="strong"><strong>Normals</strong></span>, <span class="strong"><strong>Tangents</strong></span>, and a few other bits of information. It also causes the triangle data that makes up the mesh to be reordered for optimal processing and rendering. Unless you have a very special case, this is a good box to always check.</p></li></ul></div></div></div></div>