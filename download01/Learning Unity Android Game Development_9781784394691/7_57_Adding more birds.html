<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec58"></a>Adding more birds</h2></div></div><hr /></div><p>There is one<a id="id452" class="indexterm"></a> last set of assets that we need to create for our levels: the other birds. We will create three more birds that each have a unique special ability: a yellow bird that accelerates, a blue bird that splits into multiple birds, and a black bird that explodes. With these, our flock will be complete.</p><p>To make the creation of these birds easier, we will be making use of a concept called <span class="strong"><strong>inheritance</strong></span>. Inheritance <a id="id453" class="indexterm"></a>allows a script to expand upon the functions it is inheriting without the need to rewrite them. If used correctly, this can be very powerful and, in our case, will aid in the quick creation of multiple characters that are largely similar.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec47"></a>The yellow bird</h3></div></div></div><p>First, we will <a id="id454" class="indexterm"></a>create the yellow bird. Largely, this bird functions exactly as the red bird. However, when the player touches the screen a second time, the bird's special ability is activated and its speed increases. By extending the <code class="literal">Bird</code> script that we created earlier, this bird's creation becomes quite simple. Because of the power of inheritance, the script we are creating here consists of only a handful of lines of code. Let's create it with these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start by creating the yellow bird in the same way as the red bird, using the <code class="literal">YellowBird</code> model instead.</p></li><li><p>Instead of using the <code class="literal">Bird</code> script, we will create the <code class="literal">YellowBird</code> script.</p></li><li><p>This script needs to extend the <code class="literal">Bird</code> script, so replace <code class="literal">MonoBehaviour</code> with <code class="literal">Bird</code> on line four of our new script. It should look similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">public class YellowBird : Bird {</pre></div></li><li><p>This script adds a single variable that will be used to multiply the bird's current velocity:</p><div class="informalexample"><pre class="programlisting">public float multiplier = 2f;</pre></div></li><li><p>Next, we override the <code class="literal">DoSpecial</code> function and multiply the bird's <code class="literal">body.velocity</code> variable when it is called:</p><div class="informalexample"><pre class="programlisting">protected override void DoSpecial() {
  didSpecial = true;
  body.velocity *= multiplier;
}</pre></div></li><li><p>Return to Unity, add the script to your new bird, connect the <span class="strong"><strong>Rigidbody</strong></span> component reference, and turn it into a prefab. Add some to the list on your slingshot in order to use the bird in your level.</p></li></ol></div><p>We created the yellow bird. This bird is simple. It directly modifies its velocity to suddenly gain a <a id="id455" class="indexterm"></a>boost of speed when the player touches the screen. As you will soon see, we use this same style of script to create all our birds.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec48"></a>The blue bird</h3></div></div></div><p>Next, we will <a id="id456" class="indexterm"></a>create the blue bird. This bird splits into three birds when the player touches the screen. It will also extend the <code class="literal">Bird</code> script by using inheritance, reducing the amount of code that needs to be written to create the bird. Let's do it with these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Again, start building your blue bird the same way as the previous two birds were built, substituting the appropriate model. You should also adjust the value of <span class="strong"><strong>Radius</strong></span> of the <span class="strong"><strong>Circle Collider 2D</strong></span> component to align appropriately with the small size of this bird.</p></li><li><p>Next, we create the <code class="literal">BlueBird</code> script.</p></li><li><p>Again, adjust line four so that the script extends <code class="literal">Bird</code> instead of <code class="literal">MonoBehaviour</code>:</p><div class="informalexample"><pre class="programlisting">public class BlueBird : Bird {</pre></div></li><li><p>This script has three variables. The first variable is a list of prefabs to spawn when the bird splits. The next is the angle difference between each new bird that will be launched. The final variable is a value to spawn the birds a little ahead of their current position in order to keep them from getting stuck inside each other:</p><div class="informalexample"><pre class="programlisting">public GameObject[] splitBirds = new GameObject[0];
public float launchAngle = 15f;
public float spawnLead = 0.5f;</pre></div></li><li><p>Next, we override the <code class="literal">DoSpecial</code> function and start, as with the others, by marking that we made our special move. Next, it calculates half of the number of birds to spawn and creates an empty list to store the rigidbodies of the newly spawned birds:</p><div class="informalexample"><pre class="programlisting">protected override void DoSpecial() {
  didSpecial = true;

  int halfLength = splitBirds.Length / 2;
  Rigidbody2D[] newBodies = new Rigidbody2D[splitBirds.Length];</pre></div></li><li><p>The function continues by looping through the list of birds, skipping the slots that are empty. It spawns the new birds at their position; after trying to store the object's <span class="strong"><strong>Rigidbody</strong></span>, it goes on to the next one if it is missing. The new <span class="strong"><strong>Rigidbody</strong></span> component is then stored in the list:</p><div class="informalexample"><pre class="programlisting">for(int i=0;i&lt;splitBirds.Length;i++) {
  if(splitBirds[i] == null) continue;

  GameObject next = Instantiate(splitBirds[i], transform.position, transform.rotation) as GameObject;

  Rigidbody2D nextBody = next.GetComponent&lt;Rigidbody2D&gt;();
  if(nextBody == null) continue;

  newBodies[i] = nextBody;</pre></div></li><li><p>Using<a id="id457" class="indexterm"></a> <code class="literal">Quaternion.Euler</code>, a new rotation is created that will angle the new bird along a path that is split off from the main path. The new bird's velocity is set to the rotated velocity of the current bird. An offset is calculated and it is then moved forward along its new path, so as to get out of the way of the other birds being spawned:</p><div class="informalexample"><pre class="programlisting">Quaternion rotate = Quaternion.Euler(0, 0, launchAngle * (i – halfLength));
nextBody.velocity = rotate * nextBody.velocity;
Vector2 offset = nextBody.velocity.normalized * spawnLead;
next.transform.position += new Vector3(offset.x, offset.y, 0);
}</pre></div></li><li><p>After the loop, the function uses <code class="literal">FindObjectOfType</code> to find the slingshot that is currently in the scene. If it is found, it is changed to track the first new bird spawned as the one that was fired. The new list of rigidbodies is also set to the <code class="literal">rigidbodyDamper</code> variable, in order to be added to its list of rigidbodies. Finally, the script destroys the bird it is attached to, completing the illusion that the bird has been split apart:</p><div class="informalexample"><pre class="programlisting">Slingshot slingshot = FindObjectOfType(typeof(Slingshot)) as Slingshot;
if(slingshot != null) {
  slingshot.toFireBird = newBodies[0];
  slingshot.rigidbodyDamper.AddBodiesToCheck(newBodies);
}

Destroy(gameObject);
}</pre></div></li><li><p>Before you add the script to your new bird, we actually need two blue birds: one that splits and one that does not. Duplicate your bird and name one <code class="literal">Bird_Blue_Split</code> and the other <code class="literal">Bird_Blue_Normal</code>. To the split bird, add the new script and to the normal bird, add the <code class="literal">Bird</code> script.</p></li><li><p>Turn both the birds into prefabs and add the normal bird to the other's list of birds to be split into.</p></li></ol></div><p>We created the<a id="id458" class="indexterm"></a> blue bird. This bird splits into multiple birds when the user taps the screen. The effect actually requires two birds that look identical, one that does the splitting and another that is split in two but does nothing special.</p><p>It is actually possible to add anything that we want to spawn to the blue bird's list of things to split into. Your challenge here is to create a rainbow bird. This bird can split into different types of birds, not just blue ones. Or, perhaps it is a stone bird that splits into stone blocks. For an extended challenge, create a mystery bird that randomly picks a bird from its list when it splits.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec49"></a>The black bird</h3></div></div></div><p>Finally, we<a id="id459" class="indexterm"></a> have the black bird. This bird explodes when the player touches the screen. As with all the birds discussed previously, it will extend the <code class="literal">Bird</code> script; inheriting from the red bird makes the black bird's creation much easier. Let's use these steps to do it:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>As with the others, this bird is initially created in the same way as the red bird, readjusting the value of <span class="strong"><strong>Radius</strong></span> on your <span class="strong"><strong>Circle Collider 2D</strong></span> component for its increased size.</p></li><li><p>Again, we create a new script to extend the <code class="literal">Bird</code> script. This time, it is called <code class="literal">BlackBird</code>.</p></li><li><p>Do not forget to adjust line four to extend the <code class="literal">Bird</code> script and not <code class="literal">MonoBehaviour</code>:</p><div class="informalexample"><pre class="programlisting">public class BlackBird : Bird {</pre></div></li><li><p>This script has two variables. The first variable is the size of the explosion and the second is its strength:</p><div class="informalexample"><pre class="programlisting">public float radius = 2.5f;
public float power = 25f;</pre></div></li><li><p>Once more, we override the <code class="literal">DoSpecial</code> function, first marking that we did so. Next, we use <code class="literal">Physics2D.OverlapCircleAll</code> to acquire a list of all the objects that are within the range of the bird's explosion, the 3D version of which is <code class="literal">Physics.OverlapSphere</code>. Next, we calculate where the explosion is coming from, which is just our bird's position moved down three units. We move it down because explosions that throw debris up are more exciting than the ones that push debris out. The function then loops through the list, skipping any empty slots and those without rigidbodies:</p><div class="informalexample"><pre class="programlisting">protected override void DoSpecial() {
  didSpecial = true;

  Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, radius);

  Vector2 explosionPos = new Vector2(transform.position.x, transform.position.y) – (Vector2.up * 3);

  foreach(Collider2D hit in colliders) {
    if(hit == null) continue;
    if(hit.attachedRigidbody != null) {</pre></div></li><li><p>If the <a id="id460" class="indexterm"></a>object exists and has a <span class="strong"><strong>Rigidbody</strong></span> component attached, we need to calculate how the explosion is going to affect this object, simulating the way an explosion's strength is reduced the further away you are from it. First, we save ourselves some typing by grabbing the other object's position. Next, we calculate where it is, relative to the position of the explosion. By dividing the magnitude or the length of the relative position by our <code class="literal">radius</code> variable, we can figure out how much force to apply to the object that was hit. Finally, we use <code class="literal">AddForceAtPosition</code> to give the object a kick as if the explosion was in a specific spot. The <code class="literal">ForceMode2D.Impulse</code> variable is used to apply the force immediately:</p><div class="informalexample"><pre class="programlisting">Vector3 hitPos = hit.attachedRigidbody.transform.position;
Vector2 dir = new Vector2(hitPos.x, hitPos.y) – explosionPos;
float wearoff = 1 – (dir.magnitude / radius);
Vector2 force = dir.normalized * power * wearoff;
hit.attachedRigidbody.AddForceAtPosition(force, explosionPos, ForceMode2D.Impulse);
}
}</pre></div></li><li><p>Finally, the function destroys the exploded bird:</p><div class="informalexample"><pre class="programlisting">Destroy(gameObject);
}</pre></div></li><li><p>As with the last two, apply your new script to your new bird and turn it into a prefab. You now have four birds to choose from when selecting the slingshot arsenal for each level.</p></li></ol></div><p>We created our fourth and last bird: the black bird. This bird explodes when the user touches the screen, throwing anything that might be near it into the sky. This can be a fun bird to play around with and is effective for destroying your pig forts.</p><p>The black bird <a id="id461" class="indexterm"></a>from the game we are imitating has the additional ability of a timed explosion after it has hit something. Try creating a timer for our black bird to recreate this effect. You will have to override the <code class="literal">OnCollisionEnter</code> function to start your timer and use <code class="literal">LateUpdate</code> to count down. Once your timer runs out, you can just use our <code class="literal">DoSpecial</code> function to actually cause the explosion.</p><p>Now that you know how to cause explosions, we have another challenge: create an explosive crate. You need to extend the <code class="literal">Plank</code> script to make it, and when enough damage is done to the crate, trigger the explosion. For an additional challenge, instead of making the crate explode, configure it to throw out a few bombs that explode when they hit something.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_07_06.jpg" /></div></div></div>