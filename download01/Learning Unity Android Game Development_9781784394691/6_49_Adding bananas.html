<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec51"></a>Adding bananas</h2></div></div><hr /></div><p>When it comes to a <a id="id372" class="indexterm"></a>game with monkeys, the most obvious thing for our player to collect is bananas. However, it is never enough to have items in the <a id="id373" class="indexterm"></a>world for players to collect; we have to show the player that the items are collectible. Usually, this means that the thing is spinning, bouncing, shining, generating sparks, or demonstrating some other special effect. For our game, we are going to make the bananas bounce up and down while spinning in place. Let's do it with these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Right off the bat, we are going to need a new script. Create one and name it <code class="literal">BananaBounce</code>.</p></li><li><p>This script begins with three variables. The first is how fast, in meters per second, the banana will move up and down. The second is how high the banana will go from its starting position. The third is at how many degrees per second the banana will spin in place. Altogether, these variables will let us easily control and tweak the movement of the banana:</p><div class="informalexample"><pre class="programlisting">public float bobSpeed = 1.5f;
public float bobHeight = 0.75f;
public float spinSpeed = 180f;</pre></div></li><li><p>This next variable will keep track of the actual object that will be moving. By using two objects for the setup and control of the banana, we are able to separate position and rotation and make everything easier:</p><div class="informalexample"><pre class="programlisting">public Transform bobber;</pre></div></li><li><p>The function for this script is <code class="literal">Update</code>. It first checks to make sure that our <code class="literal">bobber</code> variable has been filled. Without it, we can't do anything to make our banana move:</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(bobber != null) {</pre></div></li><li><p>Next, we use the <code class="literal">PingPong</code> function to calculate a new position for our banana. This function bounces a value between zero and the second value you to it. In this case, we are using the current time multiplied by our speed to determine how far the banana might have moved in this game. By giving a height to it, we end up with a value that moves back and forth from zero to our maximum height. We then multiply it by an up vector and apply it to our <code class="literal">localPosition</code> so that the banana will move up and down:</p><div class="informalexample"><pre class="programlisting">  float newPos = Mathf.PingPong(Time.time * bobSpeed, bobHeight);
  bobber.localPosition = Vector3.up * newPos;
}</pre></div></li><li><p>Finally, we use the same <code class="literal">Rotate</code> function that we used for rotating turrets to make the banana spin in its place. It will just do this constantly at whatever speed we tell it to:</p><div class="informalexample"><pre class="programlisting">transform.Rotate(Vector3.up * Time.deltaTime * spinSpeed);
}</pre></div></li><li><p>Next, we need to return to Unity and set these bananas up. To do this, we first need to add the <code class="literal">Banana</code> model to the scene. If it is white, be sure to add the <code class="literal">Banana</code> texture to it.</p></li><li><p>Add our <a id="id374" class="indexterm"></a>
<code class="literal">BananaBounce</code> script to the new <a id="id375" class="indexterm"></a>banana, or else it is just not going to set there.</p></li><li><p>The child object of <code class="literal">Banana</code> needs to be put in the <span class="strong"><strong>Bobber</strong></span> slot on our script component.</p></li><li><p>Finally, turn it into a prefab and scatter them about the map: a few at the beginning area, a few near the finish line, and some along the way.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_06_11.jpg" /></div></li></ol></div><p>If you try out the game now, you should have several happily bouncing bananas. By using the <code class="literal">Mathf.PingPong</code> function, our jobs are made very easy for the creation of this effect. Without it, we would have needed to do a bunch of extra calculations to figure out whether we were moving up or down and how far along we were.</p><p>Having bananas as collectibles is great, but which game these days has a single type of pickup? Try your hand at making some other pickup models. The most obvious one would be some banana bundles, such as the bunches that you can buy at the grocery store or the huge bunch <a id="id376" class="indexterm"></a>that actually grows on banana trees. However, you could also go down the route of coins, energy crystals, ancient monkey <a id="id377" class="indexterm"></a>totems, checkpoints, score multipliers, or anything else that might catch your attention.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec39"></a>Collecting bananas with touch</h3></div></div></div><p>One of the most <a id="id378" class="indexterm"></a>obvious features of the <a id="id379" class="indexterm"></a>modern mobile device is the touch screen. Devices use the electrical conductivity of the user's finger and many tiny contact points to determine the location that is being touched. In order to explore the possibilities of the touch interface for our game, we will be making our players poke the bananas on the screen rather than running into them to collect them. Unity provides us with easy access to the touch inputs. By combining the input with ray casts, as we did for making the tanks fire, we can determine which object in the 3D space was touched by the user. For us, this means we can give the player the ability to touch and collect those bananas. To do it, let's use these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First up, we need a new script. Create one and name it <code class="literal">BananaTouch</code>.</p></li><li><p>The <code class="literal">Update</code> <a id="id380" class="indexterm"></a>function is the only function in this script. It starts by checking to see whether the player is touching the screen in any way. The <code class="literal">Input</code> class provides us with the <code class="literal">touchCount</code> value, which is simply a counter for how many fingers are currently touching the device's screen. If there are no fingers touching, we don't want to waste our time doing any work, so we exit early with <code class="literal">return</code>: and are ready to check the next frame again to see whether the player is touching the screen.</p><div class="informalexample"><pre class="programlisting">public void Update() {
  if(Input.touchCount &lt;= 0) return;</pre></div></li><li><p>We next create a <code class="literal">foreach</code> loop. This is a loop that will check each item in the list of touches, but it will not track the index of that touch. We then check the phase of each touch to see whether it has just started touching the screen. Every touch has five potential phases: <span class="strong"><strong>Began</strong></span>, <span class="strong"><strong>Moved</strong></span>, <span class="strong"><strong>Stationary</strong></span>, <span class="strong"><strong>Ended</strong></span>, and <span class="strong"><strong>Canceled</strong></span>:</p><div class="informalexample"><pre class="programlisting">foreach(Touch next in Input.touches) {
  if(next.phase == TouchPhase.Began) {</pre></div><p>Here is the description for each state:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Began</strong></span>: This phase of touch occurs when the user first touches the screen.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Moved</strong></span>: This phase of touch occurs when the user moves his or her finger across the screen.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Stationary</strong></span>: This phase of touch is the opposite of the previous phase; this happens when the user's finger is not moving across the screen.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Ended</strong></span>: This <a id="id381" class="indexterm"></a>phase of touch occurs when the user's finger is lifted off the screen. This is the normal way for a touch to complete.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Canceled</strong></span>: This phase of touch occurs when an error occurs while tracking the touch. This phase tends to occur most often when a finger is touching the screen but not moving for a lot of time. The touch system is not perfect, so it assumes that it missed the finger being lifted off the screen and just cancels that touch.</p></li></ul></div></li><li><p>Next, we create a pair of variables. As with our tanks, the first is a holder for what was hit by our raycast. The second is a <code class="literal">Ray</code>, which is just a container for storing a point in space and a directional vector. The <code class="literal">ScreenPointToRay</code> function is specially provided by the camera for converting touch positions from the 2D space of the screen to the 3D space of the game world:</p><div class="informalexample"><pre class="programlisting">RaycastHit hit;
Ray touchRay = Camera.main.ScreenPointToRay(next.position);</pre></div></li><li><p>The last step for the function is to call the <code class="literal">Raycast</code> function. We pass the ray and the tracking variable to the function. If an object is hit, we send it a message to tell it that it has been touched, just like shooting things with our tank. In addition, there are several curly braces that are required to close off the <code class="literal">if</code> statements, loop, and function:</p><div class="informalexample"><pre class="programlisting">      if(Physics.Raycast(touchRay, out hit)) {
        hit.transform.gameObject.SendMessage("Touched", SendMessageOptions.DontRequireReceiver);
      }
    }
  }
}</pre></div></li><li><p>Before we <a id="id382" class="indexterm"></a>can try it out, we need to update our <code class="literal">BananaBounce</code> script to give it some health and allow it to be destroyed when its health runs out. So, open it now.</p></li><li><p>First, we need a pair of variables. The first is <code class="literal">health</code>. Actually, this is just the number of touches that are required to destroy the banana. If we had multiple types of bananas, they could each have a different amount of health. The second variable is a modifier for the banana's speed of movement. Every time the banana loses health, it will slow down, indicating how much health it has left:</p><div class="informalexample"><pre class="programlisting">public int health = 3;
public float divider = 2f;</pre></div></li><li><p>Next, we need to add a new function. This <code class="literal">Touched</code> function will receive the message from our <code class="literal">BananaTouch</code> script. It works similar to how we shot with our tank. The very first thing it does is reduce the remaining health:</p><div class="informalexample"><pre class="programlisting">public void Touched() {
  health--;</pre></div></li><li><p>After some <a id="id383" class="indexterm"></a>damage has been done, we can slow the movement of the banana by doing a little division. This way it is easy for the player to know whether their touch was successful:</p><div class="informalexample"><pre class="programlisting">  bobSpeed /= divider;
  spinSpeed /= divider;</pre></div></li><li><p>Finally, the function checks to see whether the banana has run out of health. If it has, we use the <code class="literal">Destroy</code> function to get rid of it, just like the enemy tanks:</p><div class="informalexample"><pre class="programlisting">  if(health &lt;= 0) {
    Destroy(gameObject);}
}</pre></div></li><li><p>When you return to Unity, you need to attach our new <code class="literal">BananaTouch</code> script to the <code class="literal">MonkeyBall</code> object. Due to the way it works, it could technically go on any object, but it is always a good practice to keep player control scripts together and on what they are controlling.</p></li><li><p>Next, add a <a id="id384" class="indexterm"></a>
<span class="strong"><strong>Sphere Collider</strong></span> component to one of your bananas; this can be found by navigating to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics</strong></span> | <span class="strong"><strong>Sphere Collider</strong></span>. If we make the changes to one and update the prefab, all the bananas in the scene will be updated.</p></li><li><p>Check the <span class="strong"><strong>Is Trigger</strong></span> box so that the bananas do not block the movement of our monkey,. They will still be touchable while allowing our monkey to pass through them.</p></li><li><p>The collider also needs to be positioned in a place where the player will mostly touch when they hit it. So, set the <span class="strong"><strong>Center</strong></span> to <code class="literal">0</code> for <span class="strong"><strong>X</strong></span>, <code class="literal">0.375</code> for <span class="strong"><strong>Y</strong></span>, and <code class="literal">0</code> for <span class="strong"><strong>Z</strong></span>. In addition, make sure the <span class="strong"><strong>Radius</strong></span> is set to <code class="literal">0.5</code>.</p></li><li><p>Finally, be sure to hit the <span class="strong"><strong>Apply</strong></span> button at the top right of the <span class="strong"><strong>Inspector</strong></span> panel to update all the bananas in the scene.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_06_12.jpg" /></div></li></ol></div><p>When you try out the game now, you should be able to touch any of the bananas. Initially, all of the bananas will move up and down evenly, like they did earlier. As you touch them, the ones <a id="id385" class="indexterm"></a>that you touched will move slower, thanks to the bit of division that we made, before they are finally deleted. This lets our player easily see which bananas have been touched and which haven't.</p><p>The next step from having collectible objects in a game is to give meaning to the player. This is mostly done by giving them some point value. Try to do that here. It could be done in a very similar manner to the point system we had when we were destroying enemy tanks. If you created some other pickups earlier, you could set each of them up to have different <a id="id386" class="indexterm"></a>amounts of health. They could also give you different amounts of points as a result. Play around with the numbers and settings until you find something that will be fun for the player to interact with.</p></div></div>