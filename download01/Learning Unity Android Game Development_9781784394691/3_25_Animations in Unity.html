<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec29"></a>Animations in Unity</h2></div></div><hr /></div><p>The <a id="id201" class="indexterm"></a>next topic that we will be covering is animation. As we explore animations in Unity, we will create some targets for our tank to shoot at. Much of the power of Unity's animation <a id="id202" class="indexterm"></a>system, <span class="strong"><strong>Mecanim</strong></span>, lies in working with humanoid characters. But, setting up and <a id="id203" class="indexterm"></a>animating human type characters could fill an entire book in itself, so it will not be covered here. However, there is still much that we can learn and do with Mecanim.</p><p>The following bullet points will explain all of the settings that are available for importing animations:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Before we <a id="id204" class="indexterm"></a>continue with the explanation of the animation import settings, we need an animated model to work with. We have one last set of assets to import to our project. Import the <code class="literal">Target.blend</code> and <code class="literal">Target.png</code> files into the <code class="literal">Targets</code> folder of our project. Once they are imported, adjust the <span class="strong"><strong>Import Settings</strong></span> window on the <span class="strong"><strong>Model</strong></span> page for the target, just as we did for the tank. Now, switch to the <span class="strong"><strong>Rig</strong></span> tab (as shown in the following screenshot):</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_11.jpg" /></div></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Animation Type</strong></span> attribute tells Unity what type of skeleton the current model is going to use when animation is going to be done. Models with different types are<a id="id205" class="indexterm"></a> unable to share animations. The different options under <span class="strong"><strong>Animation Type</strong></span> are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="strong"><strong>Humanoid</strong></span> option adds many more buttons and switches to the page for working with human type characters. But again, this is too complex to cover here.</p></li><li style="list-style-type: disc"><p>A <span class="strong"><strong>Generic</strong></span> rig still uses Mecanim and many of its features. In reality, this is just any animation skeleton that does not resemble a human in structure.</p></li><li style="list-style-type: disc"><p>The third option, <span class="strong"><strong>Legacy</strong></span>, utilizes Unity's old animation system. However, this system will be phased out over the next few versions of Unity, so this will not be covered here either.</p></li><li style="list-style-type: disc"><p>The last option, <span class="strong"><strong>None</strong></span>, indicates that the object will not animate. You could select this option for both the tank and the city because it also keeps Unity from adding the Animator component, and saves space in the final project's size.</p></li></ul></div></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Root Node</strong></span> value is a list of every object that is in the model file. Its purpose is to select the base object of your animation rig. For this target, select <span class="strong"><strong>Bone_Arm_Upper</strong></span>, which is underneath the second <span class="strong"><strong>Armature</strong></span> option.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Optimize Game Object</strong></span> option will hide the whole skeleton of your model when it is checked. Hitting the plus sign on the new box that appears will allow you to select specific bones, which you still want access to when you view the model in the <span class="strong"><strong>Hierarchy</strong></span> window. This is an especially useful option when dealing with any complex rig that has a great many bones.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_12.jpg" /></div></li><li style="list-style-type: disc"><p>The last tab of the import settings, <span class="strong"><strong>Animations</strong></span>, contains everything that we need to get the animations from our files into Unity. At the top of the <span class="strong"><strong>Target Import Settings</strong></span> window, we have the <span class="strong"><strong>Import Animation</strong></span> checkbox. If an object is not going <a id="id206" class="indexterm"></a>to animate, it is a good idea to turn this option off. Doing so will also save space in your project.</p></li><li style="list-style-type: disc"><p>The option below that, <span class="strong"><strong>Bake Animations</strong></span>, is only used when your animations contain kinematics and are from 3ds Max or Maya. This target is from Blender, so the option is grayed out.</p></li><li style="list-style-type: disc"><p>The next four options, <span class="strong"><strong>Anim. Compression</strong></span>, <span class="strong"><strong>Rotation Error</strong></span>, <span class="strong"><strong>Position Error</strong></span>, and <span class="strong"><strong>Scale Error</strong></span>, are primarily used for smoothing jittery animations. Nearly all the time, the defaults will be just fine for use.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Clips</strong></span> section is what we are really concerned about here. This will be a list of every animation clip that is currently being imported from the model. On the left-hand side <a id="id207" class="indexterm"></a>of the list, we have the name of the clip. On the right-hand side, we can see the start and end frames of the clip. The various parameters under the <span class="strong"><strong>Clips</strong></span> section are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Unity will add a default animation to every new model. This is a clip generated from the default preview range of your modeling program when the file was saved. In the case of our target, this is <span class="strong"><strong>Default Take</strong></span>.</p></li><li style="list-style-type: disc"><p>In Blender, it is also possible to create a series of actions for each rig. By default, they are imported by Unity as animation clips. In this case, the <span class="strong"><strong>ArmatureAction</strong></span> clip is created.</p></li><li style="list-style-type: disc"><p>Below and to the right-hand side of the clips, there is a little tab with the <span class="strong"><strong>+</strong></span> and <span class="strong"><strong>â€“</strong></span> buttons. These two buttons add a clip to the end and remove the selected clip respectively.</p></li></ul></div><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_13.jpg" /></div></li><li style="list-style-type: disc"><p>When a clip is selected, the next section appears. It starts with a text field for changing the name of the clip.</p></li><li style="list-style-type: disc"><p>Below the text field, when working with Blender, there is a <span class="strong"><strong>Source Take</strong></span> drop-down list. This list is the same as the default animations. Most of the time, you will just use <span class="strong"><strong>Default Take</strong></span>; but, if your animation is for ever appearing wrong or is missing, try changing the <span class="strong"><strong>Source Take</strong></span> drop-down list first.</p></li><li style="list-style-type: disc"><p>Then, we have a small timeline, followed by input fields for the <span class="strong"><strong>Start</strong></span> and <span class="strong"><strong>End</strong></span> frames of the animation clip. Clicking on the two blue flags and dragging them in the timeline will change the numbers in the input fields.</p></li><li style="list-style-type: disc"><p>Next, we<a id="id208" class="indexterm"></a> have <span class="strong"><strong>Loop Time</strong></span>, <span class="strong"><strong>Loop Pose</strong></span>, and <span class="strong"><strong>Cycle Offset</strong></span>. If we want our animation to repeat, check the box next to <span class="strong"><strong>Loop Time</strong></span>. <span class="strong"><strong>Loop Pose</strong></span> will cause the positions of the bones in the first and last frames of the animation to match. When an animation is looping, <span class="strong"><strong>Cycle Offset</strong></span> will become available. This value lets us adjust the frame on which the looping animation starts.</p></li><li style="list-style-type: disc"><p>The next three small sections, <span class="strong"><strong>Root Transform Rotation</strong></span>, <span class="strong"><strong>Root Transform Position (Y)</strong></span>, and <span class="strong"><strong>Root Transform Position (XZ)</strong></span>, allow us to control the movement of a character through the animation. The controls under these sections are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>All three of these sections have a <span class="strong"><strong>Bake into Pose</strong></span> option. If these are left unchecked, the movement of the root node (we selected it under the <span class="strong"><strong>Rig</strong></span> page) within the animation is translated into movement of the whole object. Think of it like this: say you were to animate a character running to the right inside the animation program, you will actually move them rather than animating in place as normal.</p></li><li style="list-style-type: disc"><p>With Unity's old animation system, for the physical part of a character to move the collider, the GameObject had to be moved with the code. So, if you were to use the animation, the character would appear as if it had moved, but it would have no collision. With this new system, the whole character will move when the animation is played. However, this requires a different and more complex setup to work completely. So, we did not use this on the tank, though we could have used it.</p></li><li style="list-style-type: disc"><p>Each of the three sections also has a <span class="strong"><strong>Based Upon</strong></span> drop-down option. The choice of this option dictates the object's center for each of the sections. There are more choices if you are working with humanoid characters, but for now we only have two. A choice of <span class="strong"><strong>Root Node</strong></span> means the pivot point of the root node object is the center. A choice of <span class="strong"><strong>Original</strong></span> means that the origin, as defined by the animation program, is the center of the object.</p></li><li style="list-style-type: disc"><p>There is also an <span class="strong"><strong>Offset</strong></span> option for the first two of these sections that works to correct errors in the motion. When animating a walk cycle for a character, if the character is pulling to the side slightly, adjusting the <span class="strong"><strong>Offset</strong></span> option under <span class="strong"><strong>Root Transform Rotation</strong></span> will correct it.</p></li></ul></div></li><li style="list-style-type: disc"><p>The next <a id="id209" class="indexterm"></a>option for our animation clip is a <span class="strong"><strong>Mask</strong></span>. By clicking on the arrow to the left, you can expand a list of all objects in the model. Each object has a checkbox next to it. The objects that are not checked will not be animated when this clip is played. This is useful in the case of a hand-waving animation. Such an animation would only need to move the arm and hand, so we would uncheck all of the objects that might make up the body of the character. We could then layer animations, making our character capable of waving while standing, walking, or running without the need to create three extra animations.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Curves</strong></span> option will give you the ability to add a float value to the animation, which will change over the course of the animation. This value can then be checked by your code while the animation plays. This could be used to adjust the gravity affecting your character while they jump, change the size of their collider as they crouch into a ball, or do a great many other things.</p></li><li style="list-style-type: disc"><p>Events work similar to how we used the <code class="literal">SendMessage</code> function in our <code class="literal">RepeatButton</code> script. At a specific point in your animation, a function can be called to perform some action.</p></li><li style="list-style-type: disc"><p>The<span class="strong"><strong> Motion</strong></span> option lets you define which bone in your animation controls the model motion. This can override the one chosen on the <span class="strong"><strong>Rig</strong></span> tab. Our target does not move, so it is not particularly relevant to our situation.</p></li><li style="list-style-type: disc"><p>Finally, we have our <span class="strong"><strong>Revert</strong></span> button, <span class="strong"><strong>Apply</strong></span> button, and the <span class="strong"><strong>Preview</strong></span> window at the bottom. Just as with all of our other import settings, we have to hit one of these buttons when changes are made. This <span class="strong"><strong>Preview</strong></span> window is made special by the speed slider in the top-right corner and the big play button in the top-left corner. By clicking on this button, we can preview the selected animation. This lets us detect the errors in motion that we discussed earlier, and it generally makes sure that the animation is what we want it to be.</p></li></ul></div><p>There are a lot of settings that are available to us when we are working with animations in Unity. They let us control the frames from the original animation program that we want to import. In addition, they can be used to control how the animation interacts with your scripts. No matter what settings you choose, the most important thing is the animation clip's name. If <a id="id210" class="indexterm"></a>this is not set, it can be extremely difficult to work with several animations that have the same name.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec26"></a>The target's animations</h3></div></div></div><p>So, now that the description is all out of the way, let's actually make something with it. We will start by setting up the animations for the target. Using the knowledge that we just gained, we can <a id="id211" class="indexterm"></a>now set up our target's animations as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>For starters, if you missed or skipped it earlier, be sure to import the <code class="literal">Target.blend</code> and <code class="literal">Target.png</code> files to the <code class="literal">Targets</code> folder. In addition, on the <span class="strong"><strong>Rig</strong></span> page of the import settings, ensure that the <span class="strong"><strong>Animation Type</strong></span> attribute is set to <span class="strong"><strong>Generic</strong></span> and the <span class="strong"><strong>Root Node</strong></span> attribute is set to <span class="strong"><strong>Bone_Arm_Upper</strong></span>.</p></li><li><p>We need a total of six animations. By clicking on the <span class="strong"><strong>+</strong></span> button in the <span class="strong"><strong>Clips</strong></span> section, you can add four more animations. If you have added too many, click on the <span class="strong"><strong>-</strong></span> button to remove the extra clips.</p></li><li><p>All of these clips should have a <span class="strong"><strong>Source Take</strong></span> drop-down list of <span class="strong"><strong>Default Take</strong></span> and all of the <span class="strong"><strong>Bake into Pose</strong></span> options should be checked because the target will not move from its starting location.</p></li><li><p>First, let's create our idle animations. Select the first clip and rename it as <code class="literal">Idle_Retract</code>. As this is a mechanical object, we can get away with a really short animation; it is so short that we are just going to use the first frame. Set the starting frame to <code class="literal">0.9</code> and the ending frame to <code class="literal">1</code>.</p></li><li><p>We also need to turn on <span class="strong"><strong>Loop Pose</strong></span> because idle animations are, of course, looping.</p></li><li><p>The extended idle animation is created in almost exactly the same manner. Select the second clip and rename it as <code class="literal">Idle_Extend</code>. The starting frame here is <code class="literal">14</code> and the ending frame is <code class="literal">14.1</code>. In addition, this animation needs to loop.</p></li><li><p>Our next two animations are for a situation when the target extends and retracts. They will be called <code class="literal">Extend</code> and <code class="literal">Retract</code>, so rename the next two clips. The <code class="literal">Extend</code> animation will start at frame <code class="literal">1</code> and end at frame <code class="literal">13</code>. The <code class="literal">Retract</code> animation will start at frame <code class="literal">28</code> and ends at frame <code class="literal">40</code>. Neither of these will loop.</p></li><li><p>The last two animations also will not loop. They are for when we shoot the targets. There is one for being shot in the front and one for being shot from behind. The <code class="literal">Hit_Front</code> animation will be from frame <code class="literal">57</code> to frame <code class="literal">87</code>. The <code class="literal">Hit_Back</code> animation will be from frame <code class="literal">98</code> to frame <code class="literal">128</code>.</p></li><li><p>Once all of the changes are made, make sure to click on <span class="strong"><strong>Apply</strong></span> or they will not be saved.</p></li></ol></div><p>We have now <a id="id212" class="indexterm"></a>set up the animations that will be used by our targets. There are six in total. They may not seem like much now, but the next section would not be possible without them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"></a>State machines to control animations in Unity</h3></div></div></div><p>In order for us to control these new animations in Unity, we need to set up a state machine. A <a id="id213" class="indexterm"></a>state machine<a id="id214" class="indexterm"></a> is just a fancy object that keeps track of what an object can do, and how to transition between things. You can think of it in terms of a builder from a real-time strategy game. The builder has a walk state that is used when moving to the next construction site. When the builder gets there, it switches to a build state. If an enemy shows up, the builder will enter a runaway state until the enemy is gone. Finally, there is an idle state for when the builder does nothing. In Unity, these are called Animator controllers when you work with animations and Mecanim.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec36"></a>Target state machine</h4></div></div></div><p>The use of a state machine allows us to focus more on what the target is doing, while letting Unity handle the <span class="emphasis"><em>how it is going to do it</em></span> part. Perform these steps to create the state machine<a id="id215" class="indexterm"></a> and <a id="id216" class="indexterm"></a>control the target:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Creating an <span class="strong"><strong>Animator</strong></span> controller is simple and this is done just as we have been doing for our scripts and materials. The option is approximately in the middle of the <span class="strong"><strong>Create</strong></span> menu. Create an Animator controller in the <code class="literal">Targets</code> folder and name it <code class="literal">TargetController</code>.</p></li><li><p>Double-click on <code class="literal">TargetController</code> to open a new window (as shown in the following screenshot):</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_14.jpg" /></div><p>The <span class="strong"><strong>Animator</strong></span> window is where we edit our state machines. The various parts of the <span class="strong"><strong>Animator</strong></span> window are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>In the<a id="id217" class="indexterm"></a> top-left side is a <span class="strong"><strong>Layers</strong></span> button. Clicking on it will display a list of all of the blendable layers that make up your animation system. Every state machine will have at least the <span class="strong"><strong>Base Layer</strong></span>. Adding more layers would allow us to blend state machines. Let's say we have a character that walks around normally when he is at full health. When his health drops below half, he starts to limp. If the character has only ten percent of his health left, he starts to crawl. This would be achieved through the use of layers to prevent the need of creating extra animations for each type of movement.</p></li><li style="list-style-type: disc"><p>To the right of that is a <span class="strong"><strong>Parameters</strong></span> button that will display the list of parameters. Clicking on the <span class="strong"><strong>+</strong></span> button will add a new parameter to the list. These parameters can be <span class="strong"><strong>Float</strong></span>, <span class="strong"><strong>Int</strong></span>, <span class="strong"><strong>Bool</strong></span>, and <span class="strong"><strong>Trigger</strong></span>. The transitions between the states are most often triggered by changes in these parameters. Any scripts working with the state machine can modify these values.</p></li><li style="list-style-type: disc"><p>The next bit is a breadcrumb trail, like one that you might find on a website. It lets us see where we are in the state machine at a glance.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Auto Live Link</strong></span> button at the top-right corner controls our ability to see the state machine's update in real time within the game. This is useful for debugging transitions and controls for the character.</p></li><li style="list-style-type: disc"><p>In the center of the <span class="strong"><strong>Animator</strong></span> window, there are three boxes: <span class="strong"><strong>Any State</strong></span>, <span class="strong"><strong>Entry</strong></span>, and <span class="strong"><strong>Exit</strong></span>. (If you can't see them, click on the middle mouse button and drag on the grid to pan the view around.) These boxes are<a id="id218" class="indexterm"></a> the base controls for your animation state machine. The <span class="strong"><strong>Any State</strong></span> box will allow your object to transition into specific animations, no matter where in the state machine they may be, such as moving to a death animation irrespective of the action the player was performing. The <span class="strong"><strong>Entry</strong></span> box is used when you first start your state machine. All of the transitions are analyzed and the first suitable and subsequent animation becomes the starting location. The <span class="strong"><strong>Exit</strong></span> box is used primarily for substate machines and allows you to transition out of the group without a lot of extra convoluted connections.</p></li></ul></div></li><li><p>To create a new state, right-click on the grid that is inside our <span class="strong"><strong>Animator</strong></span> window. Hover your mouse over <span class="strong"><strong>Create State</strong></span> and select <span class="strong"><strong>Empty</strong></span>. This creates a new empty state for our state machine. Normally, new states are gray, but since this is the first state in our machine, it is orange, which is the color of the default state.</p></li><li><p>Every state machine will start in its default state. Click on the state to select it, and we can take a look at it in the <span class="strong"><strong>Inspector</strong></span> window (as shown in the following screenshot).</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_15.jpg" /></div><p>You can see the following fields in the preceding screenshot:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>At the top, there is a text field for changing the name of the state.</p></li><li style="list-style-type: disc"><p>Below <a id="id219" class="indexterm"></a>that, you can add a <span class="strong"><strong>Tag</strong></span> for organizational purposes.</p></li><li style="list-style-type: disc"><p>Next, there is a <span class="strong"><strong>Speed</strong></span> field. This field controls the playback speed of the animation.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Motion</strong></span> field is where we will add connections to the animation clips that we created earlier.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Foot IK</strong></span> option lets us decide whether we want to let a part of the animation to be calculated with <a id="id220" class="indexterm"></a>
<span class="strong"><strong>Inverse Kinematics</strong></span> (<span class="strong"><strong>IK</strong></span>), which is the process of calculating how a chain of bones will be laid out based on the position of the target bone at the end. We did not set up any IK for these animations, so we do not need to worry about this option.</p></li><li style="list-style-type: disc"><p>With the <span class="strong"><strong>Write Defaults</strong></span> option, we can control whether animated properties remain changed after the animation ends.</p></li><li style="list-style-type: disc"><p>The last option, <span class="strong"><strong>Mirror</strong></span>, is used to flip the left and right axis (or <span class="emphasis"><em>x</em></span> axis) of the animation. If you created a right-hand-waving animation, this option would let you change it to a left-hand-waving animation.</p></li><li style="list-style-type: disc"><p>Below <a id="id221" class="indexterm"></a>that, there is the list of transitions that go from the current state to another state. These are transitions that are out of the state and not into it. As you will soon see, a transition in this list appears as the name of the current state with an arrow to the right, followed by the name of the state it is connected to.</p></li><li style="list-style-type: disc"><p>Checkboxes also appear under the <span class="strong"><strong>Solo</strong></span> and <span class="strong"><strong>Mute</strong></span> labels on the right. These are for debugging transitions between the states. Any number of transitions can be muted at one time, but only one can be soloed at a time. When a transition has been muted, it means that the state machine will ignore it when deciding which transition to make. Checking the <span class="strong"><strong>Solo</strong></span> box is the same as muting all but one of the transitions; this is just a quick way to make it the only active transition.</p></li></ul></div></li><li><p>We are going to need one state for each of our target's animations. So, create five more states and rename all six to match the names of the animation clips that we created earlier. The default state, the first one you created that will appear orange on your screen, should be named <code class="literal">Idle_Retract</code>.</p></li><li><p>In the <span class="strong"><strong>Project</strong></span> window, click on the little triangle on the right side of the <span class="strong"><strong>Target</strong></span> model (as highlighted in the following screenshot):</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_16.jpg" /></div><p>This expands the model so that we can see all of the objects that make up that model in Unity. The first group consists of the actual objects that make up the model. Next are the raw meshes that are used in the model. These are followed by the animation clips (they will appear on your screen as a blue box with a big play button at the center); these are what we are interested in right now. Last is an avatar object; this is what keeps track of the <span class="strong"><strong>Rig</strong></span> setup.</p></li><li><p>Select each state<a id="id222" class="indexterm"></a> in your <span class="strong"><strong>Animator</strong></span> window and pair it with the correct clip by dragging an animation clip from the <span class="strong"><strong>Project</strong></span> window, and dropping it onto the <span class="strong"><strong>Motion</strong></span> field in the <span class="strong"><strong>Inspector</strong></span> window.</p></li><li><p>Before we can create our transitions, we need a few parameters. Open the parameters list by clicking on the <span class="strong"><strong>Parameters</strong></span> button in the top-left corner. Then, click on the <span class="strong"><strong>+</strong></span> button and select <span class="strong"><strong>Float</strong></span> from the menu that appears. A new parameter should now appear in the list.</p></li><li><p>The new field on the left-hand side is the name of the parameter; it can be renamed at any time by double-clicking on it. Rename this one to <code class="literal">time</code>. The field on the right is the current value of this parameter. When debugging our state machine, we can modify these values here to trigger changes in the state machine. Any changes made by the scripts while the game is running will also appear here.</p></li><li><p>We need two more parameters. Create two <span class="strong"><strong>Bool</strong></span> parameters and rename them as <code class="literal">wasHit</code> and <code class="literal">inTheFront</code>. These will trigger the machine to change to the getting hit states, while the time parameter will trigger the machine to utilize the <code class="literal">extend</code> and <code class="literal">retract</code> states.</p></li><li><p>To create a new transition, right-click on a state and select <span class="strong"><strong>Make Transition</strong></span> from the menu that pops up. A transition line is now connected from the state to your mouse. To complete the transition creation, click on the state that you wish to connect to. There will be an arrow on the line, indicating the direction of the transition. We need the following transitions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>We need a transition from <code class="literal">Idle_Retract</code> to <code class="literal">Extend</code>.</p></li><li style="list-style-type: disc"><p>We also need a transition from <code class="literal">Extend</code> to <code class="literal">Idle_Extend</code>.</p></li><li style="list-style-type: disc"><p><code class="literal">Idle_Extend</code> needs three transitions, one going to <code class="literal">Retract</code>, the other to <code class="literal">Hit_Front</code>, and the last to <code class="literal">Hit_Back</code>.</p></li><li style="list-style-type: disc"><p>The<code class="literal"> Retract</code>, <code class="literal">Hit_Front</code>, and <code class="literal">Hit_Back</code> animations need a transition that goes to <code class="literal">Idle_Retract</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip07"></a>Tip</h3><p>Use the following screenshot as a reference. If you create a transition or state that you do not want, select it and hit the <span class="emphasis"><em>Delete</em></span> key on your keyboard to remove it.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_17.jpg" /></div></div></li></ul></div></li><li><p>If you click <a id="id223" class="indexterm"></a>on one of the transition lines, then we can take a look at its settings (as shown in the following screenshot):</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_03_18.jpg" /></div><p>You can see the following things in the screenshot:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>At the top of the <span class="strong"><strong>Inspector</strong></span> window, we have the same indicators of which states we are transitioning between that we had in the stateâ€”the name of the state the transition starts in, followed by an arrow, and finally the name of the state the transition ends in.</p></li><li style="list-style-type: disc"><p>Underneath<a id="id224" class="indexterm"></a> the familiar <span class="strong"><strong>Transitions</strong></span> list, there is a text field where we can give our transitions specific names. This is useful if we have several different types of transitions between the same two states.</p></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Has Exit Time</strong></span> checkbox dictates whether the transition will wait until the animation is close to its end before changing to the next animation. This is good for things like smoothly transitioning between walk and idle animations.</p></li><li style="list-style-type: disc"><p>The first value in <span class="strong"><strong>Exit Time</strong></span> under <span class="strong"><strong>Settings</strong></span> sets when the transition would start. This is only relevant when the checkbox above it is checked. It should have a value from zero to start the animation, and to one to end the animation.</p></li><li style="list-style-type: disc"><p>The<span class="strong"><strong> Transition Duration</strong></span> setting defines how long the transition will take. It again takes a value between zero and one.</p></li><li style="list-style-type: disc"><p>The<span class="strong"><strong> Transition Offset</strong></span> setting defines where in the target animation the transition will begin.</p></li><li style="list-style-type: disc"><p>The<span class="strong"><strong> Interruption Source</strong></span> and <span class="strong"><strong>Ordered Interruption</strong></span> options determine whether another transition can occur while it is in the process of going through this one. They also set which set of transitions will have precedence and in which order they will be processed.</p></li><li style="list-style-type: disc"><p>Next is a timeline block that lets us preview the transition between animations. By dragging the little flag left and right, we can watch the transition in the <span class="strong"><strong>Preview</strong></span> window. The top half of this block holds waveforms that indicate the movement contained in an animation. The bottom half shows the states as boxes that overlap where the transition actually occurs. Either one of these boxes can be dragged to change the length of the transition.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip08"></a>Tip</h3><p>Since our two idle animations are of negligible length, this normally can't easily be seen in our setup. If you create a temporary transition between the <code class="literal">extend</code> and <code class="literal">retract</code> states, it would be visible.</p></div></li><li style="list-style-type: disc"><p>Lastly, we have a <span class="strong"><strong>Conditions</strong></span> list. Using the parameters that we set up, we can create any number of conditions here that must be met before this transition can take place.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note07"></a>Note</h3><p>There is another <span class="strong"><strong>Preview</strong></span> window at the bottom of the <span class="strong"><strong>Inspector</strong></span> panel. It functions just like the one for the <span class="strong"><strong>Animation Import Settings</strong></span> page, but this one plays the transition between the two relevant animations.</p></div></li><li><p>Select the <a id="id225" class="indexterm"></a>transition between the <code class="literal">Idle_Retract</code> state and the <code class="literal">Extend</code> state. We want the targets to randomly pop up. This will be controlled by a script that will change the time parameter.</p></li><li><p>Click on the <span class="strong"><strong>+</strong></span> under the <span class="strong"><strong>Conditions</strong></span> list to add a new condition. Then, click on the arrow in the middle of the condition to select <span class="strong"><strong>time</strong></span> from the list of parameters.</p></li><li><p>In order to turn a <span class="strong"><strong>Float</strong></span> value into a conditional statement, we need to compare it with another value. That is why we got a new drop-down button with comparison options when we selected the parameter. A <span class="strong"><strong>Float</strong></span> value will be either greater than or less than the value on the right. Our time will be counting down, so select <span class="strong"><strong>Less</strong></span> from the list and leave the value as zero.</p></li><li><p>Add a condition so that the transition between the <code class="literal">Idle_Extend</code> and <code class="literal">Retract</code> states will be the same.</p></li><li><p>For the transition between the <code class="literal">Idle_Extend</code> state and the <code class="literal">Hit_Front</code> state, we will use both the <span class="strong"><strong>Bool</strong></span> parameters that were created. Select the transition and click on the <span class="strong"><strong>+</strong></span> button under <span class="strong"><strong>Conditions</strong></span> until you have two conditions.</p></li><li><p>For the first condition, select <span class="strong"><strong>wasHit</strong></span>, and select <span class="strong"><strong>inTheFront</strong></span> for the second condition. A <span class="strong"><strong>Bool</strong></span> parameter is either <code class="literal">true</code> or <code class="literal">false</code>. In the case of transitions, it needs to know which of the values it is waiting for. For this transition, both should be left as <span class="strong"><strong>true</strong></span>.</p></li><li><p>Next, set up the conditions for the transition between <code class="literal">Idle_Extend</code> and <code class="literal">Hit_Back</code>, just as you did for the previous transition. The only difference is that <code class="literal">false</code> needs to be selected from the drop-down list next to the <span class="strong"><strong>inTheFront</strong></span> conditional.</p></li></ol></div><p>Here, we created a state machine that will be used by our targets. By linking each state to an animation and connecting all of them with transitions, the target will be able to switch between animations. This transitioning is controlled by adding conditionals and parameters.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec37"></a>Scripting the target</h4></div></div></div><p>We only <a id="id226" class="indexterm"></a>need one more piece before we can finish putting the target togetherâ€”a script:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Create a new script in our <code class="literal">Scripts</code> folder and name it <code class="literal">Target</code>.</p></li><li><p>First, in order to interact with our state machine, we need a reference to the <code class="literal">Animator</code> component. It is the component that you removed from the tank and the city. The <code class="literal">Animator</code> component is what ties all of the pieces of the animation together:</p><div class="informalexample"><pre class="programlisting">public Animator animator;</pre></div></li><li><p>This is followed by two float values that will dictate the range of time, in seconds, during which our targets will sit in their idle states:</p><div class="informalexample"><pre class="programlisting">public float maxIdleTime = 10f;
public float minIdleTime = 3f;</pre></div></li><li><p>Next, we have three values that will hold the ID numbers of the parameters that we need to change. It is technically possible to just use the names of the parameters to set them, but using the ID number is much faster:</p><div class="informalexample"><pre class="programlisting">private int timeId = -1;
private int wasHitId = -1;
private int inTheFrontId = -1;</pre></div></li><li><p>The last two variables will hold the ID numbers of the two idle states. We need these for checking which state we are in. All of the IDs are initially set to <code class="literal">-1</code> as a dummy value; we set them to their actual values with the function in the next step:</p><div class="informalexample"><pre class="programlisting">private int idleRetractId = -1;
private int idleExtendId = -1;</pre></div></li><li><p>The <code class="literal">Awake</code> function is a special function in Unity that is called on every script at the beginning of the game. Its purpose is initialization before the game gets underway, and it is perfect for initially setting our ID values.</p><div class="informalexample"><pre class="programlisting">public void Awake() {</pre></div></li><li><p>For each ID, we make a call to the <code class="literal">Animator.StringToHash</code> function. This function calculates the ID number of the parameter or state whose name we give it. The state names also needs to be prefixed with <code class="literal">Base Layer</code>. This is because Unity wants us to be specific when it is possible to have several different layers with states that are named the same. It is also very important that the name here exactly matches the name in the <span class="strong"><strong>Animator</strong></span> window. If it does not, IDs will not match, errors will occur, and the script will not function correctly.</p><div class="informalexample"><pre class="programlisting">  timeId = Animator.StringToHash("time");
  wasHitId = Animator.StringToHash("wasHit");
  inTheFrontId = Animator.StringToHash("inTheFront");
  idleRetractId = Animator.StringToHash("Base Layer.Idle_Retract");
  idleExtendId = Animator.StringToHash("Base Layer.Idle_Extend");
}</pre></div></li><li><p>To make<a id="id227" class="indexterm"></a> use of all of these IDs, we turn to our very good friendâ€”the <code class="literal">Update</code> function. At the beginning of the function, we use the <code class="literal">GetCurrentAnimatorStateInfo</code> function to figure out which state is the current one. We send a zero to this function because it wants to know the index of the layer we are inquiring about, of which we only have one. The function returns an object with the information about the current state, and we grab the <code class="literal">nameHash</code> value (also known as the ID value) of this state right away and set our variable to it.</p><div class="informalexample"><pre class="programlisting">public void Update() {
  int currentStateId = animator.GetCurrentAnimatorStateInfo(0).nameHash;</pre></div></li><li><p>The next line of code is a comparison with our idle state IDs to figure out whether we are in one of those states. If we are, we call upon the <code class="literal">SubtractTime</code> function (which we will write in a moment) to reduce the time parameter.</p><div class="informalexample"><pre class="programlisting">if(currentStateId == idleRetractId || currentStateId == idleExtendId) {
  SubtractTime();
}</pre></div></li><li><p>If the target is not currently in one of its idle states, we start by checking to see whether we were hit. If so, the hit is cleared using the <code class="literal">ClearHit</code> function and the time parameter is reset using the <code class="literal">ResetTime</code> function. We will write both these functions in a moment. Finally, we check to see whether our timer has dropped below zero. If it has, we again reset the timer.</p><div class="informalexample"><pre class="programlisting">else {
  if(animator.GetBool(wasHitId)) {
    ClearHit();
    ResetTime();
  }

  if(animator.GetFloat(timeId) &lt; 0) {
    ResetTime();
  }
}
}</pre></div></li><li><p>In the <code class="literal">SubtractTime</code> function, we use the <code class="literal">GetFloat</code> function of our <code class="literal">Animator</code> component to retrieve the value of a float parameter. By sending our <code class="literal">timeId</code> variable to it, we can receive the current value of the time parameter. Like we did with the tank, we then use <code class="literal">Time.deltaTime</code> to keep pace with our frame rate and subtract time from the timer. Once this is done, we need to <a id="id228" class="indexterm"></a>give the state machine the new value, which is done with the <code class="literal">SetFloat</code> function. We tell it which parameter to change by giving it an ID value, and we tell it what to change by giving it our new time value.</p><div class="informalexample"><pre class="programlisting">public void SubtractTime() {
  float curTime = animator.GetFloat(timeId);
  curTime -= Time.deltaTime;
  animator.SetFloat(timeId, curTime);
}</pre></div></li><li><p>The next function to create is <code class="literal">ClearHit</code>. This function uses <code class="literal">SetBool</code> from the <code class="literal">Animator</code> component to set Boolean parameters. It functions just like the <code class="literal">SetFloat</code> function. We just give it an ID and a value. In this case, we set both of our Boolean parameters to <code class="literal">false</code> so that the state machine no longer thinks that it has been hit.</p><div class="informalexample"><pre class="programlisting">public void ClearHit() {
  animator.SetBool(wasHitId, false);
  animator.SetBool(inTheFrontId, false);
}</pre></div></li><li><p>The last function for the script is <code class="literal">ResetTime</code>. This is another quick function. First, we use the <code class="literal">Random.Range</code> function to get a random value. By passing it a minimum and maximum value, our new random number will be between them. Finally, we use the <code class="literal">SetFloat</code> function to give the state machine the new value.</p><div class="informalexample"><pre class="programlisting">public void ResetTime() {
  float newTime = Random.Range(minIdleTime, maxIdleTime);
  animator.SetFloat(timeId, newTime);
}</pre></div></li></ol></div><p>We have created a script to control the state machine of our target. For comparing states and setting parameters, we gathered and used IDs. For now, do not worry about when the hit states are activated. It will be made clear in the following section when we finally make the tank shoot.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec28"></a>Creating the prefab</h3></div></div></div><p>Now that we have the model, animations, state machine, and script, it is time to create the target and turn it into a prefab. We have all the pieces, so let's put them all together:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>Start by dragging the <span class="strong"><strong>Target</strong></span> model from the <span class="strong"><strong>Project</strong></span> window to the <span class="strong"><strong>Hierarchy</strong></span> window. This creates a new instance of the target object.</p></li><li><p>By <a id="id229" class="indexterm"></a>selecting the new target object, we can see that it already has an <span class="strong"><strong>Animator</strong></span> component attached to it; we just need to add a reference to the <code class="literal">AnimatorController</code> that we created. Do this by dragging <code class="literal">TargetController</code> from the <span class="strong"><strong>Project</strong></span> window and dropping it onto the Animator component's <span class="strong"><strong>Controller</strong></span> field, just like all the other object references that we have set up so far.</p></li><li><p>Also, we need to add the <code class="literal">Target</code> script to the object and connect a reference to the <span class="strong"><strong>Animator</strong></span> component in its relevant field.</p></li><li><p>The last thing to do to the target object is to add a collider to actually receive our cannon shots. Unfortunately, since the <code class="literal">Target</code> object uses bones and a rig to animate, it is not as simple as adding a collider directly to the mesh at which we will be shooting. Instead, we need to create a new empty <code class="literal">GameObject</code>.</p></li><li><p>Rename this to <code class="literal">TargetCollider</code> and make it a child of the target's <code class="literal">Bone_Target</code> bone.</p></li><li><p>Add a <code class="literal">MeshCollider</code> component to the new GameObject.</p></li><li><p>Now, we need to provide this component with some mesh data. Find the <span class="strong"><strong>Target</strong></span> mesh data in the <span class="strong"><strong>Project</strong></span> window, underneath the <span class="strong"><strong>Target</strong></span> model. Drag it to the <span class="strong"><strong>Mesh</strong></span> value of the <code class="literal">MeshCollider</code> component. This causes a green cylinder to appear in the <span class="strong"><strong>Scene</strong></span> view. This is our collision, but it is not yet aligned to the target.</p></li><li><p>Use the <span class="strong"><strong>Transform</strong></span> component to set the <span class="strong"><strong>GameObject</strong></span> position to <code class="literal">4</code> for the <span class="strong"><strong>X</strong></span> value and <code class="literal">0</code> for both <span class="strong"><strong>Y</strong></span> and <span class="strong"><strong>Z</strong></span>. The rotation needs to be changed to <code class="literal">0</code> for <span class="strong"><strong>X</strong></span>, <code class="literal">-90</code> for <span class="strong"><strong>Y</strong></span>, and <code class="literal">90</code> for <span class="strong"><strong>Z</strong></span>.</p></li><li><p>As we made the changes, you probably noticed that the font of everything that was new or changed became bold. This is to indicate that something is different with this prefab instance as compared to the original. Remember, models are essentially prefabs; the problem with them is that we cannot directly make changes, such as adding scripts. To make this target into a new prefab, simply drag it from the <span class="strong"><strong>Hierarchy</strong></span> window and drop it onto the <code class="literal">Prefabs</code> folder in the <span class="strong"><strong>Project</strong></span> window.</p></li><li><p>After this spiffy new prefab is created, populate the city with it.</p></li><li><p>When you placed all of these targets, you probably noticed that they are a little large. Instead of editing each target individually or even all of them as a group, we only have to make a change to the original prefab. Select the <code class="literal">Target</code> prefab in the <span class="strong"><strong>Project</strong></span> window. The <span class="strong"><strong>Inspector</strong></span> window displays the same information for a root prefab object as it does for any other object in the scene. With our prefab selected, half the scale and all of the instances already in the scene will automatically be updated to match. We can also make changes to the min and max idle times and make it affect the whole scene.</p></li></ol></div><p>We just finished<a id="id230" class="indexterm"></a> creating the targets for our tank. By making use of Unity's prefab system, we can also duplicate the target throughout our game and easily make changes that affect them all.</p><p>If you wanted one of the targets to be larger than all of the others, you could change it in the scene. Any changes made to a prefab instance are saved, and they take precedence over changes made to the root prefab object. In addition, when you look at an instance in the <span class="strong"><strong>Inspector</strong></span> window, there will be three new buttons at the top of the window. The <span class="strong"><strong>Select</strong></span> button selects the root prefab object in the <span class="strong"><strong>Project</strong></span> window. The <span class="strong"><strong>Revert</strong></span> button will remove any unique changes made to this instance, whereas the <span class="strong"><strong>Apply</strong></span> button updates the root object with all the changes that were made in this instance.</p><p>Using all that you have learned about animations and state machines, your challenge here is to create a second type of target. Play around with different movements and behaviors. You can perhaps create one that transitions from waving around to standing still.</p></div></div>