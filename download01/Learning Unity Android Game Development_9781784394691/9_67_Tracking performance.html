<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec66"></a>Tracking performance</h2></div></div><hr /></div><p>Unity provides us with many tools<a id="id561" class="indexterm"></a> that allow us to determine how well our game is running. The first tool that we will be covering is readily available for both Unity Pro and Basic users. However, the information is rather limited, though it is still useful. The second tool is only available to Unity Pro users. It provides significantly more detail and information on performance. Finally, we will create our own tool, allowing us to view the performance of our scripts in detail.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec61"></a>Editor statistics</h3></div></div></div><p>In the top-right <a id="id562" class="indexterm"></a>corner of the <span class="strong"><strong>Game</strong></span> window, there is a button labeled <span class="strong"><strong>Stats</strong></span>. Clicking on this button will open a window that will give us information about how the game is running and how long it will take to process. Most of the information in this window concerns how well the game is being rendered, largely amounting to how many objects are currently on the screen, how many are animating, and how much memory they take up. Additionally, there is also some information about the sound in the game and any network traffic that might be occurring. The <span class="strong"><strong>Stats</strong></span> tab is displayed in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_10.jpg" /></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>The <span class="strong"><strong>Audio</strong></span> section <a id="id563" class="indexterm"></a>concerns the various audio clips that are playing in your scene. It contains information about how loud your game is and how much memory is required to process it all. The <span class="strong"><strong>Audio</strong></span> section consists of the following details:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>Level</strong></span>: This is how loud your game is in decibels. It is really just a special form of volume measurement and represents a total for every audio clip that is playing in your game.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>DSP load</strong></span>: This is the cost in processing the digital audio clips in your scene. It is represented as a percentage of the memory used by your game.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Clipping</strong></span>: This is the percentage of your audio files that are simply not played because of the overload on the system. Based on the power of your device's processor, the device can only play a limited number of audio clips at one time. Any extra audio clips are ignored based on the priority setting in the <span class="strong"><strong>Inspector</strong></span> panel of the <span class="strong"><strong>Audio Source</strong></span> component.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Stream load</strong></span>: This is the cost involved in processing any audio that must be streamed as it is being played. It is again a percentage of the memory used.</p></li></ul></div></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Graphics</strong></span> section is concerned with the rendering of your game and the memory required in doing this. It contains information about how fast the game is running, how many objects are being rendered, and how detailed the objects are. Most of the time, when using the <span class="strong"><strong>Stats</strong></span> window, you will be looking at this section. The <span class="strong"><strong>FPS</strong></span> value to the right of this group heading is an excellent estimation of how fast your game is running. This is the number of frames being processed <a id="id564" class="indexterm"></a>in one second, followed by the number of milliseconds it takes to process a single frame of your game. The <span class="strong"><strong>Graphics</strong></span> section consists of the following details:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p><span class="strong"><strong>CPU</strong></span>: This section breaks down into two pieces. The <span class="strong"><strong>main</strong></span> piece is how long it takes to process the code that is used to run your game. The <span class="strong"><strong>render thread</strong></span> piece is how long it takes to draw all the parts of your game on the screen. Together, you can get a good idea of what is taking the most time to run in your game.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Batches</strong></span>: When using <span class="strong"><strong>Static</strong></span> or <span class="strong"><strong>Dynamic Batching</strong></span>, found in the <span class="strong"><strong>Rendering</strong></span> group of <span class="strong"><strong>Player Settings</strong></span>, the first number denotes how many groups were created for the batch rendering pass and the <span class="strong"><strong>Saved by batching</strong></span> value is the number of draw calls that were avoided because of the batching process. The more saved means that less work was done to draw your game on the screen.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Tris</strong></span>: Ultimately, every model in 3D graphics is made from a series of triangles. This value is the total number of triangles that are seen and are being rendered by the cameras in your scene. Fewer triangles means that the graphics process has to do less work to draw a model on the screen.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Verts</strong></span>: Most of the information in a model file is concerned with the world position, normal orientation, and texture position of each vertex. This value is the total number of vertexes seen and rendered by the camera. The lower the number of vertexes for each model, the faster it will be calculated for rendering.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Screen</strong></span>: This is the current width and height, in pixels, of the <span class="strong"><strong>Game</strong></span> window. It also displays the amount of memory that is needed for rendering at that size. A smaller size results in less detail for your game, but it also makes the game easier to render.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>SetPass calls</strong></span>: This is essentially the number of times the different parts of a shader need to be called to draw everything in your scene on the screen. It is based more on the number of different materials in your scene than the number of objects.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Shadow casters</strong></span>: This statistic is used when you make use of real-time shadows. Real-time <a id="id565" class="indexterm"></a>shadows are expensive. If possible, they should not be used on mobile devices. However, if you have to have them, minimize the number of objects that cast shadows. Limit it to move objects that are large enough for the user to see the shadow. Small, static objects especially do not need to cast shadows.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Visible skinned meshes</strong></span>: This is the total number of rigged objects that are currently in the view of the camera. Skinned meshes are often going to be your characters and just about anything else that animates. They are more expensive to render than static meshes because of the extra calculations that are needed to make them move and change with animation.</p></li><li style="list-style-type: disc"><p><span class="strong"><strong>Animations</strong></span>: This is simply the total number of animations playing in the scene.</p></li></ul></div></li><li style="list-style-type: disc"><p>The <span class="strong"><strong>Network</strong></span> group of statistics only becomes visible when it is connected to other players in a multiplayer game. The information generally amounts to how many people the game is connected to and how fast those connections are.</p></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec62"></a>The Profiler</h3></div></div></div><p>The<a id="id566" class="indexterm"></a> <span class="strong"><strong>Profiler</strong></span> window, found in Unity's toolbar by navigating to <span class="strong"><strong>Window | Profiler</strong></span>, is a great tool for analyzing how your game is running. It gives us a colorful breakdown of each part of our system and how much work it is doing. The only really unfortunate part of this tool is that it is only available to Unity Pro users. The <span class="strong"><strong>Profiler</strong></span> window is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_11.jpg" /></div><p>By first <a id="id567" class="indexterm"></a>opening the <span class="strong"><strong>Profiler</strong></span> window, we can then play our game in the window and watch the tool give us a fairly detailed breakdown of what is going on. We can click on any point and see detailed information about that frame at the bottom of the window. The information provided is specific to the point, such as <span class="strong"><strong>CPU Usage</strong></span>, <span class="strong"><strong>Rendering</strong></span>, <span class="strong"><strong>Memory</strong></span>, and so on, that you clicked on.</p><p>The <span class="strong"><strong>CPU Usage</strong></span> information is particularly useful when we are trying to find parts of our game that are taking too long to process. Spikes in processing cost stand out pretty easily. By clicking on a spike, we can see the breakdown of what each part of the game played in making that frame expensive. For most of these parts, we can dig down to the exact object or function that is causing the issue. However, we can only get down to the function level. Just because we know where an issue in the code generally is, the <span class="strong"><strong>Profiler</strong></span> window will not tell us exactly which part of that function is causing the issue.</p><p>In order to actually work, the Profiler needs to hook into every part of your game. This introduces a little extra cost in the speed of your game. Therefore, when analyzing the information provided, it is best to consider the relative costs rather than hold each cost as an exact value.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec63"></a>Tracking script performance</h3></div></div></div><p>All of these<a id="id568" class="indexterm"></a> tools that Unity provides are great, but they are not always the right solution. The Unity Basic user<a id="id569" class="indexterm"></a> does not have access to the <span class="strong"><strong>Profiler</strong></span> window. In addition, both <span class="strong"><strong>Profiler</strong></span> and <span class="strong"><strong>Editor Statistics</strong></span> are fairly generalized. We can get a little more detail with the <span class="strong"><strong>Profiler</strong></span>, but<a id="id570" class="indexterm"></a> the information is not always enough without you having to dig through a bunch of menus. In this next part, we will create a special script that is capable of tracking the performance of specific parts of any script. It should definitely become a regular piece of your developer kit. Let's use these steps to create the script in our Monkey Ball game:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>First, we will need a special class that will keep track of our performance statistics. To do this, create a new script and name it <code class="literal">TrackerStat</code>.</p></li><li><p>To begin this script, we need to enable the ability to interact with the various GUI elements. Go to the very top of the script and add this line next to the other lines that begin with <code class="literal">using</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine.UI;</pre></div></li><li><p>Next, we need to change the class definition line. We do not want or need to extend the <code class="literal">MonoBehaviour</code> class. So, find the following line of code:</p><div class="informalexample"><pre class="programlisting">public class TrackerStat : MonoBehaviour {</pre></div><p>And, change it to the following code:</p><div class="informalexample"><pre class="programlisting">public class TrackerStat {</pre></div></li><li><p>This script starts with four variables. The first variable will be used as an ID, allowing us to track multiple scripts at once by supplying different key values. The second variable will keep track of the average amount of time that the tracked bits of code will take. The third variable is just the total number of times the tracked code has been called. The fourth variable is the longest time the code has taken to execute:</p><div class="informalexample"><pre class="programlisting">public string key = "";
public float averageTime = 0;
public int totalCalls = 0;
public float longestCall = 0;</pre></div></li><li><p>Next, we have two more variables. These will do the work of actually tracking how long the script takes to execute. The first variable includes the time when the tracking starts. The second variable is a flag that marks that tracking has started.</p><div class="informalexample"><pre class="programlisting">public float openTime = 0;
public bool isOpen = false;</pre></div></li><li><p>The third and last batch of variables for this script is used to store references to the Text objects that will actually display our stat information:</p><div class="informalexample"><pre class="programlisting">private Text averageLabel;
private Text totalLabel;
private Text longestLabel;</pre></div></li><li><p>The first function for this script is <code class="literal">Open</code>. This function is called when we want to start tracking a bit of code. It first checks to see whether the code is already being tracked. If it is, then it uses <code class="literal">Debug.LogWarning</code> to send a warning to the <span class="strong"><strong>Console</strong></span> <a id="id571" class="indexterm"></a>window. Next, it sets the flag marking that the code is being tracked. Finally, the function tracks the time it was called by using <code class="literal">Time.realtimeSinceStartup</code>, which contains the actual number of seconds since the game started.</p><div class="informalexample"><pre class="programlisting">public void Open() {
  if(isOpen) {
    Debug.LogWarning("Tracking is already open. Key: " + key);
  }

  isOpen = true;
  openTime = Time.realtimeSinceStartup;
}</pre></div></li><li><p>The next <a id="id572" class="indexterm"></a>function, <code class="literal">Close</code>, acts as the opposite of the previous one. It is called when we have reached the end of the code that we want to track. The time when the tracking should stop is passed to it. This is done to minimize excess code from being executed. As with the previous function, it checks to see whether tracking is being done and sends out another warning and exits early if the function is not being tracked. Next, the <code class="literal">isOpen</code> flag is cleared by setting it to <code class="literal">false</code>. Finally, the amount of time since tracking was opened is calculated and the <code class="literal">AddValue</code> function is called.</p><div class="informalexample"><pre class="programlisting">public void Close(float closeTime) {
  if(!isOpen) {
    Debug.LogWarning("Tracking is already closed. Key: " + key);
    return;
  }

  isOpen = false;
  AddValue(closeTime – openTime);
}</pre></div></li><li><p>The <code class="literal">AddValue</code> function is passed <code class="literal">callLength</code>, which is the length of time that the tracked bit of code took. It then uses some calculations to add the value to <code class="literal">averageTime</code>. Next, the function compares the current <code class="literal">longestCall</code> with the new value and updates it, if the new one is greater than the current one. The <a id="id573" class="indexterm"></a>function then increments <code class="literal">totalCalls</code> before finally updating the text on screen with the new values.</p><div class="informalexample"><pre class="programlisting">public void AddValue(float callLength) {
  float totalTime = averageTime * totalCalls;
  averageTime = (totalTime + callLength) / (totalCalls + 1);

  if(longestCall &lt; callLength) {
    longestCall = callLength;
  }

  totalCalls++;

  averageLabel.text = averageTime.ToString();
  totalLabel.text = totalCalls.ToString();
  longestLabel.text = longestCall.ToString();
}</pre></div></li><li><p>The last function<a id="id574" class="indexterm"></a> for our script, <code class="literal">CreateTexts</code>, is called when we first create an instance of this class to track some bit of code. It first calculates the vertical position of the GUI elements. By using the <code class="literal">ScriptTracker.NewLabel</code> function, which we will create in our next script, we can save ourselves some work; it automatically handles the creation and basic setup of the Text objects that are needed to display the stat information. We just need to pass a name to it to use it in the <span class="strong"><strong>Hierarchy</strong></span> window and set the position and size when it gives us the new object.</p><div class="informalexample"><pre class="programlisting">public void CreateTexts(int position) {
  float yPos = -45 – (30 * position);

  Text keyLabel = ScriptTracker.NewLabel(key + ":Key");
  keyLabel.text = key;
  keyLabel.rectTransform.anchoredPosition = new Vector2(75, yPos);
  keyLabel.rectTransform.sizeDelta = new Vector2(150, 30);

  averageLabel = ScriptTracker.NewLabel(key + ":Average");
  averageLabel.rectTransform.anchoredPosition = new Vector2(200, yPos);
  averageLabel.rectTransform.sizeDelta = new Vector2(100, 30);
  
  totalLabel = ScriptTracker.NewLabel(key + ":Total");
  totalLabel.rectTransform.anchoredPosition = new Vector2(200, yPos);
  totalLabel.rectTransform.sizeDelta = new Vector2(100, 30);
  
  longestLabel = ScriptTracker.NewLabel(key + ":Longest");
  longestLabel.rectTransform.anchoredPosition = new Vector2(200, yPos);
  longestLabel.rectTransform.sizeDelta = new Vector2(100, 30);
}</pre></div></li><li><p>Next, we <a id="id575" class="indexterm"></a>need to <a id="id576" class="indexterm"></a>create another new script and name it <code class="literal">ScriptTracker</code>. This script will allow us to do actual performance tracking.</p></li><li><p>Just like we did for the previous script, we need to add a new line at the very top of the script next to the other <code class="literal">using</code> lines so that the script can create and interact with GUI objects:</p><div class="informalexample"><pre class="programlisting">using UnityEngine.UI;</pre></div></li><li><p>This script starts off with a single variable. This variable maintains all of the stats that are currently being tracked. Note the use of <code class="literal">static</code> here; it allows us to easily update the list from anywhere in the game:</p><div class="informalexample"><pre class="programlisting">private static TrackerStat[] stats = new TrackerStat[0];</pre></div></li><li><p>The first function for this script, <code class="literal">Open</code>, allows us to start tracking the code's execution. It uses the <code class="literal">static</code> flag, so the function can be called easily by any script. A <code class="literal">key</code> value is passed to the function, allowing us to group track calls. The function starts by creating a variable to hold the index of the stat to start tracking. Next, it loops through the current set of stats to find a matching <code class="literal">key</code> value. If one is found, the <code class="literal">index</code> variable is updated with the value and the loop is exited.</p><div class="informalexample"><pre class="programlisting">public static void Open(string key) {
  int index = -1;

  for(int i=0;i&lt;stats.Length;i++) {
    if(stats[i].key == key) {
      index = I;
      break;
    }
  }</pre></div></li><li><p>The <code class="literal">Open</code> function continues by checking whether a stat was found. The <code class="literal">index</code> variable will be less than zero only if we make it through the whole loop of current stats and are unable to find a matching <code class="literal">key</code>. If one is not found, we first check to see whether the list of stats is empty and if it is empty, we create some display labels by calling the <code class="literal">CreateLabels</code> function. We then call <code class="literal">AddNewStat</code> to<a id="id577" class="indexterm"></a> set up the new stat for tracking. We will create both of these functions shortly. The <code class="literal">index</code> is then set to that of the new stat. Finally, the stat is triggered to start tracking by using the stat's <code class="literal">Open</code> function.</p><div class="informalexample"><pre class="programlisting">  if(index &lt; 0) {
    if(stats.Length &lt;= 0) {
      CreateLabels();
    }

    AddNewStat(key);
    index = stats.Length – 1;
  }

  stats[index].Open();
}</pre></div></li><li><p>The <code class="literal">AddNewStat</code> function is<a id="id578" class="indexterm"></a> passed the key of the stat that is to be created. It starts by storing the list of stats in a temporary variable and increasing the size of the stats list by one. Each value is then transferred from the temp list to the larger stats list. Finally, a new stat is created, and it is assigned to the last slot in the stats list. Then, the <code class="literal">key</code> is set and its <code class="literal">CreateTexts</code> function is called so that it can display on screen.</p><div class="informalexample"><pre class="programlisting">private static void AddNewStat(string key) {
  TrackerStatp[] temp = stats;
  stats = new TrackerStat[temp.Length + 1];

  for(int i=0;i&lt;temp.Length;i++) {
    stats[i] = temp[i];
  }

  stats[stats.Length – 1] = new TrackerStat();
  stats[stats.Length – 1].key = key;
  stats[stats.Length – 1].CreateTexts(stats.Length – 1);
}</pre></div></li><li><p>Next, we have the <code class="literal">Close</code> function. This function is passed the key value of the stat to be closed. It starts by finding the time when the function was called, minimizing the amount of excess code that will be tracked. It continues by looping through the list of stats to find a matching <code class="literal">key</code>. If one is found, the stat's <code class="literal">Close</code> function is called and the function is exited. If a match is not found, <code class="literal">Debug.LogError</code> is called to send an error message to the <span class="strong"><strong>Console</strong></span> window.</p><div class="informalexample"><pre class="programlisting">public static void Close(string key) {
  float closeTime = Time.realtimeSinceStartup;

  for(int i=0;i&lt;stats.Length;i++) {
    if(stats[i].key = key) {
      stats[i].Close(closeTime);
      return;
    }
  }

  Debug.LogError("Tracking stat not found. Key: " + key);
}</pre></div></li><li><p>The <code class="literal">CreateLabels</code> function handles the creation of text labels on the screen, so we can easily tell <a id="id579" class="indexterm"></a>what each bit of displayed information <a id="id580" class="indexterm"></a>means. Just like our previous script, it uses the <code class="literal">NewLabel</code> function to handle the basic creation of the text objects, passing it a name to be displayed in the <span class="strong"><strong>Hierarchy</strong></span> window. It then sets the text to be displayed on the screen, positions it along the top-left corner of the screen, and sets its size.</p><div class="informalexample"><pre class="programlisting">private static void CreateLabels() {
  Text keyLabel = NewLabel("TrackerLabel:Key");
  keyLabel.text = "Key";
  keyLabel.rectTransform.anchoredPosition = new Vector2(75, -15);
  keyLabel.rectTransform.sizeDelta = new Vector2(150, 30);

  Text averageLabel = NewLabel("TrackerLabel:Average");
  averageLabel.text = "Average";
  averageLabel.rectTransform.anchoredPosition = new Vector2(200, -15);
  averageLabel.rectTransform.sizeDelta = new Vector2(100, 30);

  Text totalLabel = NewLabel("TrackerLabel:Total");
  totalLabel.text = "Total";
  totalLabel.rectTransform.anchoredPosition = new Vector2(275, -15);
  totalLabel.rectTransform.sizeDelta = new Vector2(50, 30);

  Text longestLabel = NewLabel("TrackerLabel:Longest");
  longestLabel.text = "Longest";
  longestLabel.rectTransform.anchoredPosition = new Vector2(350, -15);
  longestLabel.rectTransform.sizeDelta = new Vector2(100, 30);
}</pre></div></li><li><p>The last static function for this script is the <code class="literal">NewLabel</code> function. It handles the basic creation of each text object that we are using in the rest of the script. It first tries to find the canvas object and creates a new one if it can't be found. To use our text objects, we need the canvas so that they can actually be drawn.</p><div class="informalexample"><pre class="programlisting">public static Text NewLabel(string labelName) {
  Canvas canvas = GameObject.FindObjectOfType&lt;Canvas&gt;();
  if(canvas == null) {
    GameObject go = new GameObject("Canvas");
    go.AddComponent&lt;RectTransform&gt;();
    canvas = go.AddComponent&lt;Canvas&gt;();
  }</pre></div></li><li><p>Next, the <code class="literal">NewLabel</code> function<a id="id581" class="indexterm"></a> creates a new <span class="strong"><strong>GameObject</strong></span> by using the name that was passed to it and making it a child of the <a id="id582" class="indexterm"></a>canvas. It then adds the <code class="literal">RectTransform</code> component so that it can position itself in 2D space and anchors it to the top-left corner. The text object is then given a <code class="literal">CanvasRenderer</code> component so that it can actually draw on the screen and a <code class="literal">Text</code> component so it is actually a text object. We then use the <code class="literal">Resources.GetBuiltinResource</code> function to grab Unity's default <code class="literal">Arial</code> font for the text object before returning it to the caller of the function.</p><div class="informalexample"><pre class="programlisting">GameObject label = new GameObject(labelName);
label.transform.parent = canvas.transform;

RectTransform labelTrans = label.AddComponent&lt;RectTransform&gt;();
labelTrans.anchorMin = Vector2.up;
labelTrans.anchorMax = Vector2.up;

label.AddComponent&lt;CanvasRenderer&gt;();
Text textComp = label.AddComponent&lt;Text&gt;();
textComp.font = Resources.GetBuiltinResource(typeof(Font), "Arial.ttf") as Font;
return textComp;
}</pre></div></li><li><p>To test these scripts, open your <code class="literal">BananaBounce</code> script. At the beginning of the <code class="literal">Update</code> function, add the following line to start tracking how long it takes to run:</p><div class="informalexample"><pre class="programlisting">ScriptTracker.Open("BananaBounce Update");</pre></div></li><li><p>At the <a id="id583" class="indexterm"></a>end of the <code class="literal">Update</code> function, we need to call the <code class="literal">Close</code> function with the same key:</p><div class="informalexample"><pre class="programlisting">ScriptTracker.Close("BananaBounce Update");</pre></div></li><li><p>Finally, start the game and take a look at the results (shown in the following screenshot):</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_09_12.jpg" /></div></li></ol></div><p>We created a tool for<a id="id584" class="indexterm"></a> testing specific parts of code. By wrapping any bit of code in calls to the functions and sending a unique ID, we can determine how long it takes to execute the code. By averaging out the calls to the script and wrapping different parts of code, we can determine exactly which parts of a script are taking the longest time to complete. We can also find out whether the parts of code have been called too many times. Both cases are ideal points to look at for minimizing processing and lag.</p><p>Be sure to remove any references to this tool before you deploy your game. If it is left in the final levels, it can add an unnecessary amount of load on the CPU. This adverse effect on the game could make the game unplayable. Always remember to clear out any uses of tools that are exclusively for Editor debugging.</p></div></div>