<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec53"></a>2D games in a 3D world</h2></div></div><hr /></div><p>Perhaps the<a id="id387" class="indexterm"></a> most little-known thing when developing games is the fact that it's possible to create 2D-style games in a 3D game engine, such as Unity. As with everything else, it comes with its own set of advantages and disadvantages, but the choice can be well worth it for generating a pleasing game experience. The foremost advantage is that you can use 3D assets for the game. This allows dynamic lighting and shadows to be easily included. However, when using a 2D engine, any shadow will need to be painted directly into the assets and you will be hard-pressed to make it dynamic. On the side of disadvantages is the use of 2D assets in the 3D world. It is possible to use them, but large file sizes become necessary to achieve the desired detail and<a id="id388" class="indexterm"></a> to keep it from appearing pixelated. Most 2D engines, however, make use of vector art that will keep the image's lines smooth as it is scaled up and down. Also, one is able to use normal animations for the 3D assets, but frame-by-frame animation is generally required for any 2D asset. Altogether, the advantages have outweighed the disadvantages for many developers, creating a large selection of great looking 2D games that you may never realize were actually made in a 3D game engine.</p><p>To address the growing demand from developers for 2D game support, the Unity team has been additionally been working long and hard on creating an optimized 2D pipeline for the 3D engine. When creating your project, you have the option to select 2D defaults, optimizing assets for use in a 2D game. While there is still no direct vector graphics support from Unity, many other features have been optimized to work better in a 2D world. One of the biggest features is the 2D optimization of the physics engine, which we will be focusing on in this chapter. All the principles that we will use will transfer over to 3D physics, which will save some trouble when setting up and working with it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec40"></a>Setting up the development environment</h3></div></div></div><p>To explore<a id="id389" class="indexterm"></a> making a 2D game in a primarily 3D engine, and the use of physics, we will be recreating a highly popular 2D game, Angry Birds. However, before we can dive into the meat of the game, we need to set up our development environment so that we are optimized for 2D game creation. Let's use these steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><p>To begin with, we need to create a new project in Unity. Naming it <code class="literal">Ch7_AngryBirds</code> will work well. We also need to select <span class="strong"><strong>2D</strong></span> under <span class="strong"><strong>Templates</strong></span>, so all the defaults are set for our 2D game.</p></li><li><p>We also need to be sure to change the target platform in the <span class="strong"><strong>Build Settings</strong></span> field to <span class="strong"><strong>Android</strong></span> and set <span class="strong"><strong>Bundle Identifier</strong></span> to an appropriate value. We don't want to have to worry about this later.</p></li><li><p>There are a few differences that you will notice right away. First, you can only pan from side to side and up and down when moving around in the scene. This is a setting that can be toggled in the top-middle of the <span class="strong"><strong>Scene</strong></span> view, by clicking on the little <span class="strong"><strong>2D</strong></span> button. Also, if you select the camera in the <span class="strong"><strong>Hierarchy</strong></span> window, you can see that it simply appears as a white box in the <span class="strong"><strong>Scene</strong></span> view. This is because it has been defaulted to use the <span class="strong"><strong>Orthographic</strong></span> mode for its <span class="strong"><strong>Projection</strong></span> setting, which you can see in the <span class="strong"><strong>Inspector</strong></span> panel.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>Every camera has two options for how to render the game. A perspective renders everything by utilizing their distance from the camera, imitating the real world; objects that are farther away from the camera are drawn smaller than objects that are closer. An orthographic camera renders everything without this consideration; objects are not scaled based on their distance from the camera.</p></div></li><li><p>Next, we are going to need a ground. So, go to the menu bar of Unity and navigate to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Cube</strong></span>. This will work well as a simple ground.</p></li><li><p>To <a id="id390" class="indexterm"></a>make it look a little like a ground, create a green material and apply it to the <span class="strong"><strong>Cube</strong></span> GameObject.</p></li><li><p>The ground cube needs to be large enough to cover the whole of our field of play. To do this, set the cube's <span class="strong"><strong>Scale</strong></span> attribute to <code class="literal">100</code> for the <span class="strong"><strong>X</strong></span> axis, <code class="literal">10</code> for the <span class="strong"><strong>Y</strong></span> axis, and <code class="literal">5</code> for the <span class="strong"><strong>Z</strong></span> axis. Also, set its <span class="strong"><strong>Position</strong></span> attribute to <code class="literal">30</code> for the <span class="strong"><strong>X</strong></span> axis, <code class="literal">-5</code> for the <span class="strong"><strong>Y</strong></span> axis, and <code class="literal">0</code> for the <span class="strong"><strong>Z</strong></span> axis. Since nothing will be moving along the <span class="emphasis"><em>x</em></span> axis, the ground only needs to be large enough for the other objects that will be in our scene to land on. It does, however, need to be wide and tall enough to keep the camera from seeing the edges.</p></li><li><p>To optimize our ground cube for use in our 2D game, we need to change its collider. Select the <span class="strong"><strong>Cube</strong></span> GameObject in the <span class="strong"><strong>Hierarchy</strong></span> window and take a look at it in the <span class="strong"><strong>Inspector</strong></span> panel. Right-click on the <span class="strong"><strong>Box Collider</strong></span> component and select <span class="strong"><strong>Remove Component</strong></span>. Next, at the top of Unity, navigate to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics 2D</strong></span> | <span class="strong"><strong>Box Collider 2D</strong></span>. This component works just like a normal <span class="strong"><strong>Box Collider</strong></span> component, except that it does not have limited depth.</p></li><li><p>Right now, the ground looks rather dark due to the lack of light. From the menu bar of Unity, navigate to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Light</strong></span> | <span class="strong"><strong>Directional Light</strong></span> in order to add some brightness to the scene.</p></li><li><p>Next, we need to keep all the objects that will be flying around the scene from straying too far and causing problems. To do this, we need to create some trigger volumes. The simplest way to do this is to create three empty <span class="strong"><strong>GameObjects</strong></span> and give each a <span class="strong"><strong>Box Collider 2D</strong></span> component. Be sure to check the <span class="strong"><strong>Is Trigger</strong></span> checkbox in order to change them into trigger volumes.</p></li><li><p>Position one at each end of the ground object and the last GameObject at about 50 units above. Then, scale them to form a box with the ground. Each should be no thicker than a single unit.</p></li><li><p>To make the volumes actually keep objects from straying too far, we need to create a new script. Create a new script and name it <code class="literal">GoneTooFar</code>.</p></li><li><p>This script <a id="id391" class="indexterm"></a>has a single, short function, <code class="literal">OnTriggerEnter2D</code>. We use this function to destroy any object that might enter the volume. This function is used by Unity's physics system to detect when an object has entered a trigger volume. We will go into more detail regarding this later, but for now, know that one of the two objects, either the volume or the object entering it, needs a <span class="strong"><strong>Rigidbody</strong></span> component. In our case, everything that we might want to remove when they enter the trigger will have a <span class="strong"><strong>Rigidbody</strong></span> component:</p><div class="informalexample"><pre class="programlisting">public void OnTriggerEnter2D(Collider2D other) {
  Destroy(other.gameObject);
}</pre></div></li><li><p>Finally, return to Unity and add the script to the three trigger-volume objects.</p><div class="mediaobject"><img src="/graphics/9781784394691/graphics/4691OT_07_01.jpg" /></div></li></ol></div><p>We have done the initial setup for our 2D game. By changing the project type from <span class="strong"><strong>3D</strong></span> to <span class="strong"><strong>2D</strong></span>, defaults in Unity are changed to be optimized for 2D game creation. The most immediately noticeable thing is that the camera is now in the <span class="strong"><strong>Orthographic</strong></span> view, making everything appear flattened. We also created a ground and some trigger volumes for our scene. Together, these <a id="id392" class="indexterm"></a>will keep our birds and anything else from straying too far.</p></div></div>