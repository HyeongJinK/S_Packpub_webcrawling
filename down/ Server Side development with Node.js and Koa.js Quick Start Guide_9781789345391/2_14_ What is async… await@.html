<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>What is async… await?</h2></div></div><hr /></div><p>Asynchronous functions are functions that work asynchronously. They return a <code class="literal">Promise</code> class implicitly and can run concurrently. We will be discussing two major ways to <span>define</span><a id="id325748987" class="indexterm"></a> asynchronous functions. These include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Using the native <code class="literal">Promise</code> class</li><li style="list-style-type: disc">Using the modern <code class="literal">Async</code> keyword</li></ul></div><p>The <code class="literal">await</code> keyword is used <span>inside</span><a id="id325022168" class="indexterm"></a> an asynchronous function to resolve a promise. Async and await are usually used together for managing the control of flow in a modern asynchronous JavaScript application. Koa relies heavily on <code class="literal">async.. await</code> to avoid callback hell and provide a more convenient method for handling errors.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec5"></a>The promise class</h3></div></div></div><p>Before introducing <code class="literal">async</code>, let's discuss a little <span>about</span><a id="id325904436" class="indexterm"></a> the native <code class="literal">Promise</code> class in JavaScript. As mentioned, promises are the way modern JavaScript manages asynchronous actions. The standard <code class="literal">Promise</code> class can be used for creating promises. A promise can be defined as seen in the following code snippet:</p><pre class="programlisting">const dataPromise = new Promise((resolve, reject) =&gt; resolve("some important data!"));</pre><p>From the preceding code block, we can see that a function is passed to the <code class="literal">Promise</code> constructor—this function is called an <code class="literal">executor</code> function. This executor has two arguments passed into it, which are used to determine two important properties of the resulting promise—its <code class="literal">state</code> and <code class="literal">result</code> properties.</p><p>The default value of <code class="literal">state</code> is <code class="literal">pending</code>, which then changes to either <code class="literal">fulfilled</code> or <code class="literal">rejected</code>. The default value of <code class="literal">result</code> is <code class="literal">undefined</code>, which then changes to any value of your choosing.</p><p>The two functions an executor receives as arguments are <code class="literal">resolve(value)</code> and <code class="literal">reject(error)</code>. The <code class="literal">resolve(value)</code> function indicates that the promise was successfully completed, and hence it sets the <code class="literal">state</code> of the promise to <code class="literal">fulfilled</code> and assigns <code class="literal">value</code> to its <code class="literal">result</code> property. The reject function indicates that a promise failed (an error occurred) and accordingly sets the <code class="literal">state</code> propertyof the promise to <code class="literal">rejected</code> and assigns  <code class="literal">error</code> to its <code class="literal">result</code> property.</p><p>The result of the promise defined previously can be obtained using its <code class="literal">.then()</code> function, as seen here:</p><pre class="programlisting">dataPromise()
  .then(data =&gt; console.log(`Here is ${data}`));

// Here is some important data!</pre><p>In the case of failures, promises can also be rejected in a like manner. Here's a promise definition that throws an error or rejection:</p><pre class="programlisting">const dataPromise = new Promise((resolve, reject) =&gt; reject(new Error('data failure!')));</pre><p>When retrieving results for the <span>previous</span><a id="id325904509" class="indexterm"></a> promise, the error can be handled with the <code class="literal">.catch()</code> function:</p><pre class="programlisting">dataPromise()
  .catch(error =&gt; console.log(`Data retrieval failed. ${error}`));

// Data retrieval failed. Error: data failure!</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec6"></a>Introducing async</h3></div></div></div><p>Another way to create and resolve <span>promises</span><a id="id325904539" class="indexterm"></a> is to use the <code class="literal">async… await</code> syntax. Async is basically syntactical sugar around the <code class="literal">Promise</code> class. The <code class="literal">dataPromise</code> promise we defined earlier with the <code class="literal">Promise</code> class can be defined with <code class="literal">async</code> as follows:</p><pre class="programlisting">async dataPromise() {
  return "some important data!";
}</pre><p>Rejections can also be defined simply by throwing errors within the<code class="literal">async</code>function:</p><pre class="programlisting">async dataPromise() {
  throw new Error('data failure');
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec7"></a>Introducing await</h3></div></div></div><p>The <code class="literal">await</code> keyword helps us manage <span>promises</span><a id="id326106425" class="indexterm"></a> in a more procedural manner. The <code class="literal">await</code> keyword can be only used inside an <code class="literal">async</code> (asynchronous) function to resolve a promise. It helps us resolve promises just like the <code class="literal">.then()</code> function we saw earlier. <code class="literal">Async... await</code> is the cleanest way to control the flow of a modern asynchronous JavaScript application. An example can be seen here:</p><pre class="programlisting">async function getPostCategory() {
  const postId = 123;
  const post = await Post.findById(postId);
  return post.category;
}</pre><p>The preceding code block is essentially the same as the one shown here, using the <code class="literal">.then()</code> function:</p><pre class="programlisting">function getPostCategory() {
  const postId = 123;

  return Post.findById(postId).then(post =&gt; {
    return post.category;
  });
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note5"></a>Note</h3><p><span>Note: The <code class="literal">await</code> keyword can only be used in <code class="literal">async</code> functions.</span></p></div><p>As seen in the preceding code examples, using <code class="literal">async</code> and <code class="literal">await</code>, we are able to clearly follow the flow of data in an asynchronous application. Koa takes advantage of this, hence <span>making</span><a id="id326106666" class="indexterm"></a> middleware definition and error handling much easier.</p></div></div>