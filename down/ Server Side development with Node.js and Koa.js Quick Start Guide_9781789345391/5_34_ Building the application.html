<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec38"></a>Building the application</h2></div></div><hr /></div><p>In this section, we will get right into the code and <span>start</span><a id="id325755185" class="indexterm"></a> to build our application. We will need to follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Starting the server</li><li>Connecting to a database</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Creating data models</li><li>Setting up a router</li><li>Setting up a logger</li><li>Creating contact endpoints and controller actions</li><li>Validating requests</li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec23"></a>Starting the server</h3></div></div></div><p>First, let's start a simple server in our <code class="literal">index.js</code> entry file. In the <span>following</span><a id="id325755145" class="indexterm"></a> code block, we simply require Koa as a dependency, then start a Koa server by using the <code class="literal">app.listen()</code> method:</p><pre class="programlisting">// ./index.js

const Koa = require('koa');
const app = new Koa();

const port = process.env.PORT || 3000;
app.listen(port, () =&gt;
  console.log(`Server running on http://localhost:${port}`)
);</pre><p>The server either runs on a specified port with the <code class="literal">PORT</code> environmental variable, or on the default <code class="literal">3000</code> port.</p><p>To start our application, you can run the following command from the project root:</p><pre class="programlisting"><span class="strong"><strong>node index.js</strong></span></pre><p>You should see the following message in your console after running this: <code class="literal">Server running on http://localhost:3000</code>.</p><p>To start the application on a different port, you can <span>specify</span><a id="id325749006" class="indexterm"></a> the following <code class="literal">PORT</code> environment variable when starting the application:</p><pre class="programlisting"><span class="strong"><strong>PORT=1234 node index.js</strong></span></pre><p>Running this will produce the following message: <code class="literal">Server running on http://localhost:1234</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec2"></a>Using Nodemon</h4></div></div></div><p>Nodemon is a command-line tool that helps with the speedy development of Node.js applications. It monitors your project directory and automatically restarts your node application when it detects any changes.</p><p>This means that you do not have to stop and restart your applications in order for your changes to take effect. You can simply write code, and test your application a few seconds later.</p><p>To install <code class="literal">nodemon</code> locally, we can run the following in the Terminal::</p><pre class="programlisting"><span class="strong"><strong>npm install -g nodemon</strong></span></pre><p><span>Nodemon serves as a replacement for node</span>, and does not require any code changes within your application. Once it has installed, we can start our application with auto-restart, using the following command:</p><pre class="programlisting"><span class="strong"><strong>nodemon index.js</strong></span></pre><p>You can also try to run the following command:</p><pre class="programlisting"><span class="strong"><strong>PORT=1234 nodemon index.js</strong></span></pre><p>Now, after making a change to any file in your project directory, <code class="literal">nodemon</code> will automatically restart your server, and you will get to see the changes in effect.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec24"></a>Connecting to a database</h3></div></div></div><p>MongoDB, the NoSQL database, which is <span>popular</span><a id="id325902571" class="indexterm"></a> for being a part of the <span class="strong"><strong>MEAN stack</strong></span> (<span class="strong"><strong>MongoDB, Express, Angular, and Node.js</strong></span>), will be used to persist all of our contact data into our API. Its ability to easily save JSON objects without needing a strict schema setup is great for our purposes.</p><p>We will be making use of Mongoose, a popular ODM library, for all of our database interactions. Mongoose manages our interactions with the database, does object schema validation, and also maps objects in our code into their corresponding MongoDB document representations.</p><p>Let's update our <code class="literal">index.js</code> file, in order to allow our app to connect to the database with Mongoose, as follows:</p><pre class="programlisting">// ./index.js
// ...

const mongoose = require('mongoose');
mongoose.connect(
  'mongodb://localhost:27017/koa-contact',
  { useNewUrlParser: true }
);

const db = mongoose.connection;
db.on('error', error =&gt; {
  throw new Error(`error connecting to db: ${error}`);
});
db.once('open', () =&gt; console.log('database connected'));

// ...</pre><p>In the preceding code block, first, we require the <code class="literal"><span>mongoose</span></code> dependency as the <code class="literal">mongoose</code> object. Then, we use the <code class="literal">mongoose.connect()</code> method to connect our Mongo database. The <code class="literal">connect</code> method takes the MongoDB connection URL as its first argument, then an object with connection options as its second. The only option that we specify is for <code class="literal">mongoose</code> to use the new URL parser for the mongo connection string.</p><p><span>Next, we define listeners to alert us when there's an error connecting to the DB, and once the database is successfully connected to</span>.</p><p>At this point, the complete <code class="literal">index.js</code> file <span>should</span><a id="id326093333" class="indexterm"></a> look as follows:</p><pre class="programlisting">// ./index.js

// require needed dependencies
const Koa = require('koa');
const app = new Koa();

// connect to mongodb with mongoose
const mongoose = require('mongoose');
mongoose.connect(
  'mongodb://localhost:27017/koa-contact',
  { useNewUrlParser: true }
);

// listen for successful connection, or error
const db = mongoose.connection;
db.on('error', error =&gt; {
  throw new Error(`error connecting to db: ${error}`);
});
db.once('open', () =&gt; console.log('database connected'));

// start server
const port = process.env.PORT || 3000;
app.listen(port, () =&gt;
  console.log(`Server running on http://localhost:${port}`)
);</pre><p>Running this, you <span>should</span><a id="id326344436" class="indexterm"></a> see a <code class="literal">database connected</code> message on your console or Terminal, right after the server starts.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec25"></a>Creating data models</h3></div></div></div><p>To communicate with our database, we need to <span>define</span><a id="id326344456" class="indexterm"></a> a data model for the contacts. Mongoose models serve as wrappers around schema definitions. A Mongoose schema defines the object structure, constraints, default values, and so on. <span>Models are responsible for CRUD operations for an object with the underlying database</span>.</p><p>To create a simple data model, let's create a <code class="literal">Contact.js</code> file in the <code class="literal">models</code> folder, and insert the following code into it:</p><pre class="programlisting">// ./models/Contact.js

const Koa = require('koa');
const app = new Koa();

const mongoose = require('mongoose');
mongoose.connect(
  'mongodb://localhost:27017/koa-contact',
  { useNewUrlParser: true }
);

const db = mongoose.connection;
db.on('error', error =&gt; {
  throw new Error(`error connecting to db: ${error}`);
});
db.once('open', () =&gt; console.log('database connected'));

const port = process.env.PORT || 3000;
app.listen(port, () =&gt;
  console.log(`Server running on http://localhost:${port}`)
);</pre><p>In the preceding code block, first, we require the <code class="literal">mongoose</code> dependency. The <code class="literal">mongoose</code> reference that is created here will be the same as the one that was returned when we initially connected to the database. This means that we do not need to create any other connections for interacting with our database.</p><p>Next, we <span>define</span><a id="id326344494" class="indexterm"></a> our schema by using the <code class="literal">mongoose.Schema</code> object. Our contact object will have the following properties:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">name</code>: The name of a contact. This should be a string. This is a required value, and the schema validation will fail if a contact object without a name is persisted to the database.</li><li style="list-style-type: disc"><code class="literal">company</code>: The company that a contact works at. This should be a string value.</li><li style="list-style-type: disc"><code class="literal">position</code>: The position that a contact holds at a company. Also a string value.</li><li style="list-style-type: disc"><code class="literal">address</code>: The contact's address. Also a string value.</li><li style="list-style-type: disc"><code class="literal">phoneNumber</code>: The contact's phone number. This is also specified as a string value, to cater to special characters, such as a country code or parentheses.</li><li style="list-style-type: disc"><code class="literal">createdAt</code>: The date that the document was created. This can be saved as a JavaScript date object. The default value is the current date.</li><li style="list-style-type: disc"><code class="literal">updatedAt</code>: The date that the document was most recently updated. This can be saved as a JavaScript date object. The default value is the current date.</li></ul></div><p>Finally, we will create the mongoose model and export it, so that it can be used elsewhere in our application.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec26"></a>Setting up the router</h3></div></div></div><p>In order to be able to visit <span>different</span><a id="id325903308" class="indexterm"></a> endpoints, we need to set up some form of a router, to route different URL oath visits to different actions. Koa does not come bundled with an out-of-the-box router like Express does; hence, we will be making use of <code class="literal">koa-router</code>, which is an open source RESTful router for use with Koa.</p><p>Let's start off by creating a <code class="literal">router.js</code> file in the <code class="literal">middleware</code> folder, and inserting the following contents:</p><pre class="programlisting">// ./middleware/router.js

const KoaRouter = require('koa-router');
const router = new KoaRouter();

router
  .get('/', async ctx =&gt; (ctx.body = 'Welcome to the contacts API!'));

module.exports = router;</pre><p>In the preceding code block, we require the <code class="literal">koa-router</code> dependency, and we initialize it. After that, we register an index route, which sends the <code class="literal">Welcome to the contacts API!</code> text response. Then, we export it to be registered as a middleware in our index file.</p><p>To define a route, we call the HTTP verb method of the router, which takes the route path as the first parameter, and a callback function as the second. For example, for a GET route, we use <code class="literal">router.get()</code>; for a POST route, we use <code class="literal">router.post()</code>; and so on.</p><p>Update the <code class="literal">index.js</code> file, as follows:</p><pre class="programlisting">// ./index.js

// ...
const router = require('./middleware/router');

// router
app.use(router.routes());
app.use(router.allowedMethods());

// ...</pre><p>After requiring the router middleware, we register it with the <code class="literal">router.routes()</code> and <code class="literal">router.allowedMethods()</code> methods. The <code class="literal">.routes()</code> method registers the routes that we define via the router, and the <code class="literal">.allowedMethods()</code> method returns a separate middleware for responding to the <code class="literal">OPTIONS</code> requests, with the <code class="literal">Allow</code> header <span>containing</span><a id="id325948950" class="indexterm"></a> the allowed methods.</p><p>Our complete <code class="literal">index.js</code> file will now look as follows:</p><pre class="programlisting">const Koa = require('koa');
const router = require('./middleware/router');
const app = new Koa();

const mongoose = require('mongoose');
mongoose.connect(
  'mongodb://localhost:27017/koa-contact',
  { useNewUrlParser: true }
);

const db = mongoose.connection;
db.on('error', error =&gt; {
  throw new Error(`error connecting to db: ${error}`);
});
db.once('open', () =&gt; console.log('database connected'));

// router
app.use(router.routes());
app.use(router.allowedMethods());

const port = process.env.PORT || 3000;
app.listen(port, () =&gt;
  console.log(`Server running on http://localhost:${port}`)
);</pre><p>With the router middleware and the routes registered, we can test the <code class="literal">GET /</code> route with Postman or a browser; we should see the <strong class="userinput"><code>Welcome to the contacts API!</code></strong> response, as <span>shown</span><a id="id326018644" class="indexterm"></a> in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789345391/graphics/577fa535-c971-4840-8228-1ede6a1d91bd.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec27"></a>Setting up a logger</h3></div></div></div><p>Sometimes, we need a logger to help with <span>debugging</span><a id="id326018667" class="indexterm"></a> during development. In this section, we will implement a simple Koa console logger, in order to log our requests to the console or Terminal.</p><p>It is recommended that the logger middleware be registered close to the top of the middleware stack, so that it can wrap all subsequent middleware.</p><p>To register the <code class="literal">koa-logger</code> middleware, refer to the following code block:</p><pre class="programlisting">// ./index.js

// ...
const logger = require('koa-logger');

app.use(logger());

// ...</pre><p>We can configure the logger with a custom transporter, as seen in the <code class="literal">koa-logger</code> documentation (<a class="ulink" href="https://github.com/koajs/logger" target="_blank">https://github.com/koajs/logger</a>).</p><p>Now, the <code class="literal">index.js</code> file, with the logger implemented, will look as follows:</p><pre class="programlisting">// ./index.js

const Koa = require('koa');
const router = require('./middleware/router');
const app = new Koa();

const logger = require('koa-logger');

// logger
app.use(logger());

const mongoose = require('mongoose');
mongoose.connect(
  'mongodb://localhost:27017/koa-contact',
  { useNewUrlParser: true }
);

const db = mongoose.connection;
db.on('error', error =&gt; {
  throw new Error(`error connecting to db: ${error}`);
});
db.once('open', () =&gt; console.log('database connected'));

// router
app.use(router.routes());
app.use(router.allowedMethods());

const port = process.env.PORT || 3000;
app.listen(port, () =&gt;
  console.log(`Server running on http://localhost:${port}`)
);</pre><p>Now, when we run our app and hit the <code class="literal">GET /</code> endpoint, we will see the logs in the Terminal, showing <span>request</span><a id="id326018748" class="indexterm"></a> and response log data:</p><pre class="programlisting">Server running on http://localhost:3000
database connected
  &lt;-- GET /
  --&gt; GET / 200 11ms</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec28"></a>Creating contact endpoints and controller actions</h3></div></div></div><p>Now that we have our model, our <span>database</span><a id="id326018768" class="indexterm"></a> connection, our router, and a logger setup, we can start to write the business logic for our application. This will <span>mainly</span><a id="id326018777" class="indexterm"></a> consist of different <span>controller</span><a id="id326018786" class="indexterm"></a> actions, to handle CRUD operations for the contacts in our database.</p><p>We will start by creating a <code class="literal">ContactController.js</code> file in the <code class="literal">controllers</code> folder, as follows:</p><pre class="programlisting">touch controllers/ContactController.js</pre><p>Next, we can define the different route actions in our controller.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec3"></a>Retrieving all contacts</h4></div></div></div><p>The <code class="literal">index</code> route will retrieve all of the <span>contacts</span><a id="id326019059" class="indexterm"></a> from the database and send them back to the client in a JSON object. We can use the mongoose <code class="literal">.find()</code> method to retrieve all of the entries of a model from the database.</p><p>Insert the following code into the <code class="literal">ContactController.js</code> file:</p><pre class="programlisting">// ./controllers/ContactController.js

const Contact = require('../models/Contact');

module.exports = {
  async index(ctx) {
    const contacts = await Contact.find();
    ctx.body = {
      status: 'success',
      data: contacts
    };
  }
};</pre><p>Next, we head over to the <code class="literal">./middleware/router.js</code> file, in order to add the corresponding route, as follows:</p><pre class="programlisting">// ./middleware/router.js
// ...
const contactController = require('../controllers/ContactController');

router
  .get('/', async ctx =&gt; (ctx.body = 'Welcome to the contacts API!'))
  .get('/contact', contactController.index);

//...</pre><p>Calling the <code class="literal">GET /contact</code> endpoint should send a JSON object with a <code class="literal">success</code> status and an empty array as the data property. The data property, which is meant to hold a list of contacts, is empty, as we have not yet inserted any records into the database. An example response object can be seen as follows:</p><pre class="programlisting">{
    "status": "success",
    "data": []
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec4"></a>Storing new contacts</h4></div></div></div><p>The <code class="literal">store</code> route will create new <span>contact</span><a id="id326109875" class="indexterm"></a> documents and save them to the database. It will send the created contacts back as a JSON response.</p><p>The <code class="literal">store</code> action will receive the JSON request body as data to use for creating the contact document. In order to be able to read the request body properly, we need to register <code class="literal">koa-body</code>, a body parser middleware for Koa.</p><p>According to its documentation, <code class="literal">koa-body</code> is the <span>following:</span></p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A full-featured Koa body parser middleware. Supports multipart, <code class="literal">urlencoded</code> and <code class="literal">json</code> request bodies. Provides same functionality as Express's bodyParser - <code class="literal">multer</code>. And all that is wrapped only around <code class="literal">co-body</code> and formidable."</em></span></p></blockquote></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip20"></a>Note</h3><p>The <code class="literal">koa-body</code> documentation (<a class="ulink" href="https://github.com/dlau/koa-bod" target="_blank">https://github.com/dlau/koa-bod</a>) shows a lot of example usages and configuration options for implementing the middleware.</p></div><p>To register the <code class="literal">koa-body</code> middleware, we can <span>update</span><a id="id326110212" class="indexterm"></a> our <code class="literal">index.js</code> with the following content:</p><pre class="programlisting">// ./index.js

// ...

const bodyParser = require('koa-body');

app.use(bodyParser());

// ...</pre><p>To add the <code class="literal">store</code> route, we will update the controller actions, as follows:</p><pre class="programlisting">// ./controllers/ContactController.js

// ...

module.exports = {
  // ...

  async store(ctx) {
    const { body } = ctx.request;
    let contact = new Contact(body);
    contact = await contact.save();
    ctx.body = {
      status: 'success',
      data: contact
    };
  }
};</pre><p>Then, we register the corresponding route, as follows:</p><pre class="programlisting">// ./middleware/router.js
// ...

router
  .get('/', async ctx =&gt; (ctx.body = 'Welcome to the contacts API!'))
  .get('/contact', contactController.index)
  .post('/contact', contactController.store);

// ...</pre><p>Now, we can call the <code class="literal">POST /contact</code> endpoint to create a contact with Postman, as seen in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789345391/graphics/97f5d907-9974-4914-acfd-b47951b0a130.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec5"></a>Retrieving a single contact</h4></div></div></div><p>The <code class="literal">show</code> route will retrieve a single <span>contact</span><a id="id326110267" class="indexterm"></a> from the database, via a specified <code class="literal">id</code>, and send it back as a response to the client. We can get the required <code class="literal">id</code> from the route parameter, and easily pass it to the mongoose <code class="literal">.findById()</code> method, in order to retrieve the required contact. We update the controller, as follows:</p><pre class="programlisting">// ./controllers/ContactController.js

// ...

module.exports = {
  // ...

  async show(ctx) {
    const { id } = ctx.params;
    const contact = await Contact.findById(id);
    ctx.body = {
      status: 'success',
      data: contact
    };
  }
};</pre><p>We then add the corresponding route, as follows:</p><pre class="programlisting">// ./middleware/router.js
// ...

router
  .get('/', async ctx =&gt; (ctx.body = 'Welcome to the contacts API!'))
  .get('/contact', contactController.index)
  .post('/contact', contactController.store)
  .get('/contact/:id', contactController.show);

// ...</pre><p>Making a request to retrieve a contact that we have already saved by calling <code class="literal">GET /contact/{contactId}</code> should return a response similar to the following:</p><pre class="programlisting">{
    "status": "success",
    "data": {
        "_id": "5be8e3028053210ddc1d162b",
        "name": "Test name",
        "address": "Street 5",
        "company": "test company",
        "createdAt": "2018-11-12T02:18:42.377Z",
        "updatedAt": "2018-11-12T02:18:42.377Z",
        "__v": 0
    }
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec6"></a>Updating a contact</h4></div></div></div><p>The <code class="literal">update</code> route will update an existing <span>contact</span><a id="id326112296" class="indexterm"></a> with new details. We can achieve this by getting the required <code class="literal">id</code> as a route parameter, along with the updated content from the request body, then using the mongoose <code class="literal">.findByIdAndUpdate()</code> method to update the specified contact. <span>The route will return the updated contact as a response on a successful update</span>:</p><pre class="programlisting">// ./controllers/ContactController.js

// ...

module.exports = {
  async index(ctx) {
    const contacts = await Contact.find();
    ctx.body = {
      status: 'success',
      data: contacts
    };
  },

  async store(ctx) {
    const { body } = ctx.request;
    let contact = new Contact(body);
    contact = await contact.save();
    ctx.body = {
      status: 'success',
      data: contact
    };
  },

  async show(ctx) {
    const { id } = ctx.params;
    const contact = await Contact.findById(id);
    ctx.body = {
      status: 'success',
      data: contact
    };
  },

  async update(ctx) {
    const { id } = ctx.params;
    const { body } = ctx.request;
    await Contact.findByIdAndUpdate(id, body);
    const contact = await Contact.findById(id);
    ctx.body = {
      status: 'success',
      message: 'contact successfully updated',
      data: contact
    };
  }
};</pre><p>The corresponding router definition is shown as follows:</p><pre class="programlisting">// ./middleware/router.js
// ...

router
  .get('/', async ctx =&gt; (ctx.body = 'Welcome to the contacts API!'))
  .get('/contact', contactController.index)
  .post('/contact', contactController.store)
  .get('/contact/:id', contactController.show)
  .put('/contact/:id', contactController.update);

// ...</pre><p>An example request to <code class="literal">PUT /contact/{contactId}</code> to update a contact is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789345391/graphics/c18e4e83-41a1-479e-9ea1-b483f5fc4ebb.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec7"></a>Deleting a contact</h4></div></div></div><p>The <code class="literal">destroy</code> route will take an <code class="literal">id</code> route parameter and delete the <span>contact</span><a id="id326112561" class="indexterm"></a> with that <code class="literal">id</code> from the database, using the mongoose <code class="literal">.findByAndDelete()</code> method:</p><pre class="programlisting">// ./controllers/ContactController.js

// ...

module.exports = {
  async index(ctx) {
    const contacts = await Contact.find();
    ctx.body = {
      status: 'success',
      data: contacts
    };
  },

  async store(ctx) {
    const { body } = ctx.request;
    let contact = new Contact(body);
    contact = await contact.save();
    ctx.body = {
      status: 'success',
      data: contact
    };
  },

  async show(ctx) {
    const { id } = ctx.params;
    const contact = await Contact.findById(id);
    ctx.body = {
      status: 'success',
      data: contact
    };
  },

  async update(ctx) {
    const { id } = ctx.params;
    const { body } = ctx.request;
    await Contact.findByIdAndUpdate(id, body);
    const contact = await Contact.findById(id);
    ctx.body = {
      status: 'success',
      message: 'contact successfully updated',
      data: contact
    };
  },

  async destroy(ctx) {
    const { id } = ctx.params;
    await Contact.findByIdAndDelete(id);
    ctx.body = {
      status: 'success',
      message: 'contact successfully deleted'
    };
  }
};</pre><p>We add the corresponding router definition, as follows:</p><pre class="programlisting">// ./middleware/router.js
// ...

router
  .get('/', async ctx =&gt; (ctx.body = 'Welcome to the contacts API!'))
  .get('/contact', contactController.index)
  .post('/contact', contactController.store)
  .get('/contact/:id', contactController.show)
  .put('/contact/:id', contactController.update)
  .delete('/contact/:id', contactController.destroy);

// ...</pre><p>Making a request to <code class="literal">DELETE /contact/{contactId}</code> with the specified <code class="literal">id</code> should return a response similar to the following:</p><pre class="programlisting">{
    "status": "success",
    "message": "contact successfully deleted"
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec29"></a>Validating requests</h3></div></div></div><p>A great way to ensure that we always get the data that we need is to validate requests before persisting them to the database. Mongoose already does schema validation, but we can also <span>implement</span><a id="id326113733" class="indexterm"></a> an extra layer of validation, to ensure that we are in full control of our data.</p><p>A popular JSON schema validation library that we can make use of in Node.js is <code class="literal">Joi</code>. <code class="literal">Joi</code> is an object schema validator, and it will work well for ensuring that we have the proper data coming through from our requests.</p><p>We will create a custom middleware for validating requests on selected routes, and register it in our app.</p><p>First, let's create the <code class="literal">middleware</code> function. Creating a <code class="literal">validator.js</code> file in the <code class="literal">middleware</code> folder can be done by using the following command:</p><pre class="programlisting">touch middleware/validator.js</pre><p>Now, we can insert the following content into the file:</p><pre class="programlisting">// ./middleware/validator.js

const Joi = require('joi');

const schema = Joi.object({
 name: Joi.string().required(),
 address: Joi.string(),
 company: Joi.string(),
 position: Joi.string(),
 phoneNumber: Joi.number().required()
});

const ALLOWED_METHODS = ['PUT', 'POST'];

module.exports = () =&gt; {
 return async (ctx, next) =&gt; {
   const { method } = ctx;
   const { body } = ctx.request;

   if (ALLOWED_METHODS.includes(method)) {
     const { error } = Joi.validate(body, schema);
     if (error) {
       ctx.status = 422;
       ctx.body = {
         status: 'error',
         message: 'validation error',
         errors: error.details.map(e =&gt; e.message)
       };
     } else {
       await next();
     }
   } else {
     await next();
   }
 };
};</pre><p>In the preceding code block, we specify the <span>methods</span><a id="id326113778" class="indexterm"></a> that we would like to validate against in the <code class="literal">ALLOWED_METHODS</code> variable. This ensures that we only validate against <code class="literal">POST</code> and <code class="literal">PUT</code> requests that contain request body data, and not <code class="literal"><span>GET</span></code> requests, which do not. If a request matches any of these methods, we then validate the request body against a defined schema.</p><p><code class="literal">Joi</code> possesses various methods for schema validation. Notably, we make use of the <code class="literal">.required()</code> method, to ensure that the <code class="literal">name</code> and <code class="literal">phoneNumber</code> properties are always present.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note21"></a>Note</h3><p>Note that we only specify one validation schema in our application, as we only have one data model. In more complex applications, which possess multiple data models, multiple schemas need to be implemented, where the correct schema to use for validation can be decided based on the route.</p></div><p>If an error occurs from <code class="literal">Joi</code> during validation, we set the response status code to <code class="literal">422 (Unprocessable Entity)</code> and send back the error messages from <code class="literal">Joi</code>.</p><p>To register the middleware, let's update the <code class="literal">index.js</code> file, as follows:</p><pre class="programlisting">// ./index.js
// ...

const validator = require('./middleware/validator');

app.use(validator());

// ...</pre><p>At this point, the complete <code class="literal">index.js</code> file looks as follows:</p><pre class="programlisting">const Koa = require('koa');
const logger = require('koa-logger');
const bodyParser = require('koa-body');
const router = require('./middleware/router');
const validator = require('./middleware/validator');
const app = new Koa();

const mongoose = require('mongoose');
mongoose.connect(
  'mongodb://localhost:27017/koa-contact',
  { useNewUrlParser: true }
);

const db = mongoose.connection;
db.on('error', error =&gt; {
  throw new Error(`error connecting to db: ${error}`);
});
db.once('open', () =&gt; console.log('database connected'));

app.use(logger());

app.use(bodyParser());

app.use(validator());

app.use(router.routes());
app.use(router.allowedMethods());

const port = process.env.PORT || 3000;
app.listen(port, () =&gt;
  console.log(`Server running on http://localhost:${port}`)
);</pre><p>If we try to save a contact without <span>specifying</span><a id="id326116076" class="indexterm"></a> a name, the following is an example response that we might receive:</p><pre class="programlisting">{
    "status": "error",
    "message": "validation error",
    "errors": [
        "\"name\" is required"
    ]
}</pre></div></div>