<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec20"></a>A primer on Node</h2></div></div><hr /></div><p>As JavaScript developers who may or may not have experience working with Node.js, a brief introduction to Node.js and its core ideology will help get <span>everyone</span><a id="id326411146" class="indexterm"></a> up to speed. Node.js, or simply Node, is a run-time environment that executes JavaScript outside a browser. In simpler terms, and as it relates to web developers, Node is a platform that allows developers to write JavaScript applications that can also act as servers.</p><p>JavaScript became popular for being a language used to <span>manipulate</span><a id="id326332565" class="indexterm"></a> the <span class="strong"><strong>DOM</strong></span> (<span class="strong"><strong>Document Object Model</strong></span>) on web pages. It was a language typically used for client-side scripting. Node, which was built on Chrome's open source v8 JavaScript engine, made it possible to run JavaScript both on the browser and the server. This was highly accepted, as developers could now develop applications with the same language on servers and web browsers.</p><p>Node is very fast and is a great choice for building HTTP applications. It processes incoming requests in a loop, called the <span class="strong"><strong>event loop</strong></span>, which allows the <span>development</span><a id="id326332534" class="indexterm"></a> of fast web servers in JavaScript. Its event-driven architecture allows asynchronous operations. This means that developers can create highly scalable applications capable of processing requests asynchronously without using threading.</p><p>Asynchronous programming in Node is one of the reasons the language is so widely adopted. If you are unfamiliar with asynchronous programming or its benefits and how it compares to synchronous programming, here is a good example of a program that needs to make a request to get data from two external sources:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>In a synchronous program</strong></span>: The logical <span>thing</span><a id="id326332569" class="indexterm"></a> to do would be to make a request to the first external source, get a response, and then make another request to the second external source and merge the results. While this is a flow that is logical and easy to follow, it means that the wait time to service another request will be at least the sum of the wait times for each individual request. Since synchronous code leads to resource and event blocking, it does not lead an efficient solution and effectively slows down our application due to poor resource utilization.</li><li style="list-style-type: disc"><span class="strong"><strong>In an asynchronous program</strong></span>: Both <span>requests</span><a id="id326332544" class="indexterm"></a> can be made in parallel. When each request is completed, it notifies the main program and the results can be combined after the request that took the longest is completed. In this case, the wait time is only the time it takes for the slower request to be completed. Also, neither of the requests cause resource/event blocking, which would allow our program to respond to more new requests while waiting for results for the initial task.</li></ul></div><p> </p><p> </p><p>Managing asynchronous actions can get quite complicated, especially in programs where the flow of logic should be synchronous. Callback functions can be used to manage asynchronous operations. Callback functions are functions that are passed to another function (the main function) to be executed inside the <span>main</span><a id="id325749011" class="indexterm"></a> function. Here's a simple example of using a callback function with the <code class="literal">setTimeout()</code> function:</p><pre class="programlisting">function logTimeUp() {
  console.log(“Time up!”);
}

setTimeout(logTimeUp, 1000);</pre><p>The <code class="literal">setTimeout</code> function in JavaScript waits a given number of milliseconds and then executes the callback function passed to it. In the previous code example, we define a callback function called <code class="literal">logTimeUp</code> that simply prints <code class="literal">Time up!</code> to <code class="literal">stdout</code>. We then pass this function as a parameter to the <code class="literal">setTimeout</code> function, which will execute the callback function after <code class="literal">1000</code> milliseconds (one second). This is a classic example of how callbacks work.</p><p>In modern JavaScript, asynchronous actions can be modeled using <code class="literal">Promises</code>, which can be managed and consumed in multiple ways. One of these ways is using the <code class="literal">async… await</code> syntax.</p></div>