<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>The TensorFlow core</h2></div></div><hr /></div><p>The <span class="strong"><strong>TensorFlow core</strong></span> is the lower-level API on which the higher-level TensorFlow modules are built. In this section, we will go over a quick overview of TensorFlow core and <span>learn</span><a id="id325615016" class="indexterm"></a> about the basic elements of TensorFlow.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec4"></a>Tensors</h3></div></div></div><p><span class="strong"><strong>Tensors</strong></span> are the basic components in TensorFlow. A tensor is a multidimensional collection of data elements. It is generally identified by shape, type, and rank. <span class="strong"><strong>Rank</strong></span> refers to the number of <span>dimensions</span><a id="id326420185" class="indexterm"></a> of a tensor, while <span class="strong"><strong>shape</strong></span> refers to the <span>size</span><a id="id326420186" class="indexterm"></a> of each dimension. You may have seen several examples <span>of</span><a id="id325944101" class="indexterm"></a> tensors before, such as in a zero-dimensional collection (also known as a scalar), a one-dimensional collection (also known as a vector), and a two-dimensional collection (also known as a matrix).</p><p>A scalar value is a tensor of rank 0 and <span>shape []</span>. A vector, or a one-dimensional array, is a tensor of rank 1 and shape [<code class="literal">number_of_columns</code>] or [<code class="literal">number_of_rows</code>]. A matrix, or a two-dimensional array, is a tensor of rank 2 and shape [<code class="literal">number_of_rows</code>, <code class="literal">number_of_columns</code>]. A three-dimensional array is a tensor of rank 3. In the same way, an n-dimensional array is a tensor of rank n.</p><p>A tensor can store data of one type in all of its dimensions, and the <span>data</span><a id="id325944131" class="indexterm"></a> type of a tensor is the same as the data type of its elements.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip4"></a>Note</h3><p>The data types that can be found in the TensorFlow library are described at the following link: <a class="ulink" href="https://www.tensorflow.org/api_docs/python/tf/DType" target="_blank">https://www.tensorflow.org/api_docs/python/tf/DType</a>.</p></div><p>The following are the most commonly used data types in TensorFlow:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>TensorFlow Python API data type</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tf.float16</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>16-bit floating point (half-precision)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tf.float32</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>32-bit floating point (single-precision)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tf.float64</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>64-bit floating point (double-precision)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tf.int8</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>8-bit integer (signed)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tf.int16</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>16-bit integer (signed)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tf.int32</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>32-bit integer (signed)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">tf.int64</code></p></td><td style=""><p>64-bit integer (signed)</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip5"></a>Note</h3><p>Use TensorFlow data types for defining tensors instead of native data types from Python or data types from NumPy.</p></div><p>Tensors can be created in the following ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">By defining constants, operations, and variables, and passing the values to their constructor</li><li style="list-style-type: disc">By defining placeholders and passing the values to <code class="literal">session.run()</code></li><li style="list-style-type: disc">By converting Python objects, such as scalar values, lists, NumPy arrays, and pandas DataFrames, with the <code class="literal">tf.convert_to_tensor()</code> function</li></ul></div><p>Let's explore different ways of creating Tensors.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec5"></a>Constants</h3></div></div></div><p>The constant valued <span>tensors</span><a id="id325960824" class="indexterm"></a> are created using the <code class="literal">tf.constant()</code> function, and has the following d<span>efiniti</span><span><span><span><span><span><span>on:</span></span></span></span></span></span></p><pre class="programlisting">tf.constant(
  value,
  dtype=None,
  shape=None,
  name='const_name',
  verify_shape=False
  )</pre><p>Let's create some constants with the following code:</p><pre class="programlisting">const1=tf.constant(34,name='x1')
const2=tf.constant(59.0,name='y1')
const3=tf.constant(32.0,dtype=tf.float16,name='z1')</pre><p>Let's take a look at the preceding code in detail:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The first line of code defines a constant tensor, <code class="literal">const1</code>, stores a value of <code class="literal">34</code>, and names it <code class="literal">x1</code>.</li><li style="list-style-type: disc">The second line of code defines a constant tensor, <code class="literal">const2</code>, stores a value of <code class="literal">59.0</code>, and names it <code class="literal">y1</code>.</li><li style="list-style-type: disc">The third line of code defines the data type as <code class="literal">tf.float16</code> for <code class="literal">const3</code>. Use the <code class="literal">dtype</code> parameter or place the data type as the second argument to denote the data type. </li></ul></div><p>Let's print the constants <code class="literal">const1</code>, <code class="literal">const2</code>, and <code class="literal">const3</code>:</p><pre class="programlisting">print('const1 (x): ',const1)
print('const2 (y): ',const2)
print('const3 (z): ',const3)</pre><p>When we print these constants, we get the following output:</p><pre class="programlisting"><span class="strong"><strong>const1 (x):  Tensor("x:0", shape=(), dtype=int32)</strong></span>
<span class="strong"><strong>const2 (y):  Tensor("y:0", shape=(), dtype=float32)</strong></span>
<span class="strong"><strong>const3 (z):  Tensor("z:0", shape=(), dtype=float16)</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note6"></a>Note</h3><p>Upon p<span>rinting the previously </span>defined tensors, we can see that the data types of <code class="literal">const1</code> and <code class="literal">const2</code> are automatically deduced by TensorFlow.</p></div><p>To print the values of these constants, we can execute them in a TensorFlow session with the <code class="literal">tfs.run()</code> command:</p><pre class="programlisting">print('run([const1,const2,c3]) : ',tfs.run([const1,const2,const3]))</pre><p>We will see the following output:</p><pre class="programlisting"><span class="strong"><strong>run([const1,const2,const3]) : [34, 59.0, 32.0]</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec6"></a>Operations</h3></div></div></div><p>The TensorFlow library <span>contains</span><a id="id325966112" class="indexterm"></a> several built-in operations that can be applied on tensors. An operation node can be defined by passing input values and saving the output in another tensor. To understand this better, let's define two operations, <code class="literal">op1</code> and <code class="literal">op2</code>:</p><pre class="programlisting">op1 = tf.add(const2, const3)
op2 = tf.multiply(const2, const3)</pre><p>Let's print <code class="literal">op1</code> and <code class="literal">op2</code>:</p><pre class="programlisting">print('op1 : ', op1)
print('op2 : ', op2)</pre><p>The output is as follows, and shows that <code class="literal">op1</code> and <code class="literal">op2</code> are defined as tensors:</p><pre class="programlisting">op1 :  Tensor("Add:0", shape=(), dtype=float32)
op2 :  Tensor("Mul:0", shape=(), dtype=float32)</pre><p>To print the output from executing these operations, the <code class="literal">op1</code> and <code class="literal">op2</code> tensors have to be executed in a TensorFlow session:</p><pre class="programlisting">print('run(op1) : ', tfs.run(op1))
print('run(op2) : ', tfs.run(op2))</pre><p>The output is as follows:</p><pre class="programlisting">run(op1) :  91.0
run(op2) :  1888.0</pre><p>Some of the built-in operations of TensorFlow include arithmetic operations, math functions, and complex number operations.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec7"></a>Placeholders</h3></div></div></div><p>While constants store the value at the time of <span>defining</span><a id="id325966533" class="indexterm"></a> the tensor, placeholders allow you to create empty tensors so that the values can be provided at runtime. The TensorFlow library provides the <code class="literal">tf.placeholder()</code> function with the following signature to create placeholders:</p><pre class="programlisting">tf.placeholder(
  dtype,
  shape=None,
  name=None
  )</pre><p>As an example, let's create two placeholders and print them:</p><pre class="programlisting">p1 = tf.placeholder(tf.float32)
p2 = tf.placeholder(tf.float32)
print('p1 : ', p1)
print('p2 : ', p2)</pre><p>The following output shows that each placeholder has been created as a tensor:</p><pre class="programlisting">p1 :  Tensor("Placeholder:0", dtype=float32)
p2 :  Tensor("Placeholder_1:0", dtype=float32)</pre><p>Let's define an operation using these placeholders:</p><pre class="programlisting">mult_op = p1 * p2</pre><p>In TensorFlow, shorthand symbols can be used for various operations. In the preceding code, <code class="literal">p1 * p2</code> is shorthand for <code class="literal">tf.multiply(p1,p2)</code>:</p><pre class="programlisting">print('run(mult_op,{p1:13.4, p2:61.7}) : ',tfs.run(mult_op,{p1:13.4, p2:61.7}))</pre><p>The preceding command runs <code class="literal">mult_op</code> in the TensorFlow session and feeds the values dictionary (the second argument to the <code class="literal">run()</code> operation) with the values for <code class="literal">p1</code> and <code class="literal">p2</code>.</p><p>The output is as follows: </p><pre class="programlisting">run(mult_op,{p1:13.4, p2:61.7}) :  826.77997</pre><p>We can also specify the values dictionary by using the <code class="literal">feed_dict</code> parameter in the <code class="literal">run()</code> operation:</p><pre class="programlisting">feed_dict={p1: 15.4, p2: 19.5}
print('run(mult_op,feed_dict = {p1:15.4, p2:19.5}) : ',
      tfs.run(mult_op, feed_dict=feed_dict))</pre><p>The output is as follows:</p><pre class="programlisting">run(mult_op,feed_dict = {p1:15.4, p2:19.5}) :  300.3</pre><p>Let's look at one final example, which is of a vector being fed to the same operation:</p><pre class="programlisting">feed_dict={p1: [2.0, 3.0, 4.0], p2: [3.0, 4.0, 5.0]}
print('run(mult_op,feed_dict={p1:[2.0,3.0,4.0], p2:[3.0,4.0,5.0]}):',
      tfs.run(mult_op, feed_dict=feed_dict))</pre><p>The output is as follows:</p><pre class="programlisting">run(mult_op,feed_dict={p1:[2.0,3.0,4.0],p2:[3.0,4.0,5.0]}):[  6.  12.  20.]</pre><p>The elements of the two input vectors are multiplied in an element-wise fashion.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec8"></a>Tensors from Python objects</h3></div></div></div><p>Tensors can be created from <span>Python</span><a id="id326002487" class="indexterm"></a> objects such as lists, <span>NumPy</span> arrays, and pandas DataFrames. To create tensors from Python objects, use the <code class="literal">tf.convert_to_tensor()</code> function with the following definition:</p><pre class="programlisting">tf.convert_to_tensor(
  value,
  dtype=None,
  name=None,
  preferred_dtype=None
  )</pre><p>Let's practice doing this by creating some tensors and printing their definitions and values:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Define a 0-D tensor:</li></ol></div><pre class="programlisting">tf_t=tf.convert_to_tensor(5.0,dtype=tf.float64)

print('tf_t : ',tf_t)
print('run(tf_t) : ',tfs.run(tf_t))</pre><p>The output is as follows: </p><pre class="programlisting">tf_t : Tensor("Const_1:0", shape=(), dtype=float64)
run(tf_t) : 5.0</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Define a 1-D tensor:</li></ol></div><pre class="programlisting">a1dim = np.array([1,2,3,4,5.99])
print("a1dim Shape : ",a1dim.shape)

tf_t=tf.convert_to_tensor(a1dim,dtype=tf.float64)

print('tf_t : ',tf_t)
print('tf_t[0] : ',tf_t[0])
print('tf_t[0] : ',tf_t[2])
print('run(tf_t) : \n',tfs.run(tf_t))</pre><p>The output is as follows:</p><pre class="programlisting">a1dim Shape :  (5,)
tf_t :  Tensor("Const_2:0", shape=(5,), dtype=float64)
tf_t[0] :  Tensor("strided_slice:0", shape=(), dtype=float64)
tf_t[0] :  Tensor("strided_slice_1:0", shape=(), dtype=float64)
run(tf_t) : 
 [ 1.    2.    3.    4.    5.99]</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Define a 2-D tensor:</li></ol></div><pre class="programlisting">a2dim = np.array([(1,2,3,4,5.99),
                  (2,3,4,5,6.99),
                  (3,4,5,6,7.99)
                 ])
print("a2dim Shape : ",a2dim.shape)

tf_t=tf.convert_to_tensor(a2dim,dtype=tf.float64)

print('tf_t : ',tf_t)
print('tf_t[0][0] : ',tf_t[0][0])
print('tf_t[1][2] : ',tf_t[1][2])
print('run(tf_t) : \n',tfs.run(tf_t))</pre><p>The output is as follows:</p><pre class="programlisting">a2dim Shape :  (3, 5)
tf_t :  Tensor("Const_3:0", shape=(3, 5), dtype=float64)
tf_t[0][0] :  Tensor("strided_slice_3:0", shape=(), dtype=float64)
tf_t[1][2] :  Tensor("strided_slice_5:0", shape=(), dtype=float64)
run(tf_t) : 
 [[ 1.    2.    3.    4.    5.99]
  [ 2.    3.    4.    5.    6.99]
  [ 3.    4.    5.    6.    7.99]]</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Define a 3-D tensor:</li></ol></div><pre class="programlisting">a3dim = np.array([[[1,2],[3,4]],
                  [[5,6],[7,8]]
                 ])
print("a3dim Shape : ",a3dim.shape)

tf_t=tf.convert_to_tensor(a3dim,dtype=tf.float64)

print('tf_t : ',tf_t)
print('tf_t[0][0][0] : ',tf_t[0][0][0])
print('tf_t[1][1][1] : ',tf_t[1][1][1])
print('run(tf_t) : \n',tfs.run(tf_t))</pre><p>The output is as follows:</p><pre class="programlisting">a3dim Shape :  (2, 2, 2)
tf_t :  Tensor("Const_4:0", shape=(2, 2, 2), dtype=float64)
tf_t[0][0][0] :  Tensor("strided_slice_8:0", shape=(), dtype=float64)
tf_t[1][1][1] :  Tensor("strided_slice_11:0", shape=(), dtype=float64)
run(tf_t) : 
 [[[ 1.  2.][ 3.  4.]]
  [[ 5.  6.][ 7.  8.]]]</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec9"></a>Variables</h3></div></div></div><p>In the previous sections, we learned how to define tensor <span>objects</span><a id="id326002640" class="indexterm"></a> of different types, such as constants, operations, and placeholders. The values of parameters need to be held in an updatable memory location while building and training models with TensorFlow. Such updatable memory locations for tensors are known as variables in TensorFlow.</p><p>To summarize this, TensorFlow variables are tensor objects in that their values can be modified during the execution of the program.</p><p>Although <code class="literal">tf.Variable</code> seems to be similar to <code class="literal">tf.placeholder</code>, they have certain differences. These are listed in the following table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tf.placeholder</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">tf.Variable</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tf.placeholder</code> defines the input data that does not get updated over time</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">tf.Variable</code> defines values that get updated over time</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">tf.placeholder</code> does not need to be provided with an initial value at the time of definition</p></td><td style=""><p><code class="literal">tf.Variable</code> needs an initial value to be provided at the time of definition</p></td></tr></tbody></table></div><p> </p><p>In TensorFlow, a variable can be created with the API function <code class="literal">tf.Variable()</code>. Let's look at an example of using placeholders and variables and create the following model in TensorFlow:</p><div class="mediaobject"><img src="/graphics/9781789132212/graphics/59da1815-f5fb-4e36-bc54-ba89bda815cc.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Define the model parameters <code class="literal">w</code> and <code class="literal">b</code> as variables with the initial values <code class="literal">[.3]</code> and <code class="literal">[-0.3]</code>:</li></ol></div><pre class="programlisting">w = tf.Variable([.3], tf.float32)
b = tf.Variable([-.3], tf.float32)</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Define the input placeholder <code class="literal">x</code> and the output operation node <code class="literal">y</code>:</li></ol></div><pre class="programlisting">x = tf.placeholder(tf.float32)
y = w * x + b</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Print the variables and placeholders <code class="literal">w</code>, <code class="literal">v</code>, <code class="literal">x</code>, and <code class="literal">y</code>:</li></ol></div><pre class="programlisting">print("w:",w)
print("x:",x)
print("b:",b)
print("y:",y)</pre><p>The output depicts the type of nodes as <code class="literal">Variable</code>, <code class="literal">Placeholder</code>, or operation node, as follows:</p><pre class="programlisting">w: &lt;tf.Variable 'Variable:0' shape=(1,) dtype=float32_ref&gt;
x: Tensor("Placeholder_2:0", dtype=float32)
b: &lt;tf.Variable 'Variable_1:0' shape=(1,) dtype=float32_ref&gt;
y: Tensor("add:0", dtype=float32)</pre><p>The preceding output indicates that <code class="literal">x</code> is a <code class="literal">Placeholder</code> tensor, <code class="literal">y</code> is an operation tensor, and that <code class="literal">w</code> and <code class="literal">b</code> are variables with a shape of <code class="literal">(1,)</code> and a data type of <code class="literal">float32</code>.</p><p>The variables in a TensorFlow session have to be initialized before they can be used. We can either initialize a single variable by running its initializer operation or we can initialize all or a group of variables.</p><p>For example, to initialize the <code class="literal">w</code> variable, we can use the following code:</p><pre class="programlisting">tfs.run(w.initializer)</pre><p>TensorFlow provides a convenient function that can initialize all of the variables:</p><pre class="programlisting">tfs.run(tf.global_variables_initializer())</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip7"></a>Note</h3><p>TensorFlow also provides the <code class="literal">tf.variables_initializer()</code> function so that you can initialize a specific set of variables.</p></div><p>The global convenience function for initializing these variables can be executed in an alternative way. Instead of executing inside the <code class="literal">run()</code> function of a session object, the run function of the object returned by the initializer function itself can be executed:</p><pre class="programlisting">tf.global_variables_initializer().run()</pre><p>After the variables have been initialized, execute the model to get the output for the input values of <code class="literal">x = [1,2,3,4]</code>:</p><pre class="programlisting">print('run(y,{x:[1,2,3,4]}) : ',tfs.run(y,{x:[1,2,3,4]}))</pre><p>The output is as follows:</p><pre class="programlisting">run(y,{x:[1,2,3,4]}) :  [ 0.          0.30000001  0.60000002  0.90000004]</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>Tensors generated from library functions</h3></div></div></div><p>TensorFlow provides <span>various</span><a id="id326010650" class="indexterm"></a> functions to generate tensors with pre-populated values. The generated values from these functions can be stored in a constant or variable tensor. Such generated values can also be provided to the tensor constructor at the time of initialization.</p><p>As an example, let's generate a 1-D tensor that's been pre-populated with <code class="literal">100</code> zeros:</p><pre class="programlisting">a=tf.zeros((100,))
print(tfs.run(a))</pre><p>Some of the TensorFlow library functions that populate these tensors with different values at the time of their definition are listed as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Populating all of the elements of a tensor with similar values: <code class="literal">tf.ones_like()</code>, <code class="literal">tf.ones()</code>,<code class="literal"> tf.fill()</code>, <code class="literal">tf.zeros()</code>, and<code class="literal">tf.zeros_like()</code> </li><li style="list-style-type: disc">Populating tensors with sequences: <code class="literal">tf.range()</code>,and <code class="literal">tf.lin_space()</code></li><li style="list-style-type: disc">Populating tensors with a probability distribution: <code class="literal">tf.random_uniform()</code>, <code class="literal">tf.random_normal()</code>, <code class="literal">tf.random_gamma()</code>,and <code class="literal">tf.truncated_<span>normal()</span></code></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"></a>Obtaining variables with the tf.get_variable()</h3></div></div></div><p>If a variable is defined with a <span>name</span><a id="id326010896" class="indexterm"></a> that has already been used for another variable, then an exception is thrown by TensorFlow. The<code class="literal">tf.get_variable()</code> function makes it convenient and safe to create a variable in place of using the<code class="literal">tf.Variable()</code> function. The <code class="literal">tf.get_variable()</code> function returns a variable that has been defined with a given name. If the variable with the given name does not exist, then it will create the variable with the specified initializer and shape.</p><p>Consider the following example:</p><pre class="programlisting">w = tf.get_variable(name='w',shape=[1],dtype=tf.float32,initializer=[.3])
b = tf.get_variable(name='b',shape=[1],dtype=tf.float32,initializer=[-.3])</pre><p>The initializer can either be a list of values or another tensor. An initializer can also be one of the built-in initializers. Some of these are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">tf.ones_initializer</code></li><li style="list-style-type: disc"><code class="literal">tf.constant_initializer</code></li><li style="list-style-type: disc"><code class="literal">tf.zeros_initializer</code></li><li style="list-style-type: disc"><code class="literal">tf.truncated_normal_initializer</code></li><li style="list-style-type: disc"><code class="literal">tf.random_normal_initializer</code></li><li style="list-style-type: disc"><code class="literal">tf.random_uniform_initializer</code></li><li style="list-style-type: disc"><code class="literal">tf.uniform_unit_scaling_initializer</code></li><li style="list-style-type: disc"><code class="literal">tf.orthogonal_initializer</code></li></ul></div><p>The <code class="literal">tf.get_variable()</code> function only returns the global variables when the code is run across multiple machines <span>in dis</span>tributed TensorFlow. The local variables can be retrieved by using the <code class="literal">tf.get_local_variable()</code> function.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note8"></a>Note</h3><p><span class="strong"><strong>Sharing or reusing variables</strong></span>: Getting variables that have already been defined promotes reuse. However, an exception will be thrown if the reuse flags are not set by using <code class="literal">tf.variable_scope.reuse_variable()</code> or <code class="literal">tf.variable.scope(reuse=True)</code>.</p></div><p>Now that we have learned how to define tensors, constants, operations, placeholders, and variables, let's learn about the next level of abstraction in TensorFlow that combines these basic elements to form a basic unit of computation: the computation graph.</p></div></div>