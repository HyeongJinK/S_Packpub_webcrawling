<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec52"></a>Creating a stock price prediction model</h2></div></div><hr /></div><p>We will begin our <span>project</span><a id="id325936236" class="indexterm"></a> by processing the data present in the dataset:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a d<span>ataframe</span> with yearly time series for each stock. Represent each year's stock price by an individual column in that dataframe. Restrict number of rows in the dataframe to 252 which is roughly the number of trading days in a year. Also add the fiscal quarter associated with each row of data as a separate column.</li></ol></div><pre class="programlisting">def get_prices_by_year(self):
   df = self.modify_first_year_data()
   for i in range(1, len(self.num_years)):
       df = pd.concat([df, pd.DataFrame(self.get_year_data(year=self.num_years[i], normalized=True))], axis=1)
   df = df[:self.num_days]
   quarter_col = []
   num_days_in_quarter = self.num_days // 4
   for j in range(0, len(self.quarter_names)):
       quarter_col.extend([self.quarter_names[j]]*num_days_in_quarter)
   quarter_col = pd.DataFrame(quarter_col)
   df = pd.concat([df, quarter_col], axis=1)
   df.columns = self.num_years + ['Quarter']
   df.index.name = 'Day'
   df = self.fill_nans_with_mean(df)
   return df</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"></a>Note</h3><p>Note that there are almost 252 trading days in a year, as stock markets are closed on weekends.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Even if there are more trading days in a particular year (like leap year), <span>limit</span><a id="id325935984" class="indexterm"></a> data to 252 days to ensure consistency across the years. In case the number of trading days is less than 252 in a particular year, extrapolate the data to 252 days by imputing the mean price of the year for missing days. Implement the following code to achieve this:</li></ol></div><pre class="programlisting">def fill_nans_with_mean(self, df):
   years = self.num_years[:-1]
   df_wo_last_year = df.loc[:,years]
   df_wo_last_year = df_wo_last_year.fillna(df_wo_last_year.mean())
   df_wo_last_year[self.num_years[-1]] = df[self.num_years[-1]]
   df= df_wo_last_year

   returndf</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>For each year, normalize the prices to transform the yearly series to zero mean and unit standard deviation. Also, subtract the first day price from all of the data points in that year. This basically forces a yearly time series to start from zero, thereby avoiding any influence of previous year's prices on it.</li></ol></div><pre class="programlisting">def normalized_data_col(self, df):
   price_normalized = pd.DataFrame()
   date_list = list(df.Date)
   self.num_years = sorted(list(set([date_list[i].year for i in range(0, len(date_list))])))
   for i in range(0, len(self.num_years)):
       prices_data = self.get_year_data(year=self.num_years[i], normalized=False)
       prices_data = [(prices_data[i] - np.mean(prices_data)) / np.std(prices_data) for i in range(0, len(prices_data))]
       prices_data = [(prices_data[i] - prices_data[0]) for i in range(0, len(prices_data))]
       price_normalized = price_normalized.append(prices_data, ignore_index=True)
   return price_normalized</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note42"></a>Note</h3><p>Please make sure to install this library as mentioned in the <span class="strong"><strong>README</strong></span> file in the repository for this chapter, before executing the code.</p></div><p></p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>As mentioned in the previous section, <span>generate</span><a id="id325601666" class="indexterm"></a> the covariance matrix as a sum of two kernels:</li></ol></div><pre class="programlisting">kernel=gpflow.kernels.RBF(2,lengthscales=1,variance=63)+gpflow.kernels.White(2,variance=1e-10)</pre><p>We use the SciPy optimizer in GPflow package to optimize hyper parameters using maximum likelihood estimation. Scipy is a standard optimizer from Python library Scipy. If you are not familiar with Scipy optimizer, please refer to the official page (<a class="ulink" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html" target="_blank">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</a>).</p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Implement the final wrapper function <code class="literal">make_gp_predictions</code> to train a GP model and make future price predictions. Following are the steps that the function implements:<div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Takes the input of training data, start and end of training period and prediction year and quarter. </li><li>Constructs 2 separate series using data from the start year of the training period, one for the independent variables (X) and one for the target (Y). Each element in series (X) represents each day of the year and consists of two independent variables, year and day of the year. For example, for start year 2008, X looks like [[2008,1], [2008,2],[2008,3].......[2008,252]].</li><li>Appends the independent and target variables for each subsequent year to list X and Y respectively. </li><li>If input <code class="literal">pred_quarters</code> is not None, predicts for the quarters specified instead of the entire year. For example, if <code class="literal">pred_quarters</code> is [4] and <code class="literal">pred_year </code>is 2018, the function will predict for Quarter 4 of 2018 using all the data till Quarter 3 of 2018. </li><li>Defines the kernel function as mentioned before and trains the GP model using Scipy optimizer. </li><li>Predicts the stock prices for the prediction period.</li></ol></div></li></ol></div><pre class="programlisting">def make_gp_predictions(self, start_year, end_year, pred_year, pred_quarters = []):
   start_year, end_year, pred_year= int(start_year),int(end_year), int(pred_year)
   years_quarters = list(range(start_year, end_year + 1)) + ['Quarter']
   years_in_train = years_quarters[:-2]
   price_df = self.preprocessed_data.prices_by_year[self.preprocessed_data.prices_by_year.columns.intersection(years_quarters)]
   num_days_in_train = list(price_df.index.values)
   #Generating X and Y for Training
   first_year_prices = price_df[start_year]
   if start_year == self.preprocessed_data.num_years[0]:
       first_year_prices = (first_year_prices[first_year_prices.iloc[:] != 0])
       first_year_prices = (pd.Series([0.0], index=[first_year_prices.index[0]-1])).append(first_year_prices)
   first_year_days = list(first_year_prices.index.values)
   first_year_X = np.array([[start_year, day] for day in first_year_days])
   X = first_year_X
   Target = np.array(first_year_prices)
   for year in years_in_train[1:]:
       current_year_prices = list(price_df.loc[:, year])
       current_year_X = np.array([[year, day] for day in num_days_in_train])
       X = np.append(X, current_year_X, axis=0)
       Target = np.append(Target, current_year_prices)
   final_year_prices = price_df[end_year]
   final_year_prices = final_year_prices[final_year_prices.iloc[:].notnull()]
   final_year_days = list(final_year_prices.index.values)
   if pred_quarters is not None:
       length = 63 * (pred_quarters[0] - 1)
       final_year_days = final_year_days[:length]
       final_year_prices = final_year_prices[:length]
   final_year_X = np.array([[end_year, day] for day in final_year_days])
   X = np.append(X, final_year_X, axis=0)
   Target = np.append(Target, final_year_prices)
   if pred_quarters is not None:
       days_for_prediction = [day for day in
                              range(63 * (pred_quarters[0]-1), 63 * pred_quarters[int(len(pred_quarters) != 1)])]
   else:
       days_for_prediction = list(range(0, self.preprocessed_data.num_days))
   x_mesh = np.linspace(days_for_prediction[0], days_for_prediction[-1]
                        , 2000)
   x_pred = ([[pred_year, x_mesh[i]] for i in range(len(x_mesh))])
   X = X.astype(np.float64)
   Target = np.expand_dims(Target, axis=1)
   kernel = gpflow.kernels.RBF(2, lengthscales=1, variance=63) + gpflow.kernels.White(2, variance=1e-10)
   self.gp_model = gpflow.models.GPR(X, Target, kern=kernel)
   gpflow.train.ScipyOptimizer().minimize(self.gp_model)
   y_mean, y_var = self.gp_model.predict_y(x_pred)
   return x_mesh, y_mean, y_var</pre></div>