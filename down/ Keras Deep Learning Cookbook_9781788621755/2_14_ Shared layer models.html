<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec22"></a>Shared layer models</h2></div></div><hr /></div><p>Multiple layers in Keras can share the <span>output</span><a id="id324879982" class="indexterm"></a> from one layer. There can be multiple different feature extraction layers from an input, or multiple layers can be used to predict the output from a feature extraction layer.</p><p>Let's look at both of these examples.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec22"></a>Introduction – shared input layer</h3></div></div></div><p>In this section, we show how multiple convolutional layers with differently sized kernels interpret an image input. The model takes colored CIFAR images with a size of 32 x 32 x 3 pixels. There are two CNN feature extraction submodels that share this input; the first has a kernel size of 4, the second a kernel size of 8. The outputs from these feature extraction sub-models are flattened into vectors and concatenated into one long vector, and this is passed on to a fully connected layer for interpretation before a final <span>output</span><a id="id325338096" class="indexterm"></a> layer makes a <span>binary</span><a id="id325338104" class="indexterm"></a> classification.</p><p>This is the model topology:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">One input layer</li><li style="list-style-type: disc">Two feature extraction layers</li><li style="list-style-type: disc">One interpretation layer</li><li style="list-style-type: disc">One dense output layer</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec23"></a>How to do it...</h3></div></div></div><p>First, we need to define the appropriate layers using the Keras APIs. <span>The key API here</span> is creating a merge layer and using it to create an interpretation layer.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec25"></a>Concatenate function</h4></div></div></div><p>The <code class="literal">concatenate</code> function is <span>used</span><a id="id325345146" class="indexterm"></a> to merge two models, as shown in the following code:</p><pre class="programlisting"># merge feature extractors
merge = concatenate([flat1, flat2])
# interpretation layer
hidden1 = Dense(512, activation='relu')(merge)</pre><p>Here is the complete model topology code:</p><pre class="programlisting">#input layer
visible = Input(shape=(32,32,3))
# first feature extractor
conv1 = Conv2D(32, kernel_size=4, activation='relu')(visible)
pool1 = MaxPooling2D(pool_size=(2, 2))(conv1)
flat1 = Flatten()(pool1)
# second feature extractor
conv2 = Conv2D(16, kernel_size=8, activation='relu')(visible)
pool2 = MaxPooling2D(pool_size=(2, 2))(conv2)
flat2 = Flatten()(pool2)
# merge feature extractors
merge = concatenate([flat1, flat2])
# interpretation layer
hidden1 = Dense(512, activation='relu')(merge)
# prediction output
output = Dense(10, activation='sigmoid')(hidden1)
model = Model(inputs=visible, outputs=output)</pre><p> </p><p>The model topology is saved to a file and shows how a single input layer feeds into two feature extraction layers, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788621755/graphics/db463219-dd1f-48f5-b65b-fe784955c760.png" /></div><p>Next, let's compile this model, pass the training dataset, and calculate the accuracy:</p><pre class="programlisting"># Let's train the model using RMSprop
model.compile(loss='categorical_crossentropy',
 optimizer=opt,
 metrics=['accuracy'])
model.fit(x_train, y_train,
 batch_size=batch_size,
 epochs=epochs,
 validation_data=(x_test, y_test),
 shuffle=True)
scores = model.evaluate(x_test, y_test, verbose=1)
print('Test loss:', scores[0])
print('Test accuracy:', <span>scores</span>[1])</pre><p>In the next section, we look at how to use Keras functional APIs to create models and create more complex topologies.</p></div></div></div>