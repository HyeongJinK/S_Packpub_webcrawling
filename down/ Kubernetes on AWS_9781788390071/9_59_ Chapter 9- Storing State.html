<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch09"></a>Chapter 9. Storing State</h2></div></div></div><p>This chapter is all about utilizing the deep integration that Kubernetes has with the AWS native storage solution <span class="strong"><strong>Elastic Block Store</strong></span> (<span class="strong"><strong>EBS</strong></span>). Amazon EBS provides network attached storage as a service, and is the primary solution used to provide block storage to EC2 instances.</p><p>Nearly every EC2 instance <span>launched</span><a id="id325546192" class="indexterm"></a> is backed by an EBS root volume (created from an AMI machine image). Because EBS storage is network attached, if an underlying machine hosting an EC2 instance fails in some way, the data stored on the volume is safe as it is automatically replicated across multiple physical storage devices.</p><p>In addition to being used to store the root filesystem of EC2 instances, additional EBS volumes can be attached to EC2 instances and mounted on demand via the AWS API. Kubernetes integration with AWS EBS makes use of this to provide persistent volumes that can be used by your pods. If a pod is killed and is replaced by a pod on another EC2 instance, Kubernetes will handle detaching the EBS volume from the old EC2 instance and attaching it to the new instance, ready to be mounted into the new pod as required.</p><p>In this chapter, we will start by looking at how we can configure our pods to make use of additional volumes. We will then look at the abstractions Kubernetes provides for dealing with storage that provides persistence (such as EBS). We will look at how Kubernetes can automatically provision EBS volumes for us based on the specifications requested in our pod configurations.</p><p>Once you have mastered using Kubernetes to provision persistent storage for your pods, in the second half of this chapter we will look at stateful sets, the abstraction that Kubernetes provides to run a set of pods, each of which can have its own attached storage and an identity that remains even if rescheduled to another node. This is the final piece of the puzzle required if you want to run complex stateful applications on your Kubernetes cluster, such as databases.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Volumes</li><li style="list-style-type: disc">Storage classes</li><li style="list-style-type: disc">Stateful sets</li></ul></div></div>