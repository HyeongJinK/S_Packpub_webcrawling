<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec50"></a>Getting started with Terraform</h2></div></div><hr /></div><p>Terraform is a command-line tool <span>that</span><a id="id325268185" class="indexterm"></a> you can run on your workstation to make changes to your infrastructure. Terraform is a <span>single</span><a id="id325268194" class="indexterm"></a> binary that just needs to be installed onto your path.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note56"></a>Note</h3><p>You can download Terraform from <span><a class="ulink" href="https://www.terraform.io/downloads.html" target="_blank">https://www.terraform.io/downloads.html</a> </span>for six different operating systems, including macOS, Windows, and Linux. Download the ZIP file for your operating system, extract it, and then copy the Terraform binary to a location on your path.</p></div><p>Terraform uses files with the <code class="literal">.tf</code> extension to describe your infrastructure. Because Terraform supports the management of resources on many different cloud platforms, it can contain the concepts of the relevant providers, which are loaded as required to support the different APIs exposed by the different cloud providers.</p><p>First, let's configure the AWS Terraform provider in order to be ready to build a Kubernetes cluster. Create a new directory to hold the Terraform configuration for your Kubernetes cluster, and then create a file where we will configure the AWS provider, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>aws.tf</strong></span>
provider "aws" { 
  version = "~&gt; 1.0" 
 
  region = "us-west-2" 
} </pre><p>Save the file, and then run the following:</p><pre class="programlisting"><span class="strong"><strong>terraform.init</strong></span>
Initializing provider plugins... 
- Checking for available provider plugins on https://releases.hashicorp.com... 
- Downloading plugin for provider "aws" (1.33.0)... 
Terraform has been successfully initialized! </pre><p>When you use a supported provider, Terraform can discover and download the required plugin for you. Note that we have already configured the provider with an AWS region of <code class="literal">us-west-2</code>, as this is the region where we will be launching our cluster in this example.</p><p>In order for Terraform to communicate with the AWS API, you will need to provide the AWS provider with some credentials. We learned how to obtain credentials in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Reach for the Cloud</em></span>. If you followed the advice in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Reach for the Cloud</em></span>, and set your credentials up with the <code class="literal">aws configure</code> command, then Terraform will read your default credentials from your local config file.</p><p>Alternatively, Terraform can read AWS credentials from the <code class="literal">AWS_ACCESS_KEY_ID</code> and <code class="literal">AWS_SECRET_ACCESS_KEY</code> environment variables, or, if you are running Terraform on an EC2 instance, it can use the credentials provided by an EC2 instance role.</p><p>It is also possible to statically configure the credentials by adding an <code class="literal">access_key</code> and<code class="literal">secret_key</code><span>parameter inline in the AWS provider block, but I wouldn't really recommend this practice as it makes it much harder to check your configuration into a version control system.</span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note57"></a>Note</h3><p>By default, Terraform uses a local file called <code class="literal">terraform.tfstate</code> to keep track of the state of your infrastructure. This is so that it can keep track of the changes you have made to the configuration since you last ran Terraform.
If you are going to be the only person managing your infrastructure, then this might be acceptable, but you would need to securely back up the state file. It should be considered sensitive, and Terraform won't function correctly if you lose it.
If you are using AWS, I would recommend using S3 as a backend. You can read about how to set this up in the Terraform documentation at <a class="ulink" href="https://www.terraform.io/docs/backends/types/s3.html" target="_blank">https://www.terraform.io/docs/backends/types/s3.html</a>. If configured correctly, S3 storage is highly secure, and if you are working on a team, then you can utilize a DynamoDB table as a lock to ensure that multiple instances of Terraform are not running at the same time. If you want to make use of this, set the configuration in the <code class="literal">backend.tf</code> file, otherwise delete that file.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec73"></a>Variables</h3></div></div></div><p>Terraform allows us to define <span>variables</span><a id="id325761956" class="indexterm"></a> in order to make our configuration more reusable. This is particularly useful if you later want to use your configuration as a module in order to define multiple clusters. We won't cover that in this chapter, but we can follow best practices and define some key variables to allow you to simply shape the cluster to meet your needs.</p><p>It is standard to create a <code class="literal">variables.tf</code> file to include all of the variables in your project. This is helpful because it acts as high-level documentation about how your configuration can be controlled.</p><p>As you can see, between choosing descriptive names for my variables and adding the optional description field, the whole file is quite self-explanatory. Because I have provided defaults for each variable, we can run Terraform without passing any values for these variables, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>variables.tf</strong></span>
variable "cluster_name" { 
  default = "lovelace" 
} 
 
variable "vpc_cidr" { 
  default     = "10.1.0.0/16" 
  description = "The CIDR of the VPC created for this cluster" 
} 
 
variable "availability_zones" { 
  default     = ["us-west-2a","us-west-2b"] 
  description = "The availability zones to run the cluster in" 
} 
 
variable "k8s_version" { 
  default     = "1.10" 
  description = "The version of Kubernetes to use" 
} </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec74"></a>Networking</h3></div></div></div><p>We will start by creating a config <span>file</span><a id="id325761986" class="indexterm"></a> to describe the network setup for our Kubernetes cluster. You might recognize the design of this network, as it is quite similar the one we manually created in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Reach for the Cloud</em></span>, but with a few additions to make it more suitable for a production setup.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p>Terraform configuration files can be documented with comments, and to better illustrate this configuration, I have provided some commentary in the form of comments. You will notice that they are surrounded by <code class="literal">/*</code> and <code class="literal">*/</code>.</p></div><p>In order to support high availability, we are going to create subnets for more than one availability zone, as shown in the following code. Here, we are using two, but if you wanted even greater resiliency, you can easily add another availability zone to the <code class="literal">availability_zones</code> variable:</p><pre class="programlisting"><span class="strong"><strong>networking.tf</strong></span>
/*  Set up a VPC for our cluster. 
*/resource "aws_vpc" "k8s" { 
  cidr_block           = "${var.vpc_cidr}" 
  enable_dns_hostnames = true 
 
  tags = "${ 
    map( 
     "Name", "${var.cluster_name}", 
     "kubernetes.io/cluster/${var.cluster_name}", "shared", 
    ) 
  }" 
} 
 
/*  In order for our instances to connect to the internet 
  we provision an internet gateway.*/ 
resource "aws_internet_gateway" "gateway" { 
  vpc_id = "${aws_vpc.k8s.id}" 
 
  tags { 
    Name = "${var.cluster_name}" 
  } 
} 
 
/*  For instances without a Public IP address we will route traffic  
  through a NAT Gateway. Setup an Elastic IP and attach it. 
 
  We are only setting up a single NAT gateway, for simplicity. 
  If the availability is important you might add another in a  
  second availability zone. 
*/ 
resource "aws_eip" "nat" { 
  vpc        = true 
  depends_on = ["aws_internet_gateway.gateway"] 
} 
 
resource "aws_nat_gateway" "nat_gateway" { 
  allocation_id = "${aws_eip.nat.id}" 
  subnet_id     = "${aws_subnet.public.*.id[0]}" 
} </pre><p>We are going to provision two subnets for each of the availability zones we are using for our cluster. A public subnetwhich have a direct route to the internet where Kubernetes will provision load balancers that are accessible to the internet. And a private subnet that will be used by Kubernetes to assign IP addresses to pods.</p><p>Because the address space available in the private subnets will be the limiting factor on the number of pods that Kubernetes will be able to launch, we provision a large address range with 16382 available IP addresses. This should allow our cluster some room for expansion.</p><p>If you are only planning to run internal services that are not be accessible to the internet, then you might be able to skip the public subnets.You can find the full<code class="literal"><span>networking.tf</span></code>file in the example files for this chapter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec75"></a>Plan and apply</h3></div></div></div><p>Terraform allows us to incrementally <span>build</span><a id="id325793405" class="indexterm"></a> our infrastructure by adding to and changing the code that defines it. Then if you wish, as you go through this chapter, you can <span>build</span><a id="id325793414" class="indexterm"></a> up your configuration piece by piece, or you can use Terraform to build your whole cluster in one go.</p><p>Whenever you use Terraform to make a change to your infrastructure, it first produces a plan of the changes that it is going to make, and then it applies this plan. This two-stage operation is ideal when modifying production infrastructure as it gives you the opportunity to review the changes that will actually be applied to your cluster before they are made.</p><p>Once you have saved your networking configuration to a file, we can follow a few steps to safely provision our infrastructure.</p><p>We can check for syntax errors in the configuration by running the following command:</p><pre class="programlisting"><span class="strong"><strong>terraform validate</strong></span></pre><p>If your configuration is good, then there will be no output, but if there are syntax errors with your file(s), you should see an error message explaining the issue. For example, a missing closing brace might cause an error such as <code class="literal">Error parsing networking.tf: object expected closing RBRACE got: EOF</code>.</p><p>Once you have ensured that your files are correctly formatted for Terraform, you can create a plan for the changes to your infrastructure using the following command:</p><pre class="programlisting"><span class="strong"><strong>terraform plan -out k8s.plan</strong></span></pre><p>This command will output a summary of the changes that will be made to your infrastructure if this plan is run. The <code class="literal">-out</code> flag is optional, but it is a good idea because it allows us to apply exactly these changes later on. If you were paying attention to the output when you ran the Terraform plan, then you should have seen a message like:</p><pre class="programlisting"><span class="strong"><strong>To perform exactly these actions, run the following command to apply:</strong></span>
<span class="strong"><strong>terraform apply "k8s.plan"</strong></span></pre><p>When you run <code class="literal">terraform apply</code> with a precomputed plan, it will make the changes that were outlined when the plan was generated. You could also run <code class="literal">terraform plan</code> command without pregenerating a plan, but in this case, it will still plan the changes and then prompt you before applying them.</p><p>Terraform computes the dependencies between the different resources in your infrastructure—for example, it ensures that the VPC is created before the route tables and other resources are created. Some resources can take a few seconds to create, but Terraform will wait until they are available before moving on to create dependent resources.</p><p>If you want to remove a resource that Terraform has created in your AWS account, you can just delete the definition from the relevant <code class="literal">.tf</code> file and then plan and apply your changes. When you are testing a Terraform configuration, it can be useful to remove all of the resources created by a particular configuration in order to test provisioning your infrastructure from scratch. If you need to do this, the <code class="literal">terraform destroy</code> command is very useful; it will remove all of the resources that are defined in your Terraform files from your infrastructure. However, be aware that this could cause essential resources to be terminated and removed, and so you shouldn't use this method on a running production system. Before any resources are removed, Terraform will list them and then ask you whether you want to remove them.</p></div></div>