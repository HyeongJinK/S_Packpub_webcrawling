<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec17"></a>Creating an AWS account</h2></div></div><hr /></div><p>If you don't already have an <span>AWS</span><a id="id325162570" class="indexterm"></a> account, then head over to <a class="ulink" href="https://aws.amazon.com/" target="_blank"><span>https://aws.amazon.com/</span></a> and sign up for one. Before you can create resources in your account, you will need to <span>add</span><a id="id325750949" class="indexterm"></a> a credit card to your account to cover any charges.</p><p>When you first sign up for an AWS account, you will be eligible for a free usage tier on some services for the first 12 months. Unfortunately, this free tier doesn't provide quite enough resources to run Kubernetes, but in this chapter, we have optimized our choice of instances for their low cost, so you should be able to follow the examples without spending too much.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec22"></a>Creating an IAM user</h3></div></div></div><p>When you sign up for an <span>AWS</span><a id="id326407274" class="indexterm"></a> account, the email address and password you choose will be used to log in to the root account. Before you start to interact with AWS, it is a good idea to create an IAM user that you will use to interact with AWS. The advantage of <span>this</span><a id="id326407283" class="indexterm"></a> is that if you wish, you can give each IAM user as much or as little access as they need to AWS services. If you use the root account, you automatically have full access and have no way to manage or revoke privileges. Go through the following steps to set up the account:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Once you have logged into the AWS console, go to the <strong class="userinput"><code>Identity and Access Management</code></strong> dashboard by clicking on <strong class="userinput"><code>Services</code></strong> and typing <code class="literal">IAM</code> into the search box.</li><li>From the sidebar, choose <strong class="userinput"><code>Users</code></strong> to view the IAM users in your AWS account. If you have only just set up a new account, there won't be any users here yet—the root account doesn't count as a user.</li><li>Start the process of <span>setting</span><a id="id326407316" class="indexterm"></a> up a new user account by clicking on the <strong class="userinput"><code>Add user</code></strong> button at the top of the screen.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Start by choosing a username for your user. Check both boxes to enable <span class="strong"><strong>Programmatic access</strong></span> (so you can use the command-line client) and <span class="strong"><strong>AWS Management Console access</strong></span> so you can log into the web console, as <span>shown</span><a id="id326456870" class="indexterm"></a> in the preceding screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788390071/graphics/876969f0-ddf5-43ae-a5bb-f001dc9c82f0.png" /></div><p></p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>On the next screen, you can configure the permissions for your user. Choose <strong class="userinput"><code>Attach existing policies directly</code></strong>, then choose the <strong class="userinput"><code>AdministratorAccess</code></strong> policy, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788390071/graphics/df5e487e-95d5-4ac6-9c76-cafa1ed1c969.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Review your settings, then click <strong class="userinput"><code>Create user</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788390071/graphics/a6e63c23-7282-4050-8fea-d0ad37533e32.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Once your user has been created, take a <span>note</span><a id="id326462711" class="indexterm"></a> of the credentials. You will need the <span class="strong"><strong>Access key ID</strong></span> and <span class="strong"><strong>Secret access key</strong></span> shortly to configure <span>the</span><a id="id326462726" class="indexterm"></a> AWS command-line client. Also take a note of the console sign-in link, as this is <span>unique</span><a id="id326462732" class="indexterm"></a> to your AWS account, shown as follows:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788390071/graphics/9a7c8811-8cf3-4ef6-8ef0-a1724af0affb.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Once you have set up an IAM user for yourself, log out of the root account in your browser and check that you can sign back in using your username and password.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Note</h3><p>You might want to set up two-factor authentication for your AWS account for greater security. Remember that anyone with Administrator access to the account can access or delete any of the resources in your account.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"></a>Getting the CLI</h3></div></div></div><p>You can control AWS using the <span>web</span><a id="id326462770" class="indexterm"></a> console, but your control of AWS will be more precise if you do everything from the command line with the AWS command-line client.</p><p>You should follow the instructions provided by AWS to install the command-line client on your system (or by using your systems package manager) using the instructions found at <span><a class="ulink" href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html" target="_blank">https://docs.aws.amazon.com/cli/latest/userguide/installing.html</a>)</span>.</p><p>Once you have installed the command-line client, run the <code class="literal">aws configure</code> command to configure the CLI with your credentials. This command will update the <code class="literal">aws config</code> files in your home directory.</p><p>At this stage, you should choose an AWS region for your cluster. For testing and experimentation, it makes sense for you to choose one that is located relatively close to your location. Doing so will improve latency when you access your instances with <code class="literal">ssh</code> or <code class="literal">connect</code> to the Kubernetes API.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>Setting up a key pair</h3></div></div></div><p>When we launch an EC2 instance, we want to be able to access it via SSH. We can register a key pair in the EC2 console to allow us to log in once our instance has been launched.</p><p>It is possible for us to instruct AWS to <span>generate</span><a id="id326462813" class="indexterm"></a> a key pair for you (that you can then download). But the best practice is to generate a key pair on your workstation and upload the public part to AWS. This ensures that you (and only you) have control of your instance, since the private half of your key will never leave your own machine. To set up the key pair, go through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>You may already have a key pair on your machine that you wish to use. You can check for existing keys by looking in your <code class="literal">.ssh</code> directory, as follows:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ ls -la ~/.ssh</strong></span><span class="strong"><strong>total 128</strong></span><span class="strong"><strong>drwx------    6 edwardrobinson  staff    192 25 Feb 15:49 .</strong></span><span class="strong"><strong>drwxr-xr-x+ 102 edwardrobinson  staff   3264 25 Feb 15:49 ..</strong></span><span class="strong"><strong>-rw-r--r--    1 edwardrobinson  staff   1759 25 Feb 15:48 config</strong></span><span class="strong"><strong>-rw-------    1 edwardrobinson  staff   3326 25 Feb 15:48 id_rsa</strong></span><span class="strong"><strong>-rw-r--r--    1 edwardrobinson  staff    753 25 Feb 15:48 
id_rsa.pub</strong></span><span class="strong"><strong>-rw-r--r--    1 edwardrobinson  staff  53042 25 Feb 15:48 
known_hosts</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>In this example, you can see that I have one key pair in my <code class="literal">.ssh</code> directory—the private key has the default name of <code class="literal">id_rsa</code> and the public key is called <code class="literal">id_rsa.pub</code>.</li><li>If you don't already have a key pair set up, or if you want to create a fresh one, then you can use the <code class="literal">ssh-keygen</code> command to create a new one, as follows:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ ssh-keygen -t rsa -b 4096 -C "email@example.com"</strong></span><span class="strong"><strong>Generating public/private rsa key pair.</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>This command creates a new key pair using your email address as a label.</li><li>Next, choose where to save the new key pair. If you don't already have a key pair, just press <span class="emphasis"><em>Enter</em></span> to write it to the default location as follows:</li></ol></div><pre class="programlisting"><span class="strong"><strong>Enter file in which to save the key (/home/edwardrobinson/.ssh/id_rsa):</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Next, you will be asked for a passphrase (password). If you just press <span class="emphasis"><em>Enter</em></span>, then the key will be created without any password protection, as shown in the following command. If you choose a password, make sure that you remember it or store it securely, as you won't be able to use your SSH key (or access your instances) without it.</li></ol></div><pre class="programlisting"><span class="strong"><strong>Enter passphrase (empty for no passphrase):</strong></span><span class="strong"><strong>Enter same passphrase again:</strong></span><span class="strong"><strong>Your identification has been saved in /home/edwardrobinson/.ssh/id_rsa.</strong></span><span class="strong"><strong>Your public key has been saved in /home/edwardrobinson/.ssh/id_rsa.</strong></span><span class="strong"><strong>The key fingerprint is:</strong></span><span class="strong"><strong>SHA256:noWDFhnDxcvFl7DGi6EnF9EM5yeRMfGX1wt85wnbxxQ email@example.com</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Once you have an SSH key <span>pair</span><a id="id326462926" class="indexterm"></a> on your machine, you can go about importing it into your AWS account. Remember that you only need to import the public part of your key pair. This will be in a file that ends with the <code class="literal">.pub</code> extension.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>From the AWS EC2 console (click on <strong class="userinput"><code>Services</code></strong> and then search for <strong class="userinput"><code>EC2</code></strong>), choose <span class="strong"><strong>Key Pairs</strong></span> from the menu on the left of the screen, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788390071/graphics/7e427a6a-beba-48a7-b07b-a69d1549a5f6.png" /></div><p></p><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>From this screen, choose <span class="strong"><strong>Import Key Pair</strong></span> to bring up a dialog where you can upload your key pair, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788390071/graphics/c032b4cb-114c-4190-8826-3341069f3490.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Choose a name that will identify your key pair within AWS (I chose <code class="literal">eds_laptop</code>). Then, either navigate to your key's location or just paste its text into the large text box, and then click <span class="strong"><strong>Import</strong></span>. Once you have imported your key, you should see it listed on the <span class="strong"><strong>Key Pairs</strong></span> page.</li></ol></div><p>If you are using AWS in more than one region, you will need to import a key pair in each region that you want to launch instances in.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"></a>Preparing the network</h3></div></div></div><p>We will set up a new VPC in your AWS account. A VPC, or virtual private cloud, allows us to have a <span>private</span><a id="id326342732" class="indexterm"></a> network that is isolated from all the other users of EC2 and the internet that we can launch instances onto.</p><p>It provides a secure foundation that we can use to build a secure network for our cluster, as shown in the following command:</p><pre class="programlisting"><span class="strong"><strong>$ VPC_ID=$(aws ec2 create-vpc --cidr-block 10.0.0.0/16 --query "Vpc.VpcId" --output text)</strong></span></pre><p>The <code class="literal">VpcId</code> will be unique to your account, so I am going to set a shell variable that I can use to refer to it whenever we need. You can do the same with the <code class="literal">VpcId</code> from your account, or you might prefer to just type it out each time you need it.</p><p>The rest of the steps in this chapter follow this pattern, but if you don't understand what is happening, don't be afraid to look at the shell variables and correlate the IDs with the resources in the AWS console, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ echo $VPC_ID</strong></span></pre><p>Kubernetes names your instances based on the internal DNS hostnames that AWS assigns to them. If we enable DNS support in the VPC, then we will be able to resolve these hostnames when using the DNS server provided inside the VPC, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ aws ec2 modify-vpc-attribute \</strong></span><span class="strong"><strong>--enable-dns-support \</strong></span><span class="strong"><strong>--vpc-id $VPC_ID</strong></span><span class="strong"><strong>$ aws ec2 modify-vpc-attribute \</strong></span><span class="strong"><strong>--enable-dns-hostnames \</strong></span><span class="strong"><strong>--vpc-id $VPC_ID</strong></span></pre><p>Kubernetes makes extensive use of AWS resource tags, so it knows which resources it can use and which resources are managed by Kubernetes. The key for these tags is <code class="literal">kubernetes.io/cluster/&lt;cluster_name&gt;</code>. For resources that might be shared between several distinct clusters, we use the <code class="literal">shared</code> value. This means that Kubernetes can make use of them, but won't ever remove them from your account.</p><p>We would use this for resources such as VPCs. Resources where the life cycle is fully managed by Kubernetes have a tag value of <code class="literal">owned</code> and may be deleted by Kubernetes if they are no longer required. Kubernetes typically creates these tags automatically when it creates resources such as instances in an autoscaling group, EBS volumes, or load balancers.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>I like to name the clusters I create after famous people from the history of computer science. The cluster I created for this chapter is named after Grace Hopper, who designed the COBOL programming language.</p></div><p>Let's add a tag to our new VPC so that Kubernetes will be able to use it, as shown in the following command:</p><pre class="programlisting"><span class="strong"><strong>aws ec2 create-tags \</strong></span><span class="strong"><strong>--resources $VPC_ID \</strong></span><span class="strong"><strong>--tags Key=Name,Value=hopper \</strong></span><span class="strong"><strong>Key=kubernetes.io/cluster/hopper,Value=shared</strong></span></pre><p>When we created our VPC, a main route table was automatically created. We will use this for routing in our private subnet. Let's grab the ID to use later, as shown in the following command:</p><pre class="programlisting"><span class="strong"><strong>$ PRIVATE_ROUTE_TABLE_ID=$(aws ec2 describe-route-tables \</strong></span><span class="strong"><strong>--filters Name=vpc-id,Values=$VPC_ID \</strong></span><span class="strong"><strong>--query "RouteTables[0].RouteTableId" \</strong></span><span class="strong"><strong>--output=text)</strong></span></pre><p>Now we will add a second route table to manage routing for the public subnets in our VPC, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ PUBLIC_ROUTE_TABLE_ID=$(aws ec2 create-route-table \</strong></span><span class="strong"><strong>--vpc-id $VPC_ID \</strong></span><span class="strong"><strong>--query "RouteTable.RouteTableId" --output text)</strong></span></pre><p>Now we will give the route tables names so we can keep track of them later:</p><pre class="programlisting"><span class="strong"><strong>$ aws ec2 create-tags \</strong></span><span class="strong"><strong>--resources $PUBLIC_ROUTE_TABLE_ID \</strong></span><span class="strong"><strong>--tags Key=Name,Value=hopper-public</strong></span><span class="strong"><strong>$ aws ec2 create-tags \</strong></span><span class="strong"><strong>--resources $PRIVATE_ROUTE_TABLE_ID \</strong></span><span class="strong"><strong>--tags Key=Name,Value=hopper-private</strong></span></pre><p>Next, we are going to create two subnets for our cluster to use. Because I am creating my cluster in the <code class="literal">eu-west-1</code> region (Ireland), I am going to create these subnets in the <code class="literal">eu-west-1a</code> subnet. You should choose an availability zone for your cluster from the region you are using by running <code class="literal">aws ec2 describe-availability-zones</code>. In <span>Part 3</span>, we will learn how to create high-availability clusters that span multiple availability zones.</p><p>Let's start by creating a subnet for instances that will only be accessible from within our private network. We are going to use a <code class="literal">/20 netmask</code> on the CIDR block, as shown in the following command; with this, AWS will give us 4089 IP addresses that will be available to be assigned to our EC2 instances and to pods launched by Kubernetes:</p><pre class="programlisting"><span class="strong"><strong>$ PRIVATE_SUBNET_ID=$(aws ec2 create-subnet \</strong></span><span class="strong"><strong>--vpc-id $VPC_ID \
</strong></span><span class="strong"><strong>--availability-zone eu-west-1a \</strong></span><span class="strong"><strong>--cidr-block 10.0.0.0/20 --query "Subnet.SubnetId" \</strong></span><span class="strong"><strong>--output text)</strong></span><span class="strong"><strong>$ aws ec2 create-tags \</strong></span><span class="strong"><strong>--resources $PRIVATE_SUBNET_ID \</strong></span><span class="strong"><strong>--tags Key=Name,Value=hopper-private-1a \</strong></span><span class="strong"><strong>Key=kubernetes.io/cluster/hopper,Value=owned \</strong></span><span class="strong"><strong>Key=kubernetes.io/role/internal-elb,Value=1</strong></span></pre><p>Next, let's add another subnet to the <span>same</span><a id="id325198186" class="indexterm"></a> availability zone, as shown in the following command. We will use this subnet for instances that need to be accessible from the internet, such as public load balancers and bastion hosts:</p><pre class="programlisting"><span class="strong"><strong>$ PUBLIC_SUBNET_ID=$(aws ec2 create-subnet \</strong></span><span class="strong"><strong>--vpc-id $VPC_ID \</strong></span><span class="strong"><strong> --availability-zone eu-west-1a \</strong></span><span class="strong"><strong>  --cidr-block 10.0.16.0/20 --query "Subnet.SubnetId" \</strong></span><span class="strong"><strong> --output text)</strong></span><span class="strong"><strong>$ aws ec2 create-tags \</strong></span><span class="strong"><strong>  --resources $PUBLIC_SUBNET_ID \</strong></span><span class="strong"><strong>  --tags Key=Name,Value=hopper-public-1a \</strong></span><span class="strong"><strong>Key=kubernetes.io/cluster/hopper,Value=owned \</strong></span><span class="strong"><strong>Key=kubernetes.io/role/elb,Value=1</strong></span></pre><p>Next, we should associate this subnet with the public route table, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ aws ec2 associate-route-table \</strong></span><span class="strong"><strong>--subnet-id $PUBLIC_SUBNET_ID \</strong></span><span class="strong"><strong>--route-table-id $PUBLIC_ROUTE_TABLE_ID</strong></span></pre><p>In order for the instances in our public subnet to communicate with the internet, we will create an internet gateway, attach it to our VPC, and then add a route to the route table, routing traffic bound for the internet to the gateway, as shown in the following command:</p><pre class="programlisting"><span class="strong"><strong>$ INTERNET_GATEWAY_ID=$(aws ec2 create-internet-gateway \</strong></span><span class="strong"><strong>--query "InternetGateway.InternetGatewayId" --output text)</strong></span><span class="strong"><strong>$ aws ec2 attach-internet-gateway \</strong></span><span class="strong"><strong>--internet-gateway-id $INTERNET_GATEWAY_ID \</strong></span><span class="strong"><strong>--vpc-id $VPC_ID</strong></span><span class="strong"><strong>$ aws ec2 create-route \</strong></span><span class="strong"><strong>--route-table-id $PUBLIC_ROUTE_TABLE_ID \</strong></span><span class="strong"><strong>--destination-cidr-block 0.0.0.0/0 \</strong></span><span class="strong"><strong>--gateway-id $INTERNET_GATEWAY_ID</strong></span></pre><p>In order to configure the instances in the private subnet, we will need them to be able to make outbound connections to the internet in order to install software packages and so on. To make this possible, we will add a NAT gateway to the public subnet and then add a route to the private route table for internet-bound traffic, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ NAT_GATEWAY_ALLOCATION_ID=$(aws ec2 allocate-address \</strong></span><span class="strong"><strong>--domain vpc --query AllocationId --output text)</strong></span><span class="strong"><strong>$ NAT_GATEWAY_ID=$(aws ec2 create-nat-gateway \</strong></span><span class="strong"><strong>--subnet-id $PUBLIC_SUBNET_ID \</strong></span><span class="strong"><strong>--allocation-id $NAT_GATEWAY_ALLOCATION_ID \</strong></span><span class="strong"><strong>--query NatGateway.NatGatewayId --output text)</strong></span></pre><p>At this stage, you may have to wait a few moments for the NAT gateway to be created before creating the route, as shown in the following command:</p><pre class="programlisting"><span class="strong"><strong>$ aws ec2 create-route \</strong></span><span class="strong"><strong>--route-table-id $PRIVATE_ROUTE_TABLE_ID \</strong></span><span class="strong"><strong>--destination-cidr-block 0.0.0.0/0 \</strong></span><span class="strong"><strong>--nat-gateway-id $NAT_GATEWAY_ID</strong></span></pre></div></div>