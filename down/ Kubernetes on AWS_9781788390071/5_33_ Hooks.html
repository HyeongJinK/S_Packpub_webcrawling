<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec37"></a>Hooks</h2></div></div><hr /></div><p>So far, we have been using Helm to <span>help</span><a id="id325162570" class="indexterm"></a> us generate the resources our applications need to be submitted to Kubernetes. In the ideal world, this would be all that we would need a tool like Helm to do. Kubernetes aims to be declarative; in other words, we submit resources describing what we want the state of the cluster to look like, and Kubernetes handles the rest.</p><p>Unfortunately, in the real world, sometimes we still need to explicitly take some actions to get our applications running correctly. Perhaps when you install your application, you need to run a script to initialize a database schema or set up some default users. Perhaps when you install a new version of an application, you need to run a script to migrate the schema of your database to be compatible with the new version of the application.</p><p>Helm provides a hook mechanism that allows us to take actions at eight specific points in the life cycle of a release. In order to define a hook in your Helm chart, you add the <code class="literal">helm.sh/hook</code> annotation to a resource. You can use the hook annotation on any resource to ensure that it is created at the appropriate time. But typically, it is very useful to create resources of the job type. If your resource is of the job type, Tiller will block until the job has successfully run to completion. This means that if you are using one of the <code class="literal">pre-</code> hooks then your application can depend on that job having run.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">pre-install</code>: This action runs after Tiller has rendered the templates in a chart, but before any resources have been submitted to the Kubernetes API. This action runs when a new release is created by installing a chart. If you also need a hook to run when a release is upgraded, you should combine this hook with the <code class="literal">pre-upgrade</code> hook. You might make use of this hook to initialize resources that will be used by your application.</li><li style="list-style-type: disc"><code class="literal">post-install</code>: This action runs after all the resources have been submitted to the Kubernetes API. You might, for example, use this to run a script that provides notifications to a chatroom or to register the new instance of the chart with a monitoring tool.</li><li style="list-style-type: disc"><code class="literal">pre-delete</code>: This hook runs before any resources are deleted from Kubernetes when a deletion request is made. This could be useful, for example, if you needed to make a backup of data stored by your application.</li><li style="list-style-type: disc"><code class="literal">post-delete</code>: This hook runs after Helm has deleted the resources created as part of a release. You might utilize this hook to clean up any external resources that your application uses that are not managed by Helm or Kubernetes.</li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">pre-upgrade</code>: This hook provides the same functionality as the <code class="literal">pre-install</code> hook, but runs each time a release is upgraded. You might use this hook to run a database migration script.</li><li style="list-style-type: disc"><code class="literal">post-upgrade</code>: This hook provides the same functionality as the <code class="literal">post-install</code> hook, but runs each time a release is upgraded. Again, this might be used for notification purposes.</li><li style="list-style-type: disc"><code class="literal">pre-rollback</code>: This hook runs before changes to rollback an upgrade of a release is submitted to the Kubernetes API.</li><li style="list-style-type: disc"><code class="literal">post-rollback</code>: This hook runs after a request to rollback an upgrade of the release has been submitted to Kubernetes. Depending on the expectations of your application, you might run scripts to roll back database changes here or in the <code class="literal">pre-rollback</code> hook.</li><li style="list-style-type: disc">Let's look at an example, where we will be using a hook to run a setup script:</li></ul></div><pre class="programlisting">apiVersion: batch/v1 
kind: Job 
metadata: 
  name: "{{.Release.Name}}-setup" 
  labels: 
    heritage: {{.Release.Service | quote }} 
    release: {{.Release.Name | quote }} 
    chart: "{{.Chart.Name}}-{{.Chart.Version}}" 
  annotations: 
    "helm.sh/hook": pre-install 
spec: 
  template: 
    metadata: 
      name: "{{.Release.Name}}-setup" 
    labels: 
      heritage: {{.Release.Service | quote }} 
      release: {{.Release.Name | quote }} 
      chart: "{{.Chart.Name}}-{{.Chart.Version}}" 
    spec: 
      restartPolicy: Never 
      containers: 
      - name: setup 
        image: errm/awesome-application 
        command: ["bin/setup"] </pre><p>Everything about the definition of this job is the same as the standard Kubernetes resource definition that we looked at in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Managing Change in Your Applications</em></span>. It is the annotation added to the job metadata that enables Helm to treat this definition as a hook rather than a managed part of our application.</p><p>A single resource can be used to implement multiple hooks. For example, if you wanted the setup script to be run each time the release is updated as well as when it is first installed, we could change the hook annotation to:</p><pre class="programlisting">annotations: 
  "helm.sh/hook": pre-install,pre-upgrade </pre><p>Helm allows you to create any Kubernetes resource using the hook mechanism. This might be useful if, for example, a job created using a hook depends on a <code class="literal">ConfigMap</code> or <code class="literal">Secret</code>.</p><p>If you have multiple hook resources <span>that</span><a id="id325750939" class="indexterm"></a> need to be created in a specific order, you can use the <code class="literal">helm.sh/hook-weight</code> annotation. This weight can be any positive or negative integer number. When Helm evaluates a particular hook, the resources will be sorted by these weights in ascending order. Since annotations can only hold strings, it is important to quote the number used in a hook weight.</p><p>For example, a resource with the annotation <code class="literal">"helm.sh/hook-weight": "-5"</code> would be run before <code class="literal">"helm.sh/hook-weight": "5"</code>, but would be run after a resource with the annotation <code class="literal">"helm.sh/hook-weight": "-10"</code>.</p><p>There is one wrinkle in Helm's hook system that can be quite confusing at first, but luckily, once you understand it, there are some simple ways to work around it.</p><p>Helm keeps track of nearly all of the resources you create with your templates. This means that when you upgrade a release, Helm can update all of the resources managed by the release, and when a release is deleted, Helm can remove all of the resources that it created. The one exception to this is the resources created by hooks. Once they are created, Helm no longer manages them and Kubernetes takes over.</p><p>This can cause two different issues when using them in your charts:</p><p>Firstly, when a chart is deleted, the resources created by hooks won't be deleted. This can unexpectedly use up resources in your cluster unless the resources are manually deleted. Secondly, if you are using a hook that can be called more than once in the life of a chart release, the names of your resources can clash.</p><p>With our example job, to run a setup script if we had updated the hook annotation to <code class="literal">"helm.sh/hook": pre-install,pre-upgrade</code>, we would have found that the job would run correctly when the chart was installed, but when we come to upgrade the release, Helm would try to create a new job with the same name as the job already created in the <code class="literal">pre-install</code> hook. This would cause an error, which would prevent the upgrade from proceeding.</p><p>One way to work around this issue would be to include the release revision number in the name of job, as in the following:</p><pre class="programlisting">metadata: 
  name: "{{.Release.Name}}-setup-{{ Release.Revision }}" </pre><p>While this does prevent job names from colliding, it does mean that each upgrade of a release will create a new resource, all of which may need to be cleaned up manually when they are no longer required.</p><p>Helm provides one more annotation to assist us with this issue. The <code class="literal">helm.sh/hook-delete-policy</code> allows us to instruct Helm to delete a resource after it has been successfully executed, or after it fails, or both.</p><p>The annotation <code class="literal">"helm.sh/hook-delete-policy": hook-succeeded</code> is useful for the majority of use cases, such as the setup script job example. If the job runs successfully, it is deleted, cleaning up the resource ready for a new instance to be created with the same name the next time the chart is upgraded. If the job fails, it is left as is on the Kubernetes server so it could be inspected for debugging purposes.</p><p>If you are using Helm as part of an automated workflow, where it is important to ensure all of the resources created by installing a chart are deleted, whatever the outcome, you might want to use the following annotation:</p><p><code class="literal">"helm.sh/hook-delete-policy": hook-succeeded,hook-failed</code></p></div>