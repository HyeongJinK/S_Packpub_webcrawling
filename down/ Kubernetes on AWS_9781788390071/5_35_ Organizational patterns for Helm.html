<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec39"></a>Organizational patterns for Helm</h2></div></div><hr /></div><p>Within an organization using Kubernetes to <span>deploy</span><a id="id325162570" class="indexterm"></a> its own applications, there are a few strategies that you might want to consider in order to produce and maintain charts to manage deploying the applications that you use.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec54"></a>Chart per application</h3></div></div></div><p>The simplest way to use <span>Helm</span><a id="id325268180" class="indexterm"></a> within your organization is to create a new chart for each application that you want to deploy to Kubernetes.</p><p>When you have an application that might be deployed to a number of different contexts, such as testing, staging, and production environments, this can make sure that you have parity between each environment while making it simple to provide overrides for the configuration that might be environment-specific.</p><p>Creating Helm charts for your applications can help in larger organizations where applications might need to be deployed to a number of different environments without the help of the team that builds and manages the application.</p><p>For example, mobile app or frontend web developers might deploy a backend API application developed by another team to a testing or development environment using Helm. If the team that develops the backend provides a Helm chart, they make it simple for other teams to deploy without needing in-depth knowledge of how to install and configure the app.</p><p>If the same Helm chart is used to deploy to production as well as the testing and development environments, it is simpler to reduce the otherwise inevitable drift between production and development environments.</p><p>It is simple to use the control flow features of the Helm templating language to provide different configurations where appropriate. For example, in staging or production environments, your application might rely on saving data to an EBS volume, whereas on development machines, the application might simply save to a local volume.</p><p>You might need to override some values when your chart is deployed. For example, you might want to run many more replicas of a pod in a production environment, whereas on a development machine, a single replica might be sufficient.</p><p>If your application can be scaled horizontally by adding more replicas of a pod, it makes sense to provide the same memory and CPU limits in all environments and then scale up for production traffic by adding additional pods, rather than giving each pod greater resource limits. This makes it much simpler to debug issues with applications being killed due to out-of-memory errors or being starved of CPU resources, since a single pod will have the same resources on your development and production clusters.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec55"></a>Shared charts</h3></div></div></div><p>If your organization maintains a <span>service</span><a id="id325268234" class="indexterm"></a> or micro-service based system, it is common to maintain some level of standardization between the different services that you deploy.</p><p>One way of maintaining a consistent pattern of deployment between each of your applications is to provide a Helm chart that can be used to deploy all of your services.</p><p>If you do this, you will find that the configuration you need to provide to the chart and the templates themselves becomes more complex. But the advantage of working this way is it lets you quickly apply new configuration best practices to all of your applications.</p><p>In the simpler Helm chart, we provided a new template for each pod that would form part of our application. When a chart is to be reused by a number of applications, there might be different pods required by each one.</p><p>For example, one application might require a web server and a batch job to run every hour, while another service provides an admin interface and a worker for processing background jobs from a message queue.</p><p>To be able to deploy two different applications with these different sorts of pods using one chart, you need to produce a templateâ€”not for each pod in your application, but for each type of pod that your service contract supports.</p><p>For example, you might have one template for long-running pods that are managed with Kubernetes Deployment Resources, and another template for managing batch jobs with the <code class="literal">CronJob</code> resource. To then enable and configure each of these templates, you can provide a list of each of the pods that your application requires in the values passed when you deploy your application.</p><p>I have made an example chart that takes this approach. It is available at <a class="ulink" href="https://github.com/errm/charts/tree/master/app" target="_blank">https://github.com/errm/charts/tree/master/app</a><span>.</span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec56"></a>Library charts</h3></div></div></div><p>If your organization has configuration <span>and</span><a id="id325747125" class="indexterm"></a> deployment patterns that you want to share between different applications, but the shared chart approach doesn't provide enough flexibility or results in overly complex logic in your templates, one alternative is to provide library charts that include templates or functions that can be used as dependencies of your application to provide common components or configuration to each chart that needs them.</p><p>This can provide you with some of the benefits of both approaches through being able to tailor your chart to a specific application, whilst still being able to use shared functionality, to reduce duplication of configuration or to enforce best practices or other organization-wide deployment patterns.</p></div></div>