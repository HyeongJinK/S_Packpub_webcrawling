<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec34"></a>Installing Helm</h2></div></div><hr /></div><p>If you have already set up your <span>own</span><a id="id325268218" class="indexterm"></a> Kubernetes cluster and have correctly configured <code class="literal">kubectl</code> on your machine, then it is simple to install Helm.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec40"></a>macOS</h3></div></div></div><p>On macOS, the simplest way to install the <span>Helm</span><a id="id325981885" class="indexterm"></a> client is with Homebrew:</p><pre class="programlisting"><span class="strong"><strong>$ brew install kubernetes-helm</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec41"></a>Linux and Windows</h3></div></div></div><p>Every release of H<span>elm</span><a id="id325981907" class="indexterm"></a> includes <span>prebuilt</span><a id="id325981915" class="indexterm"></a> binaries for Linux, Windows, and macOS. Visit <span><a class="ulink" href="https://github.com/kubernetes/helm/releases" target="_blank">https://github.com/kubernetes/helm/releases</a></span> to download the version you need for your platform.</p><p>To install the client, simply unpack and copy the binary onto your path.</p><p>For example, on a Linux machine you might do the following:</p><pre class="programlisting"><span class="strong"><strong>$ tar -zxvf helm-v2.7.2-linux-amd64.tar.gz</strong></span><span class="strong"><strong>$ mv linux-amd64/helm /usr/local/bin/helm</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec42"></a>Installing Tiller</h3></div></div></div><p>Once you have the Helm CLI <span>tool</span><a id="id325985057" class="indexterm"></a> installed on your machine, you can go about installing Helm's server-side component, Tiller.</p><p>Helm uses the same configuration as <code class="literal">kubectl</code>, so start by checking which context you will be installing Tiller onto:</p><pre class="programlisting"><span class="strong"><strong>$ kubectl config current-context</strong></span><span class="strong"><strong>minikube</strong></span></pre><p>Here, we will be installing Tiller into the cluster referenced by the Minikube context. In this case, this is exactly what we want. If your <code class="literal">kubectl</code> is not currently pointing to another cluster, you can quickly switch to the context you want to use like this:</p><pre class="programlisting"><span class="strong"><strong>$ kubectl config use-context minikube</strong></span></pre><p>If you are still not sure that you are using the correct context, take a quick look at the full config and check that the cluster server field is correct:</p><pre class="programlisting"><span class="strong"><strong>$ kubectl config view --minify=true</strong></span></pre><p>The <code class="literal">minify</code> flag removes any config not referenced by the current context. Once you are happy that the cluster that <code class="literal">kubectl</code> is connecting to is the correct one, we can set up Helm's local environment and install Tiller on to your cluster:</p><pre class="programlisting"><span class="strong"><strong>$ helm init</strong></span><span class="strong"><strong>$HELM_HOME has been configured at /Users/edwardrobinson/.helm.</strong></span><span class="strong"><strong>Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.</strong></span><span class="strong"><strong>Happy Helming!</strong></span></pre><p>We can use <code class="literal">kubectl</code> to check that Tiller is indeed running on our cluster:</p><pre class="programlisting"><span class="strong"><strong>$ kubectl -n kube-system get deploy -l app=helm</strong></span><span class="strong"><strong>NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</strong></span><span class="strong"><strong>tiller-deploy   1         1         1            1           3m</strong></span></pre><p>Once we have verified that Tiller is correctly running on the cluster, let's use the <code class="literal">version</code> command. This will validate that we are able to connect correctly to the API of the Tiller server and return the version number of both the CLI and the Tiller server:</p><pre class="programlisting"><span class="strong"><strong>$ helm version</strong></span><span class="strong"><strong>Client: &amp;version.Version{SemVer:"v2.7.2", GitCommit:"8478fb4fc723885b155c924d1c8c410b7a9444e6", GitTreeState:"clean"}</strong></span><span class="strong"><strong>Server: &amp;version.Version{SemVer:"v2.7.2", GitCommit:"8478fb4fc723885b155c924d1c8c410b7a9444e6", GitTreeState:"clean"}</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec43"></a>Installing a chart</h3></div></div></div><p>Let's start by <span>installing</span><a id="id325992408" class="indexterm"></a> an application by using one of the charts provided by the community.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note37"></a>Note</h3><p>You can discover applications that the community has produced Helm charts for at <a class="ulink" href="https://hub.kubeapps.com/" target="_blank"><span>https://hub.kubeapps.com/</span></a>. As well as making it simple to deploy a wide range of applications to your Kubernetes cluster, it's a great resource for learning some of the best practices the community uses when packaging applications for Helm.</p></div><p>Helm charts can be stored in a repository, so it is simple to install them by name. By default, Helm is <span>already</span><a id="id326027997" class="indexterm"></a> configured to use one remote repository called <span class="strong"><strong>Stable</strong></span>.</p><p>This makes it simple for us to try out some commonly used applications as soon as Helm is installed.</p><p>Before you install a chart, you will need to know three things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The name of the chart you want to install</li><li style="list-style-type: disc">The name you will give to this release (If you omit this, Helm will create a random name for this release)</li><li style="list-style-type: disc">The namespace on the cluster you want to install the chart into (If you omit this, Helm will use the default namespace)</li></ul></div><p>Helm calls each distinct installation of a particular chart a release. Each release has a unique name that is used if you later want to update, upgrade, or even remove a release from your cluster. Being able to install multiple instances of a chart onto a single cluster makes Helm a little bit different from how we think about traditional package managers that are tied to a single machine, and typically only allow one installation of a particular package at once. But once you have got used to the terminology, it is very simple to understand:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">A <span class="strong"><strong>chart</strong></span> is the package that contains all the information about <span class="emphasis"><em>how</em></span> to install a particular application or tool to the cluster. You can think of it as a template that can be reused to create many different instances or releases of the packaged application or tool.</li><li style="list-style-type: disc">A <span class="strong"><strong>release</strong></span> is a named installation of a chart to a particular cluster. By referring to a release by name, Helm can make upgrades to a particular release, updating the version of the installed tool, or making configuration changes.</li><li style="list-style-type: disc">A <span class="strong"><strong>repository</strong></span> is an HTTP server storing charts along with an index file. When configured with the location of a repository, the Helm client can install a chart from that repository by downloading it and then making a new release.</li></ul></div><p>Before you can install a chart onto your cluster, you need to make sure that Helm knows about the repository that you want to use. You can list the repositories that are currently in use by running the <code class="literal">helm repo list</code> command:</p><pre class="programlisting"><span class="strong"><strong>$ helm repo list</strong></span><span class="strong"><strong>NAME   URL</strong></span><span class="strong"><strong>stable https://kubernetes-charts.storage.googleapis.com</strong></span><span class="strong"><strong>local  http://127.0.0.1:8879/charts</strong></span></pre><p>By default, Helm is configured with a repository named stable pointing at the community chart repository and local repository that points at a local address for testing your own local repository. (You need to be running <code class="literal">helm serve</code> for this.)</p><p>Adding a Helm repository to this list is simple with the <code class="literal">helm repo add</code> command. You can add my Helm repository that contains some example applications related to this book by running the following command:</p><pre class="programlisting"><span class="strong"><strong>$ helm repo add errm https://charts.errm.co.uk</strong></span><span class="strong"><strong>"errm" has been added to your repositories</strong></span></pre><p>In order to pull the latest chart information from the configured repositories, you can run the following command:</p><pre class="programlisting"><span class="strong"><strong>$ helm repo update</strong></span><span class="strong"><strong>Hang tight while we grab the latest from your chart repositories...</strong></span><span class="strong"><strong>...Skip local chart repository</strong></span><span class="strong"><strong>...Successfully got an update from the "errm" chart repository</strong></span><span class="strong"><strong>...Successfully got an update from the "stable" chart repository</strong></span><span class="strong"><strong>Update Complete.  Happy Helming!</strong></span></pre><p>Let's start with one of the simplest applications available in my Helm repository, <code class="literal">kubeslate</code>. This provides some very basic information about your cluster, such as the version of Kubernetes you are running and the number of pods, deployments, and services in your cluster. We are going to start with this application, since it is very simple and doesn't require any special configuration to run on Minikube, or indeed any other cluster.</p><p>Installing a chart from a repository on your cluster couldn't be simpler:</p><pre class="programlisting"><span class="strong"><strong>$ helm install --name=my-slate errm/kubeslate</strong></span></pre><p>You should see a lot of output from the <code class="literal">helm</code> command.</p><p>Firstly, you will see some metadata about the release, such as its name, status, and namespace:</p><pre class="programlisting"><span class="strong"><strong>NAME:   my-slate</strong></span><span class="strong"><strong>LAST DEPLOYED: Mon Mar 26 21:55:39 2018</strong></span><span class="strong"><strong>NAMESPACE: default</strong></span><span class="strong"><strong>STATUS: DEPLOYED</strong></span></pre><p>Next, you should see some information about the resources that Helm has instructed Kubernetes to create on the cluster. As you can see, a single service and a single deployment have been created:</p><pre class="programlisting"><span class="strong"><strong>RESOURCES:</strong></span><span class="strong"><strong>==&gt; v1/Service</strong></span><span class="strong"><strong>NAME                TYPE       CLUSTER-IP     PORT(S)  AGE</strong></span><span class="strong"><strong>my-slate-kubeslate  ClusterIP  10.100.209.48  80/TCP   0s</strong></span><span class="strong"><strong>==&gt; v1/Deployment</strong></span><span class="strong"><strong>NAME                DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE</strong></span><span class="strong"><strong>my-slate-kubeslate  2        0        0           0          0s</strong></span><span class="strong"><strong>==&gt; v1/Pod(related)</strong></span><span class="strong"><strong>NAME                                 READY  STATUS             AGE</strong></span><span class="strong"><strong>my-slate-kubeslate-77bd7479cf-gckf8  0/1    ContainerCreating  0s
my-slate-kubeslate-77bd7479cf-vvlnz 0/1 ContainerCreating 0s</strong></span></pre><p>Finally, there is a section with some <span>notes</span><a id="id326080969" class="indexterm"></a> that have been provided by the chart's author to give us some information about how to start using the application:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note38"></a>Note</h3><p><span class="strong"><strong>Notes</strong></span>:
To access <code class="literal">kubeslate</code>.
</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>First start the kubectl proxy:</li></ol></div><p><code class="literal"><span class="strong"><strong>kubectl proxy</strong></span></code></p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Now open the following URL in your browser:</li></ol></div><p><code class="literal"><span class="strong"><strong>http://localhost:8001/api/v1/namespaces/default/services/my-slate-kubeslate:http/proxy</strong></span></code></p><p>Please try reloading the page if you see <code class="literal">ServiceUnavailable / no endpoints available for service</code>, as pod creation might take a few moments.</p></div><p>Try following these instructions yourself and open Kubeslate in your browser:</p><div class="mediaobject"><img src="/graphics/9781788390071/graphics/7239b71c-290e-412a-b778-2c3a6de94e75.png" /></div><p>Kubeslate deployed with Helm</p></div></div>