<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec35"></a>Configuring a chart</h2></div></div><hr /></div><p>When you use Helm to make a <span>release</span><a id="id325162570" class="indexterm"></a> of a chart, there are certain attributes that you might need to change, or configuration you might need to provide. Luckily, Helm provides a standard way for users of a chart to override some or all of the configuration values.</p><p>In this section, we are going to look at how, as the user of a chart, you might go about supplying configuration to Helm. Later in the chapter, we are going to look at how you can create your own charts and use the configuration passed in to allow your chart to be customized.</p><p>When we invoke <code class="literal">helm install</code>, there are two ways we can provide configuration values: passing them as command-line arguments, or by providing a configuration file.</p><p>These configuration values are merged with the default values provided by a chart. This allows a chart author to provide a default configuration to allow users to get up and running quickly, but still allow users to tweak important settings, or enable advanced features.</p><p>Providing a single value to Helm on the command line is achieved by using the set flag. The <code class="literal">kubeslate</code> chart allows us to specify additional labels for the pod(s) that it launches using the <code class="literal">podLabels</code> variable. Let's make a new release of the kubeslate chart, and then use the <code class="literal">podLabels</code> variable to add an additional <code class="literal">hello</code> label with the value <code class="literal">world</code>:</p><pre class="programlisting"><span class="strong"><strong>$ helm install --name labeled-slate --set podLabels.hello=world errm/kubeslate</strong></span></pre><p>Once you have run this command, you should be able to prove that the extra variable you passed to Helm did indeed result in the pods launched by Helm having the correct label. Using the <code class="literal">kubectl get pods</code> command with a label selector for the label we applied using Helm should return the pods that have just been launched with Helm:</p><pre class="programlisting"><span class="strong"><strong>$ kubectl get pods -l hello=world</strong></span><span class="strong"><strong>NAME                                      READY     STATUS</strong></span><span class="strong"><strong>labeled-slate-kubeslate-5b75b58cb-7jpfk   1/1       Running</strong></span><span class="strong"><strong>labeled-slate-kubeslate-5b75b58cb-hcpgj   1/1       Running</strong></span></pre><p>As well as being able to pass a configuration to Helm when we create a new release, it is also possible to update the configuration in a pre-existing release using the upgrade command. When we use Helm to update a configuration, the process is much the same as when we updated deployment resources in the last chapter, and a lot of those considerations still apply if we want to avoid downtime in our services. For example, by launching multiple replicas of a service, we can avoid downtime, as a new version of a deployment configuration is rolled out.</p><p>Let's also upgrade our original kubeslate release to include the same <code class="literal">hello: world pod</code> label that we applied to the second release. As you can see, the structure of the <code class="literal">upgrade</code> command is quite similar to the <code class="literal">install</code> command. But rather than specifying the name of the release with the <code class="literal">--name</code> flag, we pass it as the first argument. This is because when we install a chart to the cluster, the name of the release is optional. If we omit it, Helm will create a random name for the release. However, when performing an upgrade, we need to target a pre-existing release to upgrade, and thus this argument is mandatory:</p><pre class="programlisting"><span class="strong"><strong>$ helm upgrade my-slate --set podLabels.hello=world errm/kubeslate</strong></span></pre><p>If you now run <code class="literal">helm ls</code>, you should see that the release named <code class="literal">my-slate</code> has been upgraded to Revision 2. You can test that the deployment managed by this release has been upgraded to include this pod label by repeating our <code class="literal">kubectl get</code> command:</p><pre class="programlisting"><span class="strong"><strong>$ kubectl get pods -l hello=world</strong></span><span class="strong"><strong>NAME                                      READY     STATUS</strong></span><span class="strong"><strong>labeled-slate-kubeslate-5b75b58cb-7jpfk   1/1       Running</strong></span><span class="strong"><strong>labeled-slate-kubeslate-5b75b58cb-hcpgj   1/1       Running</strong></span><span class="strong"><strong>my-slate-kubeslate-5c8c4bc77-4g4l4        1/1       Running</strong></span><span class="strong"><strong>my-slate-kubeslate-5c8c4bc77-7pdtf        1/1       Running</strong></span></pre><p>We can now see that four pods, two from each of our releases, now match the label selector we passed to <code class="literal">kubectl get</code>.</p><p>Passing variables on the command line with the <code class="literal">set</code> flag is convenient when we just want to provide values for a few variables. But when we want to pass more complex configurations, it can be simpler to provide the values as a file. Let's prepare a configuration file to apply several labels to our kubeslate pods:</p><pre class="programlisting"><span class="strong"><strong>values.yml 
podLabels: 
  hello: world 
  access: internal 
  users: admin</strong></span></pre><p>We can then use the <code class="literal">helm</code> command to apply this configuration file to our release:</p><pre class="programlisting"><span class="strong"><strong>$ helm upgrade labeled-slate -f values.yml errm/kubeslate</strong></span></pre></div>