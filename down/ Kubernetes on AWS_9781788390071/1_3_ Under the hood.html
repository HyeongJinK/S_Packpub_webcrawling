<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>Under the hood</h2></div></div><hr /></div><p>Now we have learned a little <span>about</span><a id="id325162570" class="indexterm"></a> the functionality that Kubernetes provides to us, the user, let's go a little deeper and look at the components that Kubernetes uses to implement these features. Kubernetes makes this task a little easier for us by having a microservice architecture, so we can look at the function of each component in a certain degree of isolation.</p><p>We will get our hands dirty over the next few chapters by actually deploying and configuring these components ourselves. However for now, let's start by getting a basic understanding of the function of each of these components by looking at the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788390071/graphics/6868cebd-2b10-4d46-b5fc-0bd45b31eadf.png" /></div><p>The main Kubernetes components on the master node</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>API server</h3></div></div></div><p>The <span class="strong"><strong>API server</strong></span> acts as Kubernetes' central hub. All the other components in Kubernetes communicate by reading, watching, and updating resources in Kubernetes APIs. This central component is used for all of the access and manipulation of information <span>about</span><a id="id325750948" class="indexterm"></a> the current state of the cluster, allowing Kubernetes to be extended and augmented with new features while still maintaining a high degree of consistency.</p><p>Kubernetes uses etcd to store the current state of the cluster. An etcd store is used because its design means that it is both resistant to failure and has strong guarantees of its consistency. However, the different components that make up Kubernetes never directly interact with etcd; instead, they communicate with the API server. This is a good design for us, the operator of a cluster, because it allows us to restrict access to etcd only to the API server component, improving security and simplifying management.</p><p>While the API server is the component in the Kubernetes architecture that everything else communicates with to access or update the state, it is stateless itself, with all storage being deferred to the backing etcd cluster. This again is an ideal design decision for us as cluster operators since it allows us to deploy multiple instances of the API server (if we wish) to provide high availability.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"></a>Controller manager</h3></div></div></div><p>The <span class="strong"><strong>controller manager</strong></span> is the service that runs the core control loops (or controllers) that implement some of core functionality that makes Kubernetes function. Each of <span>these</span><a id="id325750971" class="indexterm"></a> controllers watches the state of the cluster through the API server and then makes changes to try and move the state of the cluster closer to the desired state. The design of the controller manager means that only one instance of it should be running at a given time; however, to simplify deployment in a high-availability configuration, the controller manager has a built-in leader election functionality, so that several instances can be deployed side by side, but only one will actually carry out work at any one time.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec12"></a>Scheduler</h3></div></div></div><p>The <span class="strong"><strong>scheduler</strong></span> is perhaps the single <span>most</span><a id="id325751180" class="indexterm"></a> important component that makes Kubernetes a useful and practical tool. It watches for new pods in the unscheduled state, and then analyzes the current state of the cluster with regard to running workloads, available resources, and other policy-based issues. It then decides the best place for that pod to be run in. As with the controller manager, a single instance of the scheduler works at any one time, but in a high-availability configuration, leader election is available.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec13"></a>Kubelet</h3></div></div></div><p>The <span class="strong"><strong>kubelet</strong></span> is the agent that <span>runs</span><a id="id325751200" class="indexterm"></a> on each node, and is responsible for launching pods. It doesn't directly run containers but instead controls a runtime, such as Docker or rkt. Typically, the kubelet watches the API server to discover which pods have been scheduled on its node.</p><p>The kubelet operates at the level of <code class="literal">PodSpec</code>, so it only knows how to launch pods. Any of the higher-level concepts in the Kubernetes API are implemented by controllers that ultimately create or destroy pods with a specific configuration.</p><p>The kubelet also <span>runs</span><a id="id325751216" class="indexterm"></a> a tool called <span class="strong"><strong>cadvisior</strong></span> that collects metrics about resource usage on the node, and using each container that is running on the node, this information can then be used by Kubernetes when making scheduling decisions.</p></div></div>