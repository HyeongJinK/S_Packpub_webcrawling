<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec65"></a>Pushing Docker images to ECR</h2></div></div><hr /></div><p>Currently, the most commonly <span>adopted</span><a id="id325162570" class="indexterm"></a> way to store and deliver Docker images is through Docker Registry, an open source application by Docker that hosts Docker repositories. This application can <span>be</span><a id="id325268173" class="indexterm"></a> deployed on-premises, as well as <span>used</span><a id="id325268193" class="indexterm"></a> as a service <span>from</span><a id="id325268199" class="indexterm"></a> multiple providers, such as <span class="strong"><strong>Docker Hub</strong></span>, <span class="strong"><strong>Quay.io</strong></span>, and <span class="strong"><strong>AWS ECR</strong></span>.</p><p>The application is a simple, stateless service, where most of the maintenance work involves making sure that storage is available, safe, and secure. As any seasoned system administrator knows, that is far from an easy ordeal, especially, if there is a large data store. For that reason, and especially if you're just starting out, it is highly recommended to use a hosted solution and let someone else deal with keeping your images safe and readily available.</p><p>ECR is AWS's approach to a hosted Docker registry, where there's one registry per account, uses AWS IAM to authenticate and authorize users to push and pull images. By default, the limits for both repositories and images are set to 1,000. As we'll see, the setup flow feels very similar to other AWS services, whilst also being familiar for Docker Registry users.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec91"></a>Creating a repository</h3></div></div></div><p>To create a repository, it's as simple as <span>executing</span><a id="id325231898" class="indexterm"></a> the following <code class="literal">aws ecr</code> command:</p><pre class="programlisting"><span class="strong"><strong>$ aws ecr create-repository --repository-name randserver</strong></span></pre><p>This will create a repository for storing our <code class="literal">randserver</code> application. Its output should look like this:</p><pre class="programlisting"><span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>     "repository": {</strong></span>
<span class="strong"><strong>            "repositoryArn": "arn:aws:ecr:eu-central-1:123456789012:repository/randserver",</strong></span>
<span class="strong"><strong>            "registryId": "123456789012",</strong></span>
<span class="strong"><strong>            "repositoryName": "randserver",</strong></span>
<span class="strong"><strong>            "repositoryUri": "123456789012.dkr.ecr.eu-central-1.amazonaws.com/randserver",</strong></span>
<span class="strong"><strong>         "createdAt": 1543162198.0</strong></span>
<span class="strong"><strong>     }</strong></span>
<span class="strong"><strong>    }</strong></span></pre><p>A nice addition to your repositories is a life cycle policy that cleans up older versions of your images, so that you don't eventually get blocked from pushing a newer version. This can be <span>achieved</span><a id="id325782297" class="indexterm"></a> as follows, using the same <code class="literal">aws ecr</code> command:</p><pre class="programlisting"><span class="strong"><strong>$ aws ecr put-lifecycle-policy --registry-id 123456789012 --repository-name randserver --lifecycle-policy-text '{"rules":[{"rulePriority":10,"description":"Expire old images","selection":{"tagStatus":"any","countType":"imageCountMoreThan","countNumber":800},"action":{"type":"expire"}}]}'</strong></span></pre><p>This particular policy will start cleaning up once have more than 800 images on the same repository. You could also clean up based on the images, age, or both, as well as consider only some tags in your cleanup.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note74"></a>Note</h3><p>For more information and examples, refer to <span><a class="ulink" href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/lifecycle_policy_examples.html" target="_blank">https://docs.aws.amazon.com/AmazonECR/latest/userguide/lifecycle_policy_examples.html</a>.</span></p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec92"></a>Pushing and pulling images from your workstation</h3></div></div></div><p>In order use your newly-created ECR repository, first we're going to need to authenticate your local Docker <span>daemon</span><a id="id325782336" class="indexterm"></a> against the ECR registry. Once again, <code class="literal">aws ecr</code> will help you achieve just that:</p><pre class="programlisting"><span class="strong"><strong>aws ecr get-login --registry-ids 123456789012 --no-include-email</strong></span></pre><p>This will output a <code class="literal">docker login</code> command that will <span>add</span><a id="id325839260" class="indexterm"></a> a new user-password pair for your Docker configuration. You can copy-paste that command, or you can just run it as follows; the results will be the same:</p><pre class="programlisting"><span class="strong"><strong>$(aws ecr get-login --registry-ids 123456789012 --no-include-email)</strong></span></pre><p>Now, pushing and pulling images is just like using any other Docker registry, using the outputted repository URI that we got when creating the repository:</p><pre class="programlisting"><span class="strong"><strong>$ docker push 123456789012.dkr.ecr.eu-central-1.amazonaws.com/randserver:0.0.1</strong></span><span class="strong"><strong>$ docker pull 123456789012.dkr.ecr.eu-central-1.amazonaws.com/randserver:0.0.1</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec93"></a>Setting up privileges for pushing images</h3></div></div></div><p>IAM users' permissions should <span>allow</span><a id="id325839293" class="indexterm"></a> your users to perform strictly only the operations they actually need to, in order to avoid any possible mistakes that might have a larger area of impact. This is also true for ECR management, and to that effect, there are three AWS IAM managed policies that greatly simplify achieving it:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">AmazonEC2ContainerRegistryFullAccess</code>: This allows a user to perform any operation on your ECR repositories, including deleting them, and should therefore be left for system administrators and owners.</li><li style="list-style-type: disc"><code class="literal">AmazonEC2ContainerRegistryPowerUser</code>: This allows a user to push and pull images on any repositories, which is very handy for developers that are actively building and deploying your software.</li><li style="list-style-type: disc"><code class="literal">AmazonEC2ContainerRegistryReadOnly</code>: This allows a user to pull images on any repository, which is useful for scenarios where developers are not pushing their software from their workstation, and are instead just pulling internal dependencies to work on their projects.</li></ul></div><p>All of these policies can be attached to an IAM user as follows, by replacing the policy name at the end of the ARN with a suitable policy (as described previously) and pointing <code class="literal">--user-name</code> to the user you are managing:</p><pre class="programlisting"><span class="strong"><strong>$ aws iam attach-user-policy --policy-arn arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly  --user-name johndoe</strong></span></pre><p>All these AWS managed policies do have an important characteristic—all of them add permissions for all repositories on your registry. You'll probably find several use cases where this is far from ideal—maybe your organization has several teams that do not need access over each other's repositories; maybe you would like to have a user with the power to delete some repositories, but not all; or maybe you just <span>need</span><a id="id325870122" class="indexterm"></a> access to a single repository for <span class="strong"><strong>Continuous Integration</strong></span> (<span class="strong"><strong>CI</strong></span>) setup.</p><p>If your needs match any of these described situations, you should create your own policies with as granular permissions as required.</p><p>First, we will create an IAM group for the developers of our <code class="literal">randserver</code> application:</p><pre class="programlisting"><span class="strong"><strong>$ aws iam create-group --group-name randserver-developers</strong></span><span class="strong"><strong>{</strong></span><span class="strong"><strong>      "Group": {</strong></span><span class="strong"><strong>      "Path": "/",</strong></span><span class="strong"><strong>      "GroupName": "randserver-developers",</strong></span><span class="strong"><strong>      "GroupId": "AGPAJRDMVLGOJF3ARET5K",</strong></span><span class="strong"><strong>      "Arn": "arn:aws:iam::123456789012:group/randserver-developers",</strong></span><span class="strong"><strong>      "CreateDate": "2018-10-25T11:45:42Z"</strong></span><span class="strong"><strong>      }</strong></span><span class="strong"><strong>}  </strong></span></pre><p>Then we'll add the <code class="literal">johndoe</code> user to the group:</p><pre class="programlisting"><span class="strong"><strong>$ aws iam add-user-to-group --group-name randserver-developers --user-name johndoe</strong></span></pre><p>Now we'll need to create our policy so that we can attach it to the group. Copy this JSON document to a file:</p><pre class="programlisting">{ 
   "Version": "2012-10-17", 
   "Statement": [{ 
         "Effect": "Allow", 
         "Action": [ 
               "ecr:GetAuthorizationToken", 
               "ecr:BatchCheckLayerAvailability", 
               "ecr:GetDownloadUrlForLayer", 
               "ecr:GetRepositoryPolicy", 
               "ecr:DescribeRepositories", 
               "ecr:ListImages", 
               "ecr:DescribeImages", 
               "ecr:BatchGetImage", 
               "ecr:InitiateLayerUpload", 
               "ecr:UploadLayerPart", 
               "ecr:CompleteLayerUpload", 
               "ecr:PutImage"
          ], 
         "Resource": "arn:aws:ecr:eu-central-1:123456789012:repository/randserver" 
   }] 
} </pre><p>To create the policy, execute <span>the</span><a id="id325911980" class="indexterm"></a> following, passing the appropriate path for the JSON document file:</p><pre class="programlisting"><span class="strong"><strong>$ aws iam create-policy --policy-name EcrPushPullRandserverDevelopers --policy-document file://./policy.json</strong></span><span class="strong"><strong>{</strong></span><span class="strong"><strong>      "Policy": {</strong></span><span class="strong"><strong>      "PolicyName": "EcrPushPullRandserverDevelopers",</strong></span><span class="strong"><strong>      "PolicyId": "ANPAITNBFTFWZMI4WFOY6",</strong></span><span class="strong"><strong>      "Arn": "arn:aws:iam::123456789012:policy/EcrPushPullRandserverDevelopers",</strong></span><span class="strong"><strong>      "Path": "/",</strong></span><span class="strong"><strong>      "DefaultVersionId": "v1",</strong></span><span class="strong"><strong>      "AttachmentCount": 0,</strong></span><span class="strong"><strong>      "PermissionsBoundaryUsageCount": 0,</strong></span><span class="strong"><strong>      "IsAttachable": true,</strong></span><span class="strong"><strong>      "CreateDate": "2018-10-25T12:00:15Z",</strong></span><span class="strong"><strong>      "UpdateDate": "2018-10-25T12:00:15Z"</strong></span><span class="strong"><strong>      }</strong></span><span class="strong"><strong>}</strong></span></pre><p>The final step is then to attach the policy to the group, so that <code class="literal">johndoe</code> and all future developers of this application can use the repository from their workstation, just like we did previously:</p><pre class="programlisting"><span class="strong"><strong>$ aws iam attach-group-policy --group-name randserver-developers --policy-arn arn:aws:iam::123456789012:policy/EcrPushPullRandserverDevelopers</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec94"></a>Use images stored on ECR in Kubernetes</h3></div></div></div><p>You may recall, in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>A Production-Ready Cluster</em></span> that we attached the IAM policy, <code class="literal">AmazonEC2ContainerRegistryReadOnly</code>, to the instance profile used by our cluster nodes. This allows our nodes to fetch any images in any repository in the AWS account where <span>the</span><a id="id325926202" class="indexterm"></a> cluster resides.</p><p>In order to use an ECR repository in this manner, you should set the <code class="literal">image</code> field of the pod template on your manifest to point to it, such as in the following example:</p><pre class="programlisting">image: 123456789012.dkr.ecr.eu-central-1.amazonaws.com/randserver:0.0.1.</pre></div></div>