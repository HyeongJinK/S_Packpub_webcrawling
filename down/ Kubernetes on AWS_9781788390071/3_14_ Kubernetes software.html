<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec20"></a>Kubernetes software</h2></div></div><hr /></div><p>We are going to launch an instance in <span>which</span><a id="id325750937" class="indexterm"></a> we will install all of the software that the different nodes that make up our cluster will need. We will then create an AMI, or Amazon machine image, that we can use to launch the nodes on our cluster.</p><p>First, we create a security group for this instance, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ K8S_AMI_SG_ID=$(aws ec2 create-security-group \</strong></span><span class="strong"><strong>--group-name k8s-ami \
</strong></span><span class="strong"><strong>   --description "Kubernetes AMI Instances" \</strong></span><span class="strong"><strong> --vpc-id $VPC_ID \</strong></span><span class="strong"><strong>--query GroupId \</strong></span><span class="strong"><strong> --output text)</strong></span></pre><p>We will need to be able to access this instance from our bastion host in order to log in and install software, so let's add a rule to allow SSH traffic on port <code class="literal">22</code> from instances in the <code class="literal">ssh-bastion</code> security group, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ aws ec2 authorize-security-group-ingress \</strong></span><span class="strong"><strong>--group-id $K8S_AMI_SG_ID \</strong></span><span class="strong"><strong>--protocol tcp \</strong></span><span class="strong"><strong>--port 22 \</strong></span><span class="strong"><strong>--source-group $BASTION_SG_ID</strong></span></pre><p>We are just using a <code class="literal">t2.mico</code> instance here since we don't need a very powerful instance just to install packages, as shown in the following command:</p><pre class="programlisting"><span class="strong"><strong>$ K8S_AMI_INSTANCE_ID=$(aws ec2 run-instances \</strong></span><span class="strong"><strong>--subnet-id $PRIVATE_SUBNET_ID \</strong></span><span class="strong"><strong>--image-id $UBUNTU_AMI_ID \</strong></span><span class="strong"><strong>--instance-type t2.micro \</strong></span><span class="strong"><strong>--key-name eds_laptop \</strong></span><span class="strong"><strong>--security-group-ids $K8S_AMI_SG_ID \</strong></span><span class="strong"><strong>--query "Instances[0].InstanceId" \</strong></span><span class="strong"><strong>--output text)</strong></span></pre><p>We add a <code class="literal">Name</code> tag so we can identify the instance later if we need, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ aws ec2 create-tags \</strong></span><span class="strong"><strong>--resources $K8S_AMI_INSTANCE_ID \</strong></span><span class="strong"><strong>--tags Key=Name,Value=kubernetes-node-ami</strong></span></pre><p>Grab the IP address of the instance, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ K8S_AMI_IP=$(aws ec2 describe-instances \</strong></span><span class="strong"><strong>--instance-ids $K8S_AMI_INSTANCE_ID \</strong></span><span class="strong"><strong>--query "Reservations[0].Instances[0].PrivateIpAddress" \</strong></span><span class="strong"><strong> --output text)</strong></span></pre><p>Then log in with <code class="literal">ssh</code>, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ ssh ubuntu@$K8S_AMI_IP</strong></span></pre><p>Now we are ready to start configuring the instance with the software and configuration that all of the nodes in our cluster will need. Start by synchronizing the apt repositories, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ sudo apt-get update</strong></span></pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"></a>Docker</h3></div></div></div><p>Kubernetes can work with a <span>number</span><a id="id325761998" class="indexterm"></a> of container runtimes, but Docker is still the most widely used.</p><p>Before we install Docker, we will add a <code class="literal">systemd</code> drop-in config file to the Docker service, as follows:</p><pre class="programlisting"><span class="strong"><strong>/etc/systemd/system/docker.service.d/10-iptables.conf</strong></span><span class="strong"><strong>[Service]</strong></span><span class="strong"><strong>ExecStartPost=/sbin/iptables -P FORWARD ACCEPT</strong></span></pre><p>In order for our Kubernetes <span>pods</span><a id="id325850562" class="indexterm"></a> to be accessible to other instances in the cluster, we need to set the default policy for the <code class="literal">iptables FORWARD</code> chain as shown in the following command; otherwise, Docker will set this to <code class="literal">DROP</code> and traffic for Kubernetes services will be dropped:</p><pre class="programlisting"><span class="strong"><strong>$ sudo mkdir -p /etc/systemd/system/docker.service.d/</strong></span><span class="strong"><strong>$ printf "[Service]\nExecStartPost=/sbin/iptables -P FORWARD ACCEPT" |   sudo tee /etc/systemd/system/docker.service.d/10-iptables.conf</strong></span></pre><p>Kubernetes will work well with the version of Docker that is included in the Ubuntu repositories, so we can install it simply by installing the <code class="literal">docker.io</code> package, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ sudo apt-get install -y docker.io</strong></span></pre><p>Check that Docker is installed by running the following:</p><pre class="programlisting"><span class="strong"><strong>$ sudo docker version</strong></span></pre></div></div>