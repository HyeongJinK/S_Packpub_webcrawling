<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec30"></a>CronJob</h2></div></div><hr /></div><p>Now you have learned how to <span>run</span><a id="id325750937" class="indexterm"></a> one-off or batch tasks with jobs, it is simple to extend the concept in order to run scheduled jobs. In Kubernetes, a <code class="literal">CronJob</code> is a controller that creates new jobs from a template on a given schedule.</p><p>Let's begin with a simple example. The following example will launch a job every minute. This job will output the current date and time and then exit:</p><pre class="programlisting"><span class="strong"><strong>fun-with-cron.yaml
</strong></span>apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: fun-with-cron
spec:
  schedule: "* * * * *"
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            cronjob: fun-with-cron
        spec:
          restartPolicy: OnFailure
          containers:
          - name: how-soon-is-now
            image: alpine:3.6
            command: ["/bin/date"]<span class="strong"><strong>
</strong></span></pre><p>Push the CronJob to Kubernetes with <code class="literal">kubectl</code>:</p><pre class="programlisting"><span class="strong"><strong>$ kubectl apply -f fun-with-cron.yaml</strong></span></pre><p>After some time (less than a minute), you should see the first job created:</p><pre class="programlisting"><span class="strong"><strong>$ kubectl get jobs</strong></span>
<span class="strong"><strong>NAME DESIRED SUCCESSFUL AGE</strong></span>
<span class="strong"><strong>fun-with-cron-1533475680 1 1 9s</strong></span></pre><p>The label we added to the pod template spec allows us to use <code class="literal">kubectl logs</code> to see the output of all the pods created by the CronJob:</p><pre class="programlisting"><span class="strong"><strong>$ kubectl logs -l cronjob=fun-with-cron</strong></span>
<span class="strong"><strong>  Sun Aug 5 13:26:08 UTC 2018</strong></span>
<span class="strong"><strong>  Sun Aug 5 13:27:08 UTC 2018</strong></span>
<span class="strong"><strong>  Sun Aug 5 13:28:08 UTC 2018</strong></span></pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec30"></a>Cron syntax</h3></div></div></div><p>The syntax of the schedule field <span>follows</span><a id="id325753319" class="indexterm"></a> the standard Cron format, which should be familiar if you have ever set up CronJobs on a Unix-like system. Kubernetes supports standard cron strings with a few common extensions.</p><p>A standard cron string consists of five fields that each represent different units of time. Each can be set to an expression representing a particular time, or a wildcard (*) that would match every time. For example, a wildcard in the <span class="strong"><strong>Months</strong></span> column would match every month:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; "><p>Minutes</p></td><td style="border-right: 0.5pt solid ; "><p>Hours</p></td><td style="border-right: 0.5pt solid ; "><p>Day of Month</p></td><td style="border-right: 0.5pt solid ; "><p>Month</p></td><td style=""><p>Day of Week</p></td></tr></tbody></table></div><p>Order of cron fields</p><p>The cron format is simplest to understand if it is read from left to right. Here are some examples:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">0 * * * *</code>: On the hour, every hour</li><li style="list-style-type: disc"><code class="literal">15 * * * *</code>: 15 minutes past every hour</li><li style="list-style-type: disc"><code class="literal">0 0 * * *</code>: At midnight, every day</li><li style="list-style-type: disc"><code class="literal">30 5 1 * *</code>: 5:30 a.m. on the first day of the month, every month</li><li style="list-style-type: disc"><code class="literal">30 17 * * 1</code>: 15:30 p.m., every Monday</li></ul></div><p>As well as the wildcard, there are a few other characters with special meaning.</p><p>Slashes are used to indicate steps:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">0/15 * * * *</code>: Every 15 minutes, starting at 0; for example, 12:00, 12:15, 12:30, and so on</li><li style="list-style-type: disc"><code class="literal">15/15 * * * *</code>: Every 15 minutes, starting at 15; for example, 12:15, 12:30, 12:45, 13:15, 13:30, and so on</li><li style="list-style-type: disc"><code class="literal">0 0 0/10 * *</code>: Every 10 days at midnight</li></ul></div><p>Hyphens indicate ranges:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">0 9-17 * * *</code>: Once an hour during office hours (9 a.m. till 5 p.m.)</li><li style="list-style-type: disc"><code class="literal">0 0 1-15/2 * *</code>: Every other day for the first 15 days of every month</li></ul></div><p>Commas indicate lists:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">0 0 * * 6,0</code>: Midnight on Saturday and Sunday</li><li style="list-style-type: disc"><code class="literal">0 9,12,17 * * 1-5</code>: At 9:00 a.m., 12 noon, and 5:00 p.m., Monday to Friday</li></ul></div><p>As an aid to readability, names can be used in the month and day of the week fields:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">0 0 * * SUN</code>: Midnight on Sunday</li><li style="list-style-type: disc"><code class="literal">0 6 * MAR-MAY *</code>: 6 a.m. every day in Spring</li></ul></div><p>If you don't mind when exactly a job is run, you can specify a fixed interval and Kubernetes will create jobs at a fixed interval:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">@every 15m</code>: Every 15 minutes</li><li style="list-style-type: disc"><code class="literal">@every 1h30m</code>: Every 1-and-a half hours</li><li style="list-style-type: disc"><code class="literal">@every 12h</code>: Every 12 hours</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Note</h3><p>Bear in mind that the interval doesn't take the time that the job takes to run into account; it just ensures that the time that each job is scheduled is separated by the given interval.</p></div><p>Finally, there are several predefined schedules that can be used as a shortcut in place of a cron string:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Shortcut</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Equivalent cron</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">@hourly</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">0 0 * * * *</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Every hour, on the hour</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">@daily</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">0 0 0 * * *</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Every day at midnight</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">@weekly</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">0 0 0 * * 0</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Every week midnight on Sunday</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">@monthly</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">0 0 0 1 * *</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Monthly, at midnight on the 1st</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">@yearly</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">0 0 0 1 1 *</code></p></td><td style=""><p>Midnight, every New Year's Eve</p></td></tr></tbody></table></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec31"></a>Concurrency policy</h3></div></div></div><p>Kubernetes CronJob, in contrast to the traditional CronJob, allows us to decide what happens when a <span>job</span><a id="id325887147" class="indexterm"></a> overruns and we reach the scheduled time while the previous job is still running. We can control this behavior by setting the <code class="literal">spec.concurrencyPolicy</code> field on the CronJob. There are three possible policies that we can choose:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">By default, if the field is unset then we get the <code class="literal">Allow</code> policy. This behaves just like a traditional CronJob and allows multiple instances of a job to run at the same time. If you stick with this, you should be sure that your jobs indeed get completed at some point, or your cluster could end up overwhelmed with many jobs running at the same time.</li><li style="list-style-type: disc">The <code class="literal">Forbid</code> policy prevents any new jobs from starting while an existing job is still running. This means that if a job overruns, Kubernetes will skip the next run. This is a good choice if having two or more instances of a job running could cause conflicts or use up shared resources. Your job, of course, does need to be able to account for missing runs in this case.</li><li style="list-style-type: disc">Finally, the <code class="literal">Replace</code> policy also prevents more than one job from running at once, but rather than skipping a run, it first kills the existing job and then launches a new job.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec32"></a>History limits</h3></div></div></div><p>By default, when you use a CronJob, the jobs that it creates will stick around, so you can check on <span>what</span><a id="id325919101" class="indexterm"></a> happened to a particular run of a job for debugging or reporting. You might, however, find that the number of jobs in the successful or failed state starts to pile up quite quickly when using CronJob. This is simple to manage with the <code class="literal">spec.successfulJobsHistoryLimit</code> and <code class="literal">spec.failedJobsHistoryLimit</code> fields. Once the successful, or failed jobs reach the number specified in the limit, the oldest job is deleted each time a new job is created. If you set a limit to 0, the jobs are removed as soon as they complete.</p></div></div>