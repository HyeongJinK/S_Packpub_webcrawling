<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec52"></a>Preparing node images</h2></div></div><hr /></div><p>As we did in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Reach for the Cloud</em></span>, we will now be preparing an AMI for the worker <span>nodes</span><a id="id325268194" class="indexterm"></a> in our cluster. However, we will improve this process by automating it with <span class="strong"><strong>Packer</strong></span>. Packer is a tool that makes it simple to build machine images on AWS (and other platforms).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec76"></a>Installing Packer</h3></div></div></div><p>Just like Terraform, Packer is <span>distributed</span><a id="id325268213" class="indexterm"></a> as a single <span>binary</span><a id="id325268221" class="indexterm"></a> that just needs to be copied to a location on your path. You can find detailed installation instructions on the <span>Packer</span><a id="id325268231" class="indexterm"></a> website at <a class="ulink" href="https://www.packer.io/intro/getting-started/install.html" target="_blank">https://www.packer.io/intro/getting-started/install.html</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip60"></a>Note</h3><p>Once you have installed Packer, you can run <code class="literal">packer version</code> to check that you have correctly copied it into to your path.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec77"></a>Packer configuration</h3></div></div></div><p>Packer is configured with a JSON-formatted configuration file, that you can see at <code class="literal">ami/node.json</code>.</p><p>There are three parts to the <span>example</span><a id="id325753369" class="indexterm"></a> configuration here. The first is a list of variables. Here, we are using variables to store the version numbers of the important software that we are going to install in our image. This will make it simple to build and test images <span>with</span><a id="id325753378" class="indexterm"></a> updated versions of the Kubernetes software when it becomes available in the future.</p><p>The second part of the configuration configures the builder. Packer allows us to choose to build our image with one or more builders that support building images for different cloud providers. Since we want to build an image to use on AWS, we are using the <code class="literal">amazon-ebs</code> builder, which creates an image by launching a temporary EC2 instance and then creating an AMI from the contents of its root EBS volume (just like the manual procedure we followed in <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Reach for the Cloud</em></span>). This builder configuration allows us to choose the base image that our machine will be based on; here, we are using an official Ubuntu server image, a trusted source. The <code class="literal">ami-name</code> field in the builder configuration defines the name that the outputted image will be given. We have included the version of the Kubernetes software used and a timestamp to ensure that this image name is unique. Having a unique image name lets us defineÂ precisely which image to use when we deploy servers using it.</p><p>Finally, we configure a provisioner to install the software that our image will require. Packer supports many different provisioners that can install software, including full configuration-management systems such as Chef or Ansible. To keep this example simple, we will automate the installation of the software that we need by using a shell script. Packer will upload the configured script to the builder instance and then execute it via SSH.</p><p>We are just using a simple shell script, but if your organization already has a configuration-management tool in use, then you might prefer to use that to install the software that your image needs, especially as it makes it simple to include your organization's base configuration.</p><p>In this script, we are installing the software and configuration that our worker nodes will need to join an EKS cluster and function correctly, as shown in the following list. In a real deployment, there may be other tools and configurations that you <span>wish</span><a id="id325753410" class="indexterm"></a> to add in addition to these.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Docker</strong></span>: Docker is currently the best tested and most common container runtime to use with Kubernetes</li><li style="list-style-type: disc"><span class="strong"><strong>kubelet</strong></span>: The Kubernetes node agent</li><li style="list-style-type: disc"><span class="strong"><strong>ekstrap</strong></span>: Configures the kubelet to connect to the EKS cluster endpoint</li><li style="list-style-type: disc"><span class="strong"><strong>aws-iam-authenticator</strong></span>: Allows the node to authenticate with the EKS cluster using the node's IAM credentials</li></ul></div><p>We install these elements using the following code:</p><pre class="programlisting"><span class="strong"><strong>install.sh</strong></span>
          #!/bin/bash
          set -euxo pipefail  
...
          # Install aws-iam-authenticator
curl -Lo /usr/local/bin/heptio-authenticator-aws https://github.com/kubernetes-sigs/aws-iam-authenticator/releases/download/v0.3.0/heptio-authenticator-aws_0.3.0_linux_amd64
chmod +x /usr/local/bin/heptio-authenticator-aws

apt-get install -y \
  docker-ce=$DOCKER_VERSION* \
  kubelet=$K8S_VERSION* \
  ekstrap=$EKSTRAP_VERSION*
# Cleanup
apt-get clean
rm -rf /tmp/*
   # Cleanup
   apt-get clean
   rm -rf /tmp/*</pre><p>Once you have prepared the configuration for Packer, you can use the <code class="literal">packer build</code> command to build the AMI in your AWS account, as shown in the following code. This will start a temporary EC2 instance. Save the new AMI into your account and clean up the temporary instance:</p><pre class="programlisting"><span class="strong"><strong>packer build node.json</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip61"></a>Note</h3><p>If your organization uses a continuous integration service, you might want to configure it to build your node image on a regular schedule in order to pick up security updates to the base operating system.</p></div></div></div>