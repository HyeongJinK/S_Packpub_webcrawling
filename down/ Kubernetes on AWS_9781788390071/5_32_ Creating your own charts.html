<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec36"></a>Creating your own charts</h2></div></div><hr /></div><p>Now you have a little experience <span>with</span><a id="id325268218" class="indexterm"></a> Helm and can use the command-line tool to install a chart from a community repository, we are going to take a look at how you can leverage Helm to build charts for your own applications.</p><p>We will walk through using Helm to deploy the versions application that we manually deployed in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Managing Change in Your Applications</em></span>. The aim here is for us to replicate the deployments we made in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Managing Change in Your Applications</em></span>, but this time to encapsulate the configuration in a Helm chart so it is simple to make configuration changes, deploy new versions of our code, and even deploy the same configuration multiple times.</p><p>Helm makes it very easy to build a chart and deploy it to your cluster. The Helm command-line tool has some commands that will get us started very quickly. The <code class="literal">helm create</code> command will create a skeleton for our new chart that we can quickly fill in with the configuration for our application:</p><pre class="programlisting"><span class="strong"><strong>$ helm create version-app</strong></span><span class="strong"><strong>Creating version-app</strong></span><span class="strong"><strong>$ tree version-app</strong></span><span class="strong"><strong>version-app</strong></span><span class="strong"><strong>├── Chart.yaml</strong></span><span class="strong"><strong>├── values.yaml</strong></span><span class="strong"><strong>└── templates</strong></span><span class="strong"><strong>├── NOTES.txt</strong></span><span class="strong"><strong>├── _helpers.tpl</strong></span><span class="strong"><strong>├── deployment.yaml</strong></span><span class="strong"><strong>└── service.yaml</strong></span><span class="strong"><strong>2 directories, 7 files</strong></span></pre><p>Let's look at each of the files created by Helm, and then look at the configuration we will need to add to deploy our versioned web service from <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Managing Change in Your Applications</em></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec44"></a>Chart.yaml</h3></div></div></div><p>This file contains some basic metadata <span>about</span><a id="id326208396" class="indexterm"></a> this chart, such as its name, a description, and a version number. This file is required.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec45"></a>values.yaml</h3></div></div></div><p>This file contains the default configuration <span>values</span><a id="id326208411" class="indexterm"></a> for this chart. These are the values that will be used when rendering the templated resources when installing the chart, unless overrides are provided.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec46"></a>templates</h3></div></div></div><p>This directory contains the templates that will be rendered to produce the definitions of the resources that <span>this</span><a id="id326208426" class="indexterm"></a> chart provides. When we run the <code class="literal">helm new</code> command, several skeleton template files are created for us.</p><p><code class="literal">NOTES.txt</code> is a special file that is used to provide a post-install message to users of your chart. You saw an example of this earlier in the chapter when we installed the kube-ops-dashboard.</p><p>As with the YAML resources we created by hand in earlier chapters, Helm doesn't attach any significance to the filenames we give to our resources. It is up to you to decide how to organize resources within the templates directory. The skeleton chart we created just now comes with a few files to get us started, but if you need to create more resources, you may just add additional files to the templates directory.</p><p><code class="literal">deployment.yaml</code> contains a simple manifest for a deployment, <code class="literal">service.yaml</code> contains a simple service manifest for this deployment, and <code class="literal">_helpers.tpl</code> contains some predefined helper functions that you can reuse throughout your chart.</p><p>When you ran <code class="literal">helm new</code>, some other files may have been created. These are optional files used for some more advanced functionality, and we can ignore them for now, but if you wish, you can safely remove them altogether from your chart.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"></a>Note</h3><p>There are some standard ways of working with the templates directory that are followed in the community charts repository. You might like to review these, as they do help to keep your work organized. But unless you are planning to try getting your chart published to the community repository, there is no need to stick rigidly to these guidelines: <a class="ulink" href="https://docs.helm.sh/chart_best_practices" target="_blank">https://docs.helm.sh/chart_best_practices</a><span>.</span></p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec47"></a>Making it your own</h3></div></div></div><p>Let's go through the steps <span>that</span><a id="id325747098" class="indexterm"></a> we will take to edit this chart in order to deploy our own application. Start by taking a look at the generated <code class="literal">deployment.yaml</code> file. You will notice that it looks very similar to the manifest that we produced in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Managing Change in Your Applications</em></span>, but with one important difference: all of the specific configuration values have replaced will calls to variables. Look, for example, at the line where the image for the container is specified:</p><pre class="programlisting"><span class="strong"><strong>image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"</strong></span></pre><p>You will notice that when a reference to a variable is inserted into the template, it is surrounded by two curly braces, like this: <code class="literal">{{ variable }}</code>. Secondly, you will also notice the dot notation used to access nested attributes on objects. The <code class="literal">.Values</code> object refers to all of the values, either supplied (by default) from the <code class="literal">values.yaml</code> file within the chart, or overridden from the command line when the chart is deployed.</p><p>So, in order to configure the source for the image we want to use in our deployment, let's start by editing the <code class="literal">values.yaml</code> file. Find the section where the image is configured and edit to pull the versions application we deployed in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Managing Change in Your Applications</em></span>:</p><pre class="programlisting"><span class="strong"><strong>image: 
  repository: errm/versions 
  tag: 0.0.1 
  pullPolicy: IfNotPresent</strong></span></pre><p>While we are editing the <code class="literal">values.yaml</code> file, let's also edit the values used to configure the service that Helm created for our deployment. We need to change the port that our container exposes from <code class="literal">80</code> to <code class="literal">3000</code>, and we should change the name of our service from <code class="literal">nginx</code> to something more descriptive:</p><pre class="programlisting"><span class="strong"><strong>service: 
  name: versions 
  type: ClusterIp 
  externalPort: 80 
  internalPort: 3000</strong></span></pre><p>If we go back and look at <code class="literal">deployment.yaml</code> and <code class="literal">service.yaml</code>, we can see one of the advantages of being able to inject variables into our Kubernetes resources with templates.</p><p><a class="ulink" href="" target="_blank">By changing</a> the value of <code class="literal">service.internalPort</code> in the <code class="literal">values.yaml</code> file, we have a single source of truth; in this case, the port that our container exposes. This single source of truth then gets used three times within <code class="literal">deployment.yaml</code> and then again in <code class="literal">service.yaml</code>. Of course, with a simple example like this, we could have edited these files manually, but it makes the cost of maintaining the configuration that little bit higher, having to search through several resources, and understanding how different configuration values interact.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip40"></a>Note</h3><p>When I am building a Helm chart, I try to imagine my future self using the chart. My aim is to expose enough variables to make the chart flexible enough to reuse and redeploy in several environments without having to change or even look at the templates. To achieve this, it is important to choose descriptive variable names, and provide clear documentation for the use of those variables in the<code class="literal">README.md</code> file.</p></div><p>It is simple to deploy our chart using the Helm command-line client, rather than referring to the name of a chart within a remote repository (for example, <code class="literal">stable/kube-ops-view</code>). We can run our Helm commands by pointing to the chart directory on disk:</p><pre class="programlisting"><span class="strong"><strong>$ helm install --name happy-bear version-app/</strong></span><span class="strong"><strong>NAME:   happy-bear</strong></span><span class="strong"><strong>LAST DEPLOYED: Sun Dec  3 13:22:13 2017</strong></span><span class="strong"><strong>NAMESPACE: default</strong></span><span class="strong"><strong>STATUS: DEPLOYED</strong></span><span class="strong"><strong>RESOURCES:</strong></span><span class="strong"><strong>==&gt; v1/Service</strong></span><span class="strong"><strong>NAME                    TYPE       CLUSTER-IP  EXTERNAL-IP  PORT(S)</strong></span><span class="strong"><strong>happy-bear-version-app  ClusterIP  10.0.0.121  &lt;none&gt;       80/TCP</strong></span><span class="strong"><strong>==&gt; v1/Deployment</strong></span><span class="strong"><strong>NAME                    DESIRED  CURRENT  UP-TO-DATE  AVAILABLE</strong></span><span class="strong"><strong>happy-bear-version-app  1        1        1           0</strong></span><span class="strong"><strong>==&gt; v1/Pod(related)</strong></span><span class="strong"><strong>NAME                                     READY  STATUS</strong></span><span class="strong"><strong>happy-bear-version-app-6597799867-ct5lk  0/1    ContainerCreating</strong></span></pre><p>Now the chart has been installed on to our cluster, let's test that it's working correctly. The simplest way to do this is to run <code class="literal">kubectl proxy</code> to set up a local proxy to the kubernetes API, and use the service endpoint to view our service. The chart that Helm created for us <span>creates</span><a id="id326379364" class="indexterm"></a> a service with a name formed by combining the name of the release with the name of the chart. So, assuming that the <code class="literal">kubectl proxy</code> started on port <code class="literal">8001</code>, we should be able to view our service at the following URL: <code class="literal">http://localhost:8001/api/v1/namespaces/default/services/happy-bear-version-app:80/</code>.</p><div class="mediaobject"><img src="/graphics/9781788390071/graphics/e2806f84-4e3e-4497-a9e9-4fb23297cf1f.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec48"></a>Developing and debugging</h3></div></div></div><p>As our charts become more complex and we leverage more of the power of the templating language that <span>Helm</span><a id="id326379399" class="indexterm"></a> provides to <span>build</span><a id="id326379408" class="indexterm"></a> our own abstractions on top of the Kubernetes resources, you might notice that it becomes harder to reason about errors returned by Kubernetes. Because we can no longer see the resources directly that we are submitting to Kubernetes, it can become harder to work out the source of a bug or misconfiguration.</p><p>Luckily, Helm has some options that will help us debug our charts as we develop them:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong><code class="literal">--dry-run</code></strong></span>: This option allows us to submit our chart to the Tiller server, where it will be validated in exactly the same way as when we deploy our chart without actually submitting the resources to Kubernetes. This lets us see and understand any errors with our chart quickly without having to use resources on our cluster.</li><li style="list-style-type: disc"><code class="literal">--debug</code>: This option allows us to see a lot of useful debugging information; in fact, so much that it can be a little overwhelming at first. Firstly, we see some logging information marked <code class="literal">[debug]</code>. This includes some details about how the Helm client is connecting to Tiller and the chart that is being deployed.</li></ul></div><p>This is followed by the release metadata. This is made up from the chart metadata from <code class="literal">Chart.yaml</code> and computed information about the release, such as its number and the date and time that it was made.</p><p>The next section, <code class="literal">COMPUTED VALUES</code>, shows the exact values that Helm will be using as it renders the templates to produce the resources for this release. If you are not passing any extra variables when you make your release, this should be identical to the contents of <code class="literal">values.yaml</code>, but is very useful if you are trying to understand exactly what variables are being used by the templates if you are providing overrides when you invoke Helm. The <code class="literal">HOOKS</code> section shows the resources that will be created by the Helm hooks mechanism. You will learn a little about hooks later in this chapter.</p><p>Finally, the <code class="literal">MANIFEST</code> section lists out the computed resources, as they will be submitted to Kubernetes. When you are developing chart templates, this is invaluable, for quickly seeing how your chart behaves given different values. You will find that using both these options together with a call to <code class="literal">helm install</code> or <code class="literal">helm upgrade</code> is very useful in debugging your charts, as well as for validating your work and building confidence that changes to your chart or values have the desired effect.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec49"></a>Templating language</h3></div></div></div><p>Helm's templating language is <span>based</span><a id="id326407325" class="indexterm"></a> on the Go templating language. Essentially, Helm provides the standard templating language from the Go programming language, plus some additional functions and the mechanism for making variables available inside of your templates.</p><p>You have already seen how to use the templating language to place information into YAML formatted Kubernetes resources. Calls to functions provided by Helm are surrounded by double curly braces, like <code class="literal">{{ this }}</code>.</p><p>If we simply want to include a variable into our template, we can just refer to it by name. Helm namespaces its variables inside of a number of objects that are exposed to the template. You will have already noticed that the values from our <code class="literal">values.yaml</code> file (as amended by any overwritten variables passed in on the command line) are available in the <code class="literal">.Values</code> object. In addition to this object, Helm makes further objects available within the template:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">.Release</code>: This object describes the release itself, and includes a number of attributes that can be used to customize your resources to their parent release. Commonly, you will use these values to ensure that the resources from this release do not conflict with the resources from another release of the same chart.</li><li style="list-style-type: disc"><code class="literal">.Release.Name</code>: This is the name of the release. It can be passed to <code class="literal">helm install</code> with the <code class="literal">--name</code> flag, or it might be automatically generated.</li><li style="list-style-type: disc"><code class="literal">.Release.Time.Seconds</code>: This is the time when the release was created as a UNIX-style timestamp. It can be useful if you need to add a unique value to a resource name.</li><li style="list-style-type: disc"><code class="literal">.Release.Namespace</code>: This indicates the Kubernetes namespace of this release.</li><li style="list-style-type: disc"><code class="literal">.Release.Service</code>: This indicates the service that made the release. Currently, this is always Tiller, but if there was an alternative implementation of Helm, perhaps it would populate this attribute differently.</li><li style="list-style-type: disc"><code class="literal">.Release.Revision</code>: This is a number used to track updates to the release. It begins with 1 and increases each time the release is upgraded via <code class="literal">helm upgrade</code>.</li><li style="list-style-type: disc"><code class="literal">.Release.IsUpgrade</code> and <code class="literal">.Release.IsInstall</code>: These are Boolean values that indicate if the operation producing this release is a new install of the chart, or an upgrade of an existing release. These might be utilized to only carry out actions at a particular point in the chart's life cycle.</li><li style="list-style-type: disc"><code class="literal">.Chart</code>: The chart object contains the fields from <code class="literal">Chart.yaml</code>.</li><li style="list-style-type: disc"><code class="literal">.Files</code>: This object allows you to access the contents of non-template files included in the chart. It exposes two functions, <code class="literal">.Get</code> and <code class="literal">.GetBytes</code>, that allow you to read contents of files as text or indeed as bytes. This can be useful for providing static config files or other data that is not included in your container images as part of your chart.</li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">.Capabilities</code>: This object provides information about the cluster that Tiller is running on. It can be useful to query this information if you want to produce a chart that will work with more than one version of Kubernetes. You will see an example of this later in the chapter.</li><li style="list-style-type: disc"><code class="literal">.Template</code>: This object provides a <code class="literal">.Name</code> and a <code class="literal">.BasePath</code> attribute that includes the filename and directory of the template currently being rendered by Helm.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec50"></a>Functions</h3></div></div></div><p>Helm's templating language <span>provides</span><a id="id326532573" class="indexterm"></a> over 60 functions that can manipulate and format the data we pass to our templates.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"></a>Note</h3><p>Some of these functions are part of the Go templating language, but most are part of the Sprig templating language.
When you begin using Helm, it can be useful to have the documentation to hand so you can find the function that you need.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><a class="ulink" href="https://godoc.org/text/template" target="_blank">https://godoc.org/text/template</a></li><li style="list-style-type: disc"><a class="ulink" href="https://godoc.org/github.com/Masterminds/sprig" target="_blank">https://godoc.org/github.com/Masterminds/sprig</a></li></ul></div></div><p>There are two ways to invoke a template function in the Helm templating language. The first of these involves calling a function, and passing a value as an argument.</p><p>For example, <code class="literal">{{ upper "hello" }}</code> will produce the output <code class="literal">HELLO</code>.</p><p>The second way to invoke a function is as a pipeline. You can think of a pipeline a little like a UNIX pipe; it provides a concise way to pass the result of one function to another. This lets us compose together several functions to get at the result we want.</p><p>We could rewrite our first example as <code class="literal">{{ "hello" | upper }}</code> and the result would be exactly the same. The advantage of this form comes when we want to apply several functions to a value. When we use the pipeline operator, the result of the previous function is passed into the next as the last argument. This allows us to also call functions that take more than one argument, and is the reason that most of the functions in Helm are optimized to take the value to be operated on as the last argument.</p><p>We could, for example, form a pipeline with the <code class="literal">trunc</code> function to truncate our string to a certain number of characters and then use the <code class="literal">upper</code> function to uppercase the result, like this: <code class="literal">{{ "hello" | trunc 4 | upper }}</code>. The result, of course, would be <code class="literal">HELL.</code></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec51"></a>Flow control</h3></div></div></div><p>We already get a lot of value from Helm by being able to take a single value from a chart and include it in a <span>number</span><a id="id326532946" class="indexterm"></a> of places throughout a chart, like the example earlier in the chapter, where we referred to the same port number in several related places. You might also use this technique, for example, to ensure a system with a number of different components provided by different containers are always deployed to the same version number.</p><p>Another important way that we can use variables in our Helm charts is to provide a signal to our template to change our configuration or even turn whole features into optional extras that might not always be enabled.</p><p>There are three constructs that allow us to construct really powerful abstractions using Helm templates: <code class="literal">if...else</code>, <code class="literal">range</code>, and <code class="literal">with</code>.</p><p>The structure of the <code class="literal">if...else</code> construct in Helm should be very familiar to anyone who has used a programming language. We use the <code class="literal">if</code> keyword to test a variable or expression. If the test passes, we do the action in the first branch; if not, we fall back to the action indicated by the <code class="literal">else</code> branch.</p><p>Here is an example you might use to provide a custom message in the <code class="literal">NOTES.txt</code> template, depending on the value of a variable:</p><pre class="programlisting">{{ if .Values.production }} 
WARNING THIS IS A PRODUCTION ENVIRONMENT - do not use for testing. 
{{ else }} 
THIS IS A TEST ENVIRONMENT; any data will be purged at midnight. 
{{ end }} </pre><p><code class="literal">if</code> functions can be nested within the <code class="literal">else</code> branch to provide more complex behavior. In this example, the <code class="literal">Capabilities</code> object is queried so the templated resource can use a correct API version for a <code class="literal">CronJob</code> resource. This kind of capability is useful since it lets you make changes to your configuration to support a newer version of Kubernetes, but maintain backwards compatibility. If both of our tests for a supported version fail, then we explicitly throw an error that will halt the installation of the chart:</p><pre class="programlisting">{{- if and ge .Capabilities.KubeVersion.Minor "8" -}} 
apiVersion: batch/v1beta1
 {{- else if ge .Capabilities.KubeVersion.Minor "5" -}} 
apiVersion: batch/v1alpha1 
{{- else -}} 
{{required "Kubernetes version 1.5 or higher required" nil }} 
{{- end -}} </pre><p>Providing toggles like this around configuration based on feature flags or even version numbers is a very useful tool to manage change in your configuration. It allows you to add an option to your chart, test it out in safety, and then only enable it when you are happy to do so.</p><p>The <code class="literal">range</code> keyword is used to loop over a collection. It can loop over simple lists or collections with a key value structure.</p><p>Let's start by adding a list of values to our <code class="literal">values.yaml</code> file:</p><pre class="programlisting">users: 
  - yogi 
  - paddington 
  - teddy </pre><p>Then we can use the <code class="literal">range</code> keyword to loop over the data in our list, and use values in our template:</p><pre class="programlisting">apiVersion: v1 
kind: ConfigMap 
metadata: 
  name: {{ .Release.Name }}-configmap 
data: 
  usernames: |- 
    {{- range .Values.users }} 
    {{ . }} 
    {{- end }} </pre><p>In this example, we are using the <code class="literal">|-</code> marker, which is part of YAML. It indicates that the usernames string is multi-line. This will result in each username being available in the <code class="literal">ConfigMap</code> separated by new lines.</p><p>As you can see here, when we use the range function on a list, on each iteration, the special <code class="literal">.</code> variable is replaced by the value from the list.</p><p>When rendered, this template produces the following result:</p><pre class="programlisting">apiVersion: v1 
kind: ConfigMap 
metadata: 
  name: ordered-dolphin-configmap 
data: 
  usernames: |- 
    yogi 
    paddington 
    teddy </pre><p>In this next example, we are going to assign the result of the range function to two variables. When we do this with a list, the first variable includes an index, and you will notice that when we assign a variable, we prefix its name with a <code class="literal">$</code>:</p><pre class="programlisting">apiVersion: v1 
kind: ConfigMap 
metadata: 
  name: {{ .Release.Name }}-configmap 
data: 
  user_id.properties: |- 
    {{- range $index, $user := .Values.users }} 
    user.{{ $user }}={{ $index }} 
    {{- end }} </pre><p>The output of this template when rendered looks like this:</p><pre class="programlisting">apiVersion: v1 
kind: ConfigMap 
metadata: 
  name: interested-ibex-configmap 
data: 
  user_id.properties: |- 
    user.yogi.id=0 
    user.paddington.id=1 
    user.teddy.id=2 </pre><p>When using the range function to loop over a key value structure, we can also use variables to capture the key and the value.</p><p>Let's consider the following data in our <code class="literal">values.yaml</code> file:</p><pre class="programlisting">users:
   yogi:
     food: picnic 
    height: 1500 
  paddington:
     food: marmalade 
    height: 1066 
  teddy: 
    food: honey 
    height: 500  </pre><p>Now we have some key value <span>data</span><a id="id326533328" class="indexterm"></a> in the users variable, let's use it to configure some environment variables for a pod:</p><pre class="programlisting">apiVersion: v1 
kind: Pod 
metadata: 
  name: {{ .Release.Name }}-env-pod 
spec: 
  containers: 
  - image: alpine 
    name: bear-env 
    env: 
    {{- range $name, $user := .Values.users }} 
      {{- range $var, $value := $user }} 
      - name: {{ $name | upper }}_BEAR_{{ $var | upper }} 
        value: {{ $value | quote }} 
      {{- end }} 
    {{- end }} 
    command: ["env"] </pre><p>When we use the range keyword to loop over a key value structure, the key becomes the first variable returned and the value becomes the second. By nesting loops, as in this case, it becomes possible to use quite complex data structures in the values file.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip42"></a>Note</h3><p>The type of some variables in Kubernetes resources is important. In the preceding example, the value in an environment variable must always be a string, so we have used the <code class="literal">quote</code> pipeline function to ensure that values of other types (like numbers) are of the correct string type.</p></div><p>When rendered, this template produces a pod manifest, like this:</p><pre class="programlisting">apiVersion: v1 
kind: Pod 
metadata: 
  name: solemn-whale-env-pod 
spec: 
  containers: 
  - image: alpine 
    name: bear-env 
    env: 
      - name: PADDINGTON_BEAR_FOOD 
        value: "marmalade" 
      - name: PADDINGTON_BEAR_HEIGHT 
        value: "1066" 
      - name: TEDDY_BEAR_FOOD 
        value: "honey" 
      - name: TEDDY_BEAR_HEIGHT 
        value: "500" 
      - name: YOGI_BEAR_FOOD 
        value: "picnic" 
      - name: YOGI_BEAR_HEIGHT 
        value: "1500" 
    command: ["env"] </pre></div></div>