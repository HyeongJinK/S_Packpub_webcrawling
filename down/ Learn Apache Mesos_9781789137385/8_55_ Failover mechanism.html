<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec55"></a>Failover mechanism</h2></div></div><hr /></div><p>To check the failover mechanism, we <span>will</span><a id="id325092076" class="indexterm"></a> first go to <code class="literal">master2</code>, and stop the Docker instances using the following command:</p><pre class="programlisting"><span class="strong"><strong>sudo docker stop (Container ID)</strong></span></pre><p>Here, you can check in Marathon that <code class="literal">cassandra1</code> has stopped.</p><p> </p><p>On refreshing the page, you can see it has created the instance on <code class="literal">master2</code>, where we have stopped it. This is done automatically. Here, the scenario where we have seen one of the containers went down and a backup was automatically created. Now, let's validate this by running the following command:</p><pre class="programlisting"><span class="strong"><strong>sudo docker ps -a</strong></span></pre><p>You will find that your old container is down, and the new one, which was created automatically, will be up.</p><p>What happens if your server is down? For example, let's shut down our <code class="literal">master2</code> server. To do that, let's go to AWS console, then EC2 <strong class="userinput"><code>Instances</code></strong>, click on <code class="literal">master2</code> server, stop the server. On the Marathon app, you can see the failure gets detected. As you are aware, we have stopped the <code class="literal">master2</code> server, but our slave and Cassandra are both up and running. We can verify this by checking the keyspaces. You will notice there is no impact here. This is how the failover will be managed. We can call this high availability, such that if one server went down, the other server can still serve requests.</p><p>You must have noticed that, as soon as I stopped the <code class="literal">mesos-master2</code>, our Marathon also went down.</p><p>This happened as our <code class="literal">master1</code> server was already in a shutdown state, and we also closed our <code class="literal">master2</code> server, which was why the marathon was not able to detect the available master. Let's now start all the master servers. Here, we considered <code class="literal">master2</code> as our slave, and <code class="literal">master1</code> as our server. Keep in mind here that we need to keep the server and slave separate.</p><p>Consider one more scenario. For example, if we stop or shut down the slave servers, any instance of a container running on the slave instance <span>will</span><a id="id325482969" class="indexterm"></a> get started on another server automatically. Let's replicate this scenario. Let's go to the Marathon app, and you can see our <code class="literal">cassandra1</code> and <code class="literal">cassandra2</code> instances are automatically up as soon as we started our mesos server which is on <code class="literal">slave2</code> and <code class="literal">slave1</code>. As you are aware, our Docker container was running on <code class="literal">master2</code>, which is <code class="literal">slave1</code>, and as soon as <code class="literal">slave1</code> shuts down, the application started running under the <code class="literal">slave2</code> server. Let's check what happens when we shut down <code class="literal">slave2</code>. Verify that the cluster is up and running by visiting the Mesos page. You will notice that there is no cluster name present in <code class="literal">master3</code>. To add a cluster name, we need to update the IP as our EC2 public IP.</p><p>After the IP is updated, you can check that all three master servers are up. This shows how the Cassandra server worked and served the customer, even though our master servers were down, and the server again went to the node once the masters were up again. Now, let's check with a scenario where we shut down the slave server, and see how the Cassandra server behaves.</p><p>You can see in the Mesos framework that the one Mesos server has two slave servers: <code class="literal">slave2</code>, and <code class="literal">slave1</code>, the latter of which is where the Cassandra server is running. First, stop <code class="literal">slave1</code> instances. Here, we will see how our Cassandra container will get stopped; and it will get enabled under the server with the same persistent data storage enabled. It will automatically attach the EBS volume to the new server. Once <code class="literal">slave2</code> has stopped, check on the Marathon app and you will find that the problem with the server was detected. Within no time, the <code class="literal">master2</code> server got activated automatically and is in the running state. Now let's start <code class="literal">slave1</code> again, and shut down <code class="literal">slave2</code>. Once <code class="literal">slave1</code> is up and running, go to <strong class="userinput"><code>slave1-log in</code></strong> and check the process. But before this, you will have to enable <code class="literal">docker start</code> first. This can also be done by adding your startup script, so that when your server is restarted, and Docker will start automatically start. The recommended practice is that it should start automatically during a server restart. On running the following command, you should be shown the exited process:</p><pre class="programlisting"><span class="strong"><strong>Sudo docker ps -a</strong></span></pre><p>If you want you can remove this process, do so using the <code class="literal">sudo docker rm</code> command. Now let's stop the <code class="literal">slave2</code> server. Wait until it gets stopped. Wait for a few seconds for Marathon to detect this. You will notice that it has detected the failure and our Cassandra has <span>started</span><a id="id325485937" class="indexterm"></a> working on slave1. This is how we can check and test the failover. So let's go to the server and validate this. On our <code class="literal">slave1</code> server, enter <code class="literal">sudo docker ps -a</code>, and you will be able to find our Cassandra image. You can check our container by using the following command:</p><pre class="programlisting"><span class="strong"><strong>sudo docker exec -it {container ID} cqlsh</strong></span></pre><p>You will enter <code class="literal">cqlsh</code>, and now you can verify the keyspaces by using the following command:</p><pre class="programlisting"><span class="strong"><strong>describe keyspaces</strong></span></pre><p> </p><p>You will notice the <code class="literal">production</code> keyspace, <code class="literal">devtest</code>, and <code class="literal">devtest1</code> are available. This show that even if your server is down, the Cassandra database continues to work automatically. It has also attached the external storage, which is AWS EBS, with the help of the REX-Ray volume driver.</p><p>This is how you can deploy the Cassandra database on a Mesos cluster. You can not only attach a Cassandra database, but any other database as well, including MySQL or Spark, or any other tool for which you want high availability, which is often mission-critical for businesses. You can <span>deploy</span><a id="id325489799" class="indexterm"></a> it on Apache Mesos and take advantage of this.</p></div>