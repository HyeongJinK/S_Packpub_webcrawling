<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec41"></a>Introduction to persistent volumes</h2></div></div><hr /></div><p>To understand persistent volumes, first we <span>need</span><a id="id325092406" class="indexterm"></a> to understand the following stateless and stateful applications:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Stateless</strong></span>: With stateless applications, the application <span>does</span><a id="id325489790" class="indexterm"></a> some calculations based on one or more input and sends its results to one or more output. When the application is run on such data, it will do the same job. Usually these types of applications scale very well and are easier to write and maintain.</li><li style="list-style-type: disc"><span class="strong"><strong>Stateful</strong></span>: The stateful <span>application</span><a id="id325489803" class="indexterm"></a> is one that needs to store data, so databases are the best example of stateful applications. A database is a special type of application in which we store the data of our system, which is then stored on disk. In Mesos, on the completion or failure of tasks, all data created by these tasks could be deleted. For example, if one of the applications storing the customer information in the database is lost, terminated, or shut down but state, the database remains the same if you are using persistent volumes. If you are not using persistent volumes, your data will be lost. So, for stateful applications, you should have a persistent volume for the database where your data will get stored and can be retrieved later on if any of the application gets terminated.</li><li style="list-style-type: disc"><span class="strong"><strong>There are two ways to handle the problem</strong></span>: You can use the shared filesystem or the persistent volumes.</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec29"></a>Need for persistent volumes</h3></div></div></div><p>The idea behind persistent <span>volumes</span><a id="id325489821" class="indexterm"></a> is quite easy; the application can reserve some space for specific tasks and mark them as persistent volumes. When the application that is using this space terminates, the newly spawned application will get access to the data created by the previously-terminated application so they can restore the data. We can have a shared filesystem or we can have persistent volumes, as these are the only two ways to handle the problem.</p><p>Here, we will use EBS persistent volumes in AWS to understand how our data will be persisted on the EBS volume using the REX-Ray volume driver. The following procedure illustrates the problem of why we need persistent volumes:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We will run the Redis Docker image from Marathon to deploy on the Mesos slave server, which will save Redis data to a local Docker volume. We will save some data on Redis using the Redis command.</li><li>We cease Docker on the server where the Redis container is running, which will automatically detect the issue and re-run on another server. This means Mesos is notified that something is going wrong (the Redis container is not reachable), and hence it will re-run on another server.</li><li>We will check with the accessibility of the original container's data to understand it more clearly.</li></ol></div><p>Before getting into the practical aspect of how you will perform persistent volume configuration, first we will look at the consequences of not using the persistent volumes. So, let's perform a quick demo here.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>As shown in the following screenshot of our Marathon server, we will run the image by clicking on the <strong class="userinput"><code>Create Application</code></strong> button and providing the following required details:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>ID</code></strong>: <code class="literal">redis-test</code></li><li style="list-style-type: disc"><strong class="userinput"><code>CPUs</code></strong>: <code class="literal"><code class="literal">0.2</code></code></li><li style="list-style-type: disc"><strong class="userinput"><code>Memory (MiB)</code></strong>: 50</li></ul></div></li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/725f4d5c-421f-4506-9a3f-d3ee5e9f4ba4.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>In the left navigation pane, click on the <strong class="userinput"><code>Docker Container</code></strong> pane and type <code class="literal">redis</code> under the <strong class="userinput"><code>Image</code></strong> option:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/f87ae0b1-16d6-4415-af70-22bea338ba22.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Then, click on the <strong class="userinput"><code>Environment Variables</code></strong> pane and fill in the following fields:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Key</code></strong>: <code class="literal">volume</code></li><li style="list-style-type: disc"><strong class="userinput"><code>Value</code></strong>: <code class="literal">redis_vol:/tmp</code></li></ul></div></li></ol></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Click on the <strong class="userinput"><code>Cre</code></strong><strong class="userinput"><code>ate Application</code></strong> button. Now, you can see that <code class="literal">mesos-master2.server</code> is running:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/55043bb8-c45f-44ab-8116-652d5f3ae054.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>The reason why it's run on mesos-master2 is that a Mesos slave is enabled on the master server, so we can have a number of slave servers. So, let's quickly log into the master2 server, to check the Redis process by executing the <span>following</span><a id="id325092088" class="indexterm"></a> command line:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo docker ps -a</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>You can see our Redis container is running here:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/ec395f8e-924c-4f4f-9118-0188c65cf135.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Now, we will enter into this Redis container and save some data by executing the following command line:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo docker exec -it 9ff330e78c79 redis-cli</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Let's save some data and exit:</li></ol></div><pre class="programlisting"><span class="strong"><strong>127.0.0.1:6379&gt; set data loca_Data</strong></span>
<span class="strong"><strong>OK1</strong></span>
<span class="strong"><strong>127.0.0.1:6379&gt; save</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>127.0.0.1:6379&gt; exit</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Let's try to get data that we saved earlier to understand whether we can get this saved data after running another container on the server:</li></ol></div><pre class="programlisting"><span class="strong"><strong>127.0.0.1:6379&gt; get data
"loca_Data"
</strong></span><span class="strong"><strong>127.0.0.1:6379&gt;</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>So, what we are going to do here is stop the Docker container or process that we already ran on mesos-master2 by executing the following command line:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo service docker stop</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>You can see the following output:</li></ol></div><pre class="programlisting"><span class="strong"><strong>Redirecting to /bin/systemctl stop docker.service</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Let's go to Marathon console. You can see in the following screenshot that it has detected the issue and it is running on another server now, which is <code class="literal">mesos-slave1</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/16c262a5-5d5c-41c8-9599-a943dab7a90d.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Let's quickly log into the <code class="literal">mesos-slave1</code> server and see whether we can get that data of the container ID:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ sudo docker ps -a</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Remember to change the container ID every time you hit the <code class="literal">exec</code> command to get data from the volumes. As you can see, it says <code class="literal">(nil)</code>, so it has not found the data:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ sudo docker exec -it 1e34d10e43f9 redis-cli
127.0.0.1:6379&gt;
</strong></span><span class="strong"><strong>127.0.0.1:6379&gt; get data
(nil)
</strong></span><span class="strong"><strong>127.0.0.1:6379&gt;</strong></span></pre><p>This means, along with the creation of a container on another server, the local volume got created on the local server, which disabled the access to the data created on our <code class="literal">master2</code> server.</p><p>Now we understood why persistent volumes are necessary for our stateful applications. In the preceding example, we started a Redis container with Redis volume using Marathon to deploy on a Mesos slave. The Redis image failed to get the volume from the old node and instead it <span>created</span><a id="id325092494" class="indexterm"></a> a new Redis volume on a new server, which disabled the access to the created data.</p><p>Let's see the following <span>limitations</span><a id="id325092505" class="indexterm"></a> of Redis:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Lack of external storage support</strong></span>: By default, Docker stores all the volumes in the <code class="literal">var/lib/docker</code> directory, which can become an obstacle to its capacity and performance. Failure of the host might lead to the loss of data, disabling the data retrieval.</li><li style="list-style-type: disc"><span class="strong"><strong>Data persistency</strong></span>: Docker data volumes are not globally persistent. The mobility of a Docker container from one physical host to another or the failure of the running Docker container in the node decides the persistency of the Docker volume.</li></ul></div><p> </p></div></div>