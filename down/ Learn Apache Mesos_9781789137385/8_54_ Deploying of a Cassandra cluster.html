<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec54"></a>Deploying of a Cassandra cluster</h2></div></div><hr /></div><p>Let's see how we can deploy an Apache Cassandra <span>cluster</span><a id="id325092054" class="indexterm"></a> on our Apache Mesos cluster using the Marathon framework. Before we start, let's quickly review our two JSON files, which will create one Cassandra container each on our Apache Mesos cluster. Let's check our JSON files:</p><div class="mediaobject"><img src="/graphics/9781789137385/graphics/5df152e0-4d82-449d-80bd-d5d6fd788f95.png" /></div><p>You can see that we have the <code class="literal">id</code> as <code class="literal">cassandra1</code>, which is our container. We are not using <code class="literal">cmd</code> command hence, <code class="literal">"cmd": null</code>. We have defined <code class="literal">cpus</code> as <code class="literal">1</code>, and memory is around 8 GB. We have not defined any disk, as we will be using external storage, which is AWS EBS. We wull also define <code class="literal">instances</code> as <code class="literal">1</code>, and <code class="literal">constraints</code> is <code class="literal">UNIQUE</code>, as we will use a unique server to deploy these <span>Cassandra</span><a id="id325490211" class="indexterm"></a> images. We will use <code class="literal">DOCKER</code> as our container type, and the <code class="literal">image</code> will be <code class="literal">cassandra</code>. This will pull the <code class="literal">cassandra</code> image from Docker Hub. Then, we have defined some environments: <code class="literal">CASSANDRA_CLUSTERNAME</code>, <code class="literal">CASSANDRA_SEEDS</code>, and the most important part, the <code class="literal">volume-driver</code>. We are using the <code class="literal">rexray/ebs</code> volume driver, which is for AWS EBS. This will create a volume on our AWS. The volume will be defined as <code class="literal">data1</code>, and will be mounted to <code class="literal">var/lib/cassandra</code>. We will keep the rest as default. Next, we'll deploy the JSON file using <code class="literal">curl</code> and hit <span class="emphasis"><em>Enter</em></span>:</p><pre class="programlisting"><span class="strong"><strong>curl -X POST http://marathon1:8080/v2/apps -d @cassendra1.json -H "Content-type: application/json"</strong></span></pre><p>Let's check our Marathon web console here, you will see <code class="literal">cassandra1</code> was deployed.</p><p>This JSON file will run on <code class="literal">mesos-master2</code>, which is our slave server; refresh the page and you will see the volumes and the data when a volume has been created. Now we will run another JSON file, which means we will be deploying two Cassandra servers in the cluster.</p><p>To deploy the second Cassandra server, we will be following the same procedure as we did for the <code class="literal">cassandra1.json</code> file. Before we deploy the file, let's check the JSON file to verify whether <code class="literal">instances</code> is <code class="literal">1</code>.</p><p>After deploying the JSON file, go to the console and you will see <code class="literal">cassandra2</code> deployed. You can check your EBS volume, the data-persistent volume it has created, and you will find that the <code class="literal">data2</code> volume of 16 GB has been created. Here, we have two servers in the cluster. Let's log in to the Cassandra server and validate these clusters. First, log in to <code class="literal">master2</code> and enter the <code class="literal">sudo docker ps -a</code> command. This should show you the whole Cassandra cluster.</p><p>Enter the same command under <code class="literal">slave1</code>, and you will find the Cassandra server has been deployed.</p><p>Now, enter this command:</p><pre class="programlisting"><span class="strong"><strong> sudo docker exec -it  c70a97cfd470 cqlsh</strong></span></pre><p>Here, <code class="literal">cqlsh</code> is a Cassandra client to connect to your Cassandra server. You will be able to connect.</p><p>Next, repeat the preceding mentioned command for <code class="literal">slave1</code> and enter the <code class="literal">describe keyspaces</code> command. When you initialize the database, it will show that there are five keyspaces created. Now, we will be creating a new keyspace in <code class="literal">master2</code>, and check if it gets replicated on <code class="literal">slave1</code> or not. To check that, we need to enter the following command:</p><pre class="programlisting"><span class="strong"><strong>create keyspace devtest WITH replication = {'class': 'Strategy name', 'replication_factor' :1};</strong></span></pre><p>Here, we created a <code class="literal">devtest</code> keyspace. Check the keyspace created using the <code class="literal">describe</code> command. We need to check this also on <code class="literal">slave1</code>. As you can see, it got replicated automatically across another server.</p><p>We will also create one more keyspace using the <code class="literal">create keyspace</code> command. This will be <code class="literal">devtest1</code>, which is created on <code class="literal">slave1</code> too.</p><p>Now, let's check if any changes made in <code class="literal">slave1</code> are reflected in the <code class="literal">master</code> too. In <code class="literal">slave1</code>, we will create a keyspace, say, <code class="literal">production</code>, using the following command:</p><pre class="programlisting"><span class="strong"><strong>create keyspace devtest WITH replication = {'class': 'Strategy name', 'replication_factor' :1};</strong></span></pre><p>This will create the keyspace. Now, to check the newly created keyspace, run <code class="literal">describe keyspaces</code> on <code class="literal">slave1</code>, as well as on <code class="literal">master2</code>. You will find the keyspace got replicated in <code class="literal">master2.</code></p><p>This is how the Apache <span>Cassandra</span><a id="id325489801" class="indexterm"></a> works in clusters. Now, let's understand how the failover mechanism works here.</p></div>