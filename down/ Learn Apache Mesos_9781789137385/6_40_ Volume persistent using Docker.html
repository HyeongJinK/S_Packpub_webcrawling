<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec42"></a>Volume persistent using Docker</h2></div></div><hr /></div><p>In this section we will see how we can <span>make</span><a id="id325092395" class="indexterm"></a> the volume persistent in our <span>Mesos</span><a id="id325092414" class="indexterm"></a> environment that is using Docker by using <span class="strong"><strong>REX-Ray.</strong></span></p><p>Rex-Ray is a storage-orchestration tool that provides a set of common commands for managing multiple storage platforms. It's built on top of the lib storage 6 framework. REX-Ray enables persistent storage for container runtimes such as Docker and Mesos. The following image shows, that we have a REX-Ray installed on each of the Docker hosts and we have a storage platform:</p><div class="mediaobject"><img src="/graphics/9781789137385/graphics/8bfe6aa5-daf8-4709-ac24-fe4b83989199.png" /></div><p>In our case, the storage platform we will have is our <span class="strong"><strong>Elastic Block Storage</strong></span> (<span class="strong"><strong>EBS</strong></span>), which can be found in AWS. We will use the already-created persistent volume to mount it in the application container, and we will perform the same step we performed in the previous example to understand whether our data remains persistent.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Let's get started by first by installing REX-Ray on an AWS instance where we have a Docker container so that Docker provides the plugin to install REX-Ray:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo docker plugin install rexray/ebs EBS_ACCESSKEY={ACCESSKEY} EBS_SECRETKEY={SECRET_KEY}</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>You need to enter the your ESS access key and secret key you acquired from AWS. You will get the following output:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/73db3858-7d4b-42e4-a6e8-6cd457411784.png" /></div><p>In the preceding screenshot, you can see it is plugging and <code class="literal">rexray/ebs</code> is requesting the following privileges. Type <span class="emphasis"><em>y</em></span> to grant the permission and hit the <span class="emphasis"><em>Enter</em></span> button. This will pull <code class="literal">rexray</code> and install it.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now just clear the screen and execute the following command line to validate the Docker volume:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo docker volume ls</strong></span></pre><p>The preceding command line will generate the following output:</p><div class="mediaobject"><img src="/graphics/9781789137385/graphics/21a9b5e5-76a9-4983-af03-b8dc50592a2f.png" /></div><p>As of now, you don't see any volume with our REX-Ray plugin, but you can see your plugin details here. Here you will see your REX-Ray for Amazon EBS is enabled, so we will do the same thing on all other servers.</p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Let's quickly validate our REX-Ray plugin by executing the following command line:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo docker plugin ls</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>You you see it is enabled on <code class="literal">slave1</code> as well as <code class="literal">slave2</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Now, let's run the <span>Redis</span><a id="id325485777" class="indexterm"></a> container on our Mesos slave servers <span>using</span><a id="id325485785" class="indexterm"></a> Marathon and deploy the Redis container using the persistent volume. Click on the <strong class="userinput"><code>Create Application</code></strong> button and select the <strong class="userinput"><code>General</code></strong> pane to fill in the following fields:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>ID</code></strong>: <code class="literal">redis</code></li><li style="list-style-type: disc"><strong class="userinput"><code>CPUs</code></strong>: <code class="literal">0.2</code></li><li style="list-style-type: disc"><strong class="userinput"><code>Memory (MiB)</code></strong>: <code class="literal">50</code></li></ul></div></li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/e43fe516-1c1d-4c5d-9b3b-6659881eb938.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Click on the <strong class="userinput"><code>Docker Container</code></strong> pane and fill in the following fields:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><strong class="userinput"><code>Image</code></strong>: <strong class="userinput"><code>redis</code></strong>.</li><li style="list-style-type: disc"><strong class="userinput"><code>Host</code></strong>: <strong class="userinput"><code>Bridged</code></strong>.</li><li style="list-style-type: disc"><strong class="userinput"><code>Parameters</code></strong>: We will add two keys here. First, type <code class="literal">volume-driver</code> under the <strong class="userinput"><code>Key</code></strong> field and enter the <code class="literal">rexray/ebs</code> value under the <strong class="userinput"><code>Value</code></strong> option. To add one more parameter here, click on the plus sign and type volume under the <strong class="userinput"><code>Key</code></strong> option, and then enter the <code class="literal">vol_redis:/data</code> value under the <strong class="userinput"><code>Value</code></strong> field:</li></ul></div></li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/5e12a7a5-41b6-4b6e-b976-703a7c096dc8.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Now click on the <strong class="userinput"><code>Create Application</code></strong> button. You will see it's deploying:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/cc3b65f0-7753-4d7e-a9c8-8d47459c38e0.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Let's quickly go to our EC2 management console. Refresh here, and then you will see our volume is created:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/13695994-57b2-470e-b40a-4336fa59bc07.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>So, let's wait for volume to be created, and then your Redis container will come in running state, in <code class="literal">mesos-slave1</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/3fb419cd-442d-4efb-9f5a-4f7de8c39660.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Let's quickly <span>jump</span><a id="id325490088" class="indexterm"></a> into the <code class="literal">mesos-slave1</code> server and <span>check</span><a id="id325490100" class="indexterm"></a> the status of our process by executing the following command line:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo docker ps -a</strong></span></pre><p>The preceding command line will generate the following output:</p><div class="mediaobject"><img src="/graphics/9781789137385/graphics/550d7762-4ad9-42f5-929d-82bbd0434f5d.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Let's enter our container ID, which is <code class="literal">23874</code>, by executing the following command line:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo docker exec -it 23874e561754 redis-cl</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Now we will set the data here and hit <span class="emphasis"><em>Enter</em></span>, as shown earlier. <code class="literal">save</code> and <code class="literal">exit</code> the container:</li></ol></div><pre class="programlisting"><span class="strong"><strong>127.0.0.1:6379&gt; set data persistent_ata</strong></span>
<span class="strong"><strong>127.0.0.1:6379&gt; save</strong></span>
<span class="strong"><strong>127.0.0.1:6379&gt; exit</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>We will stop our Docker process here and Mesos will be notified about the failure, and then it will run this container on another node. Take a look at the following snippet:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ sudo service docker stop</strong></span>
<span class="strong"><strong>connecting to /bin/systemctl stop docker.service</strong></span></pre><p> </p><p> </p><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>As you can see in the following screenshot, as soon as the process is stopped, it tries to migrate on the <code class="literal">mesos-slave2</code> server. Let's wait until it comes into running state:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/994358c6-11db-4f04-b564-f42e074fbbcf.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="16" type="1"><li>So, here you can see it's in running state now:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/08ded5ee-8b38-46bc-be9e-fb6cbbacc86a.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="17" type="1"><li>Let's jump into the <code class="literal">mesos-slave2</code> server. As you can see in the following screenshot, our Redis container has started on the <code class="literal">mesos-slave2</code> server:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/784d2dfe-e825-4734-8ba1-ef0592dd27a9.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="18" type="1"><li>Let's check the <span>process</span><a id="id325092906" class="indexterm"></a> that got migrated from <code class="literal">slave1</code> to <code class="literal">slave2</code> by <span>executing</span><a id="id325092921" class="indexterm"></a> the following command line:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo docker ps -a</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="19" type="1"><li>Perform the following <code class="literal">exec</code> command to enter the container:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo docker exec -it 0545be937c65 redis-cli</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="20" type="1"><li>Run the following command, and then you can see that the persistent data information is available once the container gets migrated to another server:</li></ol></div><pre class="programlisting"><span class="strong"><strong>get data</strong></span></pre><p>The preceding command line will generate the following output:</p><pre class="programlisting"><span class="strong"><strong>"persistent_data"
127.0.0.1:6379&gt;</strong></span></pre><p>So, this is how the REX-Ray volume driver can be used to make your volume persistent across nodes and containers.</p><p>In this example, we started a Redis container with <code class="literal">redis_vol</code> on the server using Marathon. On another node, the Redis image successfully attaches to the existing volume, making data persistent across the nodes.</p><p>Now, let's explore the advantages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Persistent Docker data</strong></span>: We get persistent Docker data using our Mesos configuration and environment with Marathon. The container data is stored on EBS volumes using the REX-Ray volume driver, making it globally persistent, which is useful during containers' migration as well.</li><li style="list-style-type: disc"><span class="strong"><strong>Container migration</strong></span>: Containers can be migrated from one host to another without losing access to the data that has a failover support.</li><li style="list-style-type: disc"><span class="strong"><strong>Failover support</strong></span>: An <span>automatic</span><a id="id325093080" class="indexterm"></a> failure of a container over to a <span>different</span><a id="id325093089" class="indexterm"></a> host provides access to the container data, and we retrieve our data using the persistent volume.</li></ul></div></div>