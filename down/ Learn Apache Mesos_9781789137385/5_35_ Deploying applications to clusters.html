<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec38"></a>Deploying applications to clusters</h2></div></div><hr /></div><p>Before we start deploying the <span>application</span><a id="id325092395" class="indexterm"></a> to the cluster, we'll check what is the <span>current</span><a id="id325245782" class="indexterm"></a> status of the environment. As seen in the following diagram, we have three Mesos masters and two Marathon servers. So, Mesos master has three consoles because we are using three servers, and Marathon has two consoles because we are using two Marathon servers. We need to manage all three consoles every time we need to log in on each console to validate the application status, and the same goes with Marathon to check the information about your application and where it is deployed. Logging into each console every time is time consuming and it takes more effort, so to avoid this we will set up two load balancers in AWS: one for Mesos master, and another for Marathon console.</p><div class="mediaobject"><img src="/graphics/9781789137385/graphics/db839918-6e45-4021-b1e5-973a9907bc3b.png" /></div><p>So, what is load balancing? Elastic Load Balancing automatically distributes incoming traffic across multiple targets. If any instance is down, it will not send traffic on that instance and port, and will keep sending to other instances and ports which are up and running. So, here: you get high availability and you don't have to manage each console every time. So, this is going to make our life easy.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Now, let's set up a load balancer by visiting the EC2 dashboard. On EC2 dashboard, go to <strong class="userinput"><code>Load Balancers</code></strong> and click on <strong class="userinput"><code>Create Load Balancer</code></strong>. Select <strong class="userinput"><code>Application Load Balancer</code></strong> and click on <strong class="userinput"><code>Create</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/43743efd-06e1-4498-b051-fc34faa3ddbb.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Now, we need to provide a name; as we are using Mesos master, we will enter <code class="literal">lb-mesos-master</code>, and then select <strong class="userinput"><code>Scheme</code></strong> as <strong class="userinput"><code>internet-facing</code></strong> load balancer, the <strong class="userinput"><code>IP address type</code></strong> as the <code class="literal">ipv4</code>, and for Listeners, <strong class="userinput"><code>Load Balancer Protocol</code></strong> would be <code class="literal">HTTP</code> and <strong class="userinput"><code>Load Balancer Por</code></strong><strong class="userinput"><code>t</code></strong> is <code class="literal">80</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/56595532-b296-485f-bf1b-eda116821e18.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now we <span>need</span><a id="id325245897" class="indexterm"></a> to add our <strong class="userinput"><code>Availability Zones</code></strong>, so we'll select <strong class="userinput"><code>VPC</code></strong> and <span>select</span><a id="id325245912" class="indexterm"></a> both the availability zones because two master servers are on one availability zone, and the third one is on another. The same will apply to Marathon—one on <strong class="userinput"><code>east-1a</code></strong> and another one <strong class="userinput"><code>east-1b</code></strong>. Then click <strong class="userinput"><code>Next</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/baad9e85-fc87-4d95-80be-f05cf6089c9f.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Next, select <strong class="userinput"><code>Configure Secu</code></strong><strong class="userinput"><code>rity Setting</code></strong>. We are using HTTP <code class="literal">80</code> port here,  not HTTPS. Then click on <strong class="userinput"><code>Next: Configure Security Groups</code></strong>.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note6"></a>Note</h3><p>I would recommend to use HTTPS, but it's not compulsory.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>On <strong class="userinput"><code>Configure Security Groups</code></strong>, check the <strong class="userinput"><code>Create a new security group</code></strong> radiobox. Enter <strong class="userinput"><code>Security group name</code></strong> as <code class="literal">lb-mesos</code>, <strong class="userinput"><code>Type</code></strong> to <code class="literal">Custom TCP</code>, <strong class="userinput"><code>Protocol</code></strong> to <code class="literal">TCP</code>, <strong class="userinput"><code>Port Range</code></strong> to <code class="literal">80</code>, and <strong class="userinput"><code>Source</code></strong> to <code class="literal">Anywhere</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/63ecfe48-6436-46cc-bea0-135bab8e6248.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>So, you will access this load balancer on port <code class="literal">80</code> and the source will be <code class="literal">Anywhere</code>. You can restrict this to your specific IP address but, as of now, we're using <code class="literal">Anywhere.</code> Click on <strong class="userinput"><code>Next: <strong class="userinput"><code>Configure Routing</code></strong></code></strong>, enter <code class="literal">mesos-master</code> as <strong class="userinput"><code>Name</code></strong>, and set <strong class="userinput"><code>Protocol</code></strong> to <code class="literal">HTTP</code> and <strong class="userinput"><code>Port</code></strong> to <code class="literal">5050</code> because our Mesos runs on <code class="literal">5050</code>. Select <strong class="userinput"><code>Target type</code></strong> to <code class="literal">instance</code>. The <strong class="userinput"><code>Health checks</code></strong> settings will stay on default, and then you can click on <strong class="userinput"><code>Next: Register Targets</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/008f8f3a-464c-4c19-9ec0-5e84705be85d.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Now we <span>need</span><a id="id325092473" class="indexterm"></a> to select our three master servers in <span>register</span><a id="id325092482" class="indexterm"></a> targets, so click on <strong class="userinput"><code>Add to registered</code></strong> and the port should be <code class="literal">5050</code>, which we have already defined. Then click <strong class="userinput"><code>Next: Review</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/1c79d771-f894-4862-be97-73cd5467dbd8.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Now we will validate it in the <strong class="userinput"><code>Review</code></strong> step. You will see <strong class="userinput"><code>Load balancer</code></strong>, the <strong class="userinput"><code>Security group</code></strong>, the <strong class="userinput"><code>Routing</code></strong>, where we have created <strong class="userinput"><code>New target group</code></strong>, for which the name is <code class="literal">mesos-master</code>, and the targets. You will also see the instance IDs, which are on port <code class="literal">5050</code>. Then click on <strong class="userinput"><code>Create</code></strong>. Now the creation will start. Let's look at the load balancer. The state is provisioning, so it will take some time to provision your load balancer. After some time, <strong class="userinput"><code>State</code></strong> will become active, so our load balancer is provisioned to us now. We will need the DNS name to access our application.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Before accessing, let's tail the logs of Mesos master. Run the <code class="literal">sudo tail -f /var/log/messages</code> command. We need to tail all three servers to see where our request goes. Now copy the DNS name and paste it in a browser:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/610e0c28-5876-4926-9d17-006ee601a88b.png" /></div><p>The output shows we are able to connect.</p><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Now we'll see on which master it is running. Only the <code class="literal">master1</code> log is moving—that means it has connected to <code class="literal">master1</code>. Let's stop this <code class="literal">master1</code> and see what happens. So, currently our leader is <code class="literal">mesos-master1</code>: press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> and run <code class="literal">sudo service mesos-master stop</code>. So, we have stopped the <code class="literal">master1</code> master. After refreshing, it will see the instance is down and it will forward our request to another available Mesos master:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/f45163c8-f9a4-45ed-a76b-a2d3b09ffaff.png" /></div><p>It will take time, depending on <span>how</span><a id="id325092621" class="indexterm"></a> you have set your monitoring in AWS. If you <span>have</span><a id="id325092630" class="indexterm"></a> set more time, then it will take some time. After some time, we will see our console is up and running again. As we have stopped <code class="literal">master1</code>, the request will go to <code class="literal">master2</code> and, in <code class="literal">master3</code>, we can see the normal logs updating. Load balancer is very helpful for managing our Mesos master console. The same we will set up for <code class="literal">marathon1</code> and <code class="literal">marathon2</code> as well. You can see our cluster has changed, so now the leading is Mesos master: <code class="literal">mesos-master2</code> has control and it will take care of the rest of the stuff. Now start our <code class="literal">master1</code> master back by running the <code class="literal">sudo service mesos-master start</code> command.</p><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec27"></a>Setting up the Marathon</h3></div></div></div><p>Now, let's set up the <span>same</span><a id="id325092712" class="indexterm"></a> for Marathon. Go to the EC2 dashboard and <span>create</span><a id="id325092721" class="indexterm"></a> the load balancer by clicking on <strong class="userinput"><code>Create Load Balancer | Create</code></strong>. The name will be <code class="literal">lb-marathon</code>; otherwise, everything remains the same. On the <strong class="userinput"><code>Configure Security Groups</code></strong> page, select <strong class="userinput"><code>Create a new security group</code></strong>, and the <strong class="userinput"><code>s</code></strong>ecurity group name will be <code class="literal">lb-marathon</code>. We will use the same <code class="literal">80</code> port from <strong class="userinput"><code>Anywhere</code></strong>. Next, on the <strong class="userinput"><code>Configure Routing</code></strong> page, we need to select <strong class="userinput"><code>New target group</code></strong> and, for the <strong class="userinput"><code>Target group</code></strong> field, the name will be <code class="literal">marathon-targetgroup</code>, <strong class="userinput"><code>Protocol</code></strong> will be <code class="literal">HTTP</code>, the <strong class="userinput"><code>Port</code></strong> will be <code class="literal">8080</code>, and <strong class="userinput"><code>Target type</code></strong> is <code class="literal">instance</code>. You can manipulate the setting as per your requirement. So, it will quickly detect the unhealthy node and it will remove it. Next, in <strong class="userinput"><code>Register Targets</code></strong>, we'll select two Marathon servers, then we will add to the registered. Now review all the settings and click on <strong class="userinput"><code>Create</code></strong>. On the dashboard, we will see its state as provisioning and then as active. So, now our Marathon load balancer is up and running. Copy the DNS name and paste it in the browser so it will access one of the Marathon servers and provide the following results:</p><div class="mediaobject"><img src="/graphics/9781789137385/graphics/6c234f68-6685-4ebd-a99f-bf4ad5b4c125.png" /></div><p>Now we will work on deploying the application on the Mesos cluster. But, before that, we need to perform two most important steps. One is to add information about containerizers, and the other is to add a Marathon user on our slave server. There are multiple types of containerizers, but we will add Docker and Mesos. Mesos is the default one, and we will add Docker as we will run our application inside a Docker container. Docker containerizer allows tasks to be run inside a Docker container, so this is enabled when you configure the agent flag as <code class="literal">containerizer = Docker</code>. Then we need to add a Marathon user on all our slave servers as, when Marathon deploys the application, it requires a Marathon user on all the slave servers to deploy the application.</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Now we will enable the containerizer flag, as follows:</li></ol></div><pre class="programlisting"><span class="strong"><strong>cd /etc/mesos-slave</strong></span>
<span class="strong"><strong>pwd </strong></span>
<span class="strong"><strong>sudo vi containerizers</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Add <code class="literal">mesos</code>, then <code class="literal">docker</code> inside the <code class="literal">containerizers</code> file, and restart the server (<code class="literal">:wq!</code>), and then restart the Mesos slave server by running the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo service mesos-slave restart</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Check the status by running the following:</li></ol></div><pre class="programlisting"><span class="strong"><strong>sudo service mesos-slave status</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Do the same thing in <code class="literal">slave2</code>. So, you need to perform these steps on all the servers. Let's add the user. First, we'll check whether we have a Marathon user by running the <code class="literal">id marathon</code> command; if it's not added, add it by running the <code class="literal">sudo useradd marathon</code> command. This step needs to be performed on all of the slave servers.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Let's deploy a sample <span>application</span><a id="id325493693" class="indexterm"></a> using the Marathon <span>framework</span><a id="id325493702" class="indexterm"></a> to the Mesos cluster. Log in to your Marathon. We will deploy the nginx web server. Click on <strong class="userinput"><code>Create Application</code></strong>. Inside the <strong class="userinput"><code>General</code></strong> tab, enter any ID you want, CPUs, and disk space as per your requirement. In <strong class="userinput"><code>Docker Container</code></strong>, for <strong class="userinput"><code>Image</code></strong>, put <code class="literal">nginx</code>, and <strong class="userinput"><code>Network</code></strong> should be <strong class="userinput"><code>Bridged</code></strong>. In the <strong class="userinput"><code>Ports</code></strong> tab, <strong class="userinput"><code>Conatainer Port</code></strong> will be <code class="literal">80</code>, and <strong class="userinput"><code>Name</code></strong> will be <code class="literal">nginx</code>. Click on <strong class="userinput"><code>Create Application</code></strong>. It will start deploying and running. Let's quickly see where it has run that nginx container:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/f62455f5-da88-48cd-96d0-63f051422782.png" /></div><p>So, it's on <code class="literal">mesos-master2</code>. So, this is our slave server.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip7"></a>Note</h3><p>You shouldn't get confused. We have added three master slaves, as well as our Mesos master as a slave.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>If you click on the ID, it will not connect. The reason behind that is we need to allow the port on AWS, so we need to edit the security group to allow the port. Let's go to the EC2 dashboard. Click on <strong class="userinput"><code>Security Groups</code></strong>, click on your security group, which is <code class="literal">mesos1</code>, then click on <strong class="userinput"><code>Edit</code></strong>. We need to add a rule to allow communication on that port and then click on <strong class="userinput"><code>Save</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/a10f3e21-51bf-47a8-9a88-f44cf689a46a.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>We need to add the same thing on another security group (<code class="literal">mesos</code>). After this, refresh the page and you will see you have deployed our nginx container successfully and we can access it:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/a92a7ae8-f1e8-4108-abc8-5ce3cc610acf.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>So, now we will scale it. On the Marathon where nginx is running, we will click on <strong class="userinput"><code>Scale Application</code></strong>, then, in the top-right corner, click on the three dots and select <strong class="userinput"><code>Scale</code></strong>. We will make it <code class="literal">3</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/2a283c0b-40b8-4987-87c1-4631203fc678.png" /></div><p>You will see three instances <span>running,</span><a id="id325493859" class="indexterm"></a> and they have run on <code class="literal">mesos-slave2</code> and <code class="literal">mesos-master1</code>. So, let's try to access it. Let's try <code class="literal">mesos-master1</code>. We can connect to it. For <code class="literal">mesos-slave2</code>, we are <span>unable</span><a id="id325493880" class="indexterm"></a> to connect; this is happening because our host doesn't have a <code class="literal">mesos-slave2</code> entry. So, we will do the Mesos host entry on our local machine. We'll add the IP, <code class="literal">mesos-slave2</code>, and save it. If you refresh now, it will connect. You can scale it further if you want, and you can access any instance. So, this is how you can deploy your application in the Mesos cluster and scale it. You can destroy the application by clicking on the three dots and selecting <strong class="userinput"><code>Destroy</code></strong>.</p><p>We have scaled up and scaled down the nginx container, and now we will see a real-life example where we will run the WordPress container and use the AWS RDS for MySQL database. Let's set up the WordPress container, which connects to the MySQL database. We will be using AWS RDS for MySQL database.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec28"></a>MySQL database on AWS</h3></div></div></div><p>Let's start with <span>setting</span><a id="id325493908" class="indexterm"></a> up MySQL database on <span>AWS</span><a id="id325493916" class="indexterm"></a> as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Go to AWS console, and in the <strong class="userinput"><code>Database</code></strong> section click on <strong class="userinput"><code>Relational Database Service</code></strong>. Then click on <strong class="userinput"><code>Get started now</code></strong>. We need MySQL, so select <strong class="userinput"><code>MySQL</code></strong> and click on the <strong class="userinput"><code>Next</code></strong> button. In the <strong class="userinput"><code>Use case</code></strong> page, select <strong class="userinput"><code>Dev/Test - MySQL </code></strong>and click on <strong class="userinput"><code>Next</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/b02eb2d2-9051-460c-815b-abd78f9fa1c6.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Next, in for DB details, select <strong class="userinput"><code>general-public-license</code></strong> for the <strong class="userinput"><code>License model</code></strong> field, select <strong class="userinput"><code>mysql 5.6.39</code></strong> for the DB engine version, select <strong class="userinput"><code>db.t2.micro</code></strong> for <strong class="userinput"><code>DB instance class</code></strong> field, enter <code class="literal">mesosDatabase</code> for <strong class="userinput"><code>DB instance identifier</code></strong>, then for <strong class="userinput"><code>Master username</code></strong>, enter <code class="literal">tetrauser</code>. Let's provide the DB identifier; we'll use <code class="literal">wordpressmesosdatabase</code>. Specify the master username, <code class="literal">tetrauser</code>, and then we need to specify the master password. We will use the master password <code class="literal">tetra1234</code> and click<strong class="userinput"><code>Next</code></strong>.</li><li>Next, you will see the advanced settings; under the <strong class="userinput"><code>Network &amp; Security</code></strong> tab, do the following configuration:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/be9815db-2073-4bb0-ac19-e55617c3d449.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>For <strong class="userinput"><code>Database options,</code></strong> do the following configuration:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/2e1e71f4-c59d-4e6a-aca7-33c6ab93786c.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>The rest of the settings will remain as is. Next, click <strong class="userinput"><code>Launch DB instance</code></strong>. Your DB instance will be created. Then click <strong class="userinput"><code>View DB instance details</code></strong> to see the DB instance status, which will show <strong class="userinput"><code>creating</code></strong>, so wait until it shows <strong class="userinput"><code>available</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/47774d98-006e-4fe9-a2d4-ebe47beb3f25.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>As our database is up and running, let's allow the traffic from our EC2 instances. For that, we need the security <span>group</span><a id="id325494165" class="indexterm"></a> that we created. You will find it under <strong class="userinput"><code>Details | Security <span>and</span><a id="id325494211" class="indexterm"></a> network | Security groups</code></strong>. Click on it. Under the <strong class="userinput"><code>Inbound</code></strong> tab, click <strong class="userinput"><code>Edit</code></strong>, do the following settings, and click on <strong class="userinput"><code>Save</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/5bd939d1-056a-48f6-9b24-f4a85cef6bc5.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>This will allow our communication between Mesos EC2 instances to our RDS database. Now we will go on one of the instances and try to telnet on the <code class="literal">3306</code> port, which will validate if a connection is established or not. To get the URL for our database instance, go to <strong class="userinput"><code>Relational Database Service</code></strong> and click on our RDB instance. Under the <strong class="userinput"><code>Connect</code></strong> tab, you will find <strong class="userinput"><code>Endpoint</code></strong>, which contains a URL:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/e8a060b8-1470-41fb-83df-2d62d4d003d4.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Copy the URL, go to our SSH console, and paste it with the <code class="literal">telnet</code> command:</li><li>This says we are able to connect to our MySQL successfully on port <code class="literal">3306</code>. Now, deploy our WordPress container on the Mesos cluster using database information. Go to the Marathon load balancer URL, access the Marathon console, and click on <strong class="userinput"><code>Create Application</code></strong>. Enter the ID as <code class="literal">wordpress</code> and the disk space as <code class="literal">500</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/aa8e624b-85cc-4767-960f-2d5839b36419.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>The <strong class="userinput"><code>Docker Container</code></strong> configuration is as follows:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/04b54f4b-e59c-478f-bda6-4d56bff0477b.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>Next, the <strong class="userinput"><code>Ports</code></strong><span>configuration</span><a id="id325494483" class="indexterm"></a> is <span>as</span><a id="id325494491" class="indexterm"></a> follows:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/7fd1891f-effc-487d-a711-ab2ae841e9f3.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>We need to provide additional environment variables for WordPress container to connect to a database. So, go to <a class="ulink" href="https://hub.docker.com/" target="_blank"><span>hub.docker.com</span></a> and see how the WordPress container can be set up. We are using an external database, so we need to use the environment variables <code class="literal">WORDPRESS_DB_HOST</code> or <code class="literal">WORDPRESS_DB_USER</code> and <code class="literal">WORDPRESS_DB_PASSWORD</code>. Let's enter <code class="literal">WORDPRESS_DB_HOST</code> for <strong class="userinput"><code>Key</code></strong>, the DNS name and the <code class="literal">8080</code> port, then add a field and use <code class="literal">WORDPRESS_DB_USER</code> for <strong class="userinput"><code>Key</code></strong>, and <code class="literal">tetrauser</code> for <strong class="userinput"><code>Value</code></strong>. Let's use <code class="literal">WORDPRESS_DB_PASSWORD</code> for <strong class="userinput"><code>Key</code></strong>, and <code class="literal">tetra1234</code> for <strong class="userinput"><code>Value</code></strong>, then click <strong class="userinput"><code>Create Application</code></strong>.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip8"></a>Note</h3><p>I would strongly recommend you use Docker secrets to store your password.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>The status will show <strong class="userinput"><code>Deploying</code></strong>, and then <strong class="userinput"><code>Running</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/4bfa4d8a-edc2-468e-bbfc-08688fe27e9e.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Click on <code class="literal">wordpress</code>, and then click on the ID; it's on <code class="literal">mesos-slave1</code>. We will not be able to connect. Let's see why. Click on <code class="literal">wordpress</code> and <strong class="userinput"><code>Configuration</code></strong>. So, you see what we have done there; we have given <code class="literal">8080</code> instead of <code class="literal">3306</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/dcd2afe2-aba0-474b-8f29-05c13d60bb99.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>To change the port, go to <strong class="userinput"><code>Edit</code></strong>, then <strong class="userinput"><code>Environment Variables</code></strong>, and inside <strong class="userinput"><code>Value</code></strong>, change it to <code class="literal">3306</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/6e6ea639-9641-41e7-9ff4-8a5b0b3e5c84.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="16" type="1"><li>Click on <strong class="userinput"><code><span>Change</span><a id="id325494716" class="indexterm"></a> an</code></strong><strong class="userinput"><code>d deploy configuration</code></strong>. Now it <span>will</span><a id="id325494728" class="indexterm"></a> show <strong class="userinput"><code>Running</code></strong>; click on <code class="literal">wordpress</code>, then access the URL.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="17" type="1"><li>So, we have the install page for your WordPress, and our instance is able to connect to the database successfully. Now we'll stop the database to see what happens to the page. This will help us to verify that our instance is connecting to our database or whether our container is successfully connecting to our database or not. Go to RDS instances and under <strong class="userinput"><code>Instance actions</code></strong>, select <strong class="userinput"><code>Stop</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137385/graphics/dd976e8a-6f9a-42db-8261-11c72af98ad4.png" /></div><p>So, the database will stop. Now let's try to access it again: it will take time, which means it's trying to connect to the database but it's unable to find it because we have stopped it. So, this proves that we have successfully deployed our WordPress container and it can connect to the database. Let's start the RDS instance again: <strong class="userinput"><code>Instance actions | Start</code></strong>. Now the status will be <strong class="userinput"><code>Starting</code></strong>, so it will take some time. After we have initiated the start command, we will refresh the page and see whether we get the existing WordPress landing screen again. Our database instance is available now. As you can see, the status is available.</p><p>Let's scale up by using <strong class="userinput"><code>Scale Application</code></strong>, and scale to <code class="literal">4</code>. You can see it has scaled on different servers, <code class="literal">master2</code>, <code class="literal">slave1</code>, <code class="literal">master3</code>, and <code class="literal">slave2</code>. Let's try to validate the URL, by clicking on every instance, and it will show the desired output. Now, one thing comes up here. Do we need to access each master server one by one? How will our customer access it? To resolve this issue, we have Marathon-lb, a service discovery and a load balancing tool for Marathon based on HAProxy. It reads Marathon task information and dynamically generates HAProxy configuration details.</p><p> </p><p>You can see when you scale up an application that it dynamically assigns a <code class="literal">31108</code>port for each container. You can see this on <code class="literal">slave1</code>, <code class="literal">master3,</code> and <code class="literal">slave2</code> as well. So, what Marathon-lb does is it automatically checks port assignments and makes changes in the configuration so your <span>customer</span><a id="id325494852" class="indexterm"></a> can connect to the newly <span>available</span><a id="id325494860" class="indexterm"></a> services on different ports. That's the advantage of Marathon-lb. So, as soon as the service is available, it discovers that service and it knows on which port it's running, and it makes the changes in the configuration dynamically so our customer can connect to the newly added service. Therefore, to gather the task information, Marathon-lb needs to know where to find Marathon. We will see how to set up the Marathon-lb for service discovery and load balancing to our WordPress container.</p></div></div>