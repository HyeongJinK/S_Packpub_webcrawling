<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec40"></a>Analysis of point patterns</h2></div></div><hr /></div><p>One of the point <span>pattern</span><a id="id325302936" class="indexterm"></a> processes is called <span class="strong"><strong>Complete Spatial Randomness</strong></span> (<span class="strong"><strong>CSR</strong></span>), which means that the probability of finding events at any point is the same everywhere. There are a <span>couple</span><a id="id325302976" class="indexterm"></a> of methods for testing this, which we'll be discussing next.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec58"></a>Quadrat test</h3></div></div></div><p>In this test, the window is <span>divided</span><a id="id325536939" class="indexterm"></a> into parts and <span>the</span><a id="id325536953" class="indexterm"></a> number of points in each part is computed. If the process is CSR, these numbers in subregions come from a Poisson distribution. Then, using a chi-square test, we can test for CSR.</p><p>We'll work with <code class="literal">ppp3.csv</code>, in this case, and use the <code class="literal">quadrat.test()</code> function from the <code class="literal">spstat</code> package to conduct the quadrat test:</p><pre class="programlisting"># update address as necessary
location3 = read.csv("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter06/Data/ppp3.csv")
ppp_object3 = ppp(location3$lon, location3$lat, c(min(location3$lon), max(location3$lon)), c(min(location3$lat), max(location3$lat)))
quadrat.test(ppp_object3)</pre><p>This gives the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/ab81cbd6-9eae-45df-ab55-535b796095cb.png" /></div><p>As<code class="literal">p-value</code>is much lower than 0.01, we can reject the null hypothesis that the points are completely spatially random, as we can see that there might be some spatial pattern in these events. Also, note that there are some cells or parts where the counts are really small, indicating potential inaccuracies in the chi-square estimate.</p><p>We can check whether there is a clustered <span>pattern</span><a id="id325748891" class="indexterm"></a> by using <code class="literal">alternative = "clustered"</code> inside <code class="literal">quadrat.test()</code>, as follows: </p><pre class="programlisting">quadrat.test(ppp_object3, alternative = "clustered")</pre><p>This gives the following result: </p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/887f4685-d156-40cf-970b-f261561f2cf9.png" /></div><p>As <code class="literal">p-value</code> is way lower than 0.01, we can <span>reject</span><a id="id325753592" class="indexterm"></a> the null hypothesis of CSR in favor of clustered point pattern process.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec59"></a>G-function</h3></div></div></div><p><code class="literal">G-function</code> is a useful <span>function</span><a id="id325753639" class="indexterm"></a> for describing clustering in point patterns. In this process, the distance of the nearest neighbor for each event is calculated and then the cumulative distribution of <span>the</span><a id="id325753648" class="indexterm"></a> nearest neighbor distance is used to give the probability of an event occurring within a distance, <span class="emphasis"><em>d</em></span>. We can use <code class="literal">G-function</code> in R using <code class="literal">Gest()</code>. We can get the range of estimates for <span class="emphasis"><em>d</em></span> values using <code class="literal">envelope()</code>, which presents them as a shaded region. We'll also need to adjust for the events near the window as these points might not give an unbiased nearest-neighbor distance—what can also be given as an argument to <code class="literal">envelope()</code>. If the data is over the envelope or the shaded region, that would indicate clustering:</p><pre class="programlisting">ppp_gf = envelope(ppp_object3, Gest, correction = "border")
plot(ppp_gf, main = "G-function")</pre><p> </p><p>This gives us the following plot:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/80b8a115-0e88-44f8-b0aa-0976675f81fd.png" /></div><p>We can see that our <span>observed</span><a id="id325756120" class="indexterm"></a> cumulative <span>distribution</span><a id="id325756183" class="indexterm"></a> is above the high and low ranges of the theoretical cumulative distribution, therefore suggesting clustering.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec60"></a>K-function</h3></div></div></div><p><code class="literal">K-function</code> is another useful <span>function</span><a id="id325756201" class="indexterm"></a> for clustering point patterns. For different values of distance, <span class="emphasis"><em>r</em></span>, the function takes the average number of events in a radius, <span class="emphasis"><em>r</em></span>, around every event: <span class="emphasis"><em>K(r)</em></span>. Similar to <code class="literal">G-function</code>, we can also use <code class="literal">envelope()</code> to estimate the <span>upper</span><a id="id325756226" class="indexterm"></a> and lower values for every <span class="emphasis"><em>r</em></span> under consideration. Similar to before, if, for the observed data, <span class="emphasis"><em>K(r)</em></span> is greater than the upper limit of the range, there is the possibility of clustering:</p><pre class="programlisting">ppp_gf = envelope(ppp_object3, Kest, correction = "border")
plot(ppp_gf, main = "K-function")</pre><p>This gives us the following plot:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/77fab9f4-5c1f-47e9-919f-6575eea3202f.png" /></div><p>For many points, the observed <span class="emphasis"><em>K(r)</em></span> is higher than the envelope or above the theoretical and the <span>upper</span><a id="id325759264" class="indexterm"></a> range of this value, so we can say that there is clustering.</p><p>If we have a mark and want to <span>test</span><a id="id325759274" class="indexterm"></a> the null hypothesis of CSR, we can use maximum absolute deviation with <code class="literal">mad.test()</code>, as follows:</p><pre class="programlisting">mad.test(ppp_object3, Kest)</pre><p> </p><p> </p><p>This gives us the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/e4b0c5af-7a6d-4def-9995-2c3afdc3dca4.png" /></div><p>As <code class="literal">p-value</code> is lower than 0.01, we can reject the possibility of CSR.</p><p>We can also use the sum of the squared distance between different simulated K-functions to test the null hypothesis of CSR. We can do this using <code class="literal">dclf.test()</code>:</p><pre class="programlisting">dclf.test(ppp_object3, Kest)</pre><p>This gives the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/2b1f05c6-0772-47b0-bd6b-2f91feecc5da.png" /></div><p>As <code class="literal">p-value</code> is 0.01, we can reject the null hypothesis of CSR at 1% level for this test also. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec61"></a>L-function</h3></div></div></div><p><code class="literal">L-function</code> is a <span>simple</span><a id="id325759369" class="indexterm"></a> transformation of <code class="literal">K-function</code> and can be <span>used</span><a id="id325759381" class="indexterm"></a> as an alternative to <code class="literal">K-function</code>. Let's code it:</p><pre class="programlisting">ppp_lf = envelope(ppp_object3, Lest, correction = "border")
plot(ppp_lf, main = "L function")</pre><p>We <span>now</span><a id="id325761179" class="indexterm"></a> see a <span>similar</span><a id="id325761186" class="indexterm"></a> plot to <code class="literal">K-function</code>:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/c53ead75-c60e-43c8-bde2-ee1b368a109c.png" /></div><p>We can use <code class="literal">mad.test()</code> and <code class="literal">dclf.test()</code> with <code class="literal">L-function</code> for the null hypothesis of CSR as we did with <code class="literal">K-function</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec62"></a>Spatial segregation for a bivariate marked point pattern</h3></div></div></div><p>For bivariate marked point <span>pattern</span><a id="id326087795" class="indexterm"></a> processes such as case and control events, a null hypothesis could be the probability of disease being the same in every place against the alternative of it <span>not</span><a id="id326087803" class="indexterm"></a> being the same in all places. The <code class="literal">spatialkernel</code> package allows us to conduct significance tests for spatial segregation. First, we'll need to choose a bandwidth for kernel smoothing. Using the <code class="literal">spseg()</code> function, we can get it in the following way:</p><pre class="programlisting">bandwidth = spseg(marked_ppp, h = seq(0, 100000, by = 50), opt = 1)</pre><p>Now, we are looking for a bandwidth between 0 and 1,00,000 meters with a 50-meter step. Here <code class="literal">opt = 1</code> tells <code class="literal">spseg()</code> to look for the best bandwidth. This returns a list and the best bandwidth is stored in the <code class="literal">hcv</code> element, which we can access using <code class="literal">bandwidth$hcv</code>. Now, to do the test, we'll again use <code class="literal">spseg()</code>, but with <span>some</span><a id="id326087841" class="indexterm"></a> different and some <span>new</span><a id="id326087849" class="indexterm"></a> values for the arguments—now <code class="literal">h</code> will be <code class="literal">bandwidth$hcv</code>, <code class="literal">opt</code> will be <code class="literal">3</code> for conducting the test, and the <code class="literal">ntest</code> argument with a value of <code class="literal">100</code> will be added so we can do 100 simulations:</p><pre class="programlisting">simulations = spseg(pts = marked_ppp, h = bandwidth$hcv, opt = 3, ntest = 100, proc = FALSE)</pre><p>Now we can plot the probability of disease, <code class="literal">"yes"</code>, by using <code class="literal">plotmc()</code> in the following way:</p><pre class="programlisting">plotmc(simulations, "yes")</pre><p>We get the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/4987dfec-a59d-4f7b-8a11-90bf91107107.png" /></div></div></div>