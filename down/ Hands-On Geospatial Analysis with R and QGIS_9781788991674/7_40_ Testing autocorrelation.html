<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec42"></a>Testing autocorrelation</h2></div></div><hr /></div><p>In this section, we'll learn how to <span>test</span><a id="id325302936" class="indexterm"></a> spatial autocorrelation. In this test, we examine whether the assumption of the independence of observations from one another is true. In a normal distribution, we assume that observations are independent of each other, which is likely not to be true for spatial data, according to the first law of geography:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Everything is related to everything else, but near things are more related than distant things.</em></span></p></blockquote></div><p>As such, it is important to test for spatial autocorrelation when dealing with spatial data. Unlike with point pattern data, we are considering data that is picked or the location of which is fixed by the observer (for example, survey data with location information).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec63"></a>Preparing data</h3></div></div></div><p>We'll be working with migration <span>data</span><a id="id325759350" class="indexterm"></a> from the Sylhet division of Bangladesh (this data is fictitious and created for the sake of demonstrating different spatial analysis examples). In the <code class="literal">migration.csv</code> CSV file, we have data for 30 <span class="emphasis"><em>thanas</em></span> (administrative units) of Sylhet. This file has six columns, where the first column, <code class="literal">ID</code>, represents the unique ID of each area for which data is compiled; <code class="literal">val</code> represents the percentage of population in that area that have migrated; <code class="literal">agri</code> represents the percentage of agricultural area to total area; <code class="literal">pop</code> represents the population, in millions, of that area; <code class="literal">migration</code> represents the total number of people who have migrated; and <code class="literal">density</code> represents the population density for each area. We also have a shapefile, <code class="literal">syl_div.shp</code>, which has 30 polygons corresponding to the 30 <span class="emphasis"><em>thanas</em></span> we have in the <code class="literal">migration.csv</code> file. In the <code class="literal">syl_div.shp</code> file, the unique identifier for each polygon is saved in the field named <code class="literal">ID_4</code>. </p><p>Let's import the CSV file first and have a look at the first few observations of its columns:</p><pre class="programlisting">migration = read.csv("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter07/Data/migration.csv")
head(migration)</pre><p>We see that it has six columns, as expected:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/aa31e5c8-ff94-4f74-9f7d-d0c2c95e80b4.png" /></div><p>Now, using <code class="literal">readOGR()</code> of the <code class="literal">spdep</code> library, we read in the <code class="literal">syl_div.shp</code> shapefile:</p><pre class="programlisting">library(rgdal)
syl = readOGR("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter07/Data", "syl_div")</pre><p>We can also change the projection to longitude and latitude using <code class="literal">spTransform()</code> of the <code class="literal">sp</code> package in the following way:</p><pre class="programlisting">library(sp)
syl = spTransform(syl, CRS("+proj=longlat +datum=WGS84"))</pre><p>This now reprojects our data into longitude and latitude. Now we need to add the CSV file information to our <code class="literal">spatialPolygonsDataFrame</code> file, <code class="literal">syl</code>. Using <code class="literal">merge()</code> and showing the two unique identifiers for the <code class="literal">ID_4</code> shapefile and the <code class="literal">ID</code> CSV file, we can do this in the following way:</p><pre class="programlisting">migration_spdf = merge(syl, migration, by.x="ID_4", by.y="ID")
class(migration_spdf)</pre><p>We can see that the class of <code class="literal">migration_spdef</code> is <code class="literal">spatialPolygonsDataFrame</code>:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/55de3c49-8416-4414-8cc2-62a3fa152c5b.png" /></div><p> </p><p>This <code class="literal">spatialPolygonsDataFrame</code> class now has all of the information from the CSV file added to each of the polygons.</p><p>Let's have a look at the percentage of migrated people for each of the polygons (<span class="emphasis"><em>thanas</em></span>) using <code class="literal">spplot()</code>:</p><pre class="programlisting">spplot(migration_spdf, zcol="val")</pre><p>We get the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/1dedefaf-f759-4a56-a114-2dbb5fc949a4.png" /></div><p>It looks as if there is a spatial pattern in migration; for example, in the southwest region, we see the lowest percentage of migration. We'll be using Moran's I index here to measure autocorrelation in the next segment.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec64"></a>Moran's I index for autocorrelation</h3></div></div></div><p>Moran's I index is an <span>index</span><a id="id325937543" class="indexterm"></a> for measuring autocorrelation. To run this test, we need to get neighboring polygons for each polygon, and we'll use the <code class="literal">poly2nb()</code> function of the <code class="literal">spdep</code> package to make a list of neighbors, a type known as an <code class="literal">nb</code> object in the <code class="literal">spdep</code> package. Then, we'll need to convert this <code class="literal">nb</code> object into a <code class="literal">listw</code> object using <code class="literal">nb2listw()</code> to create a list of neighbors along with their weights. Let's first create the <code class="literal">nb</code> object, a list of neighbors for each polygon in <code class="literal">migration_spdef</code>:</p><pre class="programlisting">library(spdep)
neighbor_syl = poly2nb(syl)</pre><p>Now let's plot this <code class="literal">nb</code> object on the map to see what it has done:</p><pre class="programlisting">plot(syl, col="gray") 
plot(neighbor_syl, coordinates(syl), add = TRUE, col="blue")</pre><p>Now we see that the neighborhoods are shown using connected lines:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/46bd55de-cb8e-4074-91da-5fe6006e8cf5.png" /></div><p>We can get the value of Moran's I index using <code class="literal">moran.test()</code> in the following way:</p><pre class="programlisting">moran.test(migration_spdf$val, nb2listw(neighbor_syl))</pre><p>This gives us the following result:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/21e4c867-2b1c-4329-8535-eda5712f29f8.png" /></div><p>We find that <code class="literal">p-value</code> is a very small number (much less than 0.05), and so we can reject the null hypothesis of no autocorrelation in favor of autocorrelation.</p><p>We can also use simulation to test the significance of Moran's I; we do so by doing a number of permutations of the data and assignments to polygons. We calculate Moran's I for each of <span>these</span><a id="id326002937" class="indexterm"></a> permutations and then, using this, we can get <code class="literal">p-value</code>. In R, we can use <code class="literal">moran.mc()</code> for simulation:</p><pre class="programlisting">moran.mc(migration_spdf$val, nb2listw(neighbor_syl), nsim = 499)</pre><p>Here, we have simulated 499 times, and the result is as follows:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/ad48cc01-cfc7-41f6-9d27-ff2efb6fa558.png" /></div><p> </p><p>We can also see here that <code class="literal">p-value</code> is <code class="literal">0.002</code>, and so we can reject the null hypothesis of no autocorrelation.</p></div></div>