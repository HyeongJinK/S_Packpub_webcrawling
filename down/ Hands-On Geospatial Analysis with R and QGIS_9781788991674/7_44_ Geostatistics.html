<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec46"></a>Geostatistics</h2></div></div><hr /></div><p>In geostatistics, observed <span>variables</span><a id="id325302936" class="indexterm"></a> are random, with the assumption that we observe them as outcomes of random processes. Usually, the data is observed in discrete locations of a spatially continuous regions, and we are interested in the prediction of values in non-observed locations in the given region. For example, soil salinity is measured in certain points in an area, and we are interested in predicting or interpolating soil salinity in every point under this area. Now, soil salinity in a point could depend on multiple factors: it could be due to its proximity to the saline-affected area, its spatial autocorrelation, the climate, or a random process. Other examples of geostatistical data include rainfall data, air quality, and measurements of chemical components at multiple locations in an area.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec69"></a>Some important concepts</h3></div></div></div><p>Covariance is a measure of dispersion. An analogous measure for geostatistical data is a <span class="strong"><strong>covariogram</strong></span>, which is <span>the</span><a id="id325752053" class="indexterm"></a> same as covariance with the only difference being that observations are spatially indexed and covariance between <span>points</span><a id="id325753585" class="indexterm"></a> is measured at a <span>fixed</span><a id="id325753593" class="indexterm"></a> separation distance. Similar to the case with correlation, we have a <span class="strong"><strong>correlogram</strong></span> for spatial data where, again, observations are spatially indexed and we take correlation between pairs of points at a given separation distance. Now, if we plot a correlogram for all possible separation distances, or lags, we get a correlogram plot.</p><p>We need second-order stationarity to explain local variation using covariograms. <span class="strong"><strong>Second-order stationarity</strong></span> conditions stipulate that the expected value of the variable is independent of the points and that the covaroigram for any <span>distance</span><a id="id325753644" class="indexterm"></a> is independent of the points.</p><p>We'll work with the <code class="literal">meuse</code> dataset from the <code class="literal">sp</code> package. Let's load this dataset and use its coordinates to turn it into a <code class="literal">SpatialPointsDataFrame</code> instance:</p><pre class="programlisting">library(sp)
data(meuse)
coordinates(meuse) = c("x", "y")
head(meuse@data)</pre><p>We now see the first five rows of this <code class="literal">meuse</code> dataset as follows:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/5530902d-01b4-43b8-8d5b-09528659e8c0.png" /></div><p>We'll only work with data in the <code class="literal">zinc</code> column, and so now we subset this data from the <code class="literal">meuse</code> dataset:</p><pre class="programlisting">meuse_coord = meuse@coords
zinc = meuse@data[, 4]
# cbind this two
meuse_zinc = cbind(meuse_coord, zinc)
head(meuse_zinc)</pre><p>This gives us the following dataset, as we expected:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/10fb2981-bef9-48fe-b44d-cf05e63dca57.png" /></div><p>Now let's map the <code class="literal">zinc</code> column of the <code class="literal">meuse</code> dataset to have an understanding of how it looks:</p><pre class="programlisting">spplot(meuse, "zinc")</pre><p>This gives us the following plot:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/a60c227c-85ff-4aa5-b22c-f3b9c0d5fdba.png" /></div><p>Many values of this <code class="literal">zinc</code> column are concentrated in the lower range and, if we use <code class="literal">do.log=TRUE</code>, these values pop up in the plot:</p><pre class="programlisting">spplot(meuse, "zinc", do.log=TRUE)</pre><p>We get the following result:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/cfec08c1-7c71-4442-ba48-a2afa172add2.png" /></div><p>We now see that the values are now segregated in a better way for visualization, as many values fall between 113 and 197.4 and 197.4 and 344.9 (see the preceding plot). </p><p>We'll use the <code class="literal">gstat</code> and <code class="literal">geoR</code> packages to <span>demonstrate</span><a id="id325759254" class="indexterm"></a> how to perform different geostatistical analyses. Now we'll convert the <code class="literal">meuse_zinc</code> DataFrame into a class of <code class="literal">geodata</code> defined in the <code class="literal">geoR</code> package using the <code class="literal">as.geodata()</code> function:</p><pre class="programlisting">meuse_zinc = as.geodata(meuse_zinc)
class(meuse_zinc)</pre><div class="mediaobject"><img src="/graphics/9781788991674/graphics/4154b247-b8ef-41ef-9b82-d800b3492cc2.png" /></div><p> </p><p>We see that the type of data is now <code class="literal">geodata</code>. Now we can apply various functions in the <code class="literal">geoR</code> package. We'll, in fact, use both the <code class="literal">meuse</code> dataset's <code class="literal">SpatialPolygonsDataFrame</code>, which is to be used with the <code class="literal">gstat</code> package; and the <code class="literal">meuse_zinc</code> dataset, which is to be used with the <code class="literal">geoR</code> package.</p><p> </p><p>Let's also plot these points depending on which quantiles they belong to, indicated by size and color, using the <code class="literal">points.geodata()</code> function of the <code class="literal">geoR</code> package as follows:</p><pre class="programlisting">points.geodata(meuse_zinc, xlab="X", ylab="Y", pt.divide="quintile")</pre><p>This gives us the following plot:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/03f0b817-bd2b-4d9d-9b9f-47147d0de576.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec70"></a>Variograms</h3></div></div></div><p><span class="strong"><strong>Semivariance</strong></span> is the squared <span>difference</span><a id="id326111907" class="indexterm"></a> between two <span>points</span><a id="id326111915" class="indexterm"></a> divided by two. A <span class="strong"><strong>v</strong></span><span class="strong"><strong>ariogram</strong></span> cloud plots all of the squared differences of all pairs of points as a function of separation distance. A <span>variogram</span><a id="id326111929" class="indexterm"></a> is the expected squared difference of all pairs of points for a separation distance.</p><p>The <span class="strong"><strong>n</strong></span><span class="strong"><strong>ugget</strong></span> is the <span>value</span><a id="id326111945" class="indexterm"></a> of the semivariance at the starting location, which reflects the measurement error. The <span class="strong"><strong>s</strong></span><span class="strong"><strong>ill</strong></span> is where the semivariogram reaches its maximum height. The <span class="strong"><strong>r</strong></span><span class="strong"><strong>ange</strong></span> is the <span>distance</span><a id="id326112036" class="indexterm"></a> beyond which the variogram value doesn't change much. A partial sill is defined as the difference between the sill and the nugget.</p><p>There are different variogram models, including pure nugget effects, linear models, spherical models, Gaussian models, and parabolic models. Depending on the plot of the variogram, we can decide which model to fit.</p><p>We now plot the variogram cloud and variogram using the <code class="literal">geoR</code> package and the <code class="literal">variog()</code> function:</p><pre class="programlisting">#Set the chart to one row, two columns 
par(mfrow=c(1,2))
# Variogram cloud
plot(variog(meuse_zinc,option="cloud"),main="Variogram Cloud")
#Variogram 
plot(variog(meuse_zinc),main="Binned Variogram")
# draw a line
lines(variog(meuse_zinc))
# set the default chart setting to 1 row, 1 column
par(mfrow=c(1,1))</pre><p>This gives us the following plot:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/fe470319-05ec-4346-8a8c-c0689a3869b9.png" /></div><p> </p><p>We see that semivariance reaches its maximum at about a distance of 1,500 units, and then it comes down. From the preceding variogram, it looks like the value of the nugget is 750,000, and the value of the sill is 180,000 as, at this point, semivariance reaches the maximum height.</p><p>Now, we'll use the <code class="literal">variogram()</code> function of the <code class="literal">gstat</code> package to plot the variogram:</p><pre class="programlisting">library(gstat)
plot(variogram(zinc ~ 1, meuse))</pre><p>We get the following result:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/4aa1f977-4b1a-425d-8e0c-657d5e560d32.png" /></div><p>Note that here, a distance of up to 1,500 is considered instead of the distance 4,000+ considered in the variogram fitted by <code class="literal">variog()</code> in the <code class="literal">geoR</code> package. The reason for this is that, as we go further away from a point, we see a greater variation in semivariance value, which actually doesn't add much information, and so <code class="literal">gstat</code> uses a cutoff value.</p><p>Let's have a look at the <code class="literal">summary</code> of this dataset:</p><pre class="programlisting">summary(meuse_zinc)</pre><p>We get the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/29dddc70-f459-41c4-9c73-f32b8f503bd0.png" /></div><p>We see that the <span>minimum</span><a id="id326112718" class="indexterm"></a> distance is 43.93 and the maximum distance is 444.76. Now we'll plot between 40 and 1,600 in the following way:</p><pre class="programlisting"># Variogram
model = variog(meuse_zinc,uvec=seq(40,1600,l=15),bin.cloud=T)
plot(model,main="Variogram Cloud", bin.cloud=T)</pre><p>We get the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/44231d6a-9dc7-4a23-89e7-b5cdc3ee2545.png" /></div><p>We see that there are 15 bins, clouds, and box plots together.</p><p>Now, let's use the <code class="literal">variofit()</code> function of the <code class="literal">geoR</code> package to automatically fit a line to it:</p><pre class="programlisting">model = variog(meuse_zinc)
model_fit = variofit(model)
model_fit</pre><p>We get the following result:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/e3ef709d-1148-4445-b2cc-e651aff2845b.png" /></div><p>Here <code class="literal">sigmasq</code> is the sill value, and we can see that the value of this is <code class="literal">131205.241</code>.</p><p>Using <code class="literal">vgm()</code> from the <code class="literal">gstat</code> package, we can also model a variogram. A list of the models that we can fit to the sample variogram can be listed as follows:</p><pre class="programlisting">vgm()</pre><p>We get the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/ed4aff2d-8b1b-4bf9-8efb-91a7b877b6be.png" /></div><p>Now we'll fit the <span>variogram</span><a id="id326112810" class="indexterm"></a> parameters of a spherical model to the sample variogram:</p><pre class="programlisting">model2 = variogram(zinc~1, meuse)
fit.variogram(model2, vgm("Sph"))</pre><p> </p><p>We get the following result:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/2cbfa0e9-e6d9-4a2c-a118-5a0abf8f1340.png" /></div><p> </p><p><code class="literal">vgm()</code> can also take a set of models and then return the best model, as follows:</p><pre class="programlisting">model2.fit = fit.variogram(model2, vgm(c("Mat", "Exp", "Gau", "Sph")))
model2.fit</pre><p>We get the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/c33ba1ec-62ec-4a7e-a776-38c2981e96a3.png" /></div><p>We can see that it returns the <code class="literal">Mat</code> model as the model of best fit.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec71"></a>Kriging</h3></div></div></div><p>Kriging is an interpolation process in <span>which</span><a id="id326112908" class="indexterm"></a> interpolated values are due to a Gaussian process. In kriging, a variogram is used to interpolate geostatistical data. Kriging gives us the best, linear, unbiased prediction.</p><p>With the use of observed data and a variogram, kriging computes estimates and uncertainties at unobserved points. There are different types of kriging; we'll discuss some of them briefly now. Ordinary kriging assumes that the mean is constant. Simple <span>kriging</span><a id="id326112920" class="indexterm"></a> assumes that the generalized least squares estimate of the trend coefficients is known. Universal kriging has a local trend component.</p><p>Now we'll use some of these kriging methods. We'll use the <code class="literal">meuse.grid</code> dataset, which contains coordinates of points on a regular grid. We convert it into <code class="literal">SpatialPixelsDataFrame</code>:</p><pre class="programlisting">data(meuse.grid)
coordinates(meuse.grid) = c("x", "y")
meuse.grid = as(meuse.grid, "SpatialPixelsDataFrame")</pre><p> </p><p> </p><p>Now we fit a simple kriging as follows:</p><pre class="programlisting">krig_simple = krige(zinc ~ 1, meuse, meuse.grid, model2.fit, beta = 10)</pre><p>Let's have a look at the names of different contents of <code class="literal">krig_sample</code>:</p><pre class="programlisting">names(krig_simple)</pre><p>We get the following result:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/81bf4ac1-c05e-4687-8c17-697cabb39800.png" /></div><p> </p><p>Let's plot the predicted values contained in <code class="literal">var1.pred</code>:</p><pre class="programlisting">spplot(krig_simple, "var1.pred")</pre><p>We get the following plot:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/aeac9c61-c70c-4142-b290-327ec9f26539.png" /></div><p>We can also compute exceedance probability; for example, we can compute the probability of a value of <code class="literal">zinc</code> being above 1,200:</p><pre class="programlisting">krig_simple$exceedanceProb = 1 - pnorm(1200, mean = krig_simple$var1.pred, sd = sqrt(krig_simple$var1.var))</pre><p>Now plot the exceedance probability as follows:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/48a93b09-27b1-49d8-abd2-2943b6c8f17a.png" /></div><p>It looks like, for most of the area, the exceedance probability is very low.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec23"></a>Checking residuals </h4></div></div></div><p>We can check how well our <span>kriging</span><a id="id326214887" class="indexterm"></a> model is doing in modeling the data and in predicting. We can use cross-validation, which divides data into two parts—training and validation—where we fit the variogram model to the training set and the kriging model on the validation set. We then compare prediction on the validation set with the measured value on the training set.</p><p>Let's create training data with 70% of the <code class="literal">meuse</code> data and create validation data with the remaining 30%:</p><pre class="programlisting">no_rows = dim(meuse@data)[1]
sample_size = floor(0.75 * no_rows)
train_no = sample(seq_len(no_rows), size = sample_size)
train = meuse[train_no, ]
validation = meuse[-train_no, ]</pre><p>Now, fit a variogram to the training data:</p><pre class="programlisting"># In vgm, first argument is partial sill, second is model, third is range
train_fit = fit.variogram(variogram(zinc~1, train), vgm(134746.5, "Mat", 1200, 1))</pre><p>Get a kriging prediction for the validation set as follows:</p><pre class="programlisting">validation_pred = krige(zinc ~ 1, train, validation, train_fit)</pre><p>Now, we'll estimate the R2: </p><pre class="programlisting">kriging_residual = validation$zinc - validation_pred$var1.pred
mean_residual = validation$zinc - mean(validation$zinc)
# R2 computation
1 - sum(kriging_residual^2)/sum(mean_residual^2)</pre><p>We get the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/0c1dd96f-9d43-4bc0-86b8-92bf0ef97734.png" /></div><p>We see that our R2 is only 0.47, which is a poor fit. That means we have to look for other ways to improve the model fitting and prediction.</p><p> </p><p> </p></div></div></div>