<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>GIS in R</h2></div></div><hr /></div><p><span class="strong"><strong>GIS </strong></span>is a combination of software <span>and</span><a id="id325232775" class="indexterm"></a> data that informs us about the location of something and its relation to others. In GIS, every dataset is associated with a coordinate system, which is a system for representing the locations of different geographic features <span>and</span><a id="id326017968" class="indexterm"></a> different measurements. There are two main types of coordinate systems: <span class="strong"><strong>geographic coordinate systems</strong></span> (<span class="strong"><strong>GCS</strong></span>) and <span class="strong"><strong>projected coordination systems</strong></span>. One example of GCS is using latitude-longitude, and one <span>example</span><a id="id326026043" class="indexterm"></a> of a projected coordination system is the transverse Mercator system. Whereas GCS uses a three-dimensional spherical surface, the projected coordination system uses two dimensions for representing spatial data. Data is used in GCS to define the position of the spheroid in relation to the <span>center</span><a id="id326026050" class="indexterm"></a> of the earth; a very commonly used GCS is <span class="strong"><strong>WGS 84</strong></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec10"></a>Data types in GIS</h3></div></div></div><p>There are two <span>main</span><a id="id326026067" class="indexterm"></a> data types in GIS:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Vector</strong></span> data</li><li style="list-style-type: disc"><span class="strong"><strong>Raster</strong></span> data</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec10"></a>Vector data</h4></div></div></div><p>Vector data is good for representing <span>categorical</span><a id="id326026096" class="indexterm"></a> and multivariate data. It also has attribute tables <span>where</span><a id="id326050681" class="indexterm"></a> every record or row corresponds to a feature or an object and every column corresponds to different attributes. Vector data has three different types: <span class="strong"><strong>points</strong></span>, <span class="strong"><strong>lines</strong></span>, and <span class="strong"><strong>polygons</strong></span>. Points data normally refers to data collected at some point in space. Points connect to each other to become lines and represent <span>features</span><a id="id326050702" class="indexterm"></a> such as highways, paths of anything, and so on. If those lines add up to make a closed shape, we get a polygon.</p><p>One commonly used vector <span>data</span><a id="id326050714" class="indexterm"></a> format is shapefile, which is mainly specific to ArcGIS but is widely used now. Shapefile is used to describe vector features such as points, lines, and polygons. For doing so, shapefile uses three to seven files for a single map file to describe different components such as geometries or shape format, projection, attributes, and so on. In shapefile, a file with an <code class="literal">.shp</code> extension represents geometry, an <code class="literal">.shx</code> file represents the positional index of the feature geometry, and a file with a <code class="literal">.dbf</code> extension represents attribute formats in the dBASE IV format. There are also other files such as <code class="literal">.prj</code> for projection, <code class="literal">.ixs</code> for geocoding indexes, and some more. But <code class="literal">.shp</code>, <code class="literal">.shx</code>, and <code class="literal">.dbf</code> are essential files for constituting a shapefile for representing vector data.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec11"></a>Raster data</h4></div></div></div><p>Raster data is used for continuous <span>data</span><a id="id326050756" class="indexterm"></a> and stores data in a grid-like arrangement. Raster is good for measuring continuous features such as elevation, vegetation, and so on.</p><p>Now, in the next section, we will have a look at how to work with different vector data in R, starting with point data.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec11"></a>Plotting point data</h3></div></div></div><p>Location is a point characterized by its coordinates. Point data comprises attributes of a location or <span>data</span><a id="id326050774" class="indexterm"></a> collected on a parameter from different points. Shapefile is a popular data format for vector data. In R, the <code class="literal">sp</code> package loads shapefile as <code class="literal">SpatialPoints</code> and if it contains attributes, it is saved as <code class="literal">SpatialPointsDataFrame</code>. We can import a shapefile into R, using the <code class="literal">readOGR()</code> function of the <code class="literal">sp</code> package. We have to provide the path to the shapefile as the first parameter for the <code class="literal">readOGR()</code> function and the name of the shapefile is the second parameter. Here, we have to provide the name of the shapefile without the <code class="literal">.shp</code> extension. So, if we want to import a shapefile containing points, we can do so by writing the following:</p><pre class="programlisting"># SpatialPoints
library(sp)
library(rgdal)
library(maptools)
map = readOGR("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter 02/Data","indicator")
plot(map)</pre><p>We see the following map, which just shows point data as a plus point indicating different districts in Bangladesh:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/0ab1bbb0-75c4-40cf-beb9-fa89d168cd84.png" /></div><p> </p><p>Now, let's check the <span>class</span><a id="id326059533" class="indexterm"></a> of this data <code class="literal">map</code>:</p><pre class="programlisting">class(map)</pre><p>The class is <code class="literal">SpatialPointsDataFrame</code>. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec12"></a>Importing point data from Excel</h4></div></div></div><p>We have many arbitrary <span>measures</span><a id="id326059561" class="indexterm"></a> collected for different districts of Bangladesh along with their point coordinates; these measures contain both numeric and categorical values.</p><p>Now, we will import this data into R using <code class="literal">read.csv()</code> as follows:</p><pre class="programlisting">bd_val = read.csv("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter02/Data/r_val.csv", stringsAsFactors = FALSE)</pre><p> We check the structure of this dataset <code class="literal">bd_val</code> using <code class="literal">str()</code>:</p><pre class="programlisting">str(bd_val)</pre><p>We get the following output:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/d1e84e7d-f810-4695-a619-97778c14f55a.png" /></div><p>We see that the type of <code class="literal">bd_val</code> is dataframe. Now, we convert this into <code class="literal">SpatialPointsDataFrame</code> by using <code class="literal">coordinates()</code> and by specifying which columns contain the longitude and latitude of these points. </p><pre class="programlisting"># Convert it into SpatialPointsDataframe
coordinates(bd_val) = c("lon", "lat")
str(bd_val)</pre><div class="mediaobject"><img src="/graphics/9781788991674/graphics/3c726207-384d-4da9-b896-ec59f42e4bee.png" /></div><p>Now, plot this using <code class="literal">plot()</code>:</p><pre class="programlisting">plot(bd_val, col = "blue", pch = 19)</pre><p>Now, we get the following map with blue dot for each point:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/b59b77b1-8adf-4d4a-b581-9d72c07e36ee.png" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec12"></a>Plotting lines and polygons data in R</h3></div></div></div><p><span class="strong"><strong>Lines</strong></span> data <span>consists</span><a id="id326083524" class="indexterm"></a> of lines and, in the <code class="literal">sp</code> package of R, it is stored as a <code class="literal">SpatialLines</code> class. If it <span>contains</span><a id="id326083537" class="indexterm"></a> attributes, it is saved as <code class="literal">SpatialLinesDataFrames</code>. Similarly for polygons, without attributes the class is defined as <code class="literal">SpatialPolygons</code> and with attributes <span>the</span><a id="id326083552" class="indexterm"></a> class is defined as <code class="literal">SpatialPolygonsDataFrame</code>. </p><p>We will load a shapefile consisting of lines attributes, which will be treated as a <code class="literal">SpatialLinesDataFrames</code> class in R<span class="strong"><strong>.</strong></span> Let's load the shapefile of highways in Dhaka, Bangladesh:</p><pre class="programlisting"># SpatialLines
highway = readOGR("F:/Hands-on Geospatial Analysis Using R and QGIS/Chapter02/Data","dhaka_gazipur")
plot(highway)</pre><p>This gives us the following map:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/297d083f-d9db-40d9-8df1-74f47b656b41.png" /></div><p>Now, we will read polygons (a map of Dhaka saved as <code class="literal">dhaka.shp</code>) into R as <code class="literal">SpatialPolygonsDataFrame</code>, and will plot this:</p><pre class="programlisting">map_dhaka = readOGR("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter02/Data","dhaka")
plot(map_dhaka)</pre><p>This gives the following gray map:</p><p> </p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/d37717c0-9860-409c-ae40-09b9713baf47.png" /></div><p>Now, let's have a look at the structure of this <code class="literal">SpatialPolygonsDataFrame</code> to understand how it is being stored and how to access and manipulate it:</p><pre class="programlisting"># Use max.level = 2 to show a reduced or succinct structure
str(map_dhaka, max.level = 2)</pre><p>The structure of <code class="literal">map_dhaka</code> contains<span class="strong"><strong>:</strong></span></p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">@ data</code>: This contains all the attribute information or it contains data.</li><li style="list-style-type: disc"><code class="literal">@ polygon</code>: This stores information on polygons or coordinates.</li><li style="list-style-type: disc"><code class="literal">@ bbox</code>: This contains information on the extent of the map or the coordinates of two corners of the bounding box.</li></ul></div><p>These three parts of <span>the</span><a id="id326112190" class="indexterm"></a> structure are pointed out in <span>the</span><a id="id326112199" class="indexterm"></a> following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/3a7c165f-df13-49b7-bda5-3d33ca3c753d.png" /></div><p>In the preceding screenshot, we can see that it has five slots and each of these can be accessed using <code class="literal">@</code>. If we want to access data and see the first five rows of it, we can do so by doing the following:</p><pre class="programlisting"># load another map
map_bd = readOGR("F:/Hands-on-Geospatial-Analysis-Using-R-and QGIS/Chapter02/Data","BGD_adm3_data_re")
head(map_bd@data)</pre><p>We can see the first five rows of the attribute table now:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/ba7b55c8-0a76-4dcd-8e41-6e2ccd36b9dc.png" /></div><p>Now, let's examine <code class="literal">@ polygons</code>:<span class="strong"><strong> </strong></span></p><pre class="programlisting">str(map_bd@polygons, max.level = 2)</pre><p>What we find is another list of 66 where each list is again 66 polygons and each again has five slots just as <code class="literal">map_bd</code> has. The following is a snapshot of the first few lines of output. The remaining lines have not been shown here for <span>the</span><a id="id326126457" class="indexterm"></a> purposes of keeping <span>the</span><a id="id326126466" class="indexterm"></a> example succinct:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/f8888fbb-81ce-4855-8a60-63296053fed1.png" /></div><p>That means we can also access these lists' slots using <code class="literal">@</code> and any of the five slots previously discussed. We now access the 6<code class="literal">th element</code> of <code class="literal">map_bd</code> and investigate its structure as follows:</p><pre class="programlisting"># 6th element in the Polygons slot of map_bd
sixth_element = map_bd@polygons[[6]]
# make it succinct with max.level = 2 in str() for the 6th element of the bd@Polygons
str(sixth_element, max.level = 2)</pre><p>We can see the structure of the <code class="literal">6th element</code> of the polygon now:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/87ba2dae-922b-4cd7-b8f9-a2eed2bcd925.png" /></div><p>Now, again check the structure of the 2<sup>nd</sup> polygon inside <code class="literal">sixth_element</code>. We can do so by writing the following:</p><pre class="programlisting"># Structure of the 2nd polygon inside seventh_element
str(sixth_element@Polygons[[2]], max.level = 2)</pre><div class="mediaobject"><img src="/graphics/9781788991674/graphics/b18cd4ef-c2d9-4b7d-af3e-fa476a6eefc5.png" /></div><p>Now, we can access these slots and. for demonstration purposes only, we will access <code class="literal">coords</code> and then will plot it:</p><pre class="programlisting"># plot() the coords slot of the 2nd element of the Polygons slot.
plot(sixth_element@Polygons[[2]]@coords)</pre><p>This gives the following graph:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/887ec6e6-2b28-416a-be87-96ac0b280861.png" /></div><p>To access data elements of a <code class="literal">SpatialPolygonsdataFrame</code>, we can use either <code class="literal">$</code> or <code class="literal">[[]]</code> as we can do with a data frame. To access the column or attribute <code class="literal">NAME_3</code>, we can do the following:</p><pre class="programlisting">map_bd$NAME_3</pre><p>This will print all the values of the attribute <code class="literal">NAME_3</code>.</p><p>We can do the same using <code class="literal">[[]]</code> in the following way:</p><pre class="programlisting">map_bd[["NAME_3"]]

</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec13"></a>Adding point data on polygon data</h4></div></div></div><p>Now, we will plot <span>point</span><a id="id326148651" class="indexterm"></a> data on polygon data. For doing so, we will first plot <code class="literal">SpatialPolygonsDataFrame</code> (containing polygons) and then will add <code class="literal">SpatialPointsDataFrame</code> (containing points) using <code class="literal">points()</code>. We do so in the following way:</p><pre class="programlisting"># Adding point data on polygon data
plot(map_bd)
points(bd_val, pch=19, col="blue")</pre><p>This gives us the following map where points are overlaid on the polygon:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/103723f4-6241-438b-a697-09c95c44d3a6.png" /></div><p> </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec13"></a>Changing projection system</h3></div></div></div><p>To change projection, we can use <code class="literal">spTransform()</code> from the <code class="literal">rgdal</code> package. We can do so using a <code class="literal">CRS()</code> argument inside <code class="literal">spTransform()</code>:</p><pre class="programlisting">map_bd = spTransform(map_bd, CRS("+proj=longlat +datum=WGS84"))</pre><p>The preceding code sets the projection <span>system</span><a id="id326157011" class="indexterm"></a> to the longitude and latitude and the GCS to <code class="literal">WGS84</code>. If we want to change the projection to any other layer's (shapefile's) projection inside <code class="literal">CRS()</code>, we can write <code class="literal">proj4string()</code> to get the CRS of a new layer and then set it to that. For example, if we want to set the projection system of a layer <code class="literal">a</code> to the projection system of layer <code class="literal">b</code>, we can do so simply by writing the following: </p><pre class="programlisting">a = spTransform(a, CRS(proj4string(b)))</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec14"></a>Plotting quantitative and qualitative data on a map</h3></div></div></div><p>We can plot quantitative <span>values</span><a id="id326157047" class="indexterm"></a> using the <code class="literal">choropleth()</code> of the <code class="literal">GISTools</code> package. We can generate a <span>choropleth</span><a id="id326157062" class="indexterm"></a> using the following commands:</p><pre class="programlisting"># plot quantitative data
library(GISTools)
choropleth(map_bd, as.numeric(map_bd$value2))</pre><p>We can also write a title and design this map further, but we will do these things in upcoming chapters. This gives us a nice little map:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/6189c73c-563c-4b4d-a529-a91aee3950b4.png" /></div><p>Using <code class="literal">spplot()</code>, we can also plot qualitative data. First, we need to convert this qualitative attribute or column of <code class="literal">SpatialPolygonsDataFrame</code> to a factor variable and use a suitable color range. We have a shapefile of Dhaka's divisions, which consist of seven districts each whose name is stored in the <code class="literal">NAME_3</code> column, and our goal is to color different districts of Dhaka's divisions. Here we have picked seven colors from the <code class="literal">RColorBrewer</code> package as there are seven unique values for the <code class="literal">NAME_3</code> column. Plotting to qualitative data (here the names of the districts) or coloring different districts can be done in the following way:</p><pre class="programlisting"># Plot qualitative data
#install.packages("RColorBrewer")
library(RColorBrewer)
dhaka_div = readOGR("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter02/Data","dhaka_div")
# check how many unique elements map_bd$NAME_3 has by writing unique(dhaka_div$NAME_3)
unique(dhaka_div$NAME_3)
# There are 7 unique districts and so pick 7 colors
colors = colorRampPalette(brewer.pal(12, "Set3"))(7)
dhaka_div$NAME_3 = as.factor(as.character(dhaka_div$NAME_3))
spplot(dhaka_div, "NAME_3", main = "Coloring different districts of Dhaka division", col.regions = colors, col = "white")</pre><p>This gives us the following map with every polygon colored according to its name:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/a2e53106-9423-41bf-8a1a-073988689a67.png" /></div><p>We will be learning easier ways to plot now in the next section.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Using tmap for easier plotting</h3></div></div></div><p>We can map quantitative and qualitative values in a much easier way using the <code class="literal">tmap</code> package. For a simple <span>choropleth</span><a id="id326157269" class="indexterm"></a> map, we can just use the <code class="literal">qtm()</code> function and inside it, there are two arguments. The first one is the shapefile and the second one is the numeric column we want to use for making a choropleth map. First, we need to install and load it before we proceed further:</p><pre class="programlisting"># Using tmap
install.packages("tmap")
library(tmap)</pre><p>We will be using <code class="literal">BGD_adm3_data_re.shp</code> and will use the <code class="literal">value1</code> column for mapping. Let's load this dataset and check the structure of the attribute table associated with this shapefile:</p><pre class="programlisting"># load the map
map_bd = readOGR("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter02/Data","BGD_adm3_data_re")
#head(map_bd@data)
str(map_bd@data)</pre><p>This shows that the numeric column <code class="literal">value1</code> is stored as a factor variable by R:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/f8e5b1a9-5053-4abe-9c9c-5dbfa7d682f3.png" /></div><p>Thus, we need to change its type to numeric. We do this in the following way:</p><pre class="programlisting">map_bd$value1 = as.numeric(map_bd$value1)</pre><p>Now, we are <span>ready</span><a id="id326181249" class="indexterm"></a> to use the <code class="literal">qtm()</code> function and, providing two arguments, the <code class="literal">SpatialPolygonsDataFrame</code> (the imported shapefile) and the column to be used:</p><pre class="programlisting">qtm(shp = map_bd, fill = "value1")</pre><p>The resulting map is as follows:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/f2d53c75-2f12-4891-b9cf-77f27ee30283.png" /></div><p>Similar to <code class="literal">ggplot2</code>, we can add subsequent layers in <code class="literal">tmap</code> for plotting. First, inside <code class="literal">tm_shape()</code>, we provide the <code class="literal">SpatialPolygonsDataFrame</code>, then we can add layers for borders, for fill, and also for style, among other features. Let's make a choropleth map again but <span>this</span><a id="id326181330" class="indexterm"></a> time using <code class="literal">tmap()</code> and also using multiple layers:</p><pre class="programlisting">tm_shape(map_bd) +
 tm_borders() +
 tm_fill(col="value1") +
 tm_compass() + # This puts a compass on the bottom left of the map 
 tmap_style("cobalt")</pre><p>This gives us the following map:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/dc1955ea-eb0c-4d02-964b-d84e121d8bdb.png" /></div><p>We can also use bubble size to correspond to the magnitude of the values using <code class="literal">tm_bubbles()</code> instead of <code class="literal">tm_fill()</code>.</p><pre class="programlisting">tm_shape(map_bd) +
 tm_bubbles(size = "value1", style = "quantile") +
 tm_borders(col="orange3") # Add a colorful border</pre><p>Now, we will see a beautiful map of Bangladesh with the values plotted as bubbles.</p><p>We can also label this map very easily with <code class="literal">tmap</code>. We need to use <code class="literal">tm_text()</code> as a new layer and <span>specify</span><a id="id326181758" class="indexterm"></a> which column it should use for labeling. As <code class="literal">map_bd</code> corresponds to the districts of Bangladesh and its name is represented by the <code class="literal">NAME_3</code> column, we will use that for labeling, using <code class="literal">text = "NAME_3"</code> inside <code class="literal">tm_text()</code> as follows:</p><pre class="programlisting"># labeling
tm_shape(map_bd) +
 tm_fill(col = "value1", style = "quantile") +
 tm_borders() +
 tm_text(text = "NAME_3", size = 0.5)</pre><p>We can also use <code class="literal">tm_credits()</code> for adding a credit to the map or to just put some relevant text on the map. It has a position argument, and by using this we can position it in different places on the map. Now, we are going to add credits and some text regarding the quantitative variable we are using as follows:</p><pre class="programlisting">tm_shape(map_bd) +
 tm_fill(col = "value1", style = "quantile", title = "Value of quantitative indicator", palette = "Blues") + 
 tm_borders(col = "grey30", lwd = 0.6) +
 tm_text(text = "NAME_3", size = 0.5) +
 tm_credits("Source: Author", position = c("right", "top"))</pre></div></div>