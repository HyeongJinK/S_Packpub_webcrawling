<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec45"></a>Spatial interpolation</h2></div></div><hr /></div><p>Spatial interpolation is a <span>technique</span><a id="id325302946" class="indexterm"></a> for predicting spatial data in a place where there is no observed data. This technique uses observed data for interpolation. Now we'll work with arbitrary meteorological data recorded in several locations of areas surrounding Dhaka, Bangladesh. We'll predict temperature at every <span>point</span><a id="id325302954" class="indexterm"></a> of the raster that covers this area. For doing so, we consider the raster of the <span class="strong"><strong>Digital Elevation Model</strong></span> (<span class="strong"><strong>DEM</strong></span>) and use its extent to generate a raster and plot point data on this raster. Then, using different interpolation techniques, we'll predict temperatures at every other point of the raster file.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec67"></a>Nearest-neighbor interpolation</h3></div></div></div><p>We'll then convert this raster data into <span>point</span><a id="id325302981" class="indexterm"></a> data and get the nearest neighbor for each location and <span>assign</span><a id="id325536940" class="indexterm"></a> values to an unobserved point; the values will be those of the nearest neighboring points. This is called nearest-neighbor interpolation. </p><p>Let's load the DEM file first:</p><pre class="programlisting">library(raster)
dem = raster("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter 07/Data/dem.tif") 
plot(dem, main="Elevation")</pre><p>Now have a look at the coordinate reference system of this raster screenshot:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/0a30e101-1b19-4ee1-aaf0-237f6c8fb830.png" /></div><pre class="programlisting">dem@crs</pre><p>We get the following result:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/db069e62-19b2-4bd6-b2cd-7bb979dbf098.png" /></div><p>We'll aggregate 4 x 4 cells to one cell for computational purpose (to get more speed):</p><pre class="programlisting">dem = aggregate(dem, 4)</pre><p>Load the CSV file with temperature data:</p><pre class="programlisting">values = read.csv("F:/Hands-on-Geospatial-Analysis-Using-R-and-QGIS/Chapter07/Data/temp.csv")</pre><p>Now convert this DataFrame into <code class="literal">SpatialPointsDataFrame</code>:</p><pre class="programlisting">coordinates(values) = ~ longitude + latitude</pre><p>We need to set the coordinate reference system of this <code class="literal">SpatialPointsDataFrame</code> using CRS:</p><pre class="programlisting">proj4string(values) = CRS("+proj=longlat +datum=WGS84")</pre><p>As we need to use the raster extent for spatial interpolation, we need to transform the CRS of <code class="literal">SpatialPointsDataFrame</code> to the CRS of the raster file:</p><pre class="programlisting">temp = spTransform(values, CRS(proj4string(dem)))</pre><p>Now we convert the raster cells into points, calculate the distance between each point in the raster, and calculate the nearest point indices:</p><pre class="programlisting"># Convert raster to points
raster = rasterToPoints(dem, spatial = TRUE)
library(rgeos)
# Calculate distance matrix
distance = gDistance(temp, raster, byid = TRUE)
# Calculate nearest point index
nearest_index = apply(dist, 1, which.min)</pre><p>Now, in the attribute table of the raster, we assign new predicted temperature values that are the nearest neighbors to those points in the raster. We, again, then convert into raster data:</p><pre class="programlisting">raster$value = values$value[nearest_index]
raster = rasterize(raster, dem, "value")
plot(raster)</pre><p>We get the following result:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/0bc2a66a-4700-41f4-909d-743487933609.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec68"></a>Inverse distance weighting </h3></div></div></div><p>In <span class="strong"><strong>Inverse Distance Weighting</strong></span> (<span class="strong"><strong>IDW</strong></span>), the predicted <span>value</span><a id="id325759378" class="indexterm"></a> at a point is a weighted average of the values measured at different points. Here, we create a model without independent <span>variables</span><a id="id325761129" class="indexterm"></a> with the following command:</p><pre class="programlisting">install.packages("gstat")
library(gstat)
g = gstat(formula = value ~ 1, data = temp)</pre><p>By using <code class="literal">gstat()</code>, we create a <code class="literal">gstat</code> object that can now be utilized to make predictions of temperature using <code class="literal">interpolate()</code> in the following way:</p><pre class="programlisting">prediction = interpolate(dem, g)</pre><p>Now plot the predicted raster along with the observed data:</p><pre class="programlisting">plot(prediction)
plot(temp, add = TRUE, pch = 18, cex = 0.5)</pre><p>We see that we now have a much smoother prediction of temperature over a continuous area:</p><div class="mediaobject"><img src="/graphics/9781788991674/graphics/927f72d3-09f1-4ab8-a7d7-ba5e5b6ee80c.png" /></div></div></div>