<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec41"></a>Exception handling</h2></div></div><hr /></div><p>Exception handling is crucial for <span>enterprise</span><a id="id325813047" class="indexterm"></a> applications. Exceptions can arise in the middle of execution, such as a <code class="literal">PersonCreationException</code> in our example. Once an exception arises somewhere within the execution, the data will either be persisted in the database or the complete transaction will be rolled back, depending on the exception.</p><p>For example, let's say our <code class="literal">createPerson()</code> function throws <code class="literal">PersonCreationException</code>:</p><pre class="programlisting">public class PersonCreationException extends Exception {
 public PersonCreationException(String message) {
   super(message)
} 
}</pre><p>Since <code class="literal">PersonCreationException</code> is a checked exception, the transaction will not be rolled back if the exception is thrown during the execution of the <code class="literal">createPerson()</code> function. These kinds of exceptions are commonly called <span class="strong"><strong>application exceptions</strong></span>.</p><p>Application exceptions are checked exceptions that either have to be handled in a function, or declared to be thrown in the function declaration. That means that although the <code class="literal">createPerson()</code>function throws an exception, the person object would still be persisted in the database. This is shown in the following code:</p><pre class="programlisting">@Stateless
class App {
    @Inject
    private lateinit var identityCreator: IdentityCreator

   @PersistenceContext(unitName="local")
    private lateinit var entityManager: EntityManager

     @TransactionAttribute(TransactionAttributeType.REQUIRED)
    fun createIdentity(inputData: InputData): Person throws PersonCreationException {
        val person = identityCreator.createPerson(inputData)
        entityManager.persist(person)
        throw new PersonCreationException("exception occurred while 
         creating the person")
        return person
    }

    fun findAllPerson(): List&lt;Identity&gt; {
        return 
         entityManager.createNamedQuery(Queries.FIND_ALL_PERSON,
                               Person::class.java).resultList
    }
 }
}</pre><p>If <code class="literal">PersonCreationException</code> were a runtime exception, the entire transaction would be rolled back. These exception types extend from the <code class="literal">RuntimeException</code> class <span>and</span><a id="id326569597" class="indexterm"></a> are commonly called <span class="strong"><strong>system exceptions</strong></span>:</p><pre class="programlisting">public class PersonCreationException extends RuntimeException {
    public PersonCreationException (String message) {
super(message);
}
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip30"></a>Note</h3><p>The application exception extends from the Java <code class="literal">Exception</code> class. If such an exception is thrown during the execution of EJB- or CDI-managed bean functions, the transaction will not be rolled back, as these kinds of exceptions are expected and the function either declares the exception to be thrown or it handles the exceptions.
The system exceptions are child classes of the Java <code class="literal">RuntimeExeption</code> class. If such an exception is thrown during the execution of a function, the transaction will be rolled back as these kinds of exceptions are not expected at runtime.</p></div><p>However, if we want to roll back the <span>transaction</span><a id="id326569690" class="indexterm"></a> once an exception arises during the execution of the function, we can use the <code class="literal">@ApplicationException</code> annotation with <code class="literal">rollback = true</code>. This makes the exceptions that occur to be treated as application exceptions, which causes the transaction to roll back:</p><pre class="programlisting">@ApplicationException(rollback = true)
public class PersonCreationException extends RuntimeException {
    public PersonCreationException (String message) {
super(message)
}
}</pre><p>Now, if this <code class="literal">PersonCreationException</code> is thrown during the execution, the transaction will be rolled back and the person data would not be persisted into the database:</p><pre class="programlisting">    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    fun createIdentity(inputData: InputData): Person throws PersonCreationException {
        val person = identityCreator.createPerson(inputData)
        entityManager.persist(person)
        throw new PersonCreationException("exception occurred while creating the person")
        return person
    }</pre><p>Similarly, for the CDI-managed beans, the CDI doesn't take the <code class="literal">@ApplicationException</code> annotation into consideration in order to roll back the transaction. These beans can, however, be configured to use the <code class="literal">@Transactional</code> annotation to roll back on a specified exception type:</p><pre class="programlisting">class IdentityCreator {

    @Transactional(rollbackOn = PersonCreationException.class)</pre><pre class="programlisting">fun createPerson(inputData: InputData): Person {
//..
}
}</pre></div>