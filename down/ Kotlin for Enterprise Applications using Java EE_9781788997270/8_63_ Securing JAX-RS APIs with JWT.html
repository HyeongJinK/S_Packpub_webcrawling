<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec63"></a>Securing JAX-RS APIs with JWT</h2></div></div><hr /></div><p>Token-based authentication is more common in the modern <span>enterprise</span><a id="id325808126" class="indexterm"></a> applications because it is stateless, unmodifiable, and of course, secure in nature. JWT is one of the most popular token-based authentication mechanisms. </p><p>A <span class="strong"><strong>JSON Web Token</strong></span> (<span class="strong"><strong>JWT</strong></span>) is a JSON object <span>representation</span><a id="id325601670" class="indexterm"></a> in an encoded format. This is used for authentication and authorization and is based on the RFC 7519 standard. This is a compact JSON model used for managing stateless authentication and claiming verification over the web interactions. In a JWT, the claims are encoded as a JSON object in the payload part of the token. This is digitally signed and secured through the <span>interaction</span><a id="id325601661" class="indexterm"></a> of two parties; for example, this could be the client and the server.</p><p>Once the user is authenticated against the server, the <code class="literal">JWT</code> token is digitally signed and trustable. It carries a sufficient amount of information about the user.</p><p>A service can take this token in the request as part of the existing <code class="literal">auth</code> interaction it had in the first place, and this time, it doesn't look in any LDAP/databases for authentication. This means that once the user is authenticated, the subsequent request need not contain the client credentials. Instead, the client can just pass the token obtained as part of the request, and the server looks at the token and grants the access to the resources based on the token validation.</p><p>The <code class="literal">JWT</code> token can either be passed in the request header or the request parameter, as it is in an encoded format.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec62"></a>The structure of JWT</h3></div></div></div><p>A JWT <span>consists</span><a id="id326441693" class="indexterm"></a> of three parts—the header, payload, and signature.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec56"></a>Header</h4></div></div></div><p>The first part of the token is the header. This <span>provides</span><a id="id326441570" class="indexterm"></a> information, such as which algorithm is being used for signing the token, and the nature of the token. For example, consider the following code:</p><pre class="programlisting">{
  "alg": "HS256",
  "typ": "JWT"
}</pre><p>Note that the header is represented as a JSON object. Here, <code class="literal">alg</code> represents the algorithm used, and <code class="literal">typ</code> indicates the type of token. In this case, this is JWT. Different algorithms, such as <code class="literal">HS256</code>, <code class="literal">HS384</code>, <code class="literal">RS256</code>, and <code class="literal">ES512</code> can be used to sign the token. The type is open for extensibility to support other token types in future.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec57"></a>Payload</h4></div></div></div><p>The second part of the <code class="literal">JWT</code> token is the <span>payload</span><a id="id326229559" class="indexterm"></a>. Here, we have a set of claims that are again represented as a JSON object:</p><pre class="programlisting">{
  "sub": "testuserid",
  "name": "Test User",
  "aud": [
    "https://myserver.com/jwt_token",
    "http://localhost/jwt_token"
  ],
  "iat": 1534935981,
  "exp": 1534937448
}</pre><p>Here, the <code class="literal">sub</code>—the subject of the claim—is an identifier. The claim can have a <code class="literal">name</code> value, and <code class="literal">iat</code> is the timestamp that shows at which point the token is issued. The <code class="literal">exp</code> is the timestamp, indicating at which point the token will expire. The timestamps are shown in epoch format.</p><p><code class="literal">aud</code> is the audience claim that identifies the recipients that the JWT is intended for. Generally, the <code class="literal">aud</code> value is an array of case-sensitive strings, each containing a string or URI value. The interpretation of audience values is generally application-specific.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec58"></a>Signature</h4></div></div></div><p>The third part of the token is the <span>signature</span><a id="id326229961" class="indexterm"></a>, which is a signed version of the previous two elements. This is shown as follows:</p><pre class="programlisting">HMACSHA256(base64UrlEncode(header)+"."+base64urlEncode(payload), secret)</pre><p>Here, we create an <code class="literal">HMACSHA256</code> signed token. We use the <code class="literal">base64UrlEncoding</code> of the header, followed by a period, then a <code class="literal">base64UrlEncode</code> of the payload, which is the collection of the claims and an HMAC secret.</p><p>Depending on the algorithm used, this step of signing the token may vary. However, the idea here is to encode and sign the token with a secret. This becomes the third part of the <code class="literal">JWT</code> token.</p><p>So, our <code class="literal">JWT</code> token is in a format like this:</p><pre class="programlisting">Base64UrlEncode(header).base64Encode(payload).HMACSHA256(base64UrlEncode(header)+"."+base64urlEncode(payload), secret)</pre><p>An example value of the JWT is shown as follows:</p><pre class="programlisting">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.eyJzdWIiOiJ0ZXN0dXNlcmlkIiwibmFtZSI6IlRlc3QgVXNlciIsImlhdCI6MTUzNDkzNzQ0OH0
._mPNoWWCq3dYjN7cU3lemI23Ft_uEyA9woY_dJpu9l0</pre><p>Note that the three parts of the token are separated by the period (<code class="literal">.</code>) character. The JWT of this sort will be passed in the request while making a call to the resource on the server. This <code class="literal">JWT</code> token can be passed as an authorization header, as a <code class="literal">Bearer</code> token, or a query parameter; whichever form that the server's resource can understand.</p><p>One final note about the JWT is that the claims that we use, such as <code class="literal">aud</code>, <code class="literal">iat</code>, <code class="literal">exp</code>, and  <code class="literal">sub</code>, are registered with the IANA (<a class="ulink" href="https://www.iana.org/assignments/jwt/jwt.xhtml" target="_blank">https://www.iana.org/assignments/jwt/jwt.xhtml</a>), the organization that manages these sorts of names used when generating the JWT token information. We can register the new name with the IANA. But this already has a set of reusable claims that are sufficient for the web/REST resource authentication and authorization.</p><p>As we have seen, a JWT is a compact, stateless, digitally signed token that we can use for authentication and authorization mechanisms.</p><p>We will implement a simple example of generating a JWT and validating it to see how to protect a REST endpoint using JWT.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec63"></a>Implementing JWT</h3></div></div></div><p>Let's consider the <span>identity</span><a id="id326441275" class="indexterm"></a> app once again. We implemented <code class="literal">IdentityStore</code> and <code class="literal">AuthMechanism</code> to authenticate the user, and then provided access to the user to invoke the <code class="literal">/organization</code> endpoint.</p><p>We will modify this project to demonstrate the JWT. We will also add a new <code class="literal">/login</code> resource, which takes the user ID and password in the header, and validates it against<code class="literal">IdentityStore</code>, as explained earlier. Let's write this sequence to understand what we intend to do:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/d0cb387c-9bb7-49e1-9b11-0aa87e3bc2f2.png" /></div><p>As shown in the preceding sequence diagram,  <code class="literal">/login</code> is the entry point that takes the user's credentials, which we then validate using the <code class="literal">IdentityStore</code>, before generating the <code class="literal">JWT</code> token and returning it as a response. The end user passes this JWT to invoke the <code class="literal">/organization</code> API.</p><p>Let's take a look at these steps in detail:</p><p>Once the user is authenticated against our custom <span>identity</span><a id="id326441331" class="indexterm"></a> store, we will invoke the <code class="literal">createJWT()</code> function, as follows:</p><pre class="programlisting">public fun createJwt(id: String, issuer: String, subject: String, 
               expiryTime: Long): String {
    val signatureAlgorithm = SignatureAlgorithm.HS256
    val currentTimeInMillis = System.currentTimeMillis()
    val date = Date(currentTimeInMillis)
    val apiKeySecretBytes = DatatypeConverter.parseBase64Binary(SECRET)
    val signingKey = SecretKeySpec(apiKeySecretBytes, 
                          signatureAlgorithm.getJcaName())

    val builder = Jwts.builder()
                      .setId(id)
                      .setIssuedAt(date)
                      .setSubject(subject)
                      .setIssuer(issuer)
                      .setAudience(AUDIENCE)
                      .signWith(signatureAlgorithm, signingKey)

    if (expiryTime &gt;= 0) {
        val expMillis = currentTimeInMillis + expiryTime
        val exp = Date(expMillis)
        builder.setExpiration(exp)
    }
    return builder.compact()
}</pre><p>This function takes an ID, <code class="literal">jwtId</code>, an <code class="literal">issuer</code>, a <code class="literal">subject</code>, and <code class="literal">expiryTime</code> as input arguments. We use the <code class="literal">HMACSHA256</code> algorithm and a defined secret to generate the JWT, and use the <code class="literal">Jwts.builder()</code> method from the <code class="literal">jjwt</code> library to create the token. We will return this token in response to the <code class="literal">/login</code> API.</p><p>Let's invoke a <code class="literal">curl</code> command for the <code class="literal">/login</code> API with valid credentials, as follows:</p><pre class="programlisting">curl -X POST \
  http://localhost:8080/login \
  -H 'Accept: application/json' \
  -H 'Content-Type: application/json' \
  -H 'UserId: testUser'
  -H 'Password: testUserPass' \</pre><p>The output of the preceding REST API call is as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/2c07b503-56be-4939-bc03-94757da8b609.png" /></div><p>The <code class="literal">/login</code> API returns a JWT token, valid for 15 minutes. We passed the expiry time of fifteen minutes when generating the token.</p><p>Now let's try to invoke the <code class="literal">GET</code> organization API with an invalid <span>authorization</span><a id="id326441656" class="indexterm"></a> header and see what happens:</p><pre class="programlisting">curl -X GET \
  http://localhost:8080/organization/4c118afd-eccb-4ac7-bcfc-15e47f10770a \
  -H 'Accept: application/json' \
  -H 'Authorization: Bearer 123' \
  -H 'Content-Type: application/json' </pre><p>The output of the preceding REST invocation is as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/85c4e874-eb21-4df9-aa41-d8a3d0038bef.png" /></div><p>An invalid authorization header resulted in a <code class="literal">403</code> response.</p><p>Now, let's pass the valid JWT that we obtained in the authorization header, as follows:</p><pre class="programlisting">curl -X GET \
http://localhost:8080/organization/4c118afd-eccb-4ac7-bcfc-15e47f10770a\
  -H 'Accept: application/json' \
  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIxMjM0IiwiaWF0IjoxNTM1MDAwNzEzLCJzdWIiOiJzdWIxMjMiLCJpc3MiOiJsb2NhbGhvc3QiLCJhdWQiOiIvand0dG9rZW4iLCJleHAiOjE1MzUwMDE2MTN9.1ZWJlw4zj3xGTghq9Q36GYpy_7cxYCbCN-QJhJ1s_Lk' \
  -H 'Content-Type: application/json'</pre><p>The output of the preceding REST call is as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/74e5b11d-37a6-4788-918b-b81e8793ac7a.png" /></div><p>Now, the  <code class="literal">GET</code> organization API returns the organization details in response.</p><p>So, we have looked at how a REST API can be secured with JWT with a simple use case. In real-world applications, the complexity can be increased by using private and public keys while generating and verifying the JWT.</p></div></div>