<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>Kotlin versus Java</h2></div></div><hr /></div><p>When we think of <span>developing</span><a id="id326226199" class="indexterm"></a> an application, Java is one of <span>the</span><a id="id326226192" class="indexterm"></a> programming languages that comes to mind for various reasons, including its robust and secure nature, and the independence of its platform. Most enterprise applications are built using Java, and this particular programming language has been around for more than 20 years.</p><p>Kotlin is designed to be interoperable with Java, meaning Kotlin can seamlessly co-exist with Java. We can add Kotlin to our existing applications and we can use Java-based frameworks for application development. With this <span class="emphasis"><em>bi-directional use</em></span> of Kotlin, we can invoke Java constructs from Kotlin, or Kotlin constructs from Java.</p><p>Although Java and Kotlin are both JVM-based languages used for application development, there are several differences between them. Kotlin has addressed some of the limitations previously associated with Java.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec18"></a>Null safety issue</h3></div></div></div><p>Accessing a member variable of a <span>null</span><a id="id326166585" class="indexterm"></a> reference will result in a null reference exception. In Java, this is <code class="literal">NullPointerException</code>. Java allows us to assign a null value to any variable that we declare, but when we try to use an object reference that has a null value, it throws <code class="literal">NullPointerException</code>. This is a common problem to do with programming languages. The language allows us to assign a null reference to a member variable, while also allowing us to access that variable without checking whether it is initialized. It would be preferable if the compiler reports such issues. This is exactly what Kotlin compiler does for us. </p><p>In Kotlin, all the types are non-nullable by default. If we try to assign or return a null in the code, it fails to compile. The compiler differentiates between nullable references and non-null references, and the language provides an elegant syntax for null checks. This makes it almost impossible to encounter NPEs in Kotlin. In fact, if we do encounter an NPE, it is likely to be because we explicitly asked Kotlin to throw one, or because the NPE originates from external Java code.</p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"></a>Arrays in Kotlin are invariant</h3></div></div></div><p>Arrays in Kotlin are not built on <span>native</span><a id="id326225992" class="indexterm"></a> types, but are instead based on a Java array. Although these are similar, they do behave slightly differently. In Java, we can assign an array of a type to an array of its parent type. Arrays in Kotlin are invariant, which means that an array of a specific type cannot be assigned to an array of its parent type. It is not possible to assign <code class="literal">Array&lt;Integer&gt;</code> to <code class="literal">Array&lt;Any&gt;</code>. This provides implicit type safety and prevents possible runtime errors in the application. Kotlin also provides specialized classes to create arrays of primitive data types, including <code class="literal">ByteArray</code>, <code class="literal">ShortArray</code>, and <code class="literal">IntArray</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec20"></a>Extension functions</h3></div></div></div><p>Kotlin gives us the ability to extend a class <span>with</span><a id="id325601661" class="indexterm"></a> new functionalities without modifying it. These <span class="emphasis"><em>extension functions</em></span> are not available in Java.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec21"></a>No checked exceptions</h3></div></div></div><p>In Java, exception handling is tedious and controlled by strict rules. Whenever we <span>are</span><a id="id325601681" class="indexterm"></a> dealing with checked exceptions, we can either handle exceptions in <code class="literal">try…catch</code> blocks, or they can be declared to be thrown. In this case, the code is repeated. Kotlin doesn't have any checked exceptions. The <code class="literal">Exception</code> class is extended from the <code class="literal">java.lang.Exception</code> class of the JDK library via <code class="literal">typealias</code>. We don't have to declare or handle the exceptions, thereby reducing a lot of boilerplate code.</p><p>Kotlin also provides other benefits, as explained in the following subsections.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec9"></a>Functional paradigms</h4></div></div></div><p>Kotlin is both an object-oriented and <span>functional</span><a id="id325812925" class="indexterm"></a> programming language. It combines the functional and object-oriented paradigms. Kotlin offers support for lambda functions and higher-order functions, making it a great choice for functional programming.</p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec10"></a>Concise code</h4></div></div></div><p>Kotlin code is elegant and clear and has a lot less boilerplate code than Java. When we compare a Java class and a Kotlin class that perform the same task, the one written in <span>Kotlin</span><a id="id325812947" class="indexterm"></a> will typically be much more concise, clear, and compact than the one written in Java. Kotlin greatly reduces the boilerplate code, meaning we don't need to write getters, setters, or <code class="literal">toString()</code>, <code class="literal">hashCode()</code>, or <code class="literal">equals()</code> functions. Kotlin generates all these constructs by itself, making the language more clean and concise.</p><p>We can choose which language to use for application development. If we already have an application written in Java, we can include Kotlin to get the benefits that it offers so that the code becomes clear, concise, and easy to maintain.</p></div></div></div>