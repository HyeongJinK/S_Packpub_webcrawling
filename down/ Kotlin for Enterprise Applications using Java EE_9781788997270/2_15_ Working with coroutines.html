<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>Working with coroutines</h2></div></div><hr /></div><p>A program in execution that <span>initiates</span><a id="id326155168" class="indexterm"></a> long-running operations, such as file IO, network IO, or CPU- or GPU-intensive work, requires the invoker to block until the operations complete. Programming languages handle this via concurrency. </p><p>The JVM has support for concurrency. Java has had strong support for multithreading and concurrency since its first release. Any process that is running inside the JVM can create a number of threads to execute multiple tasks in an asynchronous fashion. However, developing concurrent code in an optimal and error-free manner and debugging it is really challenging. Java provides various constructs to write concurrent code and, along with other JVM languages and third-party libraries, has tried to come up with innovative and elegant ways to achieve concurrency.</p><p>Java 5 made a lot of progress with regard to writing concurrent applications. It has higher-level constructs, such as the executor framework, which makes it easier to write concurrent code and allows us to decouple thread management code from the business logic. Java 8 has introduced parallel streams to turn the code to concurrent much more easily. RxJava brings reactive extensions to Java, allowing us to write very concise code for asynchronous functionality. Kotlin supports almost all of those approaches and offers a few of its own as well.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec25"></a>Coroutines in Kotlin</h3></div></div></div><p>Kotlin offers a better way to <span>perform</span><a id="id326155050" class="indexterm"></a> asynchronous tasks, called <span class="strong"><strong>coroutines</strong></span>. Coroutines are a <span>new</span><a id="id326155026" class="indexterm"></a> and fluent way of writing asynchronous and non-blocking code in Kotlin. They are much lighter than threads and are easy to manage. Both coroutines and threads are multitasking, but they differ in that threads are managed by the kernel and coroutines are managed by the code itself, thereby giving programmatic control.</p><p> </p><p>Coroutines were introduced in Kotlin 1.1 as an experimental feature. There are two types of coroutines:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Stackful</li><li style="list-style-type: disc">Stackless</li></ul></div><p>A stackful coroutine is a normal function that can be suspended during execution. It will be suspended with its entire stack, including its local variables, and the parameters passed from the invoking function. The stackful coroutine waits for the scheduler to resume its execution, similar to what a thread does. The scheduler can resume either the same coroutine or another suspended coroutine. A stackless coroutine, on the other hand, doesn't have its own stack, so it doesn't have to map on the native thread and doesn't require context switching on the processor.</p><p>Coroutines in Kotlin are based on the idea of suspending functions that can stop execution when they are invoked and resume execution once the task is complete. This utilizes the CPU better than blocking the execution in its entirety.</p><p>Functions can be suspended using the <code class="literal">suspend</code> keyword, and may only be invoked inside other suspended functions or inside a coroutine. Coroutines can run concurrently, similar to threads in Java, and wait for one another, communicating during execution. They are light compared to threads, meaning we can create thousands of them without worrying about the slow performance of an application.</p><p>As mentioned earlier, coroutines have been introduced as an experimental feature in Kotlin and are provided as a library. We need to include this dependency in the Maven or Gradle, or with the classpath in your project:</p><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jetbrains.kotlinx&lt;/groupId&gt;
    &lt;artifactId&gt;kotlinx-coroutines-core&lt;/artifactId&gt;
    &lt;version&gt;0.22.5&lt;/version&gt;
&lt;/dependency&gt;</pre><p>Let's create a Maven project to demonstrate coroutines:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a Maven project using the<strong class="userinput"><code>kotlin-archetype-jvm </code></strong>archetype.<strong class="userinput"><code> </code></strong></li><li>Specify the <code class="literal">groupid</code> and <code class="literal">artifactid</code>.</li><li>This will create a project with the following structure:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/d14dab58-76bc-4e9a-bb73-5f4d14da29c3.png" /></div><p>As coroutines have experimental status in Kotlin 1.1, the compiler reports a warning every time coroutines are used by default.</p><p>To avoid the compiler yelling at us whenever coroutines are used, we have to add <code class="literal">kotlin-maven-plugin</code> to the coroutines flag enabled in <code class="literal">pom.xml</code>:</p><pre class="programlisting">&lt;plugin&gt;
    &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
    &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;args&gt;
           &lt;arg&gt;-Xcoroutines=enable&lt;/arg&gt;
        &lt;/args&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</pre><p> </p><p> </p><p>Note that the <code class="literal">kotlinx-coroutines-core</code> JAR is published at <a class="ulink" href="http://jcenter.bintray.com/" target="_blank">http://jcenter.bintray.com</a>. We have to add it to the <code class="literal">repository</code> section in our <code class="literal">pom.xml</code> file:</p><pre class="programlisting">&lt;repositories&gt;
    &lt;repository&gt;
       &lt;id&gt;jcenter&lt;/id&gt;
       &lt;url&gt;https://jcenter.bintray.com/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</pre><p>The Kotlin library provides <span>different</span><a id="id325601673" class="indexterm"></a> ways to create the coroutines. The most simple <span>way</span><a id="id325601682" class="indexterm"></a> of creating this is the <code class="literal">launch {}</code> function.</p><p>Now, let's write our first coroutine:</p><pre class="programlisting">fun main(args: Array&lt;String&gt;) {
    println("Inside main")

    launch {
        println("Coroutine in execution")
    }

    Thread.sleep(2000)
    println("main completed")
}</pre><p>The program prints the output as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/ecea431f-4d1b-4b6e-811b-ed7272184578.png" /></div><p>This program starts a coroutine and prints the message. The main thread must wait until the coroutine finishes the execution, otherwise the program will end prematurely.</p><p>The <code class="literal">launch</code> function starts a new coroutine. By default, it runs in a shared pool of the thread that is in execution. Threads exist in a program and each thread can run multiple coroutines. This means that the coroutines are much lighter.</p><p> </p><p>There is a construct in Kotlin that can be used to suspend the coroutine—the <code class="literal">delay()</code> function. This function takes time as input which can be of <code class="literal">long/int</code> type:</p><pre class="programlisting">fun main(args: Array&lt;String&gt;){
    println("Inside main")

    launch{
        println("delay in 2 seconds")
        delay(2000L)
        println("Coroutine in execution")
    }

    Thread.sleep(2000)
    println("main completed")
}</pre><p>The output is as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/6edf7725-fb5d-47bc-8f25-d8bf45c7efb3.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>The <code class="literal">delay()</code> function can only be called inside a coroutine. If we try to use it outside the coroutine, the code fails to compile. The <code class="literal">delay()</code> function is declared with the <code class="literal">suspend</code> keyword in its declaration. Any function declared with <code class="literal">suspend</code> can only be invoked from the coroutines or other <code class="literal">suspend</code> functions.
When a coroutine is in a waiting or suspended state, the thread is returned back to the pool. When the waiting/block state is over, the coroutine resumes its execution on a thread that is available in the pool.</p></div><p>Let's create functions that can be called from a coroutine:</p><pre class="programlisting">private suspend fun game1(): String {
    delay(1000)
    return "game1"
}
private suspend fun game2(): String {
    delay(2000)
    return "game2"
}

fun main(args: Array&lt;String&gt;) {
    println("Inside main")

    launch(CommonPool) {
        val one = game1()
        val two = game2()
        println("Game ----- " + one)
        println("Game ----- " + two)
    }
    Thread.sleep(4000)
}</pre><p>The output is as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/10ab36d6-6818-4226-be55-290000dee9d9.png" /></div><p>So far, we have discussed how to create and run coroutines. Note that all the coroutines that we have created so far execute in a serial fashion. In the preceding example, we created two coroutines—<code class="literal">game1()</code> and <code class="literal">game2()</code>. These were executed serially in the main thread. Let's now create coroutines that run concurrently in the main thread.</p><p>We can use <code class="literal">async()</code> to create and <span>execute</span><a id="id325816096" class="indexterm"></a> two <span>coroutines</span><a id="id325816104" class="indexterm"></a> concurrently, as follows:</p><pre class="programlisting">private suspend fun game1(): String {
    delay(1000)
    return "game1"
}
private suspend fun game2(): String {
    delay(2000)
    return "game2"
}

fun main(args: Array&lt;String&gt;) {
    println("Inside main")

    launch(CommonPool) {
        val one = async(CommonPool){
            game1()
        }
        val two = async(CommonPool){
            game2()
        }
        println("Game ----- " + one.await()+": "+two.await())
    }
    Thread.sleep(4000)
}</pre><p>This gives us the following output:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/037f25af-9870-4599-aabb-351dcaa829ee.png" /></div><p>The asynchronous function returns an instance of the <code class="literal">Deferred&lt;T&gt;</code>, type, which has an <code class="literal">await()</code> function that returns the result of the coroutine.</p><p>Now let's look at one more example, where we can really use the power of parallel execution:</p><pre class="programlisting">fun main(args: Array&lt;String&gt;) {
    println("Inside main")

    launch(CommonPool) {
        val deferred = (1..1_000_000)
                .map { n -&gt; async { n }
                }
        var sum = deferred.sumBy { it.await() }
        println("sum ----- " + sum)
    }
    Thread.sleep(4000)
}</pre><p>The output is as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/1d1338ea-ddc7-4bc9-8f87-ae305b8eeb3d.png" /></div><p>When we are performing long-running operations, we need to run these as background tasks.</p><p>In this section, we have learned different ways to create and manage coroutines in Kotlin in <span>order</span><a id="id325818962" class="indexterm"></a> to execute a number of operations in the background, both <span>serially</span><a id="id325818970" class="indexterm"></a> and concurrently.</p></div></div>