<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec75"></a>Profiling</h2></div></div><hr /></div><p>Profiling is another <span>technique</span><a id="id326287550" class="indexterm"></a> that is used to understand how the application behaves. In software engineering, profiling is a form of dynamic program analysis that measures various run-time performance parameters such as memory utilization, timing, control flow, and more.</p><p>Profiling is used to determine the time spent on each function when the application is running. Profiling tools gather runtime information and record resource utilization including memory, CPU usage, the time spent on functions, and so on. Profiling helps identify problems and looks at the code again to reevaluate the choice of data structures used to optimize for better application performance.</p><p>Different tools are available for profiling. Tools such as <code class="literal">jvisualvm</code>, <code class="literal">jstat</code>, JMC, JProfiler, and so on can be used for profiling applications.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec74"></a>Profiling with JProfiler</h3></div></div></div><p>JProfiler is one of the most <span>commonly</span><a id="id326287531" class="indexterm"></a> used tools for <span>profiling</span><a id="id326287010" class="indexterm"></a> in enterprise applications. It is simple to use and integrated with IDEs such as Eclipse, IntelliJ Idea, and many more. It can be used to profile locally deployed applications or remote applications, and it also has support for profiling applications offline.</p><p>Let's launch JProfiler and attach the <span>identity</span><a id="id326286998" class="indexterm"></a> service application that we developed in <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Implementing Microservices with Kotlin</em></span>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>When <span class="strong"><strong>JProfiler</strong></span> starts up, the start page is shown, as follows:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/f8e3eb13-663c-493d-828f-71530aa45093.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>We will profile the get organization API of the identity service app.</li><li>Select the <strong class="userinput"><code>Attach to a running JVM</code></strong> option. This will list <span>running</span><a id="id326166584" class="indexterm"></a> Java processes. We select our identity service, which is running as follows:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/b31c581b-162e-4806-947a-30124bbecb71.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Then it prompts for <span>initial</span><a id="id325442827" class="indexterm"></a> profile settings. Here, we can select <strong class="userinput"><code>Instrumentation</code></strong> or <strong class="userinput"><code>Sampling (Recommended)</code></strong>. We choose <strong class="userinput"><code>Sampling (Recommended)</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/6fa3048d-78d0-44bb-8a7a-357f2af6e9bc.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Then we select <span class="strong"><strong>CPU views</strong></span> and elect to <span>record</span><a id="id325818960" class="indexterm"></a> CPU data, as follow. This starts to capture CPU recordings:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/e1fea816-7b12-4b52-b8b9-619538481db6.png" /></div><p>Now, let's execute a load test using Jmeter. We have created simple Jmeter scripts (JMX scripts) to invoke the REST APIs. At this point, we get the JWT token and access the get organization API. We then span five threads, which make concurrent requests to the identity service.</p><p>We run the tests for about 10 <span>minutes</span><a id="id325818981" class="indexterm"></a> and capture the CPU recordings. The function call breakdown is captured and shown as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/50a27012-9b4c-4473-9417-cc5a8335f2f8.png" /></div><p>This breakdown shows how much time is spent on each function call.</p><p>As we can see, we have profiled a service written in Kotlin. Profiling helps identify performance bottlenecks in code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec75"></a>Offline profiling</h3></div></div></div><p>With JProfiler we can do offline <span>profiling</span><a id="id325857660" class="indexterm"></a>. We can do this for an application, save the result, and analyze it later. The key enabler for this offline profiling is triggered.</p><p>Firstly, we need to create a session and then add <span>triggers</span><a id="id325857669" class="indexterm"></a> to it; this will enable us to save recorded data, which can be used for analysis.</p><p>To create a session, perform the <span>following</span><a id="id325858417" class="indexterm"></a> steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Go to <span class="strong"><strong>Start Center</strong></span> and select the <span class="strong"><strong>New Remote Integration</strong></span> wizard, shown as follows:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/a4a9f057-847e-4985-8594-5861e4c8441c.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Select the JVM vendor and version, and then choose the <span>profile</span><a id="id325858473" class="indexterm"></a> offline option followed by <strong class="userinput"><code>Finish</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/c92a3485-4f18-434e-8098-75a6e3f7d1e9.png" /></div><p>This has started the profiling session. We will now add a trigger to the session.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>We have to create a session by selecting the <span>running</span><a id="id326025065" class="indexterm"></a> JVM, shown as follows:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/af674ea9-4afa-4e38-8b9c-63acd9e432b3.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Now, click on <span class="strong"><strong>Trigger Settings</strong></span> and add one or more triggers. A trigger is a list of actions that are executed when the defined condition becomes true. There are <span>different</span><a id="id326025092" class="indexterm"></a> trigger types to choose from in JProfiler:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/c7f5d59a-1434-4360-9d53-041677bf8d5e.png" /></div><p>We have to select the appropriate <span class="strong"><strong>Trigger type</strong></span> and define the action to be performed. We have the <span class="strong"><strong>Method invocation</strong></span> trigger. Here, we can select a method of a class and define an action to be performed when the method is actually invoked. We have <span class="strong"><strong>Heap usage threshold</strong></span> and <span class="strong"><strong>CPU load threshold</strong></span>, where we can define an action to be taken when it crosses a certain threshold. There is one trigger for <span class="strong"><strong>Out of Memory exception</strong></span>, which gets triggered when an application runs out of memory.</p><p>There is also a <span class="strong"><strong>Timer</strong></span> trigger to perform some actions at regular intervals, as well as a JVM start and exit trigger, which is triggered during <span class="strong"><strong>JVM startup</strong></span> and shutdown.</p><p>Let's see this in action. Say we want to record CPU usage whenever a call is made to the <code class="literal">issueJwt()</code> function defined in the <code class="literal">AuthenticationController</code> class, which we <span>described</span><a id="id326347281" class="indexterm"></a> in <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Implementing Microservices with Kotlin</em></span>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In this case, we choose <span class="strong"><strong>Method invocation</strong></span> as the trigger type and select the appropriate  methods, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/a3dbf359-1470-4bd0-af88-7f993188e29e.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>We can configure different <span>methods</span><a id="id326347325" class="indexterm"></a> or functions for the same set of actions:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/1611ef12-ff6f-47bb-81f6-1e1b4a06ef17.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>We will now select the <strong class="userinput"><code>Start recording</code></strong> option, where we will record CPU data, and click on <strong class="userinput"><code>OK</code></strong>.</li><li>Now, we have defined a trigger on a <span>particular</span><a id="id326348180" class="indexterm"></a> method invocation in the session that we created, by attaching the running application.</li><li>Using JMeter, we can now make continuous calls to the <code class="literal">/authentication-service/authorize/jwt/token</code> API, which will invoke the <code class="literal">issueJwt()</code> function in <code class="literal">AuthenticationController</code>. This automatically triggers the actions that we defined. The following screenshot shows this:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/4067c48f-5932-4f3e-9ae5-d6c8de8310e1.png" /></div><p>Note that we don't have to elect to record the CPU data manually after defining the trigger. When we invoke the API, it automatically triggers the recording of the CPU data for the function call.</p><p>Triggers are powerful tools. All we have to do is define which actions we have to perform on specific conditions. When the conditions become true, the actions will be triggered automatically.</p><p> </p></div></div>