<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec82"></a>Implementing the factory pattern</h2></div></div><hr /></div><p>The factory pattern is <span>another</span><a id="id325816201" class="indexterm"></a> commonly-used creational design pattern. This pattern provides a way to create objects for clients without knowing the concrete object types. It simplifies the way we create objects when we are dealing with multiple implementations of a type and the implementation type has to be chosen based on the context provided.</p><p>Let's consider the following code snippet:</p><pre class="programlisting">val sensor:Sensor = TemperatureSensor()</pre><p> </p><p>Here, we are directly instantiating the concrete type in our code. Our client code is directly dependent on the Sensor implementation types. If we have another type, such as <code class="literal">HumiditySensor</code>, to be used, then we have to modify our code to accommodate this change:</p><pre class="programlisting">@JvmStatic
fun main(args: Array&lt;String&gt;) {
var sensor: Sensor
if (sensorType == "heat")
        sensor = TemparatureSensor()
if (sensorType == "humid")
        sensor = HumiditySensor()
if (sensorType == "optiical") {
        sensor = OpticalSensor()
}</pre><p>In this code, we declare a variable of the <code class="literal">Sensor</code> type (which is an interface) and write conditional logic to instantiate the different sensor objects at runtime based on the sensor types. If this sensor type grows, we end up including all of these concrete types in our code. Furthermore, if we want to add or remove new sensors, we have to change the code in two places.</p><p>In principle, client code doesn't have to be aware of these concrete implementation types. Instead, it just has to say what type it needs and it will receive an object of the <code class="literal">Sensor</code> interface type:</p><pre class="programlisting">  val: Sensor = getSensor("humid")</pre><p>To solve this design problem, we use the factory pattern. We will create a new class, called <code class="literal">SensorFactory</code>, that creates different sensors based on the type given:</p><pre class="programlisting">object SensorFactory {
    fun getSensor(sensorType:String) :Sensor?{
        if (sensorType == "heat")
            return TemparatureSensor()
        else if (sensorType == "humid")
            return HumiditySensor()
        else if (sensorType == "optical")
            return OpticalSensor()
        else
            return null
    }
}</pre><p>The <code class="literal">getSensor()</code> function is a factory function that creates sensors based on the type given.</p><p>The client code looks like the following:</p><pre class="programlisting">object SensorClient {
    var sensor: Sensor ?= null

    @JvmStatic
    fun main(args: Array&lt;String&gt;) {
        sensor = SensorFactory.getSensor("optical")
    }
}</pre><p>With this pattern, the client code doesn't need to worry about the concrete details of the Sensor. All it receives is an instance of the <code class="literal">Sensor</code> type. If any new sensor has to be added, that gets added to the factory class and we don't have to change the client code. When the client code wants to use a new type, it just passes the string input, and the factory function returns the <span>appropriate</span><a id="id325813056" class="indexterm"></a> type. With this pattern, the code becomes loosely coupled and more maintainable.</p><p>We can print the class name of the instance that's created by the factory class using Kotlin reflection, as follows:</p><pre class="programlisting">fun main(args: Array&lt;String&gt;) {
        sensor = SensorFactory.getSensor("optical")
        if(sensor == null){
            println("requested sensor type not available yet")
        }else {
            println(sensor::class.simpleName)
        }
    }</pre><p>Since we have hardcoded string literals for sensor types, we can use enum instead:</p><pre class="programlisting">enum class SensorType private constructor(private val type: String) {
    HUMIDITY("humid"), TEMPARATURE("heat"), OPTICAL("optic")
}</pre><p>In the Client class, we use enum as follows:</p><pre class="programlisting">sensor = SensorFactory.getSensor(SensorType.OPTICAL.name)</pre><p>Let's consider another use case in which we want to create a list of sensors given a type and quantity. Without the factory pattern, the client class will have to create <code class="literal">SensorType</code>, repeating this for the required number of quantities.</p><p> </p><p> </p><p>First this creates the required sensors, <span>then it can have logic to process further</span>. As stated earlier, the problem with this approach is that <code class="literal">Sensor</code> interface concrete classes are tightly <span>coupled</span><a id="id325442820" class="indexterm"></a> with the Client class, and the Client class violates the <span class="strong"><strong>single responsibility principle </strong></span>(<span class="strong"><strong>SRP</strong></span>).</p><p>Let's write code for this requirement with the factory pattern. We will add a new function to the <code class="literal">SensorFactory</code> class, which takes the <code class="literal">sensorType</code> and number of quantities as input parameters:</p><pre class="programlisting">fun getSensorList(sensorType:String, quantity:Int): MutableList&lt;Sensor&gt; { }</pre><p>The <code class="literal">SensorFactory</code> class looks like the following:</p><pre class="programlisting">object SensorFactory {
   private fun getSensor(sensorType:String) : Sensor?{
        if (sensorType == "heat")
            return TemparatureSensor()
        else if (sensorType == "humid")
            return HumiditySensor()
        else if (sensorType == "optical")
            return OpticalSensor()
        else
            return null
    }

    fun getSensorList(type:String, quantity:Int): MutableList&lt;Sensor&gt; {

        var sensorList: MutableList&lt;Sensor&gt; = mutableListOf()
        for (i in 0 until quantity) {
            sensorList.add(SensorFactory.getSensor(type))
        }
        return sensorList
    }
}</pre><p><code class="literal">SensorClient</code> will invoke the <code class="literal">getSensorList()</code> function by passing the sensor type and the quantity:</p><pre class="programlisting"> var list = SensorFactory.getSensorList(SensorType.HUMIDITY.name,100)</pre><p>In the factory pattern, we define an interface to create an object. However, the actual creation logic is not exposed to the clients. The concrete <span>implementation</span><a id="id325812912" class="indexterm"></a> of the interface type will be created and returned based on the context. This makes the class or interface flexible and easier to maintain.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note52"></a>Note</h3><p>Adding a new <code class="literal">SensorType</code> to the factory class still requires modification. We can avoid this by maintaining a map that consists of the class type of the sensors, and then adding a function that takes a new Sensor and puts that into the map. The <code class="literal">getSensor()</code> function reads the type from this map and returns the instance.</p></div></div>