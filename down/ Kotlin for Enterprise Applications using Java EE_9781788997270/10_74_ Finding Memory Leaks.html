<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec72"></a>Finding Memory Leaks</h2></div></div><hr /></div><p>Kotlin is a JVM-based language that has a <span>garbage</span><a id="id326025189" class="indexterm"></a> collector, which is a daemon thread that runs on the JVM and is responsible for automatic memory management. This reclaims the memory allocated to objects that are no longer referenced by the program running inside the VM. We will discuss more about garbage collector later in the chapter.</p><p>In execution, a program creates the objects required for the computation. Here, the memory is allocated for objects in the heap region. Once the program has finished using these objects, they are no longer needed by the program and it holds no reference to the objects that it has created. An object is garbage collected when it is no longer referenced by the program. A memory leak occurs when the program holds the reference to objects when they are not being used by it. Consequently, these objects are not eligible for garbage collection. This increases the program's memory usage, causing memory leaks in the system. If the program creates many such objects, the memory allocated for the system will become full, which may cause the system to crash. So, the program that we write is responsible for releasing object references when they are no longer needed.</p><p>There are monitoring tools available that help us to understand how memory is utilized in the system. If we see any abnormal behavior in memory usage, we can fix it and redeploy the services.</p><p>We will write a program to illustrate a memory leak and use <code class="literal">jvisualvm</code>, which comes with the JDK and is used for analyzing memory utilization. <code class="literal">jvisualvm</code> is available under the <code class="literal">{{path-to-jdk}}/bin</code> directory.</p><p>Let's write a simple program that <span>creates</span><a id="id325812907" class="indexterm"></a> a hashmap and goes on adding key-value pairs to it, and a statement to print in the console when an element is added to the map:</p><pre class="programlisting">@JvmStatic
fun main(args: Array&lt;String&gt;) {
try {
val map = HashMap&lt;MemoryLeakDemo, String&gt;()
while (true) {
            map[MemoryLeakDemo("myKey")] = "value"
println("Element added to map")
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
}</pre><p>The allocated memory for an entry in the map is no longer needed after it was added and printed in the console. While the program is running, we launch <code class="literal">jvisualvm</code> to monitor the memory. When <code class="literal">jvisualvm</code> starts up, we can see that the process that is running our code is already attached to <code class="literal">jvisualvm</code> and it shows the monitoring of that running program:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/01afef30-4ed1-4adc-9d5b-1d084933b8f7.png" /></div><p>We can see from the preceding screenshot that the heap memory usage has already exceeded 200 MB and is growing. Once it reaches the upper limit and there is no memory left for objects to allocate, the program crashes with an <code class="literal">OutOfMemoryError</code> message. After crossing a certain limit before the program crashes, increasing the heap may appear to solve the problem, but eventually even that gets allocated and the <span>program</span><a id="id325812946" class="indexterm"></a> again runs out of memory. This is a clear indication that the program suffers from a memory leak problem.</p><p>There is also a sampler option in <code class="literal">jvisualvm</code> to indicate for what specific type of object the memory is being allocated. There is also an option to view the CPU usage, which is shown as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/0e2d702c-d500-4d1d-be25-50ee23ced054.png" /></div><p>This shows that the majority of the memory is allocated to type <code class="literal">HashMap</code>, which is what our program is adding to. The program still holds the reference to the allocated objects, so it can never be reclaimed by the garbage collector. We see that the running <code class="literal">MemoryLeakDemo</code> thread, which is the class that we wrote, constantly adds to the memory. This an example of a memory leak. The<code class="literal">jvisualvm</code>tool helps to analyze the memory leak.</p><p>When we are developing a large system and check to see how memory is being utilized in order to identify any memory leaks, we can use <code class="literal">jvisualvm</code>. If we see a memory leak in the code, we now have a chance to fix it.</p></div>