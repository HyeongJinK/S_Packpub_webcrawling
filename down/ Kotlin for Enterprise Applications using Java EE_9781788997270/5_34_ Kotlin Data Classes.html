<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec37"></a>Kotlin Data Classes</h2></div></div><hr /></div><p>When we are dealing with data <span>layers</span><a id="id325812953" class="indexterm"></a> in an application, such as inserting data or retrieving it from a data source, we need to have classes to represent this data. When we have this representation, it is easy to perform operations on the data, such as validation or manipulation.</p><p>If we are dealing with a large data set, it is good to have less code to represent the data, without affecting the required functionality. Kotlin provides us with a construct to represent the data in a cleaner way. Typically, classes marked with the <code class="literal">data</code> keyword will be created to hold the data in the application. These classes are known as data classes.</p><p>For example, consider the following code:</p><pre class="programlisting">data class Person(val loginId: String) {

    lateinit var identifier: UUID
    lateinit var name: PersonName
    var preferredLanguage: PreferredLanguage? = null
}</pre><p>Unlike common classes, data classes are created with the intention of holding the state information and don't include any functions that operate on the data. The Kotlin compiler automatically generates some of the required functions, such as <code class="literal">equals()</code>, <code class="literal">hashcode()</code>, and <code class="literal">toString()</code>. This makes the classes that hold the data cleaner without much boilerplate code. </p><p>Java doesn't have pure data classes. Regular Java classes can be used as data classes, but these classes may include the methods that operate on the data. </p><p>Let's compare data classes in Kotlin and Java. First, let's write a <code class="literal">Person</code> class in Java, which is <code class="literal">Person.java</code>:</p><pre class="programlisting">public class Person {

    private UUID identifier;
    private PersonName name;
    private PreferredLanguage preferredLanguage;

    public UUID getIdentifier() {
        return identifier;
    }

    public void setIdentifier(UUID identifier) {
        this.identifier = identifier;
    }

    public PersonName getName() {
        return name;
    }

    public void setName(PersonName name) {
        this.name = name;
    }

    public PreferredLanguage getPreferredLanguage() {
        return preferredLanguage;
    }

    public void setPreferredLanguage(PreferredLanguage 
     preferredLanguage) {
        this.preferredLanguage = preferredLanguage;
    }

    @Override
    public String toString() {
        return "Per(" +
                "identifier=" + identifier +
                ", name=" + name +
                ", preferredLanguage=" + preferredLanguage +
                ')';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Per per = (Per) o;
        return Objects.equals(identifier, per.identifier) &amp;&amp;
                Objects.equals(name, per.name) &amp;&amp;
                preferredLanguage == per.preferredLanguage;
    }

    @Override
    public int hashCode() {
        return Objects.hash(identifier, name, preferredLanguage);
    }
}</pre><p>We have to declare the fields and provide getters, setters, and, optionally, override methods, such as <code class="literal">hashcode()</code>, <code class="literal">equals()</code>, and <code class="literal">toString()</code>.</p><p>In Kotlin, we can write the preceding code as follows:</p><pre class="programlisting">data class Person(val loginId: String) : Identity() {
    @Id
    lateinit var identifier: UUID
    lateinit var name: PersonName

    @Enumerated(EnumType.STRING)
    var preferredLanguage: PreferredLanguage? = null
}</pre><p>In comparison to Java, these data classes have less boilerplate code. We don't have to include getters and setters, equals, or hashcode implementations. This reduces the time required to write a large number of data classes and improves the readability of the classes.</p><p>The compiler provides a <code class="literal">copy</code> function, which is useful when we are writing immutable classes.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Note</h3><p>When we write data classes, in order for the compiler to derive the behavior of the code in a meaningful way, we have to have a primary constructor with at least a single parameter in it. This can be declared either as <code class="literal">var</code> or <code class="literal">val</code>. Data classes have to be concrete classes; they cannot be abstract. They should not be marked with <code class="literal">inner</code> or <code class="literal">open</code> keywords.</p></div><p>When the implementations are provided for the <code class="literal">equals()</code>, <code class="literal">hashcode()</code>, or <code class="literal">toString()</code> functions, the one provided will be used and the compiler won't generate the default implementations. We can also provide implementations for the <code class="literal">copy()</code> and <code class="literal">componentN()</code> functions. <code class="literal">componentN()</code> functions are used for decomposing a class.</p><p>The member fields declared inside the class will not be used by the compiler while generating implementations for the <code class="literal">equals()</code>, <code class="literal">hashcode()</code>, and <code class="literal">toString()</code> functions:</p><pre class="programlisting">class Person(val loginId: String) : Identity() {
    @Id
    lateinit var identifier: UUID
    lateinit var name: PersonName

    @Enumerated(EnumType.STRING)
    var preferredLanguage: PreferredLanguage? = null
}</pre><p>In our case, this means <span>that</span><a id="id325818960" class="indexterm"></a> the identifier, the name, and <code class="literal">preferredLanguage</code> will not be used by the compiler to generate these default implementations.</p><p>Sometimes, we need to copy an object to another object. The <code class="literal">copy()</code>  function creates new instances rather than just keeping the references. This helps to achieve immutability. For example, let's say that for our <code class="literal">Person</code> class, we have two instances declared and we want to copy the values from one to another:</p><pre class="programlisting">var person1 = Person("loginId1")
var person2: Person</pre><p>We can now copy the values from <code class="literal">person1</code> to <code class="literal">person2</code> as follows:</p><pre class="programlisting"> person2 = person1.copy(loginId = "2")</pre></div>