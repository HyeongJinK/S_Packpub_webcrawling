<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec40"></a>Transactions</h2></div></div><hr /></div><p>As we said earlier, data is an important part of enterprise applications. Creating and managing data is critical. It is also necessary to maintain the integrity <span>of</span><a id="id326440322" class="indexterm"></a> the data while performing operations.</p><p>Transactions are sets of operations that can be carried out on the entities. Transaction management essentially involves managing the life cycle of the entities to maintain the integrity of the data. When a transaction executes a set of operations, it will either succeed or be rolled back if there are any failures. There is no way in which half the operations will execute, leaving the data in an inconsistent state.</p><p>Let's take a look at how to handle transactions in Java EE applications. We will discuss how we can use the Java Transaction API with both EJBs and CDI-managed beans using the <code class="literal">@Transactional</code> and <code class="literal">@TransactionAttribute</code> annotations. We will also look at how the transaction lifecycle is managed and how to handle exceptions.</p><p>Consider the following EJB, which is used to create the identity of a person:</p><pre class="programlisting">@Stateless
class App {
    @Inject
    private lateinit var identityCreator: IdentityCreator

   @PersistenceContext(unitName="local")
    private lateinit var entityManager: EntityManager

    fun createIdentity(inputData: InputData): Person {
        val person = identityCreator.createPerson(inputData)
        entityManager.persist(person)
        return person
    }

    fun findAllPerson(): List&lt;Identity&gt; {
        return 
         entityManager.createNamedQuery(Queries.FIND_ALL_PERSON,
                               Person::class.java).resultList
    }
}</pre><p>By default, the EJB business function starts new transactions. This means that both the <code class="literal">createIdentity()</code> and <code class="literal">findAllPerson()</code> functions will be executed within a transaction. Once the function completes the execution and returns it, the transaction will be committed to the database.</p><p>We could also specify a different transaction handling function using the <code class="literal">@TransactionAttribute</code> from the EJB by specifying a type that is, by default, a<code class="literal">REQUIRED</code>type. This means that a new transaction is required:</p><pre class="programlisting">@Stateless
class App {
    @Inject
    private lateinit var identityCreator: IdentityCreator

   @PersistenceContext(unitName="local")
    private lateinit var entityManager: EntityManager

     @TransactionAttribute(TransactionAttributeType.REQUIRED)
    fun createIdentity(inputData: InputData): Person {</pre><pre class="programlisting">        val person = identityCreator.createPerson(inputData)
        entityManager.persist(person)
        return person
    }

    fun findAllPerson(): List&lt;Identity&gt; {
        return 
         entityManager.createNamedQuery(Queries.FIND_ALL_PERSON,
                               Person::class.java).resultList
    }
}</pre><p>We could also specify another attribute, <code class="literal">TransactionAttributeType.REQUIRES_NEW</code>, which requires a new transaction.</p><p>For example, let's say we have two EJBs and the second one requires a new transaction. When the second EJB's function executes, the first transaction will be suspended. Then, the second transaction will be executed. Once it is committed, the first transaction resumes and continues its execution.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip29"></a>Note</h3><p>We can also specify that a transaction is not supported using <code class="literal">TransactionAttributeType.NOT_SUPPORTED</code>.
Here's an example:<code class="literal">@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)</code><code class="literal">fun deleteIdentity(inputData: InputData): Person {</code><code class="literal">  //...</code><code class="literal">}</code></p></div><p>By default, CDI-managed beans' functions don't execute in a transaction. However, we can use the <code class="literal">@Transactional</code> annotation that comes from the Java Transaction API to specify that a transaction is required, or that a new transaction will be started. A transaction type (<code class="literal">TxType</code>) is used to specify the transaction. Consider the following code:</p><pre class="programlisting">@Dependent
class IdentityCreator {
    @Inject
    private lateinit var defaultPreferredLanguage: PreferredLanguage

    @Transactional(TxType.REQUIRED)
    fun createPerson(inputData: InputData): Person {
        val person = Person()
        person.preferredLanguage = if (inputData.preferredLanguage == 
         null)</pre><pre class="programlisting">            defaultPreferredLanguage
        else
            inputData.preferredLanguage
        return person
    }
}</pre><p>We can also specify <code class="literal">REQUIRES_NEW</code>; this requires a new <span>subsequent</span><a id="id326155783" class="indexterm"></a> transaction:</p><pre class="programlisting">    @Transactional(TxType.REQUIRES_NEW)
    fun createPerson(inputData: InputData): Person {
        val person = Person()
        person.preferredLanguage = if (inputData.preferredLanguage == 
         null)
            defaultPreferredLanguage
        else
            inputData.preferredLanguage
        return person
    }</pre><p>When the function execution is completed and returned, the transaction will be committed.</p></div>