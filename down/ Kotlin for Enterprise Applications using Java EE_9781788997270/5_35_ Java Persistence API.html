<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec38"></a>Java Persistence API</h2></div></div><hr /></div><p>Java EE has an API that can be used in <span>the</span><a id="id325812945" class="indexterm"></a> ORM component of an application. This is called JPA. This is one of the most important APIs in Java EE and the solution that Java EE uses to talk to relational databases and non-relational databases.</p><p>JPA offers an ORM solution based on the ORM paradigm. The framework handles the mapping of the state of the objects to the database without us having to specify many details about the mapping. All we really have to worry about is writing appropriate annotations on our POJO classes.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec39"></a>JPA architecture</h3></div></div></div><p>One of the key aspects of the JPA is the <span>entity</span><a id="id325812926" class="indexterm"></a> manager API, which is <span>responsible</span><a id="id325812919" class="indexterm"></a> for providing <span class="strong"><strong>Create</strong></span>, <span class="strong"><strong>Read</strong></span>, <span class="strong"><strong>Update</strong></span>, <span class="strong"><strong>and</strong></span><span class="strong"><strong>Delete</strong></span> (<span class="strong"><strong>CRUD</strong></span>) functionality. These are the operations that we can perform on an object that we want to persist on to the database.</p><p>Beyond this, one of the most important concepts in the persistence tier is queries. We need rich query capability at the database layer. JPA allows us to create queries in a number of <span>different</span><a id="id325601670" class="indexterm"></a> ways. One of these is <span class="strong"><strong>Java Persistence Query Language</strong></span> (<span class="strong"><strong>JPQL</strong></span>), which we can think of as an object-oriented <span>version</span><a id="id325601656" class="indexterm"></a> of <span class="strong"><strong>Structured Query Language</strong></span> (<span class="strong"><strong>SQL</strong></span>). It is just as powerful, compact, and expressive as SQL.</p><p>Another option is <span class="emphasis"><em>criteria queries</em></span>. These are a bit different to JPQL. For criteria queries, we don't <span>really</span><a id="id326584838" class="indexterm"></a> use a <span class="strong"><strong>query language</strong></span> (<span class="strong"><strong>QL</strong></span>) at all. What we do instead is construct queries by writing a very object-oriented, API-style code.</p><p>Another possibility is to use native queries. This is where we can use SQL queries if we aren't using ORM constructs. We use the SQL native queries through JPA and we essentially get 80% of the benefits of JPA, even though we are using native SQL. There is also support for stored procedures.</p><p>Because JPA is such a high-level API, we can actually use it as a caching layer once we have done ORM mapping. We can cache all of the entities and the JPA has built-in support for caching.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec31"></a>Bootstrapping the JPA</h4></div></div></div><p>In order to bootstrap the JPA process in a <span>server</span><a id="id326224012" class="indexterm"></a> environment, we don't have to do much. We just have to configure one XML file, which is the  <code class="literal">persistence.xml</code> file under <code class="literal">resources/META-INF</code>. We define one persistence unit for a database. We can thendefine the JPA entities. An example of <code class="literal">persistence.xml</code> is shown here:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.1"
xmlns="http://xmlns.jcp.org/xml/ns/persistence"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"&gt;
    &lt;persistence-unit name="prod"&gt;
        &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
 &lt;class&gt;org.rao.kotlin.entity.Person&lt;/class&gt;
        &lt;class&gt;org.rao.kotlin.entity.ContactDetails&lt;/class&gt;
        &lt;class&gt;org.rao.kotlin.entity.Address&lt;/class&gt;
        &lt;exclude-unlisted-classes/&gt;
        &lt;properties&gt;
            &lt;property name="javax.persisteData creatednce.jdbc.driver"
value="org.postgresql.Driver"/&gt;
            &lt;property name="javax.persistence.jdbc.url"
value="jdbc:postgresql://localhost:5432/postgres"/&gt;
            &lt;property name="javax.persistence.jdbc.password" value="********"/&gt;
            &lt;property name="javax.persistence.jdbc.user" value="postgres"/&gt;
&lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec32"></a>Mapping domain entities using JPA</h4></div></div></div><p>Previously, we created a <code class="literal">Person</code> POJO class <span>that</span><a id="id326440281" class="indexterm"></a> we used to illustrate some <span>examples</span><a id="id326440292" class="indexterm"></a> using the CDI. Let's now consider the same POJO again, with some additional fields.</p><p>Let's say we want to map this class to a table in a relational database:</p><pre class="programlisting">class Person : Identity() {
    var preferredLanguage: PreferredLanguage? = null
    lateinit var identifier: UUID
    lateinit var name: PersonName
    lateinit var loginId: String
    lateinit var address: Address
}</pre><p>In order to map this POJO class to a table in the database, we need to annotate the class with <code class="literal">@Entity</code>. This makes this class identifiable to business domain entities:</p><pre class="programlisting">@Entity
class Person : Identity() {
    var preferredLanguage: PreferredLanguage? = null
    lateinit var identifier: UUID
    lateinit var name: PersonName
    lateinit var loginId: String
    lateinit var address: Address
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"></a>Note</h3><p>The <code class="literal">@Entity</code> annotation can only be specified at the type level; not at the field or the function level.</p></div><p>Each table in a database will have one or more primary keys in it to uniquely identify a record in the table. We have to specify one or more properties that act as an identifier in the entity. For this, we need to annotate the property with the <code class="literal">@Id</code> annotation. This makes our business entity identifiable.</p><p>For example, the identifier field in our <code class="literal">Person</code> entity can be marked with <code class="literal">@Id</code>, as each ID will be different in the business context. This is shown in the following code:</p><pre class="programlisting">@Entity
class Person : Identity() {
    @Id
    lateinit var identifier: UUID
    lateinit var name: PersonName
    lateinit var loginId: String
    lateinit var address: Address
    var preferredLanguage: PreferredLanguage? = null
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"></a>Note</h3><p>In Java, we can annotate setters and getters in the entity class. </p></div><p>All of the properties are automatically mapped to table columns in the database. We can also annotate other properties of the entity class as follows:</p><pre class="programlisting">     @Id
     public void setIdentifier(UUID uuid){
        this.identifier = uuid;
     }     </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>In Kotlin, we don't have setters as the member fields are accessible directly.</p></div><p>We can also specify the table name to which our entity mapped using the <code class="literal">@Table</code> annotation. For example, let's say a <code class="literal">person</code> is a table in the database. To map the <code class="literal">Person</code> entity to this table, we can use <code class="literal">@Table</code> by specifying the <code class="literal">name</code> attribute with the table name in it, which is shown in the following code:</p><pre class="programlisting">@Table(name = "person")
@Entity
class Person : Identity() {
    @Id
    lateinit var identifier: UUID
    lateinit var name: PersonName
    lateinit var loginId: String
    lateinit var address: Address
    var preferredLanguage: PreferredLanguage? = null
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Note</h3><p>
If the <code class="literal">@Table</code> annotation is not mentioned in our entity class, or if it is mentioned without the name attribute supplied, the table name defaults to the name of the entity.</p></div><p>To interact with the database using the entity <span>from</span><a id="id326441085" class="indexterm"></a> our <span class="strong"><strong>data access object</strong></span> (<span class="strong"><strong>DAO</strong></span>) layer or façade, we use the functionality that comes with the JPA, called <code class="literal">EntityManager</code>.</p><p>In previous examples, we used <code class="literal">IdentityRepository</code> to store the person object. Since we now have the <code class="literal">EntityManager</code> JPA, we don't need this repository bean:</p><pre class="programlisting">@Stateless
class App {
    @Inject
    private lateinit var identityCreator: IdentityCreator
    @PersistenceContext
    private lateinit var entityManager: EntityManager

    fun createIdentity(identity: Identity): Identity {
        val person = identityCreator.createPerson(identity)
        entityManager.persist(person)
        return person
    }
}</pre><p>We acquire the <code class="literal">EntityManager</code> with the <code class="literal">@PersistenceContext</code> annotation that will be used to interact with the persistence unit of our application. We use <span>the</span><a id="id326441127" class="indexterm"></a><code class="literal">persist</code> method of the <code class="literal">EntityManager</code> to store <span>our</span><a id="id326441142" class="indexterm"></a> entity in the database.</p><p>Our <code class="literal">createIdentity()</code> function will be executed within the transaction, which means the person data is committed to the database only after the <code class="literal">createIdentity()</code>function finishes its execution.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec40"></a>Queries</h3></div></div></div><p>In the previous section, we <span>discussed</span><a id="id326559785" class="indexterm"></a> how to persist the data to the database using the entity and the entity manager of the JPA. We can also retrieve the data from the database. JPA provides APIs to query the data from the database.</p><p>Let's say we want to retrieve the person data that we created and persisted. We could either use <code class="literal">CreateNativeQueries</code>, where we can just specify the query using SQL, or we can define a <code class="literal">NamedQuery</code>. This is a database query with a specific query syntax and is defined in the entity.</p><p>The named queries can be defined as constants and used in the entity class. For example, consider the following code:</p><pre class="programlisting">const val FIND_ALL_PERSON: String = "Person.findAll"

@Table
@Entity
@NamedQuery(name = FIND_ALL_PERSON, query = "select p from Person p")
class Person : Identity() {
    @Id
    lateinit var identifier: UUID
    lateinit var name: PersonName
    lateinit var loginId: String
    lateinit var address: Address
    var preferredLanguage: PreferredLanguage? = null
}</pre><p>We have defined <code class="literal">NamedQuery</code> in the <code class="literal">Person</code> entity. It takes a name, a unique constant defined in the class, and a query, which is JPQL. <code class="literal">Person</code> mentioned in the query is an entity type, not the table name.</p><p>We write all the constants in the <code class="literal">Queries</code> class and access that constant in the <code class="literal">Person</code> entity:</p><pre class="programlisting">object Queries{
const val FIND_ALL_PERSON:String =  "Person.findAll"
}</pre><p>We can then use <code class="literal">NamedQuery</code> in our <code class="literal">findAllPerson()</code> function:</p><pre class="programlisting">@Stateless
class App {
    @Inject
    private lateinit var identityCreator: IdentityCreator
    @PersistenceContext
    private lateinit var entityManager: EntityManager

    fun createPerson(inputData: InputData): Person {
        val person = identityCreator.createPerson(inputData)
        entityManager.persist(person)
        return person
    }

    fun findAllPerson(): List&lt;Identity&gt; {
        return entityManager.createNamedQuery(Queries.FIND_ALL_PERSON,
                               Person::class.java).resultList
    }
}</pre><p>In the preceding class, we inject the required dependencies. We have two functions—<code class="literal">createPerson()</code> and <code class="literal">findAllPerson()</code>. We create a request instance of the <code class="literal">InputData</code> type and we insert the data using the entity manager. In the <code class="literal">findAllperson()</code> function, we use <code class="literal">NamedQueries</code> to retrieve the result and we get the <code class="literal">resultList</code> back using <code class="literal">entityManager</code>. This is a list of <code class="literal">person</code> entities <span>that</span><a id="id326584873" class="indexterm"></a> are persisted. This is how we retrieve the list and create the <code class="literal">person</code> record in the database.</p></div></div>