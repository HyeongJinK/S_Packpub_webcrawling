<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec31"></a>Kotlin and CDI</h2></div></div><hr /></div><p>The IoC and dependency injection <span>patterns</span><a id="id325601682" class="indexterm"></a> are very important design <span>principles</span><a id="id325601670" class="indexterm"></a> that decouple the code from dependent objects. If we have two objects that are related to each other, one might be dependent on the other. The idea of the IoC and dependency injection patterns is to decouple this dependency so that the two objects are not tied to one another.</p><p>The Java frameworks that implement the IoC principle are Seam and Spring. Seam is a set of utilities used for web development that was integrated in the Java EE specification in order to provide dependency injection. Spring has implemented IoC and is represented by the Spring IoC container (<code class="literal">ApplicationContext</code>). The Spring container is responsible for instantiating, configuring, and assembling the required objects, which are known as beans. The Spring container manages the life cycle of the beans.</p><p>CDI is the central specification and the dependency injection framework that is built into Java EE. CDI frameworks allow us to inject the required dependencies without instantiating them manually in the code, thus simplifying the dependency injection in Java EE applications. It's a modern, extremely type-safe, and easy-to-use standard API for dependency injection. With CDI, the life cycle of the beans is managed by the Java EE container, as demonstrated in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/fb56ca3b-8bd2-4f84-920b-84083b3fb987.png" /></div><p> </p><p> </p><p> </p><p> </p><p>CDI was added to the Java EE specification in Java EE 6. Java EE 8 includes a new version of CDI, which has new features such as asynchronous events and event ordering. CDI <span>unifies</span><a id="id325442811" class="indexterm"></a> the <span class="strong"><strong>Enterprise Java beans</strong></span> (<span class="strong"><strong>EJB</strong></span>) and JSF programming models. It provides several advantages, such as allowing any JavaBean with a name and referring to it as a JSF-managed bean. This includes stateless and stateful session beans. It gives us the flexibility to inject various types of components in a loosely coupled manner with type safety.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"></a>Note</h3><p>Session beans can be injected in CDI, but not entity beans or message-driven beans, as they are non-contextual.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec34"></a>The Difference between EJB and CDI-managed beans</h3></div></div></div><p>Classes are <span>annotated</span><a id="id325816096" class="indexterm"></a> with <code class="literal">@Stateless</code>, <code class="literal">@Stateful</code>, or <code class="literal">@Singleton</code> to make them EJBs. These beans are managed by the container or application server and already implements a <span>number</span><a id="id325816180" class="indexterm"></a> of cross-cutting concerns, such as transactions, monitoring, pooling, and more. Stateless beans doesn't maintain the state interaction between the client and the server. The instances of the beans that are annotated with <code class="literal">@Stateless</code> are actually pooled. There will be several instances of these beans. The server manages them and we can configure this if we want to. If we access an instance of these beans, we get an instance that might have been created previously from the pool. After using it, it is returned to the pool. Stateful beans maintain the interaction between the client and the server.The instances of the beans that are annotated with  <code class="literal">@Stateful</code> are not pooled. These beans are created for a particular user's session and remain associated with that session till the session is active. For Singleton beans, only one instance is maintained in the application.</p><p>CDI-managed beans are typically POJOs that are injected. These beans don't come with any cross-cutting concerns, such as transaction, monitoring, and pooling. If we need these, we can add annotations to the CDI-managed beans, such as <code class="literal">@Transactional</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec23"></a>Injecting the beans</h4></div></div></div><p><code class="literal">@Inject</code> is used to inject the <span>required</span><a id="id325816210" class="indexterm"></a> dependencies. For example, let's say there are two classes—<code class="literal">IdGenerator</code> and <code class="literal">Identity</code>. <code class="literal">IdGenerator</code> has to be injected into the <code class="literal">Identity</code> class. We can use <code class="literal">@Inject</code> for this without having to instantiate the <code class="literal">IdGenerator</code> inside the <code class="literal">Identity</code> class.</p><p> </p><p> </p><p>This is shown in the following code:</p><pre class="programlisting">class Identity {
    @Inject
    private lateinit var idGenerator: IdGenerator
}</pre></div></div></div>