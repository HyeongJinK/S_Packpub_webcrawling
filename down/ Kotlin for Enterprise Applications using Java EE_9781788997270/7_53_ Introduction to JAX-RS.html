<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec54"></a>Introduction to JAX-RS</h2></div></div><hr /></div><p><span class="strong"><strong>JAX-RS</strong></span> stands for <span class="strong"><strong>Java API extension for RESTful Web services</strong></span>. JAX-RS is a specification that defines a set of APIs for <span>developing</span><a id="id326014811" class="indexterm"></a> web services in REST architecture style. This has become very popular in the past few years and is commonly used to build microservices. As previously discussed, RESTful services are interoperable services that interact with each other over the network, and JAX-RS helps us to build these services.</p><p>JAX-RS is Java's implementation for the REST style of architecture. This is a collection of Java annotations and interfaces that aid in developing RESTful web services. Here, there are both client- and server-side APIs, which are designed to do REST-based development in Java EE. JAX-RS specification was standardized in Java EE 6, the JAX-RS version was updated to JAX-RS 2.0 in Java EE 7, and this was improved in Java EE 8.</p><p>JAX-RS provides support for developing and consuming RESTful web services. JAX-RS is a set of <span class="strong"><strong>Plain Old Java Object</strong></span> (<span class="strong"><strong>POJO</strong></span>) based resource classes with some standard annotations on it, and this is designed to use a stateless communication model, such as HTTP. It specifies how to create an endpoint using POJOs as resources using the HTTP protocol, and uses either XML or JSON to represent the data.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec53"></a>JAX-RS annotations</h3></div></div></div><p>JAX-RS is an annotation-driven <span>model</span><a id="id326014446" class="indexterm"></a> for creating the web services. The annotations are applied on the classes to expose them as resources or RESTful APIs. Here, there are different annotations, such as <code class="literal">@PATH</code> , <code class="literal">@GET</code> ,<code class="literal">@POST</code> , <code class="literal">@PUT</code>, and <code class="literal">@DELETE</code>. These annotations correspond to HTTP verbs and CRUD operations in general. The classes will be annotated with <code class="literal">@PATH</code> annotation to represent the root of the resource, and each function will be annotated in correspondence with the HTTP verbs in order to respond to the HTTP requests. There are also the <code class="literal">@QueryParam</code> and <code class="literal">@PathParam</code> annotations, which are intended for data retrieval, and the <code class="literal">@Produces</code> and <code class="literal">@Consumes</code>  annotations for binding and unbinding data to the classes.</p><p>Furthermore, there are annotations that we can use for validation, such as <code class="literal">@Email</code> and <code class="literal">@NotNull</code>.</p><p> </p><p>Let's take a look at these annotations in detail:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">@Path</code>: When a class is annotated with <code class="literal">@Path</code> , that class becomes a resource. This means it can be accessible using a URI from outside. Let's say we have a class called <code class="literal">Controller</code>. We use the <code class="literal">@Path</code> annotation on this <code class="literal">Controller</code> class to mark it as a resource as follows:</li></ul></div><pre class="programlisting">@Path("/home")
public class Controller{
}</pre><p>This resource can now be accessed using a URI such as <code class="literal">https://{{hostname}}/home</code>.</p><p>Now that we have defined a resource, we need to add a function that responds to the request. These functions can be annotated with <code class="literal">@GET</code>, <code class="literal">@POST</code>, <code class="literal">@PUT</code>, or <code class="literal">@DELETE</code>, and so on, based on the action that the resource needs to perform. These annotations correspond to the HTTP verbs that we discussed and have the same meaning.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">@GET</code>: The<span class="strong"><strong> </strong></span><code class="literal">@GET</code> annotation is used for reading a resource. When <code class="literal">@GET</code> is applied to a function, a resource can be read on it. Consider the following example:</li></ul></div><pre class="programlisting">@Path("/home")
public class Controller{
  @GET
  public String login(){
    return "login.html"
  }
}</pre><p>Similarly, we can define functions with <code class="literal">@POST</code>, <code class="literal">@DELETE</code>, and <code class="literal">@PUT</code> as follows:</p><pre class="programlisting"> @POST
 public String create(){
 //..
 }
 @PUT
 public String update(){
 //..
 }
 @DELETE
 public void delete(){
 //..
 }</pre><p>Once we define the resources and functions, we also need to specify the MIME type through which data is exchanged in the specified format. Different MIME types that we can use include <code class="literal">application/xml</code>, <code class="literal">application/json</code>, <code class="literal">image/png</code>, and <code class="literal">text/plain</code>.</p><p>To specify the MIME type, we use the <code class="literal">@Produces</code> and <code class="literal">@Consumes</code> annotations.</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">@Produces</code>: This is used to specify what type of data is returned to the client who is invoking the function via an HTTP request, as shown by the following code:</li></ul></div><pre class="programlisting">@Produces("application/json")
@POST
public String create(){
  //..
}</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">@Consumes</code>: This is used to specify what type of data is acceptable for the function that processes the HTTP request, as shown by the following code:</li></ul></div><pre class="programlisting">@Consumes("application/json")
@PUT
public String create(){
  //..
}</pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">@PathParam</code>: This is used to map the query parameter to the parameter in a function for processing the request further. Now, <code class="literal">@PathParam</code> is usually used to retrieve the data by providing the input. This input is what gets mapped to the <span>parameter</span><a id="id326014822" class="indexterm"></a> of the function, which will then be used to pull the required data from the data source that the web service is tied to, as follows:</li></ul></div><pre class="programlisting">@Produces("application/json")
@GET
public getPerson(@PathParam("loginId") String loginId) {
}  </pre><p>Now let's take a look at how JAX-RS is actually implemented in an application.</p></div></div>