<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec84"></a>Implementing the decorator pattern</h2></div></div><hr /></div><p>The decorator design <span>pattern</span><a id="id325812954" class="indexterm"></a> is a structural, hierarchical pattern that is used to dynamically extend or alter the functionality of objects at runtime. This pattern builds the functionality at each level without altering the existing structure using the composition from similar data types. It does this by wrapping them in an object of a decorator class, providing the additional functionality and leaving the original object intact without any modification.</p><p>Using this pattern, we can add functionality by wrapping an object inside another without affecting the other parts of the hierarchy in the system. This is also known as a wrapper as it wraps the objects. This differs from adding functionalities to objects at design-time, which generally involves inheritance. To add any functionality, we have to create a new class and create a subclass that extends a base class. With inheritance, we can add functionalities to classes by extending a base class. A problem with this approach is that a new class is created for every possible combination of these types, resulting in a class explosion. This means that there will be many classes available just to have these functionalities. This can be achieved without actually creating a higher number of classes with the decorator pattern.</p><p>The decorator pattern attaches the additional responsibilities to an object dynamically without making any modifications to existing classes. This provides a flexible alternative to subclassing for adding the additional functionality.</p><p>The decorator pattern makes the design flexible. Applications have to be designed to be flexible enough to accommodate any functionalities for changing requirements. We also want to keep in mind that the base class should not be modified. This pattern is aligned with the open-<span>closed</span> design principle, which states that the classes should be open for extension, but closed to any modifications.</p><p>The decorator design pattern can be used when we don't want too many subclasses that would extend from a base class for every combination. This is more suitable when we want to add new functionality to a legacy system in cases in which we don't want to modify existing classes but still need a new responsibility to be handled. It makes more sense to use the decorator pattern to add the additional responsibilities than providing subclasses to add the functionality.</p><p>The key idea behind the decorator pattern is to wrap the object being decorated. Consequently, it is also known as a <span class="strong"><strong>wrapper pattern</strong></span>.</p><p>Let's illustrate the decorator pattern via an example. Consider the example of purchasing windows. In this case, the windows can be different sizes, colors, and materials. If we follow inheritance, just imagine the number of classes that we have to create for all these sets of different combinations. Instead of using inheritance, we can use decorators for these combinations when choosing a window. For example, we may want to create a small, silver window made of glass. This is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/ae17c334-47de-4159-96e0-5a62e494544e.png" /></div><p>We wrap the <span class="strong"><strong>SmallWindow</strong></span> object in a <span class="strong"><strong>GlassDecorator</strong></span> object, which again gets wrapped in a <span class="strong"><strong>BrightSilver</strong></span> color decorator object. Any combination of this sort can be created. We started with a window object and added the material type and color. We then wrapped one <span>object</span><a id="id325601678" class="indexterm"></a> in another. The price of the window will be calculated on the outermost decorator object, which is the sum of the window, material type, and the color. Note that these decorations can be wrapped dynamically at runtime:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/7e448c62-d4df-4330-adc6-311e89e7daca.png" /></div><p>With these types, we can create any combination of windows, using the window shape, material type, and color. Let's see this in action. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec84"></a>Writing the code for the decorator pattern</h3></div></div></div><p>To begin, we create four packages, each of <span>which</span><a id="id325442827" class="indexterm"></a> represents the components of the decorator pattern. These packages are named <code class="literal">component</code>, <code class="literal">concretecomponent</code>, <code class="literal">decorator</code>, and <code class="literal">concretedecorator</code>. This is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/e0c88136-7ba6-4cc4-ba45-c359d5fe56a9.png" /></div><p> </p><p> </p><p>In our case, <span class="strong"><strong>Window</strong></span> is our component. This is an interface that declares the <code class="literal">getDescription()</code> and <code class="literal">getPrice()</code> functions:</p><pre class="programlisting">interface Window {
    fun getDescription(): String
    fun getPrice(): Double
}</pre><p>We have three implementations of the <span>component—</span><code class="literal">LargeWindow</code>, <code class="literal">MediumWindow</code>, and <code class="literal">SmallWindow</code>. These implementations are similar and look like the following:</p><pre class="programlisting">class LargeWindow : Window {
    internal var description: String
    internal var price: Double

    init {
        description = "Large Window"
        price = 50.00
    }

    override fun getDescription(): String {
       return description
    }
    override fun getPrice(): Double {
        return price
    }
}</pre><p>In these concrete implementations, we set the description and the price using the <code class="literal">init</code> block, which will be invoked during object initialization. The other two implementations vary in setting the description value to medium, small, and other appropriate prices.</p><p>Let's write a simple <span>program</span><a id="id326000476" class="indexterm"></a> that creates <code class="literal">LargeWindow</code> and print its description as well as the price:</p><pre class="programlisting">fun main(args: Array&lt;String&gt;) {
    var window: Window = LargeWindow()

    println("Window description: ${window.getDescription()}")
    println("Window price: $${window.getPrice()}")

}</pre><p>Now let's run this code. We should expect this to print the <code class="literal">Large Window</code> description as well as its cost of $50, which is what we have set for the <code class="literal">LargeWindow</code> class:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/a71f17ba-c333-41b8-ac52-fb1715e1a818.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec85"></a>Adding decorators</h3></div></div></div><p>Now we need to add the decorators to the window. To do this, we will create a <code class="literal">WindowDecorator</code> class, which is our decorator. This class <span>implements</span><a id="id326000523" class="indexterm"></a> the following <code class="literal">Window</code> component:</p><pre class="programlisting">class WindowDecorator(private val window: Window) : Window {

    override fun getDescription(): String {
        return window.getDescription()
    }

    override fun getPrice(): Double {
        return window.getPrice()
    }
}</pre><p>This class takes an instance of a <code class="literal">Window</code> type in its constructor, and this is the instance that is decorated. We also override the<code class="literal">getDescription()</code>and<code class="literal">getPrice()</code>functions.</p><p>Now let's write a concrete decorator. This is called <span class="strong"><strong>Arched</strong></span>, which refers to the shape of the window:</p><pre class="programlisting">class Arched(private val window: Window) : WindowDecorator(window) {
    internal var description: String
    internal var price: Double
    init {

        description = "Arched shape"
        price = 15.00
    }

    override fun getDescription(): String {
        var desc = super.getDescription()
        return "$desc, $description"
    }

    override fun getPrice(): Double {
        return super.getPrice() + price
    }
}</pre><p>This class extends from <code class="literal">WindowDecorator</code>, taking an object of the <code class="literal">Window</code> type that will be decorated. It then calls the parent class constructor. Note the syntax in Kotlin for this step. This is just one line that is used to declare a constructor, invoking the constructor of the parent class:</p><pre class="programlisting">class Arched(private val window: Window) : WindowDecorator(window)</pre><p>We also override the <code class="literal">getDescription()</code> and <code class="literal">getPrice()</code> functions in the Arched concrete decorator. As this is the wrapping of the window in an Arched type, we need to concatenate the description and find the total price for both the <code class="literal">Window</code> and the decorator classes. We do this by overriding the <code class="literal">getDescription()</code> and <code class="literal">getPrice()</code> functions in the decorator class.</p><p>Now we need to modify the <code class="literal">main()</code> function that we wrote for verifying the decorator pattern:</p><pre class="programlisting">fun main(args: Array&lt;String&gt;) {

        var window: Window = LargeWindow()
        window = Arched(window)
        window = Glass(window)
        window = BrightSilver(window)

        println("Window description: ${window.getDescription()}")
        println("Window price: $${window.getPrice()}")

    }</pre><p>In the main function, we create a <code class="literal">Window</code> instance, which happens to be <code class="literal">LargeWindow</code>, and then wrap it around the <code class="literal">Arched</code>, <code class="literal">Glass</code>, and <code class="literal">BrightSilver</code> decorator types.</p><p>When we run this code, we should expect the <code class="literal">Window</code> created to be <code class="literal">Arched</code> in shape, <code class="literal">BrightSilver</code> in color, and made of <code class="literal">Glass</code>. The price should also be the sum of the <code class="literal">Window($50)</code>, <code class="literal">Arched($15)</code>, <code class="literal">Glass($10)</code>, and <code class="literal">BrightSilver($20)</code>, which comes to <code class="literal">$95</code>. Consider the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/eb5eb094-a400-4507-8196-5503b87ab530.png" /></div><p>We started with the <code class="literal">LargeWindow</code> type, wrapping this around the <code class="literal">Arched</code>, <code class="literal">Glass</code>, and <code class="literal">BrightSilver</code> decorator types. In the end, the instance window will be a <code class="literal">BrightSilver</code> type and when we invoke the<code class="literal">getDescription()</code>and<code class="literal">getPrice()</code>functions, this invokes the overridden version of these functions from the <code class="literal">BrightSilver</code> class.</p><p>Whenever we want to create a <span>window</span><a id="id326158418" class="indexterm"></a> of different combinations or add a new decor type, we just have to create a new decorator and wrap the component that needs to be decorated. Consequently, following the decorator pattern, we won't run into a class-explosion problem for all the possible combinations of the decor that we need to apply to an object type. This makes adding the new functionality/decor easier and the application thereforebecomes more maintainable.</p></div></div>