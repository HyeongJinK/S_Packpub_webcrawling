<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec81"></a>Implementing the singleton pattern</h2></div></div><hr /></div><p>The singleton pattern is <span>one</span><a id="id326285731" class="indexterm"></a> of the best-known design patterns. This pattern ensures that only one instance of a class exists throughout the application running inside the virtual machine.</p><p>A singleton is a class whose instance can be created only once. This exists until the application is up and running. A singleton class provides a single access point that has to be used to get the instance of the class. It restricts the number of instances of a class to one and controls the creation of instances of the class.</p><p> A singleton class in an application is used when managing things such as memory, connection pools, threads, logging, and the registry. This ensures the consistency, reliability, and correctness of the data that classes handle in the application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec80"></a>Writing a singleton class in Java</h3></div></div></div><p>Let's understand how to write a <span>singleton</span><a id="id326285747" class="indexterm"></a> class in Java. We then compare it with the singleton class in Kotlin.</p><p>Let's consider the following class:</p><pre class="programlisting">public class Singleton {
  public String getDetails() {
    System.out.println ("running the method");
    return "this is a singleton class";
  }
}</pre><p>If we want to instantiate this class, we do it as follows:</p><pre class="programlisting">new Singleton ();</pre><p>Calling a constructor like this gives an instance of this class. If we repeatedly call this constructor, we get multiple instances of the same class and it is therefore not a singleton pattern.</p><p>Now we want only one instance of this class to be created and reused. To create a singleton class, we need to do the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Make the constructor private and initialize it within the class.</li><li style="list-style-type: disc">Provide a way to access the instance that is initialized.</li></ul></div><p> </p><p> </p><p>Marking the constructor of the class private will ensure that the constructor is invoked only from that class, thus controlling the instantiation the class. This constructor can't be invoked outside of the class; only the code within the singleton class can invoke the constructor, as follows:</p><pre class="programlisting">private Singleton() {}</pre><p>If there is no zero-argument constructor and if the constructor takes some argument for initializing the member instance, we can mark that constructor as private:</p><pre class="programlisting">private Singleton(String name) {
  this.name = name;
}</pre><p>Now we need to use this private constructor to initialize the instance and provide a way to access it. This way, the instance is initialized within the class only and made available for usage in the application globally. Let's write a function that calls the private constructor of the singleton class:</p><pre class="programlisting">private static Singleton singletonInstance;
  public static Singleton getInstance() {
    if(singletonInstance == null){
      singletonInstance = new Singleton ();
    }
    return singletonInstance;
  }</pre><p>In the preceding code, we declared a static variable called <code class="literal">singletonInstance</code>, which holds the reference to the instance of the singleton class. Note that this is also private, meaning that this variable is again not accessible outside of the class; it is accessible only via the <code class="literal">getInstance()</code> function.</p><p>In the preceding code, we also <span>defined</span><a id="id326510314" class="indexterm"></a> a function named <code class="literal">getInstance()</code>, which is a static function and can be accessed directly using the class name.</p><p>In the <code class="literal">getInstance()</code> function, we check whether the <code class="literal">singletonInstance</code> member variable is initialized. If it is not, we initialize it with the private constructor of the class and return the instance.</p><p>When we make a call to the <code class="literal">getInstance()</code> function for the first time, <code class="literal">singletonInstance</code> will be null and it will be initialized using the constructor. When the call is made for the second time, the instance is not null and already holds a reference to the singleton class. This simply returns the same instance and we then have the same instance being returned from the <code class="literal">getInstance()</code> function.</p><p>Consequently, the code with the private constructor and the <code class="literal">getInstance()</code> function looks like the following:</p><pre class="programlisting">public class Singleton {
  private static Singleton singletonInstance;
  private Singleton() {}

  public static Singleton getInstance() {
    if(singletonInstance == null){
      singletonInstance = new Singleton ();
    }
    return singletonInstance;
  }

  public String getDetails() {
    System.out.println ("running the method");
    return "this is a singleton class";
  }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note51"></a>Note</h3><p>In this Singleton class, we are instantiating the singleton instance only when required. <code class="literal">singletonInstance</code> is initialized only when the <code class="literal">getInstance()</code> function is invoked. Until then, the instance will not be initialized. This type of initialization is known as lazy initialization, as the object instantiation will be done only when required.
Lazy instantiation is good when the class is resource-intensive and has complex logic. This lazy instantiation will save the class loading time when JVM tries to load all the required classes in the application.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec81"></a>Writing the test case for a singleton</h3></div></div></div><p>Now let's write a <span>test</span><a id="id325819054" class="indexterm"></a> class to verify the singleton class.</p><p>Consider the following test case:</p><pre class="programlisting">  @Test
  public void testSingletonObject() {
    Singleton singleton = Singleton.getInstance ();
    Singleton anotherSingleton = Singleton.getInstance ();

    System.out.println (singleton);
    System.out.println (anotherSingleton);
    System.out.println (singleton == anotherSingleton);

    Assert.assertEquals (singleton,anotherSingleton);
  }</pre><p>In this case, we are trying to instantiate the singleton class twice. We print the two instance objects that are initialized. Since the same object is returned every time the <code class="literal">getInstance()</code> function is invoked, it prints the same memory address at which these instances are loaded. The comparison of the instances is evaluated to true as it is the same instance:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/1b3fee32-100a-4194-ba14-9778e4b06ef9.png" /></div><p>Let's add another test case <span>where</span><a id="id325951813" class="indexterm"></a> we invoke a function on the singleton instance:</p><pre class="programlisting">  @Test
  public void testSingleton() {
    Singleton singleton = Singleton.getInstance ();
    Assert.assertNotNull (singleton);

    String details = singleton.getDetails ();
    Assert.assertNotNull (details);
    Assert.assertEquals ("this is a singleton class", details);
  }</pre><p>In this test case, we initialize the instance by invoking the <code class="literal">getInstance()</code> function. On this instance, we call the <code class="literal">getDetails()</code> function that is defined in the singleton class. Furthermore, we assert for the non-null value for the instance, followed by the response that is returned from the <code class="literal">getDetails()</code> function, and then assert the actual message that is being returned by the function.
Note that the singleton code that we wrote is not thread-safe. If multiple threads access the <code class="literal">getInstance()</code> method at the same time, we end up with two instance of the class. To solve this, we use synchronized keywords or static initialization. The synchronized way is lazy initialization and the static initialization is known as eager initialization of the instance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec82"></a>Lazy initialization</h3></div></div></div><p>The code <span>for</span><a id="id325951849" class="indexterm"></a> lazy initialization is <span>as</span><a id="id325951858" class="indexterm"></a> follows:</p><pre class="programlisting">public class Singleton {
  private static Singleton singletonInstance;

  private Singleton () {}

  public static synchronized Singleton getInstance() {
    if(singletonInstance == null){
      singletonInstance = new Singleton ();
    }
    return singletonInstance;
  }
}</pre><p>The code for eager initialization is as follows:</p><pre class="programlisting">public class Singleton {
  private static Singleton singletonInstance = new Singleton ();

  private Singleton () {}

  public static Singleton getInstance() {
    return singletonInstance;
  }
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec83"></a>Singleton implementation in comparison to Kotlin</h3></div></div></div><p>So far, we have explored how to <span>implement</span><a id="id326166579" class="indexterm"></a> a singleton pattern by making a constructor of the class private and providing a global way of accessing the instance that is initialized within the class in Java.</p><p>In Kotlin, it is much simpler to write a singleton class:</p><pre class="programlisting">object Singleton {
}</pre><p>The <code class="literal">object</code> keyword is used for a singleton class. Note that we used <code class="literal">object</code> to define constants and static functions in our examples in the previous chapters. We indeed created a singleton class in these examples. Unlike the class, the object does not have any constructors.</p><p>In addition, we don't need to create the instance to access any of its functions. Let's add the following function to the singleton class:</p><pre class="programlisting">object Singleton {
    fun getDetails(): String {
        return "this is a singleton class"
    }
}</pre><p>Our test case for the preceding code can be written as follows:</p><pre class="programlisting">class SingletonTest {
    @Test
    fun testSingletonObject() {
        var details: String = Singleton.getDetails()
        Assert.assertEquals ("this is a singleton class", details);
    }
}</pre><p>We can provide the <code class="literal">init</code> block for any initialization required:</p><pre class="programlisting">object Singleton {
    init {
        //..
    }
}</pre><p>There is no race condition when accessing the singleton class in Kotlin.</p><p>We looked at creating singleton instances in Java; to do so, we have to mark the constructor as private and provide a static method to access it. Furthermore, we need to have handled the race condition either by using the static initializer or the synchronized <span>keyword</span><a id="id326285721" class="indexterm"></a> on the <code class="literal">getInstance()</code> function. Then we looked at how easy it is to create a singleton in Kotlin, accessing the function in the singleton class. We also wrote test cases to verify the code.</p></div></div>