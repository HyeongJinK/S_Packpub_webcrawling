<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec48"></a>Message acknowledgement</h2></div></div><hr /></div><p>So far, we have learned how <span>messages</span><a id="id326364465" class="indexterm"></a> can be delivered from one point to another. We have used queues and topics to send the messages. Once the messages are consumed by the consumer, the messages will be removed from the messaging provider. Once the message is processed by the consumer, it can send an acknowledgement back to the messaging provider, so that the provider takes the messages off the queue or the topics. There are different ways to send this acknowledgement:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Auto acknowledge</strong></span>: In auto acknowledgement, when the message is received by the client, the message will be removed from the JMS provider. The message will be automatically removed from the queue or the topic once it is processed by the consumer.</li><li style="list-style-type: disc"><span class="strong"><strong>Duplicates OK</strong></span>: In duplicates OK mode, the consumer can receive duplicate messages.</li><li style="list-style-type: disc"><span class="strong"><strong>Client acknowledgment</strong></span>: In client acknowledgment mode, the client or the consumer has to acknowledge the message once it is received. Until then, the message won't be removed from the queue or topic. The provider will resend the message until it receives acknowledgement from the consumer that it has received the message.</li></ul></div><p>Let's see this in action. We previously created the point-to-point messaging model. Consider this module again. Here, we have the <code class="literal">Producer</code> class, which produces a message for the queue:</p><pre class="programlisting">class Producer { 
    fun sendMessage(message: String): String {
     //… 
    }
}</pre><p>The <code class="literal">Consumer</code> class consumes the message from the queue:</p><pre class="programlisting">class Consumer {
       fun receiveMessage(): Message {
       //….
    }
}</pre><p>We had test cases to invoke each of these classes to produce and consume the messages:</p><pre class="programlisting">class ProducerTest {
    @Test
    fun sendMessageTest() {
        //…
        val message = producer.sendMessage("TEST MESSAGE")
        Assert.assertEquals("Message sent", message)
    }
}
// Consumes the messages
class ConsumerTest {
    @Test
    fun receiveMessageTest() {
            //..
            val message = consumer.receiveMessage()
            Assert.assertNotNull(message)
            Assert.assertTrue(message is TextMessage)
     }
}</pre><p> </p><p> </p><p>By default, when we create a <code class="literal">JMSContext</code> using <code class="literal">ConnectionFactory</code>, <code class="literal">sessionMode</code> is set to <code class="literal">AUTO_ACKNOWLEDGE</code>: </p><pre class="programlisting">connectionFactory.createContext(JMSContext.AUTO_ACKNOWLEDGE)</pre><p>This means that once a message is <span>produced</span><a id="id326364010" class="indexterm"></a> by a producer and consumed by a consumer, it is automatically acknowledged to the messaging provider and the message will be removed from the queue.</p><p>If we re-run our <code class="literal">ConsumerTest</code> alone, it will wait for the message until there is a message in the queue:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/7e16f5b6-d844-4260-9f56-63d5e775d3eb.png" /></div><p>When the producer produces the message, the message will be consumed by the consumer and the message will be removed from the queue. When the consumer starts processing the message, it is automatically acknowledged and will be removed from the queue.</p><p>Let's now change <code class="literal">JMSContext</code> to <code class="literal">DUPS_OK_ACKNOWLEDGE</code> and see what happens. We will run <code class="literal">ProducerTest</code> and <code class="literal">ConsumerTest</code> once again. Notice that the message will be consumed by the receiver and the tests will pass.</p><p>Let's now re-run the <code class="literal">ConsumerTest</code> alone. The output will be as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/baf35ef0-6d5a-45f6-92ca-8b948f4182e8.png" /></div><p>This time, the <code class="literal">ConsumerTest</code> didn't block. It got the message and the test passed. If we run it again, the consumer would still receive the message as the <code class="literal">sessionMode</code> is set to <code class="literal">duplicates_ok</code>. Until the receiver sends acknowledgement, the provider keeps the message in the queue.</p><p>If we add the acknowledgement in the code once the message has been processed, after the consumer consumes the message, it will be removed from the queue. If we execute <code class="literal">ConsumerTest</code> again, it will wait for the next message to be produced in the queue.</p><p>In client acknowledgement, the message receiving party has to send acknowledgement after it processes the message. After acknowledgement, the message will be removed from the queue or the topic. Acknowledging the message tells the provider that it has processed the <span>message</span><a id="id325812942" class="indexterm"></a> and not to send it again.  If we don't acknowledge the message, it will be there in the provider until we acknowledge it:</p><pre class="programlisting">class Consumer {
    @Inject
    private lateinit var initialContext: InitialContext

    fun receiveMessage(): Message {
        val queue = initialContext.lookup("jms/PointToPointQueue") as Queue
        val connectionFactory = initialContext.lookup("jms/__defaultConnectionFactory")
                                   as ConnectionFactory
        val jmsContext = connectionFactory.createContext(JMSContext.CLIENT_ACKNOWLEDGE)
        val textMessage = jmsContext.createConsumer(queue)
                                    .receive()
        return textMessage
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note33"></a>Note</h3><p>In this case, acknowledging the message after processing it is the responsibility of the receiver. We created <code class="literal">sessionMode</code> as <code class="literal">CLIENT_ACKNOWLEDGE</code> only in the <code class="literal">Consumer</code> class.</p></div></div>