<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>Why Kotlin is the game changer</h2></div></div><hr /></div><p>Kotlin offers many features of <span>modern</span><a id="id326226205" class="indexterm"></a> languages. It has null safety, a functional style of coding, non-verbose code, and is clean and easy when it comes to using Java's stream operations, including <code class="literal">filter</code>, <code class="literal">map</code>, <code class="literal">reduce</code>, and more.All of these can help to improve your development life cycle and productivity.</p><p>Kotlin was developed with the intention of adding features that are not found in existing JVM languages. It is a modern JVM language that has full interoperability with Java, ensuring that existing applications or services don't face any problems with coexisting with Kotlin. If we are familiar with functional paradigms, it will be easier to make use of the power of the language.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec14"></a>Interoperability with Java</h3></div></div></div><p>Kotlin is completely <span>interoperable</span><a id="id326226568" class="indexterm"></a> with Java. It hasn't changed any of the existing Java functionality. This means that if we are in the middle of an application or microservice written in Java, we can switch to Kotlin and use its new features.</p><p>If we have an existing Java project and want to leverage the advantage that Kotlin offers, we can add new code in Kotlin to an existing Java project. In an application, part of the code can be written in Java, part in Kotlin, and they will work seamlessly together.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Functional paradigms</h3></div></div></div><p>Kotlin supports a functional style of <span>programming</span><a id="id326226585" class="indexterm"></a> that allows you to write more elegant, concise, and expressive code.</p><p>In Kotlin, we don't have to write lengthy code to provide simple functionality. Pure functions and higher-order functions avoid mutating the states, thereby reducing the complexity of the code and improving its readability.</p><p>Lambda expressions are anonymous functions that represent the implementation of a <span class="strong"><strong>Single Abstract Method</strong></span>(<span class="strong"><strong>SAM</strong></span>) interface. We can pass lambda expressions to functions. In doing this, we are not passing objects, but instead we are passing behaviors to the functions that are evaluated without mutating the state of an object. This turns a function into a higher-order function.</p><p>Consider the following lambda expression:</p><pre class="programlisting">val greetingLambda = { <span>println</span>(<span>"Greet from inline lambda"</span>) }</pre><p>This can be invoked using the following:</p><pre class="programlisting">greetingLambda() <span>or</span>

greetingLambda.invoke()</pre><p>The output of the preceding lambda expression is as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/dae6c92b-8c6d-4635-8457-a11e0d829f0c.png" /></div><p>Let's write an inline lambda expression to print even numbers:</p><pre class="programlisting">listOf(<span>0</span>,<span>1</span>,<span>2</span>,<span>3</span>,<span>4</span>,<span>5</span>,<span>6</span>,<span>7</span>,<span>8</span>,<span>9</span>)
.filter{ e -&gt; e % <span>2</span> == <span>0</span>}
.forEach{ e -&gt; println(e)}</pre><p> </p><p>The <span>output</span><a id="id326360224" class="indexterm"></a> will be as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/93de564d-2848-4bca-af6d-4e4443c6bb30.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>Immutability</h3></div></div></div><p>Immutability is the <span>opposite</span><a id="id326360247" class="indexterm"></a> of mutation. <span class="strong"><strong>Mutation</strong></span> is where we modify <span>the</span><a id="id326360262" class="indexterm"></a> state of an object. Mutation is error-prone and makes debugging difficult. Kotlin emphasizes immutability with <code class="literal">val</code>, which makes a variable immutable. Its collection types are also immutable by default. Once the <code class="literal">val</code> or collection is initialized, it is guaranteed to hold the same value. Immutability makes code easier to write and use and the internal state of the application will be more consistent.</p><p>Let's consider the following code sample:</p><pre class="programlisting">object ImmutabilityTest {
@JvmStatic
    fun main(args: Array&lt;String&gt;) {
val msg = "Hello"
msg = "hi"
println(msg)
    }
}</pre><p>In the preceding code, we created a immutable variable, <code class="literal">msg</code>, assigned a value. We then try to change its value.</p><p> </p><p> </p><p>If we compile this code, it gives us a compilation error that the value of <code class="literal">msg</code> cannot be changed:</p><pre class="programlisting"><span class="strong"><strong>[INFO] Changes detected - recompiling the module!
[INFO] Compiling 2 source files to ..\Intermixing Java and Kotlin\myJavaApp\target\classes
[INFO]
[INFO] --- kotlin-maven-plugin:1.2.41:compile (compile) @ myJavaApp ---</strong></span>
<span class="strong"><strong>[ERROR] ..\Intermixing Java and Kotlin\myJavaApp\src\main\java\ImmutabilityTest.kt: (5, 9) Val cannot be reassigned</strong></span></pre><p>Consider the following example as well:</p><pre class="programlisting">object ImmutabilityTest {
@JvmStatic
    fun main(args: Array&lt;String&gt;) {
val msg: String
        msg = "Good Morning"
msg = "Good Evening"

println(msg)
    }
}

</pre><p>In the preceding code, we created a immutable variable, <code class="literal">msg</code>, which is of the <code class="literal">String</code> type. Note that we declared the type explicitly here and varied the initialization of <code class="literal">msg</code>. When we are varying the initialization, we have to declare the type explicitly. We then try to change its value. </p><p>If we <span>compile</span><a id="id326369836" class="indexterm"></a> this code, it also gives us a compilation <span>error</span><a id="id326369847" class="indexterm"></a> that the value of <code class="literal">msg</code> cannot be changed:</p><pre class="programlisting"><span class="strong"><strong>[INFO] Changes detected - recompiling the module!
[INFO] Compiling 2 source files to ..\Intermixing Java and Kotlin\myJavaApp\target\classes
[INFO]
[INFO] --- kotlin-maven-plugin:1.2.41:compile (compile) @ myJavaApp ---</strong></span>
<span class="strong"><strong>[ERROR] ..\Intermixing Java and Kotlin\myJavaApp\src\main\java\ImmutabilityTest.kt: (6, 9) Val cannot be reassigned</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Null safety</h3></div></div></div><p>Generally, when we write code, we declare the fields in a class. We are not sure whether or not the field is initialized during execution. To find out, we use <span>null</span><a id="id326369883" class="indexterm"></a> checks and annotations such as <code class="literal">@Nullable</code> or <code class="literal">@NotNull</code>. Kotlin provides elegant syntax for declaring fields with nullable and non-nullable types, which prevents the problem of accidental <span class="strong"><strong>NullPointerExceptions </strong></span>(<span class="strong"><strong>NPEs</strong></span>). Kotlin catches possible <span>null</span><a id="id326559794" class="indexterm"></a> pointers when the code is being compiled, meaning that no null pointer issues will occur after the application has been deployed. This means that there are almost no cases of <code class="literal">NullPointerException</code>.</p><p>Consider the following code:</p><pre class="programlisting">object NullabilityTest {
    @JvmStatic
    fun main(args: <span>Array</span>&lt;<span>String</span>&gt;) {
        <span>var</span> msg: <span>String</span> = <span>null</span>
        println(msg)
    }
}</pre><p>Let's compile the preceding code:</p><pre class="programlisting"><span class="strong"><strong>[INFO] <span>------------------------------------------------------------------------</span>
[ERROR] Failed to <span>execute</span> goal org.jetbrains.kotlin:kotlin-maven-<span>plugin</span>:<span>1.2.41</span>:compile (compile) <span>on</span><span>project</span> myJavaApp: Compilation <span>failure</span>
[<span>ERROR</span>] ..\Intermixing <span>Java</span><span>and</span> Kotlin\myJavaApp\src\<span>main</span>\<span>java</span>\NullabilityTest.kt:[<span>10</span>,<span>28</span>] <span>Null</span> cannot be a <span>value</span><span>of</span> a non-<span>null</span><span>type</span><span>String</span></strong></span></pre><p>This code gives a compilation error. If we want to assign a null value to a variable, it has to be declared as follows:</p><pre class="programlisting"><span>var</span> msg: <span>String</span> ?= <span>null</span></pre><p>The <code class="literal">msg</code> variable can be declared with a null value. Let's consider another example:</p><pre class="programlisting"><span>object</span> NullabilityTest {
    @<span>JvmStatic
    fun <span>main</span>(<span>args: Array&lt;String&gt;</span>) </span>{
        <span>var</span> userList:ArrayList&lt;String&gt; ?= null
        println(userList.<span>get</span>(<span>0</span>))
    }
}</pre><p> </p><p> </p><p>Variables can be declared to hold a null value. If we invoke any function on these variables, such as <code class="literal">userList.get(0)</code>, it doesn't throw <code class="literal">NullPointerException</code> at runtime. Instead, it just fails to compile:</p><pre class="programlisting"><span class="strong"><strong><span>Error</span>:(<span>6</span>, <span>25</span>) Kotlin: Only safe (?.) or non-<span>null</span> asserted (!!.) calls are allowed on a nullable receiver <span>of</span> type kotlin.collections.ArrayList&lt;<span>String</span>&gt;? <span>/* = java.util.ArrayList&lt;String&gt;? */</span></strong></span></pre><p>Kotlin catches possible null pointers during compile time. It warns us that we should initialize the <code class="literal">var</code> before accessing it. The language provides clear constructs to define which variables can hold a null value, and which can hold a non-null value. When a variable is null, the language provides a safer way to deal with it, avoiding null pointer issues at runtime. This means that there are almost no cases of <code class="literal">NullPointerException</code>.</p><p>Since the variables have been declared to hold a null value, we need to perform a null check before accessing any function on this variable. Kotlin provides an elegant syntax for null check (<code class="literal">?.</code>), as follows:</p><pre class="programlisting">userList?.<span>get</span>(<span>0</span>)</pre><p>Kotlin provides an elegant syntax to perform an operation on the variable that can hold null values safely. Consider the following code:</p><pre class="programlisting">fun main(args: <span>Array</span>&lt;<span>String</span>&gt;) {
    <span>var</span> userList:<span>ArrayList</span>&lt;<span>String</span>&gt; ?= null
    var user = userList?.<span>get</span>(<span>0</span>)

    user ?.<span>let</span> {
        <span>println</span>(<span>"got the user details"</span>)
    } ?: run {
        <span>println</span>(<span>"there is no user"</span>)
    }
}</pre><p>Here, we create a <span>list</span><a id="id325977706" class="indexterm"></a> of users, <code class="literal">userList</code>, and try to get the first object and do something with it. In this case, the <code class="literal">user</code> instance is null, so when we use <code class="literal">?.</code> on it, it doesn't throw <code class="literal">NullPointerException</code>. If the  <code class="literal">user</code> instance is not null, it prints a <code class="literal">got the user details</code> message to the console. If it is null, it prints a <code class="literal">there is no user</code> message.</p><p>In short, Kotlin is a feature-packed language, with its simple and concise language constructs. If we already have an application written in Java, we can include Kotlin to get the benefits that it offers. Once the code is compiled, everything is bytecode and no distinction is made between Java or Kotlin. This is possible because Kotlin is interoperable with Java and provides an elegant way of writing code that reduces the development life cycle and is less error prone.</p></div></div>