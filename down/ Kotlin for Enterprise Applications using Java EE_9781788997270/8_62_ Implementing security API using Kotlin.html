<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec62"></a>Implementing security API using Kotlin</h2></div></div><hr /></div><p>In this section, we will <span>discuss</span><a id="id325819069" class="indexterm"></a> how to protect a REST resource by implementing the security API using Kotlin. We created a resource to create and read an organization as an identity data in the previous chapter. In this chapter, we will add a security layer to this RESTful service by implementing custom <code class="literal">HttpAuthenticationMechanism</code> and <code class="literal">IdentityStore</code> mechanisms.</p><p>We will add the following security-related dependencies to the existing dependencies:</p><pre class="programlisting">        &lt;dependency&gt;
            &lt;groupId&gt;org.glassfish.soteria&lt;/groupId&gt;
            &lt;artifactId&gt;javax.security.enterprise&lt;/artifactId&gt;
            &lt;version&gt;${org.glassfish.soteria}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;${javax.servlet-api}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.glassfish&lt;/groupId&gt;
            &lt;artifactId&gt;javax.security.auth.message&lt;/artifactId&gt;
            &lt;version&gt;${javax.security.auth.message}&lt;/version&gt;
        &lt;/dependency&gt;</pre><p>Now, let's <span>implement</span><a id="id325818983" class="indexterm"></a> our custom <code class="literal">IdentityStore</code>. For demonstration purposes, we store the user details in the store implementation itself.</p><p>We implement the <code class="literal">IdentityStore</code> interface and override the <code class="literal">validate()</code> function, as shown in the following code:</p><pre class="programlisting">@ApplicationScoped
@ManagedBean
class MyIdentityStore : IdentityStore {
    override fun validate(userCredential: Credential): 
                   CredentialValidationResult {
        return if (userCredential is UsernamePasswordCredential
                userCredential.compareTo("testUser", "testUserPass")) {
            CredentialValidationResult("admin",
                    HashSet(asList("user")))
        } else CredentialValidationResult.INVALID_RESULT
    }
}</pre><p>We also write our own custom <code class="literal">AuthenticationMechanism</code> by implementing the <code class="literal">HttpAuthenticationMechanism</code> interface and overriding the <code class="literal">validateRequest()</code> function. Consider the following code for this:</p><pre class="programlisting">@ApplicationScoped
class MyAuthMechanism : HttpAuthenticationMechanism {
    @Inject
    internal var myIdentityStore = MyIdentityStore()

    override fun validateRequest(req: HttpServletRequest,
                                 res: HttpServletResponse,
                                 context: HttpMessageContext): AuthenticationStatus {
        val result = myIdentityStore.validate(
                UsernamePasswordCredential(
                        req.getHeader("UserId"),
                        req.getHeader("Password")))
        return if (result.status == VALID) {
            AuthenticationStatus.SUCCESS
        } else {
            AuthenticationStatus.SEND_FAILURE
        }
    }
}</pre><p>With the <code class="literal">validateRequest()</code> function, we extract the user's credentials from the <code class="literal">UserId</code> and <code class="literal">Password</code> headers and construct an instance of the <code class="literal">UsernamePasswordCredential</code> type, which holds the user ID and password. We then invoke our custom <code class="literal">IdentityStore</code> instance's <code class="literal">validate()</code> function by passing the credentials.</p><p>Our request now includes two new headers—<code class="literal">UserId</code> and <code class="literal">Password</code>. When the request is made, the <code class="literal">validateRequest()</code> function will be invoked. In turn, this invokes the store's <code class="literal">validate()</code> function and <span>checks</span><a id="id325816104" class="indexterm"></a> for the credentials passed in the header. If the credentials are valid, the organization response will be returned, with <code class="literal">200</code> as the status code. If not, the <code class="literal">401</code> status code is returned, indicating unauthorized access.</p><p>Let's verify this by making a REST call using the following commands:</p><pre class="programlisting">curl -X GET \
http://localhost:8080/organization/4c118afd-eccb-4ac7-bcfc-15e47f10770a\
  -H 'Accept: application/json' \
  -H 'Content-Type: application/json' \
  -H 'Password: testUserPass' \
  -H 'UserId: testUser' \</pre><p>When we invoke the REST endpoint using the <code class="literal">curl</code> command, we get the <code class="literal">org</code> response, as we passed the correct credentials:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/ef23503c-13db-478f-8a81-352be0e7f1d2.png" /></div><p>Let's make a call with an <code class="literal">invalid</code> password. Here, we expect to <span>receive</span><a id="id325812946" class="indexterm"></a> the <code class="literal">401</code> status code:</p><pre class="programlisting">curl -X GET \
http://localhost:8080/organization/4c118afd-eccb-4ac7-bcfc-15e47f10770a\
  -H 'Accept: application/json' \
  -H 'Content-Type: application/json' \
  -H 'Password: invalid' \
  -H 'UserId: testUser' \</pre><p>The following screenshot shows the output:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/1c8cfc1d-8742-44d3-9bb4-d553cb314055.png" /></div><p>As expected, the <code class="literal">401</code> Unauthorized status code is returned.</p><p>This example is a simple demonstration of how the security layer can be implemented using Kotlin and Java EE Security API.</p></div>