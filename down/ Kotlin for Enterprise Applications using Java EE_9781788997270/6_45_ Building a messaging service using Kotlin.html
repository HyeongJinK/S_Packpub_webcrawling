<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec47"></a>Building a messaging service using Kotlin</h2></div></div><hr /></div><p>As discussed, Java messaging <span>service</span><a id="id325818963" class="indexterm"></a> has defined the following two <span>modes</span><a id="id325818952" class="indexterm"></a> of operation for exchanging messages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Point-to-Point messaging</li><li style="list-style-type: disc">Publish-Subscribe messaging</li></ul></div><p>In the point-to-point messaging model, a sender sends the message over a messaging service provider and a consumer consumes the message. In this model, we use a queue as a messaging service provider. In the publish-subscribe model, a publisher publishes the message and the subscribers will receive the messages. In this model, we use a topic as a messaging service provider.</p><p>In this section, we will demonstrate these two models and discuss some of the messaging types that can be used in these programming models.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec46"></a>Point-to-point messaging</h3></div></div></div><p>Let's create a Maven <span>project</span><a id="id325816188" class="indexterm"></a> to demonstrate what it takes to <span>write</span><a id="id325816186" class="indexterm"></a> a point-to-point messaging model.</p><p>We need to add the following dependencies to the project. We will use <span>Kotlin</span><a id="id325816107" class="indexterm"></a> and a few other dependencies such as the <span class="strong"><strong>GlassFish Message Queue</strong></span> (<span class="strong"><strong>glassfishmq</strong></span>) library and <code class="literal">weld-se-core</code> library to initialize the container:</p><pre class="programlisting">  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
      &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
      &lt;version&gt;${kotlin.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
      &lt;artifactId&gt;kotlin-test-junit&lt;/artifactId&gt;
      &lt;version&gt;${kotlin.version}&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.glassfish.main.appclient&lt;/groupId&gt;
      &lt;artifactId&gt;gf-client&lt;/artifactId&gt;
      &lt;version&gt;${gf-client}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.glassfish.mq&lt;/groupId&gt;
      &lt;artifactId&gt;imqjmsra&lt;/artifactId&gt;
      &lt;version&gt;${imqjmsra}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.weld.se&lt;/groupId&gt;
      &lt;artifactId&gt;weld-se-core&lt;/artifactId&gt;
      &lt;version&gt;${weld-se-core}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;${junit}&lt;/version&gt;
     &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec44"></a>Writing a producer class</h4></div></div></div><p>After creating the Maven <span>project</span><a id="id325816082" class="indexterm"></a> with these dependencies, we will create a message <code class="literal">Producer</code> class:</p><pre class="programlisting">class Producer{
}</pre><p>We need to initialize <code class="literal">InitialContext</code> here. <code class="literal">InitialContext</code> bootstraps the context and provides the entry point for the resolution of the named resources that we created in the <span>GlassFish</span><a id="id325601664" class="indexterm"></a> server.</p><p>We will inject <code class="literal">InitialContext</code> through <span class="strong"><strong>Context Dependency Injection</strong></span> (<span class="strong"><strong>CDI</strong></span>) as follows:</p><pre class="programlisting">class Producer {
 @Inject
 private lateinit var initialContext: InitialContext
}</pre><p>As we said earlier, queues are used in the point-to-point messaging model. We look for a queue using a JNDI lookup and this will return a reference object to a queue. This queue will be used to send messages by the producer and to read messages by the consumer.</p><p> </p><p> </p><p>We also need to look up the <code class="literal">ConnectionFactory</code> using JNDI. We use this <code class="literal">connectionFactory</code> to create the <code class="literal">JMSContext</code>, using which we can send messages to the queue:</p><pre class="programlisting">val queue = initialContext.lookup("jms/PointToPointQueue") as Queue
val connectionFactory = initialContext.lookup("jms/__defaultConnectionFactory") as ConnectionFactory</pre><p>We will create a producer using <code class="literal">JMSContext</code>. The <code class="literal">createContext()</code> function returns an instance of <code class="literal">JMSContext</code>. This is shown in the following code:</p><pre class="programlisting"> connectionFactory.createContext()
                  .createProducer()
                  .send(queue, message)</pre><p>Our <code class="literal">Producer</code> class looks as follows:</p><pre class="programlisting">class Producer {
@Inject
    private lateinit var initialContext: InitialContext

fun sendMessage(message: String): String {
try {
val queue = initialContext.lookup("jms/PointToPointQueue") as Queue
val connectionFactory = initialContext.lookup("jms/__defaultConnectionFactory") as      
                                            ConnectionFactory
            connectionFactory.createContext()
                    .createProducer()
                    .send(queue, message)
println("Message sent")
return "Message sent"
}catch ( e: NamingException){
println("unable to load a resource "+e.message)
return "Unable to deliver a message"
}
    }
}

</pre><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec45"></a>A quick comparison to Java code</h4></div></div></div><p>Let's take a moment to <span>write</span><a id="id325813046" class="indexterm"></a> the same class in Java and see the differences provided by Kotlin:</p><pre class="programlisting">public class Producer {
    @Inject
    InitialContext initialContext;

    public String sendMessage(String message) {
      try {
            Queue queue = (Queue)initialContext.lookup("jms/PointToPointQueue");
            ConnectionFactory connectionFactory = (ConnectionFactory)              
             initialContext.lookup("jms/__defaultConnectionFactory");
            JMSContext jmsContext = connectionFactory.createContext(); 
            jmsContext.createProducer()
                      .send(queue, message);
            jmsContext.close();
        }catch (NamingException e) {
            e.printStackTrace();
        }
        return "Message sent";
    }
}</pre><p>Note how the code in Kotlin looks more expressive compared to Java. We don't need the type declaration, we just use either <code class="literal">val</code> or <code class="literal">var</code> and the type is inferred from the context. This means that no explicit type casting is required; Kotlin provides us with an elegant syntax to express the type.</p><p>Also, note that the <code class="literal">initialContext</code> can be null. If we are not injecting <code class="literal">initialContext</code>, we end up with a <code class="literal">NullPointerException</code>. We then add the null check in the code. If we forget to add the null check and the context is not initialized, the compiler won't complain but the code will fail at runtime.  </p><p>Kotlin code is more mature in this respect. The compiler forces us to add null checks using <code class="literal">?.</code> before accessing a variable that is declared as <code class="literal">null</code>:</p><pre class="programlisting">@Inject
private var initialContext: InitialContext? = null</pre><p>Let's say we are trying to use this <code class="literal">initialContext</code> directly without the value being injected, as follows:</p><pre class="programlisting">val queue = initialContext.lookup("jms/PointToPointQueue") as Queue</pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>This code fails to <span>compile</span><a id="id326364492" class="indexterm"></a> and gives the following error:</p><pre class="programlisting"><span class="strong"><strong>Error:(15, 39) Kotlin: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type InitialContext?</strong></span></pre><p>Before using <code class="literal">initialContext</code>, the compiler forces us to add a null check or to initialize the variable. This way, type safety is guaranteed and possible runtime errors are reduced.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec46"></a>Writing a Consumer class</h4></div></div></div><p>Let's now write the <code class="literal">Consumer</code> class to <span>receive</span><a id="id326364557" class="indexterm"></a> the message from the queue. On the <code class="literal">Consumer</code> side, we still need the <code class="literal">JMSContext</code> to retrieve the messages from the queue. The code looks similar to that which we wrote for the producer:</p><pre class="programlisting">class Consumer {
@Inject
    private lateinit var initialContext: InitialContext

fun receiveMessage(): String {
val queue = initialContext.lookup("jms/PointToPointQueue") as Queue
val connectionFactory = initialContext.lookup("jms/__defaultConnectionFactory") as                
                                   ConnectionFactory
val message = connectionFactory
                .createContext()
                .createConsumer(queue)
                .receiveBody(String::class.java)

println("Message received $message")
return message
    }
}</pre><p>We looked up the queue using a JNDI lookup and we loaded the <code class="literal">defaultConnectionFactory</code>. Then, we created <code class="literal">JMSContext</code> using the <code class="literal">createContext()</code> function invoked on <code class="literal">connectionFactory</code>. We created the consumer, passed the queue that we looked up, and invoked the <code class="literal">receiveBody()</code> function to retrieve the message sent by the producer.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec47"></a>Writing a test case for the Point-to-point messaging model</h4></div></div></div><p>Let's write a test <span>case</span><a id="id326364601" class="indexterm"></a> to see this code in action.</p><p> </p><p>We are actually going to write two test cases: one for the <code class="literal">Producer</code> class, which sends a message to the queue, and another one for the <code class="literal">Consumer</code> class, which retrieves the message from the queue.</p><p>First, let's write a test case for the <code class="literal">Producer</code> to simulate the <code class="literal">sendMessage()</code> function:</p><pre class="programlisting">class ProducerTest {

@Test
    fun sendMessageTest() {

val seContainerInitializer = SeContainerInitializer.newInstance()
val producer = seContainerInitializer.initialize()
                .select(Producer::class.java)
                .get()

        Assert.assertNotNull(producer)
val message = producer.sendMessage("TEST MESSAGE")
        Assert.assertEquals("Message sent", message)
    }
}</pre><p>When this test is executed, it pushes a <code class="literal">TEST MESSAGE</code> to the queue. The message waits in the queue for a consumer to consume it.</p><p>Let's now write a test for the <code class="literal">Consumer</code> to test the <code class="literal">receiveMessage()</code> function:</p><pre class="programlisting">class ConsumerTest {

@Test
    fun receiveMessageTest() {

val seContainerInitializer = SeContainerInitializer.newInstance()
val consumer = seContainerInitializer.initialize()
                .select(Consumer::class.java)
                .get()
        Assert.assertNotNull(consumer)
val message = consumer.receiveMessage()
        Assert.assertNotNull(message)
    }
}</pre><p>If we run these test cases, we can see that the <code class="literal">sendMessage()</code> function in the <code class="literal">Producer</code> class <span>produces</span><a id="id326364321" class="indexterm"></a> the message and pushes it into the queue. The <code class="literal">receiveMessage()</code> function in the <code class="literal">Consumer</code> class has consumed the message from the producer.</p><p> </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec47"></a>Publish-subscribe model</h3></div></div></div><p>Creating a publish-subscribe model is <span>similar</span><a id="id326395646" class="indexterm"></a> to creating a point-to-point <span>model</span><a id="id326395655" class="indexterm"></a> as the API used to send messages is similar. The context is what will change; we will load a topic here instead of a queue. We use the same dependencies that we used in the point-to-point messaging model.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec48"></a>Writing a Publisher class</h4></div></div></div><p>We write a <code class="literal">Publisher</code> class to <span>publish</span><a id="id326395673" class="indexterm"></a> a message to the topic:</p><pre class="programlisting">class Publisher {
@Inject
    private lateinit var initialContext: InitialContext

fun publishMessage(message: String) {
val topic = initialContext.lookup("jms/Topic") as Topic
val connectionFactory = initialContext.lookup("jms/__defaultConnectionFactory") 
                                    as ConnectionFactory

        connectionFactory.createContext()
                .createProducer()
                .send(topic, message)
    }
}</pre><p>Again, this is similar to what we wrote in the <code class="literal">Producer</code> class.</p><p>We inject <code class="literal">InitialContext</code> using CDI, we look up the topic using JNDI, and we load <code class="literal">connectionFactory</code>. We then create <code class="literal">JMSContext</code> by invoking the <code class="literal">createContext()</code> function on the <code class="literal">connectionFactory</code> obtained. Using <code class="literal">JMSContext</code>, we create the producer instance and we invoke the send function by passing the message and the topic as the destination resource.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec49"></a>Writing a Subscriber class</h4></div></div></div><p>The <code class="literal">Subscriber</code> class is again <span>similar</span><a id="id326395723" class="indexterm"></a> to the <code class="literal">Consumer</code> class that we wrote earlier:</p><pre class="programlisting">class Subscriber {
@Inject
    private lateinit var initialContext: InitialContext

@Throws(NamingException::class)
fun listenToMessage(): String? {
val topic = initialContext.lookup("jms/Topic") as Topic
val connectionFactory = initialContext.lookup("jms/__defaultConnectionFactory") 
                                    as ConnectionFactory

        var messageResponse = connectionFactory.createContext()
                .createConsumer(topic)
                .receiveBody(String::class.java)

        return messageResponse
    }
}</pre><p>We load the <code class="literal">topic</code> and <code class="literal">connectionFactory</code> and we create <code class="literal">JMSContext</code>, using which we create a consumer by passing a topic to listen to. When the message is published by the publisher, this subscriber will receive the message. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec50"></a>Writing a test case for the publish-subscribe model</h4></div></div></div><p>Let's write test <span>cases</span><a id="id326395757" class="indexterm"></a> to check the <code class="literal">publishMessage()</code> and <code class="literal">listenToMessage()</code> functions. </p><p>We can write a <code class="literal">PublisherTest</code> as follows:</p><pre class="programlisting">class PublisherTest {

@Test
    fun testPublishMessage() {
val seContainerInitializer = SeContainerInitializer.newInstance()
val seContainer = seContainerInitializer.initialize()
val publisherInstance = seContainer.select(Publisher::class.java)

val publisher = publisherInstance.get()
        Assert.assertNotNull(publisher)
val message = "Test messgage for topic111"
publisher.publishMessage(message)
    }
}</pre><p>We initialize the container to inject the dependencies. We get an instance of <code class="literal">Publisher</code> and invoke the <code class="literal">publishMessage()</code> function by passing the message. This message will be published to the topic.</p><p> </p><p> </p><p>Let's write a <code class="literal">SubscriberTest</code> to check the <code class="literal">Subscriber</code>:</p><pre class="programlisting">class SubscriberTest {
    private lateinit var executorService: ExecutorService
    private lateinit var countDownLatch: CountDownLatch

    @Before
    fun setUp() {
        countDownLatch = CountDownLatch(10)
        executorService = Executors.newFixedThreadPool(4)
    }

    @Test
    @Throws(NamingException::class)
    fun receiveMessageTest() {
        val seContainerInitializer = SeContainerInitializer.newInstance()

        val subscriber = seContainerInitializer.initialize()
                .select(Subscriber::class.java)
                .get()
        Assert.assertNotNull(subscriber)

        val runnableTask = {
            var msgResponse: String? = null
            try {
                msgResponse = subscriber.listenToMessage()
            } catch (e: NamingException) {
                e.printStackTrace()
            }
            if (msgResponse != null) {
                println("Yay--- message received $msgResponse")
            }
        }
        for (i in 0..3) {
            executorService.submit(runnableTask)
        }
        countDownLatch.await(120, TimeUnit.SECONDS)
    }
}</pre><p>In the <code class="literal">SubscriberTest</code> class, we created four threads, which we subscribed to in order to listen to the topic that we created. This is similar to having four different applications subscribed and  listening to the topic. We span the threads using the <code class="literal">Executor</code> framework.</p><p>The subscriber's <code class="literal">listenToMessage()</code> function is a blocking call. When <code class="literal">SubscriberTest</code> invokes the <code class="literal">listenToMessage()</code> functions in four different threads, the threads start listening to the topic.</p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note32"></a>Note</h3><p>In the preceding test case, the thread in execution waits for the publisher to publish the message for two minutes (120 seconds). After that, the thread exits gracefully. This code can be inside a <code class="literal">while…</code> loop, meaning the subscriber will always listen to the topic:<code class="literal">while(true) {</code><code class="literal">  val runnableTask = {</code><code class="literal">  var messageResponse = subscriber.listenToMessage()</code><code class="literal">  if (messageResponse != null) {</code><code class="literal">     println("Yay--- message received $messageResponse")</code><code class="literal">  }</code><code class="literal"> }</code><code class="literal">}</code> Whenever the messages are published, the messages will be received by the subscribers listening on the topic. When the publisher publishes the message, these four threads will receive the message.</p></div><p>As we have seen, the APIs of both the point-to-point and the publish-subscribe models are syntactically similar. Both the queue and the topic derive from the <code class="literal">Destination</code> interface. These messaging models have the following steps in common:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>We load the messaging service providers using a JNDI lookup</li><li>We load <code class="literal">connectionFactory</code> using a JNDI lookup</li><li>We initialize <code class="literal">JMSContext</code> using the factory</li><li>We send the messages to and receive the messages from the queue or topic</li></ol></div><p>In the examples that we <span>have</span><a id="id326542492" class="indexterm"></a> seen so far, we have just passed string messages. We can actually pass messages of any type that is serializable. The message itself can include information such as the message identifier or the destination type.</p><p>Messages have the following structure:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/c12fe083-8890-4e0f-8e30-1e0979eb903c.png" /></div><p>Messages will have headers, properties, and payload.</p><p>There are different headers that we can apply to the messages, as listed here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">Identity</code>:<span class="strong"><strong> </strong></span>Each <code class="literal">MessageType</code> has a <code class="literal">uniqueId</code> represented by <code class="literal">JMSMessageId</code>. This can be used to identify a and refer to the message.</li><li style="list-style-type: disc"><code class="literal">Priority</code>:<span class="strong"><strong> </strong></span>Messages can be given a priority. <code class="literal">JMSPriority</code> is used to set the priority. When the priority message arrives, the messaging provider will deliver it in the order of priority. Priority is an integer value from 0-9, 0 being the least priority and 9 being the highest.</li><li style="list-style-type: disc"><code class="literal">Durability</code>:<span class="strong"><strong> </strong></span>We can set a message as durable using the <code class="literal">JMSDeliveryMode</code> property. This tells the messaging provider to store the messages in a way that is durable. This means that even if the service provider restarts or recovers from a crash, the messages will still be available to consume. Non-durable messages are stored in memory and are subject to loss when the provider is restarted. Durable messages, however, are stored on hardware. <code class="literal">JMSDeliveryMode</code> can either be <code class="literal">DeliveryMode.NON_PERSISTENT</code> or <code class="literal">DeliveryMode.PERSISTENT</code>.</li><li style="list-style-type: disc"><code class="literal">Expiration</code>:<span class="strong"><strong> </strong></span>We can define the expiry time using the <code class="literal">JMSExpiration</code>property.When messages with the<code class="literal">JMSExpiration</code>property are sent to the provider, the provider discards the messages once the amount of time indicated has elapsed, whether or not the messages are durable. </li><li style="list-style-type: disc"><code class="literal">DestinationType</code>:<span class="strong"><strong> </strong></span>We can set the destination resource to which the messages are delivered using the <code class="literal">JMSDestination</code><span class="emphasis"><em> </em></span>property. This value can be either a  <code class="literal">queue</code><span class="emphasis"><em> </em></span>or a  <code class="literal">topic</code>.</li></ul></div><p>There are also properties that we can set for the message. These include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Messaging provider properties</strong></span>: The messaging provider can set some properties, which are meaningful in the context of that provider. <code class="literal">JMS</code><span class="emphasis"><em>  </em></span>is usually prefixed to any property of this kind.</li><li style="list-style-type: disc"><span class="strong"><strong>Application properties</strong></span>: The running application can set properties on the message before it gets delivered to the queue or topic. These properties can be used during the handshake between the applications that produce and receive messages.</li><li style="list-style-type: disc"><span class="strong"><strong>Standard properties</strong></span>: These properties are prefixed with  <code class="literal">JMSX</code><span class="emphasis"><em>  </em></span>and are defined in the JMS specification. The messaging provider can choose to support some or all of these properties in the implementation. These properties will be set by the messaging provider when the message is delivered.</li></ul></div><p>JMS has different types that can be used while sending or receiving the messages. It has a message interface and a set of classes that implement the message interface. These include <code class="literal">TextMessage</code>, <code class="literal">ObjectMessage</code>, <code class="literal">MapMessage</code>, <code class="literal">BytesMessage</code>, <code class="literal">StreamMessage</code>, and so on. We can set the properties while sending the message. <code class="literal">TextMessage</code> is used to pass simple text messages along with the other properties. <code class="literal">ObjectMessage</code> can be used to pass any object that is serializable. <code class="literal">MapMessage</code> can be used to send the type of <code class="literal">Map</code>, while <code class="literal">BytesMessage</code> takes an array of bytes.</p><p>Let's enhance our point-to-point <span>messaging</span><a id="id326225381" class="indexterm"></a> model to send and receive messages of the <code class="literal">TextMessage</code> type. Instead of <code class="literal">String</code>, we use <code class="literal">TextMessage</code> in the producer. The consumer in this case receives the <code class="literal">Message</code> type instead of <code class="literal">String</code>:</p><pre class="programlisting">class Producer {
@Inject
    private lateinit var initialContext: InitialContext

fun sendMessage(message: String): String {
try {
val queue = initialContext.lookup("jms/PointToPointQueue") as Queue
val connectionFactory = initialContext.lookup("jms/__defaultConnectionFactory")
as ConnectionFactory
val jmsContext = connectionFactory.createContext()
val textMessage = jmsContext.createTextMessage(message)

            jmsContext.createProducer()
                      .send(queue, textMessage)
return "Message sent"
} catch (e: NamingException) {
return "Unable to deliver a message"
}
    }
}</pre><p>Consider the following code for the <code class="literal">Consumer</code> class. It is very similar to that which we wrote earlier, but here the consumer receives a <code class="literal">TextMessage</code> instead of a string message:</p><pre class="programlisting">class Consumer {
@Inject
    private lateinit var initialContext: InitialContext

fun receiveMessage(): Message {

val queue = initialContext.lookup("jms/PointToPointQueue") as Queue
val connectionFactory = initialContext.lookup("jms/__defaultConnectionFactory") 
                                   as ConnectionFactory
val textMessage = connectionFactory
                .createContext()
                .createConsumer(queue)
                .receive()
return textMessage
    }
}</pre><p>The <code class="literal">ProducerTest</code> class remains the same, as shown in the following code:</p><pre class="programlisting">class ProducerTest {
@Test
    fun sendMessageTest() {
val seContainerInitializer = SeContainerInitializer.newInstance()
val producer = seContainerInitializer.initialize()
                .select(Producer::class.java)
                .get()

        Assert.assertNotNull(producer)</pre><pre class="programlisting">val message = producer.sendMessage("TEST MESSAGE")
        Assert.assertEquals("Message sent", message)

    }
}</pre><p>The <code class="literal">ConsumerTest</code> class also remains the same; we just add an extra line to assert the type of the message. This is shown in the following code:</p><pre class="programlisting">class ConsumerTest {

@Test
    fun receiveMessageTest() {
val seContainerInitializer = SeContainerInitializer.newInstance()
val consumer = seContainerInitializer.initialize()
                .select(Consumer::class.java)
                .get()
        Assert.assertNotNull(consumer)

val message = consumer.receiveMessage()
        Assert.assertNotNull(message)
        Assert.assertTrue(message is TextMessage)
    }
}</pre><p>Here, if we look at the <span>message</span><a id="id326225451" class="indexterm"></a> type and its properties, we can see that we have used a text message in place of the string message. We can then carry out appropriate processing based on the message and the context.</p></div></div></div>