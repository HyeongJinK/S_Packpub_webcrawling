<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec76"></a>Getting our real-world application production-ready</h2></div></div><hr /></div><p>When developing services, we follow the <span>concept</span><a id="id326287585" class="indexterm"></a> of a microservice architecture and use design patterns to make the system flexible and reliable. However, there are a few points that we need to consider in order to make the system production ready. These are aimed at high availability and system performance. Let's discuss these points:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><span class="strong"><strong>Stability and reliability</strong></span>: Stability and reliability are <span>important</span><a id="id326287570" class="indexterm"></a> to a system in order to make it production ready. Services tend to change and evolve over time. Any new code, any change in the existing code, and configuration changes should not break the existing functionality. Any changes in the system shouldn't result in reliability issues. Furthermore, no changes should result in instability in the system. Stability and reliability go hand in hand. To ensure the stability and reliability of the system, it is important to follow some standard practices when working through code and taking it to the end user. A standard development process is required so that the development of the system goes through a set of defined activities.Test cases play a vital role in ensuring the system's stability and reliability. It's important that the code is well tested. Writing unit test cases, integration test cases, system testing, and so on make the system reliable before it is used by an end user. The load testing and performance testing ensure the stability of the system under load and also ensure that the system is performant.
A proper deployment pipeline ensures that any code that gets checked in goes through defined stages such as build, test, code quality checks, and so on:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/4a3b9afe-12db-42a8-9235-55753f640555.png" /></div><p>As shown in the preceding diagram, a central code repository is maintained. Developers working on the code create a local branch and work in that branch. Any code change in this branch will go to a code review. Gated builds will be configured so that any check-ins to the local branch trigger the code change to go through the build process, unit test execution, and quality checks. This ensures that basic hygiene is maintained while making the code change.</p><p>If the gated builds are fine, the code changes will be merged from the local branch to the central repository. Once the new code is in the central repository, it will trigger the deployment pipeline. This <span>process</span><a id="id325866827" class="indexterm"></a> is commonly known as <span class="strong"><strong>Continuous Integration and Continuous Deployment</strong></span>(<span class="strong"><strong>CI/CD</strong></span>).</p><p>The <span class="strong"><strong>Deployment pipeline</strong></span> goes through the build process and deploys the services, at which point regression test cases will be executed. Some pipelines will have a small set of regression test cases as smoke test cases to get early feedback and ensure that basic functionalities are working. Once all of the test cases are regressed, the change is pushed to the next stage in the pipeline. The following diagram depicts this:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/b888a791-50ea-4b21-9a5f-7f520931b7fc.png" /></div><p>The deployment consists of multiple phases. Once the regression tests are passed in development, the services are deployed for integration. Again, a set of test cases is executed in integration and when they pass all the test cases, the changes are pushed to staging, which is a pre-production environment. Here, services are again deployed and tested, and will be rolled out to a production environment.</p><p>The development branch is where all code changes occur and regression tests are executed frequently. Integration environments are the candidates that follow development, where the different system integration tests are validated.</p><p>Services that are deployed to staging are release candidates for production. The staging and production environments are identical and will have a stable release version of the services. A production environment is consumed by end users and this is the last phase in the deployment pipeline. The build or services pass through the different stages before making it to production.</p><p>The majority of issues will be found and addressed in the development phase before any version is released. However, if releases have any issues, they will most likely be caught either in the integration or staging phases. Fixes will then be applied through patches or hotfixes, before being rolled out to production. Issues can be caught in the production stage also and patches will therefore be applied <span>throughout</span><a id="id325866778" class="indexterm"></a> the stages. It's not a good idea to put fixes directly into production. The pipeline ensures that any code change or new code is well tested and stable before it actually gets used by end users.</p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li><span class="strong"><strong>Scalability: </strong></span>Services that we <span>develop</span><a id="id325601674" class="indexterm"></a> and deploy have to be able to handle a large number of requests simultaneously. Systems have to be designed to be scalable so that they are able to respond to a bigger chunk of requests. Utilizing system resources efficiently is necessary for a system to handle many requests at the same time. Our code must also be written in a way that makes resource utilization optimal.</li><li><span class="strong"><strong>Performance: </strong></span>Performance is a <span>measure</span><a id="id325808123" class="indexterm"></a> of how well the system is handling and processing requests. This includes proper memory utilization and efficient use of computational resources.</li><li><span class="strong"><strong>High availability: </strong></span>Availability <span>indicates</span><a id="id325812917" class="indexterm"></a> the uptime of a service or an application. A system that is serving the request has to be up and running. Mission-critical systems are expected to have zero downtime. Furthermore, scaling services when load increases, adding multiple nodes to handle requests, and properly routing requests to nodes so that the load is shared between them increases the high availability of the system.</li></ol></div></div>