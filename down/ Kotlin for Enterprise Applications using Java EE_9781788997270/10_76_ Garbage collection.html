<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec74"></a>Garbage collection</h2></div></div><hr /></div><p>For programming <span>languages</span><a id="id325816214" class="indexterm"></a> that run on JVM such as Kotlin, Java, and so on, JVM automatically manages the memory. In our programs, we don't have to explicitly allocate and deallocate memory. In languages such as C and C++, it is the responsibility of programs to manage memory. This can become difficult when an application becomes big and could be erroneous when it has to manage memory explicitly.</p><p>Automatic garbage collection makes life easier, as the program doesn't need to handle memory in this case. JVM's garbage collector manages memory, allocating it to the objects that the program creates. It then reclaims it when these objects are no longer referenced by the program so that the memory becomes available to other objects in the application.</p><p>Automatic garbage collection reduces a lot of overhead that the program would have otherwise created in order to manage the memory that it uses during execution. The program doesn't have to worry about cleaning up objects that it uses, as the garbage collection handles this automatically.</p><p>There are two kinds of <span>memory</span><a id="id325816197" class="indexterm"></a> serving a program—stack and heap memory. Stack memory is used for storing temporary and local variables which are created by the functions. Heap memory is used for allocating the memory to objects at runtime.</p><p>Whenever we create an object, the memory for it is allocated in the heap memory and the reference variable that points to the object is stored in the stack memory or the heap memory, or it can be a local variable in the program context.</p><p>Consider the following small program to understand how an object is created and how it is referenced in the program:</p><pre class="programlisting">object GCExample{
    internal fun foo() {
val userList = ArrayList&lt;Any&gt;()
    }

    @JvmStatic
fun main(args: Array&lt;String&gt;) {
val obj = Any()
val name: String = "test"
foo()
    }
}</pre><p>The simple class that we created has a <code class="literal">main()</code> function and a <code class="literal">foo()</code> function. These functions create some objects while in execution. The <code class="literal">main()</code>  function creates an object of type <code class="literal">Any</code>  and a variable of type <code class="literal">String</code>, which is initialized to the value <span class="emphasis"><em>test</em></span>. The <code class="literal">foo()</code> function creates a <code class="literal">userList</code>, which is an <code class="literal">ArrayList</code> type.</p><p>Let's see the memory allocations for these objects:    </p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/e14c64f7-d3f2-4744-b0e2-e218fb164a39.png" /></div><p>As shown in the preceding screenshot, the <span>memory</span><a id="id325813062" class="indexterm"></a> for objects is allocated in the heap memory and the references to these objects are maintained in the stack. Note that the <code class="literal">foo()</code> function has a separate stack for it. String literals are created in the pool and are reused. If we say <code class="literal">String ("test")</code> , then separate memory is allocated for it; it is outside <span class="strong"><strong>String Pool</strong></span> and not reused by other references. Each time <code class="literal">String ("test")</code>  is used, new memory is allocated in the heap area.</p><p>These objects stay in memory as long as the program holds the reference. When the program completes its execution, the references that were made to these objects are no longer reachable and objects on the heap are eligible for garbage collection. When the garbage collector runs, it reclaims the heap memory that is no longer needed by the program.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec72"></a>Memory model</h3></div></div></div><p>In the Java memory model, the heap <span>memory</span><a id="id325808124" class="indexterm"></a> is divided into a young generation and old generation. The old generation is also known as <span class="strong"><strong>tenured</strong></span>:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/4b22fd4a-f8cd-4870-8891-c1036da7c593.png" /></div><p>The young generation consists of <span class="strong"><strong>Eden</strong></span> and <span>Survivor</span> spaces (<span class="strong"><strong>S0</strong></span> and <span class="strong"><strong>S1</strong></span>) and takes up about 40% of the heap memory, while the <span class="strong"><strong>Old Generation</strong></span> takes up about 60% of the memory.</p><p>When the program creates an object, it is created in the <span class="strong"><strong>Eden</strong></span> space first. When the <span class="strong"><strong>Eden</strong></span> space is filled up, the partial GC runs, marks the objects that are still referenced, and cleans up the objects in the young generation that are no longer reachable by the program. The following diagram depicts this:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/aeda71b5-02bd-4196-8723-c50a1ebc912c.png" /></div><p>The objects that survive during the partial GC in the <span class="strong"><strong>Eden</strong></span> space are now promoted to the Survivor space of the young generation. When the <span class="strong"><strong>Eden</strong></span> space is filled up again, the partial GC runs and reclaims the memory for the objects that are no longer referenced. Any objects that survive during this GC are promoted to the <span class="strong"><strong>Old Generation</strong></span>.</p><p>When the old generation fills up, the full garbage collection runs on the heap <span>memory</span><a id="id325857701" class="indexterm"></a> and deletes the objects that are no longer needed, keeping objects that are referenced by the program. The objects that are likely to live for a long time are moved to the old generation so that the partial GC doesn't have to clean up objects that are still referenced by the program.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec73"></a>Types of garbage collector</h3></div></div></div><p>There are two types of <span>garbage</span><a id="id325857718" class="indexterm"></a> collectors:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span>Serial/Parallel garbage collectors</span></li><li style="list-style-type: disc">Concurrent collectors</li></ul></div><p>The following diagram depicts garbage collectors:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/37228f1d-b2b0-40b1-a925-bfc85279cbca.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec71"></a>Serial and parallel collectors</h4></div></div></div><p>Serial/parallel <span>garbage</span><a id="id325858555" class="indexterm"></a> collectors are <span class="emphasis"><em>stop-the-world</em></span><span class="emphasis"><em>events</em></span>, meaning that they will stop all running application threads and perform the GC. Once this is done, collectors resume the application threads. While the GC runs, the application pauses for that time.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>The difference between serial and parallel garbage collectors is that serial garbage collectors are single-threaded and parallel ones are multithreaded. When these collectors are running, the application will stop for that time.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note48"></a>Note</h3><p>Serial and parallel garbage collectors pause the application while they run GC, and the parallel collector is the default collector. These collectors work better for smaller heaps as it is quicker to clean them and stop the application while reclaiming the memory. With a smaller heap, the application pauses as the GC runs, is likely to be shorter, and mostly goes unnoticed.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec72"></a>Concurrent collectors</h4></div></div></div><p>Concurrent collectors don't pause an <span>application</span><a id="id326025107" class="indexterm"></a> when they run. Instead, they reclaim the memory while the application is running.</p><p>There are two variants of concurrent collectors—concurrent mark-sweep (CMS) and G1 GC (Garbage First). G1 GC now replaces the CMS, and G1 GC cleans the old generation concurrently when the application is running. There are still some pauses while G1 GC runs to ensure consistency, but these are much shorter than the full GC that runs with a parallel collector.</p><p>The pauses in the concurrent collectors include the mark and remark phases. When GC starts, there is a pause for the initial marking of the objects and then again for the unused objects that are claimed from memory while the application is running. After this, there will be a small pause again at the end for remarking and cleanup.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note49"></a>Note</h3><p>Younger generation collectors are parallel by default and there is no way to make them concurrent.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec73"></a>Tuning the GC</h4></div></div></div><p>Tuning the GC is not always <span>required</span><a id="id326287581" class="indexterm"></a> to achieve better performance or to reduce system downtime caused by any out-of-memory issues. The default settings are reasonable for reclaiming unused memory. The GC in the JVM is built to react to memory management adaptively. The GC is configured to run when the allocated memory reaches a certain threshold.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note50"></a>Note</h3><p>We can hint for the JVM to run GC programmatically using <code class="literal">System.gc()</code> or <code class="literal">Runtime.getRuntime().gc()</code>. However, it is up to the JVM to run the GC event. The <code class="literal">gc()</code> function is not guaranteed to run the GC.</p></div><p>The heap size can be specified using the following -Xms and -Xmx JVM options:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">-Xms is the heap area size when the JVM is starting</li><li style="list-style-type: disc">-Xmx is the maximum heap size</li></ul></div><p>JVM options can be used to set the GC types, as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">-XX:+UseSerialGC is used to set the GC type to use serial GC collectors</li><li style="list-style-type: disc">-XX:+UseParallelGC is used to set the GC type to use parallel collectors</li><li style="list-style-type: disc">-XX:-UseConcMarkSweepGC is used to set the GC type to use concurrent mark-sweep collectors</li></ul></div><p>When the application is running, there might be an out-of-memory-error. The reason for this might be that the application was allocated less memory or that it encountered a memory leak. Simply adding the memory seems to work, but this is not always the right solution. There will be a pause when GC is running, and this is not expected behavior for an application.</p><p>To address these issues, it's good to start with benchmarking, since tuning GC is not straightforward for the different memory problems that we face. While benchmarking, make small changes, measure the impact of each change, and repeat until you get the desired outcome. We can look for latency, throughput, and footprint while tuning for GC. Latency is the maximum individual pause time, throughput is the amount of time spent serving requests, and footprint is the size of the heap that we can tune for. The aim is to have high throughput and low latency in an application in order for it to perform better.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch10lvl4sec28"></a>High throughput and low latency</h5></div></div></div><p>In order to have maximum <span>throughput</span><a id="id326287773" class="indexterm"></a> and low latency, we need to use G1 GC and a large heap. When we have a large heap, a shorter pause time will lead to more time spent on serving the request, which is high throughput.</p><p>We use the -XX:+UseG1GC JVM option to indicate the JVM should use the G1 GC type.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch10lvl4sec29"></a>High throughput and low footprint</h5></div></div></div><p>If we need to have a small <span>footprint</span><a id="id326287799" class="indexterm"></a> and high throughput, then the best way to achieve that is to use a parallel collector and a small heap. In this case, what we have is a full garbage collection, which pauses the application for slightly longer in comparison to using G1 GC. This will allow the application to perform GC to claim the memory allocated to objects, but the application will pause while it performs GC. The pauses will be longer, but not as frequent. Consequently, we can still achieve more throughput while keeping the footprint low.</p><p>We use the -XX:+UseParallelGC JVM option to indicate that the JVM should use the parallel GC type.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch10lvl4sec30"></a>Low pause time and small footprint</h5></div></div></div><p>If we want low pause times and a smaller <span>footprint</span><a id="id326287820" class="indexterm"></a> then throughput will be lower. In this case, we have a lot of individual pauses that are very short. The pause time is split into smaller chunks, so it will go unnoticed.</p><p><span>The JVM manages these considerations for us.</span> First, it tries to achieve low latency (that is, low pause times). If it achieves that, it next aims for throughput and more time spent serving requests. The JVM will increase the heap to the maximum specified in order to achieve high throughput.</p></div></div></div></div>