<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec46"></a>Messaging queues and topics</h2></div></div><hr /></div><p>Messaging queues and topics are the <span>mechanisms</span><a id="id325601659" class="indexterm"></a> by which messages are <span>delivered</span><a id="id325442828" class="indexterm"></a> from one point to another. They act as the staging area for messages. Messages are pushed onto a queue or topic and wait for the consumer to consume them.</p><p>The queue is used in the point-to-point messaging model, where the message is produced by the producer and received by a single consumer. The topic is used in the publish-subscribe messaging model, where the message is published by a publisher to a topic and is then consumed by multiple subscribers that are listening on that topic.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec45"></a>Java messaging System</h3></div></div></div><p><span class="strong"><strong>Java messaging system</strong></span> is the <span>standard</span><a id="id325442813" class="indexterm"></a> Java API for the messaging systems. Any JMS implementation should expose this Java API as an interface. JMS focuses on the messaging API and its underlying messaging framework can be provided by different JMS providers. </p><p> </p><p> </p><p>There are different JMS implementations available, including OpenMQ, RabbitMQ, WebSphere MQ, and WildFly. We can choose any of these JMS providers for our application; we are going to use GlassFish, which is a reference implementation of the JMS specification and is open source.</p><p>Let's look at how to install the GlassFish server, which acts as a JMS provider. We will use GlassFish 5, which is the latest version of GlassFish at the time of writing this book.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec42"></a>Installing GlassFish</h4></div></div></div><p>The GlassFish server can be <span>downloaded</span><a id="id326232165" class="indexterm"></a> using the <span>following</span><a id="id326232144" class="indexterm"></a> URL: <a class="ulink" href="https://javaee.github.io/glassfish/download" target="_blank">https://javaee.github.io/glassfish/download</a>.</p><p>The following screenshot shows the main screen:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/4af7d63c-6cfa-4949-994f-fc412b5f76c4.png" /></div><p>Select <strong class="userinput"><code>GlassFish 5.0 - Full Platform</code></strong> and download it. Once it is downloaded, unzip the file and go to the <code class="literal">glassfish-5.0\glassfish5\glassfish\bin</code> directory. Start the server using <code class="literal">startserv</code>. This will bring up the GlassFish server on its default port, <code class="literal">4848</code>. In the browser, head over to <code class="literal">http://localhost:4848/</code>. This URL takes us to the GlassFish server console. This is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/6b5b9f74-b2fa-4fcd-9556-e0247404ac61.png" /></div><p>Now, we need to create the resources for messaging.By default, the GlassFish server has a JMS resource defined for us, which is <code class="literal">jms/__connectionFactory</code>. We will use this connection factory to create a JMS context:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/2f5f0da5-12a0-48e4-9b1a-0bec6480911c.png" /></div><p>This is all it takes to <span>install</span><a id="id325961531" class="indexterm"></a> the GlassFish server. We will use <span>this</span><a id="id325961542" class="indexterm"></a> JMS provider in the following sections.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec43"></a>Configuring GlassFish</h4></div></div></div><p>We have <span>installed</span><a id="id325961562" class="indexterm"></a> the GlassFish server. Let's now take a look at <span>how</span><a id="id325961571" class="indexterm"></a> to initialize our JMS provider, before we actually write some code to send and receive messages.</p><p>First, we define some resources in the GlassFish server, which are called <span class="strong"><strong>administered objects</strong></span>. These <span>have</span><a id="id325961586" class="indexterm"></a> names, which we can use to access the resources in our application code. The first admin object is <code class="literal">connectionFactory</code>. By default, the server has a <code class="literal">connectionFactory</code> called <code class="literal">__defaultConnectionFactory</code>. This is used for bootstrapping in the messaging model. We can use a <span class="strong"><strong>Java Naming and Directory Interface</strong></span> (<span class="strong"><strong>JNDI</strong></span>) lookup by <span>passing</span><a id="id325961964" class="indexterm"></a> the name of the factory. This gives an object in return, which represents the <code class="literal">ConnectionFactory</code>. </p><p>We then use the <code class="literal">connectionFactory</code> to create the <code class="literal">JMSContext</code>. This can be used to create queues and topics, and send messages to them.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note31"></a>Note</h3><p>In JMS, in order to implement the point-to-point model, we use queues. To implement the publish-subscribe model, we use topics. We look up these resources using JNDI in our code. The GlassFish server defines a default connection factory, <code class="literal">__defaultConnectionFactory</code>. This factory, the queues, and topics are registered as part of the JNDI setup inside the GlassFish server.</p></div><p>Finally, let's create something called destination resources. These destination resources serve as the message stores. We can create queues and topics as message stores. To create a resource, click on <strong class="userinput"><code>Destination Resource</code></strong>, select <strong class="userinput"><code>New</code></strong>, and define the resource. We provide a JNDI name, which will be used for looking up the resource, and a physical name. We also need to select the type of resource, either queue or topic. This is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/d76c0f7b-2d0e-42ef-9ebb-1ef9b93b03ec.png" /></div><p> </p><p> </p><p>Here, we created a queue called <code class="literal">jms/PointToPointQueue</code>. Similarly, we can create a topic as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/15c9ceb4-a31a-4dd2-904d-472787fb3057.png" /></div><p>We have now created two destination resources—a messaging queue called <code class="literal">PointToPointQueue</code> and a messaging topic called <code class="literal">Topic</code>. This is shown in the following screenshot: </p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/3246632b-0597-472a-a030-afdeb17a008b.png" /></div><p>We are now all set <span>with</span><a id="id325966443" class="indexterm"></a> the administration objects <span>required</span><a id="id325966452" class="indexterm"></a> to demonstrate the point-to-point and publish-subscribe models. Let's write some code to demonstrate these models.</p><p> </p><p> </p><p> </p><p> </p><p> </p></div></div></div>