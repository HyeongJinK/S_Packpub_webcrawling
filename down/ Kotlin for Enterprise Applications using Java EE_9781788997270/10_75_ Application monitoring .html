<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec73"></a>Application monitoring </h2></div></div><hr /></div><p>Monitoring services is a key aspect in <span>keeping</span><a id="id325601660" class="indexterm"></a> track of system resource usage and the application's health. When the service or application is unresponsive or not working as expected, if the system's CPU usage is high or it is taking too long to respond to a request, monitoring helps troubleshoot issues. Application monitoring helps us understand CPU usage and other system resources. The result of the monitoring can be used to make decisions such as scaling services or notifying system administrators so that they can take appropriate actions.</p><p>We will discuss some of the <span>popular</span><a id="id325601662" class="indexterm"></a> monitoring tools to analyze a system's CPU and memory.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec70"></a>Java Mission Control</h3></div></div></div><p><span class="strong"><strong>Java Mission Control</strong></span> (<span class="strong"><strong>JMC</strong></span>) is a tool that is used for <span>monitoring</span><a id="id325442817" class="indexterm"></a> and profiling Java-based applications. We can use JMC for Kotlin applications as well. JMC <span>consists</span><a id="id326367063" class="indexterm"></a> of <span class="strong"><strong>Java Flight Recorder</strong></span> (<span class="strong"><strong>JFR</strong></span>) and the JMX console. JFR is a profiling tool that collects JVM runtime information, whereas the JMX console is a monitoring tool that presents the JVM data about CPU usage, memory, and garbage collection activities.</p><p>Let's explore how to use JMC to perform a recording of the CPU and other resource usage. Then, we will analyze the recorded information for resource utilization.</p><p>Consider the program that was used to <span>illustrate</span><a id="id326366846" class="indexterm"></a> the memory leak. This creates an empty <code class="literal">HashMap</code> with the default initial capacity(16) and then goes on adding key-value pairs to it, and prints a statement to the console to the effect that an element has been added to the map. This is shown with the following code:</p><pre class="programlisting">@JvmStatic
fun main(args: Array&lt;String&gt;) {
try {
val map = HashMap&lt;MemoryLeakDemo, String&gt;()

while (true) {
            map[MemoryLeakDemo("myKey")] = "value"
println("Element added to map")
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
}</pre><p>We need to set the <code class="literal">FlightRecorder</code> flag while starting the application. To do this, we need to set the following VM option:</p><pre class="programlisting">-XX:+UnlockCommercialFeatures -XX:+FlightRecorder</pre><p>The following <span>screenshot</span><a id="id326440164" class="indexterm"></a> is the output of the preceding code:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/09881ad7-384a-431b-af8a-c5cad5a01e4e.png" /></div><p>Start the application and then open the JMC, which is in the <code class="literal">bin</code> directory of the JDK. When it starts up, it looks like this:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/29ac7ad4-d8de-47af-a1df-50d12d850f0b.png" /></div><p>Note that this has already been attached to our Kotlin application. Now, we need to start recording the resource utilization using the <span class="strong"><strong>Flight Recorder</strong></span>. We will <span>record</span><a id="id325818968" class="indexterm"></a> the data for five <span>minutes</span><a id="id325818977" class="indexterm"></a> while the application is running.</p><p>Once it has recorded the events, we can analyze the results as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/031e709f-0c99-4621-91cc-9f2bafa42218.png" /></div><p>As we can see, the flight recorder has captured a lot of details and provided a <span>summary</span><a id="id325819064" class="indexterm"></a> of events. We can see that CPU usage is high; it has reached almost 80%. There is also a <span class="strong"><strong>Heap Usage</strong></span> tab, which <span>shows</span><a id="id325857661" class="indexterm"></a> how much heap memory is consumed. The following screenshot shows this:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/e8ed3e7a-a475-4e4e-8a47-33a49274c5e0.png" /></div><p>There is also a code section, which shows which class in the application has consumed the most memory. This section shows the memory consumption for the different classes in the application. The following screenshot shows this:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/85c96aaa-5ea8-4826-955f-64c69651f727.png" /></div><p>In this case, we can see from the <span>recorded</span><a id="id325858444" class="indexterm"></a> events that we are adding a <code class="literal">HashMap</code>.</p><p>The memory column shows how memory is used, capturing garbage collection information. The following screenshot shows this:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/6b6eabb1-fb28-4c0e-92e7-b5f1679bf062.png" /></div><p>This shows <span class="strong"><strong>GC Times</strong></span>, the <span>application</span><a id="id325858547" class="indexterm"></a> pause time during the GC event, details about the younger generation GC, the older generation GC, the GC count, and so on.</p><p>There is also a <span class="strong"><strong>Threads</strong></span> section, which shows a list of threads <span>running</span><a id="id326025056" class="indexterm"></a> in the application. This shows the thread state and latency in thread executions, stating <span>whether</span><a id="id326025064" class="indexterm"></a> they are running, blocked, waiting, and so on. This is useful when monitoring concurrent applications.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>Until OpenJDK 10, JMC was not part of the OpenJDK. Instead, it was included in the Oracle JDK from version 7u40 and was a commercial tool used for monitoring and profiling Java-based applications. In Oracle JDK 11, JMC is removed and made available as a separate package, which is compatible with both OpenJDK and Oracle JDK. The open-source version was an early access build when this book was being written.</p></div><p>JMX is a powerful tool for monitoring applications. The data captured through this tool gives a lot of detailed information about the system's resource usage.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec71"></a>Java VisualVM</h3></div></div></div><p>Java VisualVM (<code class="literal">jvisualvm</code>) is <span>another</span><a id="id326025091" class="indexterm"></a> tool that can be used for <span>application</span><a id="id326025097" class="indexterm"></a> monitoring. <code class="literal">jvisualvm</code> is useful for debugging memory and performance-related issues. It also provides a graphical representation of the runtime information captured. We already used <code class="literal">jvisualvm</code> to find a memory leak in the application.</p></div></div>