<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec49"></a>Transactions</h2></div></div><hr /></div><p>As you may know, transactions are sets of <span>indivisible</span><a id="id325812936" class="indexterm"></a> operations that either succeed or roll back. Transactions in a messaging system are used to group the messages logically. When we send a group of messages in a transaction to a queue or topic, we either commit them or we roll them back. This means that the messages are either all delivered in one go or they are rolled back. On the consumer or receiver side, the messages are all either consumed and acknowledged or rolled back.</p><p>Let's take a closer look. When messages are sent in a transaction, the messages are not sent to the messaging provider, in our case the GlassFish server queue/topic, until we invoke the <code class="literal">commit()</code> function on the <code class="literal"><span>jmsContext</span></code> as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/5278a1ff-9681-4079-97b8-ba1e0ca95e6a.png" /></div><p>On the consuming side, when transactions are enabled, the messages will be removed from the queue or topic only when they are committed or rolled back. Until the <code class="literal">commit()</code> function is called, the message stays in the messaging provider service. This is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/c85509be-d39f-47e6-8fb8-429bd8411737.png" /></div><p>Let's take a look at some code to understand these concepts further. </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec48"></a>Enabling transactions in the point-to-point messaging model</h3></div></div></div><p>Consider the point-to-point <span>messaging</span><a id="id326159733" class="indexterm"></a> model that we created <span>earlier</span><a id="id326159738" class="indexterm"></a> with the <code class="literal">Message</code> type. We can enable transactions in the <code class="literal">Producer</code> class with <code class="literal">JMSContext.SESSION_TRANSACTED</code> as follows:</p><pre class="programlisting">val jmsContext = connectionFactory
                      .createContext(JMSContext.SESSION_TRANSACTED)</pre><p>Our message <code class="literal">Producer</code> class looks as follows:</p><pre class="programlisting">class Producer {
    @Inject
    private lateinit var initialContext: InitialContext

    fun sendMessage(message: String): String {
        try {
            val queue = initialContext
                             .lookup("jms/PointToPointQueue") as Queue
            val connectionFactory = initialContext
                             .lookup("jms/__defaultConnectionFactory")
                                 as ConnectionFactory
            val jmsContext = connectionFactory                           
                             .createContext(JMSContext.SESSION_TRANSACTED)
            val textMessage = jmsContext.createTextMessage(message)
            jmsContext.createProducer()
                      .send(queue, textMessage)
            return "Message sent"
        } catch (e: NamingException) {
            println("unable to load a resource " + e.message)
            return "Unable to deliver a message"
        }
    }
}</pre><p>Note that we have created the context in transaction mode but we are not committing the message. This means the message has not yet reached the messaging provider, so our <code class="literal">ConsumerTest</code> blocks while waiting for the message.</p><p> </p><p> </p><p>This is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/c681bf78-e3bf-4f7b-aab9-6098d236c91c.png" /></div><p>Let's invoke the <code class="literal">commit()</code> function in the <code class="literal">Producer</code> class, as follows:</p><pre class="programlisting"><span class="strong"><strong> jmsContext.commit()</strong></span></pre><p>The <code class="literal">ConsumerTest</code> class, which was waiting for the message, has now received the message:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/b4dc004f-93ea-42ee-9c8b-e8729d446803.png" /></div><p>We'll also take a look at the <code class="literal">Consumer</code> class:</p><pre class="programlisting">class Consumer {
    @Inject
    private lateinit var initialContext: InitialContext
    fun receiveMessage(): Message {

        val queue = initialContext
                        .lookup("jms/PointToPointQueue") as Queue
        val connectionFactory = initialContext
                        .lookup("jms/__defaultConnectionFactory") as 
         ConnectionFactory
        val jmsContext = connectionFactory
                        .createContext(JMSContext.SESSION_TRANSACTED)
        val textMessage = jmsContext.createConsumer(queue)
                                    .receive()
        return textMessage
}</pre><p> </p><p>Note that we have again <span>created</span><a id="id326101720" class="indexterm"></a> the context with the <span>transaction</span><a id="id326157450" class="indexterm"></a> enabled, and we are not committing the message. This means that we are not acknowledging the messaging provider after processing the message. As a result, the message will continue to exist in the provider. If we run <code class="literal">ConsumerTest</code> again, we continue to get the following result until we acknowledge the message:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/fc5b46f0-c504-436b-98f4-2efbe1a14cd5.png" /></div><p>Let's invoke <code class="literal">commit()</code> after receiving the message:</p><pre class="programlisting">class Consumer {
    @Inject
    private lateinit var initialContext: InitialContext

    fun receiveMessage(): Message {

        val queue = initialContext
                          .lookup("jms/PointToPointQueue") as Queue
        val connectionFactory = initialContext
                          .lookup("jms/__defaultConnectionFactory")
                              as ConnectionFactory
        val jmsContext = connectionFactory     
                          .createContext(JMSContext.SESSION_TRANSACTED)
        val textMessage = jmsContext.createConsumer(queue)
                                    .receive()
        jmsContext.commit()
        return textMessage
    }
}</pre><p> </p><p> </p><p>Run the <code class="literal">ConsumerTest</code> class again and notice that this time, the <code class="literal">commit()</code> function <span>sends</span><a id="id326157497" class="indexterm"></a> an acknowledgement to the provider that the <span>message</span><a id="id326157506" class="indexterm"></a> has been received. Any further calls on <code class="literal">ConsumerTest</code> will block and wait for the message to be produced:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/9a7375f3-4bcc-4ed3-a975-597f658c3a1c.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec49"></a>Enabling transactions in the publish-subscribe messaging model</h3></div></div></div><p>We demonstrated the <span>transactions</span><a id="id326159547" class="indexterm"></a> in the point-to-point <span>messaging</span><a id="id326159556" class="indexterm"></a> model. The same can be enabled in the publish-subscribe model, as shown here:</p><pre class="programlisting">class Publisher {
@Inject
    private lateinit var initialContext: InitialContext

    fun publishMessage(message: String) {
val topic = initialContext
                       .lookup("jms/Topic") as Topic
val connectionFactory = initialContext
                       .lookup("jms/__defaultConnectionFactory")
as ConnectionFactory

val jmsContext = connectionFactory
                          .createContext(JMSContext.SESSION_TRANSACTED)
        jmsContext.createProducer()
                  .send(topic, message)
        jmsContext.commit()
    }
}</pre><p> </p><p> </p><p>The <code class="literal">Subscriber</code> model is as follows:</p><pre class="programlisting">class Subscriber {
@Inject
    private lateinit var initialContext: InitialContext

    @Throws(NamingException::class)
fun listenToMessage(): String? {
val topic = initialContext
                       .lookup("jms/Topic") as Topic
val connectionFactory = initialContext
                       .lookup("jms/__defaultConnectionFactory")
as ConnectionFactory
val jmsContext = connectionFactory
                          .createContext(JMSContext.SESSION_TRANSACTED)
var messageResponse = jmsContext.createConsumer(topic)
                                        .receiveBody(String::class.java)
return messageResponse
    }
}</pre><p>The behavior is the <span>same</span><a id="id326159587" class="indexterm"></a> when we enable the <span>transactions</span><a id="id326159721" class="indexterm"></a> in the publish-subscribe model. Messages are not sent to the provider until the <code class="literal">commit()</code> function is invoked by the producer class and the message stays in the provider until <code class="literal">commit()</code> is called by the consumer class.</p></div></div>