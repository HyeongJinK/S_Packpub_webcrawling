<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec85"></a>Implementing the observer pattern</h2></div></div><hr /></div><p>The observer pattern is yet another <span>design</span><a id="id325860634" class="indexterm"></a> pattern that is widely used when developing applications or software. The observer pattern is useful when one object is dependent on the state of another object. This pattern defines one-to-many dependent models between the objects. Whenever an object changes its state, all the dependent objects are notified of the change and they are all updated with the new state information. Instead of periodically checking to see whether the object has changed, <span>it's better to notify the objects that will take the new state information upon the notification</span>. The object that changes state is called <span class="strong"><strong>State</strong></span> and the other observing objects are <span class="strong"><strong>Dependent</strong></span> objects:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/7cc75461-24e0-43c9-b50a-a1acb41f752b.png" /></div><p>The preceding diagram represents a one-to-many model. With this, the state information is changed in a state object and a notification is then sent to many dependents. The object that changes state might not be aware of the other dependent objects that are monitoring the state change. This pattern allows the notification to be sent to the observing objects when the object changes its state without knowing that the other objects are observing the change.</p><p>The observer pattern can be used when the concerns of one class or the instances are unrelated and/or need to be hidden from the other classes or instances that are monitoring the object for any state changes. In fact, the <span class="emphasis"><em>publisher</em></span> and <span class="emphasis"><em>subscriber</em></span> model that is described in <span>the messaging service chapte</span>r is based on the observer pattern. The <span class="emphasis"><em>publisher</em></span> is the <span class="strong"><strong><span class="emphasis"><em>subject</em></span></strong></span> and the <span class="emphasis"><em>subscriber</em></span> that listens to the messages is the <span class="strong"><strong><span class="emphasis"><em>dependent</em></span></strong></span> object.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec86"></a>Illustrating the observer pattern</h3></div></div></div><p>Let's illustrate the observer pattern <span>through</span><a id="id325860456" class="indexterm"></a> the example of stock market data. Our use case here is that the observers will be registered for specific trades of a company and they will be observing for any changes in the data.</p><p>To design this model, let's write a simple contract. We will begin with the <code class="literal">Subject</code> and <code class="literal">Observer</code> interfaces.</p><p>The <code class="literal">Subject</code> interface has the following three functions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">fun register(observer: Observer)</code></li><li style="list-style-type: disc"><code class="literal">fun remove(observer: Observer)</code></li><li style="list-style-type: disc"><code class="literal">fun notify()</code></li></ul></div><p>The <code class="literal">register()</code> function registers an <code class="literal">Observer</code> for observing the subject. The <code class="literal">remove()</code>  function will then remove dependent objects from observing <code class="literal">Subject</code>. The <code class="literal">notify()</code> function then sends a notification to all registered observers about the state change.</p><p>The <code class="literal">Observer</code> interface has one function:</p><pre class="programlisting">fun update()</pre><p>This function will be invoked by the subject while sending the notification. When this function is invoked, dependent objects will see the updated value for the stock price.</p><p>Let's provide an implementation class for the <code class="literal">Subject</code> interface, as follows:</p><pre class="programlisting">class StockData : Subject {
    internal var observerList: MutableList&lt;Observer&gt; = ArrayList()
    var symbol: String ?= null
    var price: Float? = null

    override fun register(observer: Observer) {
        observerList.add(observer)
    }

    override fun remove(observer: Observer) {
        val i = observerList.indexOf(observer)
        if (i &gt;= 0) {
            observerList.removeAt(i)
        }
        observerList.remove(observer)
    }

    override fun notify() {
        for (i in observerList.indices) {
            observerList[i].update()
        }
    }

    fun setStockData(symbol: String, price: Float?) {
        this.symbol = symbol
        this.price = price
        notifyObservers()
    }
}</pre><p>This <code class="literal">StockData</code> class maintains a list of observers for the stock-data change event. Here, the <code class="literal">register()</code> function adds the observer to the list and the <code class="literal">remove()</code> function takes the observer out of the list. The <code class="literal">notify()</code> function simply invokes <code class="literal">update()</code> on the observers that are registered.</p><p>An implementation of the <code class="literal">Observer</code> interface will have the <span>definition</span><a id="id325813036" class="indexterm"></a> for the <code class="literal">update()</code> function, which updates the required data in the observer.</p><p>We have now described the <span class="emphasis"><em>observer pattern</em></span> and illustrated it using an example. This pattern is useful when we have multiple observers that are monitoring state-information changes.</p></div></div>