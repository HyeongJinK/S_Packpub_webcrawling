<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec25"></a>Overview of Java EE</h2></div></div><hr /></div><p>The Java EE platform was <span>developed</span><a id="id326007340" class="indexterm"></a> through the <span class="strong"><strong>Java Community Process</strong></span> (<span class="strong"><strong>JCP</strong></span>), which is <span>responsible</span><a id="id326128135" class="indexterm"></a> for all Java technologies. JCP has created <span class="strong"><strong>Java Specification Requests</strong></span> (<span class="strong"><strong>JSRs</strong></span>) to describe the <span>various</span><a id="id326128150" class="indexterm"></a> proposed Java EE technologies. Typically, these specifications are implemented by the product vendors (the web-server, application-server, or database-system vendor). These vendors compete to implement the Java EE specifications. The Java Community works under the supervision of the JCP program, and JCP helps to ensure the Java technology's standards, stability, and cross-platform compatibility.</p><p>Java EE was maintained by Oracle under JCP after it took over Java from Sun Microsystems in 2009. On September 12th, 2017, Oracle Corporation announced that it <span>would</span><a id="id326128160" class="indexterm"></a> submit Java EE to the Eclipse Foundation. This Eclipse top-level project was named <span class="strong"><strong>Eclipse Enterprise for Java</strong></span> (<span class="strong"><strong>EE4J</strong></span>). On February 26th, 2018, Eclipse Foundation renamed it Jakarta EE.</p><p>Java EE (Jakarta EE) is a set of specifications that go beyond the Java <span class="strong"><strong>Standard Edition</strong></span> (<span class="strong"><strong>SE</strong></span>), giving us <span>access</span><a id="id326148258" class="indexterm"></a> to distributed computing and web services for enterprise applications. It is designed to create large, distributed, multitiered, secure, transactional, scalable, reliable, and highly-available enterprise applications that are intended to solve critical business problems. The intention of Java EE is to abstract the complex logic for distributed transactional details, leaving the programmer to work on the actual business logic.</p><p>Some of the core <span>technologies</span><a id="id326148267" class="indexterm"></a> of the Java Enterprise Edition include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"> Java Servlets</li><li style="list-style-type: disc"> JSP</li><li style="list-style-type: disc">JDBC</li><li style="list-style-type: disc">JavaMail</li><li style="list-style-type: disc">RMI</li><li style="list-style-type: disc">EJB</li></ul></div><p>Java EE is made up of different frameworks that are used to develop enterprise applications. It provides a simplified programming model to build applications. It has a rapid application development time and is based on a secure and reliable model. It allows us to focus on the business implementation rather than on setting up the system. Let's take a look at some of the benefits of using Java Enterprise Edition as a platform for <span>developing</span><a id="id326148294" class="indexterm"></a> applications:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Dependency injection</strong></span>: Through dependency injection, all the <span>required</span><a id="id326148312" class="indexterm"></a> resources can be injected into the components, thereby separating the resource-creation logic from the application code. This helps to create loosely-coupled applications that are easy to <span>maintain</span><a id="id326148321" class="indexterm"></a>. Java EE has <span class="strong"><strong>Contexts and Dependency Injections</strong></span> (<span class="strong"><strong>CDI</strong></span>) through which the required bean dependencies are injected into the components.</li><li style="list-style-type: disc"><span class="strong"><strong>Configurations</strong></span>: Java EE provides a way to define <span>configurations</span><a id="id326148341" class="indexterm"></a> using annotations. It also allows us to use XML-based configurations. The Server reads all the configurations and binds them to the components during the deployment of the application.</li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>The Java persistence API</strong></span>: Java EE provides an easy <span>way</span><a id="id326148358" class="indexterm"></a> to manage data layers and has a well-defined ORM framework known as <span class="strong"><strong>Java Persistence API</strong></span> (<span class="strong"><strong>JPA</strong></span>). JPA allows us to <span>define</span><a id="id326152916" class="indexterm"></a> entities, mapping them to the database for persistence.</li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Support for web services</strong></span>: Through its rich <span>frameworks</span><a id="id326152933" class="indexterm"></a>, the Java EE platform provides a way to develop web services. Using Java EE, we can create SOAP-based web services and from Java EE 6 onward, we can create Restful Web Services as well.</li></ul></div><p>When we combine Java EE with the Kotlin language, we can write concise and clean code, and we can create enterprise applications quickly and easily.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec28"></a>New features and enhancements in Java EE 8</h3></div></div></div><p>Java EE 8 has improved its APIs and <span>programming</span><a id="id326152950" class="indexterm"></a> models to suit the needs of modern enterprise applications. It provides an infrastructure for microservices and cloud-based environments.</p><p>Java EE 8 has a new security API and a new standardized API for binding JSON to model objects. The Servlet 4.0 API now comes with HTTP/2 support. A new Reactive rest client API and asynchronous API have been introduced in this release of the platform as well.</p><p>Java EE 8's new <span class="strong"><strong>dependency injection</strong></span> (<span class="strong"><strong>DI</strong></span>) feature, along with its <span>improved</span><a id="id326152972" class="indexterm"></a> security and reliability, makes it easier to develop applications.</p><p>Java EE 8 is also now aligned with Java 8, which means that Java 8 features, such as streams, lambda, and the new data-time API, can be used in Java EE 8's APIs as well, and it has enhanced support for these features.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec29"></a>Introduction to the Java EE architecture</h3></div></div></div><p>Modern enterprise <span>applications</span><a id="id326166304" class="indexterm"></a> are often developed using a layered architecture. The most commonly-followed architecture is a three-tiered architecture. In this model, the responsibilities of an application are divided into three layers—view, business logic, and persistence. The view or presentation layer deals with presenting a user interface and is responsible for interacting with the end user and the application. The business layer consists of the core business and the domain logic of the enterprise application. This includes the code that defines the processes to run and deals with how data is created and operated on for the business problem in question. The persistence layer defines how data is stored using a database. This three-tiered architecture is as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/da11af14-e84c-459d-8ec7-0c8e1eedce05.png" /></div><p>Java EE provides services to enterprise <span>applications</span><a id="id326166325" class="indexterm"></a> that are developed <span>using</span><a id="id326166333" class="indexterm"></a> a layered architecture. Servlets, <span class="strong"><strong>Java Server Pages</strong></span> (<span class="strong"><strong>JSP</strong></span>), or <span class="strong"><strong>Java Server Faces</strong></span> (<span class="strong"><strong>JSF</strong></span>) can be used for the presentation layer of the application. Typically, these components are deployed on a web container and the end user interacts with the web container using the web browser. Enterprise Java Beans are used for the business logic of the application and run in an EJB container. The JPA, meanwhile, is used for the persistence layer of the application, which maps between entities and relational database tables. This is depicted in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/314d8899-a6ff-44b7-b345-6fceda506fa0.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note14"></a>Note</h3><p>
A Java EE container offers many other services. These include the <span class="strong"><strong>Java Messaging Service</strong></span> (<span class="strong"><strong>JMS</strong></span>), <span class="strong"><strong>Remote Method Invocation </strong></span>(<span class="strong"><strong>RMI</strong></span>), resource adapters, and web services.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec30"></a>Integrating Kotlin plugins</h3></div></div></div><p>In this section, we will take a look at a <span>couple</span><a id="id326238417" class="indexterm"></a> of plugins that make JavaBeans behave as standard Java classes.</p><p>Kotlin is interoperable with Java. Although a Java class can easily be converted to Kotlin, Kotlin classes are not readily compatible with Java EE. Plugins are available to make them compatible, meaning that we don't have handle this manually in the code.</p><p><span class="strong"><strong>Inversion of Control</strong></span> (<span class="strong"><strong>IoC</strong></span>)-based <span>frameworks</span><a id="id326238437" class="indexterm"></a> load the beans, initialize them with all the required properties, and inject them into the required places. In Java EE, we use the <code class="literal">@Inject</code> annotation to inject the dependencies. In order to mock these beans, dependency injection needs to be reconfigured. The <span>Kotlin</span><a id="id326238961" class="indexterm"></a> compiler has support for different plugins, which simulate the structure and construct the objects that are suitable for the frameworks to use in an application.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec11"></a>The all-open compiler plugin</h4></div></div></div><p>When we define a class or <span>declare</span><a id="id326238976" class="indexterm"></a> a data member, it is final by default in Kotlin. We declare classes as final to make them non-extendable. Similarly, we make functions final so that they can't be overridden. Fields are declared as final to prevent the value from changing once it is initialized.</p><p>The <span class="strong"><strong>Aspect-Oriented Programming</strong></span> (<span class="strong"><strong>AOP</strong></span>) library and the Reflection API require classes to be non-final. These frameworks create proxy objects, so the <span>classes</span><a id="id326238996" class="indexterm"></a> and member <span>variables</span><a id="id326239004" class="indexterm"></a> have to be open and accessible.</p><p>The <span class="emphasis"><em>all-open compiler</em></span> plugin makes sure Kotlin complies with the requirements of these libraries and frameworks when dealing with proxyobjects. It makes classes and member variables that have specific annotations accessible to create proxy objects without explicitly specifying the <code class="literal">open</code> keyword in the code.</p><p>Let's take a look at an example of how we can use an <span class="emphasis"><em>all-open compiler</em></span> plugin. When we are dealing with the CDI framework, we need classes that are annotated with specific annotations, such as <code class="literal">@Inject</code> or <code class="literal">@Dependent</code>, to make them open and accessible. Let's look at the <span class="emphasis"><em>all-open plugin</em></span> support for both Maven and Gradle.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec5"></a>Using the all-open plugin in Maven</h5></div></div></div><p>The <span class="emphasis"><em>all-open plugin</em></span> for Maven can be <span>used</span><a id="id326251848" class="indexterm"></a> as follows:</p><pre class="programlisting">&lt;plugin&gt;
        &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;version&gt;${kotlin.version}&lt;/version&gt;
        &lt;configuration&gt;
            &lt;compilerPlugins&gt;
                &lt;plugin&gt;all-open&lt;/plugin&gt;
            &lt;/compilerPlugins&gt;
            &lt;pluginOptions&gt;
               &lt;option&gt;all-open:all-open:annotation=javax.inject.Inject&lt;/option&gt;
               &lt;option&gt;all-open:annotation=all-open:annotation=javax.ejb.Stateless&lt;/option&gt;
            &lt;/pluginOptions&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
                &lt;artifactId&gt;kotlin-maven-allopen&lt;/artifactId&gt;
                &lt;version&gt;${kotlin.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/plugin&gt;</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec6"></a>Using the all-open plugin in Gradle</h5></div></div></div><p>The <span class="emphasis"><em>all-open plugin</em></span> for Gradle can be <span>used</span><a id="id326251870" class="indexterm"></a> as follows:</p><pre class="programlisting">buildscript {
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-allopen:$kotlin_version"
    }
}
apply plugin: "kotlin-allopen"</pre><p>We have to add the plugin artifact in the <code class="literal">buildscript</code> dependencies section of the Gradle file. We can also enable the <span class="emphasis"><em>all-open plugin </em></span>using the plugins section, as follows:</p><pre class="programlisting">plugins {
   id "org.jetbrains.kotlin.plugin.allopen" version "1.2.41"
 }</pre><p>Following this, we can specify a list of annotations that will make our classes open and accessible:</p><pre class="programlisting">allOpen {
    annotation("javax.ejb.Stateless")
 } </pre><p>We can specify multiple annotations using the <code class="literal">annotations</code> section in the <code class="literal">allOpen</code> plugin:</p><pre class="programlisting"> allOpen {
     annotations("javax.ejb.Stateless",
     "javax.inject.Inject")
 }</pre><p>We can then define custom annotations. The <span class="emphasis"><em>all-open compiler plugin</em></span> is used to open the classes that are annotated with the custom annotations:</p><pre class="programlisting">allOpen {
    annotation("org.rao.kotlin.javaee.Annotation")
}


@org.rao.kolin.javaee.Annotation
annotation class MyAnnotation

@MyAnnotation
class  Person{ }</pre><p>Now, the <code class="literal">Person</code> class will be open.</p><p>The <code class="literal">MyAnnotation</code> class is <span>annotated</span><a id="id326251941" class="indexterm"></a> with a meta-annotation—<code class="literal">@org.rao.kolin.javaee.Annotation</code>. It is now an all-open plugin annotation that can be used in other classes to make them open and accessible.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec12"></a>No-arg compiler plugin</h4></div></div></div><p><span>Constructors are used to initiali</span>ze the <span>states</span><a id="id326302243" class="indexterm"></a> of an object. Sometimes, however, we <span>need</span><a id="id326302251" class="indexterm"></a> to have default constructors that take no arguments. The <span class="emphasis"><em>no-arg compiler plugin</em></span> is used to generate no-arg constructors (the default constructors) for classes that are annotated with aparticular annotation. When we have a <span class="emphasis"><em>no-arg compiler plugin</em></span> enabled, a no-arg constructor is added during compile-time. The generated default constructor can only be invoked by the reflection APIs and are not accessible directly from the Kotlin code. The <span class="emphasis"><em>no-arg compiler plugin enables</em></span> the CDI or the JPA to instantiate the classes, though it doesn't have any default constructors defined in the code. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>In Java, a default constructor will always be added to the compiled code by the compiler and no additional plugin is required to do this. In Kotlin, however, when we have the <span class="emphasis"><em>no-arg compiler plugin</em></span>enabled<span class="emphasis"><em>,</em></span> a default constructor will be added to the compiled code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec7"></a>Using the no-org plugin in Maven</h5></div></div></div><p>Using the <span class="emphasis"><em>no-org compiler</em></span> <span class="emphasis"><em>plugin</em></span> is the <span>same</span><a id="id326302296" class="indexterm"></a> as the <span class="emphasis"><em>all-open</em></span> plugin. The <code class="literal">kotlin-maven-noarg</code> dependency has to be added to the <code class="literal">pom.xml</code> file and we specify the plugin in the plugin section:</p><pre class="programlisting">&lt;plugin&gt;
    &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
    &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${kotlin.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;compile&lt;/id&gt;
            &lt;phase&gt;compile&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;compile&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
        &lt;execution&gt;
            &lt;id&gt;test-compile&lt;/id&gt;
            &lt;phase&gt;test-compile&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;test-compile&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;

&lt;plugin&gt;
    &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
    &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
    &lt;version&gt;${kotlin.version}&lt;/version&gt;

    &lt;configuration&gt;
        &lt;compilerPlugins&gt;
            &lt;plugin&gt;no-arg&lt;/plugin&gt;
        &lt;/compilerPlugins&gt;

        &lt;pluginOptions&gt;
            &lt;option&gt;no-arg:annotation=org.rao.kotlin.javaee.MyClass&lt;/option&gt;
&lt;!-- &lt;option&gt;no-arg:invokeInitializers=true&lt;/option&gt; --&gt;
&lt;/pluginOptions&gt;
    &lt;/configuration&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
            &lt;artifactId&gt;kotlin-maven-noarg&lt;/artifactId&gt;
            &lt;version&gt;${kotlin.version}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec8"></a>Using the no-org plugin in Gradle</h5></div></div></div><p>Add the plugin in the <code class="literal">buildscript</code> dependencies <span>section</span><a id="id326309362" class="indexterm"></a> in the Gradle file:</p><pre class="programlisting">buildscript {
    dependencies {
    classpath "org.jetbrains.kotlin:kotlin-noarg:$kotlin_version"
      }
 }

 apply plugin: "kotlin-noarg"</pre><p>Alternatively, we can enable the <span class="emphasis"><em>no-arg plugin</em></span> using Gradle as follows:</p><pre class="programlisting">plugins {
   id "org.jetbrains.kotlin.plugin.noarg" version "1.2.41"
}</pre><p>We can then specify the list of annotations in the plugin section. The <span class="emphasis"><em>no-arg plugin</em></span> generates the default constructor for the classes that are annotated with the annotations that we specified in the <code class="literal">noArg</code> annotation section of the plugin:</p><pre class="programlisting">noArg {
   annotation("org.rao.kotlin.javaee.MyClass")
 }</pre><p>If we want to execute the initialization of member variables from the default constructor, we can use the <code class="literal">invokeInitializers</code> plugin option:</p><pre class="programlisting">noArg {
invokeInitializers = true
}</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec13"></a>The kotlin-spring compiler plugin</h4></div></div></div><p>The <span class="emphasis"><em>kotlin-spring compiler plugin </em></span>is a <span>wrapper</span><a id="id326309419" class="indexterm"></a> on top of the <span class="emphasis"><em>all-open</em></span> <span class="emphasis"><em>compiler plugin.</em></span> This <span>plugin</span><a id="id326309434" class="indexterm"></a> is used for Spring-based applications.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec9"></a>Using the kotlin-spring plugin in Maven</h5></div></div></div><p>In Maven, we can <span>enable</span><a id="id326309450" class="indexterm"></a> the <span class="emphasis"><em>kotlin-spring compiler plugin</em></span> as follows:</p><pre class="programlisting">&lt;compilerPlugins&gt;
     &lt;plugin&gt;spring&lt;/plugin&gt;
&lt;/compilerPlugins&gt;</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec10"></a>Using the kotlin-spring plugin in Gradle</h5></div></div></div><p>In Gradle, the <span class="emphasis"><em>kotlin-spring compiler plugin</em></span> can be <span>enabled</span><a id="id326309479" class="indexterm"></a><span class="emphasis"><em> </em></span>by using <code class="literal">buildscript</code> with the <code class="literal">allopen</code> artifact, as shown here:</p><pre class="programlisting">buildscript {
   dependencies {
   classpath "org.jetbrains.kotlin:kotlin-allopen:$kotlin_version"
   }
 }
 apply plugin: "kotlin-spring"</pre><p>Alternatively, the plugin can be enabled using plugins as follows:</p><pre class="programlisting">plugins {
   id "org.jetbrains.kotlin.plugin.spring" version "1.2.41"
 }</pre><p>This plugin specifies the following annotations:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">@Component</code></li><li style="list-style-type: disc"><code class="literal">@Transactional</code></li><li style="list-style-type: disc"><code class="literal">@Async</code></li><li style="list-style-type: disc"><code class="literal">@Cacheable</code></li><li style="list-style-type: disc"><code class="literal">@SpringBootTest</code></li></ul></div><p>The classes that are annotated with these annotations are made open and accessible to the Spring framework so that we can create proxy objects. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec11"></a>Using the kotlin-spring plugin in CLI</h5></div></div></div><p>The <span class="emphasis"><em>all-open co</em></span><span class="emphasis"><em>mpiler plugin</em></span> is a JAR file that <span>comes</span><a id="id326330786" class="indexterm"></a> with the Kotlin compiler. In order to use the <span class="emphasis"><em>all-open plugin, </em></span>we need to provide the path to the jar file using the <code class="literal">-Xplugin</code> option:</p><p><code class="literal">-Xplugin=$KOTLIN_HOME/lib/allopen-compiler-plugin.jar</code></p><p>We can specify the <span class="emphasis"><em>all-open</em></span> annotations either with the annotation plugin option, or by enabling the preset. <span class="emphasis"><em>Spring</em></span> is the only preset that is currently available for the <span class="emphasis"><em>all-open plugin</em></span>.</p><p>The plugin option format is as follows:</p><p> <code class="literal">-P plugin:&lt;plugin id&gt;:&lt;key&gt;=&lt;value&gt;</code></p><pre class="programlisting">-P plugin:org.jetbrains.kotlin.allopen:annotation=org.rao.kotlin.javaee.MyClass
-P plugin:org.jetbrains.kotlin.allopen:preset=spring</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec14"></a>JPA plugin</h4></div></div></div><p>The <span class="emphasis"><em>kotlin-jpa plugin</em></span> is a <span>wrapper</span><a id="id326330838" class="indexterm"></a> on top of the <span class="emphasis"><em>no-arg compiler plugin</em></span>. This plugin specifies the <code class="literal">@Entity</code>, <code class="literal">@Embeddable</code>, and <code class="literal">@MappedSuperclass</code> annotations. We need to add this <span>plugin</span><a id="id326347688" class="indexterm"></a> in the plugin section of the Maven or Gradle file.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec12"></a>Using the kotlin-jpa plugin in Maven</h5></div></div></div><p>In Maven, we can <span>enable</span><a id="id326347707" class="indexterm"></a> the <span class="emphasis"><em>kotlin-jpa plugin</em></span> as follows:</p><pre class="programlisting">&lt;compilerPlugins&gt;
    &lt;plugin&gt;jpa&lt;/plugin&gt;
&lt;/compilerPlugins&gt;</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec13"></a>Using the kotlin-jpa plugin in Gradle</h5></div></div></div><p>In Gradle, we can <span>enable</span><a id="id326347732" class="indexterm"></a> the <span class="emphasis"><em>kotlin-jpa plugin</em></span> using <code class="literal">buildscript</code> with the kotlin-noarg artifact, as follows:</p><pre class="programlisting">buildscript {
    dependencies {
    classpath "org.jetbrains.kotlin:kotlin-noarg:$kotlin_version"
    }
 }
apply plugin: "kotlin-jpa"</pre><p>Alternatively, we can use the Gradle plugins section to enable the <span class="emphasis"><em>kotlin-jpa compiler plugin, </em></span>as follows:</p><pre class="programlisting">plugins {
   id "org.jetbrains.kotlin.plugin.jpa" version "1.2.41"
 }</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec14"></a>Using the kotlin-jpa plugin in CLI</h5></div></div></div><p>We can use the -Xplugin option to <span>enable</span><a id="id326348181" class="indexterm"></a> the <span class="emphasis"><em>kotlin-jpa plugin </em></span>in <span>order</span> to use the JPA plugin in the command line. This is shown in the following snippet:</p><pre class="programlisting">-Xplugin=$KOTLIN_HOME/lib/noarg-compiler-plugin.jar
 -P plugin:org.jetbrains.kotlin.noarg:annotation=org.rao.kotlin.javaee.MyClass
 -P plugin:org.jetbrains.kotlin.noarg:preset=jpa</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec15"></a>The SAM-with-receiver compiler plugin</h4></div></div></div><p>Java 8 introduced lambda expressions, which are <span>geared</span><a id="id326348210" class="indexterm"></a> toward the functional programming paradigm. With lambda expressions, we can write higher-order functions, which <span>means</span><a id="id326369758" class="indexterm"></a> we can pass a function to another function. Lambda expressions can be applied to interfaces with a single abstract method, which are known as SAM interfaces. </p><p>Before Java 8, when we wanted to use the SAM interface or the functional interface, we had to write an anonymous inner class, which requires a lot of verbose code. For example, let's write a SAM interface:</p><pre class="programlisting">@FunctionalInterface
interface Greet {
fun hello(str: String): String

}</pre><p>To use the interface type as a method argument, we need to use the anonymous inner class, as shown here:</p><pre class="programlisting">var Greeter = str :Greet
{
override
    fun hello(name: String): String {
return "hello $name"
}
}</pre><p>In functional programming, however, this can be written as follows with the Kotlin SAM conversion:</p><pre class="programlisting">var Greeter = Greet { name - &gt; "hello $name" }</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec15"></a>Using the SAM-with-receiver plugin in Maven</h5></div></div></div><p>In Maven, we can <span>enable</span><a id="id326369793" class="indexterm"></a> sam-with-receiver as follows:</p><pre class="programlisting">&lt;plugin&gt;
   &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
   &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
   &lt;version&gt;${kotlin.version}&lt;/version&gt;
   &lt;configuration&gt;
      &lt;compilerPlugins&gt;
         &lt;plugin&gt;sam-with-receiver&lt;/plugin&gt;
      &lt;/compilerPlugins&gt;
      &lt;pluginOptions&gt;
         &lt;option&gt;sam-with-receiver:annotation=com.my.SamWithReceiver&lt;/option&gt;
      &lt;/pluginOptions&gt;
   &lt;/configuration&gt;
   &lt;dependencies&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
         &lt;artifactId&gt;kotlin-maven-sam-with-receiver&lt;/artifactId&gt;
         &lt;version&gt;${kotlin.version}&lt;/version&gt;
      &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/plugin&gt;
</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec16"></a>Using the SAM-with-receiver plugin in Gradle</h5></div></div></div><p>In Gradle, we can <span>enable</span><a id="id326369812" class="indexterm"></a> the <span class="emphasis"><em>kotlin-sam-with-receiver plugin</em></span> using <code class="literal">buildscript</code> with the <code class="literal">kotlin-noorg</code> artifact, as follows:</p><pre class="programlisting">buildscript {
    dependencies {
      classpath "org.jetbrains.kotlin:kotlin-sam-with-receiver:$kotlin_version"
    }
 }

apply plugin: "kotlin-sam-with-receiver"</pre><p>We can then specify the annotations that apply to the classes that are annotated with this list of meta-annotations to enable the plugin:</p><pre class="programlisting">samWithReceiver {
      annotation("org.rao.kotlin.javaee.MySamInterface")
 }</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Note</h3><p>The kotlin-sam-with-receiver compiler plugin doesn't have any built-in annotations. We need to specify a list of custom annotations to effectively apply the plugin.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec17"></a>Using the SAM-with-receiver plugin in CLI</h5></div></div></div><p>We can use the <span class="emphasis"><em>Xplugin</em></span> option to<span>enable</span><a id="id326369995" class="indexterm"></a> the <span class="emphasis"><em>kotlin-sam-with-receiver plugin</em></span>. We need to point to the sam-with-receiver-compiler-plugin jar that is available in the Kotlin compiler distribution. We can then specify a list of custom annotations as follows:</p><pre class="programlisting">-Xplugin=$KOTLIN_HOME/lib/sam-with-receiver-compiler-plugin.jar
-P plugin:org.jetbrains.kotlin.samWithReceiver:annotation=org.rao.kotlin.MySamInterface</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec16"></a>The Jackson plugin</h4></div></div></div><p>The Jackson plugin is not <span>available</span><a id="id326370019" class="indexterm"></a> with the Kotlin compiler distribution, but it is available as part of the Jackson module. It provides an automatic binding between the parsed JSON data and the constructor arguments of a class. All Kotlin types are supported. We need to specify <code class="literal">JsonProperty</code> on the constructor <span>arguments</span><a id="id326408944" class="indexterm"></a> in order to bind the JSON data.</p><p>This plugin is useful for mapping JSON data to the members of a class:</p><pre class="programlisting">data class Person(
    @param:JsonProperty("firstName") override val firstName: String,
    @param:JsonProperty("lastName") override val lastName: String
 ) : Person</pre><p>Bytecode prior to Java 8 did not contain names for the arguments of the constructor. Frameworks cannot bind the data to the constructor arguments automatically.</p><p>The Kotlin compiler and the Java 8 compiler add more metadata to the bytecode during compilation. This metadata can be used by frameworks to carry out the required binding of the data after parsing the JSON. In order to automatically map this data to the constructor, we can rewrite the preceding code as follows:</p><pre class="programlisting">data class Person(
    override val firstName: String,
    override val lastName: String
 ) : Person</pre><p>In order to bind the parsed JSON data to the constructor arguments and to enable the Jackson plugin, we need to add the <code class="literal">jackson-module-kotlin</code> and <code class="literal">kotlin-reflect</code> dependencies. We also need to enable the Kotlin module in the <code class="literal">Application.kt</code> file.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec18"></a>Using the Jackson plugin in Maven</h5></div></div></div><p>In Maven, we add the <span>following</span><a id="id326408990" class="indexterm"></a> <span>dependencies</span>: </p><pre class="programlisting">&lt;dependencies&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;
   &lt;artifactId&gt;jackson-module-kotlin&lt;/artifactId&gt;
   &lt;version&gt;${jackson_version}&lt;/version&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
   &lt;artifactId&gt;kotlin-reflect&lt;/artifactId&gt;
   &lt;version&gt;${kotlin_version}&lt;/version&gt;
 &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec19"></a>Using the Jackson plugin in Gradle</h5></div></div></div><p>In Gradle, we add the <span>following</span><a id="id326409357" class="indexterm"></a> dependencies: </p><pre class="programlisting">dependencies {
   compile("com.fasterxml.jackson.module:jackson-module-kotlin:$jackson_version")
   compile("org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"
 }</pre><p>Enable the Kotlin module in the <code class="literal">Application.kt</code> file:</p><pre class="programlisting">@ApplicationPath("home")
class Application :MyApp(){
    private val classes = setOf(PersonService: :class.java)
    private val singletons = setOf(ContextResolver())
        override fun getClasses() = classes
        override fun getSingletons() = singletons
}

class ContextResolver :ContextResolver&lt;ObjectMapper&gt; {
    val objectMapper = ObjectMapper()
       init{
         objectMapper.registerModule(KotlinModule())
       }
       override fun getContext(p0:Class&lt;*&gt;?) = objectMapper
 }</pre><p>The frameworks and their configurations offer loose coupling, dependency injections, and so on. We can use Kotlin compiler plugins to take advantage of the benefits that these frameworks provide. This reduces the number of classes that have to be modified.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec31"></a>Kotlin and Servlets</h3></div></div></div><p>Java EE is an extension of the Java SE and is <span>used</span><a id="id326409389" class="indexterm"></a> for creating web applications, RESTful  web services, and microservices.</p><p>In this section, we will discuss how to create a web application with HTTP servlets. A servlet is a server-side Java program. Java EE HTTP servlets can be used in Kotlin much like any other Java library or framework. We will create a controller to respond to this request using <code class="literal">HttpServlet</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec17"></a>Kotlin for server-side development</h4></div></div></div><p>Kotlin is a feature-packed language that is great for developing server-side applications, as it allows us to write code in a very concise and expressive manner while <span>maintaining</span><a id="id326409410" class="indexterm"></a> full compatibility with existing Java-based technology stacks. Using Kotlin to develop components on the server side has the following benefits:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Less time to develop</strong></span>: With its elegant syntax andnew features, such as its support for the functional programming paradigm and type inference, the Kotlin language helps to build more expressive and concise code, which makes developing applications easier</li><li style="list-style-type: disc"><span class="strong"><strong>Interoperability</strong></span>:<span class="strong"><strong> </strong></span>Kotlin is 100% compatible with all Java-based frameworks, which lets us stay in the same technology stack and make the most of the benefits offered by the modern JVM-based language</li><li style="list-style-type: disc"><span class="strong"><strong>Scalability</strong></span>: Kotlin's coroutines feature helps us to build server-side applications that can scale to a massive number of clients with minimal hardware requirements</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec18"></a>Servlets</h4></div></div></div><p><span class="strong"><strong> </strong></span>Servlets are the core of web-application development. A servlet is a Java program that runs on the server side, either on a web server or an application server. <span>Servlets</span><a id="id326418124" class="indexterm"></a> acts as a middle layer between an HTTP server and a web client, typically a web browser. The client can either be an HTTP client or a service that runs on an HTTP server. The servlet technology is the underlying technology behind JSP, which is used to create UI pages using HTML. JSP is compiled to a servlet. When a request is made by a web client, the servlet container loads the servlet. The servlet accepts the request, processes it, and returns the response to the servlet container. The servlet container in turn sends the response to the web client that issued the request. The servlet remains in memory to serve subsequent requests and the servlet gets removed from the container when it is no longer needed or the servlet container restarts.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec20"></a>The life cycle of a servlet</h5></div></div></div><p>A servlet's life cycle has <span>three</span><a id="id326418139" class="indexterm"></a> phases. These are depicted in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/9f9435e9-73cf-4294-8d47-9a9e0937db3d.png" /></div><p>                </p><p>Let's look at each phase of the servlet life cycle:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Initialization</strong></span>: The <span>first</span><a id="id326419605" class="indexterm"></a> phase in the Servlet's life cycle is initialization. In this phase, the resources that a servlet needs to serve the request are created and initialized. The Servlet classes implement the contract of the <code class="literal">javax.servlet.Servlet</code> interface, and the <code class="literal">javax.servlet.Servlet</code> interface declares the <code class="literal">init()</code> method that represents the initialization. When the servlet is loaded by the container, it invokes the <code class="literal">init()</code> method to create and initialize the resources. This <code class="literal">init()</code> method is invoked only once during the servlet's life cycle after the servlet has been loaded into the container.
</li><li style="list-style-type: disc"><span class="strong"><strong>Service</strong></span>: The service <span>phase</span><a id="id326419636" class="indexterm"></a> in the servlet's life cycle represents the interaction between the servlet and the client. Whenever the server receives a request from the client for a servlet, it creates a new servlet and invokes the <code class="literal">service()</code> method. The Servlet interface declares the <code class="literal">service()</code> method, which takes the request (<code class="literal">ServletRequest</code>) and response (<code class="literal">ServletResponse</code>) objects. The <code class="literal">ServletRequest</code> object represents a client's request for a dynamic resource, and the <code class="literal">ServletResponse</code> object represents the servlet's response to the client. The <code class="literal">service()</code> method implementation checks for the HTTP request type, which could be something such as <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, or <code class="literal">DELETE</code>, and invokes an appropriate method, such as <code class="literal">doGet()</code>, <code class="literal">doPost()</code>, <code class="literal">doPut()</code>, or <code class="literal">doDelete()</code>.</li><li style="list-style-type: disc"><span class="strong"><strong>Destruction</strong></span>: Destruction is the last <span>phase</span><a id="id326419699" class="indexterm"></a> in the servlet's life cycle. In the servlet's destruction phase, it gets removed from the container that it was loaded by during its initialization phase. The <code class="literal">Servlet</code> interface declares the <code class="literal">destroy()</code> method and the container invokes this method just before the servlet gets removed from the container. This allows the servlet to clean up resources and gracefully terminate them.</li></ul></div><p>To summarize, once a servlet has been loaded into the container, it creates and initializes resources in its initialization phase. In its service phase, it serves a request from the client; in its destruction phase, however the resources gets cleaned up and the servlet get removed from the container.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec19"></a>Creating a simple servlet application</h4></div></div></div><p>Let's take a look at how to create a simple servlet application <span>using</span><a id="id326419722" class="indexterm"></a> Maven and the Kotlin runtime. Follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li> Click on <strong class="userinput"><code>File</code></strong> | <strong class="userinput"><code>New</code></strong> | <strong class="userinput"><code>Project.</code></strong></li><li>In the <strong class="userinput"><code>New Project</code></strong> window, select <strong class="userinput"><code>Maven</code></strong> and enable <strong class="userinput"><code>Create from archetype.</code></strong></li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Select <strong class="userinput"><code>org.apache.maven.archetypes:maven-archetype-webapp</code></strong> as the archetype and click on <strong class="userinput"><code>Next</code></strong>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/d9a0538c-15a7-4ca7-9349-b1298d3a9894.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Enter the <strong class="userinput"><code>GroupId</code></strong>, <strong class="userinput"><code>ArtifactId</code></strong>, and <strong class="userinput"><code>Version</code></strong> for the Maven project and click on <strong class="userinput"><code>Next.</code></strong></li><li>Verify the project's name and click on <strong class="userinput"><code>Finish. </code></strong>This has <span>created</span><a id="id326441959" class="indexterm"></a> a maven web app project with the following structure:
</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/b9586d5f-0b6c-408b-8f09-ed1f50b72d91.png" /></div><p>Let's write a simple login form and a welcome page.</p><p>We need to include the following dependencies so that we can use HTTP servlets in a Kotlin runtime environment:</p><pre class="programlisting">&lt;dependency&gt;
   &lt;groupId&gt;javax&lt;/groupId&gt;
   &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
   &lt;version&gt;${javax.javaee-api.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
   &lt;artifactId&gt;kotlin-runtime&lt;/artifactId&gt;
   &lt;version&gt;${org.jetbrains.kotlin.kotlin-runtime}&lt;/version&gt;
&lt;/dependency&gt;</pre><p>We will be creating a WAR file that we specify via <span>packaging</span><a id="id326441990" class="indexterm"></a> properties. Now that we have added the required dependencies to create a servlet app, let's add a controller that receives a request and serves the response:</p><pre class="programlisting">@WebServlet(name="home",value="/home")
Class HomeController:HttpServlet(){
Override fun doPost(request:HttpServletRequest,response:HttpServletResponse){
        response.writer.write("&lt;html&gt;&lt;body&gt;&lt;h2&gt;Welcome${request.getParameter("loginId")}&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;")
    }
}</pre><p>Build the application in the terminal using the <code class="literal">mvn clean install</code> command. To deploy it, configure Tomcat in the IDE and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Go to <strong class="userinput"><code>Edit configuration</code></strong> and select any web server. We use Tomcat here for demonstration purposes.</li><li>Click on Configure and select Tomcat Directory.</li><li>Click on <strong class="userinput"><code>Deployment</code></strong>, select the artifact, and click on the <strong class="userinput"><code>OK</code></strong> button:</li></ol></div><div class="mediaobject"><img src="/graphics/9781788997270/graphics/e7c7116a-2d7c-4ec7-900e-608509d7d733.png" /></div><p>Now that we are using the run configuration, deploy the <span>application</span><a id="id326442041" class="indexterm"></a> and enter <code class="literal">http://localhost:8080/</code> in the browser.</p><p>We will then see the index page that we defined, which has a login form. Enter the details and hit <code class="literal">Login</code>:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/984d2b4e-f36b-4ec6-b3cf-7da83265fc42.png" /></div><p>This takes us to the following screen:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/2b576587-e398-4dec-8262-6bd01da77675.png" /></div><p>In this example, we created a simple servlet <span>application</span><a id="id326442080" class="indexterm"></a> that responds to a login request. We used the Kotlin runtime and the controller logic that we wrote in Kotlin.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip17"></a>Note</h3><p>JSPs cannot contain scriptlets written in Kotlin. They can, however, contain scriptlets written in Java, and scriptlets written in Java can easily call Kotlin classes because of Kotlin's interoperability with Java.
JSP's <span class="strong"><strong>Expression Language</strong></span> (<span class="strong"><strong>EL</strong></span>) expressions can refer to DTOs written in Kotlin.</p></div><p>In this section, we learned the role of a servlet in a web application, and we created and deployed a servlet to respond to a request from a web client using Kotlin.</p><p>In the next section, we will discuss the Enterprise JavaBean.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec32"></a>Kotlin and EJB</h3></div></div></div><p>As we discussed <span>earlier</span>, Kotlin is fully <span>interoperable</span><a id="id326536227" class="indexterm"></a> with Java. It can be <span>used</span><a id="id326536235" class="indexterm"></a> with any Java-based framework; one such technology that Kotlin can work with is <span class="strong"><strong>Enterprise Java Beans</strong></span> (<span class="strong"><strong>EJBs</strong></span>).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec20"></a>An overview of EJBs</h4></div></div></div><p>An application or a service <span>comprises</span><a id="id326536259" class="indexterm"></a> different components that interact with each other. Each component implements a contract defined by the interfaces to achieve a functionality. These components exist in the runtime environment of the system and use the services in the system environment.</p><p>An enterprise bean is a server-side component. These beans implement the business logic of an enterprise application and comply with the rules of the EJB architecture. These beans live in an EJB container and the EJB container provides different services to them.</p><p>The purpose of EJBs is to provide a framework for the components of the service or an application that may be plugged into a server, thereby extending that server's functionality. EJBs provide an architecture to develop and deploy component-based enterprise applications with a high level of scalability, good performance, and robustness.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec21"></a>Advantages of EJBs</h4></div></div></div><p>The <span>advantages</span><a id="id326536280" class="indexterm"></a> of EJBs are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">EJBs make it easier to develop large, distributed enterprise applications.The EJB container offers services to EJBs that include security, logging, and transactional aspects. The container is also responsible for managing the life cycle of the beans. </li><li style="list-style-type: disc">The EJBs are portable application components that contain business logic.
</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl4sec21"></a>The EJB component model</h5></div></div></div><p>As a <span>component</span><a id="id326536306" class="indexterm"></a> model, EJB <span>defines</span><a id="id326536314" class="indexterm"></a> three bean types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Sess</strong></span><span class="strong"><strong>ion Bean</strong></span>: The session bean <span>stores</span><a id="id326563916" class="indexterm"></a> the data of a particular user's session. The lifetime of a session bean is limited to the duration of the interaction between the <span>client</span><a id="id326563925" class="indexterm"></a> and the bean. The client normally creates a session bean and invokes the functions. The EJB container removes the bean when it is no longer required. Session beans can be further classified into the following three types:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Stateless Bean</strong></span>: The state <span>information</span><a id="id326563943" class="indexterm"></a> between the client and bean is not maintained in a stateless bean. When a function of a stateless bean is invoked by a client, the instance variables of the beans may have some client-specific state information. This information exists only during the invocation of that function. When the function finishes its execution, the client-specific state will not be saved. A stateless session bean is shared between the different clients.</li><li style="list-style-type: disc"><span class="strong"><strong>Stateful Bean</strong></span>: The EJB container maintains the state <span>information</span><a id="id326563958" class="indexterm"></a> of the bean and the client in a stateful bean. A stateful session bean is created only for a specific client and it is not shared among the clients.<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Singleton Bean</strong></span>: A singleton bean is <span>instantiated</span><a id="id326585174" class="indexterm"></a> only once in the application and exists throughout its life cycle. A singleton bean is shared among the different clients and can be accessed simultaneously. Singleton beans are instantiated during the start of the application and are removed before the application goes down. Singleton classes are suitable for cases in which we need to initialize or clean up resources at an application level.</li></ul></div></li></ul></div></li><li style="list-style-type: disc"><span class="strong"><strong>Entity Bean</strong></span>: Entity beans <span>store</span><a id="id326585188" class="indexterm"></a> the data in a data store, which is <span>usually</span><a id="id326585196" class="indexterm"></a> a relational database. Entity beans are often referred to as data-persistent units as they store the data that they carry. Entity beans have attributes and functions. Attributes are used to store data in a secondary store and functions perform operations on them. Entity beans are always shared among the clients. The EJB specifications define two entity bean models:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Bean-managed Persistence</strong></span>: In this model, a bean is <span>responsible</span><a id="id326585214" class="indexterm"></a> for managing the data persistence of the bean's state information. When creating the bean, we must implement details such as connecting to a database and interacting with the database to store the information.
</li><li style="list-style-type: disc"><span class="strong"><strong>Container-managed Persistence</strong></span>: In this model, the EJB <span>container</span><a id="id326585229" class="indexterm"></a> manages the data-persistence aspects. The container is responsible for connecting to the database and storing state interaction between the client and the bean in the database.</li></ul></div></li><li style="list-style-type: disc"><span class="strong"><strong>Message-driven Bean</strong></span>: A message-driven bean <span>listens</span><a id="id325929953" class="indexterm"></a> to messages that flow in an asynchronous fashion. When an EJB-based application needs to <span>receive</span><a id="id325929961" class="indexterm"></a> messages asynchronously from other systems, we can use message-driven beans. These message-driven beans are activated by the container when a message is received and it is not directly accessible to the clients. The clients subscribe to a topic or to a queue and interact with these EJBs by sending messages to the queues or topics.</li></ul></div><p>Let's enhance the project that we created using servlets to include a stateless bean that will have business logic. We will write a stateless bean that accepts a name and returns a greeting message:</p><pre class="programlisting">@Stateless
open class StatelessEjb {
     fun hello(name:String):String{
return"Hello $name"
}
}</pre><p>Let's modify <code class="literal">AuthController</code> to make it use the stateless bean that we created:</p><pre class="programlisting">@WebServlet(name = "home", value = "/home")
class HomeController: HttpServlet() {
private var statelessEjb: StatelessEjb = StatelessEjb()
   override fun doPost(request: HttpServletRequest, response: HttpServletResponse) {
     statelessEjb.hello(request.getParameter("loginId"))
       response.writer.write("&lt;html&gt;&lt;body&gt;&lt;h2&gt;${statelessEjb.hello(request.getParameter("loginId"))}&lt;/h2&gt;          &lt;/body&gt;&lt;/html&gt;")
   }
}</pre><p>Deploy the WAR file and enter <span>the</span> details:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/b7574702-99e9-4e29-8a20-4d7592915cb8.png" /></div><p>The <span>output</span><a id="id325930004" class="indexterm"></a> we get is as follows:</p><div class="mediaobject"><img src="/graphics/9781788997270/graphics/e2972c83-7336-499a-bf7d-30284219a5fa.png" /></div><p>Here, we used a stateless EJB to display a <span>greeting</span><a id="id326068232" class="indexterm"></a> message in the controller.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec22"></a>Bean validation</h4></div></div></div><p>Data validation is very <span>important</span><a id="id326068247" class="indexterm"></a> in enterprise <span>applications</span><a id="id326068256" class="indexterm"></a> to ensure data integrity. It allows us to check for possible data manipulation between the request made by the user and that received on the server side.</p><p>Let's take a look at an example of validating a Bean and writing a unit test to verify it. First, create a maven project:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li> Create a bean named <code class="literal">Person</code> that takes <code class="literal">name</code>, <code class="literal">emailId</code>, and <code class="literal">preferredLanguage</code> in its constructor. This is shown in the following code:</li></ol></div><pre class="programlisting">class Person(@field:NotBlank private val name:String,
@field:Email private val emailId:String,
@field:NotNull private val preferredLanguage:String)</pre><p>Let's analyze what we have written for the <code class="literal">Person</code> bean. Take a look at how simple this class is.  All we have is a <code class="literal">Person</code> class with a constructor that takes <code class="literal">name</code>, <code class="literal">emailId</code>, and <code class="literal">preferredLanguage</code> as parameters to initialize the class. We used three annotations from the <code class="literal">javax(javaee-api)</code> library: <code class="literal">@Email</code>, <code class="literal">@NotBlank</code>, and <code class="literal">@NonNull</code>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">@Email</code> annotation ensures the <code class="literal">emailId</code> field accepts a String in the proper <code class="literal">emailId</code> format.</li><li style="list-style-type: disc">The <code class="literal">@NotBlank</code> annotation ensures the field name accepts a non-null value or a String that is not empty.</li><li style="list-style-type: disc">The <code class="literal">@NotNull</code> annotation ensures the <code class="literal">preferredLanguage</code> field accepts a non-null value.</li></ul></div></li></ul></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Write a Junit test to verify this, as follows:</li></ol></div><pre class="programlisting">class PersonTest {

@Test
    fun validUser() {
val person = Person(
"Raghavendra Rao",
"kraghavendrarao1@gmail.com",
"en-us")

val validationErrors = PersonTest.validator
.validate(person)
        Assert.assertTrue(validationErrors.isEmpty())
    }

@Test
    fun invalidName() {
val person = Person(
"",
"kraghavendrarao1@gmail.com",
"en-us")

val validationErrors = PersonTest.validator
.validate(person)
        Assert.assertEquals(1, validationErrors.size.toLong())
    }

@Test
    fun invalidEmailId() {
val person = Person(
"Raghavendra Rao",
"kraghavendrarao1",
"en-us")

val validationErrors = PersonTest.validator
.validate(person)
        Assert.assertEquals(1, validationErrors.size.toLong())
    }

companion object {
private val validator: Validator = Validation.buildDefaultValidatorFactory()
                                                     .validator
}
}</pre><p><code class="literal">PersonTest.kt</code> is a simple Junit test class to verify the data-validation <span>constraints</span><a id="id326370081" class="indexterm"></a> defined in the Person bean class.</p><p>We are using a <code class="literal">Validator</code> class to validate the Person bean. The <code class="literal">PersonTest.kt</code> test class initializes the Person object and it verifies that the properties of the <code class="literal">Person.kt</code> class are valid.</p><p>In this section, we learned how to carry out bean validation using the <code class="literal">javaee-api</code> library. We also wrote a unit test to verify the data.</p></div></div></div>