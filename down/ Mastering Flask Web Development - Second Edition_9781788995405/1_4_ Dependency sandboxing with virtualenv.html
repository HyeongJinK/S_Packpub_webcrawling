<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec12"></a>Dependency sandboxing with virtualenv</h2></div></div><hr /></div><p>So you have installed all the packages that you <span>want</span><a id="id325375190" class="indexterm"></a> for your new project. Great! But what happens when we develop a second project some time later that will use newer versions of the same packages? And what happens when a library that you wish to use depends on a library that you installed for the first project, but which uses an older version of these packages? When newer versions of packages contain breaking changes, upgrading them would require extra development work on an older project that you may not be able to afford. So in our system, we could have clashing Python packages between projects.</p><p>We should also consider automated build environments, such as <span class="strong"><strong>Jenkins</strong></span>, where we <span>want</span><a id="id325375205" class="indexterm"></a> to run tests. These builds may run on the same system on which other projects are being built, so it's essential that <span>during</span><a id="id325376881" class="indexterm"></a> the build jobs we create a contained Python package environment that is not shared between jobs. This environment is created from the information in the<code class="literal">requirements.txt</code> file that we created earlier. This way, multiple Python applications can be built and tested on the same system without clashing with each other.</p><p>Thankfully, there is <span class="strong"><strong>virtualenv</strong></span>, a tool that sandboxes your Python projects. The secret to virtualenv is in tricking your computer to look for and install packages in the project directory rather than in the main Python directory, which allows you to keep them completely separate.</p><p>If you're using Python 3—and I recommend that you do, because Python 2 support will end in 2020—then you don't have to install virtualenv; you can use it just by running it like a package, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong># Create a python 3 virtualenv
$ python3 -m venv env</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>Now that we have pip, if we need to install <code class="literal">virtualenv</code>, then we can just run the following command:</p><pre class="programlisting"><span class="strong"><strong>$ pip install virtualenv</strong></span></pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec9"></a>Virtualenv basics</h3></div></div></div><p>Let's <span>initialize</span><a id="id325378743" class="indexterm"></a><code class="literal">virtualenv</code> for our project, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ virtualenv env</strong></span></pre><p>The extra <code class="literal">env</code> tells virtualenv to store all the packages in a folder named <code class="literal">env</code>. Virtualenv requires you to start it before it will sandbox your project. You can do this using the following code:</p><pre class="programlisting"><span class="strong"><strong>$ source env/bin/activate</strong></span><span class="strong"><strong># Your prompt should now look like</strong></span><span class="strong"><strong>(env) $</strong></span></pre><p>The <code class="literal">source</code> command tells Bash to run the <code class="literal">env/bin/activate</code> script in the context of the current directory. Let's reinstall Flask in our new sandbox, as follows:</p><pre class="programlisting"><span class="strong"><strong># you won't need sudo anymore</strong></span><span class="strong"><strong>(env) $ pip install flask</strong></span><span class="strong"><strong># To return to the global Python</strong></span><span class="strong"><strong>(env) $ deactivate</strong></span></pre></div></div>