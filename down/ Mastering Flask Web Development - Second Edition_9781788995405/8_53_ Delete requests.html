<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec54"></a>Delete requests</h2></div></div><hr /></div><p>Finally, in the following code we have the <code class="literal">DELETE</code> request, which is the simplest of the four supported methods. The main difference with the <code class="literal">delete</code> method is that it <span>returns</span><a id="id324991598" class="indexterm"></a> no content, which is the accepted standard with <code class="literal">DELETE</code> requests:</p><pre class="programlisting">@jwt_required
def delete(self, post_id=None):
if post_id:
        abort(400)
    post = Post.query.get(post_id)
if not post:
        abort(404)
if get_jwt_identity() != post.user_id:
        abort(401)
    db.session.delete(post)
    db.session.commit()
return "", 204</pre><p>Again, we can test using the following:</p><pre class="programlisting"><span class="strong"><strong>$ curl -X DELETE -H "Authorization: Bearer $ACCESS"</strong></span><span class="strong"><strong>http://localhost:5000/api/post/102</strong></span></pre><p>If everything is successfully deleted, you should receive a <code class="literal">204</code> status code and nothing should show up.</p><p>Before we move on from REST completely, there is one final challenge for you to test your understanding of Flask Restful. Try to create a comments API that is not only modifiable from <code class="literal">http://localhost:5000/api/comments</code>, but that also allows developers to modify only those comments on a specific post by using the URL formatÂ <code class="literal">http://localhost:5000/api/post/&lt;int:post_id&gt;/comments</code>.</p></div>