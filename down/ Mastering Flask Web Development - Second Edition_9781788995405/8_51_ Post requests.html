<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec52"></a>Post requests</h2></div></div><hr /></div><p>The <code class="literal">POST</code> methods on REST are <span>used</span><a id="id324991595" class="indexterm"></a> for resource creation, not that this isn't considered an idempotent method. Using our new knowledge of the Flask Restful parser, we can cover the <code class="literal">POST</code> endpoint. First, we will need a parser that will take a title, the body text, and a list of tags. In the <code class="literal">parser.py</code> file, find the following:</p><pre class="programlisting">post_post_parser = reqparse.RequestParser()
post_post_parser.add_argument(
'title',
type=str,
required=True,
help="Title is required",
location=('json', 'values')
)
post_post_parser.add_argument(
'text',
type=str,
required=True,
help="Body text is required",
location=('json', 'values')
)
post_post_parser.add_argument(
'tags',
type=str,
action='append',
location=('json', 'values')
)</pre><p>Next, we have created a helper function, called <code class="literal">add_tags_to_post</code>, to add tags to a post. If the tags don't exist, it will add them to the database. We will use it on <code class="literal">POST</code> and <code class="literal">PUT</code> requests. Nothing new here—just a simple SQLAlchemy helper function to help us keep our code concise.</p><p>Next, the <code class="literal">PostApi</code> class will need a <code class="literal">post</code> method to handle incoming requests. The <code class="literal">post</code> method will use the given values for the title and body text. Also, if the <code class="literal">tags</code> key exists, then add the tags to the post, which creates new tags if the passed ones do not exist, as shown in the following code:</p><pre class="programlisting">import datetime 
from .parsers import ( 
  post_get_parser, 
  post_post_parser 
) 
from webapp.models import db, User, Post, Tag 
class PostApi(Resource): 
  ... 
  @jwt_required
  def post(self, post_id=None):  
      args = post_post_parser.parse_args(strict=True) 
      new_post = Post(args['title'])
<span class="strong"><strong>new_post.user_id = get_jwt_identity()</strong></span>
      new_post.text = args['text'] 
      if args['tags']:
        <span class="strong"><strong>add_tags_to_post(post, args['tags'])</strong></span> 
      db.session.add(new_post) 
      db.session.commit()
      <span class="strong"><strong>return {'id': new_post.id}, 201</strong></span></pre><p>At the <code class="literal">return</code> statement, if a tuple is returned, the second argument is treated as the status code. There is also a third value that acts as extra header values by passing a dictionary. Also, note the <code class="literal">get_jwt_identity</code> that we use to fetch the user ID from the JWT token. This was set up at the login phase where we used the user ID to set the JWT identity.</p><p> </p><p>To pass <code class="literal">POST</code> variables, the <code class="literal">d</code> flag is used, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ curl -X POST -H "Authorization: Bearer $ACCESS" -H "Content-Type: application/json" -d '{"title":"Text Title", "text":"Some text"}' "http://localhost:5000/api/post"
</strong></span>{
    "id": 310
}</pre><p>The ID of the newly created post should be returned. If you go to the browser, you should see our newly created post, which was made by the user that you used to generate the authentication token.</p></div>