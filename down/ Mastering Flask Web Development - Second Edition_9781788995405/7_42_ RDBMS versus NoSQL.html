<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec44"></a>RDBMS versus NoSQL</h2></div></div><hr /></div><p>NoSQL is a tool, and like <span>any</span><a id="id324993883" class="indexterm"></a> tool there are specific use cases where it excels and there are use cases where some other tool would be a better fit. No one would use a screwdriver to pound in a nail; it's possible, but using a hammer would make the job easier. One large problem with NoSQL databases is that people adopt them when an RDBMS would solve the problem just as well, or better.</p><p>To understand which tool should be used when, we must understand the strengths and weaknesses of both systems.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec49"></a>The strengths of RDBMS databases</h3></div></div></div><p>One of the biggest strengths of RDBMSes is their maturity. The <span>technology</span><a id="id324993898" class="indexterm"></a> behind RDBMSes has existed for over 40 years and is based on the solid theory of relational algebra and relational calculus. Because of their maturity, they have a long, proven track record across many different industries of handling data in a safe and secure way.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec22"></a>Data integrity</h4></div></div></div><p>Integrity is also one of the <span>biggest</span><a id="id324993916" class="indexterm"></a> selling points of RDBMSes. RDBMSes have several methods in place to ensure that the data entered into a database will not only be correct, but that data loss will be practically nonexistent. These methods combine to form what is known as <span><span class="strong"><strong>ACID</strong></span></span> (short for <span class="strong"><strong>atomicity</strong></span>, <span class="strong"><strong>consistency</strong></span>, <span class="strong"><strong>isolation</strong></span>, and <span class="strong"><strong>durability</strong></span>). ACID is a set of rules for transactions that guarantee that the transaction is <span>handled</span><a id="id325368993" class="indexterm"></a> safely.</p><p>The <span>principle</span> of atomicity requires that each transaction is all or nothing. If one part of the transaction fails, the entire transaction fails. This is much like the following quote from <span><span class="emphasis"><em>The Zen of Python</em></span>:</span></p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em><span>"Errors should never pass silently. Unless explicitly silenced."</span></em></span></p></blockquote></div><p>If there is a problem with the data that has been changed or entered, the transaction should not keep operating because the proceeding operations most likely require that the previous operations were successful.</p><p>The principle of consistency requires that any data that the transaction modifies or adds follows the rules of each table. Such rules include type checks, user-defined constraints—such as <span class="emphasis"><em>foreign keys—</em></span>cascade rules, and triggers. If any of the rules are broken, then according to the atomicity rule, the transaction will be thrown out.</p><p>The principle of isolation requires that if the database runs transactions concurrently to speed up writes, then the outcome of the transactions would be the same as if they were run serially. This is mostly a rule for database programmers, and is not something that web developers need to worry about.</p><p>Finally, the principle of durability requires that once a transaction is accepted, the data must never be lost, barring a hard drive failure after the transaction is accepted. If the database crashes or loses power, then the durability principle requires that any data written before the problem occurred should still be present when the server is backed up. This essentially means that all transactions must be written to the disk once they are accepted.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec23"></a>Speed and scale</h4></div></div></div><p>A common <span>misconception</span><a id="id325371670" class="indexterm"></a> is that the ACID principle makes RDBMSes slow and unable to scale. This is only half true—it is completely possible for an RDBMS to scale. For example, an Oracle database configured by a professional database administrator can handle tens of thousands of complex queries a second. Huge companies, such as Facebook, Twitter, Tumblr, and Yahoo!, are using MySQL to great effect, and PostgreSQL is emerging as a favorite of many programmers because of its speed advantage over MySQL.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec24"></a>Tools</h4></div></div></div><p>When evaluating a programming language, the strongest points for or <span>against</span><a id="id325371850" class="indexterm"></a> adopting it are the size and activity of its community. A larger and more active community means more help if you get stuck and more open source tools available for you to use in your projects.</p><p>It's no different with databases. RDBMSes, such as MySQL and PostgreSQL, have official libraries for almost every language that is used in commercial environments and unofficial libraries for everything else. Tools, such as Excel, can easily download the latest data from one of these databases and allow the user to treat it like it was any other dataset. Several free desktop GUIs exist for each database, and some are officially supported by the databases' corporate sponsor.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec50"></a>The strengths of NoSQL databases</h3></div></div></div><p>The main reason that many people use <span>NoSQL</span><a id="id325371867" class="indexterm"></a> databases is its speed advantage over traditional databases. Out of the box, many NoSQL databases can outperform RDBMSes. However, a well-tuned and properly scaled SQL database with read slaves can outperform NoSQL databases. Many NoSQL databases, especially document stores, sacrifice consistency for availability. This means that they can handle many concurrent reads and writes, but those writes may be in conflict with one another. Yet, this is not straightforward, as you will soon see when we look at the CAP theorem.</p><p>The second feature that pulls people to NoSQL is its ability to handle unformatted data. Storing data in XML or JSON allows an arbitrary structure to each document. Applications that store user-designed data have benefited greatly from the adoption of NoSQL. For example, a video game that allows players to submit their custom levels to some central repository can now store the data in a queryable format rather than in a binary blob.</p><p>The third feature that draws people to NoSQL is the ease of creating a cluster of databases working in tandem. Not having <code class="literal">JOIN</code> operators or only accessing values via keys makes splitting the data across servers a rather trivial task when compared with RDBMSes. This is due to the fact that <code class="literal">JOIN</code> operators require a scan of the entire table, even if it is split across many different servers. The <code class="literal">JOIN</code> operators become even slower when documents or keys can be assigned to a server by an algorithm as simple as the starting character of its unique identifier—for example, everything that starts with the letters A–H is sent to server 1, I–P to server 2, and Q–Z to server 3. This makes looking up the location of data for a connected client very fast.</p><p>Next, we will briefly explain the CAP theorem, to give you some background on the underlying problems behind database-distributed systems.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec51"></a>CAP theorem</h3></div></div></div><p>The <span class="strong"><strong>CAP</strong></span> theorem stands for <span class="strong"><strong>consistency</strong></span>, <span class="strong"><strong>availability</strong></span>, and <span class="strong"><strong>partition</strong></span> tolerance, and states that it's not <span>possible</span><a id="id325375177" class="indexterm"></a> for a distributed system to guarantee all three, so a trade-off must be made.</p><p>The following list shows exactly what each of these guarantees means on a distributed system:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Consistency:</strong></span> Guarantees that each node on a cluster returns the most recent write and preserves linear consistency</li><li style="list-style-type: disc"><span class="strong"><strong>Availability:</strong></span> Every <span>non failing</span><a id="id325375204" class="indexterm"></a> node is able to respond to a request with a non error response</li><li style="list-style-type: disc"><span class="strong"><strong>Partition tolerance</strong></span>: The system continues to operate despite <span>network</span><a id="id325376885" class="indexterm"></a> outages/delays</li></ul></div><p>The theorem states that in <span>case</span> of a network partition, a distributed system has to choose between consistency or availability, so in the case of a network partition, systems must fall into two main categories, CP and AP.</p><p>A simple visualization of such a distributed system would be two instances serving many clients concurrently on distinct data centers. One client sends: write the key-value <span class="strong"><strong>a:0</strong></span> to <span class="strong"><strong>server1</strong></span>. Then <span class="strong"><strong>server1</strong></span> sends <span class="strong"><strong>a:0</strong></span> to <span class="strong"><strong>server2</strong></span>, <span class="strong"><strong>server2</strong></span> sends an acknowledgement back to <span class="strong"><strong>server1</strong></span> which then sends an acknowledgement back to the client. This is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/13b6fc1f-fb51-4167-b7a2-d86b6faa1ac6.png" /></div><p>Imagine that a network partition occurs and this prevents <span class="strong"><strong>server1</strong></span> from communicating with <span class="strong"><strong>server2</strong></span>. Meanwhile, <span class="strong"><strong>client1</strong></span> requests that <span class="strong"><strong>server1</strong></span> changes <span class="strong"><strong>a:0</strong></span> to <span class="strong"><strong>a:1</strong></span>. If the system aims for consistency, then it would reject the transaction since it can't send the write to <span class="strong"><strong>server2</strong></span> and <span class="strong"><strong>server2</strong></span> would deny any transactions since it could serve dirty reads, and we are aiming for consistency. This relationship is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/8db04a73-8ca0-4b2f-8b98-7d0fc68570f9.png" /></div><p>If we want to aim for availability, we must relax consistency. In today's database RDBMS or NoSQL, systems are not 100% CP or AP, but they can be configured to be more or less relaxed as to their consistency and availability to a certain degree.</p><p> </p><p> </p><p>Although not 100% correct, MongoDB aims for consistency and partition tolerance. MongoDB in a cluster architecture uses a single-master setup, which means that a single node can accept writes. It avoids a <span class="strong"><strong>single point of failure</strong></span> (<span class="strong"><strong>SPOF</strong></span>) by having the ability to switch if the majority of the other nodes lose contact with their current master. This increases availability by lowering consistency for the following reasons:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">If you use a single node, then reads and writes to the same system on MongoDB will make it a very consistent system, but if you use multiple instances for reads with asynchronous replication, then the entire system will eventually become consistent</li><li style="list-style-type: disc">When the old master node recovers, it will rejoin the cluster as a slave node, and all the dirty writes it might have will be rolled back</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec52"></a>What database to use and when</h3></div></div></div><p>So, each database has different uses. It was stated at the beginning of the section that the main problem when programmers choose a <span>NoSQL</span><a id="id325379683" class="indexterm"></a> database for their technology stack is that they choose it when an RDBMS would work just as well. This is born out of some common misconceptions. Firstly, people try to use a relational mindset and data model and think that they will work just as well in a NoSQL database. People usually come to this misunderstanding because the marketing on the various websites of NoSQL databases is misleading, and encourages users to drop their current database without considering whether a non-relational model will work for their project.</p><p>Secondly, people believe that you must use only one data store for your application. Many applications can benefit from using more than one data store. Take a Facebook clone as an example. It could use MySQL for holding user data, Redis to store session data, a document store to hold the data for the quizzes and surveys that people share with each other, and a graph database to implement a feature for finding friends.</p><p>If an application feature needs very fast writes, and write safety is not a primary concern, then you should use a document store database. If you need to store and query schemaless data, then you should use a document store database.</p><p>If an application feature needs to store something that deletes itself after a specified time, or if the data does not need to be searched, then you should use a key-value store.</p><p>If an application feature involves finding or describing complex relationships between two or more sets of data, then you should use a graph <span>store</span>.</p><p> </p><p>If an application feature needs guaranteed write safety, or if it needs each entry to fit into a specified schema, different sets of data in the database to be compared using <code class="literal">JOIN</code> operators, or constraints on the entered data, then you should use an RDBMS.</p></div></div>