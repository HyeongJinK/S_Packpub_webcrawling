<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec43"></a>Types of NoSQL database</h2></div></div><hr /></div><p>NoSQL is a blanket term used to describe nontraditional methods of <span>storing</span><a id="id324993880" class="indexterm"></a> data in a database. The vast majority of NoSQL databases are not relational—unlike RDBMS—which means that they normally cannot perform operations such as <code class="literal">JOIN</code>. There are a number of other features that distinguish an SQL database from a NoSQL database. With a NoSQL database, we have the ability to not impose a fixed schema—for example, a collection on MongoDB can hold different fields, and so they can accept any kind of document. With NoSQL you can (and should) take advantage of denormalization, making a tradeoff between storage and speed.</p><p>Modern NoSQL databases include key-value stores, document stores, column family stores, and graph databases.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec45"></a>Key-value stores</h3></div></div></div><p>A <span class="strong"><strong>key-value</strong></span> NoSQL database acts much like a dictionary in Python. A single value is associated with one key and is accessed via that key. Also, like a Python dictionary, most key-value databases have the same read speed regardless of how many entries there are. Advanced programmers would know this as <span class="strong"><strong>O(1) reads</strong></span>. In some key-value stores, only one key can be retrieved at a time, rather than multiple rows in traditional SQL databases. In most key-value stores, the content of the value is not queryable, but the keys are. Values are just binary blobs: they can be literally anything, from a string to a movie file. However, some key-value stores give default types, such as strings, lists, sets, and dictionaries, while still giving the option of adding binary data.</p><p>Because of their simplicity, key-value stores are typically very fast. However, their simplicity makes them unsuitable as the main database for most applications. As such, most key-value store use cases involve <span>storing</span><a id="id325629342" class="indexterm"></a> simple objects that need to expire after a certain amount of time. Two common examples of this pattern are storing users' session data and shopping cart data. Also, key-value stores are commonly used as caches for the application or for other databases. For example, results from a commonly run, or CPU-intensive, query or function are stored with the query or function name as a key. The application will check the cache in the key-value store before running the query on the database, thereby decreasing <span>page</span><a id="id325629351" class="indexterm"></a> load times and stress on the database. An <span>example</span><a id="id325629360" class="indexterm"></a> of this functionality <span>will</span><a id="id325629368" class="indexterm"></a> be shown in <a class="link" href="#" linkend="ch10"><span>Chapter 10</span></a>, <span class="emphasis"><em>Useful Flask Extensions</em></span>.</p><p>The most popular key–value stores are <span class="strong"><strong>Redis</strong></span>, <span class="strong"><strong>Riak</strong></span>, and <span class="strong"><strong>Amazon DynamoDB</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec46"></a>Document stores</h3></div></div></div><p><span class="strong"><strong>Document store</strong></span> is one of the most popular NoSQL <span>database</span><a id="id325631834" class="indexterm"></a> types, and is typically used to replace RDBMSes. Databases store data in collections of key-value pairs called documents. These documents are schemaless, meaning that no document follows the structure of any other document. Also, extra keys may be appended to each document after its creation. Document stores can store data in <span class="strong"><strong>JSON</strong></span>, BSON, and XML. For example, the following are two different post objects stored in JSON:</p><pre class="programlisting">{ 
  "title": "First Post", 
  "text": "Lorem ipsum...", 
  "date": "2015-01-20", 
  "user_id": 45 
},
{ 
  "title": "Second Post", 
  "text": "Lorem ipsum...", 
  "date": "2015-01-20", 
  "user_id": 45, 
  "comments": [ 
    { 
      "name": "Anonymous", 
      "text": "I love this post." 
    } 
  ] 
} </pre><p>Note that the first document has no comments array. As stated before, documents are schemaless, so this format is perfectly valid. The lack of a schema also means that there are no type checks at the database level. There is nothing in the database to stop an integer from being entered into the title field of a post. Schemaless data is the most powerful feature of document stores and attracts many developers to adopt it for their apps. However, it can also be considered very dangerous, as there is one less check to stop faulty or malformed data from getting into your database.</p><p>Some document stores collect similar objects into collections of documents to make querying objects easier. However, in some document stores, all objects are queried at once. Document stores store the metadata of <span>each</span><a id="id325631856" class="indexterm"></a> object, which allows all of the values in <span>each</span><a id="id325631864" class="indexterm"></a> document to be <span>queried</span><a id="id325631873" class="indexterm"></a> and return matching documents.</p><p>The most popular document stores are <span class="strong"><strong>MongoDB</strong></span>, <span class="strong"><strong>CouchDB</strong></span>, and <span class="strong"><strong>Couchbase</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec47"></a>Column family stores</h3></div></div></div><p><span class="strong"><strong>Column family stores</strong></span>, also known as <span class="strong"><strong>wide column stores</strong></span>, have many things in common with both key-value stores and document stores. Column family stores are the fastest type of NoSQL <span>database</span><a id="id325631911" class="indexterm"></a> because they are designed for large applications. Their main advantage is their <span>ability</span><a id="id325631920" class="indexterm"></a> to handle terabytes of data and still have very fast read and write speeds by distributing the data across several servers in an intelligent way.</p><p>Column family stores <span>are</span><a id="id325631928" class="indexterm"></a> also the hardest to understand, due in part to the vernacular of column family stores, as they use many of the same terms as RDBMSes, but with wildly different meanings. In order to clearly understand what a column family store is, let's jump straight into an example. Let's create a simple<span class="emphasis"><em>user-to-posts</em></span>association in a typical column family store.</p><p>First, we need a user table. In column family stores, data is stored and accessed via a unique key, such as a key-value store, but the content consists of unstructured columns, such as a document store. Consider the following user table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Key</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Jack</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p> </p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p> </p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">John</code></p></td><td style="border-bottom: 0.5pt solid ; "><p> </p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Column</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Full Name</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Bio</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Location</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Full Name</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">Bio</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Value</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">Jack Stouffer</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">This is my about me</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">Michigan, USA</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">John Doe</code></p></td><td style=""><p><code class="literal">This is my about me</code></p></td></tr></tbody></table></div><p> </p><p>Note that each key holds columns, which are key-value pairs as well. Also, it is not necessary for each key to have the same number or type of columns. Each key can store hundreds of unique columns, or they can all have the same number of columns to make application development easier. This is in contrast to key-value stores, which can hold any type of data with each key. This is also slightly different than document stores, which can store types, such as arrays and dictionaries, in each document. Now let's create our posts table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Key</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Post/1</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p> </p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p> </p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Post/2</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p> </p></td><td style="border-bottom: 0.5pt solid ; "><p> </p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Column</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Title</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Date</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Text</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Title</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Date</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">Text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Value</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">Hello World</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">2015-01-01</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">Post text...</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">Still Here</code></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">2015-02-01</code></p></td><td style=""><p><code class="literal">Post text...</code></p></td></tr></tbody></table></div><p> </p><p> </p><p>There are several things to understand about column family stores before we continue. Firstly, in column family stores, data can only be selected via a single key or key range; there is no way to query the contents of the columns. To get around this, many programmers use an external search tool with their database—such as <span class="strong"><strong>Elasticsearch</strong></span>—that stores the contents of columns in a searchable format (Lucene's inverted indexes) and returns matching keys to be queried on the database. This limitation is why proper <span class="emphasis"><em>schema</em></span> design is so crucial in column family stores, and must be carefully thought through before storing any data.</p><p>Secondly, data cannot be ordered by the content of the columns. Data can only be ordered by key, which is why the keys to the posts are integers. This allows the posts to be returned in the order in which they were entered. This is not a requirement for the user table because there is no need to sequentially order users.</p><p>Thirdly, there are no <code class="literal">JOIN</code> operators, and we cannot query for a column that would hold a user key. With our current schema, there is no way to associate a post with a user. To create this functionality, we need a third table that holds the user to post associations, as follows:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Key</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Jack</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Column</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Posts</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Posts/1</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">Post/1</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>Value</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p></p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">Posts/2</code></p></td><td style=""><p><code class="literal">Post/2</code></p></td></tr></tbody></table></div><p>This is slightly different from the other tables we have seen so far. The <code class="literal">Posts</code> column is named a <span class="strong"><strong>super column</strong></span>, which is a column that holds other columns. In this table, a super column is associated with our user key, which is holding an association of the position of a post to one post. Clever readers might ask why we wouldn't just store this association in our <code class="literal">user</code> table, much like how the problem would be solved in document stores. This is because regular columns and super columns cannot be held in the same table. You must choose one at the creation of each table.</p><p>To get a list of all the posts by a user, we would first have to query the post association table with our user key, use the returned list of associations to get all of the keys in the posts' table, and query the post table with the keys.</p><p>If that query seems like a roundabout process to you, that's because it is, and it is made that way by design. The limiting nature of a column family store is what allows it to be so fast and handle so much data. Removing features such as searching by value and column name gives column family stores the ability to handle hundreds of terabytes of data. It's not an exaggeration to say that SQLite is a more complex database for the programmer than a typical column family store.</p><p> </p><p>For this reason, most Flask developers should steer clear of column family stores as they add complexity to applications that isn't necessary. Unless your application is going to handle millions of <span>reads</span><a id="id325731406" class="indexterm"></a> and <span>writes</span><a id="id325731415" class="indexterm"></a> a second, using a column family store is like pounding in a nail <span>with</span><a id="id325731424" class="indexterm"></a> an atomic bomb.</p><p>The most popular column family stores are <span class="strong"><strong>BigTable</strong></span>, <span class="strong"><strong>Cassandra</strong></span>, and <span class="strong"><strong>HBase</strong></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec48"></a>Graph databases</h3></div></div></div><p>Designed to describe and then <span>query</span><a id="id325731453" class="indexterm"></a> relationships, <span class="strong"><strong>graph databases</strong></span> are like document stores, but have <span>mechanisms</span><a id="id325731706" class="indexterm"></a> to create and describe links between two nodes.</p><p>A <span class="strong"><strong>node</strong></span> is like an <span>instance</span><a id="id325731721" class="indexterm"></a> of an object, usually a collection of key-value pairs or a JSON document. Nodes can be given labels to mark them as part of a category—for example, a user or a group. After your nodes have been defined, an arbitrary number of one-way relationships between the nodes, named <span class="strong"><strong>links</strong></span>, can be created with <span>their</span><a id="id325731732" class="indexterm"></a> own attributes. For example, if our data had two user nodes and each of the two users knew each other, we would define two <code class="literal">knows</code> links between them to describe that relationship, as shown in the following diagram. This would allow you to query all the people that know one user or all the people that a user knows:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/32dede41-8fa8-40c7-9235-e71070e43ed5.png" /></div><p> </p><p>Graph <span>stores</span> also allow you to query by the link's attributes. This allows you to easily create otherwise complex queries, such as a search for all of the users that one user marked as known in October 2001. Graph <span>stores</span> can follow links from node to node to create even more complex queries. If this example dataset had more groups, we can query for groups that people we know have joined but that we haven't joined. Otherwise, we can query for people who are in the same groups as a user, but who the user doesn't know. Queries in a graph <span>store</span> can also follow a large number of links to answer complex questions, such as "which restaurants in New York that serve burgers and have a three-star rating or higher have my friends liked?"</p><p>The most common use case for a graph database is to build a recommendation engine. For example, say that we had a graph <span>store</span> that is filled with our friend data from a social networking site. Using this data, we could build a mutual friend finder by querying for users that have been marked as friends by more than two of our friends.</p><p>It is very rare for a graph <span>database</span><a id="id325739499" class="indexterm"></a> to be used as the primary data store of an application. Most uses of graph <span>stores</span> have each node acting as a representation of a piece of data in their main <span>database</span><a id="id325739513" class="indexterm"></a> by storing its unique identifier and a small amount of other identifying information.</p><p>The most popular graph <span>stores</span> are <span class="strong"><strong>Neo4j</strong></span> and <span class="strong"><strong>InfoGrid</strong></span>.</p></div></div>