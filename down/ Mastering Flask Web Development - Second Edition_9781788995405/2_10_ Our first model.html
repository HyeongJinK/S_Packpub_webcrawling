<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Our first model</h2></div></div><hr /></div><p>You may have <span>noticed</span><a id="id324847030" class="indexterm"></a> that we did not actually create any tables in our database to abstract from. This is because SQLAlchemy allows us to create either models from tables or tables from our models. We will look at this after we have created the first model.</p><p> </p><p>In our <code class="literal">main.py</code> file, SQLAlchemy must first be initialized with our app as follows:</p><pre class="programlisting">from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from config import DevConfig

app = Flask(__name__)
app.config.from_object(DevConfig)
db = SQLAlchemy(app) </pre><p>SQLAlchemy will read our app's configuration and automatically connect to our database. Let's create a <code class="literal">User</code> model to interact with a user table in the <code class="literal">main.py</code> file, as follows:</p><pre class="programlisting">class User(db.Model): 
  id = db.Column(db.Integer(), primary_key=True) 
  username = db.Column(db.String(255)) 
  password = db.Column(db.String(255)) 
 
  def __init__(self, username): 
    self.username = username 
 
  def __repr__(self): 
    return "&lt;User '{}'&gt;".format(self.username) </pre><p>What have we accomplished? We now have a model that is based on a user table with three columns. When we inherit from <code class="literal">db.Model</code>, the entire connection and communication with the database will already be handled for us.</p><p>Each class variable that is the <code class="literal">db.Column</code> instance represents a column in the database. There is an optional first argument in the <code class="literal">db.Column</code> instance that allows us to specify the name of the column in the database. Without it, SQLAlchemy will assume that the name of the variable is the same as the name of the column. Using this, optional variable would look like the following:</p><pre class="programlisting">username = db.Column('user_name', db.String(255))</pre><p>The second argument to <code class="literal">db.Column</code> tells SQLAlchemy what type the column should be treated as. The main types that we will work with in this book are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">db.String</code></li><li style="list-style-type: disc"><code class="literal">db.Text</code></li><li style="list-style-type: disc"><code class="literal"><code class="literal">db.Integer</code></code></li><li style="list-style-type: disc"><code class="literal">db.Float</code></li><li style="list-style-type: disc"><code class="literal"><code class="literal">db.Boolean</code></code></li><li style="list-style-type: disc"><code class="literal">db.Date</code></li><li style="list-style-type: disc"><code class="literal">db.DateTime</code></li><li style="list-style-type: disc"><code class="literal">db.Time</code></li></ul></div><p>What each type represents is rather simple, as shown in the following list:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">String</code> and <code class="literal">Text</code> types take Python strings and translate them to the <code class="literal">varchar</code> and <code class="literal">text</code> type columns, respectively.</li><li style="list-style-type: disc">The <code class="literal">Integer</code> and <code class="literal">Float</code> types take any Python number and translates it into the correct type before inserting it into the database.</li><li style="list-style-type: disc">Boolean takes Python <code class="literal">True</code> or <code class="literal">False</code> statements and, if the database has a <code class="literal">boolean</code> type, inserts a Boolean into the database. If there is no <code class="literal">boolean</code> type in the database, SQLAlchemy automatically translates between Python Booleans and a 0 or a 1 in the database.</li><li style="list-style-type: disc">The <code class="literal">Date</code>, <code class="literal">DateTime</code>, and <code class="literal">Time</code> types use the Python types of the same names from the <code class="literal">datetime</code> native library and translates them into the database.</li></ul></div><p>The <code class="literal">String</code>, <code class="literal">Integer</code>, and <code class="literal">Float</code> types take an extra argument that tells SQLAlchemy the length limit of our column.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note8"></a>Note</h3><p>If you wish to truly understand how SQLAlchemy translates your code into SQL queries, add the following to the <code class="literal">DevConfig</code> file, <code class="literal">SQLALCHEMY_ECHO = True</code>.
This will print out the created queries to the Terminal. You may wish to turn this feature off as you get further along in the book, as dozens of queries could be printed to the terminal with every page load.</p></div><p>The <code class="literal">primary_key</code> argument tells SQLAlchemy that this column has the<span class="strong"><strong>primary key index</strong></span>on it. Each SQLAlchemy model requires a primary key to function. All object-relationally <span>mapped</span><a id="id325571063" class="indexterm"></a> objects are linked to their database rows within the session via an identity map, a pattern central to the unit of work mechanism implemented in SQLAlchemy. That's why we need primary keys to be declared in the model.</p><p>SQLAlchemy will assume that the name of your table is the lowercase version of your model class name. However, what if we want our table to be called something other than <code class="literal">user</code>? To tell SQLAlchemy what name to use, add the <code class="literal">__tablename__</code> class variable.</p><p> </p><p>This is also how you connect to tables that already exist in your database. Just place the name of the table in the following string:</p><pre class="programlisting">class User(db.Model): 
  __tablename__ = 'user_table_name' 
 
  id = db.Column(db.Integer(), primary_key=True) 
  username = db.Column(db.String(255)) 
  password = db.Column(db.String(255)) </pre><p>We don't have to include the <code class="literal">__init__</code> or <code class="literal">__repr__</code> functions. If we don't, then SQLAlchemy will automatically create an <code class="literal">__init__</code> function that accepts the names and values of your columns as keyword arguments.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note9"></a>Note</h3><p>Naming a table <code class="literal">user</code> using an ORM may lead to problems, since in MySQL, <code class="literal">user</code> is a reserved word. One of the advantages of using an ORM is that you can easily migrate your engine from SQLite to MySQL and then to ORACLE, for example. One very easy fix would be to prefix your schema and use. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Creating the user table</h3></div></div></div><p>Using SQLAlchemy to do the heavy lifting, we will <span>now</span><a id="id325578321" class="indexterm"></a> create the user table in our database. Update <code class="literal">manage.py</code> to the following:</p><pre class="programlisting">from main import app, db, User 

@app.shell_context_processor
def make_shell_context():
  return dict(app=app, db=db, User=User) </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip10"></a>Note</h3><p>From now on, whenever we create a new model, we will import it and add it to the returned <code class="literal">dict</code>.</p></div><p>This will allow us to work with our models in the Flask shell, because we are injecting. Run the shell now and use <code class="literal">db.create_all()</code> to create all of the tables, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong># Tell Flask where to load our shell context
</strong></span><span class="strong"><strong>$ export FLASK_APP=manage.py</strong></span>
<span class="strong"><strong>    $ flask shell</strong></span><span class="strong"><strong>&gt;&gt;&gt; db.create_all()</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>In your database, you should now see a table called <code class="literal">users</code> with the columns specified. Also, if you are using SQLite, you should now see a file named <code class="literal">database.db</code> in your file structure, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>$ sqlite3 database.db .tables
</strong></span>user</pre></div></div>