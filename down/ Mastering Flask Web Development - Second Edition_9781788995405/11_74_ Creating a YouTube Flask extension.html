<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec72"></a>Creating a YouTube Flask extension</h2></div></div><hr /></div><p>To begin, the first extension we are going to create is a simple extension that allows the <span>embedding</span><a id="id324974901" class="indexterm"></a> of YouTube videos in Jinja templates using the following tag:</p><pre class="programlisting">{{ youtube(video_id) }} </pre><p>The <code class="literal">video_id</code> object is the code after <code class="literal">v</code> in any YouTube URL. For example, in the URL <code class="literal">https://www.youtube.com/watch?v=_OBlgSz8sSM</code>, the <code class="literal">video_id</code> object is <code class="literal">_OBlgSz8sSM</code>.</p><p>For now, the code for this extension resides in <code class="literal">__init__.py</code>. However, this is only for development and debugging purposes. When the code is ready to be shared, it is moved into its own project directory.</p><p> </p><p>The first thing that any Flask extension needs is the object that will be initialized on the app. This object will handle adding its <code class="literal">Blueprint</code> object to the app and registering the <code class="literal">youtube</code> function on Jinja:</p><pre class="programlisting">from flask import Blueprint

class Youtube(object):
def __init__(self, app=None, **kwargs):
if app:
self.init_app(app)

def init_app(self, app):
self.register_blueprint(app)
<span class="strong"><strong>app.add_template_global(youtube)</strong></span>

def register_blueprint(self, app):
        module = Blueprint(
"youtube",
__name__,
url_prefix='youtube',
template_folder="templates"
)
        app.register_blueprint(module)
return module</pre><p>So far, the only thing this code does is initialize an empty blueprint on the <code class="literal">app</code> object.</p><p>Notice the code marked with bold. In the <code class="literal">YouTube</code> class, we have to register the function to Jinja in the <code class="literal">init_app</code> method. We can now use the <code class="literal">youtube</code> Jinja function on our templates.</p><p>The next piece of code needed is a representation of a video. The following is a class that handles the parameters from the Jinja function and renders HTML to display in the template:</p><pre class="programlisting">from flask import render_template, Blueprint, Markup 

class Video(object): 
    def __init__(self, video_id, cls="youtube"): 
      self.video_id = video_id 
      self.cls = cls

    @property 
    def html(self): 
      return Markup(render_template('youtube/video.html', video=self)) </pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>This object is created from the <code class="literal">youtube</code> function in the template, and any arguments passed in the template are given to this object to render the HTML. There is also a new object in this code, <code class="literal">Markup</code>, which was not used before. The <code class="literal">Markup</code> class is Flask's way of automatically escaping HTML, or marking it as safe to include in the template. If we just returned HTML, Jinja would auto escape it because it does not know whether it is safe or not. This is Flask's way of protecting your site from <span class="strong"><strong>cross-site scripting attacks</strong></span>.</p><p>The next step is to create the function that will be registered in Jinja:</p><pre class="programlisting">def youtube(*args, **kwargs): 
  video = Video(*args, **kwargs) 
  return video.html </pre><p>Finally, we have to create the HTML that will add the video to the page. In a new folder named <code class="literal">youtube</code> in the <code class="literal">templates</code> directory, create a new HTML file named <code class="literal">video.html</code> and add the following code to it:</p><pre class="programlisting">&lt;iframe 
  class="{{ video.cls }}" 
  width="560" 
  height="315" 
  src="https://www.youtube.com/embed/{{ video.video_id }}" 
  frameborder="0" 
  allowfullscreen&gt; 
&lt;/iframe&gt; </pre><p>This is all the code that's needed to embed YouTube videos in your templates. Let's test this out now. In <code class="literal">__init__.py</code>, initialize the <code class="literal">Youtube</code> class below the <code class="literal">Youtube</code> class definition:</p><pre class="programlisting">youtube = Youtube()</pre><p>In <code class="literal">__init__.py</code>, use the <code class="literal">youtube_ext</code> variable, which contains the initialized class, and use the <code class="literal">init_app</code> method we created to register it on the app:</p><pre class="programlisting">def create_app(object_name): 
    ... 
    youtube.init_app(app) </pre><p>Now, as a simple example, add the <code class="literal">youtube</code> function to the top of the <span>blog</span><a id="id325591108" class="indexterm"></a> home page on <code class="literal">templates/blog/home.html</code>:</p><pre class="programlisting">{% extends "base.html" %}
{% import 'macros.html' as macros %}
{% block title %}Home{% endblock %}
{% block leftbody %}

<span class="strong"><strong>{{ youtube("_OBlgSz8sSM") }}</strong></span>

{{ macros.render_posts(posts) }}
{{ macros.render_pagination(posts, 'blog.home') }}
{% endblock %}</pre><p>This will have the following result:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/929c6359-f066-473e-85bf-911059c5ffa8.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec74"></a>Creating a Python package</h3></div></div></div><p>In order to make our new Flask extension available to others, we have to create an <span>installable</span><a id="id325599068" class="indexterm"></a> Python package from the code we have written so far. To begin, we need a new project directory outside of our current application directory. We will need two things: a <code class="literal">setup.py</code> file, which we will fill in later, and a folder named <code class="literal">flask_youtube</code>. In the <code class="literal">flask_youtube</code> directory, we will have an <code class="literal">__init__.py</code> file, which contains all the code that we wrote for our extension. This includes the <code class="literal">Youtube</code> and the <code class="literal">Video</code> Python classes.</p><p>Also, inside the <code class="literal">flask_youtube</code> directory, we will need a <code class="literal">templates</code> directory, which holds the <code class="literal">youtube</code> directory that <span>we</span><a id="id325599108" class="indexterm"></a> put in our app's <code class="literal">templates</code> directory.</p><p>In order to turn this code into a Python package, we use the library named <code class="literal">setuptools</code>. Now, <code class="literal">setuptools</code> is a Python package that allows developers to easily create installable packages for their code. <code class="literal">setuptools</code> bundles code so that <code class="literal">pip</code> and <code class="literal">easy_install</code> can automatically install them, and will even upload your package to the <span class="strong"><strong>Python Package Index</strong></span> (<span class="strong"><strong>PyPI</strong></span>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note39"></a>Note</h3><p>All the packages that we have been installed from <code class="literal">pip</code> have come from PyPI. To see all the available packages, go to <a class="ulink" href="https://pypi.python.org/pypi" target="_blank"><span>https://pypi.python.org/pypi</span></a>.</p></div><p>All you need to do to get this functionality is fill out the <code class="literal">setup.py</code> file:</p><pre class="programlisting">from setuptools import setup, find_packages

setup(
name='Flask-YouTube',
version='0.4',
license='MIT',
description='Flask extension to allow easy 
    embedding of YouTube videos',
author='Jack Stouffer',
author_email='example@gmail.com',
platforms='any',
install_requires=['Flask'],
packages=find_packages(),
include_package_data=True,
package_data = {
'templates': ['*']
    },
zip_safe=False,
classifiers=[
'Development Status :: 5 - Production/Stable',
'Environment :: Web Environment',
'Intended Audience :: Developers',
'License :: OSI Approved :: BSD License',
'Operating System :: OS Independent',
'Programming Language :: Python',
'Topic :: Software Development :: Libraries :: Python Modules'
]
)</pre><p>This code uses the <code class="literal">setup</code> function from <code class="literal">setuptools</code> to find your source code and make sure that the machine that is installing your code has the required packages. Most of the attributes are rather self-explanatory, except the package attribute, which uses the <code class="literal">find_packages</code> function from <code class="literal">setuptools</code>.</p><p>The <code class="literal">package</code> attribute finds which parts of the source code are part of the package to be released. We use the <code class="literal">find_packages</code> method to automatically find which parts of the code to include. This is based on some sane defaults, such as looking for directories with <code class="literal">__init__.py</code> files and excluding common file extensions.</p><p>We must also declare a manifest file that the <code class="literal">setuptools</code> will use to know how to create our package. This includes rules for cleaning up files, <span>and what folders that are not Python modules to include</span>:</p><p><code class="literal"><span>MANIFEST</span>.in</code></p><pre class="programlisting">prune *.pyc
recursive-include flask_youtube/templates *</pre><p>Although it is not mandatory, this setup also contains metadata about the author and the license, which would be included on the PyPI page if we were to upload this there. There is a lot more customization available in the <code class="literal">setup</code> function, so I encourage you to read the documentation at <a class="ulink" href="http://pythonhosted.org/setuptools/" target="_blank"><span>http://pythonhosted.org/setuptools/</span></a>.</p><p>You can now install this package on your machine by running the following commands:</p><pre class="programlisting"><span class="strong"><strong>$ python setup.py build</strong></span><span class="strong"><strong>$ python setup.py install</strong></span></pre><p>This installs your code into your Python <code class="literal">packages</code> directory, or if you're using <code class="literal">virtualenv</code>, it installs it to the local <code class="literal">packages</code> directory. Then, you can import <span>your place on package</span> via the following code:</p><pre class="programlisting">from flask_youtube import Youtube</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec75"></a>Creating blog posts with videos</h3></div></div></div><p>We are now going to extend our blog so that users can include <span>videos</span><a id="id325700750" class="indexterm"></a> on their posts. This is a nice feature and is useful for showing how to create a new feature that includes database schema change and migration, as well as giving a review on Jinja2 and WTForms.</p><p>First, we need to add a new column named <code class="literal">youtube_id</code> (on the following highlighted code) to our <code class="literal">Post</code> SQLAlchemy model on the <code class="literal">blog/models.py</code> file:</p><pre class="programlisting">...
<span class="strong"><strong>class </strong></span><span class="strong"><strong>Post(db.Model):</strong></span>
    id = db.Column(db.Integer(), primary_key=True)
    title = db.Column(db.String(255), nullable=False)
    text = db.Column(db.Text(), nullable=False)
    publish_date = db.Column(db.DateTime(),  
    default=datetime.datetime.now)
    user_id = db.Column(db.Integer(), db.ForeignKey('user.id'))
<span class="strong"><strong>youtube_id = db.Column(db.String(20))</strong></span>
    comments = db.relationship('Comment', backref='post', 
    lazy='dynamic')
    tags = db.relationship('Tag', secondary=tags, 
    backref=db.backref('posts', lazy='dynamic'))
...</pre><p>Now we are able to store our user's YouTube ID to go along with their posts. Next we need to include our new field on the <code class="literal">Post</code> form. So, in the <code class="literal">blog/forms.py</code> file, we add the following:</p><pre class="programlisting">class PostForm(Form):
    title = StringField('Title', [DataRequired(),Length(max=255)])
<span class="strong"><strong>youtube_id = StringField('Youtube video id', [Length(max=255)])</strong></span>
    text = TextAreaField('Content', [DataRequired()])</pre><p>Now we need to change the <code class="literal">edit</code> and <code class="literal">new_post</code> controllers:</p><p><code class="literal"><span>blog/controllers.py</span></code>:</p><pre class="programlisting">...
def new_post():
    form = PostForm()
if form.validate_on_submit():
        new_post = Post()
        ...
<span class="strong"><strong>new_post.youtube_id = form.youtube_id.data</strong></span>
        ...
        db.session.add(new_post)
...</pre><p>We are setting the <code class="literal">Post.youtube_id</code> SQLAlchemy model attribute to the form <code class="literal">youtube_id</code> field, and for the <code class="literal">edit</code> method, we have the same thing when the forms have been submitted (POST HTTP method), and it's the other way around when the form is shown:</p><p><code class="literal"><span>blog/controllers.py</span></code>:</p><pre class="programlisting">...
def edit_post(id):
    post = Post.query.get_or_404(id)
# We want admins to be able to edit any post
if current_user.id == post.user.id:
        form = PostForm()
if form.validate_on_submit():
            ...
<span class="strong"><strong>post.youtube_id = form.youtube_id.data</strong></span>
            ...
            db.session.add(post)
            db.session.commit()
return redirect(url_for('.post', post_id=post.id))
        form.title.data = post.title
<span class="strong"><strong>form.youtube_id.data = post.youtube_id</strong></span>
        form.text.data = post.text
return render_template('edit.html', form=form, post=post)
    abort(403)
...</pre><p>Finally, we just have to include this new field on our Jinja2 templates. On our <code class="literal">templates/blog/post.html</code>, we render this field if it exists on the database:</p><pre class="programlisting">{% if post.youtube_id %}
&lt;div class="row"&gt;
    &lt;div class="col"&gt;
{{ youtube(post.youtube_id) | safe }}
&lt;/div&gt;
&lt;/div&gt;
{% endif %}</pre><p>To finish, we change our new post and edit the post templates. Just look for the change in the provided code.</p></div></div>