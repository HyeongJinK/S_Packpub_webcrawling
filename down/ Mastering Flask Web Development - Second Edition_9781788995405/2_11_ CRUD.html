<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>CRUD</h2></div></div><hr /></div><p>In every storage <span>mechanism</span><a id="id325375210" class="indexterm"></a> for data, there are four basic types of functions: <span class="strong"><strong>create</strong></span>, <span class="strong"><strong>read</strong></span>, <span class="strong"><strong>update</strong></span>, and <span class="strong"><strong>delete</strong></span> (<span class="strong"><strong>CRUD</strong></span>). These allow us to perform all the basic ways of manipulating and viewing the data that is needed for our web apps. To use these functions, we will use an object in the database named a <span class="strong"><strong>session</strong></span>. Sessions will be explained later in the chapter, but for now, think of them as a storage location for all of our changes to the database.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>Creating models</h3></div></div></div><p>To create a new row in your database <span>using</span><a id="id325378691" class="indexterm"></a> our models, add the model to the <code class="literal">session</code> and <code class="literal">commit</code> objects. Adding an object to the session marks its changes for saving. Committing is when the session is saved to the database, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; user = User(username='fake_name')</strong></span><span class="strong"><strong>&gt;&gt;&gt; db.session.add(user)</strong></span><span class="strong"><strong>&gt;&gt;&gt; db.session.commit()</strong></span></pre><p>As you can see, adding a new row to our table is simple.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Reading models</h3></div></div></div><p>After we have added data to our database, data <span>can</span><a id="id325378758" class="indexterm"></a> be queried using <code class="literal">Model.query</code>. For those who use SQLAlchemy, this is shorthand for <code class="literal">db.session.query(Model)</code>.</p><p>For our first example, use <code class="literal">all()</code> to get all rows from the user table as a list, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; users = User.query.all()</strong></span><span class="strong"><strong>&gt;&gt;&gt; users</strong></span>
    [&lt;User 'fake_name'&gt;]</pre><p> </p><p> </p><p> </p><p> </p><p>When the number of items in the database increases, this query process becomes slower. In SQLAlchemy, as in SQL, we have the <code class="literal">limit</code> function to specify the total number of rows we wish to work with:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; users = User.query.limit(10).all()</strong></span></pre><p>By default, SQLAlchemy returns the records ordered by their primary keys. To control this, we have the <code class="literal">order_by</code> function, which is given as follows:</p><pre class="programlisting"><span class="strong"><strong># ascending</strong></span><span class="strong"><strong>&gt;&gt;&gt; users = User.query.order_by(User.username).all()</strong></span><span class="strong"><strong># descending</strong></span><span class="strong"><strong>&gt;&gt;&gt; users = User.query.order_by(User.username.desc()).all()</strong></span></pre><p>To return just one record, we use <code class="literal">first()</code> instead of <code class="literal">all()</code>, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; user = User.query.first()</strong></span><span class="strong"><strong>&gt;&gt;&gt; user.username</strong></span>
fake_name</pre><p>To return one model by its primary key, use <code class="literal">query.get()</code>, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; user = User.query.get(1)</strong></span><span class="strong"><strong>&gt;&gt;&gt; </strong></span><span class="strong"><strong>user.username</strong></span>
fake_name</pre><p>All these functions are chainable, which means that they can be appended onto each other to modify the returned result. Those of you who are fluent in JavaScript will find the following syntax familiar:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; users = User.query.order_by(</strong></span><span class="strong"><strong>        User.username.desc()</strong></span><span class="strong"><strong>    ).limit(10).first()</strong></span></pre><p>The <code class="literal">first()</code> and <code class="literal">all()</code> methods return a value, and therefore end the chain.</p><p>There is also a Flask-SQLAlchemy-specific method, called <span class="strong"><strong>pagination</strong></span>, that can be used rather than <code class="literal">first()</code> or <code class="literal">all()</code>. This is a convenient method that is designed to <span>enable</span><a id="id325571021" class="indexterm"></a> the pagination feature that most websites use while displaying a long list of items. The first parameter defines which page the query should return to and the second parameter defines the number of items per page. So, if we passed <code class="literal">1</code> and <code class="literal">10</code> as the parameters, the first 10 objects would be returned.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>If we instead passed <code class="literal">2</code> and <code class="literal">10</code>, then objects 11–20 would be returned, and so on. The pagination method is different from the <code class="literal">first()</code> and <code class="literal">all()</code> methods because it returns a pagination object rather than a list of models. For example, if we want to get the first 10 items of a fictional <code class="literal">Post</code> object for the first page in our blog, we would use the following:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; User.query.paginate(1, 10)</strong></span>
&lt;flask_sqlalchemy.Pagination at 0x105118f50&gt;</pre><p>This object has several useful properties, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; page = User.query.paginate(1, 10)</strong></span><span class="strong"><strong># returns the entities in the page</strong></span><span class="strong"><strong>&gt;&gt;&gt; page.items</strong></span>
[&lt;User 'fake_name'&gt;]
<span class="strong"><strong># what page does this object represent</strong></span><span class="strong"><strong>&gt;&gt;&gt; page.page</strong></span>
1
<span class="strong"><strong># How many pages are there</strong></span><span class="strong"><strong>&gt;&gt;&gt; page.pages</strong></span>
1
<span class="strong"><strong># are there enough models to make the next or previous page</strong></span><span class="strong"><strong>&gt;&gt;&gt; page.has_prev, page.has_next</strong></span>
(False, False)
<span class="strong"><strong># return the next or previous page pagination object</strong></span><span class="strong"><strong># if one does not exist returns the current page</strong></span><span class="strong"><strong>&gt;&gt;&gt; page.prev(), page.next()</strong></span>
(&lt;flask_sqlalchemy.Pagination at 0x10812da50&gt;,
&lt;flask_sqlalchemy.Pagination at 0x1081985d0&gt;)</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec1"></a>Filtering queries</h4></div></div></div><p>Now we get to the actual power of SQL—that is, filtering <span>results</span><a id="id325570972" class="indexterm"></a> by a set of rules. To get a list of models that satisfy a set of qualities, we use the <code class="literal">query.filter_by</code> filter. The <code class="literal">query.filter_by</code> filter takes named arguments that represent the values we are looking for in each column in the database. To get a list of all users with a username of <code class="literal">fake_name</code>, we would use the following:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; users = User.query.filter_by(username='fake_name').all()</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>This example is filtering on one value, but multiple values can be passed to the <code class="literal">filter_by</code> filter. Just like our previous functions, <code class="literal">filter_by</code> is chainable, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; users = User.query.order_by(User.username.desc())</strong></span><span class="strong"><strong>        .filter_by(username='fake_name')</strong></span><span class="strong"><strong>        .limit(2)</strong></span><span class="strong"><strong>        .all()</strong></span></pre><p>The <code class="literal">query.filter_by</code> phrase only works if you know the exact values that you are looking for. This is avoided by passing Python comparison statements to the query with <code class="literal">query.filter</code>, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; user = User.query.filter(</strong></span><span class="strong"><strong>        User.id &gt; 1</strong></span><span class="strong"><strong>    ).all()</strong></span></pre><p>This is a simple example, but <code class="literal">query.filter</code> accepts any Python comparison. With common Python types, such as <code class="literal">integers</code>, <code class="literal">strings</code>, and <code class="literal">dates</code>, the <code class="literal">==</code> operator can be used for equality comparisons. If you had an <code class="literal">integer</code>, <code class="literal">float</code>, or <code class="literal">date</code> column, an inequality statement could also be passed with the <code class="literal">&gt;</code>, <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, and <code class="literal">&gt;=</code> operators.</p><p>We can also translate complex SQL queries with SQLAlchemy functions. For example, to use <code class="literal">IN</code>, <code class="literal">OR</code>, or <code class="literal">NOT</code> SQL comparisons, we would use the following:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from sqlalchemy.sql.expression import not_, or_</strong></span><span class="strong"><strong>&gt;&gt;&gt; user = User.query.filter(</strong></span><span class="strong"><strong>    User.username.in_(['fake_name']),</strong></span><span class="strong"><strong>    User.password == None</strong></span><span class="strong"><strong>).first()</strong></span><span class="strong"><strong># find all of the users with a password</strong></span><span class="strong"><strong>&gt;&gt;&gt; user = User.query.filter(</strong></span><span class="strong"><strong>    not_(User.password == None)</strong></span><span class="strong"><strong>).first()</strong></span><span class="strong"><strong># all of these methods are able to be combined</strong></span><span class="strong"><strong>&gt;&gt;&gt; user = User.query.filter(</strong></span><span class="strong"><strong>    or_(not_(User.password == None), User.id &gt;= 1)</strong></span><span class="strong"><strong>).first()</strong></span></pre><p>In SQLAlchemy, comparisons to <code class="literal">None</code> are translated to comparisons to <code class="literal">NULL</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec18"></a>Updating models</h3></div></div></div><p>To update the values of <span>models</span><a id="id325959847" class="indexterm"></a> that already exist, apply the <code class="literal">update</code> method to a query object—that is, before you return the models with a method such as <code class="literal">first()</code> or <code class="literal">all()</code>, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; User.query.filter_by(username='fake_name').update({</strong></span><span class="strong"><strong>    'password': 'test'</strong></span><span class="strong"><strong>})</strong></span><span class="strong"><strong># The updated models have already been added to the session</strong></span><span class="strong"><strong>&gt;&gt;&gt; db.session.commit()</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"></a>Deleting models</h3></div></div></div><p>If we wish to remove a model from the database, we would use the <span>following</span><a id="id326080553" class="indexterm"></a> code:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; user = User.query.filter_by(username='fake_name').first()</strong></span><span class="strong"><strong>&gt;&gt;&gt; db.session.delete(user)</strong></span><span class="strong"><strong>&gt;&gt;&gt; db.session.commit()</strong></span></pre></div></div>