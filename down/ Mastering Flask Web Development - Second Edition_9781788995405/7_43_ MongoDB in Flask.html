<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec45"></a>MongoDB in Flask</h2></div></div><hr /></div><p>MongoDB is far and away the most popular <span>NoSQL</span><a id="id324993880" class="indexterm"></a> database. MongoDB is also the best-supported NoSQL database for Flask and Python in general. Therefore, our examples will focus on MongoDB.</p><p>MongoDB is a document storage <span>NoSQL</span><a id="id325562445" class="indexterm"></a> database. Documents are stored in collections, which allow the grouping of similar documents, but no similarities between documents are necessary to store a document in a collection. Documents are defined in a JSON superset named <span class="strong"><strong>BSON</strong></span> (short for <span class="strong"><strong>Binary JSON</strong></span>). BSON allows JSON to be stored in binary format rather than in string format, saving a lot of space. BSON also distinguishes between <span>several</span><a id="id325562462" class="indexterm"></a> different ways of storing numbers, such as 32-bit integers and doubles.</p><p>To understand the basics of MongoDB, we will use <span class="strong"><strong>Flask-MongoEngine</strong></span> to cover the same functionality of Flask-SQLAlchemy in the previous chapters. Remember that these are just examples. There is no <span>benefit</span><a id="id325628494" class="indexterm"></a> of refactoring our current code to use MongoDB because MongoDB cannot offer any new functionality for our use case. New functionality with MongoDB will be shown in the next section.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec53"></a>Installing MongoDB</h3></div></div></div><p>To install MongoDB, go to <a class="ulink" href="https://www.mongodb.org/downloads" target="_blank"><span>https://www.mongodb.org/downloads</span></a> and select your OS from the tabs under the heading <strong class="userinput"><code>Download MongoDB</code></strong>. Every OS that has a supported version has installation <span>instructions</span><a id="id325628516" class="indexterm"></a> listed next to the download button of the installer.</p><p>To run MongoDB, go to Bash and <span>run</span><a id="id325921428" class="indexterm"></a> the following:</p><pre class="programlisting"><span class="strong"><strong>$ mongod</strong></span></pre><p>This will run a server for as long as the window is open.</p><p>Using Docker, you can easily launch a MongoDB server without needing to install anything else on your computer.</p><p> </p><p>To start a MongoDB server on Docker, enter the following:</p><pre class="programlisting"><span class="strong"><strong>$docker run -d -p 27017:27017 mongo:3.2.20-jessie
$docker container list
</strong></span>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
4c6706af399b mongo:3.2.20-jessie "docker-entrypoint.s…" About a minute ago Up About a minute 0.0.0.0:27017-&gt;27017/tcp silly_ardinghelli<span class="strong"><strong>
</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec54"></a>Setting up MongoEngine</h3></div></div></div><p> If you're following the example code provided <span>with</span><a id="id325921470" class="indexterm"></a> this book (which you can find at <a class="ulink" href="https://github.com/PacktPublishing/Hands-On-Web-Development-with-Flask" target="_blank">https://github.com/PacktPublishing/Hands-On-Web-Development-with-Flask</a>), then all you need to do is <span>create</span><a id="id325436792" class="indexterm"></a> a new Python virtual environment and install all the necessary dependencies. You will notice the provided<code class="literal">init.sh</code>and<code class="literal">requirements.txt</code>. Inside the<code class="literal">init.sh</code>, we have all the necessary commands to get us set up, as shown in the following code:</p><pre class="programlisting">if [ ! -d "venv" ]; then
    virtualenv venv
fi
source venv/bin/activate
pip install -r requirements.txt</pre><p>And, of course, our <span class="strong"><strong><code class="literal">requirements.txt</code> </strong></span>contains the following necessary packages:</p><pre class="programlisting">Flask
Flask-MongoEngine</pre><p>In the <code class="literal">__init__.py</code> file, a <code class="literal">mongo</code> object will be created that represents our database, as shown in the following code:</p><pre class="programlisting">from flask_mongoengine import MongoEngine

mongo = MongoEngine

def create_app(object_name):
...
    mongo.init_app(app)
...</pre><p> </p><p> </p><p>Before our app will run, our <code class="literal">DevConfig</code> object in <code class="literal">config.py</code> needs to set up the parameters of the <code class="literal">mongo</code> connection:</p><pre class="programlisting">MONGODB_SETTINGS = { 
  'db': 'local', 
  'host': 'localhost', 
  'port': 27017 
} </pre><p>These are the defaults for a brand new MongoDB installation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec55"></a>Defining documents</h3></div></div></div><p>MongoEngine is an ORM that is <span>based</span><a id="id325452438" class="indexterm"></a> around Python's object system, and is specifically designed for MongoDB. Unfortunately, there is no SQLAlchemy-style wrapper that supports all NoSQL drivers. In RDBMSes, the implementations of SQL are so similar that creating a universal interface is possible. However, the underlying implementations of each document store are different <span>enough</span><a id="id325452446" class="indexterm"></a> that the task of creating a similar interface would be more trouble than it is worth.</p><p>Each collection in your Mongo database is represented by a class that inherits from <code class="literal">mongo.Document</code>, as shown in the following code:</p><pre class="programlisting">class Post(mongo.Document): 
    title = mongo.StringField(required=True) 
    text = mongo.StringField() 
    publish_date = mongo.DateTimeField(default=datetime.datetime.now()) 
   
    def __repr__(self): 
        return "&lt;Post '{}'&gt;".format(self.title) </pre><p>Each class variable is a representation of a key belonging to a document, which is represented in this example of a <code class="literal">Post</code> class. The class variable name is used as the key in the document.</p><p>Unlike SQLAlchemy, there is no need to define a primary key. A unique ID will be generated for you under the <code class="literal">id</code> attribute. The preceding code would generate a BSON document that would resemble the following:</p><pre class="programlisting">{ 
  "_id": "55366ede8b84eb00232da905", 
  "title": "Post 0", 
  "text": "&lt;p&gt;Lorem ipsum dolor...", 
  "publish_date": {"$date": 1425255876037} 
} </pre><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec25"></a>Field types</h4></div></div></div><p>There are a large number of fields, and each <span>represents</span><a id="id325452490" class="indexterm"></a> a distinct category of data in Mongo. Unlike the underlying database, each field provides a type check before the document is allowed to be saved or altered. The most-used fields are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">BooleanField</code></li><li style="list-style-type: disc"><code class="literal">DateTimeField</code></li><li style="list-style-type: disc"><code class="literal">DictField</code></li><li style="list-style-type: disc"><code class="literal">DynamicField</code></li><li style="list-style-type: disc"><code class="literal">EmbeddedDocumentField</code></li><li style="list-style-type: disc"><code class="literal">FloatField</code></li><li style="list-style-type: disc"><code class="literal">IntField</code></li><li style="list-style-type: disc"><code class="literal">ListField</code></li><li style="list-style-type: disc"><code class="literal">ObjectIdField</code></li><li style="list-style-type: disc"><code class="literal">ReferenceField</code></li><li style="list-style-type: disc"><code class="literal">StringField</code></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note30"></a>Note</h3><p>For a full list of fields and detailed documentation, go to the MongoEngine website at <a class="ulink" href="http://docs.mongoengine.org" target="_blank"><span>http://docs.mongoengine.org</span></a>.</p></div><p>The majority of these are named after the Python type they accept and work in the same way as the SQLAlchemy types. However, there are some new types that have no counterpart in SQLAlchemy. Let's take a look at them in detail:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">DynamicField</code> is a field that can hold any type of value and performs no type checks on values.</li><li style="list-style-type: disc"><code class="literal">DictField</code> can store any Python dictionary that can be serialized by <code class="literal">json.dumps()</code>.</li><li style="list-style-type: disc"><code class="literal">ReferenceField</code> simply stores the unique ID of a document, and when queried, MongoEngine will return the referenced document.</li><li style="list-style-type: disc"><code class="literal">EmbeddedDocumentField</code> stores the passed document in the parent document, so there is no need for a second query.</li><li style="list-style-type: disc"><code class="literal">ListField</code> represents a list of fields of a specific type. This is typically used to store a list of references to other documents or a list of embedded documents to create a one-to-many relationship. If a list of unknown types is needed, then <code class="literal">DynamicField</code> can be used.</li></ul></div><p> </p><p>Each field type takes some common arguments, as shown in the following code:</p><pre class="programlisting">Field( 
  primary_key=None 
  db_field=None, 
  required=False, 
  default=None, 
  unique=False, 
  unique_with=None, 
  choices=None 
) </pre><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">primary_key</code> argument specifies that you do not want MongoEngine to autogenerate a unique key, but the value of the field should be used as the ID. The value of this field will now be accessible from both the <code class="literal">id</code> attribute and the name of the field.</li><li style="list-style-type: disc"><code class="literal">db_field</code> defines what the key will be named in each document. If it is not set, it will default to the name of the class variable.</li><li style="list-style-type: disc">If <code class="literal">required</code> is defined as <code class="literal">True</code>, then that key must be present in the document. Otherwise, the key does not have to exist for documents of that type. When a class is defined, the nonexistent key is queried, and it will return <code class="literal">None</code>.</li><li style="list-style-type: disc"><code class="literal">default</code> specifies the value that this field will be given if no value is defined.</li><li style="list-style-type: disc">If <code class="literal">unique</code> is set to <code class="literal">True</code>, then MongoEngine checks to make sure that no other documents in the collection will have the same value for this field:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">When passed a list of field names, <code class="literal">unique_with</code>will make sure that—when taken in combination—the values of all the fields will be unique for each document. This is much like multicolumn<code class="literal">UNIQUE</code>indexes in RDBMSes.</li></ul></div></li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Finally, when given a list, the <code class="literal">choices</code> option limits the allowable values for that field to the elements in the list.</li></ul></div><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec26"></a>Types of documents</h4></div></div></div><p>MongoEngine's method to define <span>documents</span><a id="id325974875" class="indexterm"></a> allows either flexibility or rigidity on a collection-by-collection basis. Inheriting from <code class="literal">mongo.Document</code> means that only the keys defined in the class can be saved to the database. Those keys defined in the class can be empty, but everything else will be ignored. On the other hand, if your class inherits <code class="literal">mongo.DynamicDocument</code>, then any extra fields that are set will be treated as <code class="literal">DynamicField</code> and will be saved with the document, as follows:</p><pre class="programlisting">class Post(mongo.DynamicDocument): 
  title = mongo.StringField(required=True, unique=True) 
  text = mongo.StringField() 
  ... </pre><p>To show the  extreme case (which is not recommended), the following class is perfectly valid; it has no required fields and allows any fields to be set:</p><pre class="programlisting">class Post(mongo.DynamicDocument): 
  pass </pre><p>The last type of document is <code class="literal">EmbeddedDocument</code>. A <code class="literal">EmbeddedDocument</code> is simply a document that is passed to <code class="literal">EmbeddedDocumentField</code> and is stored as is in the document, as follows:</p><pre class="programlisting">class Comment(mongo.EmbeddedDocument):
    name = mongo.StringField(required=True)
    text = mongo.StringField(required=True)
    date = mongo.DateTimeField(default=datetime.datetime.now())</pre><p>Why use <code class="literal">EmbeddedDocumentField</code> over <code class="literal">DictField</code> when they seem to perform the same function? The end result of using each is the same. However, an embedded document defines a structure for the data, while <code class="literal">DictField</code> can be anything. To understand this better, think of it this way: <code class="literal">Document</code> is to <code class="literal">DynamicDocument</code> what <code class="literal">EmbeddedDocument</code> is to <code class="literal">DictField</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec27"></a>The meta attribute</h4></div></div></div><p>Using the <code class="literal">meta</code> class variable, many attributes of a document can be manually set. If you are working with an existing set of data and want to connect your classes to the collections, then set the collection key of the <code class="literal">meta</code> dictionary, as follows:</p><pre class="programlisting">class Post(mongo.Document): 
  ... 
  meta = {'collection': 'user_posts'} </pre><p> </p><p>You can also manually set the maximum number of <span>documents</span><a id="id325983126" class="indexterm"></a> in the collection and the maximum size of each document. In the following example, there can be only 10,000 documents, and each document can't be larger than 2 MB:</p><pre class="programlisting">class Post(mongo.Document): 
  ... 
  meta = { 
    'collection': 'user_posts', 
    'max_documents': 10000, 
    'max_size': 2000000 
  } </pre><p>Indexes can also be set through MongoEngine. Indexes can be made single field by using a string or multifield by using a tuple, as follows:</p><pre class="programlisting">class Post(mongo.Document): 
  ... 
  meta = { 
    'collection': 'user_posts', 
    'max_documents': 10000, 
    'max_size': 2000000, 
    'indexes': [ 
      'title', 
      ('title', 'user') 
    ] 
  } </pre><p>The default ordering of a collection can be set through the <code class="literal">meta</code> variable using the <span class="strong"><strong>ordering key</strong></span>, as shown in the following code. When <code class="literal">-</code> is prepended, it tells MongoEngine to order results in descending order of that field. If <code class="literal">+</code> is prepended, it tells MongoEngine to order results in ascending order of that field. This default behavior is overridden if the <code class="literal">order_by</code> function is specified in a query, which will be shown in the <span class="emphasis"><em>CRUD</em></span> section:</p><pre class="programlisting">class Post(mongo.Document): 
  ... 
  meta = { 
    'collection': 'user_posts', 
    'max_documents': 10000, 
    'max_size': 2000000, 
    'indexes': [ 
      'title', 
      ('title', 'user') 
    ], 
    'ordering': ['-publish_date'] 
  } </pre><p> </p><p>The <code class="literal">meta</code> variable can also enable inheritance from user-defined documents, which is disabled by default. The subclass of the original document will be treated as a member of the parent class and will be stored in the same collection, as follows:</p><pre class="programlisting">class Post(mongo.Document): 
  ... 
  meta = {'allow_inheritance': True} 
 
class Announcement(Post): 
  ... </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec56"></a>CRUD</h3></div></div></div><p>As stated in <a class="link" href="#" linkend="ch02"><span>Chapter 2</span></a>, <span class="emphasis"><em>Creating Models with SQLAlchemy</em></span>, there are four main forms of data manipulation that any data store must implement. They are the <span>creation</span><a id="id325983645" class="indexterm"></a> of new data, the reading of existing data, the updating of existing data, and the deletion of data.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec28"></a>Create</h4></div></div></div><p>To create a new document, just create a new instance of the class and <span>call</span><a id="id325983660" class="indexterm"></a> the <code class="literal">save</code> method, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; post = Post()</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.title = "Post From The Console"</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.text = "Lorem Ipsum..."</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.save()</strong></span></pre><p>Otherwise, the values can be passed as keywords in the object creation, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; post = Post(title="Post From Console", text="Lorem Ipsum...")</strong></span></pre><p>Unlike SQLAlchemy, MongoEngine does not automatically save related objects that are stored in <code class="literal">ReferenceFields</code>. To save any changes to referenced documents along with the changes to the current document, pass <code class="literal">cascade</code> as <code class="literal">True</code>, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; post.save(cascade=True)</strong></span></pre><p>If you wish to insert a document and skip its checks against the defined parameters in the class definition, then pass <code class="literal">validate</code> as <code class="literal">False</code>, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; post.save(validate=False)</strong></span></pre><p></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip31"></a>Note</h3><p>Remember that these checks exist for a reason. Turn them off only for a very good reason.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch07lvl4sec0"></a>Write safety</h5></div></div></div><p>By default, MongoDB does not <span>wait</span><a id="id325985246" class="indexterm"></a> for the data to be written to disk before acknowledging that the write occurred. This means that it is possible for writes that were acknowledged to have failed, either by hardware failure or some error when the write occurred. To ensure that the data is written to disk before Mongo confirms the write, use the <code class="literal">write_concern</code> keyword. The <code class="literal">write_concern</code> parameter tells Mongo when it should return with an acknowledgement of the write, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong># will not wait for write and not notify client if there was an error</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.save(write_concern={"w": 0})</strong></span><span class="strong"><strong># default behavior, will not wait for write</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.save(write_concern={"w": 1})</strong></span><span class="strong"><strong># will wait for write</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.save(write_concern={"w": 1, "j": True})</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note32"></a>Note</h3><p>As stated in the <span class="emphasis"><em>RDBMS versus NoSQL</em></span> section, it's very important that you understand how the NoSQL database that you are using treats writes. To learn more about MongoDB's write concern, go to <a class="ulink" href="http://docs.mongodb.org/manual/reference/write-concern/" target="_blank"><span>http://docs.mongodb.org/manual/reference/write-concern/</span></a>.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec29"></a>Read</h4></div></div></div><p>The <code class="literal">objects</code> attribute is used to access the <span>documents</span><a id="id325997358" class="indexterm"></a> from the database. To read all of the documents in a collection, use the <code class="literal">all</code> method, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects.all()</strong></span><span class="strong"><strong>[&lt;Post: "Post From The Console"&gt;]</strong></span></pre><p>To limit the number of items returned, use the <code class="literal">limit</code> method as follows:</p><pre class="programlisting"><span class="strong"><strong># only return five items</strong></span><span class="strong"><strong>&gt;&gt;&gt; Post.objects.limit(5).all()</strong></span></pre><p> </p><p> </p><p>This <code class="literal">limit</code> command is slightly different than the SQL version. In SQL, the <code class="literal">limit</code> command can also be used to skip the first results. To replicate this functionality, use the <code class="literal">skip</code> method as follows:</p><pre class="programlisting"><span class="strong"><strong># skip the first 5 items and return items 6-10</strong></span><span class="strong"><strong>&gt;&gt;&gt; Post.objects.skip(5).limit(5).all()</strong></span></pre><p>By default, MongoDB returns the results in the order of the time of their creation. To control this, there is the <code class="literal">order_by</code> function, which is used as follows:</p><pre class="programlisting"><span class="strong"><strong># ascending</strong></span><span class="strong"><strong>&gt;&gt;&gt; Post.objects.order_by("+publish_date").all()</strong></span><span class="strong"><strong># descending</strong></span><span class="strong"><strong>&gt;&gt;&gt; Post.objects.order_by("-publish_date").all()</strong></span></pre><p>If you want only the first result from a query, use the <code class="literal">first</code> method. If your query returns nothing, and you expected it to, then use <code class="literal">first_or_404</code> to automatically abort with a <code class="literal">404</code> error. This acts in exactly the same way as its Flask-SQLAlchemy counterpart, and is provided by Flask-MongoEngine, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects.first()
&lt;Post: "Post From The Console"&gt;
&gt;&gt;&gt; Post.objects.first_or_404()
&lt;Post: "Post From The Console"&gt;</strong></span></pre><p>The same behavior is available for the <code class="literal">get</code> method, which expects that the query will only return one result and will raise an exception otherwise, as follows:</p><pre class="programlisting"><span class="strong"><strong># The id value will be different your document</strong></span><span class="strong"><strong>&gt;&gt;&gt; Post.objects(id="5534451d8b84ebf422c2e4c8").get()</strong></span><span class="strong"><strong>&lt;Post: "Post From The Console"&gt;
&gt;&gt;&gt; Post.objects(id="5534451d8b84ebf422c2e4c8").get_or_404()
&lt;Post: "Post From The Console"&gt;</strong></span></pre><p>The <code class="literal">paginate</code> method is also present and has the exact same API as its Flask-SQLAlchemy counterpart, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; page = Post.objects.paginate(1, 10)</strong></span><span class="strong"><strong>&gt;&gt;&gt; page.items()</strong></span><span class="strong"><strong>[&lt;Post: "Post From The Console"&gt;]</strong></span></pre><p>Also, if your document has a <code class="literal">ListField</code> method, then the <code class="literal">paginate_field</code> method on the document object can be used to paginate through the items of the list.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch07lvl4sec1"></a>Filtering</h5></div></div></div><p>If you know the exact value of the field you <span>wish</span><a id="id326034933" class="indexterm"></a> to filter by, then you can pass its value as a keyword to the <code class="literal">objects</code> method, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects(title="Post From The Console").first()</strong></span><span class="strong"><strong>&lt;Post: "Post From The Console"&gt;</strong></span></pre><p>Unlike SQLAlchemy, we cannot pass truth tests to filter our results. Instead, special keyword arguments are used to test values. For example, to find all posts published after January 1 2015, enter the following:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects(</strong></span><span class="strong"><strong>    publish_date__gt=datetime.datetime(2015, 1, 1)</strong></span><span class="strong"><strong>).all()</strong></span><span class="strong"><strong>[&lt;Post: "Post From The Console"&gt;]</strong></span></pre><p>The <code class="literal">__gt</code> appended to the end of the keyword is called an operator. MongoEngine supports the following operators:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">ne</code>: Not equal to</li><li style="list-style-type: disc"><code class="literal">lt</code>: Less than</li><li style="list-style-type: disc"><code class="literal">lte</code>: Less than or equal to</li><li style="list-style-type: disc"><code class="literal">gt</code>: Greater than</li><li style="list-style-type: disc"><code class="literal">gte</code>: Greater than or equal to</li><li style="list-style-type: disc"><code class="literal">not</code>: Negate an operator—for example, <code class="literal">publish_date__not__gt</code></li><li style="list-style-type: disc"><code class="literal">in</code>: Value is in the list</li><li style="list-style-type: disc"><code class="literal">nin</code>: Value is not in the list</li><li style="list-style-type: disc"><code class="literal">mod</code>: Value % a == b—a and b are passed as (a, b)</li><li style="list-style-type: disc"><code class="literal">all</code>: Every item in the provided list of values is in the field</li><li style="list-style-type: disc"><code class="literal">size</code>: The size of the list</li><li style="list-style-type: disc"><code class="literal">exists</code>: Value for the field exists</li></ul></div><p>MongoEngine also provides the following operators to test string values:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">exact</code>: String equals the value</li><li style="list-style-type: disc"><code class="literal">iexact</code>: String equals the value (case-insensitive)</li><li style="list-style-type: disc"><code class="literal">contains</code>: String contains the value</li><li style="list-style-type: disc"><code class="literal">icontains</code>: String contains the value (case-insensitive)
</li><li style="list-style-type: disc"><code class="literal">startswith</code>: String starts with the value</li><li style="list-style-type: disc"><code class="literal">istartswith</code>: String starts with the value (case-insensitive)</li><li style="list-style-type: disc"><code class="literal">endswith</code>: String ends with the value</li><li style="list-style-type: disc"><code class="literal">iendswith</code>: String ends with the value (case insensitive) <code class="literal">Update</code></li></ul></div><p>These operators can be combined to create the same powerful queries that were created in the previous sections. For example, to find all of the posts that were created after January 1 2015 don't use the word <code class="literal">post</code> in the title. Instead, the body text should start with the word <code class="literal">Lorem</code> and should be ordered by the publish date, starting with the latest one. You can do this using the following code:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects(</strong></span><span class="strong"><strong>    title__not__icontains="post",</strong></span><span class="strong"><strong>    text__istartswith="Lorem",</strong></span><span class="strong"><strong>    publish_date__gt=datetime.datetime(2015, 1, 1),</strong></span><span class="strong"><strong>).order_by("-publish_date").all()</strong></span></pre><p>However, if there is a complex query that cannot be represented by these tools, then a raw Mongo query can be passed as well, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects(__raw__={"title": "Post From The Console"})</strong></span></pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec30"></a>Update</h4></div></div></div><p>To update objects, the <code class="literal">update</code> method is <span>called</span><a id="id326183196" class="indexterm"></a> on the results of a query, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects(</strong></span><span class="strong"><strong>    id="5534451d8b84ebf422c2e4c8"</strong></span><span class="strong"><strong>).update(text="Ipsum lorem")</strong></span></pre><p>If your query should only return one value, then use <code class="literal">update_one</code> to only modify the first result, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects(</strong></span><span class="strong"><strong>    id="5534451d8b84ebf422c2e4c8"</strong></span><span class="strong"><strong>).update_one(text="Ipsum lorem")</strong></span></pre><p>Unlike traditional SQL, there are many different ways to change a value in MongoDB. Operators are used to change the values of a field in the following different ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">set</code>: Sets a value (same as given earlier)</li><li style="list-style-type: disc"><code class="literal">unset</code>: Deletes a value and removes the key</li><li style="list-style-type: disc"><code class="literal">inc</code>: Increments a value
</li><li style="list-style-type: disc"><code class="literal">dec</code>: Decrements a value</li><li style="list-style-type: disc"><code class="literal">push</code>: Appends a value to a list</li><li style="list-style-type: disc"><code class="literal">push_all</code>: Appends several values to a list</li><li style="list-style-type: disc"><code class="literal">pop</code>: Removes the first or last element of a list</li><li style="list-style-type: disc"><code class="literal">pull</code>: Removes a value from a list</li><li style="list-style-type: disc"><code class="literal">pull_all</code>: Removes several values from a list</li><li style="list-style-type: disc"><code class="literal">add_to_set</code>: Adds a value to a list only if it's not in the list already</li></ul></div><p>For example, if a <code class="literal">Python</code> value needs to be added to a <code class="literal">ListField</code> named tags for all <code class="literal">Post</code> documents that have the <code class="literal">MongoEngine</code> tag, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects(</strong></span><span class="strong"><strong>    tags__in="MongoEngine",</strong></span><span class="strong"><strong>    tags__not__in="Python"</strong></span><span class="strong"><strong>).update(push__tags="Python")</strong></span></pre><p>The same write concern parameters to save exist for updates, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects(</strong></span><span class="strong"><strong>    tags__in="MongoEngine"</strong></span><span class="strong"><strong>  ).update(push__tags="Python", write_concern={"w": 1, "j": True})</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec31"></a>Delete</h4></div></div></div><p>To delete a <span>document</span><a id="id326187980" class="indexterm"></a> instance, call its <code class="literal">delete</code> method as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; post = Post.objects(</strong></span><span class="strong"><strong>    id="5534451d8b84ebf422c2e4c8"</strong></span><span class="strong"><strong>).first()</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.delete()</strong></span></pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec57"></a>Relationships in NoSQL</h3></div></div></div><p>Just as we created <span>relationships</span><a id="id326189040" class="indexterm"></a> in SQLAlchemy, we can create <span>relationships</span><a id="id326189048" class="indexterm"></a> between objects in MongoEngine. Only with MongoEngine, we will be doing so without <code class="literal">JOIN</code> operators.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec32"></a>One-to-many relationships</h4></div></div></div><p>There are two ways to create a one-to-many <span>relationship</span><a id="id326189069" class="indexterm"></a> in MongoEngine. The first method is to create a relationship between two documents by using <code class="literal">ReferenceField</code> to point to the ID of another object, as follows:</p><pre class="programlisting">class Post(mongo.Document): 
  ... 
  user = mongo.ReferenceField(User) </pre><p>Accessing the property of <code class="literal">ReferenceField</code> gives us direct access to the referenced object, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; user = User.objects.first()</strong></span><span class="strong"><strong>&gt;&gt;&gt; post = Post.objects.first()</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.user = user</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.save()</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.user</strong></span>
&lt;User Jack&gt;</pre><p>Unlike SQLAlchemy, MongoEngine has no way to access objects that have relationships to other objects. With SQLAlchemy, a <code class="literal">db.relationship</code> variable could be declared, which allowed a user object to access all of the posts with a matching <code class="literal">user_id</code> column. No such variable exists in MongoEngine.</p><p>A solution is to get the user ID for the posts you wish to search for and filter with the <code class="literal">user</code> field. This is the same thing that SQLAlchemy did behind the scenes, but we are doing it manually, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; user = User.objects.first()</strong></span><span class="strong"><strong>&gt;&gt;&gt; Post.objects(user__id=user.id)</strong></span></pre><p>The second way to create a one-to-many relationship is to use <code class="literal">EmbeddedDocumentField</code> with <code class="literal">EmbeddedDocument</code>, as follows:</p><pre class="programlisting">class Post(mongo.Document): 
    title = mongo.StringField(required=True) 
    text = mongo.StringField() 
    publish_date = mongo.DateTimeField(default=datetime.datetime.now()) 
    user = mongo.ReferenceField(User) 
    comments = mongo.ListField(mongo.EmbeddedDocumentField(Comment)) </pre><p> </p><p>Accessing the <code class="literal">comments</code> property gives a list of all the embedded documents. To add a new comment to the post, treat it like a list and append <code class="literal">comment</code> documents to it, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; comment = Comment()</strong></span><span class="strong"><strong>&gt;&gt;&gt; comment.name = "Jack"</strong></span><span class="strong"><strong>&gt;&gt;&gt; comment.text = "I really like this post!"</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.comments.append(comment)</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.save()</strong></span><span class="strong"><strong>&gt;&gt;&gt; post.comments</strong></span>
[&lt;Comment 'I really like this post!'&gt;]
  </pre><p>Note that there was no call to a <code class="literal">save</code> method on the <code class="literal">comment</code> variable. This is because the comment document is not a real document; it is only an abstraction of <code class="literal">DictField</code>. Also, keep in mind that documents can only be up to 16 MB in size, so be careful how many <code class="literal">EmbeddedDocumentFields</code> are on each document and how many <code class="literal">EmbeddedDocuments</code> each one is holding.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec33"></a>Many-to-many relationships</h4></div></div></div><p>The concept of a many-to-many <span>relationship</span><a id="id325885664" class="indexterm"></a> does not exist in <span>document store databases</span>. This is because with <code class="literal">ListFields</code>, they become completely irrelevant. To idiomatically create the tag feature for the <code class="literal">Post</code> object, add a list of strings as follows:</p><pre class="programlisting">class Post(mongo.Document):
    title = mongo.StringField(required=True) 
    text = mongo.StringField() 
    publish_date = mongo.DateTimeField(default=datetime.datetime.now()) 
    user = mongo.ReferenceField(User) 
    comments = mongo.ListField(mongo.EmbeddedDocumentField(Comment)) 
    tags = mongo.ListField(mongo.StringField()) </pre><p>Now, when we wish to query for all of the <code class="literal">Post</code> objects that have a specific tag or many tags, all we need is a simple query, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Post.objects(tags__in="Python").all()</strong></span><span class="strong"><strong>&gt;&gt;&gt; Post.objects(tags__all=["Python", "MongoEngine"]).all()</strong></span></pre><p>For the list of roles on each user object, we use a list of references using the <code class="literal">ListField</code> of <code class="literal">ReferenceField(Role)</code>, as shown in the highlighted text in the following code:</p><pre class="programlisting">...
class <span class="strong"><strong>Role</strong></span>(mongo.Document):
    name = mongo.StringField(max_length=64, required=True, unique=True)
    description = mongo.StringField()
...

class User(mongo.Document):
    username = mongo.StringField(required=True)
    password = mongo.StringField()
<span class="strong"><strong>roles = mongo.ListField(mongo.ReferenceField(Role))</strong></span>
...</pre></div></div></div>