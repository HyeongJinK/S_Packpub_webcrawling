<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec41"></a>Role-based access control (RBAC)</h2></div></div><hr /></div><p>To implement a simple role-based <span>access</span><a id="id324993880" class="indexterm"></a> control system, we need to create a new database entity <code class="literal">Role</code> model that will need a many-to-many relationship for our <code class="literal">User</code> model so that a user can have multiple roles.</p><p>With our code from <a class="link" href="#" linkend="ch02"><span>Chapter 2</span></a>, <span class="emphasis"><em>Creating Models with SQLAlchemy</em></span>, adding a many-to-many relationship to the <code class="literal">User</code> object is easy, as shown in the following code: </p><pre class="programlisting">roles = db.Table(
'role_users',
db.Column('user_id', db.Integer, db.ForeignKey('user.id')),
db.Column('role_id', db.Integer, db.ForeignKey('role.id'))
)


class User(db.Model):
    ...
<span class="strong"><strong>roles = db.relationship(</strong></span>
<span class="strong"><strong>'Role',
secondary=roles,
backref=db.backref('users', lazy='dynamic')</strong></span>
<span class="strong"><strong>    )</strong></span>

def __init__(self, username=""):
<span class="strong"><strong>default = Role.query.filter_by(name="default").one()</strong></span>
<span class="strong"><strong>self.roles.append(default)</strong></span>
self.username = username

    ...
<span class="strong"><strong>def has_role(self, name):</strong></span>
<span class="strong"><strong>for role in self.roles:</strong></span>
<span class="strong"><strong>if role.name == name:</strong></span>
<span class="strong"><strong>return True
return </strong></span><span class="strong"><strong>False</strong></span>
...
class Role(db.Model):
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(80), unique=True)
    description = db.Column(db.String(255))

def __init__(self, name):
self.name = name

def __repr__(self):
return '&lt;Role {}&gt;'.format(self.name)</pre><p>Also, when a user is created, a default role is always inserted into it. Note the <code class="literal">has_role</code> method that will help us easily check whether a user has a certain role; this will be useful for templates.</p><p>Our test data Python script has already populated the <code class="literal">Role</code> model with <span>admin, poster, and default</span>.</p><p>Next, we will need a decorator function to enable RBAC in our views. Python's decorator functions are very useful, and security is certainly a context where they can be welcome. Without them, we would have to write the same code over and over again (violating the DRY principal). We need a decorator function that receives an argument—on our case, the role name—and then checks whether the user has the required role. It returns <code class="literal">HTTP 403</code> if they do not. This is enabled using the following code:</p><pre class="programlisting">import functools
...
def has_role(name):
def real_decorator(f):
def wraps(*args, **kwargs):
if current_user.has_role(name):
return f(*args, **kwargs)
else:
                abort(403)
return functools.update_wrapper(wraps, f)
return real_decorator</pre><p>The <code class="literal">functools.update_wrapper</code> is needed so that the decorated function returns the function definition instead of the wrapper definition; without it, we would lose the routing definition from Flask.</p><p>Now, we are ready to protect our <span class="strong"><strong>new post</strong></span> view and <span class="strong"><strong>edit</strong></span> view. Since only a user with the <span class="strong"><strong>poster</strong></span> role can access them, this is now very simple using the <code class="literal">has_access</code> decorator.</p><p>Look at the <code class="literal">auth/__init__.py</code> file:</p><pre class="programlisting">...
from ..auth import has_role 
...
@blog_blueprint.route('/new, methods=['GET', 'POST']) 
@login_required 
<span class="strong"><strong>@has_role('poster')</strong></span> 
def new_post(id): 
    ... </pre><p>We can also add a user check to the view, to ensure that only a user that has created a post can actually edit it. We have already disabled the edit option, but a user can always <span>access</span><a id="id325378759" class="indexterm"></a> the view by typing the URL directly in the browser.</p><p>Go to the file named <code class="literal">blog/controllers.py</code>:</p><pre class="programlisting">@blog_blueprint.route('/edit/&lt;int:id&gt;', methods=['GET', 'POST'])
@login_required
<span class="strong"><strong>@has_role('poster')</strong></span>
def edit_post(id):
    post = Post.query.get_or_404(id)
# We want admins to be able to edit any post
<span class="strong"><strong>if current_user.id == post.user.id:</strong></span>
        form = PostForm()
if form.validate_on_submit():
            post.title = form.title.data
            post.text = form.text.data
            post.publish_date = datetime.datetime.now()
            db.session.add(post)
            db.session.commit()
return redirect(url_for('.post', post_id=post.id))
        form.title.data = post.title
        form.text.data = post.text
return render_template('edit.html', form=form, post=post)
    abort(403)</pre><p>Also, in the navigation bar, we want to show the <strong class="userinput"><code>New Post</code></strong> option only to the users that have the poster role.</p></div>