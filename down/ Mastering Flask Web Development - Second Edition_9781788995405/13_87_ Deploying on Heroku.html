<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec83"></a>Deploying on Heroku</h2></div></div><hr /></div><p><span class="strong"><strong>Heroku</strong></span> is the first of the <span class="strong"><strong>Platform as a Service</strong></span> (<span class="strong"><strong>PaaS</strong></span>) providers that this <span>chapter</span><a id="id324974918" class="indexterm"></a> will cover. PaaS is a service given to web developers that allows them to host their websites on a <span>platform</span><a id="id324974924" class="indexterm"></a> that is controlled and maintained by someone else. At the cost of some freedom, you gain assurances that your website will automatically scale with the number of users your site has, with no extra work on your part. Using PaaS utilities may, however, tend to be more expensive than running your own servers.</p><p>Heroku is a PaaS utility that aims to provide ease of use to web developers by hooking into already existing tools, and not requiring any large changes in the app. Heroku works by reading a file named <code class="literal">Procfile</code>, which contains commands that your Heroku dyno (basically a virtual machine sitting on a server) will run. Before we begin, you will need a Heroku account. If you wish to just experiment, there is a free account available.</p><p>In the root of the directory, in a new file named <code class="literal">Procfile</code>, we have the following:</p><pre class="programlisting">web: uwsgi heroku-uwsgi.ini</pre><p>This tells Heroku that we have a process named <code class="literal">web</code>, which will run the uWSGI command and pass the <code class="literal">uwsgi.ini</code> file. Heroku also needs a file named <code class="literal">runtime.txt</code>, which will tell Heroku what Python runtime you wish to use—at the time of writing, the latest Python release is 3.7.0:</p><pre class="programlisting"><span class="strong"><strong>python-3.7.0</strong></span></pre><p>Next, make sure that <span class="strong"><strong>uwsgi</strong></span> is present in the <code class="literal">requirements.txt</code> file.</p><p>Finally, we need to make some modifications to the <code class="literal">uwsgi.ini</code> file that we made earlier:</p><pre class="programlisting">    [uwsgi]
    http-socket = :$(PORT)
    die-on-term = true
    wsgi-file = wsgi.py
    callable = app
    processes = 4
    threads = 2</pre><p>We set the port on which uWSGI listens to the environment variable port, because Heroku does not directly expose the dyno to the internet. Instead, it has a very complicated load balancer and reverse proxy system, so we need to have uWSGI listening on the port that Heroku needs us to listen on. Also, we set <strong class="userinput"><code>die-on-term</code></strong> to true, so that uWSGI listens for a signal termination event from the OS correctly.</p><p>To work with Heroku's command-line tools, we first need to <span>install</span><a id="id325371646" class="indexterm"></a> them, which can be done from <a class="ulink" href="https://toolbelt.heroku.com" target="_blank"><span>https://toolbelt.heroku.com</span></a>.</p><p>Next, you need to log in to your account:</p><pre class="programlisting"><span class="strong"><strong>$ heroku login</strong></span></pre><p>We can test our setup to make sure that it will work on Heroku before we deploy it, by using the <code class="literal">foreman</code> command:</p><pre class="programlisting"><span class="strong"><strong>$ foreman start web</strong></span></pre><p>The <code class="literal">foreman</code> command simulates the same production environment that Heroku uses to run our app. To create the dyno, which will run the application on Heroku's servers, we will use the <code class="literal">create</code> command. Then, we can push Heroku to the remote branch on our Git repository to have Heroku servers automatically pull down our changes:</p><pre class="programlisting"><span class="strong"><strong>$ heroku create</strong></span><span class="strong"><strong>$ git push heroku master</strong></span></pre><p>If everything went well, you should now have a working application on your new Heroku dyno. You can open a new tab to your new web application with the following command:</p><pre class="programlisting"><span class="strong"><strong>$ heroku open</strong></span></pre><p>To see the app in action in a <span>Heroku</span><a id="id325371875" class="indexterm"></a> deployment, visit <a class="ulink" href="https://mastering-flask.herokuapp.com/" target="_blank"><span>https://mastering-flask.herokuapp.com/</span></a>.</p><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec83"></a>Using Heroku Postgres</h3></div></div></div><p>Maintaining a database properly is a full-time job. Thankfully, we can use one of Heroku's built-in features in order to automate this process for us. Heroku Postgres offers a database that is maintained and hosted entirely by Heroku. Because we are using SQLAlchemy, using <span>Heroku</span><a id="id325371901" class="indexterm"></a> Postgres is trivial. In your dyno's dashboard, there is a link to your <strong class="userinput"><code>Heroku Postgres</code></strong> information. By clicking on it, you will be taken to a page similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/b910b8fa-012d-4eb0-9cab-a99015d5f328.png" /></div><p>By clicking on the <strong class="userinput"><code>URL</code></strong> field, you will be given an SQLAlchemy URL, which you can copy directly to your production configuration object.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec84"></a>Using Celery on Heroku</h3></div></div></div><p>We have our production web server and <span>database</span><a id="id325375194" class="indexterm"></a> set up, but we still need to set up Celery. Using one of Heroku's many plugins, we can host a RabbitMQ instance in the cloud, while running the <span>Celery</span><a id="id325375203" class="indexterm"></a> worker on the dyno. The first step is to tell Heroku to run your Celery worker in <code class="literal">Procfile</code>:</p><pre class="programlisting">web: uwsgi heroku-uwsgi.ini celery: celery worker -A celery_runner</pre><p>Next, to install the <span>Heroku</span><a id="id325378663" class="indexterm"></a> RabbitMQ plugin with the free plan (the <code class="literal">lemur</code> plan), use the following command:</p><pre class="programlisting"><span class="strong"><strong>$  heroku addons:create cloudamqp:lemur</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>To get the full list of Heroku add-ons, go to <a class="ulink" href="https://elements.heroku.com/addons" target="_blank"><span>https://elements.heroku.com/addons</span></a>.</p></div><p>At the same location on the dashboard where Heroku Postgres was listed, you will now find <strong class="userinput"><code>CloudAMQP</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/ef62213e-7c88-45e8-9de8-f09c5eb79215.png" /></div><p>Clicking on <strong class="userinput"><code>CloudAMQP</code></strong> will also give you a screen with a URL, which you <span>can</span> copy and paste into your production configuration:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/ebd05592-db8b-4907-a13b-dcac1be472b4.png" /></div></div></div>