<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch12lvl1sec77"></a>Unit testing the application</h2></div></div><hr /></div><p><span class="strong"><strong>Unit testing</strong></span><span>in Python</span> works by combining <code class="literal">assert</code> statements into their <span>own</span><a id="id324974955" class="indexterm"></a> functions inside a class. This <span class="emphasis"><em>collection of testing functions</em></span> inside the class is called a <span class="strong"><strong>test case</strong></span>. Each function <span>inside</span><a id="id325368993" class="indexterm"></a> the test case should test only one thing, which is the main idea behind unit testing. Testing only one thing in your unit tests forces you to verify each piece of code individually, and not gloss over any of the functionality of your code. If you write your unit tests correctly, you will end up with lots and lots of them. While this may seem overly verbose, it will save you from headaches further down the road.</p><p>In this configuration, we will use SQLLite in the <span>memory</span> engine database, which allows us to guarantee that the tests will not interfere with our actual database. Also, the configuration disables WTForms' CSRF checks, to allow us to submit forms from the tests without the CSRF token:</p><pre class="programlisting">class TestConfig(Config):

    DEBUG = True
DEBUG_TB_ENABLED = False
SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
SQLALCHEMY_TRACK_MODIFICATIONS = False
CACHE_TYPE = 'null'
WTF_CSRF_ENABLED = False

CELERY_BROKER_URL = "amqp://guest:guest@localhost:5672//"
CELERY_BACKEND_URL = "amqp://guest:guest@localhost:5672//"

MAIL_SERVER = 'localhost'
MAIL_PORT = 25
MAIL_USERNAME = 'username'
MAIL_PASSWORD = 'password'
</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec76"></a>Testing the route functions</h3></div></div></div><p>Let's build our first test case. In this test case, we will be <span>testing</span><a id="id325371649" class="indexterm"></a> if the route <span>functions</span><a id="id325371657" class="indexterm"></a> successfully return a response when we access its URL. In a new directory named <code class="literal">tests</code>, at the root of the project directory, create a new file named <code class="literal">test_urls.py</code>, which will hold all of the unit tests for the routes. Each test case should have its own file, and each test case should focus on one area of the code that you are testing.</p><p> </p><p>In <code class="literal">test_urls.py</code>, let's start creating what the built-in Python <code class="literal">unittest</code> library needs. The code will use the <code class="literal">unittest</code> library from Python in order to run all the tests that we create in the test case:</p><pre class="programlisting">import unittest 
 
class TestURLs(unittest.TestCase): 
    pass 
 
if __name__ == '__main__': 
    unittest.main() </pre><p>Let's see what happens when this code is run. We will use the <code class="literal">unittest</code> library's ability to automatically find our test cases to run the tests. The pattern that the <code class="literal">unittest</code> library looks for is <code class="literal">test*.py</code>:</p><pre class="programlisting"><span class="strong"><strong>$ python -m unittest discover</strong></span>
    
---------------------------------------------------------------------
Ran 0 tests in 0.000s
    
OK</pre><p>Because there are no tests in the test case, the test case passed successfully.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"></a>Note</h3><p>The test script was run from the parent directory of the script, and not in the test folder itself. This is to allow imports of the application code inside the test scripts.</p></div><p>In order to test the URLs, we need to have a way to query the application's routes without actually running a server, so our requests are returned. Flask provides a way of accessing routes in tests, called the <span class="emphasis"><em>test client</em></span>. The test client gives methods to create HTTP requests on our routes, without having to actually run the application with <code class="literal">app.run()</code>.</p><p>We will need the test client object for each of the tests in this test case, but adding in code to each <code class="literal">unittest</code> to create the test client doesn't make much sense when we have the <code class="literal">setUp</code> method. The <code class="literal">setUp</code> method is run before each unit test, and can attach variables to itself in order for the test method to access them. In our <code class="literal">setUp</code> method, we need to create the application object with our <code class="literal">TestConfig</code> object and create the test client.</p><p> </p><p> </p><p>Also, there are three bugs that we need to work around. The first two are in the Flask Admin and <span>Flask Restful</span> extensions, which do not remove the Blueprint objects stored internally when the application object they are applied to is destroyed. Third, Flask SQLAlchemy's initializer doesn't correctly add the application object while outside the <code class="literal">webapp</code> directory:</p><pre class="programlisting">class TestURLs(unittest.TestCase):

def setUp(self):
        admin._views = []
        rest_api.resources = []

        app = create_app('config.TestConfig')
self.client = app.test_client()
        db.app = app
        db.create_all()</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note41"></a>Note</h3><p>All of the bugs listed here existed at the time of writing, but may no longer exist when you read this chapter.</p></div><p>Along with the <code class="literal">setUp</code> method, there is also the <code class="literal">tearDown</code> method, which is run every time a unit test ends. The <code class="literal">tearDown</code> method's goal is to destroy any objects, created in the <code class="literal">setUp</code> method, that cannot automatically be deleted or closed. In our case, we will use the<code class="literal">tearDown</code>method to close and remove our database sessions, as follows:</p><pre class="programlisting">class TestURLs(unittest.TestCase): 
    def setUp(self): 
        ... 
 
    def tearDown(self): 
        db.session.remove()</pre><p>Now we can create our first unit test. The first test will test whether accessing the root of our application returns a <code class="literal">302 redirect</code> code to the blog home page, as follows:</p><pre class="programlisting">class TestURLs(unittest.TestCase): 
    def setUp(self): 
        ... 
 
    def tearDown(self): 
        ... 
 
    def test_root_redirect(self): 
        """ Tests if the root URL gives a 302 """ 
 
        result = self.client.get('/') 
        assert result.status_code == 302 
        assert "/blog/" in result.headers['Location'] </pre><p>Each unit test must start with the word <code class="literal">test</code> to tell the <code class="literal">unittest</code> library that the function is a unit test, and not just some utility function inside the test case class.</p><p>Now, if we run the tests again, we can see its progress and how it passes the checks:</p><pre class="programlisting"><span class="strong"><strong>$ python -m unittest discover</strong></span><span class="strong"><strong>.</strong></span>
    ---------------------------------------------------------------------
    Ran 1 tests in 0.128s
    
    OK
  </pre><p>The best way to write tests is to ask yourself what you are looking for ahead of time, write the <code class="literal">assert</code> statements, and write the code needed to execute those asserts. This forces you to ask what you are really testing, before you actually start writing the test. It's also the practice to write a Python doc string for each unit test, as it will be printed with the name of the test whenever the test fails. After you write 50 or more tests, this can be very helpful to know exactly what the test is for.</p><p>Rather than using the built-in <code class="literal">assert</code> keyword from Python, we can use some of the methods provided by the <code class="literal">unittest</code> library. These methods provide specialized error messages and debug information when the <code class="literal">assert</code> statements inside these functions fail.</p><p>The following is a list of all of the special <code class="literal">assert</code> statements given by the <code class="literal">unittest</code> library and what they do:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">assertEqual(x, y)</code>: Asserts that <code class="literal">x == y</code></li><li style="list-style-type: disc"><code class="literal">assertNotEqual(x, y)</code>: Asserts that <code class="literal">x != y</code></li><li style="list-style-type: disc"><code class="literal">assertTrue(x)</code>: Asserts that <code class="literal">x</code> is <code class="literal">True</code></li><li style="list-style-type: disc"><code class="literal">assertFalse(x)</code>: Asserts that <code class="literal">x</code> is <code class="literal">False</code></li><li style="list-style-type: disc"><code class="literal">assertIs(x, y)</code>: Asserts that <code class="literal">x</code> is <code class="literal">y</code></li><li style="list-style-type: disc"><code class="literal">assertIsNot(x, y)</code>: Asserts that <code class="literal">x</code> is not <code class="literal">y</code></li><li style="list-style-type: disc"><code class="literal">assertIsNone(x)</code>: Asserts that <code class="literal">x</code> is <code class="literal">None</code></li><li style="list-style-type: disc"><code class="literal">assertIsNotNone(x)</code>: Asserts that <code class="literal">x</code> is not <code class="literal">None</code></li><li style="list-style-type: disc"><code class="literal">assertIn(x, y)</code>: Asserts that <code class="literal">y</code> contains <code class="literal">x</code></li><li style="list-style-type: disc"><code class="literal">assertNotIn(x, y)</code>: Asserts that <code class="literal">x</code> is not in <code class="literal">y</code></li><li style="list-style-type: disc"><code class="literal">assertIsInstance(x, y)</code>: Asserts that <code class="literal">isinstance(x, y)</code></li><li style="list-style-type: disc"><code class="literal">assertNotIsInstance(x, y)</code>: <span>Asserts not</span> <code class="literal">isinstance(x, y)</code></li></ul></div><p> </p><p>If we wanted to test the return value of a normal page, the unit test would look like this:</p><pre class="programlisting">class TestURLs(unittest.TestCase): 
    def setUp(self): 
        ... 
 
    def tearDown(self): 
        ... 
 
    def test_root_redirect(self): 
        ... 
 
    def test_blog_home(self): 
        """ Tests if the blog home page returns successfully """ 
        result = self.client.get('/blog/')
        self.assertEqual(result.status_code, 200)</pre><p>Remember that the preceding code only tests if the URLs give returns successfully. The content of the return data is not a part of these tests.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec77"></a>Testing security</h3></div></div></div><p>Testing security is obviously very important—if you expose your application to the web, you can be sure that your security will be heavily tested, and not for the right reasons. All of your secured endpoints will be <span>tested</span><a id="id325633110" class="indexterm"></a> and exploited if not correctly secured. First of all, we should test our login and logout processes.</p><p>If we wanted to test submitting a form, such as the login form, we can use the <span>post</span> method of the test client. Let's create a <code class="literal">test_login</code> method to see if the login form works correctly:</p><pre class="programlisting">class TestURLs(unittest.TestCase):
....

def _insert_user(self, username, password, role_name):
        test_role = Role(role_name)
        db.session.add(test_role)
        db.session.commit()

        test_user = User(username)
        test_user.set_password(password)
        db.session.add(test_user)
        db.session.commit()

def test_login(self):
""" Tests if the login form works correctly """

result = self.client.post('/auth/login', data=dict(
username='test',
password="test"
), follow_redirects=True)

self.assertEqual(result.status_code, 200)
self.assertIn('You have been logged in', result.data)
...</pre><p>The additional check for the string in the return data exists because the return code is not affected by the validity of the entered data. The <code class="literal">post</code> method will work for testing any of the form objects we have created throughout the book.</p><p>Now, let's create a failed login attempt:</p><pre class="programlisting">def test_failed_login(self):
self._insert_user('test', 'test', 'default')
    result = self.client.post('/auth/login', data=dict(
username='test',
password="badpassword"
), follow_redirects=True)

self.assertEqual(result.status_code, 200)
self.assertIn('Invalid username or password', result.data)
    result = self.client.get('/blog/new')
self.assertEqual(result.status_code, 302)</pre><p>In the preceding snippet, we make sure that a login attempt with failed credentials does not give the user a successful login, and in the same test, we also make sure that a failed login will not give the user sufficient access to add a new blog post. This may seem trivial, and it is easy to implement, but as previously stated, you should make each test simple, and only test one thing with each test, but aim to cover all your features and possibilities.</p><p>Another example of an important test covers unauthorized access from a logged-in user:</p><pre class="programlisting">def test_unauthorized_access_to_admin(self):
self._insert_user('test', 'test', 'default')
result = self.client.post('/auth/login', data=dict(
username='test',
password="test"
), follow_redirects=True)
    result = self.client.get('/admin/customview/')
self.assertEqual(result.status_code, 403)</pre><p>Here, we make sure that a low-privileged user does not have access to an high privilege area of our application: the admin interface.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec78"></a>Testing the REST API </h3></div></div></div><p>Still in the context of security, we will <span>now</span><a id="id325648629" class="indexterm"></a> learn how to test our <span>REST</span><a id="id325648637" class="indexterm"></a> API. Remember that we have implemented JWT security, so for each request, we need to use a previously acquired access token.</p><p>JWT authentication tests should look like this:</p><pre class="programlisting">def test_api_jwt_login(self):
self._insert_user('test', 'test', 'default')
    headers = {'content-type': 'application/json'}
    result = self.client.post('/auth/api', headers=headers, data='{"username":"test","password":"test"}')
self.assertEqual(result.status_code, 200)

def test_api_jwt_failed_login(self):
self._insert_user('test', 'test', 'default')
    headers = {'content-type': 'application/json'}
    result = self.client.post('/auth/api', headers=headers, data='{"username":"test","password":"test123"}')
self.assertEqual(result.status_code, 401)</pre><p>Some important details to note here <span>include the way we set our HTTP header to JSON, and how we pass the JSON payload on the HTTP POST method</span>—this will happen on all our REST API tests.</p><p>Next, let's see how to develop a test for the new post REST API. <code class="literal">/api/post</code> is the endpoint for blog posts, and the POST HTTP method is the method for adding a new post to the <span>Blog</span> application. Revisit <span><a class="link" href="#" linkend="ch08">Chapter 8</a>, <span class="emphasis"><em>Building RESTful APIs</em></span></span> if this is not clear.</p><pre class="programlisting">def test_api_new_post(self):
self._insert_user('test', 'test', 'default')
    headers = {'content-type': 'application/json'}
    result = self.client.post('/auth/api', headers=headers, data='{"username":"test","password":"test"}')
<span class="strong"><strong>access_token = json.loads(result.data)['access_token']</strong></span>
<span class="strong"><strong>    headers['Authorization'] = "Bearer %s" % access_token</strong></span>
    result = self.client.post('api/post', headers=headers, data='{"title":"Text Title","text":"Changed"}')
self.assertEqual(result.status_code, 201)</pre><p> </p><p>Once again, this is a simple test to develop—notice the way that we request an access token from our authentication JWT API using the <code class="literal">/auth/api</code> endpoint, and how we use it to make the call to <code class="literal">/api/post</code>. <span>has expected the access token is used to</span> construct the HTTP authorization header using the form <code class="literal">Authorization: Bearer &lt;ACCESS_TOKEN&gt;</code>. This can be a bit cumbersome to repeat on each API test, so make sure to write a helper function to keep your code "DRY"—that is, "Don't Repeat Yourself".</p><p>Now that you understand the mechanics of unit testing, you can use unit testing in order to test all the parts of your application. This can include testing all the routes in the application; testing any utility function that we have made, such as <code class="literal">sidebar_data</code>; and testing all possible combinations of roles and access protected pages.</p><p>If your application's code has a feature, no matter how small, you should have a test for it. Why? Because whatever can go wrong, will go wrong. If the validity of your application's code relies entirely on manual testing, then something is going to get overlooked as your app grows. When something gets overlooked, then broken code is deployed to live servers, which annoys your users.</p></div></div>