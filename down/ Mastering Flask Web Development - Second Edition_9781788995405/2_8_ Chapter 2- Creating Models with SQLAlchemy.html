<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch02"></a>Chapter 2. Creating Models with SQLAlchemy</h2></div></div></div><p>As we saw in the last chapter, models are a means of abstracting and providing a common interface to access data. In most web applications, data is stored and retrieved from a <span class="strong"><strong>relational database management system</strong></span> (<span class="strong"><strong>RDBMS</strong></span>), which is a database that holds data in a tabular format with <span>rows</span><a id="id325015011" class="indexterm"></a> and columns and is able to implement a relational model with data across tables. Some examples include MySQL, Postgres, Oracle, and MSSQL.</p><p>In order to create models on top of our database, we will use a <span>Python</span><a id="id325368978" class="indexterm"></a> package named <span class="strong"><strong>SQLAlchemy</strong></span>. SQLAlchemy is a database API at its lowest level, and performs <span class="strong"><strong>object relational mapping</strong></span> at its highest level. An <span class="strong"><strong>ORM</strong></span> (<span class="strong"><strong>object relational mapper</strong></span>) is a tool that allows <span>developers</span><a id="id325371859" class="indexterm"></a> to store and retrieve data using object-oriented approaches and solve object-relational mismatches—a set of conceptual and technical difficulties that are often encountered when a relational database management system is being used by a program that is written in an object-oriented programming language. Relational and object-oriented models are so different that additional code and <span>functionalities</span><a id="id325371865" class="indexterm"></a> are required to make them work together efficiently. This creates a virtual object database and converts data between the large number of types in databases into the mix of types and objects in Python. Also, a programming language, such as Python, allows you to have different objects that hold references to each other, and to get and set their attributes. An ORM, such as SQLAlchemy, helps translate these when inserting them into a traditional database.</p><p>In order to tie SQLAlchemy into our application context, we will use <span class="strong"><strong>Flask SQLAlchemy</strong></span>. Flask SQLAlchemy is a convenience layer on top of SQLAlchemy that <span>provides</span><a id="id325371878" class="indexterm"></a> useful defaults and Flask-specific functions. If you are already familiar with SQLAlchemy, then you are free to use it without Flask SQLAlchemy.</p><p>By the end of this chapter, we will have a full database schema of our blogging application, as well as models that interact with that schema.</p><p> </p><p>In this chapter, we'll cover the following topics: </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Designing database tables and relationships using SQLAlchemy</li><li style="list-style-type: disc">Creating, reading, updating, and deleting models</li><li style="list-style-type: disc">Learning to define model relationships, constraints, and indexes</li><li style="list-style-type: disc">Creating automatic database migrations</li></ul></div></div>