<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec31"></a>Class-based views</h2></div></div><hr /></div><p>In most Flask apps, views are handled by functions. However, when <span>many</span><a id="id324847030" class="indexterm"></a> views share common functionality or there are pieces of your code that could be broken out into separate functions, it would be useful to implement our views as classes to take advantage of inheritance.</p><p>For example, if we have views that render a template, we could create a generic view class that keeps our code <span class="emphasis"><em>DRY</em></span>:</p><pre class="programlisting">from flask.views import View 
 
class GenericView(View): 
    def __init__(self, template): 
        self.template = template 
        super(GenericView, self).__init__() 
 
    def dispatch_request(self): 
        return render_template(self.template) 
 
app.add_url_rule( 
    '/', view_func=GenericView.as_view( 
        'home', template='home.html' 
    ) 
)</pre><p>The first thing to note about this code is the <code class="literal">dispatch_request()</code> function in our view class. This is the function in our view that acts as the normal view function and returns an HTML string. The <code class="literal">app.add_url_rule()</code> function mimics the <code class="literal">app.route()</code> function as it ties a route to a function call. The first argument defines the route of the function, and the <code class="literal">view_func</code> parameter defines the function that handles the route. The <code class="literal">View.as_view()</code> method is passed to the <code class="literal">view_func</code> parameter because it transforms the <code class="literal">View</code> class into a view function. The first argument defines the name of the view function, so functions such as <code class="literal">url_for()</code> can route to it. The remaining parameters are passed to the <code class="literal">__init__</code> function of the <code class="literal">View</code> class.</p><p>Like the normal view functions, HTTP methods other than <code class="literal">GET</code> must be explicitly allowed for the <code class="literal">View</code> class. To allow other methods, a class variable containing the list of named methods must be added:</p><pre class="programlisting">class GenericView(View): 
    methods = ['GET', 'POST'] 
    ... 
    def dispatch_request(self): 
        if request.method == 'GET': 
            return render_template(self.template) 
        elif request.method == 'POST': 
            ... </pre><p>This can be a very powerful approach. Take for example web pages that render tabular lists from database tables; they are almost identical, so are nice candidates for generic approaches. Although not a trivial task to carry out, the time you take to implement it can save you time in the future. An initial skeleton using class-based views could be this:</p><pre class="programlisting">from flask.views import View


class GenericListView(View):

def __init__(self, model, list_template='generic_list.html'):
self.model = model
self.list_template = list_template
<span class="strong"><strong>self.columns = self.model.__mapper__.columns.keys()</strong></span>
# Call super python3 style
super(GenericListView, self).__init__()

def render_template(self, context):
return render_template(self.list_template, **context)

def get_objects(self):
return self.model.query.all()

def dispatch_request(self):
<span class="strong"><strong>context = {'objects': self.get_objects(),
'columns': self.columns}</strong></span>
return self.render_template(context)


app.add_url_rule(
'/generic_posts', view_func=GenericListView.as_view(
'generic_posts', model=Post)
    )

app.add_url_rule(
'/generic_users', view_func=GenericListView.as_view(
'generic_users', model=User)
)

app.add_url_rule(
'/generic_comments', view_func=GenericListView.as_view(
'generic_comments', model=Comment)
)</pre><p> </p><p>There are some interesting things to notice. First, in the class constructor we initialize the <code class="literal">columns</code> class property with the SQLAlchemy model columns; we are leveraging the model introspection ability of SQLAlchemy to be able to implement our generic template. So, column names are going to be passed to our generic template so that we can properly render a well formatted tabular list for any model we throw at it. </p><p>This is a simple example of how, with a single class view, we handle all list views from all our models.</p><p>This is how the template looks like:</p><pre class="programlisting">{% extends "base.html" %}
{% block body %}

&lt;div class="table-responsive"&gt;
    &lt;table class="table table-bordered table-hover"&gt;
{% for obj in objects %}
&lt;tr&gt;
{% for col in columns %}
&lt;td&gt;
{{col}} {{ obj[col] }}
&lt;/td&gt;
{% endfor %}
&lt;/tr&gt;
{% endfor %}
&lt;/table&gt;
&lt;/div&gt;

{% endblock %}</pre><p>You can access these views by running the example code <span>provided</span><a id="id325378686" class="indexterm"></a> for this chapter, then directly accessing the declared URLs: </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">http://localhost:5000/generic_users</code></li><li style="list-style-type: disc"><code class="literal">http://localhost:5000/generic_posts</code></li><li style="list-style-type: disc"><code class="literal">http://localhost:5000/generic_comments</code></li></ul></div><p>You may have noticed that our tabular view is missing the table column headers. As an exercise, I challenge you to implement it; you can simply render the provided <code class="literal">columns</code> class property, or even better, use a label/column mapping to display more user-friendly column names.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec33"></a>Method class views</h3></div></div></div><p>Often, when functions handle multiple HTTP methods, the code can <span>become</span><a id="id325378754" class="indexterm"></a> difficult to read due to large sections of code nested within <code class="literal">if</code> statements, as demonstrated in the following:</p><pre class="programlisting">@app.route('/user', methods=['GET', 'POST', 'PUT', 'DELETE']) 
def users(): 
    if request.method == 'GET': 
        ... 
    elif request.method == 'POST': 
        ... 
    elif request.method == 'PUT': 
        ... 
    elif request.method == 'DELETE': 
        ... </pre><p>This can be solved with the <code class="literal">MethodView</code> class. <code class="literal">MethodView</code> allows each method to be handled by a different class method to separate concerns:</p><pre class="programlisting">from flask.views import MethodView 
 
class UserView(MethodView): 
    def get(self): 
        ... 
    def post(self): 
        ... 
    def put(self): 
        ... 
    def delete(self): 
        ... 
 
app.add_url_rule( 
    '/user', 
    view_func=UserView.as_view('user') 
) </pre></div></div>