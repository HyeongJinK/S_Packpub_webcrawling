<div class="chapter" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ch09"></a>Chapter 9. Creating Asynchronous Tasks with Celery</h2></div></div></div><p>While creating web apps, it is vital to keep the time taken to process a request below or around 50 ms. On web applications or web services that have a medium to high rate of requests per second, response time becomes even more paramount. Think of requests such as a flow of liquid that needs to be handled at least as quickly as its flow rate, or else it will overflow. Any extra processing on the server that can be avoided, should be avoided. However, it is quite common to have requirements to operations in a web app that take longer than a couple of seconds, especially when complex database operations or image processing are involved. </p><p>In building an application that is able to scale horizontally, it should be possible to decouple all the heavy processing procedures from the web server's layer, <span>and couple them</span> to a worker's layer that can independently scale itself.</p><p>To protect our user experience and site reliability, a task queue named Celery will be used to move these operations out of the Flask process.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Using Docker to run RabbitMQ and Redis</li><li style="list-style-type: disc">Celery and Flask integration</li><li style="list-style-type: disc">Learning to identify processes that should run outside the web server</li><li style="list-style-type: disc">Creating and calling several types of tasks from simple asynchronous to complex workflows</li><li style="list-style-type: disc">Using Celery as a scheduler with beats</li></ul></div><p> </p></div>