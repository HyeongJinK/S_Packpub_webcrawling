<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec14"></a>The beginning of our project</h2></div></div><hr /></div><p>Finally, we can get to our first <span>Flask</span><a id="id325375190" class="indexterm"></a> project. In order to build a complex project at the end of this book, we will need a simple Flask project to start us off.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec10"></a>Simple application</h3></div></div></div><p><span>Flask</span><a id="id325378666" class="indexterm"></a> is very powerful, <span>but will most definitely not get in your way</span>. You can use it to create a simple web application using a single file. Our aim is to create a project that is structured in a way that it can scale and be easy to understand. For now, we will create a <code class="literal">config</code> file first. In the file named <code class="literal">config.py</code>, add the following:</p><pre class="programlisting">class Config(object): 
    pass 
 
class ProdConfig(Config): 
    pass 
 
class DevConfig(Config): 
    DEBUG = True </pre><p>Now, in another file named <code class="literal">main.py</code>, add the following:</p><pre class="programlisting">from flask import Flask 
from config import DevConfig 
 
app = Flask(__name__) 
app.config.from_object(DevConfig) 
 
@app.route('/') 
def home(): 
    return '&lt;h1&gt;Hello World!&lt;/h1&gt;' 
 
if __name__ == '__main__': 
    app.run() </pre><p>For anyone who is familiar with the base Flask API, this program is very basic. It will simply show <code class="literal">Hello World!</code> on the browser if we navigate to <code class="literal"><span>http://127.0.0.1:5000</span></code>. One point that may be unfamiliar to Flask users is the use of the phrase <code class="literal">config.from_object</code> rather than <code class="literal">app.config['DEBUG']</code>. We use <code class="literal">from_object</code> because in future, multiple configurations will be used, and manually changing every variable when we need to switch between configurations is time consuming.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec11"></a>Project structure</h3></div></div></div><p>We have created a very simple project structure, but can it <span>serve</span><a id="id326156227" class="indexterm"></a> as the base skeleton for any Python project. In <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Advanced Application Structure</em></span>, we will get our hands on a more scalable structure, but for now, let's go back to our environment, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>Dockerfile</strong></span> # Instructions to configure and run our application on a container
<span class="strong"><strong>requirements.txt</strong></span> # All the dependencies needed to run our application
<span class="strong"><strong>/venv</strong></span> # We will not add this folder to our Git repo, our virtualenv
<span class="strong"><strong>.gitignore</strong></span> # Instruction for Git to ignore files
<span class="strong"><strong>main.py</strong></span> # Our main Flask application
<span class="strong"><strong>config.py</strong></span> # Our configuration file</pre><p>Remember to commit these changes in Git, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong># The --all flag will tell git to stage all changes you have made</strong></span><span class="strong"><strong># including deletions and new files</strong></span><span class="strong"><strong>$ git add --all</strong></span><span class="strong"><strong>$ git commit -m" ""created the base application"</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note7"></a>Note</h3><p>You will no longer be reminded of when to commit your changes to Git. It is up to you to develop the habit of committing whenever you reach a stopping point. It is also assumed that you will be operating inside the virtual environment, so all command-line prompts will not be prefixed with <code class="literal">(env)</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec12"></a>Using Flask's command-line interface</h3></div></div></div><p>In order to make the next chapters easier for the reader, we will look at how to use the Flask CLI (using version 0.11 onward). The CLI allows programmers to create commands that act within the <span class="strong"><strong>application context</strong></span> of Flask—that is, the state in Flask that allows the <span>modification</span><a id="id326156311" class="indexterm"></a> of the <code class="literal">Flask</code> object. The Flask CLI comes with some default commands to run the server and a Python shell in the application context.</p><p>Let's take a look at the Flask CLI and how to initialize it. First, we must tell it how to discover our application using the following code:</p><pre class="programlisting"><span class="strong"><strong>$</strong></span><span class="strong"><strong>export FLASK_APP=main.py</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>Then, we will use the Flask CLI to run our application using the following code:</p><pre class="programlisting"><span class="strong"><strong>$ flask run</strong></span></pre><p>Now, let's enter the shell on the application context and see how to get all the defined URL routes, using the following code:</p><pre class="programlisting"><span class="strong"><strong>$ flask shell
</strong></span>Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 03:03:55)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
App: main [debug]
Instance: /chapter_1/instance<span class="strong"><strong>
&gt;&gt;&gt; app.url_map
Map([&lt;Rule '/' (OPTIONS, GET, HEAD) -&gt; home&gt;,
 &lt;Rule '/static/&lt;filename&gt;' (OPTIONS, GET, HEAD) -&gt; static&gt;])</strong></span></pre><p>As you can see, we already have two routes defined: the <code class="literal">/</code> where we display the "<code class="literal">Hello World</code>" sentence and the static default route created by Flask. Some other useful information shows where Flask thinks our templates and static folders are, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; app.static_folder</strong></span>
<span class="strong"><strong>/chapter_1/static'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; app.template_folder</strong></span>
<span class="strong"><strong>'templates'</strong></span></pre><p>Flask CLI, uses the <code class="literal">click</code> library from the creator of Flask itself. It was designed to be easily extensible so that the Flask extensions can extend it and implement new commands that are available when you use them. We should indeed extend it—it makes it more useful to extend it ourselves. This is the right way to create management commands for our applications. Think about commands that you can use to migrate database schemas, create users, prune data, and so on.</p></div></div>