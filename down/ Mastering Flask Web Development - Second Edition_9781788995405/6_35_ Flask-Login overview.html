<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec38"></a>Flask-Login overview</h2></div></div><hr /></div><p>Flask-Login is a popular Flask extension for <span>handling</span><a id="id325015008" class="indexterm"></a> the process of logging users in and out, properly handling cookie sessions, and even using basic authentication with HTTP headers. It will set up callbacks for user loading, header authentication, logging in, logging out, unauthorized events, and so on.</p><p>To start using Flask-Login, we first need to declare it as a dependency on our <code class="literal">requirements.txt</code>, as shown in the following code:</p><pre class="programlisting">...
Flask-Login
...</pre><p>Then, we need to update our Python virtual environment as follows:</p><pre class="programlisting"><span class="strong"><strong>$ source venv/bin/activate</strong></span>
<span class="strong"><strong>$ pip install -r requirements.txt</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note28"></a>Note</h3><p>If you have executed the provided <code class="literal">init.sh</code> script, then there is no need to update the <code class="literal">virtualenv</code>. All the required dependencies for this chapter are already installed.</p></div><p>To use the session and login flow implemented by Flask-Login, we will need to do the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Change the user model and implement the following functions:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">is_authenticated</code>: This checks whether the current user is authenticated</li><li style="list-style-type: disc"><code class="literal">is_active</code>: This checks whether a user is active</li><li style="list-style-type: disc"><code class="literal">is_anonymous</code>: This supports anonymous accesses to our blog</li><li style="list-style-type: disc"><code class="literal">get_id</code>: This fetches the user ID</li></ul></div></li><li style="list-style-type: disc">Initialize and configure the login manager object, declaring the following:
<div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Where our login view is (URL)</li><li style="list-style-type: disc">The type of session</li><li style="list-style-type: disc">The login message (flashed login message)</li><li style="list-style-type: disc">The special user class for anonymous users</li><li style="list-style-type: disc">Register and implement a function to load our authenticated user</li><li style="list-style-type: disc">A function that returns a user object by its ID</li></ul></div></li></ul></div><p> </p><p>Flask-Login is agnostic as to our authentication method, so the authentication system itself needs be implemented.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec40"></a>Setting up</h3></div></div></div><p>To implement the user authentication system, we <span>will</span><a id="id325371888" class="indexterm"></a> develop a new module in our application by following the rules that were previously proposed in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Advanced Application Structure</em></span>. Our application structure will be as follows:</p><pre class="programlisting">./
  config.py
  manage.py
  main.py
  config.py 
  database.db 
  webapp/ 
    __init__.py
    blog/
      __init__.py 
      controllers.py
      forms.py
      models.py
<span class="strong"><strong>auth/</strong></span>
<span class="strong"><strong>      __init__.py</strong></span>
<span class="strong"><strong>      controllers.py</strong></span>
<span class="strong"><strong>      models.py</strong></span>
<span class="strong"><strong>      forms.py</strong></span>
    main/
      __init__.py
      controllers.py
    templates/ 
      blog/
      auth/
  migrations/ 
    versions/ </pre><p>To keep the principle of separation of concerns in our approach to our module's design, we will make a simple change to the way we register each module blueprint. This is a nice thing to have, and it's necessity is more evident now because in this chapter, we will be using lots of new extensions to implement security, and we have to initialize them, register event methods, and configure them. All of these security bootstrapping procedures are best kept in the authentication module itself. To achieve this, we will create a new method in each <code class="literal">__init__.py</code> file for each module. Let's take a look at how this is done in our blog and authentication modules:</p><p> </p><p>First, let's look at the code in the <code class="literal">blog/__<span class="strong"><strong>init__</strong></span>.py </code>file:</p><pre class="programlisting">def create_module(app, **kwargs):
from .controllers import blog_blueprint
    app.register_blueprint(blog_blueprint)</pre><p>In the authentication module, we will handle the Flask-Login configuration and initialization as previously described. The main Flask-Login object is the <code class="literal">LoginManager</code> object.</p><p>Let's look at the code in the <code class="literal">auth/__<span class="strong"><strong>init__</strong></span>.py </code>file:</p><pre class="programlisting">from flask_login import LoginManager 
 
login_manager = LoginManager()
login_manager.login_view = "auth.login" login_manager.session_protection = "strong" login_manager.login_message = "Please login to access this page" login_manager.login_message_category = "info" 

@login_manager.user_loader 
<span class="strong"><strong>def load_user(userid):</strong></span>
    from models import User
    return User.query.get(userid) 

def create_module(app, **kwargs):
    ...
<span class="strong"><strong>login_manager.init_app(app)</strong></span>
from .controllers import auth_blueprint
    app.register_blueprint(auth_blueprint)
    ...</pre><p>The preceding configuration values define which view should be treated as the login page, and what the message should be to the user after a successful login. Setting the<code class="literal">session_protection</code> option to <code class="literal">strong</code> better protects against malicious users tampering with their cookies. When a tampered cookie is identified, the session object for that user is deleted and the user is forced to log back in.</p><p>The <code class="literal">load_user</code> function takes an ID and returns the <code class="literal">User</code> object. When a cookie is validated, Flask-Login <span>will</span><a id="id325378702" class="indexterm"></a> use our function to fetch the user into the current session.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>Finally, in the <code class="literal">create_app</code> method itself, we just have to call the <code class="literal">create_module</code> <span>on</span> each module, as follows:</p><pre class="programlisting">...

def create_app(object_name):
...
app = Flask(__name__)
    app.config.from_object(object_name)

    db.init_app(app)
    migrate.init_app(app, db)

from .auth import create_module as auth_create_module
from .blog import create_module as blog_create_module
    from .main import create_module as main_create_module
    auth_create_module(app)
    blog_create_module(app)
    main_create_module(app)

return app

</pre><p>To implement an authentication system, we need a lot of setup code. To run any type of authentication, our app will need the following elements:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The user models will need proper password hashing</li><li style="list-style-type: disc">It will need to implement a system to keep a secure user session context </li><li style="list-style-type: disc">A login form and a registration form will be needed to validate user input</li><li style="list-style-type: disc">A login view and a registration view (and templates for each) will be needed</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec41"></a>Updating the models</h3></div></div></div><p>There are many hashing algorithms, most of which are not secure because they are easy to <span class="strong"><strong>brute force</strong></span>. With brute-force attacks, hackers continuously try sending data through a hashing algorithm until <span>something</span><a id="id325379658" class="indexterm"></a> matches. To best protect the user passwords, bcrypt will be our hashing algorithm of choice. Bcrypt is purposely designed to be inefficient and slow (milliseconds rather than microseconds) for the computer to process, thereby making it harder to brute force. To add bcrypt to our project, the package flask-bcrypt <span>will</span><a id="id325379665" class="indexterm"></a> need to be installed and added as a dependency on our <code class="literal">requirements.txt</code>, as follows:</p><pre class="programlisting">...
flask-bcrypt
...</pre><p>The <code class="literal">flask-bcrypt</code> package will have to be initialized. This is done in the <code class="literal">auth</code> module, <code class="literal">auth/__<span class="strong"><strong>init__</strong></span>.py</code>, as shown in the following code:</p><pre class="programlisting">...
<span class="strong"><strong>from flask.ext.bcrypt import Bcrypt 
bcrypt = Bcrypt()</strong></span>
...
def create_module(app, **kwargs):
<span class="strong"><strong>bcrypt.init_app(app)</strong></span>
    login_managet.init_app(app)

    from .controllers import auth_blueprint
    app.register_blueprint(auth_blueprint)
 ...</pre><p>Bcrypt is now ready to use. To have our <code class="literal">User</code> object use bcrypt, we will add two methods that set the password and check whether a string matches the stored hash, as follows:</p><pre class="programlisting">from . import bcrypt

class User(db.Model):
    ...
<span class="strong"><strong>def set_password(self, password):</strong></span>
<span class="strong"><strong>self.password = bcrypt.generate_password_hash(password)</strong></span>

<span class="strong"><strong>def check_password(self, password):</strong></span>
<span class="strong"><strong>return bcrypt.check_password_hash(self.password, password)
</strong></span>...</pre><p>Now, our <code class="literal">User</code> models can store passwords securely. We also need to implement the Flask-Login methods previously described for the session and authentication flow. For this, we first need to define our anonymous user object.</p><p>On the <code class="literal">auth/__<span class="strong"><strong>init__</strong></span>.py</code>, enter the following:</p><pre class="programlisting">from flask_login import AnonymousUserMixin

class BlogAnonymous(AnonymousUserMixin):
def __init__(self):
self.username = 'Guest'</pre><p> </p><p> </p><p> </p><p> </p><p>Then add our <code class="literal">is_authenticated</code> property to the user model in<code class="literal">auth/models.py</code>, as shown in the following code. If the current user is not anonymous, then it is authenticated:</p><pre class="programlisting">class User(db.model):
...
    @property
<span class="strong"><strong>    def is_authenticated(self):</strong></span>
if isinstance(self, AnonymousUserMixin):
return False
else:
return True</pre><p>Then we add the <code class="literal">is_active</code> property; <span>we will not be using it, but it checks whether the user has gone through some sort of activation process, such as an email confirmation</span>. Otherwise, it allows site administrators to ban a user without deleting their data. To implement this, we will create a new Boolean property on our user model schema definition, as follows:</p><pre class="programlisting">class User(db.model):
...
    @property
<span class="strong"><strong>    def is_active(self):</strong></span>
return True</pre><p>Finally, we add the following <code class="literal">is_active</code> property and <code class="literal">get_id</code> method, which are pretty self explanatory:</p><pre class="programlisting">class User(db.model):
...
    @property
<span class="strong"><strong>    def is_anonymous(self):</strong></span>
if isinstance(self, AnonymousUserMixin):
return True
else:
return False

<span class="strong"><strong>    def get_id(self):</strong></span>
return unicode(self.id)</pre><p>Next, our login process needs to use these methods to create new users and check passwords, and check whether a user is authenticated.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec42"></a>Creating the forms</h3></div></div></div><p>Three forms are required: a login form, a registration form, and a <span>form</span><a id="id324993912" class="indexterm"></a> for our <span class="strong"><strong>post creation</strong></span> page. The login form <span>will</span><a id="id324993925" class="indexterm"></a> have username and password fields.</p><p>The following is the code for the <code class="literal">auth/forms.py</code> file:</p><pre class="programlisting">
from wtforms import ( 
  StringField, 
  TextAreaField, 
  PasswordField, 
  BooleanField 
) 
from wtforms.validators import DataRequired, Length, EqualTo, URL 
class LoginForm(Form): 
  username = StringField('Username', [ 
    DataRequired(), Length(max=255) 
  ]) 
  password = PasswordField('Password', [DataRequired()])

  def validate(self): 
    check_validate = super(LoginForm, self).validate() 
    # if our validators do not pass 
    if not check_validate: 
      return False 
    <span class="strong"><strong># Does our user exist</strong></span>
    user = User.query.filter_by( 
      username=self.username.data 
    ).first() 
    if not user: 
      self.username.errors.append( 
        'Invalid username or password' 
      ) 
      return False 
    <span class="strong"><strong># Do the passwords match 
    if not self.user.check_password(self.password.data):</strong></span> 
      self.username.errors.append( 
        'Invalid username or password' 
      ) 
      return False 
    return True </pre><p> </p><p> </p><p> </p><p> </p><p>Along with the normal validations, our <code class="literal">LoginForm</code> method will also check whether the username that was passed exists, and will use the <code class="literal">check_password()</code> method to check the hashes. This is done by overriding the <code class="literal">validate()</code> method called on the form <code class="literal">POST</code> requests. Here, we will first check whether the user exists on the database, and if it exists, check whether the encrypted passwords match (which will result in a successful login).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec43"></a>Protecting your form from spam</h3></div></div></div><p>The registration form <span>will</span><a id="id325510971" class="indexterm"></a> have a username field, a password field with a confirmation field, and a special field named a <code class="literal">reCAPTCHA</code> field. A <code class="literal">CAPTCHA</code> is a special field on a web form that checks whether the person who is entering data into the form is actually a person, or an automated program that is spamming your site. The <code class="literal">reCAPTCHA </code>field is simply one implementation of a <code class="literal">CAPTCHA</code> field. The <code class="literal">reCAPTCHA</code> method has been integrated into WTForms, as it is the most popular implementation on the web.</p><p>To use <code class="literal">reCAPTCHA</code>, you will need a <code class="literal">reCAPTCHA</code> login from <a class="ulink" href="https://www.google.com/recaptcha/intro/index.html" target="_blank"><span>https://www.google.com/recaptcha/intro/index.html</span></a>. As <code class="literal">reCAPTCHA</code> is a Google product, you can log in <span>with</span><a id="id325560098" class="indexterm"></a> your Google account.</p><p>Once you log in, it will ask you to add a site. In this case, any name will do, but the domain field must have <code class="literal">localhost</code> as an entry. Once you deploy your site, your domain must also be added to this list.</p><p>Now that you have added a site, dropdowns with instructions on server and client integration will appear. The given <code class="literal">script</code> tag will need to be added to the templates of our login and registration views when we create them. What WTForms needs from this page are the keys, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/9a00a6f3-6803-470f-835c-6ef2c8057c99.png" /></div><p>Remember to never show these keys to the public. As these keys are only registered to <code class="literal">localhost</code>, they can be shown here without any problem.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>Add these keys to the <code class="literal">config</code> object in the <code class="literal">config.py</code> file so that WTForms can access them as follows:</p><pre class="programlisting">class Config(object):
    SECRET_KEY = '736670cb10a600b695a55839ca3a5aa54a7d7356cdef815d2ad6e19a2031182b'
RECAPTCHA_PUBLIC_KEY = "6LdKkQQTAAAAAEH0GFj7NLg5tGicaoOus7G9Q5Uw"
RECAPTCHA_PRIVATE_KEY = '6LdKkQQTAAAAAMYroksPTJ7pWhobYb88fTAcxcYn'</pre><p>The following code is our registration form in <code class="literal">auth/forms.py</code>:</p><pre class="programlisting"><span class="strong"><strong>class RegisterForm(Form):</strong></span> 
  username = StringField('Username', [ 
    DataRequired(), 
    Length(max=255) 
  ]) 
  password = PasswordField('Password', [ 
    DataRequired(), 
    Length(min=8) 
  ]) 
  confirm = PasswordField('Confirm Password', [ 
    DataRequired(), 
    EqualTo('password') 
  ]) 
  recaptcha = RecaptchaField() 
  def validate(self): 
    check_validate = super(RegisterForm, self).validate() 
    # if our validators do not pass 
    if not check_validate: 
      return False 
    user = User.query.filter_by( 
      username=self.username.data 
    ).first() 
    <span class="strong"><strong># Is the username already being used 
    if user: 
      self.username.errors.append( 
        "User with that name already exists" 
      ) 
      return False</strong></span> 
    return True </pre><p>Note how we are preventing a user from registering itself twice by overriding the <code class="literal">validate</code> method. This is the right way to add extra form validation logic, as we previously explained.</p><p> </p><p>The post creation form will just contain a text input for the title and a text area input for the post content. So the <code class="literal">blog/forms.py</code><span>will contain the following</span>:</p><pre class="programlisting">class PostForm(Form): 
  title = StringField('Title', [ 
    DataRequired(), 
    Length(max=255) 
  ]) 
  text = TextAreaField('Content', [DataRequired()]) </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec44"></a>Creating views</h3></div></div></div><p>The login and registration views <span>will</span><a id="id326115699" class="indexterm"></a> create our form objects and pass them to the templates. After the <code class="literal">LoginForm</code> validates the user's credentials, we will use Flask-Login to actually log the user in.</p><p>In the <code class="literal">auth/controllers.py</code> controller, we will find the <code class="literal">login</code> view, as shown in the following code:</p><pre class="programlisting">...
from flask_login import login_user, logout_user
...
<span class="strong"><strong>
@auth_blueprint.route('/login', methods=['GET', 'POST'])</strong></span>
<span class="strong"><strong>@oid.loginhandler
def login():</strong></span>
    form = LoginForm()
    ...
if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).one()
<span class="strong"><strong>login_user(user, remember=form.remember.data)</strong></span>
        ...
        flash("You have been logged in.", category="success")
return redirect(url_for('main.index'))

    ...
return render_template('login.html', form=form, openid_form=openid_form)</pre><p>The <code class="literal">logout</code> view is very simple, and will redirect the user to the main index page, as follows:</p><pre class="programlisting"><span class="strong"><strong>@auth_blueprint.route('/logout', methods=['GET', 'POST']) 
def logout():
</strong></span><span class="strong"><strong>logout_user()</strong></span>
  flash("You have been logged out.", category="success") 
  return redirect(url_for('main.index'))</pre><p>The <code class="literal">register</code> view is used to register database users only, and will redirect users to the login page so that they can immediately log in, as follows:</p><pre class="programlisting"><span class="strong"><strong>@auth_blueprint.route('/register', methods=['GET', 'POST']) 
def register():</strong></span> 
  form = RegisterForm() 
  if form.validate_on_submit(): 
    new_user = User() 
    new_user.username = form.username.data 
    new_user.set_password(form.username.data) 
    db.session.add(new_user) 
    db.session.commit() 
    flash( 
      "Your user has been created, please login.", 
      category="success" 
    ) 
    return redirect(url_for('.login')) 
  return render_template('register.html', form=form) </pre><p>Your login page should now resemble the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/f245b56f-a989-4f60-909a-6034ce7c8e70.png" /></div><p>Your registration page should look like the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/906415b7-160b-4564-86ae-54761ae9b105.png" /></div><p>Now we need to create the post creation and editing page so that something can be secured. The two pages will need to transform the text area field into a <span class="strong"><strong>WYSIWYG</strong></span> (short for <span class="strong"><strong>what you see is what you get</strong></span>) editor to handle wrapping the post text in HTML. In the <code class="literal">blog/controllers.py</code> controller, you will find the <span>following</span><a id="id326123689" class="indexterm"></a> view to add new posts:</p><pre class="programlisting">...
from flask_login import login_required, current_user
from .forms import CommentForm, PostForm
...
@blog_blueprint.route('/new', methods=['GET', 'POST'])
<span class="strong"><strong>@login_required</strong></span>
def new_post(): 
  form = PostForm() 
  if form.validate_on_submit(): 
    new_post = Post()
<span class="strong"><strong>new_post.user_id = current_user.id</strong></span>
    new_post.title = form.title.data
    new_post.text = form.text.data 
    db.session.add(new_post) 
    db.session.commit()
    flash("Post added", info)
    return redirect(url_for('blog.post', post_id=new_post.id)
return render_template('new.html', form=form)</pre><p>We are protecting our view using the Flask-Login decorator <code class="literal">@login_required</code> to ensure that only authenticated users can submit new posts. Next, using the proxy method <code class="literal">current_user</code>, we fetch the currently logged user ID so that the post is associated with the user. </p><p>The <code class="literal">new.html</code> template <span>will</span><a id="id326123722" class="indexterm"></a> need a JavaScript file for the WYSIWYG editor; <span class="strong"><strong>CKEditor</strong></span> is very simple to install and use. Now, our <code class="literal">new.html</code> file can be created as follows. Name it <code class="literal">templates/blog/new.html</code>:</p><pre class="programlisting">{% extends "base.html" %}
{% block title %}Post Creation{% endblock %}
{% block body %}
&lt;div class="p-4 shadow-sm"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col"&gt;
            &lt;h1&gt;Create a New Post&lt;/h1&gt;
        &lt;/div&gt;
    &lt;/div&gt;

&lt;div class="row"&gt;
    &lt;form method="POST" action="{{ url_for('.new_post') }}"&gt;
{{ form.hidden_tag() }}
&lt;div class="form-group"&gt;
{{ form.title.label }}
            {% if form.title.errors %}
            {% for e in form.title.errors %}
&lt;p class="help-block"&gt;{{ e }}&lt;/p&gt;
{% endfor %}
            {% endif %}
            {{ form.title(class_='form-control') }}
&lt;/div&gt;
        &lt;div class="form-group"&gt;
{{ form.text.label }}
            {% if form.text.errors %}
            {% for e in form.text.errors %}
&lt;p class="help-block"&gt;{{ e }}&lt;/p&gt;
{% endfor %}
            {% endif %}
            {{ form.text(id="editor", class_='form-control') }}
&lt;/div&gt;
        &lt;input class="btn btn-primary" type="submit" value="Submit"&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/div&gt;
{% endblock %}

<span class="strong"><strong>{% block js %}</strong></span>
<span class="strong"><strong>&lt;script src="//cdn.ckeditor.com/4.4.7/standard/ckeditor.js"&gt;
&lt;/script&gt;
&lt;script&gt;
CKEDITOR.replace('editor');</strong></span>
<span class="strong"><strong>&lt;/script&gt;
{% endblock %}</strong></span></pre><p>This is all that is needed to have the user's input stored as HTML in the database. Because we passed the <code class="literal">safe</code> filter in our post template, the HTML code appears correctly on our post pages. The <code class="literal">edit.html</code> template is similar to the <code class="literal">new.html</code> template. The only difference is the <code class="literal">form</code> opening tag, shown in the <span>following</span><a id="id326130839" class="indexterm"></a> code:</p><pre class="programlisting">&lt;form method="POST" action="{{ url_for('.edit_post', id=post.id) 
   }}"&gt; 
...  
&lt;/form&gt; </pre><p>The <code class="literal">post.html</code> template will need a button for authors to link them to the edit page, as shown in the following code:</p><pre class="programlisting">&lt;div class="row"&gt; 
  &lt;div class="col-lg-6"&gt; 
    &lt;p&gt;Written By &lt;a href="{{ url_for('.user', 
       username=post.user.username) }}"&gt;{{ post.user.username 
       }}&lt;/a&gt; on {{ post.publish_date }}&lt;/p&gt; 
  &lt;/div&gt; 
  ... 
<span class="strong"><strong>{% if current_user == post.user_id %}</strong></span>
  &lt;div class="row"&gt; 
    &lt;div class="col-lg-2"&gt; 
    &lt;a href="{{ url_for('.edit_post', id=post.id) }}" class="btn 
       btn-primary"&gt;Edit&lt;/a&gt; 
  &lt;/div&gt; 
<span class="strong"><strong>{% endif %}</strong></span>
&lt;/div&gt; </pre><p>Once again, we are using the <code class="literal">current_user</code> proxy to fetch the currently logged-in user, this time on a Jinja2 template, so that we only show the <strong class="userinput"><code>Edit</code></strong> button to the user that previously create the blog post.</p><p> </p><p>Finally, we should add an entry to create new posts in the main navigation bar. We should also take a look at how the login, logout, and register options are enabled and disabled. In <code class="literal">templates/navbar.html</code><span>, enter the following:</span></p><pre class="programlisting"><span class="strong"><strong>{% if current_user.is_authenticated %}</strong></span>
&lt;li class="nav-item"&gt;
    &lt;a class="nav-link" href="{{url_for('auth.logout')}}"&gt;
    &lt;i class="fa fa-fw fa-sign-out"&gt;&lt;/i&gt;Logout&lt;/a&gt;
&lt;/li&gt;
<span class="strong"><strong>{% else %}</strong></span>
&lt;li class="nav-item"&gt;
    &lt;a class="nav-link" href="{{url_for('auth.login')}}"&gt;
    &lt;i class="fa fa-fw fa-sign-in"&gt;&lt;/i&gt;Login&lt;/a&gt;
&lt;/li&gt;
&lt;li class="nav-item"&gt;
    &lt;a class="nav-link" href="{{url_for('auth.register')}}"&gt;
    &lt;i class="fa fa-fw fa-sign-in"&gt;&lt;/i&gt;Register&lt;/a&gt;
&lt;/li&gt;
<span class="strong"><strong>{% endif %}</strong></span></pre></div></div>