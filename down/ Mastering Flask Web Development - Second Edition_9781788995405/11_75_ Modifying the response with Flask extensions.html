<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec73"></a>Modifying the response with Flask extensions</h2></div></div><hr /></div><p>So, we have created an extension that adds new functionality to our templates. But how <span>would</span><a id="id324974906" class="indexterm"></a> we create an extension that modifies the behavior of our app at the request level? To demonstrate this, let's create an extension that modifies all the responses from Flask by compressing the contents of the response. This is a common practice in web development in order to speed up page load times, as compressing objects with a method such as <code class="literal">gzip</code> is very fast and relatively cheap, CPU-wise. Normally, this would be handled at the server level. So, unless you wish to host your app with only Python code, which is possible and will be covered in <a class="link" href="#" linkend="ch13"><span>Chapter 13</span></a>, <span class="emphasis"><em>Deploying Flask Apps</em></span>, this extension really doesn't have much use in the real world.</p><p> </p><p>To achieve this, we will use the <code class="literal">gzip</code> module in the Python standard library to compress the contents after each request is processed. We will also have to add special HTTP headers into the response in order for the browser to know that the content is compressed. We will also need to check in the HTTP request headers whether the browser can accept gzipped content.</p><p>Just as before, our content will initially reside in the <code class="literal">__init__.py</code> file:</p><pre class="programlisting">from flask import request 
from gzip import GzipFile 
from io import BytesIO 
... 
class GZip(object): 
  def __init__(self, app=None): 
    self.app = app 
    if app is not None: 
      self.init_app(app) 
  def init_app(self, app): 
    app.after_request(self.after_request) 
  def after_request(self, response): 
    encoding = request.headers.get('Accept-Encoding', '') 
    if 'gzip' not in encoding or  
      not response.status_code in (200, 201): 
      return response 
    response.direct_passthrough = False 
    contents = BytesIO() 
    with GzipFile( 
      mode='wb', 
      compresslevel=5, 
      fileobj=contents) as gzip_file: 
      gzip_file.write(response.get_data()) 
    response.set_data(bytes(contents.getvalue())) 
    response.headers['Content-Encoding'] = 'gzip' 
    response.headers['Content-Length'] = response.content_length 
    return response 
flask_gzip = GZip() </pre><p>Just as with the previous extension, our initializer for the compressed object accommodates both the normal Flask setup and the application factory setup. In the <code class="literal">after_request</code> method, instead of registering a blueprint, we register a new function on the <code class="literal">after-request</code> event so that our extension can compress the results.</p><p> </p><p> </p><p> </p><p> </p><p>The <code class="literal">after_request</code> method is where the real logic of the extension comes into play. First, it checks whether the browser accepts gzip encoding by looking at the <code class="literal">Accept-Encoding</code> value in the request header. If the browser does not accept gzip, or the browser did not return a successful response, the function just returns the content and makes no modifications to the content. However, if the browser does except our content and the response was successful, then the content will be compressed. We use another standard library class named <code class="literal">BytesIO</code>, which allows file streams to be written and stored in memory, rather than being stored in an intermediate file. This is necessary because the <code class="literal">GzipFile</code> object expects to write to a file object.</p><p>After the data is compressed, we set the response object data to the results of the compression and set the necessary HTTP header values in the response as well. Finally, the gzip content is returned to the browser, and the browser then decompresses the content, significantly speeding up the page load times.</p><p>In order to test the functionality in your browser, you have to disable <strong class="userinput"><code>Flask Debug Toolbar</code></strong><span>because,</span><a id="id325371640" class="indexterm"></a> at the time of writing, there is a bug in its code where it expects all responses to be encoded in UTF-8.</p><p>If you reload the page, nothing should look different. However, if you use the developer tools in the browser of your choice and inspect the responses, you will see that they are compressed.</p></div>