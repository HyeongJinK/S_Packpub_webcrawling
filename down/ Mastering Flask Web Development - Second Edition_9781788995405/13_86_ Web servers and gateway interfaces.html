<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec82"></a>Web servers and gateway interfaces</h2></div></div><hr /></div><p>In this section, we will make a quick introduction to the most <span>commonly</span><a id="id324974901" class="indexterm"></a> used web servers and <span class="strong"><strong>Web Server Gateway Interfaces</strong></span> (<span class="strong"><strong>WSGI</strong></span>), and their differences and configuration. A WSGI is an application-agnostic layer between the web server and the python application itself.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec79"></a>Gevent</h3></div></div></div><p>The simplest option to get a web server up and <span>running</span><a id="id325463864" class="indexterm"></a> is to use a Python library, named <code class="literal">gevent</code>, to host your application. <code class="literal">Gevent</code> is a Python library that adds an alternative way of doing concurrent programming,called co-routines, outside of the Python threading library. Gevent has an interface to run WSGI applications that is both simple and has good performance. A simple gevent server can easily handle hundreds of concurrent users, <span>which is 99% more than the users of websites on the internet will ever have.</span> The downside to this option is that its simplicity means a lack of configuration options. There is no way, for example, to add rate limiting to the server, or to add HTTPS traffic. This deployment option is purely for sites that you don't expect to receive a <span>huge</span><a id="id325463884" class="indexterm"></a> amount of traffic. Remember YAGNI: only upgrade to a different web server if you really need to.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note43"></a>Note</h3><p>Co-routines are a bit outside of the scope of this book, but a good explanation can be found at <a class="ulink" href="https://en.wikipedia.org/wiki/Coroutine" target="_blank"><span>https://en.wikipedia.org/wiki/Coroutine</span></a>.</p></div><p>To install <code class="literal">gevent</code>, we will use <code class="literal">pip</code> with the following command:</p><pre class="programlisting"><span class="strong"><strong>$ pip install gevent</strong></span></pre><p>In the root of the project directory, in a new file named <code class="literal">gserver.py</code>, add the following:</p><pre class="programlisting"><span class="strong"><strong>from gevent.wsgi import WSGIServer</strong></span><span class="strong"><strong>from webapp import create_app</strong></span><span class="strong"><strong>app = create_app('webapp.config.ProdConfig')</strong></span><span class="strong"><strong>server = WSGIServer(('', 80), app)</strong></span><span class="strong"><strong>server.serve_forever()</strong></span></pre><p>To run the server with <span>supervisor</span>, just change the command value to the following:</p><pre class="programlisting"><span class="strong"><strong>[program:webapp]</strong></span><span class="strong"><strong>command=python gserver.py </strong></span><span class="strong"><strong>directory=/home/deploy/webapp</strong></span><span class="strong"><strong>user=deploy</strong></span></pre><p>Now when you deploy, <code class="literal">gevent</code> will automatically be installed for you by running your <code class="literal">requirements.txt</code> on every deployment; that is, <span>if you are properly pip freezing after every new dependency is added.</span></p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec80"></a>Tornado</h3></div></div></div><p><span class="strong"><strong>Tornado</strong></span> is another very simple way to <span>deploy</span><a id="id325661217" class="indexterm"></a> WSGI apps purely with Python. Tornado is a web server that is designed to handle thousands of simultaneous connections. If your application needs real-time data, Tornado also supports WebSockets for continuous, long-lived connections to the server.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>Do not use Tornado in production on a Windows server. The Windows version of Tornado is not only slower—it is also considered beta-stage quality software.</p></div><p>To use <span>Tornado</span><a id="id325661233" class="indexterm"></a> with our application, we will use Tornado's <code class="literal">WSGIContainer</code> in order to wrap the application object to make it Tornado-compatible. Then, Tornado will start to listen on port <span class="emphasis"><em>80</em></span> for requests until the process is terminated. In a new file, named <code class="literal">tserver.py</code>, add the following:</p><pre class="programlisting"><span class="strong"><strong>from tornado.wsgi import WSGIContainer</strong></span><span class="strong"><strong>from tornado.httpserver import HTTPServer</strong></span><span class="strong"><strong>from tornado.ioloop import IOLoop</strong></span><span class="strong"><strong>from webapp import create_app</strong></span><span class="strong"><strong>app = WSGIContainer(create_app("webapp.config.ProdConfig"))</strong></span><span class="strong"><strong>http_server = HTTPServer(app)</strong></span><span class="strong"><strong>http_server.listen(80)</strong></span><span class="strong"><strong>IOLoop.instance().start()</strong></span></pre><p>To run the Tornado with supervisor <span>privileges</span>, just change the command value to the following:</p><pre class="programlisting"><span class="strong"><strong>[program:webapp]</strong></span><span class="strong"><strong>command=python tserver.py </strong></span><span class="strong"><strong>directory=/home/deploy/webapp</strong></span><span class="strong"><strong>user=deploy</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec81"></a>Nginx and uWSGI</h3></div></div></div><p>If you need better <span>performance</span><a id="id325736403" class="indexterm"></a> or more options for customization, the most popular way to <span>deploy</span><a id="id325736411" class="indexterm"></a> a Python web application is to use a Nginx web server as a frontend for the WSGI-based uWSGI server by using a reverse proxy. A <span class="emphasis"><em>reverse proxy</em></span> is a program in networks that retrieves contents for a client from a server, as if it returned from the proxy itself. This process is shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/3dcdbaa0-0e66-4caf-be8d-e88945b680ba.png" /></div><p><span class="strong"><strong>Nginx</strong></span> and <span class="strong"><strong>uWSGI</strong></span> are used like this, because this way, we get the <span>power</span><a id="id325751325" class="indexterm"></a> of the Nginx frontend, while having the customization of uWSGI.</p><p><span class="strong"><strong>Nginx</strong></span> is a very powerful web server that became popular by providing the best combination of speed and customization. Nginx is consistently faster than other web severs, such as Apache's httpd, and has native support for WSGI applications. It achieves this speed thanks to the developers taking several good architecture decisions, as well as not going to try to cover a large amount of use cases, as Apache does. The latter point here was a decision taken early on in development of Nginx. Having a smaller feature set makes it much easier to maintain and optimize the code. From a programmer's perspective, it is also much easier to configure Nginx, as there is no giant default configuration file (<code class="literal">httpd.conf</code>) that can be <span>overridden</span> with <code class="literal">.htaccess</code> files in each of your project directories.</p><p><span class="strong"><strong>uWSGI</strong></span> is a web server that supports <span>several</span><a id="id325751356" class="indexterm"></a> different types of server interfaces, including WSGI. uWSGI handles the severing of the application content, as well as things such as the load balancing of traffic across several different processes and threads.</p><p>To install uWSGI, we will use a <code class="literal">pip</code> command, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ pip install uwsgi</strong></span></pre><p> </p><p>In order to run our application, uWSGI needs a file with an accessible WSGI application. <span>In a file named</span><code class="literal">wsgi.py</code> in the top level of the project directory.</p><p>To test uWSGI, we can run it from the <span class="strong"><strong>command-line interface</strong></span> (<span class="strong"><strong>CLI</strong></span>) with the <span>following</span><a id="id325751845" class="indexterm"></a> commands:</p><pre class="programlisting"><span class="strong"><strong>$ uwsgi --socket 127.0.0.1:8080 </strong></span><span class="strong"><strong>--wsgi-file wsgi.py </strong></span><span class="strong"><strong>--callable app </strong></span><span class="strong"><strong>--processes 4 </strong></span><span class="strong"><strong>--threads 2</strong></span></pre><p>If you are running this on your server, you should be able to access port 8080 and see your app (if you don't have a firewall, that is).</p><p>What this command does is load the app object from the <code class="literal">wsgi.py</code> file, and make it accessible from <code class="literal">localhost</code> on port <span class="emphasis"><em>8080</em></span>. It also spawns four different processes with two threads each, which are automatically load balanced by a master process. This amount of processes is overkill for the vast majority of websites. To start off, use a single process with two threads and scale up from there.</p><p>Instead of adding all of the configuration options on the CLI, we can create a text file to <span>hold</span><a id="id325752843" class="indexterm"></a> our configuration, which gives us the same benefits for configuration that were listed in the <span class="emphasis"><em>Gevent </em></span>section, about supervisor. In the root of the project directory, create a file named <code class="literal">uwsgi.ini</code> and add the following code:</p><pre class="programlisting"><span class="strong"><strong>[uwsgi]</strong></span><span class="strong"><strong>socket = 127.0.0.1:8080</strong></span><span class="strong"><strong>wsgi-file = wsgi.py</strong></span><span class="strong"><strong>callable = app</strong></span><span class="strong"><strong>processes = 4</strong></span><span class="strong"><strong>threads = 2</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note45"></a>Note</h3><p>uWSGI supports hundreds of configuration options, as well as several official and unofficial plugins. To leverage the full power of uWSGI, you can explore the documentation at <a class="ulink" href="http://uwsgi-docs.readthedocs.org/" target="_blank"><span>http://uwsgi-docs.readthedocs.org/</span></a>.</p></div><p>Let's now run the server from supervisor:</p><pre class="programlisting"><span class="strong"><strong>[program:webapp]</strong></span><span class="strong"><strong>command=uwsgi uwsgi.ini</strong></span><span class="strong"><strong>directory=/home/deploy/webapp</strong></span><span class="strong"><strong>user=deploy</strong></span></pre><p> </p><p>Because we are installing Nginx from the OS's package manager, the OS will handle the running of <span>Nginx</span><a id="id325753564" class="indexterm"></a> for us.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note46"></a>Note</h3><p>At the time of writing, the Nginx version in the official Debian package manager is several years old. To install the most recent version, follow the instructions available at <a class="ulink" href="http://wiki.nginx.org/Install" target="_blank">http<span>://wiki.nginx.org/Install</span></a>.</p></div><p>Next, we need to create an Nginx configuration file, and then, when we push the code, we need to copy the configuration file to the <code class="literal">/etc/nginx/sites-available/</code> directory. In the root of the project directory, create a new file named <code class="literal">nginx.conf</code>, and add the following:</p><pre class="programlisting">server { 
    listen 80; 
    server_name your_domain_name; 
 
    location / { 
        include uwsgi_params; 
        uwsgi_pass 127.0.0.1:8080; 
    } 
     
    location /static { 
        alias /home/deploy/webapp/webapp/static; 
    } 
} </pre><p>What this configuration file does is tells Nginx to listen for incoming requests on port <span class="emphasis"><em>80</em></span>, and forwards all requests to the WSGI application that is listening on port <span class="emphasis"><em>8080</em></span>. Also, it makes an exception for any requests for static files, and instead sends those requests directly to the file system. Bypassing uWSGI for static files gives a great boost to performance, as Nginx is really good at serving static files quickly.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec82"></a>Apache and uWSGI</h3></div></div></div><p>Using Apache httpd with uWSGI mostly requires the <span>same</span><a id="id325753612" class="indexterm"></a> setup. First off, we need an Apache configuration file, so let's create a new file, named <code class="literal">apache.conf</code>, in the root of our project directory, and add the following code:</p><pre class="programlisting">&lt;VirtualHost *:80&gt; 
    &lt;Location /&gt; 
        ProxyPass / uwsgi://127.0.0.1:8080/ 
    &lt;/Location&gt; 
&lt;/VirtualHost&gt; </pre><p> </p><p>This file simply tells Apache to pass all requests on port <span class="emphasis"><em>80</em></span> to the uWSGI web server listening on port <span class="emphasis"><em>8080</em></span>. However, this functionality requires an extra Apache plugin from uWSGI, named <code class="literal">mod-proxy-uwsgi</code>.</p><p>Next, we will cover <span>several</span><a id="id325753648" class="indexterm"></a> solutions for deploying our application on <span class="strong"><strong>Platform as a Service</strong></span> (<span class="strong"><strong>PaaS</strong></span>) and <span class="strong"><strong>Infrastructure as a Service</strong></span> (<span class="strong"><strong>IaaS</strong></span>) utilities. You will learn how to create <span>several</span><a id="id325753671" class="indexterm"></a> types of environments and make our example Blog application available to the world.</p></div></div>