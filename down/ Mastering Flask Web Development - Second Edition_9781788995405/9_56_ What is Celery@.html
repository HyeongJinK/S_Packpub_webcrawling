<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec56"></a>What is Celery?</h2></div></div><hr /></div><p><span class="strong"><strong>Celery</strong></span> is an asynchronous task queue written in Python. Celery <span>runs</span><a id="id324991595" class="indexterm"></a> multiple tasks, which are user-defined functions, concurrently, through the Python multiprocessing library. Celery receives messages that tell it to start a task from a <span class="strong"><strong>broker</strong></span>, which is usually called a message queue, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/1e421355-8765-47da-8f7b-1c3806b8634a.png" /></div><p>A <span class="strong"><strong>message queue</strong></span> is a system specifically <span>designed</span><a id="id325371901" class="indexterm"></a> to send data between producer processes and consumer processes. <span class="strong"><strong>Producer processes</strong></span> are any programs that create <span>messages</span><a id="id325375173" class="indexterm"></a> to be sent to the queue, and <span class="strong"><strong>consumer processes</strong></span> are any programs that take the <span>messages</span><a id="id325375184" class="indexterm"></a> out of the queue. Messages sent from a producer are stored in a <span class="strong"><strong>First In, First Out</strong></span> (<span class="strong"><strong>FIFO</strong></span>) queue, where the oldest items are retrieved first. Messages are stored until a consumer receives the message, after which the message is deleted. Message queues provide real-time messaging without relying on polling, which means continuously checking the status of a process. As <span>messages</span><a id="id325375198" class="indexterm"></a> are sent from producers, consumers are listening on their connection to the message queue for new messages; the consumer is not constantly contacting the queue. This difference is like the difference between <span class="strong"><strong>AJAX</strong></span> and <span class="strong"><strong>WebSockets</strong></span>, in thatÂ <span>AJAX</span><a id="id325375213" class="indexterm"></a> requires constant contact with the server, while WebSockets are just a continuous <span>bidirectional</span><a id="id325376886" class="indexterm"></a> communication stream.</p><p>It is possible to replace the message queue with a traditional database. Celery even comes with built-in support for SQLAlchemy to allow this. However, using a database as a broker for Celery is highly discouraged. Using a database in place of a message queue requires the consumer to constantly poll the database for updates. Also, because Celery uses multiprocessing for concurrency, the number of connections making lots of reads goes up quickly. Under medium loads, using a database requires the producer to make lots of writes to the database at the same time as the consumer is reading.</p><p>It is also possible to use a message queue as a broker and a database to store the results of the tasks. In the preceding diagram, the message queue was used for sending task requests and task results. However, using a database to store the end result of the task allows the final product to be stored indefinitely, whereas the message queue will throw out the data as soon as the producer receives the data, as shown in the following diagram:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/4f10a1c4-5a71-4af2-8473-2934d2e47f1f.png" /></div><p>This database is often a <span>key/value</span> NoSQL store to help handle the load. This is useful if you plan on doing analytics on previously run tasks, but otherwise it's safer to just stick with the message queue.</p><p>There is even an option to drop the results of tasks entirely, and not have the results returned at all. This has the downside that the producer has no way of knowing if a task was successful or not, but often, this is permissible in smaller projects.</p><p>For our stack, we will use RabbitMQ as the message broker. RabbitMQ <span>runs</span><a id="id325378694" class="indexterm"></a> on all major operating systems and is very simple to be set up and run. <span>Celery</span><a id="id325378702" class="indexterm"></a> also supports RabbitMQ without any extra libraries, and is the recommended message queue in the Celery documentation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note36"></a>Note</h3><p>At the time of writing, there is no way to use RabbitMQ with Celery in Python 3. You can use Redis, however, instead of RabbitMQ. The only difference will be the connection strings. For more information, see <a class="ulink" href="http://docs.celeryproject.org/en/latest/getting-started/brokers/redis.html" target="_blank"><span>http://docs.celeryproject.org/en/latest/getting-started/brokers/redis.html</span></a>.</p></div></div>