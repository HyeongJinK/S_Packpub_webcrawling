<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec32"></a>Blueprints</h2></div></div><hr /></div><p>In Flask, a <span class="strong"><strong>blueprint</strong></span> is a method of extending an <span>existing</span><a id="id325021336" class="indexterm"></a> Flask app. They provide a way of combining groups of views with common functionality and allow developers to break their app down into different components. In our architecture, the blueprints will act as our <span class="emphasis"><em>controllers</em></span>.</p><p> </p><p>Views are registered to a blueprint; a separate template and static folder can be defined for it, and when it has all the desired content in it, it can be registered on the main Flask app to add the blueprint's content. A blueprint acts much like a Flask app object, but is not actually a self-contained app. This is how Flask extensions provide view functions. To get an idea of what blueprints are, here is a very simple example:</p><pre class="programlisting">from flask import Blueprint 
example = Blueprint( 
    'example', 
    __name__, 
    template_folder='templates/example', 
    static_folder='static/example', 
    url_prefix="/example" 
) 
 
@example.route('/') 
def home(): 
    return render_template('home.html') </pre><p>The blueprint takes two required parameters, the name of the blueprint and the name of the package, which are used internally in Flask, and passing <code class="literal">__name__</code> to it will suffice.</p><p>The other parameters are optional and define where the blueprint will look for files. Because <code class="literal">templates_folder</code> was specified, the blueprint will not look in the default template folder, and the route will render <code class="literal">templates/example/home.html</code> and not <code class="literal">templates/home.html</code>. The <code class="literal">url_prefix</code> option automatically adds the provided URI to the start of every route in the blueprint. So, the URL for the home view is actually <code class="literal">/example/</code>.</p><p>The <code class="literal">url_for()</code> function will now have to be told which blueprint the requested route is in:</p><pre class="programlisting">{{ url_for('example.home') }} </pre><p>Also, the <code class="literal">url_for()</code> function will now have to be told whether the view is being rendered from within the same blueprint:</p><pre class="programlisting">{{ url_for('.home') }} </pre><p>The <code class="literal">url_for()</code> function will also look for static files in the specified <code class="literal">static</code> folder as well.</p><p>Use this to add the blueprint to our app:</p><pre class="programlisting">app.register_blueprint(example) </pre><p>Let's transform our current app to one that uses blueprints. We will first need to define our blueprint before all of our routes:</p><pre class="programlisting">blog_blueprint = Blueprint( 
    'blog', 
    __name__, 
    template_folder='templates/blog', 
    url_prefix="/blog" 
) </pre><p>Now, because the <code class="literal">templates</code> folder was defined, we need to move all of our templates into a subfolder of the <code class="literal">templates</code> folder named <code class="literal">blog</code>. Next, all of our routes need to have <code class="literal">@app.route</code> changed to <code class="literal">@blog_blueprint.route</code>, and any class view assignments now need to be registered to <code class="literal">blog_blueprint</code>. Remember that the <code class="literal">url_for()</code> function calls in the templates will also have to be changed to have a period prepended to then to indicate that the route is in the same blueprint.</p><p>At the end of the file, right before the <code class="literal">if__name__ == '__main__':</code> statement, add the following:</p><pre class="programlisting">app.register_blueprint(blog_blueprint)</pre><p>Now, all of our content is back in the app, which is registered under the blueprint. Because our base app no longer has any views, let's add a redirect on the base URL:</p><pre class="programlisting">@app.route('/') 
def index(): 
    return redirect(url_for('blog.home')) </pre><p>Why blog and not <code class="literal">blog_blueprint</code>? Because blog is the <span>name</span><a id="id325371900" class="indexterm"></a> of the blueprint and the name is what Flask uses internally for routing. <code class="literal">blog_blueprint</code> is the name of the variable in the Python file.</p><p> </p><p> </p></div>