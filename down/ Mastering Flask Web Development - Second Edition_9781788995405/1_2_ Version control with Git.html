<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec10"></a>Version control with Git</h2></div></div><hr /></div><p>Using Python or any other language requires <span>you</span><a id="id326186775" class="indexterm"></a> to use a version control system. A version control system is a tool that records changes in files over time. This allows a programmer to revert to an earlier version of the file and identify bugs more easily. You can test new ideas without fear of breaking your current code, and your team can work using a predefined workflow without stepping on each others' toes. Git was developed by Linus Torvalds, the father of Linux. It's decentralized, light, and has great features that get the job done the right way.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec3"></a>Installing Git</h3></div></div></div><p>Installing <span>Git</span><a id="id326186790" class="indexterm"></a> is very simple. Simply go to <a class="ulink" href="http://www.git-scm.com/downloads" target="_blank"><span>http://www.git-scm.com/downloads</span></a> and click on the <span class="strong"><strong>operating system</strong></span> (<span class="strong"><strong>OS</strong></span>) that is being run. A program will begin to <span>download</span><a id="id326186848" class="indexterm"></a> will walk you through the basic installation process.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec0"></a>Git on Windows</h4></div></div></div><p>Git was originally solely developed for Unix OSes (for example, Linux and macOS X). Consequently, using Git on Windows is not seamless. During the installation, the installer will ask whether you want to install <span>Git</span><a id="id326186862" class="indexterm"></a> alongside the normal Windows Command Prompt. Do not pick this option. Choose the default option that will install a new type of command processor on your system named <span class="strong"><strong>Bash</strong></span> (<span class="strong"><strong>Bourne-again shell</strong></span>), which is the <span>same</span><a id="id326186880" class="indexterm"></a> command processor that the Unix systems use. Bash is much more powerful than the default Windows command line, and this is what we will be using for all the examples in this book.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip3"></a>Note</h3><p>A good introduction to Bash for beginners can be found at <a class="ulink" href="http://linuxcommand.org" target="_blank">http://linuxcommand.org</a>.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec4"></a>Git basics</h3></div></div></div><p><span>Git</span><a id="id326186903" class="indexterm"></a> is a very complex tool; only the basics that are <span>needed</span><a id="id326078403" class="indexterm"></a> for this book will be covered in this section.</p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note4"></a>Note</h3><p>To learn more, refer to the Git documentation at <a class="ulink" href="http://www.git-scm.com/doc" target="_blank"><span>http://www.git-scm.com/doc</span></a>.</p></div><p>Git does not track your changes automatically. In order for Git to run properly, we have to give it the following information:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Which folders to track</li><li style="list-style-type: disc">When to save the state of the code</li><li style="list-style-type: disc">What to track and what not to track</li></ul></div><p>Before we can do anything, we have to tell Git to initialize a new <code class="literal">git</code> repository in our directory. Run the following code on your Terminal:</p><pre class="programlisting"><span class="strong"><strong>$ git init</strong></span></pre><p>Git will now start to track changes in our project. As <code class="literal">git</code> tracks our files, we can see the status of our tracked files and any files that are not tracked by typing the following command:</p><pre class="programlisting"><span class="strong"><strong>$ git status</strong></span></pre><p>Now we can save our first <code class="literal">commit</code>, which is a snapshot of our code at the time that we run the <code class="literal">commit</code> command:</p><pre class="programlisting"># In Bash, comments are marked with a #, just like Python
# Add any files that have changes and you wish to save in this      
# commit
<span class="strong"><strong>$ git add main.py</strong></span>
# Commit the changes, add in your commit message with -m
<span class="strong"><strong>$ git commit -m "Our first commit"</strong></span></pre><p>Now, at any point in the future, we can return to this point in our project. Adding files that are to be committed is called <span class="strong"><strong>staging</strong></span> files in Git. Remember that you should only add stage files if you are ready to commit them. Once the files are staged, any further changes will not be staged. For an example of more advanced Git usage, add any text to your <code class="literal">main.py</code> file with your text editor and then run the following:</p><pre class="programlisting"><span class="strong"><strong># To see the changes from the last commit</strong></span><span class="strong"><strong>$ git diff</strong></span><span class="strong"><strong># To see the history of your changes</strong></span><span class="strong"><strong>$ git log</strong></span><span class="strong"><strong># As an example, we will stage main.py</strong></span><span class="strong"><strong># and then remove any added files from the stage</strong></span><span class="strong"><strong>$ git add main.py</strong></span><span class="strong"><strong>$ git status</strong></span><span class="strong"><strong>$ git reset HEAD main.py</strong></span><span class="strong"><strong># After any complicated changes, be sure to run status</strong></span><span class="strong"><strong># to make sure everything went well</strong></span><span class="strong"><strong>$ git status</strong></span><span class="strong"><strong># lets delete the changes to main.py, reverting to its state at the   
</strong></span> # last commit # This can only be run on files that aren't staged
    <span class="strong"><strong>$ git checkout -- main.py</strong></span></pre><p>Your terminal should look something like the following:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/08cdfca5-6d73-4117-8e0d-adaf0a498f1a.png" /></div><p>Note that in the preceding example I have modified the <code class="literal">main.py</code> file by adding the comment <code class="literal"># Changed to show the git diff command</code>.</p><p>One important step to include in every Git repository is a <code class="literal">.gitignore</code> file. This file tells Git what files to ignore. This way you can safely commit and add all your files. The following are some common files that you can ignore:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Python's byte code files (<code class="literal">*.pyc</code>)</li><li style="list-style-type: disc">Databases (specially for our examples using SQLLite database files) (<code class="literal">*.db</code>)</li><li style="list-style-type: disc">Secrets (never push secrets (password, keys, and so on) to your repositories)</li><li style="list-style-type: disc">IDE metadata files (<code class="literal">.idea</code>)</li><li style="list-style-type: disc">The <code class="literal">Virtualenv</code> directory (<code class="literal">env</code> or <code class="literal">venv</code>)</li></ul></div><p>Here's a simple example of a <code class="literal">gitignore</code> file:</p><pre class="programlisting">*.pyc
*.pem
*.pub
*.tar.gz
*.zip
*.sql
*.db
secrets.txt
./tmp
./build/*
.idea/*
.idea
env
venv</pre><p>Now we can safely add all the files to <code class="literal">git</code> and commit them:</p><pre class="programlisting"><span class="strong"><strong>  $ git add --all</strong></span>
<span class="strong"><strong>  $ git status</strong></span>
<span class="strong"><strong>  $ git commit -a -m "Added gitignore and all the projects missing 
    files"</strong></span></pre><p>The Git system's <code class="literal">checkout</code> command is rather advanced for this simple introduction, but it is used to change the current status of the Git system's <code class="literal">HEAD</code> pointer, which refers to the current location of our code in the history of our project. This will be shown in the next example.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>Now, if we wish to see the code in a previous commit, we should first run the following command:</p><pre class="programlisting"><span class="strong"><strong>$ git log
</strong></span><span class="strong"><strong>commit cd88be37f12fb596be743ccba7e8283dd567ac05 (HEAD -&gt; master)</strong></span>
<span class="strong"><strong>Author: Daniel Gaspar</strong></span>
<span class="strong"><strong>Date: Sun May 6 16:59:46 2018 +0100</strong></span>

<span class="strong"><strong>Added gitignore and all the projects missing files</strong></span>
<span class="strong"><strong>commit beb471198369e64a8ee8f6e602acc97250dce3cd</strong></span>
<span class="strong"><strong>Author: Daniel Gaspar</strong></span>
<span class="strong"><strong>Date: Fri May 4 19:06:57 2018 +0100</strong></span>

<span class="strong"><strong>Our first commit</strong></span></pre><p>The string of characters next to our <code class="literal">commit</code> message, <code class="literal">beb4711</code>, is called the <span class="strong"><strong>hash</strong></span> of our commit. It is the unique identifier of the commit that we can use to return to the <span>saved</span><a id="id325687141" class="indexterm"></a> state. Now, to take the project back to the previous state, run the following command:</p><pre class="programlisting"><span class="strong"><strong>$ git checkout beb4711</strong></span></pre><p>Your <span>Git</span><a id="id325687156" class="indexterm"></a> project is now in a special state where any changes or commits will neither be saved nor affect any commits that were made after the one you checked out. This state is just for viewing old code. To return to the normal mode of Git, run the following command:</p><pre class="programlisting"><span class="strong"><strong>$ git checkout master</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec5"></a>Git branches and flow</h3></div></div></div><p>Source control branches are an important feature that works great in team projects. A developer can create a new line of code from a specific point in time, revision, or tag. In this way, developing new features, creating releases, and making bugfixes or hotfixes can be done safely and subjected to team revision, and/or automatic integration tools (such as tests, code coverage, lint tools). A branch can be merged with other branches until it finally reaches the main line of code, called the <span class="emphasis"><em>master branch</em></span>.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p>But let's get our hands on a practical exercise. Let's say that we want to <span>develop</span><a id="id325687200" class="indexterm"></a> a new feature. Our first chapter example displays the traditional "Hello World" message, but we want it to say "good morning" to the users. First, we create a branch from a special branch called the <code class="literal">feature/good-morning</code> that for <span>now</span><a id="id325687211" class="indexterm"></a> is a copy of the master branch, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong># Display our branches
$ git branch
</strong></span>* master<span class="strong"><strong>
# Create a branch called feature/good-morning from master
$ git branch feature/good-morning
# Display our branches again
$ git branch
</strong></span>  feature/good-morning
* master<span class="strong"><strong>
# Check out the new feature/good-morning branch
$ git checkout feature/good-morning
</strong></span></pre><p>This could be resumed to the following:</p><pre class="programlisting"><span class="strong"><strong>$ git checkout -b </strong></span><span class="strong"><strong>feature/good-morning master</strong></span></pre><p>Now let's change our code to display <strong class="userinput"><code>good morning</code></strong> to the visitors of a certain URL, along with their names. To do this, we change <code class="literal">main.py</code>, which looks like the following code:</p><pre class="programlisting">@app.route('/')
def home():
    return '&lt;h1&gt;Hello world&lt;/h1&gt;'</pre><p>We change <code class="literal">main.py</code> to the following:</p><pre class="programlisting">@app.route('/username')
def home():
    return '&lt;h1&gt;Good Morning %s&lt;/h1&gt;' % username</pre><p>Let's look at what we have done:</p><pre class="programlisting"><span class="strong"><strong>$</strong></span><span class="strong"><strong>git diff</strong></span>
<span class="strong"><strong>diff --git a/main.py b/main.py</strong></span>
<span class="strong"><strong>index 3e0aacc..1a930d9 100755</strong></span>
<span class="strong"><strong>--- a/main.py</strong></span>
<span class="strong"><strong>+++ b/main.py</strong></span>
<span class="strong"><strong>@@ -5,9 +5,9 @@ app = Flask(__name__)</strong></span>
<span class="strong"><strong> app.config.from_object(DevConfig)</strong></span>

<span class="strong"><strong> # Changed to show the git diff command</strong></span>
<span class="strong"><strong>-@app.route('/')</strong></span>
<span class="strong"><strong>-def home():</strong></span>
<span class="strong"><strong>- return '&lt;h1&gt;Hello World!&lt;/h1&gt;'</strong></span>
<span class="strong"><strong>+@app.route('/&lt;username&gt;')</strong></span>
<span class="strong"><strong>+def home(username):</strong></span>
<span class="strong"><strong>+ return '&lt;h1&gt;Good Morning %s&lt;/h1&gt;' % username</strong></span>

<span class="strong"><strong> if __name__ == '__main__':</strong></span>
<span class="strong"><strong>     app.run()</strong></span></pre><p>Looks good. Let's commit, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>$ git commit -m "Display good morning because its nice"</strong></span>
<span class="strong"><strong>[feature/good-morning d4f7fb8] Display good morning because its nice</strong></span>
<span class="strong"><strong> 1 file changed, 3 insertions(+), 3 deletions(-)</strong></span></pre><p>Now, if we were working as part of a team, or if our work was <span>open</span><a id="id326087717" class="indexterm"></a> source (or if we just wanted to back up our work), we should upload (push) our code to a centralized remote origin. One way of doing this is to push our code to a version control system, such as <span class="strong"><strong>Bitbucket</strong></span> or <span class="strong"><strong>GitHub</strong></span>, and then open a <span class="strong"><strong>pull request</strong></span> to the <span>master</span><a id="id326087736" class="indexterm"></a> branch. This pull request will show our changes. As such, it may <span>need</span><a id="id326087745" class="indexterm"></a> approval from other team members, and many other features that these systems can provide.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note5"></a>Note</h3><p>One example of a pull request on the Flask project can be found at <a class="ulink" href="https://github.com/pallets/flask/pull/1767" target="_blank">https://github.com/pallets/flask/pull/1767</a>.</p></div><p>For our example, let's just merge to the master, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong># Get back to the master branch
$ git checkout master</strong></span>
<span class="strong"><strong>Switched to branch 'master'</strong></span>
<span class="strong"><strong>bash-3.2$ git log</strong></span>
<span class="strong"><strong>commit 139d121d6ecc7508e1017f364e6eb2e4c5f57d83 (HEAD -&gt; master)</strong></span>
<span class="strong"><strong>Author: Daniel Gaspar</strong></span>
<span class="strong"><strong>Date: Fri May 4 23:32:42 2018 +0100</strong></span>

<span class="strong"><strong>    Our first commit</strong></span>
<span class="strong"><strong># Merge our feature into the master branch</strong></span>
<span class="strong"><strong>$ git merge feature/good-morning</strong></span>
<span class="strong"><strong>Updating 139d121..5d44a43</strong></span>
<span class="strong"><strong>Fast-forward</strong></span>
<span class="strong"><strong> main.py | 6 +++---</strong></span>
<span class="strong"><strong> 1 file changed, 3 insertions(+), 3 deletions(-)</strong></span>
<span class="strong"><strong>bash-3.2$ git log</strong></span>
<span class="strong"><strong>commit 5d44a4380200f374c879ec1f7bda055f31243263 (HEAD -&gt; master, feature/good-morning)</strong></span>
<span class="strong"><strong>Author: Daniel Gaspar</strong></span>
<span class="strong"><strong>Date: Fri May 4 23:34:06 2018 +0100</strong></span>

<span class="strong"><strong>Display good morning because its nice

</strong></span><span class="strong"><strong>commit 139d121d6ecc7508e1017f364e6eb2e4c5f57d83</strong></span>
<span class="strong"><strong>Author: Daniel Gaspar &lt;daniel.gaspar@miniclip.com&gt;</strong></span>
<span class="strong"><strong>Date: Fri May 4 23:32:42 2018 +0100</strong></span>

<span class="strong"><strong>Our first commit</strong></span></pre><p>As you can see from the output, Git uses the fast-forward strategy by default. If we wanted to keep an extra commit log message that mentions the merge itself, then we could have used the <code class="literal">--no-ff </code>flag on the <code class="literal">git merge</code> command. This flag will disable the fast-forward merging strategy.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip6"></a>Note</h3><p>For more details, go to <a class="ulink" href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging" target="_blank">https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging</a>.</p></div><p>Now imagine that we regret our change and want to revert the feature that we have just created back to an earlier version. To do this, we can use the following code:</p><pre class="programlisting"><span class="strong"><strong>$ git revert</strong></span></pre><p>With Git, you can actually delete your commits, but this is considered a really bad practice. Note that the <code class="literal">revert</code> command did not delete our merge, but created a new commit with the reverted changes. It's considered a good practice not to rewrite the past. </p><p>What was shown is a feature branch simple workflow. With big teams or projects, the use of more complex workflows is normally adopted to better isolate features, fixes, and releases, and to keep a stable line of code. This is what is proposed when using the git-flow process.</p><p>Now that we have a version control system, we are ready to cover Python's package management system.</p></div></div>