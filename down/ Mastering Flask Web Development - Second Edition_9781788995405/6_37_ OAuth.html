<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec40"></a>OAuth</h2></div></div><hr /></div><p>To log in with <span>Facebook</span><a id="id324993894" class="indexterm"></a> and Twitter, the <span class="strong"><strong>OAuth</strong></span> protocol is used as previously described. Our app will <span>not</span><a id="id324993905" class="indexterm"></a> use OAuth directly; instead, another Flask extension will be used, named <span class="strong"><strong>Flask Dance</strong></span>. In the <code class="literal">requirements.txt</code>, enter the following:</p><pre class="programlisting">...
flask-dance
...</pre><p>As previously described, the OAuth protocol needs a previously created application in each provider's developer page. After our application is created, we will have a key and secret token for each provider. For now, we are going to keep these credentials on the configuration file as is. Later, we will be using environment variables to handle them. So, in the configuration file <code class="literal">config.py</code>, <span>add the following:</span></p><pre class="programlisting">...
class Config(object):
    ...
TWITTER_API_KEY = "XXX"
TWITTER_API_SECRET = "XXXX"
FACEBOOK_CLIENT_ID = "YYYY"
FACEBOOK_CLIENT_SECRET = "YYYY"</pre><p> </p><p> </p><p> </p><p> </p><p>Now we are ready to initialize and configure our OAuth extension. <span class="strong"><strong>Flask-Dance </strong></span>will help us create a new Flask blueprint for each provider we want to add. Once again, <code class="literal">auth/__init__.py</code> is the place where we configure all our authentication extensions, as follows:</p><pre class="programlisting">...
from flask_dance.contrib.twitter import make_twitter_blueprint, twitter
from flask_dance.contrib.facebook import make_facebook_blueprint, facebook
...
def create_module(app, **kwargs):
...
    twitter_blueprint = make_twitter_blueprint(
api_key=app.config.get("TWITTER_API_KEY"),
api_secret=app.config.get("TWITTER_API_SECRET"),
    )
    app.register_blueprint(twitter_blueprint, url_prefix="/auth/login")

    facebook_blueprint = make_facebook_blueprint(
client_id=app.config.get("FACEBOOK_CLIENT_ID"),
client_secret=app.config.get("FACEBOOK_CLIENT_SECRET"),
)
    app.register_blueprint(facebook_blueprint, url_prefix="auth/login"
...</pre><p>Flask-Dance will create the following routes for us:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">/auth/login/twitter/authorized</code>: Here, the user is redirected after authorization is successful on Twitter</li><li style="list-style-type: disc"><code class="literal">/auth/login/twitter</code>: This is the initial login view for Twitter OAuth</li><li style="list-style-type: disc"><code class="literal">/auth/login/facebook/authorized</code></li><li style="list-style-type: disc"><code class="literal">/auth/login/facebook</code></li></ul></div><p>After a successful login/authorization is accomplished, we need to log the user in on Flask-Login; if the user does not exist on the database, add them. To do this, we register for the authorized signal event. Enter the following in<code class="literal">auth/__init__.py</code>:</p><pre class="programlisting">...
from flask_dance.consumer import oauth_authorized
...
@oauth_authorized.connect
def logged_in(blueprint, token):
from .models import db, User
<span class="strong"><strong>if blueprint.name == 'twitter':</strong></span>
<span class="strong"><strong>        username = session.get('screen_name')</strong></span>
<span class="strong"><strong>elif blueprint.name == 'facebook':</strong></span>
<span class="strong"><strong>        resp = facebook.get("/me")</strong></span>
<span class="strong"><strong>        username = resp.json()['name']</strong></span>
    user = User.query.filter_by(username=username).first()
if not user:
        user = User()
        user.username = username
        db.session.add(user)
        db.session.commit()

<span class="strong"><strong>login_user(user)</strong></span>
    flash("You have been logged in.", category="success")</pre><p>The <code class="literal">@oauth_authorized</code> is the decorator from Flask-Dance that we use to register our function to handle the after-authorized signal. This is a generic signal handler for all our providers, so we need to know what provider are we currently handling. We need to know this because we need to fetch our username, and each provider is going to expose different user information in a different way. On Twitter, we will use the <code class="literal">screen_name</code> key that has already been returned by the provider and has already been pushed to our Flask <span>session</span><a id="id325371867" class="indexterm"></a> object by Flask-Dance. But on Facebook, we need to make a further request to Facebook's API to fetch the username.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note29"></a>Note</h3><p>During development, you will probably not use HTTPS. This will trigger an error when using <code class="literal">OAuth2</code>. To get around this, you have to tell <code class="literal">oauthlib</code> to accept insecure connections. In the command line, enter  <code class="literal">$ export OAUTHLIB_INSECURE_TRANSPORT=1</code>.</p></div><p>Finally, in the register and login templates, we have the following links to start the login process:</p><pre class="programlisting">&lt;h2 class="text-center"&gt;Register/Login With Facebook&lt;/h2&gt;
&lt;a href="{{ url_for('facebook.login') }}"&gt;Login&lt;/a&gt;

&lt;h2 class="text-center"&gt;Register/Login With Twitter&lt;/h2&gt;
&lt;a href="{{ url_for('twitter.login') }}"&gt;Login&lt;/a&gt;</pre></div>