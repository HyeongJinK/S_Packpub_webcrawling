<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec35"></a>Application factories</h2></div></div><hr /></div><p>Now that we are using blueprints in a modular manner, there is another improvement we can make to our abstraction, which creates a <span class="strong"><strong>factory</strong></span> for our application. The concept of a <span>factory</span><a id="id324847034" class="indexterm"></a> comes from the <span class="strong"><strong>object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>) world, and it simply means a function or an object that creates another object. Our application factory will take one of our <code class="literal">config</code> objects, which we created at the beginning of the book, and return a <span>Flask</span><a id="id325021302" class="indexterm"></a> application object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note21"></a>Note</h3><p>The object factory design was popularized by the now famous book, <span class="emphasis"><em>Design Patterns: Elements of Reusable Object-Oriented Software</em></span>, by the Gang of Four. To learn more about these design patterns and how they can help simplify a project's code, look at <a class="ulink" href="https://en.wikipedia.org/wiki/Structural_pattern" target="_blank"><span>https://en.wikipedia.org/wiki/Structural_pattern</span></a>.</p></div><p>Creating a factory function for our application object has several benefits. First, it allows the context of the environment to change the configuration of the application. When your server creates the application object to serve, it can take into account any changes in the server that are necessary, and change the configuration object given to the app accordingly. Second, it makes testing much easier because it allows differently configured applications to be tested quickly. Third, multiple instances of the same application using the same configuration can be created very easily. This is useful for situations where web traffic is balanced across several different servers.</p><p>Now that the benefits of application factories are clear, let's modify our <code class="literal">__init__.py</code> file to implement one:</p><pre class="programlisting">from flask import Flask, render_template
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

db = SQLAlchemy()
migrate = Migrate()


def page_not_found(error):
return render_template('404.html'), 404


def create_app(object_name):
from .blog.controllers import blog_blueprint
from .main.controllers import main_blueprint

    app = Flask(__name__)
    app.config.from_object(object_name)

    db.init_app(app)
    migrate.init_app(app, db)
    app.register_blueprint(main_blueprint)
    app.register_blueprint(blog_blueprint)
    app.register_error_handler(404, page_not_found)
return app</pre><p>The change to the file is very simple: we contained our code in a function that takes a <code class="literal">config</code> object and returns an application object. To start our application using the right configuration from an environment variable, we need to changeÂ <code class="literal">main.py</code>:</p><pre class="programlisting">import os
from webapp import create_app

env = os.environ.get('WEBAPP_ENV', 'dev')
app = create_app('config.%sConfig' % env.capitalize())

if __name__ == '__main__':
    app.run()</pre><p>We also need to modify our <code class="literal">manage.py</code> file in order to work with the <code class="literal">create_app</code> function as follows:</p><pre class="programlisting">import os
from webapp import db, migrate, create_app
from webapp.blog.models import User, Post, Tag

env = os.environ.get('WEBAPP_ENV', 'dev')
app = create_app('config.%sConfig' % env.capitalize())

@app.shell_context_processor
def make_shell_context():
return dict(app=app, db=db, User=User, Post=Post, Tag=Tag, migrate=migrate)</pre><p>When we created our configuration objects, it was mentioned that the environment that the application is running in could change the configuration of the application. This code has a very simple example of that functionality, where an environment variable is loaded and determines which <code class="literal">config</code> object to give to the <code class="literal">create_app</code> function. Environment variables are dynamic name values that are part of a process environment. These environments can be shared by multiple processes, system-wide, user-wide, or for a single process. They can be set in <span>Bash</span><a id="id325371649" class="indexterm"></a> with the following syntax:</p><pre class="programlisting"><span class="strong"><strong>$ export WEBAPP_ENV="dev"</strong></span></pre><p>Use this to read a variable:</p><pre class="programlisting"><span class="strong"><strong>$ echo $WEBAPP_ENV</strong></span>
    dev</pre><p>You can also delete the variable easily, as follows:</p><pre class="programlisting"><span class="strong"><strong>$ unset $WEBAPP_ENV</strong></span><span class="strong"><strong>$ echo $WEBAPP_ENV</strong></span></pre><p>On your production server, you would set <code class="literal">WEBAPP_ENV</code> to <code class="literal">prod</code>. The true power of this setup will become clearer once you deploy to production in <a class="link" href="#" linkend="ch13"><span>Chapter 13</span></a>, <span class="emphasis"><em>Deploying Flask Apps</em></span>, and when we get to <a class="link" href="#" linkend="ch12"><span>Chapter 12</span></a>, <span class="emphasis"><em>Testing Flask Apps</em></span>, which covers testing our project.</p></div>