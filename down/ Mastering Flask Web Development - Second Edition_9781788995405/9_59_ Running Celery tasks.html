<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec59"></a>Running Celery tasks</h2></div></div><hr /></div><p>The <code class="literal">delay</code> method is a <span>shorthand</span><a id="id324991602" class="indexterm"></a> version of the <code class="literal">apply_async</code> method, which is called in this format:</p><pre class="programlisting">task.apply_async( 
  args=[1, 2], 
  kwargs={'kwarg1': '1', 'kwarg2': '2'} 
) </pre><p>However, the <code class="literal">args</code> keyword can be implicit, as shown here:</p><pre class="programlisting">apply_async([1, 2], kwargs={'kwarg1': '1', 'kwarg2': '2'}) </pre><p>Calling <code class="literal">apply_async</code> allows you to define some extra functionality in the task call that you cannot specify in the <code class="literal">delay</code> method. First, the <code class="literal">countdown</code> option specifies the amount of time in seconds that the worker, upon receiving the task, should wait before running it:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from webapp.blog.tasks import log&gt;&gt;&gt; log.apply_async(["Message"], countdown=600)</strong></span></pre><p>The <code class="literal">countdown</code> is not a guarantee that the task will be run after <code class="literal">600</code> seconds. The <code class="literal">countdown</code> option only says that the task is up for processing after <span class="emphasis"><em>x</em></span> number of seconds. If all of the worker processes are busy with the other tasks, then it will not be run immediately.</p><p>Another keyword argument that <code class="literal">apply_async</code> gives is the <code class="literal">eta</code> argument. <code class="literal">eta</code> is passed through a Python <code class="literal">datetime</code> object that specifies exactly when the task should be run. Again, <code class="literal">eta</code> is not reliable:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import datetime</strong></span><span class="strong"><strong>&gt;&gt;&gt; from webapp.blog.tasks import log</strong></span><span class="strong"><strong># Run the task one hour from now</strong></span><span class="strong"><strong>&gt;&gt;&gt; eta = datetime.datetime.now() + datetime.timedelta(hours=1)</strong></span><span class="strong"><strong>&gt;&gt;&gt; log.apply_async(["Message"], eta=eta)</strong></span></pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec62"></a>Celery workflows</h3></div></div></div><p><span>Celery</span><a id="id325371667" class="indexterm"></a> provides many ways to group multiple, dependent tasks together, or to execute many tasks in parallel. These methods take a large amount of influence from language features found in <span>functional</span><a id="id325371841" class="indexterm"></a> programming languages. However, to understand how this works, we first need to understand signatures. Consider the following task:</p><pre class="programlisting">@celery.task() 
def multiply(x, y): 
    return x * y </pre><p>Let's see a <span class="strong"><strong>signature</strong></span> in action to understand it. Open up a Flask shell and enter the following:</p><pre class="programlisting"><span class="strong"><strong># Export FLASK_APP if you haven't already</strong></span>
<span class="strong"><strong>$ export FLASK_APP=main.py</strong></span>
<span class="strong"><strong>$ flask shell</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from celery import signature
&gt;&gt;&gt; from webapp.blog.tasks import multiply
# Takes the same keyword args as apply_async
&gt;&gt;&gt; signature('webapp.tasks.multiply', args=(4, 4), countdown=10)
</strong></span>webapp.tasks.multiply(4, 4)<span class="strong"><strong>
# same as above
&gt;&gt;&gt; from webapp.blog.tasks import multiply
&gt;&gt;&gt; multiply.subtask((4, 4), countdown=10)
</strong></span>webapp.tasks.multiply(4, 4)<span class="strong"><strong>
# shorthand for above, like delay in that it doesn't take
# apply_async's keyword args
&gt;&gt;&gt; multiply.s(4, 4)
</strong></span>webapp.blog.tasks.multiply(4, 4)<span class="strong"><strong>
&gt;&gt;&gt; multiply.s(4, 4)()
</strong></span>16<span class="strong"><strong>
&gt;&gt;&gt; multiply.s(4, 4).delay()
  </strong></span></pre><p> </p><p>Calling the signature (sometimes referred to as a <span class="strong"><strong>subtask</strong></span>) of a task creates a function <span>that</span><a id="id325379667" class="indexterm"></a> can be passed to the other functions to be executed. Executing the signature, like the third to last line in the preceding example, executes the function in the current process, and not in the worker.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec34"></a>Partials</h4></div></div></div><p>The first application of task signatures is <span>functional</span><a id="id325379680" class="indexterm"></a> programming style partials. <span class="strong"><strong>Partials</strong></span> are functions, which originally take many arguments, but an operation is applied to the original function to return a new function, so the first <span class="emphasis"><em>n</em></span> arguments are always the same. Consider the following example, where we have a <code class="literal">multiply</code> function <span>that</span><a id="id325379699" class="indexterm"></a> is not a task:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; new_multiply = multiply(2)
&gt;&gt;&gt; new_multiply(5)
</strong></span>10<span class="strong"><strong>
# The first function is unaffected
&gt;&gt;&gt; multiply(2, 2)
</strong></span>4
  </pre><p>This is a fictional API, but is very close to the Celery version:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; partial = multiply.s(4)</strong></span><span class="strong"><strong>&gt;&gt;&gt; partial.delay(4)</strong></span></pre><p>The output in the worker window should show <code class="literal">16</code>. Basically, we created a new function, saved to partial, that will always multiply its input by four.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec35"></a>Callbacks</h4></div></div></div><p>Once a task is completed, it is very common to run another task, based on the output of the previous task. To achieve this, the <code class="literal">apply_async</code> function has a <code class="literal">link</code> method, used as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; multiply.apply_async((4, 4), link=log.s())</strong></span></pre><p>The worker output should show <span>that</span><a id="id325537698" class="indexterm"></a> both the <code class="literal">multiply</code> task and the <code class="literal">log</code> task returned <code class="literal">16</code>.</p><p>If you have a function that does not take input, or your callback does not need the result of the original method, then the task signature must be marked as immutable with the <code class="literal">si</code> method:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; multiply.apply_async((4, 4), link=log.si("Message"))</strong></span></pre><p><span class="strong"><strong>Callbacks</strong></span> can be used to solve real-world problems. If we wanted to send a welcome email every time a task created a new user, then we could produce <span>that</span><a id="id325537733" class="indexterm"></a> effect with the following call:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; create_user.apply_async(("John Doe", password), link=welcome.s())</strong></span></pre><p>Partials and callbacks can be combined to produce some powerful effects:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; multiply.apply_async((4, 4), link=multiply.s(4))</strong></span></pre><p>It's important to note that, if this call were saved and the <code class="literal">get</code> method was called on it, the result would be <code class="literal">16</code>, rather than <code class="literal">64</code>. This is because the <code class="literal">get</code> method does not return the results for callback methods. This will be solved with later methods.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec36"></a>Group</h4></div></div></div><p>The <code class="literal">group</code> function takes a list of signatures and creates a callable <span>function</span><a id="id325735034" class="indexterm"></a> to execute all of the signatures in parallel, then returns a list of all of the results as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from celery import group
&gt;&gt;&gt; sig = group(multiply.s(i, i+5) for i in range(10))
&gt;&gt;&gt; result = sig.delay()
&gt;&gt;&gt; result.get()
</strong></span>[0, 6, 14, 24, 36, 50, 66, 84, 104, 126]</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec37"></a>Chain</h4></div></div></div><p>The <code class="literal">chain</code> function takes task <span>signatures</span><a id="id325735710" class="indexterm"></a> and passes the value of each result to the next value in the chain, returning one result, as follows:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from celery import chain
&gt;&gt;&gt; sig = chain(multiply.s(10, 10), multiply.s(4), multiply.s(20))
# same as above
&gt;&gt;&gt; sig = (multiply.s(10, 10) | multiply.s(4) | multiply.s(20))
&gt;&gt;&gt; result = sig.delay()
&gt;&gt;&gt; result.get()
</strong></span>8000
  </pre><p>Chains and partials can be taken a bit further. Chains can be used to create new functions when using partials, and chains can be nested as follows:</p><pre class="programlisting"><span class="strong"><strong># combining partials in chains 
&gt;&gt;&gt; func = (multiply.s(10) | multiply.s(2)) 
&gt;&gt;&gt; result = func.delay(16) 
&gt;&gt;&gt; result.get() 
</strong></span>320<span class="strong"><strong>
# chains can be nested 
&gt;&gt;&gt; func = ( multiply.s(10) | multiply.s(2) | (multiply.s(4) | multiply.s(5)) ) 
&gt;&gt;&gt; result = func.delay(16) 
&gt;&gt;&gt; result.get()
</strong></span>6400
  </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec38"></a>Chord</h4></div></div></div><p>The <code class="literal">chord</code> function creates a signature that will execute a <code class="literal">group</code> of <span>signatures</span><a id="id325735754" class="indexterm"></a> and pass the final result to a callback:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from celery import chord
&gt;&gt;&gt; sig = chord(
        group(multiply.s(i, i+5) for i in range(10)),
        log.s()
)
&gt;&gt;&gt; result = sig.delay()
&gt;&gt;&gt; result.get()
</strong></span>[0, 6, 14, 24, 36, 50, 66, 84, 104, 126]
  </pre><p>Just like the link argument, the callback is not returned with the <code class="literal">get</code> method.</p><p>Using the <code class="literal">chain</code> syntax with a group and a callback automatically creates a chord signature:</p><pre class="programlisting"><span class="strong"><strong># same as above
&gt;&gt;&gt; sig = (group(multiply.s(i, i+5) for i in range(10)) | log.s())
&gt;&gt;&gt; result = sig.delay()
&gt;&gt;&gt; result.get()
</strong></span>[0, 6, 14, 24, 36, 50, 66, 84, 104, 126]
  </pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec39"></a>Running tasks periodically</h4></div></div></div><p>Celery also has the ability to call tasks periodically. For those familiar with <span class="strong"><strong>*</strong></span><span class="strong"><strong>nix</strong></span> operating systems, this system is a lot like the command-line utility <code class="literal">cron</code>, but it has the added benefit of being defined in our source code rather than on some system file. As such, it will be much easier to update our code when it is ready for publishing to production—a stage that we will reach in <a class="link" href="#" linkend="ch13"><span>Chapter 13</span></a>, <span class="emphasis"><em>Deploying Flask Apps</em></span>. In addition, all of the tasks are run <span>within</span><a id="id325736328" class="indexterm"></a> the application context, whereas a Python script called by <code class="literal">cron</code> would not be.</p><p> </p><p>To add periodic tasks, add the following to the <code class="literal">DevConfig</code> configuration object:</p><pre class="programlisting">import datetime 
... 
CELERYBEAT_SCHEDULE = { 
    'log-every-30-seconds': { 
        'task': 'webapp.blog.tasks.log', 
        'schedule': datetime.timedelta(seconds=30), 
        'args': ("Message",) 
    }, 
} </pre><p>This <code class="literal">configuration</code> variable defines that the <code class="literal">log</code> task should be run every 30 seconds, with the <code class="literal">args</code> tuple passed as the parameters. Any <code class="literal">timedelta</code> object can be used to define the interval to run the task on.</p><p>To run the periodic tasks, another specialised worker, named a <code class="literal">beat</code> worker, is needed. In another Terminal window, run the following command:</p><pre class="programlisting"><span class="strong"><strong>$ celery -A celery_runner beat</strong></span></pre><p>If you now watch the Terminal output for the main <code class="literal">Celery</code> worker, you should now see a log event every 30 seconds.</p><p>What if your task needs to run on much more specific intervals; say, for example, every Tuesday in June at 3 am and 5 pm? For very specific intervals, there is the Celery <code class="literal">crontab</code> object.</p><p>To illustrate how the <code class="literal">crontab</code> object represents intervals, consider the following examples:</p><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from celery.schedules import crontab</strong></span><span class="strong"><strong># Every midnight</strong></span><span class="strong"><strong>&gt;&gt;&gt; crontab(minute=0, hour=0)</strong></span><span class="strong"><strong># Once a 5AM, then 10AM, then 3PM, then 8PM</strong></span><span class="strong"><strong>&gt;&gt;&gt; crontab(minute=0, hour=[5, 10, 15, 20])</strong></span><span class="strong"><strong># Every half hour</strong></span><span class="strong"><strong>&gt;&gt;&gt; crontab(minute='*/30')</strong></span><span class="strong"><strong># Every Monday at even numbered hours and 1AM</strong></span><span class="strong"><strong>&gt;&gt;&gt; crontab(day_of_week=1, hour ='*/2, 1')</strong></span></pre><p> </p><p> </p><p>The object has the following arguments:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">minute</code></li><li style="list-style-type: disc"><code class="literal">hour</code></li><li style="list-style-type: disc"><code class="literal">day_of_week</code></li><li style="list-style-type: disc"><code class="literal">day_of_month</code></li><li style="list-style-type: disc"><code class="literal">month_of_year</code></li></ul></div><p>Each of these arguments can take various inputs. With plain integers, they operate much like the <code class="literal">timedelta</code> object, but can also take strings and lists. When passed a list, the task will execute on every moment that is in the list. When passed a string in the form of <span class="emphasis"><em>*/x</em></span>, the task will execute every moment that the modulo operation returns zero. Also, the two forms can be combined to form a comma-separated string of integers and divisions.</p></div></div></div>