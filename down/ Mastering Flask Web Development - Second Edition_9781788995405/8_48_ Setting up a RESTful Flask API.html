<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec49"></a>Setting up a RESTful Flask API</h2></div></div><hr /></div><p>In our app, we will create a RESTful <span>interface</span><a id="id324993880" class="indexterm"></a> to the blog post data in our database. The representations of the data will be sent <span>as</span> JSON. The data will be retrieved and modified using the general form in the preceding table, but the URI will be <code class="literal">/api/posts</code>.</p><p>If you haven't already downloaded and accessed the example code given for this chapter and taken a look at the Flask URL maps for the API, then a simple way of doing this can be seen in the root directory of the application, as shown in the following code:</p><pre class="programlisting"><span class="strong"><strong>$ # Initialise the virtual environment and database with test data
$ ./init.sh
$ # Activate the python virtual environment
$ source venv/bin/activate
$</strong></span><span class="strong"><strong>export FLASK_APP=main.py
$ echo app.url_map | flask shell | grep api
</strong></span><span class="strong"><strong>..</strong></span>
 &lt;Rule '/auth/api' (POST, OPTIONS) -&gt; auth.api&gt;,
 &lt;Rule '/api/post' (HEAD, GET, PUT, POST, OPTIONS, DELETE) -&gt; postapi&gt;,
 &lt;Rule '/api/post/&lt;post_id&gt;' (HEAD, GET, PUT, POST, OPTIONS, DELETE) 
 -&gt; postapi&gt;,<span class="strong"><strong>
</strong></span></pre><p>We are going to implement an authentication endpoint for the API and the necessary endpoints to create a CRUD API for the blog posts.</p><p> </p><p>We could just use the standard Flask views to create the API, but the Flask extension <span><span class="strong"><strong>Flask Restful</strong></span></span> makes the task much easier and will help us adhere to a full REST compliance (RESTful).</p><p>To include this new dependency in our application, you can find the following in the <code class="literal">requirements.txt</code> file:</p><pre class="programlisting">... 
<span class="strong"><strong>Flask-Restful
</strong></span>...</pre><p>We are going to create a new module for the API. The application structure looks like the following code:</p><pre class="programlisting">./
  main.py
  config.py
  ...
  webapp/
    blog/
    main/
    auth/
<span class="strong"><strong>api/</strong></span>
<span class="strong"><strong>      __init__.py
</strong></span><span class="strong"><strong>blog/</strong></span>
<span class="strong"><strong>          controlers.py
          fields.py</strong></span>
<span class="strong"><strong>          parsers.py</strong></span>
    templates/
    static/</pre><p>Once again, the idea is to structure our application so that it can grow easily. This time, for each application module we add—such as a blog, shared photos, you name it—we create a new module inside the <code class="literal">api/</code> module itself where all the API logic is defined. A different approach could be to include the REST API inside each module.</p><p>Just like with all the other modules, there is a <code class="literal">create_module</code> function on the <code class="literal">api/__init__.py</code> that handles its own initialization for the main factory function, <code class="literal">create_app</code> . The <code class="literal">PostApi</code> class will also have its route defined with the <code class="literal">add_resource()</code> method of the <code class="literal">Api</code> object.</p><p>This can be seen in the provided code file, <code class="literal">api/__init__.py</code>, as follows:</p><pre class="programlisting">from flask_restful import Api
from .blog.controllers import PostApi

rest_api = Api()


def create_module(app, **kwargs):
    rest_api.add_resource(
        PostApi,
'/api/post',
'/api/post/&lt;int:post_id&gt;',
)
    rest_api.init_app(app)</pre><p>It can also be seen in the <code class="literal">create_app</code> function in <code class="literal">__init__.py</code> file, as follows:</p><pre class="programlisting">...
def create_app(object_name):
...
from api import create_module as api_create_module
    ...
    api_create_module(app)

return app</pre><p>The control logic and views for our <code class="literal">Post</code> API are stored in a new folder named <code class="literal">api/blog</code> in the <code class="literal">controllers.py</code> file. Inside the <code class="literal">controllers.py</code>, we are going to create the API itself, as follows:</p><pre class="programlisting">from flask_restful import Resource 
 
class PostApi(Resource): 
  ...</pre><p>In <span>Flask Restful</span>, every REST resource is defined as a class that inherits from the <code class="literal">Resource</code> object. Much like the <code class="literal">MethodView</code> object shown in <a class="link" href="#" linkend="ch04"><span>Chapter 4</span></a>, <span class="emphasis"><em>Creating Controllers with Blueprints</em></span>, any class that inherits from the <code class="literal">Resource</code> object defines its logic with methods named after the HTTP methods. For example, when the <code class="literal">GET</code> HTTP method hits the <code class="literal">PostApi</code> class, the <code class="literal">get</code> method will be executed.</p><p> </p><p> </p></div>