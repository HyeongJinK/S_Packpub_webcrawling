<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch12lvl1sec80"></a>Test-driven development</h2></div></div><hr /></div><p>Now that we have our tests written, how can they be integrated into the development process? Currently, we are using our tests in order to ensure code correctness after we create a feature. But, what if we flipped the order and used tests in order to create correct <span>code</span><a id="id324974901" class="indexterm"></a> from the beginning? This is what <span class="strong"><strong>test-driven development</strong></span> (<span class="strong"><strong>TDD</strong></span>) advocates.</p><p>TDD follows a simple loop to write the code of a new feature in your <span>application</span>:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/a111c868-5736-4255-b5e0-5f292d524656.png" /></div><p>In a project that uses TDD, the first thing that you write, before any of the code that controls what you are actually building, is the tests. What this forces the programmers on the project to do is to plan out the project's scope, design, and requirements before writing any code. While designing APIs, it also forces the programmer to design the interface (or contract) of the API from a consumer's perspective, rather than design the interface after all the backend code has been written.</p><p>In TDD, tests are designed to fail the first time that you run them. There is a saying in TDD, that if your tests don't fail the first time that you run them, you're not really testing anything. What this means is that you are most likely testing to the <span>tested unit's function, rather than how it should function</span> while writing tests after the fact.</p><p>After your tests fail the first time, you then continuously write code until all the tests pass. This process is repeated for each new feature.</p><p>Once all of the original tests pass and the code is refactored, TDD tells you to stop writing code. By only writing <span>code</span><a id="id325371666" class="indexterm"></a> until the tests pass, TDD also enforces the <span class="strong"><strong>You Aren't Going To Need It</strong></span> (<span class="strong"><strong>YAGNI</strong></span>) philosophy, which states that programmers should only implement what they actually need, rather than what they perceive they will need. A huge amount of wasted effort is made during development when programmers try to preemptively add functionality when no-one needed it.</p><p>TDD also promotes the idea of <span class="strong"><strong>Keep It Simple, Stupid</strong></span> (<span class="strong"><strong>KISS</strong></span>), which dictates that simplicity should be a design goal from the beginning. TDD promotes KISS because it requires small, testable units of <span>code</span><a id="id325371857" class="indexterm"></a> that can be separated from each other and don't rely on a shared global state.</p><p>Also, in projects that follow TDD, there is an always-current documentation throughout the tests. One of the axioms of programming is that with any sufficiently large program, the documentation will always be out of date. This is because the documentation is one of the last things on the mind of the programmer when they are changing the code. However, with tests, there are clear examples of each piece of functionality in the project (if the project has a large <span>code</span><a id="id325371865" class="indexterm"></a> coverage percentage). The tests are updated all the time, and therefore, show good examples of how the functions and API of the program should work.</p><p>Now that you understand Flask's functionality and how to write tests for Flask, the next project that you create in Flask can be made entirely with TDD.</p><p> </p><p> </p></div>