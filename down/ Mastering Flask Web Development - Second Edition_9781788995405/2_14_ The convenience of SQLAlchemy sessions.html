<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec21"></a>The convenience of SQLAlchemy sessions</h2></div></div><hr /></div><p>Now you understand the power of SQLAlchemy and what the <span>SQLAlchemy</span><a id="id324847030" class="indexterm"></a> session object is, and why web apps should never be made without them. As stated before, the session can be simply described as an object that tracks the changes in our models and commits them to the database when we tell it to. However, there is a bit more to it than this.</p><p>First, the session is also the handler for <span class="strong"><strong>transactions</strong></span>. Transactions are sets of <span>changes</span><a id="id325369000" class="indexterm"></a> that are flushed to the database on commit. Transactions provide a lot of hidden functionality. For example, transactions automatically determine which objects are to be saved first when objects have relations. You might have noted this when we were saving tags in the previous section. When we added tags to the posts, the session automatically knew to save the tags first despite the fact that we did not add them to be committed. If we are working with raw SQL queries and a database connection, we will have to keep track of which rows are related to which other rows to avoid saving a foreign key reference to an object that does not exist.</p><p> </p><p>Transactions also automatically mark data as stale when changes to an object are saved to the database. The next time we access the object, a query is made to the database to update the data, but all of this happens behind the scenes. If we are not using SQLAlchemy, we will also need to manually track which rows need to be updated. If we want to be resource efficient, we only need to query and update those rows.</p><p>Second, the session makes it impossible for there to be two different references to the same row in the database. This is accomplished by ensuring that all queries go through the session (<code class="literal">Model.query</code> is actually <code class="literal">db.session.query(Model)</code>), and if the row has already been queried in this transaction, that the pointer to that object will be returned and not a new object. If this check did not exist, two objects that represent the same row could be saved to the database with different changes. This creates subtle bugs that might not be caught instantly.</p><p>Keep in mind that Flask SQLAlchemy creates a new session for every request and discards any changes that were not committed at the end of the request, so always remember to save your work.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"></a>Note</h3><p>For an in-depth look at sessions, the creator of SQLAlchemy, Mike Bayer, gave a talk at PyCon Canada 2012. Refer to <span class="emphasis"><em>The SQLAlchemy Session - In Depth</em></span>, at <a class="ulink" href="https://www.youtube.com/watch?v=PKAdehPHOMo" target="_blank"><span>https://www.youtube.com/watch?v=PKAdehPHOMo</span></a>.</p></div></div>