<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec37"></a>Authentication methods</h2></div></div><hr /></div><p>An authentication method is a process of <span>confirming</span><a id="id325641009" class="indexterm"></a> an identity. In the case of an application, a user is given a username and a secret security token (password) and uses them to verify their identity on the application itself. There are several authentication methods and types, used for different types of applications (such as API, web exposed, intranet, and government). We will be covering the most used type of authentication—single factor.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec35"></a>Basic authentication</h3></div></div></div><p>As the name suggests, basic authentication is a <span>very</span><a id="id325641024" class="indexterm"></a> simple authentication method implemented by the HTTP protocol itself. It is part of the RFC7617. To use it, we can configure our <span>web</span><a id="id325641032" class="indexterm"></a> servers (IIS, Apache, and NGINX) to implement it, or we can implement it ourselves.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Note</h3><p>For details on how to configure NGINX for basic authentication, go to <a class="ulink" href="https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/" target="_blank">https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/</a>.</p></div><p>The basic authentication protocol goes through the following general steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The user requests a protected resource from the server.</li><li>The server responds with <code class="literal">401</code> (unauthorized) and the HTTP header <code class="literal">WWW-Authenticate: Basic realm="Login required"</code><span class="emphasis"><em>.</em></span></li><li>The browser will display a basic authentication login window for the user to send a username/password back to the server.</li><li>The username and password provided by the user will be sent to the server on the HTTP header with the form <code class="literal">Authorization: Basic &lt;Username&gt;:&lt;Password&gt;</code><span class="emphasis"><em>.</em></span>The<code class="literal">username:password</code>will be base64-encoded.</li></ol></div><p>Flask will make it easy for us to implement this protocol, since it will automatically decode the base64 authorization from the HTTP header <span>and place the username and password has properties of the</span> <code class="literal">Request.authorization</code> object, as shown in the following code:</p><pre class="programlisting"><span>def authenticate(username, password):
    return username == 'admin' and password == 'password'

@app.route</span><span>(</span><span>'/basic-auth-page'</span><span>)</span><span>def</span><span>basic_auth_page</span><span>():
</span>    auth = request.authorization
<span>if</span><span>not</span><span>auth</span><span>or</span><span>not</span><span>authenticate</span><span>(</span><span>auth</span><span>.</span><span>username</span><span>,</span><span>auth</span><span>.</span><span>password</span><span>)
        return Response('Login with username/password', 401, {</span><span>'WWW-Authenticate'</span><span>:</span><span>'Basic realm="Login Required"'</span><span>})
</span><span>    return</span><span>render_template</span><span>(</span><span>'some_page.html'</span><span>)</span></pre><p>This type of authentication is very simple, but not very secure. The username and password will be sent to the server on every request, so make sure that you always use HTTPS to properly encrypt their transmission over the wire. Additionally, as you may have already noticed in the code flow of the preceding example, the authentication method will be invoked on every request, so it is not very efficient. Yet this can be a good option for the internal use of a very simple back-office application, or for rapidly protecting a proof-of-concept application.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec36"></a>Remote-user authentication</h3></div></div></div><p>We can, with some intranet setups, use <span>single</span><a id="id325767093" class="indexterm"></a> sign-on authentication methods, where the <span>web</span><a id="id325768536" class="indexterm"></a> servers do all the heavy lifting related with security. This can be done using <span class="strong"><strong>IIS integrated windows authentication</strong></span> or <span class="strong"><strong>Apache mod_auth_sspi</strong></span>, <span class="strong"><strong>Apache Samba</strong></span>, or others. The setup is beyond the scope of this book. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Note</h3><p>You can check out some examples of how to set up this kind of authentication with Apache Samba at <a class="ulink" href="https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory" target="_blank">https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory</a>.</p></div><p>With this kind of authentication method, the web server will pass the already authenticated username as an environment key to the<span class="strong"><strong>WSGI</strong></span>(<span class="strong"><strong>web server gateway interface</strong></span>), so we just have to fetch it <span>using</span><a id="id325768576" class="indexterm"></a> the following:</p><pre class="programlisting"> username <span>=</span> request.environ.get(<span><span>'</span>REMOTE_USER<span>'</span></span>)</pre><p>For our blog application, we could just check whether the user exists on the database, so no password database field is needed. This authentication method can be considered secure if it is properly set up on the server, and can be very convenient on intranet setups since the user, if already authenticated on the domain (for example, Active Directory) will no longer need to fill his/her login/password again (using Kerberos GSSAPI, or Windows SSPI, for example). </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec37"></a>LDAP authentication</h3></div></div></div><p><span class="strong"><strong>LDAP</strong></span> (<span class="strong"><strong>lightweight directory access protocol</strong></span>) is an open standard described currently by RFC4511. Its purpose is to implement a distributed information directory over the IP. This <span>directory</span><a id="id325787734" class="indexterm"></a> can contain different types of information normally related to users, groups, and devices. It has a fixed schema describing each object's attributes, but this schema can be changed <span>using</span><a id="id325787742" class="indexterm"></a> LDIF.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip24"></a>Note</h3><p>Active Directory is Microsoft's implementation of LDAP. You can take a look at the base-implemented user attributes that are available at <a class="ulink" href="http://www.kouti.com/tables/userattributes.htm" target="_blank">http://www.kouti.com/tables/userattributes.htm</a>.</p></div><p>An entry (for example, the user) on the <span>directory</span><a id="id325787761" class="indexterm"></a> is identified by a <span class="strong"><strong>distinguished name</strong></span> (<span class="strong"><strong>DN</strong></span>). For example, take a look at the following code:</p><pre class="programlisting">CN=user1,OU=Marketing,DC=example,DC=com</pre><p>The <code class="literal">DC</code><span class="strong"><strong> </strong></span>phrase is the domain component, and it identifies the domain where the user is (an LDAP <span>directory</span><a id="id325848240" class="indexterm"></a> can have trees of domains and subdomains). In our example, the domain is <code class="literal">example.com</code>. The phrase<code class="literal"> OU</code> refers to the organizational unit where the user is, and <code class="literal">CN</code><span class="strong"><strong> </strong></span>is its common name. </p><p>The LDAP implements various operations, such as adding users, searching, deleting and so on. For authentication purposes only, we are interested on the <code class="literal">Bind</code> and <code class="literal">Search</code> operations. </p><p>To use the LDAP, we will need to install <code class="literal">python-ldap</code>, so let's do that first using the following code:</p><pre class="programlisting"><span class="strong"><strong>$ pip install python-ldap</strong></span></pre><p>The two most commonly used LDAP services nowadays are <span class="strong"><strong>OpenLDAP</strong></span> (open and free) and <span class="strong"><strong>Microsoft Active Directory</strong></span> (commercial). Their implementation differs a bit, mainly <span>regarding</span><a id="id325848290" class="indexterm"></a> their user attributes. The following code is an example of Active Directory. First, we need to define some configuration keys to connect to and <span>authenticate</span><a id="id325848298" class="indexterm"></a> with the service:</p><pre class="programlisting">import ldap

LDAP_SERVER="ldap://example.com:389"
ROOT_DN="dc=example,dc=com"
SERVICE_USER="ServiceAccount"
SERVICE_PASSWORD="SOME_PASSWORD"
UID_FIELD_NAME="userPrincipalName" # specific for AD
USER_DOMAIN="example.com"</pre><p>Note that we are using nonencrypted communication between our application server and the LDAP server; we can turn encryption on by using digital certificates and using LDAPS on our <code class="literal">LDAP_SERVER</code> configuration key.</p><p>If we were to integrate LDAP authentication with our blog application, these values would be good candidates for our configuration on <code class="literal">config.py</code><span class="emphasis"><em><span class="strong"><strong>.</strong></span></em></span></p><p>Next, we will connect to and <span>authenticate</span> with the service as follows:</p><pre class="programlisting">con = ldap.initialize(LDAP_SERVER)
con.set_option(ldap.OPT_REFERRALS, 0)
con.bind_s(SERVICE_USER, SERVICE_PASSWORD)</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>The <code class="literal">OPT_REFERRALS</code> is a specific workaround for MSFT AD. Take a look at the FAQ for <code class="literal">python-ldap</code> for more detailed information at <a class="ulink" href="https://www.python-ldap.org/en/latest/faq.html" target="_blank">https://www.python-ldap.org/en/latest/faq.html</a>.</p></div><p>Now that we have an authenticated connection, we will search for our user to fetch its username, as shown in the following code. In Active Directory, we could <span>bind</span> directly using the user's username and password, yet that method would fail in OpenLDAP. This way, we are following the standard method that will work on both systems:</p><pre class="programlisting">username = username + '@' + USER_DOMAIN
filter_str = "%s=%s" % (UID_FIELD_NAME, username)
user = con.search_s(ROOT_DN,
                        ldap.SCOPE_SUBTREE,
                        filter_str,
                        ["givenName","sn","mail"])</pre><p>A complete authentication function for LDAP could be as follows:</p><pre class="programlisting">def ldap_auth(username, password):
    con = ldap.initialize(LDAP_SERVER)
    con.set_option(ldap.OPT_REFERRALS, 0)
    username = username + '@' + USER_DOMAIN
    con.bind_s(SERVICE_USER, SERVICE_PASSWORD)
    filter_str = "%s=%s" % (UID_FIELD_NAME, username)
    user = con.search_s(ROOT_DN,
                        ldap.SCOPE_SUBTREE,
                        filter_str,
                        ["givenName","sn","mail"])
<span class="strong"><strong>if user:</strong></span>
<span class="strong"><strong>        print("LDAP got User {0}".format(user))</strong></span>
<span class="strong"><strong>        # username = DN from search</strong></span>
<span class="strong"><strong>        username = user[0][0]</strong></span>
<span class="strong"><strong>        try:</strong></span>
<span class="strong"><strong>            con.bind_s(username, password)</strong></span>
<span class="strong"><strong>            return True</strong></span>
<span class="strong"><strong>        except ldap.INVALID_CREDENTIALS:</strong></span>
<span class="strong"><strong>            return False</strong></span>
    else:
        return False</pre><p>Finally, with the LDAP username we make a final bind to authenticate our user (the highlighted code).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec38"></a>Database user model authentication</h3></div></div></div><p>Database authentication is widely <span>used</span><a id="id325885080" class="indexterm"></a> for internet-faced applications. If properly implemented, it can be considered a secure method. It has the advantages of being simple to add new users, and having no dependency on any external services. Security roles, groups, fine-grained access permissions, and extra user attributes are also all kept on the database. These can be easily changed without any external dependencies, and maintained within the scope change of the application.</p><p>This authentication method consists of checking the username and password submitted by a user against the stored attributes in our database's user model. But until now, our users had their passwords stored as plain text in the database. This is a major security flaw. If any malicious user were to gain access to the data in the database, they could log in to any account. The fallout of such a breach not be limited to our site. Large numbers of people on the internet use a common password for many sites. If an attacker had access to an email and password combination, it is very likely that this information could be used to log in to a Facebook account, or even a bank account.</p><p>To protect our user passwords, they will be encrypted with a one-way encryption method called a <span class="strong"><strong>hashing algorithm</strong></span>. A one-way encryption means that after the information is encrypted, the original information cannot be regained from the result. However, given the same data, the hashing algorithm will always produce the same result. The data given to the hashing algorithm can be anything from a text file to a movie file. In this case, the data is just a string of characters. With this functionality, our passwords can be stored as <span class="strong"><strong>hashes</strong></span> (data that has been hashed). Then, when a user enters their password in the login or registration page, the text entered for the password will be sent through the same hashing algorithm, and the stored hash and the entered hash will be verified.</p><p>This is one of the authentication methods we will use; further implementation details are described later in this chapter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec39"></a>OpenID and OAuth</h3></div></div></div><p>Integrating alternative login and registration <span>options</span><a id="id325895011" class="indexterm"></a> into your site becomes <span>more</span><a id="id325895019" class="indexterm"></a> important as time goes on. Every month, there is another announcement that passwords have been stolen from a popular website. Implementing the following login options means that our site's database never stores a password for that user. Verification is handled by a large brand-named company that the user already places their trust in. By using social logins, the amount of trust a user has to place in the website they are using is much <span>higher</span>. Your login process also becomes much shorter for the user, decreasing the barrier to entry to your app.</p><p>Socially authenticated users act as normal users, and unlike the password-based login methods, they can all be used in tandem.</p><p><span class="strong"><strong>OpenID</strong></span> is an open-standard authentication protocol that allows users on one site to be authenticated by any third-party site that implements the protocol, which are called <span class="strong"><strong>identity providers</strong></span>. An OpenID login is <span>represented</span><a id="id325895045" class="indexterm"></a> as a URL from one of the identity providers, typically the profile page of the website. The users that wish to use this authentication method need to be already registered on at least one of the OpenID providers.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"></a>Note</h3><p>To see a full list of sites that use OpenID, and to learn how to use each one, go to <a class="ulink" href="https://openid.net/get-an-openid/" target="_blank"><span>https://openid.net/get-an-openid/</span></a>.</p></div><p>During the process of authentication, the user is redirected to the OpenID provider, where the user can authenticate—typically using a username/password, but it can be any other method—and is asked if they trust the party (our application). If the user trusts our application and authenticates successfully, then the user is redirected back with a document holding some requested user information (such as the username or email). A final request is made to check whether the data really came from the provider.</p><p><span class="strong"><strong>OAuth</strong></span> is not an <span>authentication</span><a id="id325914800" class="indexterm"></a> method—it is an access-delegation method. It was mainly designed to enable third-party applications to interact with the OAuth providers (Facebook, Twitter, and so on). With it, we can design an application to interact with a user's Facebook account, performing actions such as posting on his behalf, sending notifications, retrieving their friends list, and so on.</p><p>To start using OAuth, we first need to register our application on the OAuth provider and use its consumer key and secret token.</p><p> </p><p>For Facebook, we need to register our application at <a class="ulink" href="http://developers.facebook.com" target="_blank"><span>http://developers.facebook.com</span></a>. Once you create a new app, look for the panel that lists your app's ID and secret key, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781788995405/graphics/38a737e2-cd2c-4bb2-9274-19d1863c56ad.png" /></div><p> To create a <span>Twitter</span><a id="id325914832" class="indexterm"></a> app and receive your keys, go to <a class="ulink" href="https://apps.twitter.com/" target="_blank"><span>https://apps.twitter.com/</span></a><span>. </span>Please do so, since we are going to use these keys, tokens and configuration information to set up our blog application for OAuth pseudoauthentication. </p><p>The OAuth process is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The application requests access to a user's resources from the OAuth provider.</li><li>The user is redirected and authorizes the requested access.</li><li>The application receives an authorization grant, and requests an access token by providing its own credentials (key and token) as well as the received grant.</li><li>The application receives the access token (this will serve as our <span>authentication</span><a id="id325942069" class="indexterm"></a> method) and can be further used to interact with the provider API on behalf of our user.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip27"></a>Note</h3><p>For a view of the complete OAuth process, go to <a class="ulink" href="https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2" target="_blank">https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2</a>.</p></div><p>Since we will be using both methods in our application, you will find the implementation details in the following <span>chapters</span>.</p><p> </p></div></div>