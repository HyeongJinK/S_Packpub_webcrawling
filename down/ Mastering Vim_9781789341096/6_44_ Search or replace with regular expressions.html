<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec46"></a>Search or replace with regular expressions</h2></div></div><hr /></div><p>Regular expressions (or regexes) are wonderful, and you <span>should</span><a id="id326567429" class="indexterm"></a> know how to use them. Vim, as is custom among regex implementations, has its own flavor of regex. However, once you learn one, you're comfortable with all of them.</p><p>First, let's talk about the regular (that is, the normal) search and replace command.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec52"></a>Search and replace</h3></div></div></div><p>Vim supports search and replace through the <code class="literal">:substitute</code> command, most <span>often</span><a id="id326400081" class="indexterm"></a> abbreviated to <code class="literal">:s</code>. By default, <code class="literal">:s</code> will replace one substring with another in a current line. It has the following format:</p><pre class="programlisting"><span class="strong"><strong>:s/&lt;find-this&gt;/&lt;replace-with-this&gt;/&lt;flags&gt;</strong></span></pre><p>The flags are optional, and you shouldn't worry about them for now. To try it, open <code class="literal">animal_farm.py</code>, navigate to the line containing <code class="literal">cat</code> (for example, with <code class="literal">/cat</code>), and execute the following:</p><pre class="programlisting"><span class="strong"><strong>:s/cat/dog</strong></span></pre><p>As you can see in the screenshot, this replaces the first occurrence of <code class="literal">cat</code> in the current line:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/d22c3173-3157-4e41-8308-209f681b36d6.png" /></div><p>Now, let's look at the flags you can pass to the substitute command:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">g</code>—global replace: replace every occurrence of the pattern, not just the first one</li><li style="list-style-type: disc"><code class="literal">c</code> —confirm each substitution: prompt the user before replacing the text</li><li style="list-style-type: disc"><code class="literal">e</code> —do not show errors if no matches are found</li><li style="list-style-type: disc"><code class="literal">i</code> —ignore case: make the search case-insensitive</li><li style="list-style-type: disc"><code class="literal">I</code> —make the search case-sensitive</li></ul></div><p>You can mix and match these (except for <code class="literal">i</code> and <code class="literal">I</code>) as you see fit. For example, running <code class="literal">:s/cat/dog/gi</code> will turn the string <code class="literal">cat.Cat()</code> into <code class="literal">dog.dog()</code>.</p><p><code class="literal">:substitute</code> can be prefixed by a range, which tells it what to operate on. The most common range used with <code class="literal">:substitute</code> is <code class="literal">%</code>, which makes <code class="literal">:s</code> operate on the current file.</p><p>For instance, if we wanted to replace each instance of <code class="literal">animal</code> in a file with <code class="literal">creature</code>, we would run the folxlowing:</p><pre class="programlisting"><span class="strong"><strong>:%s/animal/creature/g</strong></span></pre><p>If you try it on <code class="literal">animal_farm.py</code>, you'll see, as in the screenshot, that every instance of <code class="literal">animal</code> was replaced with <code class="literal">creature</code>:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/26cb4b89-6d1a-4ff9-bb71-460591d30d41.png" /></div><p>The <code class="literal">:substitute</code> command conveniently tells us how many matches <span>were</span><a id="id326400513" class="indexterm"></a> replaced in the status line at the bottom of the screen.</p><p>It seems as if we just completed a very simple case of refactoring!</p><p><code class="literal">:substitute</code> supports more ranges. Here are some common ones:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">numbers—a line number</li><li style="list-style-type: disc"><code class="literal">$</code>—the last line in the file
</li><li style="list-style-type: disc"><code class="literal">%</code>—a whole file (this is one of the most used ones)</li><li style="list-style-type: disc"><code class="literal">/search-pattern/</code>—lets you find a line to operate on</li><li style="list-style-type: disc"><code class="literal">?backwards-search-pattern?</code>—does the same thing as the previous flag, but searches backwards</li></ul></div><p>Furthermore, you can combine the ranges with a <code class="literal">;</code> operator. For example, <code class="literal">20;$</code> will let you search from line 20 until the end of the file.</p><p>To demonstrate, the following command will search for and replace every instance of <code class="literal">animal</code> with <code class="literal">creature</code> from line 12, up to and including the line where it encounters <code class="literal">dog</code>:</p><pre class="programlisting"><span class="strong"><strong>:12;/dog/s/animal/creature/g</strong></span></pre><p>As you can see in the following screenshot, two instances of <code class="literal">animal</code> were replaced on lines 13 and 14, but not on lines 10 or 21 (I've enabled line number display by running <code class="literal">:set nu</code>):</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/6946ac72-cd79-4250-beac-cb5e383863f5.png" /></div><p>You can also select a range in a visual mode, and run <code class="literal">:s</code> without any explicit ranges to operate on a selected text. See <code class="literal">:help cmdline-ranges</code> for more information on ranges.</p><p> </p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip116"></a>Note</h3><p>If you find yourself working with Linux file paths (or anything with <code class="literal">/</code> in them), you can escape them by prefixing with a backslash (<code class="literal">\</code>), or change the separator. For example, <code class="literal">:s+path/to/dir+path/to/other/dir+gc</code> is (with a separator changed to <code class="literal">+</code>) equivalent to <code class="literal">:s/path\/to\/dir/path\/to\/other\/dir/gc</code>.</p></div><p>Most often, you will find yourself <span>replacing</span><a id="id326407463" class="indexterm"></a> all occurrences in the <span>whole</span><a id="id326407472" class="indexterm"></a> file by running the following:</p><pre class="programlisting"><span class="strong"><strong>:%s/find-this/replace-with-this/g</strong></span></pre><p>When replacing text, you may want to only search for the whole word. You can use <code class="literal">\&lt;</code> and <code class="literal">\&gt;</code> for this purpose. For example, given the following file, we can search for <code class="literal">/animal</code> (<code class="literal">:set hlsearch</code> is enabled to highlight all results), but we also get results we're not exactly interested in, such as <code class="literal">animals</code>:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/b130bf38-725d-4454-963e-bcfc8bdf7778.png" /></div><p> </p><p>However, if we search for <code class="literal">/\&lt;animal\&gt;</code>, we'll be able to match whole words only, without falsely detecting <code class="literal">animals</code>, as follows:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/894a8640-078e-480b-af85-f7f39666f0ea.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec53"></a>Operations across files using arglist</h3></div></div></div><p>Arglist allows you to perform the same operation on <span>multiple</span><a id="id326450418" class="indexterm"></a> files, without having to have <span>them</span><a id="id326450426" class="indexterm"></a> preloaded in buffers first.</p><p>Arglist provides a few commands, as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">:arg</code> defines the arglist.</li><li style="list-style-type: disc"><code class="literal">:argdo</code> allows you to execute a command on all the files in the arglist.</li><li style="list-style-type: disc"><code class="literal">:args</code> displays the list of files in the arglist.</li></ul></div><p> </p><p>For example, if we wanted to replace all instances of <code class="literal">animal</code> in every Python file (recursively), we would do the following:</p><pre class="programlisting"><span class="strong"><strong>:arg **/*.py</strong></span>
<span class="strong"><strong>:argdo %s/\&lt;animal\&gt;/creature/ge | update</strong></span></pre><p>This command work as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">:arg &lt;pattern&gt;</code> adds a set of files matching a pattern to the arglist (each argument in arglist also has a corresponding buffer).</li><li style="list-style-type: disc"><code class="literal">**/*.py</code> is a wildcard for every <code class="literal">.py</code> file, recursively starting with the current directory.</li><li style="list-style-type: disc"><code class="literal">:argdo</code> executes a command on every item in the argument list.</li><li style="list-style-type: disc"><p><code class="literal">%s/\&lt;animal\&gt;/creature/ge</code> replaces every occurrence of <code class="literal">animal</code> with <code class="literal">creature</code>, in every file, without raising errors if the matches are not found.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note117"></a>Note</h3><p>As mentioned above, <code class="literal">\&lt;</code> and <code class="literal">\&gt;</code> around <code class="literal">animal</code> tell Vim to only replace a whole word, so we won't be replacing occurrences like <code class="literal">animal_farm</code> or <code class="literal">animals</code>.</p></div><p><code class="literal">:update</code> is equivalent to <code class="literal">:write</code>, but it only saves the file if the buffer has been modified.</p><p>You need to use <code class="literal">:update</code> in arglist commands, because Vim doesn't like when you switch buffers without saving their contents. An alternative would be to use <code class="literal">:set hidden</code> to silence these warnings, and save all files at the end by running <code class="literal">:wa</code>.</p><p>Give it a shot, and you'll see that every occurrence of a word has been replaced (you can check by running <code class="literal">git status</code> or <code class="literal">git diff</code> if you have a repository checked into Git). You can also view the contents of the arglist by running  the following without any arguments:</p><pre class="programlisting"><span class="strong"><strong>:args </strong></span></pre><p>Arglist is actually left over from the Vi days—it was used in a similar way to how we use buffers today. Buffers expand upon an argument list: every arglist entry is in the buffer list, but not every buffer is in the arglist.</p><p>Technically, you can also use <code class="literal">:bufdo</code> to perform an operation on every open buffer (since arglist entries are reflected in the buffer list). However, I would advise against it, since there is a risk of running a command on buffers you unintentionally had open before populating the argument list.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec54"></a>Regex basics</h3></div></div></div><p>Regular expressions work in <span>substitution</span><a id="id326491882" class="indexterm"></a> commands, as well as in search. Regex introduces special patterns that can be used to match a set of characters; for example, see the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">\(c\|p\)arrot</code> matches both <code class="literal">carrot</code> and <code class="literal">parrot</code>—the <code class="literal">\(c\|p\)</code> denotes either <code class="literal">c</code> or <code class="literal">p</code>.</li><li style="list-style-type: disc"><code class="literal">\warrot\?</code> matches <code class="literal">carrot</code>, <code class="literal">parrot</code>, and even <code class="literal">farro</code>—the <code class="literal">\w</code> signifies any word character, and the <code class="literal">t\?</code> means that the <code class="literal">t</code> is optional.</li><li style="list-style-type: disc"><code class="literal">pa.\+ot</code> matches <code class="literal">parrot</code>, <code class="literal">patriot</code>, or even <code class="literal">pa123ot</code>—the <code class="literal">.\+</code> denotes one or more of any character.</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip118"></a>Note</h3><p>If you're familiar with other variations of regex, then you'll notice that unlike in many other regex flavors, most special characters need to be escaped with <code class="literal">\</code> to work (the default mode for most characters is non-regex, with a few exceptions such as <code class="literal">.</code> or <code class="literal">*</code>). This behavior can be reversed by using magic mode, as we will cover below.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec35"></a>Special regex characters</h4></div></div></div><p>Let's dig <span>deeper</span><a id="id326516896" class="indexterm"></a> into regex:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Symbol</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Meaning</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">.</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Any character, except for end of the line</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">^</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The beginning of the line</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">$</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The end of the line</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\_</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Any character, including end of the line</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\&lt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>The beginning of a word</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">\&gt;</code></p></td><td style=""><p>The end of a word</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip119"></a>Note</h3><p>You can see the full list of these using <code class="literal">:help ordinary-atom</code>.</p></div><p> </p><p> </p><p>There are also what Vim calls character classes:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Symbol</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Meaning</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\s</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Whitespace (<span class="emphasis"><em>Tab</em></span> and Space)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\d</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>A digit</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\w</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>A word character (digits, numbers or underscores)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\l</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>A lowercase character</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\u</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>An uppercase character</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">\a</code></p></td><td style=""><p>An alphabetic character</p></td></tr></tbody></table></div><p> </p><p>These classes have the opposite effect when capitalized; for example, <code class="literal">\D</code> matches all non-digit characters, whereas <code class="literal">\L</code> matches everything but lowercase letters (note that this is different to just matching uppercase letters).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip120"></a>Note</h3><p>You can see the full list by checking out <code class="literal">:help character-classes</code>.</p></div><p>You can also specify a set of characters explicitly, using square brackets (<code class="literal">[]</code>). For instance, <code class="literal">[A-Z0-9]</code> will match all uppercase characters and all digits, while <code class="literal">[,4abc]</code> will only match commas, the number <code class="literal">4</code>, and letters <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code>.</p><p>For sequences (such as numbers or letters of the alphabet), you can use a hyphen (<code class="literal">-</code>) to represent a range. For instance, <code class="literal">[0-7]</code> will include numbers from <code class="literal">0</code> to <code class="literal">7</code>, and <code class="literal">[a-z]</code> will include all lowercase letters from <code class="literal">a</code> to <code class="literal">z</code>.</p><p>Here's one more example, including letters, numbers, and underscores: <code class="literal">[0-9A-Za-z_]</code>.</p><p>Finally, you can negate an entire range by prefixing it with a caret (<code class="literal">^</code>). For instance, if you wanted to match all non-alphanumeric characters, you would put <code class="literal">[^0-9A-Za-z]</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec36"></a>Alternation and grouping</h4></div></div></div><p>Vim has a few more <span>special</span><a id="id326580187" class="indexterm"></a> operators:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Symbol</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Meaning</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\|</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>alternation</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">\(\)</code></p></td><td style=""><p>grouping</p></td></tr></tbody></table></div><p> </p><p>The alternation operator is used to signify <span class="emphasis"><em>or</em></span>. For example, <code class="literal">carrot\|parrot</code> matches both <code class="literal">carrot</code> and <code class="literal">parrot</code>.</p><p>Grouping is used to put multiple characters in a group, which can serve two purposes. Firstly, you can combine operators with each other. For example, <code class="literal">\(c\|p\)arrot</code> is a nicer way to match both <code class="literal">carrot</code> and <code class="literal">parrot</code>.</p><p>Grouping can also be used to later refer to each section in parentheses. For example, if you wanted to turn the string <code class="literal">cat hunting mice</code> into <code class="literal">mice hunting cat</code>, you could use the following <code class="literal">:substitute</code> command:</p><pre class="programlisting"><span class="strong"><strong>:s/\(cat\) hunting \(mice\)/\2 hunting \1</strong></span></pre><p>This becomes relevant during refactoring; for example, when reordering arguments—but more on that later.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec37"></a>Quantifiers or multis</h4></div></div></div><p>Each character (be it a literal or a <span>special</span><a id="id326580610" class="indexterm"></a> character) or a range of characters is followed by a quantifier, or a <span class="emphasis"><em>multi</em></span> in Vim terms.</p><p>For example, <code class="literal">\w\+</code> will match one or more word characters, and <code class="literal">a\{2,4}</code> will match two to four <code class="literal">a</code>characters in succession (such as  <code class="literal">aaa</code>, for example).</p><p>Here is the list of most common quantifiers:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Symbol</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Meaning</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">*</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>0 or more, greedy</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\+</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>1 or more, greedy</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\{-}</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>0 or more, non-greedy</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\? or \=</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>0 or 1, greedy</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">\{n,m}</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>n to m, greedy</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">\{-n,m}</code></p></td><td style=""><p>n to m, non-greedy</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip121"></a>Note</h3><p>The full list of quantifiers is available through <code class="literal">:help multi</code>.</p></div><p> </p><p>You may have encountered two new terms in the table given: greedy and non-greedy. <span class="strong"><strong>Greedy</strong></span> search refers to trying to match as many characters as possible, while <span class="strong"><strong>non-greedy</strong></span> search tries to match as few characters as possible.</p><p>For example, given a string <code class="literal">foo2bar2</code>, greedy regex <code class="literal">\w\+2</code> will match <code class="literal">foo2bar2</code> (as many characters as it can until encountering a final <code class="literal">2</code>), while non-greedy <code class="literal">\w\{-1,}2</code> will only match <code class="literal">foo2</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec55"></a>More about magic</h3></div></div></div><p>Escaping <span>special</span><a id="id326603992" class="indexterm"></a> characters with backslashes <code class="literal">\</code> is no trouble if you're only occasionally spicing up your searches and substitutions with regular expressions. If you want to write longer expressions without having to escape every special character, you could switch to the magic mode for that expression.</p><p>Magic mode determines how Vim parses regex-enabled strings (like those in search or substitute commands).</p><p>Vim has three magic modes: magic, no magic, and very magic.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec38"></a>Magic</h4></div></div></div><p>The default mode. Most <span>special</span><a id="id326604012" class="indexterm"></a> characters need to be escaped, but some (such as <code class="literal">.</code> or <code class="literal">*</code>) don't have to be.</p><p>You can prefix your regex strings with <code class="literal">\m</code> (for example, <code class="literal">/\mfoo</code> or <code class="literal">:s/\mfoo/bar</code>) to explicitly set magic.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec39"></a>No magic</h4></div></div></div><p>This mode is similar to magic mode, but every <span>special</span><a id="id326604043" class="indexterm"></a> character needs to be escaped with a backslash, <code class="literal">\</code>.</p><p>For example, in default magic mode, you'd search for a line containing any text with <code class="literal">/^.*$</code> (here, <code class="literal">^</code> is for beginning of line, <code class="literal">.*</code> searches for every character repeatedly, and <code class="literal">$</code> is for end of line). However, in no magic mode, you'd have to escape each one of those: <code class="literal">/\^\.\*\$</code>.</p><p> </p><p>You can explicitly set no magic mode by prefixing your regex strings with <code class="literal">\M</code> (for example, <code class="literal">/\Mfoo</code> or <code class="literal">:s/\Mfoo/bar</code>). No magic can be also set in your <code class="literal">.vimrc</code> by adding <code class="literal">set nomagic</code>, but it's highly discouraged: by changing the way Vim treats regular expressions, you're more than likely to break several plugins you're using (as their creators will not have built them to work in no magic mode).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec40"></a>Very magic</h4></div></div></div><p>Very magic mode treats every character apart from letters, numbers, and underscores as a special character.</p><p>You can set very magic mode for a command by prefixing your regex strings with <code class="literal">\v</code> (for example, <code class="literal">/\vfoo</code> or <code class="literal">:s/\vfoo/bar</code>).</p><p>Very magic mode is often used when many <span>special</span><a id="id326606198" class="indexterm"></a> characters are to be used. For instance, we used the following example to replace <code class="literal">cat hunting mice</code> with <code class="literal">mice hunting cat</code>:</p><pre class="programlisting"><span class="strong"><strong>:s/\(cat\) hunting \(mice\)/\2 hunting \1</strong></span></pre><p>In very magic mode, this can be rewritten as follows:</p><pre class="programlisting"><span class="strong"><strong>:s/\v(cat) hunting (mice)/\2 hunting \1</strong></span></pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec56"></a>Applying the knowledge in practice</h3></div></div></div><p>Many tasks when refactoring code involve renaming or reordering things, and <span>regular</span><a id="id326292104" class="indexterm"></a> expressions are perfect tools for this.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec41"></a>Renaming a variable, a method, or a class</h4></div></div></div><p>Oftentimes, we rename things <span>when</span><a id="id326292119" class="indexterm"></a> refactoring, and these changes need to be <span>reflected</span><a id="id326292128" class="indexterm"></a> throughout the code base. However, simple search and replace <span>often</span><a id="id326292136" class="indexterm"></a> won't cut it, since you'll risk accidentally renaming unrelated things.</p><p>For example, let's try renaming our <code class="literal">Dog</code> class as <code class="literal">Pitbull</code>. Since we need to carry this out in multiple files, we'll use arglist:</p><pre class="programlisting"><span class="strong"><strong>:arg **/*.py</strong></span></pre><p> </p><p> </p><p>Now, move your cursor over the class name you'd like to rename (<code class="literal">Dog</code>), and enter the following(here, <code class="literal">\&lt;[Ctrl + r, Ctrl + w]\&gt;</code><span class="emphasis"><em> </em></span>signifies pressing <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>r</em></span> followed by <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>w</em></span> and not typing in square brackets):</p><pre class="programlisting"><span class="strong"><strong>:argdo %s/\&lt;[Ctrl + r, Ctrl + w]\&gt;/Pitbull/gec | update</strong></span></pre><p>Once you run it, you'll be prompted for every match:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/eac7e66a-c629-4459-aabc-ddf77e90e057.png" /></div><p>Press <code class="literal">y</code> to approve each change, or <code class="literal">n</code> to reject it.</p><p>Here's what's going on here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">:argdo</code> runs the operation on every arglist entry (which we loaded with <code class="literal">:arg</code>)</li><li style="list-style-type: disc"><code class="literal">%s/.../.../gec</code> substitutes every occurrence (<code class="literal">g</code>) throughout the whole file (<code class="literal">%</code>), without raising errors if no entries were found (<code class="literal">e</code>), and asking the user before making changes (<code class="literal">c</code>)
</li><li style="list-style-type: disc"><code class="literal">\&lt;...\&gt;</code> ensures we're looking for a whole word, and not just partial matches (otherwise we'll also rename another class called <code class="literal">Dogfish</code>, which we don't want to do)</li><li style="list-style-type: disc"><span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>r</em></span>, <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>w</em></span> is a shortcut to insert the word under the cursor in the current command (which would insert <code class="literal">Dog</code>)</li></ul></div><p>This approach has the <span>disadvantage</span><a id="id326540461" class="indexterm"></a> of locking you into <span>dialog</span><a id="id326540470" class="indexterm"></a> windows, without you being able to look around the file first. If you'd like more control, another alternative would be to use <code class="literal">:vimgrep</code> to find the matches first:</p><pre class="programlisting"><span class="strong"><strong>:vimgrep /\&lt;Dog\&gt;/ **<span class="emphasis"><em>/*</em></span>.py</strong></span></pre><p>You'll be able to look at matches, and step through them with <code class="literal">:cn</code> or <code class="literal">:cp</code> (or open the quickfix window with <code class="literal">:copen</code> and navigate from there):</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/345b4370-96ac-45c2-b5a8-3c9155438a39.png" /></div><p>In this particular example, you could replace the word using the usual change word command (<code class="literal">cw</code> followed by <code class="literal">Pitbull</code> followed by <span class="emphasis"><em>Esc</em></span>), and then replay the changes by pressing dot (<code class="literal">.</code>), or run a non-global <code class="literal">:substitute</code> command (<code class="literal">:s/\&lt;Dog\&gt;/Pitbull</code>).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec42"></a>Reordering function arguments</h4></div></div></div><p>Another common refactoring operation is to <span>change</span><a id="id326602632" class="indexterm"></a> the function arguments. Let's look at reordering arguments, since findings from this example can also be applied to other situations.</p><p>Here is a sample method in <code class="literal">animal.py</code>:</p><pre class="programlisting">def act(self, target, verb):
    return 'Suddenly {kind} {verb} at {target}!'.format(
            kind=self.kind,
            verb=verb,
            target=target)</pre><p>The order of arguments in this method doesn't seem very intuitive. We might be better off changing it to look like this:</p><pre class="programlisting">def act(self, verb, target):
    return 'Suddenly {kind} {verb} at {target}!'.format(
            kind=self.kind,
            verb=verb,
            target=target)</pre><p>However, there are quite a few callers for this method already, since we also use the method in <code class="literal">farm.py</code> (the code is intentionally repetitive for illustration purposes):</p><pre class="programlisting">def act(self, target):
    for animal in self.animals:
        if animal.get_kind() == 'cat':
            print(animal.act(target, 'meows'))
        elif animal.get_kind() == 'dog':
            print(animal.act(target, 'barks'))
        elif animal.get_kind() == 'sheep':
            print(animal.act(target, 'baas'))
        else:
            print(animal.act(target, 'looks'))</pre><p>This looks like a job for regular expressions! Let's write one up:</p><pre class="programlisting"><span class="strong"><strong>:arg **<span class="emphasis"><em>/*</em></span>.py</strong></span>
<span class="strong"><strong>:argdo %s/\v&lt;act&gt;\((\w{-1,}), ([^,]{-1,})\)/act(\2, \1)/gec | update</strong></span></pre><p>Give it a shot, and you will be greeted by a confirmation screen for every one of your matches (as we specified the <code class="literal">c</code> flag for the <code class="literal">:substitute</code> command):</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/101a77b8-59f8-40c9-b935-56e1c5523d26.png" /></div><p>To break it down, we have the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">\v</code> sets the magic mode for this string to <span>very</span><a id="id326603806" class="indexterm"></a> magic, to avoid having to escape every special character.</li><li style="list-style-type: disc"><code class="literal">&lt;act&gt;\(</code> matches the literal string <code class="literal">act(</code>, ensuring that <code class="literal">act</code> is a whole word (so partial matches such as <code class="literal">react(</code> would not be picked up).</li><li style="list-style-type: disc"><code class="literal">(\w{-1,}), ([^,]{-1,})\)</code> defines two groups separated by a comma and a space, and followed by a closing parenthesis. The first group is a word of at least one character, while the second is any character string of at least one character, excluding commas (this way we'll match <code class="literal">act(target, 'barks')</code>, but not <code class="literal">act(self, target, verb)</code>).</li><li style="list-style-type: disc">Finally, <code class="literal">act(\2, \1)</code> places the two matching groups in reverse order.</li></ul></div></div></div></div>