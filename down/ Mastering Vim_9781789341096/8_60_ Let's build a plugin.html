<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec60"></a>Let's build a plugin</h2></div></div><hr /></div><p>Let's try building a <span>simple</span><a id="id326634184" class="indexterm"></a> plugin; this way, we can learn by the example.</p><p>A common task you have to perform when working with code is commenting out chunks of code. Let's build a plugin that does just that. Let's (uninspiringly) name our plugin <code class="literal">vim-commenter</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec79"></a>Plugin layout</h3></div></div></div><p>Since the Vim 8 release, there's thankfully only one <span>way</span><a id="id326634308" class="indexterm"></a> of structuring your plugins (which is also compatible with major plugin managers, such as vim-plug, Vundle, or Pathogen). The plugins are expected to have the following directory structure:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">autoload/</code> lets you lazy load bits of your plugin (more on that later)</li><li style="list-style-type: disc"><code class="literal">colors/</code> color schemes</li><li style="list-style-type: disc"><code class="literal">compiler/</code> (language-specific) compiler-related functionality</li><li style="list-style-type: disc"><code class="literal">doc/</code> documentation</li><li style="list-style-type: disc"><code class="literal">ftdetect/</code> (filetype-specific) filetype detection settings
</li><li style="list-style-type: disc"><code class="literal">ftplugin/</code> (filetype-specific) filetype-related plugin code</li><li style="list-style-type: disc"><code class="literal">indent/</code> (filetype-specific) indentation-related settings</li><li style="list-style-type: disc"><code class="literal">plugin/</code> the core functionality of your plugin</li><li style="list-style-type: disc"><code class="literal">syntax/</code> (language-specific) defines language syntax group</li></ul></div><p>As we develop our plugin, let's use Vim 8's new plugin functionality and place our plugin directory into <code class="literal">.vim/pack/plugins/start</code>. Since we decided to name our plugin commenter, we'll plop it into <code class="literal">.vim/pack/plugins/start/vim-commenter</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note137"></a>Note</h3><p>Remember, the <code class="literal">plugins/</code> directory can have any name. See <a class="link" href="#" linkend="ch03">Chapter</a><a class="link" href="#" linkend="ch03">3,</a><span class="emphasis"><em>Follow the Leader - Plugin Management</em></span> for more info. The <code class="literal">start/</code> directory means that the plugin will be loaded on Vim startup.</p></div><p>Let's create a directory for it now:</p><pre class="programlisting"><span class="strong"><strong>$ mkdir -p ~/.vim/pack/plugins/start/vim-commenter</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec80"></a>The basics</h3></div></div></div><p>Let's start simple: let's get our <span>plugin</span><a id="id325898626" class="indexterm"></a> to add a key binding that comments out the current line by prefixing it with a Python-style comment (<code class="literal">#</code>).</p><p>Let's start in <code class="literal">~/.vim/pack/plugins/start/vim-commenter/plugin/commenter.vim</code>:</p><pre class="programlisting">" Comment out the current line in Python.
function! g:commenter#Comment()
  let l:line = getline('.')
  call setline('.', '# ' . l:line)
endfunction

nnoremap gc :call g:commenter#Comment()&lt;cr&gt;</pre><p>In the previous example, we've created a function that inserts <code class="literal">#</code> in front of the current line (<code class="literal">.</code>) and maps it to <code class="literal">gc</code>. As you might remember, <code class="literal">g</code>, while having some mappings assigned to it (see <code class="literal">:help g</code>), is effectively a free namespace for the user to fill, and <code class="literal">c</code> stands for "comment".</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note138"></a>Note</h3><p>Another popular prefix for custom mappings is the comma (<code class="literal">,</code>), which is a rarely used command.</p></div><p> </p><p>Save the file and load it (either using <code class="literal">:source</code>, or by restarting Vim). Let's open a Python file and navigate to some line we'd like to comment:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/6a04cb76-39fc-456e-ac05-50568df15023.png" /></div><p>Now, try running <code class="literal">gc</code>:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/5eadfd26-0f52-4b5f-a8be-786e6d179549.png" /></div><p>Success! Well, kind of. First, the comment begins at the beginning of the line and not at the current indentation level, as the user might want. Also, the cursor hasn't moved from the current position, which might be a little annoying for the user. Let's fix these two issues.</p><p>You can get the indentation level of the line (in spaces) using the <code class="literal">indent</code> function:</p><pre class="programlisting">" Comment out the current line in Python.
function! g:commenter#Comment()
  let l:i = indent('.') " Number of spaces.
  let l:line = getline('.')
  call setline('.', l:line[:l:i - 1] . '# ' . l:line[l:i:])
endfunction


nnoremap gc :call g:Comment()&lt;cr&gt;
let s:comment_string = '# '

" Comment out the current line in Python.
function! g:Comment()
  let l:i = indent('.') " Number of spaces.
  let l:line = getline('.')
  let l:cur_row = getcurpos()[1]
  let l:cur_col = getcurpos()[2]
  call setline('.', l:line[:l:i - 1] . s:comment_string . l:line[l:i:])
  call cursor(l:cur_row, l:cur_col + len(s:comment_string))
endfunction

nnoremap gc :call g:Comment()&lt;cr&gt;</pre><p>Let's go back to our file:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/fb040347-30f2-4f72-be84-136bfb7ffdc6.png" /></div><p>Now, run <code class="literal">gc</code> to comment out an indented line:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/b91cafa2-0424-48ad-b0a0-2a83fa220fea.png" /></div><p>Wonderful! But now, we'll probably need a way to uncomment the line as well! Let's change our function to <code class="literal">g:ToggleComment()</code>:</p><pre class="programlisting">let s:comment_string = '# '

" Comment out the current line in Python.
function! g:ToggleComment()
  let l:i = indent('.')  " Number of spaces.
  let l:line = getline('.')
  let l:cur_row = getcurpos()[1]
  let l:cur_col = getcurpos()[2]
  if l:line[l:i:l:i + len(s:comment_string) - 1] == s:comment_string
    call setline('.', l:line[:l:i - 1] . 
    \ l:line[l:i + len(s:comment_string):])
    let l:cur_offset = -len(s:comment_string)
  else
    call setline('.', l:line[:l:i - 1] . s:comment_string . l:line[l:i:])
    \ let l:cur_offset = len(s:comment_string)
  endif
  call cursor(l:cur_row, l:cur_col + l:cur_offset)
endfunction

nnoremap gc :call g:ToggleComment()&lt;cr&gt;</pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>Let's give it a shot! Reload the script, and go <span>back</span><a id="id325900492" class="indexterm"></a> to our file:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/e1388342-1a30-4c39-89f4-b4de9aafd6de.png" /></div><p>Hit <code class="literal">gc</code> to comment the line:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/61fdc2ce-d225-4ae9-ae45-b571785c96cb.png" /></div><p>And hit <code class="literal">gc</code> again to uncomment it:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/8871afca-7cd8-4f1b-a6af-8f5c152f0cf9.png" /></div><p>Let's make sure we covered corner cases! Let's try to comment out the line without indentation. Move your cursor to an un-indented line:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/f8857d47-07f3-4f3a-803c-ce85b1636fa2.png" /></div><p> </p><p>Hit <code class="literal">gc</code> to run our function:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/44aebebf-d0e2-4746-97bc-b249b32b39ca.png" /></div><p>Oh no! Looks like our script is not working well for when there's no indentation. Let's fix it:</p><pre class="programlisting">let s:comment_string = '# '

" Comment out the current line in Python.
function! g:ToggleComment()
  let l:i = indent('.') " Number of spaces.
  let l:line = getline('.')
  let l:cur_row = getcurpos()[1]
  let l:cur_col = getcurpos()[2]
  let l:prefix = l:i &gt; 0 ? l:line[:l:i - 1] : '' " Handle 0 indent cases.
  if l:line[l:i:l:i + len(s:comment_string) - 1] == s:comment_string
    call setline('.', l:prefix . l:line[l:i + len(s:comment_string):])
    let l:cur_offset = -len(s:comment_string)
  else
    call setline('.', l:prefix . s:comment_string . l:line[l:i:])
    let l:cur_offset = len(s:comment_string)
  endif
  call cursor(l:cur_row, l:cur_col + l:cur_offset)
endfunction

nnoremap gc :call g:ToggleComment()&lt;cr&gt;</pre><p>Let's save, reload, and run the script using <code class="literal">gc</code>:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/b0116517-d721-4338-9688-91699dc05998.png" /></div><p> </p><p>And run <code class="literal">gc</code> again to test uncommenting:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/66e5efb9-11f9-4185-b46b-3b1ac31d9934.png" /></div><p>Wonderful! The very basic version of our <span>plugin</span><a id="id325974281" class="indexterm"></a> is complete!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec81"></a>Housekeeping</h3></div></div></div><p>So far, we've had our <span>plugin</span><a id="id325974296" class="indexterm"></a> all within one file. Let's see how we can break it down into multiple files to keep our newly created project organized! Give a look at the list in <span class="emphasis"><em>Plugin layout</em></span> section of this chapter.</p><p>First, you can see that the <code class="literal">ftplugin/</code> directory contains filetype-specific plugin configuration. Right now, most of our plugin is actually pretty independent from working with Python, except for the <code class="literal">s:comment_string</code> variable. Let's move it out to <code class="literal">&lt;...&gt;/vim-commenter/ftplugin/python.vim</code>:</p><pre class="programlisting">" String representing inline Python comments.
let g:commenter#comment_str = '# '</pre><p>We've changed the scope from <code class="literal">s:</code> to <code class="literal">g:</code> (since the variable is now used in different scripts), and added the <code class="literal">commenter#</code> namespace to avoid namespace collision.</p><p>The name should also be updated in <code class="literal">&lt;...&gt;/vim-commenter/plugin/commenter.vim</code>. Now might be a good time to test those substitution commands you learned earlier in this book:</p><pre class="programlisting"><span class="strong"><strong>:%s/\&lt;s:comment_string\&gt;/g:commenter#comment_str/g</strong></span></pre><p>Another directory of interest is <code class="literal">autoload/</code>. Currently, whenever Vim starts, it will parse and load <code class="literal">g:commenter#ToggleComment</code>. That's not very fast. Instead, we can choose to move the function to the <code class="literal">autoload/</code> directory. The name of the file needs to correspond to its namespace; in this case, it's <code class="literal">commenter</code>. Let's create <code class="literal">&lt;...&gt;/vim-commenter/autoload/commenter.vim</code>:</p><pre class="programlisting">" Comment out the current line in Python.
function! g:commenter#ToggleComment()
  let l:i = indent('.') " Number of spaces.
  let l:line = getline('.')
  let l:cur_row = getcurpos()[1]
  let l:cur_col = getcurpos()[2]
  let l:prefix = l:i &gt; 0 ? l:line[:l:i - 1] : '' " Handle 0 indent cases.
 if l:line[l:i:l:i + len(g:commenter#comment_str) - 1] ==
    \ g:commenter#comment_str
  call setline('.', l:prefix .
        \ l:line[l:i + len(g:commenter#comment_str):])
    let l:cur_offset = -len(g:commenter#comment_str)
  else
    call setline('.', l:prefix . g:commenter#comment_str . l:line[l:i:])
    let l:cur_offset = len(g:commenter#comment_str)
  endif
  call cursor(l:cur_row, l:cur_col + l:cur_offset)
endfunction</pre><p>At this point, the only thing left in <code class="literal">&lt;...&gt;/vim-commenter/plugin/commenter.vim</code> is the mapping:</p><pre class="programlisting">nnoremap gc :call g:commenter#ToggleComment()&lt;cr&gt;</pre><p>Here's how our plugin will get loaded when a user is working with Vim:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">User opens Vim, and <code class="literal">&lt;...&gt;/vim-commenter/plugin/commenter.vim</code> is loaded. Our <code class="literal">gc</code> mapping is now registered.</li><li style="list-style-type: disc">User opens a Python file, and <code class="literal">&lt;...&gt;/vim-commenter/ftplugin/python.vim</code> is loaded. <code class="literal">g:commenter#comment_str</code> is initialized.</li><li style="list-style-type: disc">User runs <code class="literal">gc</code>, which loads and executes <code class="literal">g:commenter#ToggleComment</code> within <code class="literal">&lt;...&gt;/vim-commenter/autoload/commenter.vim</code>.</li></ul></div><p>One directory we haven't given much love to yet is <code class="literal">doc/</code>. Vim is known for having extensive documentation, and we have a recommendation to uphold this. Let's add <code class="literal">&lt;...&gt;/vim-commenter/doc/commenter.txt</code>:</p><pre class="programlisting">*commenter.txt* Our first commenting plugin.
*commenter*

=========================================================================
CONTENTS                                             *commenter-contents*

  1. Intro..............................................|commenter-intro|
  2. Usage..............................................|commenter-usage|

=========================================================================
1. Intro                                                *commenter-intro*

Have you ever wanted to comment out a line with only three presses of a
button? Now you can! A new and wonderful vim-commenter lets you comment
out a single line in Python quickly!

2. Usage                                                *commenter-usage*

This wonderful plugin supports the following key bindings:

  gc: toggle comment on a current line

That's it for now. Thanks for reading!

  vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:</pre><p>Vim help has its own format, but here are some highlights:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">*help-tag*</code> is used to denote a help tag. Whenever you run :help help-tag, Vim takes you to a file containing <code class="literal">*help-tag*</code>, and places the cursor right at the tag.</li><li style="list-style-type: disc"><code class="literal">Text...|help-tag|</code> is used for navigation within a help file. It lets the reader jump to the desired tags from this section.</li><li style="list-style-type: disc">All the <code class="literal">===</code> lines are just for pretty looks. They don't actually mean anything.</li><li style="list-style-type: disc">A line like <code class="literal">vim:tw=78:ts=2:sts=2:sw=2:ft=help:norl:</code> lets you tell Vim how to display a file when editing it (all of these are options you can set using the <code class="literal">set</code> keyword). This becomes really useful for files without clearly identifiable filetypes (such as <code class="literal">.txt</code> files).</li></ul></div><p>You can learn more about Vim's help format by reading <code class="literal">:help help-writing</code>. The easiest thing though is to find some popular <span>plugins</span><a id="id326286891" class="indexterm"></a> and copy what they do.</p><p>After you finished writing the doc, you'll need to tell Vim to generate its help tags in order for the entries to be indexed by the <code class="literal">:help</code> command. Run the following:</p><pre class="programlisting"><span class="strong"><strong>:helptags ~/.vim/pack/plugins/start/vim-commenter/doc</strong></span></pre><p>Now, you'll be able to visit entries you added to the help file:</p><pre class="programlisting"><span class="strong"><strong>:help commenter-intro</strong></span></pre><p>Here's a screenshot of Vim help taking you to the requested section:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/252fcb98-186a-425a-acd2-23997fc289ec.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec82"></a>Improving our plugin</h3></div></div></div><p>There are many paths we can take <span>our</span><a id="id326286939" class="indexterm"></a> plugin in, but let's focus on two main issues we have right now:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Our plugin fails with spectacular errors when we try to execute it in any other language</li><li style="list-style-type: disc">The plugin does not provide a way to operate on multiple lines at once</li></ul></div><p> </p><p> </p><p>Let's start with the first problem: making the plugin work across different languages. Right now, if you try to execute the plugin in, for example, a <code class="literal">.vim</code> file, you'll get the following volley of errors:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/29955641-d6c0-4f92-bc2e-8a721227928a.png" /></div><p>That's because we define <code class="literal">g:commenter#comment_str</code> in <code class="literal">&lt;...&gt;/vim-commenter/ftplugin/python.vim</code>, and the variable is only defined when we're working with a Python file.</p><p>Vim syntax files define what the comments look like for each language, but they're not very consistent, and the logic to parse those and all the corner cases is outside of the scope of this book.</p><p>However, we can at least get rid of the nasty error, and make our own!</p><p>The canonical way of checking a variable exists is with <code class="literal">exists</code>. Let's add a new function to <code class="literal">&lt;...&gt;/vim-commenter/autoload/commenter.vim</code>, which would throw a custom error if <code class="literal">g:commenter#comment_str</code> is not set:</p><pre class="programlisting">" Returns 1 if g:commenter#comment_str exists.
function! g:commenter#HasCommentStr()
  if exists('g:commenter#comment_str')
    return 1
  endif
  echom "vim-commenter doesn't work for filetype " . &amp;ft . " yet"
  return 0
endfunction

" Comment out the current line in Python.
function! g:commenter#ToggleComment()
  if !g:commenter#HasCommentStr()
    return
  endif
  let l:i = indent('.') " Number of spaces.
  let l:line = getline('.')
  let l:cur_row = getcurpos()[1]
  let l:cur_col = getcurpos()[2]
  let l:prefix = l:i &gt; 0 ? l:line[:l:i - 1] : '' " Handle 0 indent cases.
  if l:line[l:i:l:i + len(g:commenter#comment_str) - 1] ==#
      \ g:commenter#comment_str
    call setline('.', l:prefix .
      \ l:line[l:i + len(g:commenter#comment_str):])
    let l:cur_offset = -len(g:commenter#comment_str)
  else
    call setline('.', l:prefix . g:commenter#comment_str . l:line[l:i:])
    let l:cur_offset = len(g:commenter#comment_str)
  endif
  call cursor(l:cur_row, l:cur_col + l:cur_offset)
endfunction</pre><p>Now, we get a message when we try to comment out a line in a non-Python file:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/806626e3-ed61-4f8c-afa2-9db2a8e407d4.png" /></div><p>A much better user experience if you ask me.</p><p>And now, let's add a way for our plugin to be invoked on multiple lines. The easiest thing to do would be to allow the user to prefix our <code class="literal">gc</code> command with a number, and we'll do just that.</p><p>Vim lets you access a number that prefixes a mapping by using <code class="literal">v:count</code>. Even better, there's a <code class="literal">v:count1</code>, which defaults to 1 if no count was given (this way, we can reuse more of <span>our</span><a id="id326288334" class="indexterm"></a> code).</p><p>Let's update our mapping in <code class="literal">&lt;...&gt;/vim-commenter/plugin/commenter.vim</code>:</p><pre class="programlisting">nnoremap gc :&lt;c-u&gt;call g:commenter#ToggleComment(v:count1)&lt;cr&gt;</pre><p><code class="literal">&lt;c-u&gt;</code> is required to be used with <code class="literal">v:count</code> and <code class="literal">v:count1</code>. You can check <code class="literal">:help v:count</code> or <code class="literal">:help v:count1</code> for an explanation.</p><p> </p><p>In fact, we can also add a visual mode mapping to support visual selection:</p><pre class="programlisting">vnoremap gc :&lt;cu&gt;call g:commenter#ToggleComment(
  \ line("'&gt;") - line("'&lt;") + 1)&lt;cr&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note139"></a>Note</h3><p><code class="literal">line("'&gt;")</code> gets the line number of the end of the selection, while <code class="literal">line("'&lt;")</code> gets the line number of the beginning of the selection. Subtract the beginning line number from the end, add one, and we have ourselves a line count!</p></div><p>Now, let's update <code class="literal">&lt;...&gt;/vim-commenter/autoload/commenter.vim</code> with a few new methods:</p><pre class="programlisting">" Returns 1 if g:commenter#comment_str exists.
function! g:commenter#HasCommentStr()
  if exists('g:commenter#comment_str')
    return 1
  endif
  echom "vim-commenter doesn't work for filetype " . &amp;ft . " yet"
  return 0
endfunction

" Detect smallest indentation for a range of lines.
function! g:commenter#DetectMinIndent(start, end)
  let l:min_indent = -1
  let l:i = a:start
  while l:i &lt;= a:end
    if l:min_indent == -1 || indent(l:i) &lt; l:min_indent
      let l:min_indent = indent(l:i)
    endif
    let l:i += 1
  endwhile
  return l:min_indent
endfunction

function! g:commenter#InsertOrRemoveComment(lnum, line, indent, is_insert)
  " Handle 0 indent cases.
  let l:prefix = a:indent &gt; 0 ? a:line[:a:indent - 1] : ''
  if a:is_insert
    call setline(a:lnum, l:prefix . g:commenter#comment_str .
      \ a:line[a:indent:])
  else
    call setline(
       \ a:lnum, l:prefix . a:line[a:indent + len(g:commenter#comment_str):]
  endif
endfunction

" Comment out the current line in Python.
function! g:commenter#ToggleComment(count)
  if !g:commenter#HasCommentStr()
    return
  endif
  let l:start = line('.')
  let l:end = l:start + a:count - 1
  if l:end &gt; line('$') " Stop at the end of file.
    let l:end = line('$')
  endif
  let l:indent = g:commenter#DetectMinIndent(l:start, l:end)
  let l:lines = l:start == l:end ? 
  \ [getline(l:start)] : getline(l:start, l:end)  
  let l:cur_row = getcurpos()[1]
  let l:cur_col = getcurpos()[2]
  let l:lnum = l:start
  if l:lines[0][l:indent:l:indent + len(g:commenter#comment_str) - 1] ==#
      \ g:commenter#comment_str
    let l:is_insert = 0
    let l:cur_offset = -len(g:commenter#comment_str)
  else
    let l:is_insert = 1
    let l:cur_offset = len(g:commenter#comment_str)
  endif
  for l:line in l:lines
    call g:commenter#InsertOrRemoveComment(
        \ l:lnum, l:line, l:indent, l:is_insert)
    let l:lnum += 1
  endfor
  call cursor(l:cur_row, l:cur_col + l:cur_offset)
endfunction</pre><p>This script is now much bigger, but it's not as scary as it looks! Here, we've added two new functions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">g:commenter#DetectMinIndent</code> finds the smallest indent within a given range. This way, we make sure to indent the outermost section of code.</li><li style="list-style-type: disc"><code class="literal">g:commenter#InsertOrRemoveComment</code> either inserts or removes a comment within a given line and at a given indentation level.
</li></ul></div><p>Let's test run our plugin. Let's, say, run it with <code class="literal">11gc</code>:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/6d14fb97-96bc-4477-bb70-c26d182e76fa.png" /></div><p>Ta-da! Now, our little plugin can <span>comment</span><a id="id326295260" class="indexterm"></a> out multiple lines! Give it a go with a few more tries to make sure we covered corner cases such as commenting in the visual mode going past the end of the file, commenting and uncommenting a single line, and so on.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec83"></a>Distributing the plugin</h3></div></div></div><p>Effectively, we're all set up to <span>distribute</span><a id="id326295275" class="indexterm"></a> the plugin. Just a few things left.</p><p>Update the documentation, and add a <code class="literal">README.md</code> file to let people know what your plugin does (this can be copied from the intro of your plugin). You'll also want to add a <code class="literal">LICENSE</code> file, indicating the license under which you're distributing the plugin. You can distribute the plugin under the same license as Vim (:help license), or choose your own (GitHub has a helpful <a class="ulink" href="https://choosealicense.org" target="_blank">https://choosealicense.org</a> for this purpose).</p><p>Now, you'll just have to turn <code class="literal">$HOME/.vim/pack/plugins/vim-commenter</code> into a Git repository, and upload it somewhere.</p><p>At the time of writing this book, GitHub is the go-to bastion of freedom for storing code (however, as SourceForge proved around 2015, times change).</p><p>Let's give it a shot:</p><pre class="programlisting"><span class="strong"><strong> $ cd $HOME/.vim/pack/plugins/start/vim-commenter</strong></span>
<span class="strong"><strong> $ git init</strong></span>
<span class="strong"><strong> $ git add .</strong></span>
<span class="strong"><strong> $ git commit -m "First version of the plugin is ready!"</strong></span>
<span class="strong"><strong> $ git remote add origin &lt;repository URL&gt;</strong></span>
<span class="strong"><strong> $ git push origin master</strong></span></pre><p>Done! You're now ready to distribute the plugin, and plugin managers such as vim-plug can now pick up your plugin!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec84"></a>Where to take the plugin from here</h3></div></div></div><p>There's a lot more room for improvement, but we'll take a break here. You're welcome to continue working on this plugin on your own—you can add visual <span>selection</span><a id="id326295516" class="indexterm"></a> support, make it work with additional languages, or do whatever it is you would like with it.</p></div></div>