<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec43"></a>Building and testing</h2></div></div><hr /></div><p>As you work on your code, you will <span>have</span><a id="id326441493" class="indexterm"></a> to compile (in compiled languages, which does not <span>apply</span><a id="id326441483" class="indexterm"></a> to Python) it and run accompanying tests.</p><p>Vim supports populating build and test failures through quickfix and location lists, which we will cover in this section.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec47"></a>Quickfix list</h3></div></div></div><p>You've already had a brush with a <span>quickfix</span><a id="id326441433" class="indexterm"></a> window in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Advanced Editing and Navigation</em></span>, but let's dig a bit deeper into it.</p><p>Vim has an additional mode that makes jumping to certain parts of files easier. Some Vim commands use it to navigate between positions in files, such as jumping to compile errors for <code class="literal">:make</code> or search terms for <code class="literal">:grep</code> or <code class="literal">:vimgrep</code>. Plugins such as linters (syntax checking) or test runners use the quickfix list as well.</p><p> </p><p>Let's try using a quickfix list by running a <code class="literal">:grep</code> command to search for the <code class="literal">animal</code> keyword recursively (<code class="literal">-r</code>) in every Python file (<code class="literal">--include="*.py"</code>), starting in the current directory (<code class="literal">.</code>):</p><pre class="programlisting"><span class="strong"><strong>:grep -r --include="*.py" animal .</strong></span></pre><p>This will open the first match in a current window. To open a quickfix window and see all of the matches, execute the following:</p><pre class="programlisting"><span class="strong"><strong>:copen</strong></span></pre><p>You can see the results a horizontal split now:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/6ab82929-5fd3-4386-a244-54b0e5469240.png" /></div><p>You can navigate the quickfix window as usual with <code class="literal">k</code> and <code class="literal">j</code> keys to move up and down, <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>f </em></span>and <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>b</em></span> to scroll by pages, and <code class="literal">/</code> and <code class="literal">?</code> to search forward and backward. <span class="emphasis"><em>Enter</em></span> will open a file with a match in the buffer you were searching from. It will also place your cursor in the desired position.</p><p>For example, if you wanted to open a match in a file, <code class="literal">animals/sheep.py</code>, you can navigate to the desired line by running <code class="literal">/sheep</code>, followed by <code class="literal">n</code> (next) until the cursor is at the right line, and pressing <span class="emphasis"><em>Enter</em></span>. The file will be opened in the original window with the cursor located where the match is:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/2447fab0-650c-4996-81c2-2a158729fdd5.png" /></div><p>You can close the quickfix list with <code class="literal">:cclose</code> (or <code class="literal">:bd</code> to delete the quickfix buffer if it's in an active window).</p><p>You can also navigate the quickfix list without opening the quickfix window:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">:cnext</code> (or <code class="literal">:cn</code>) navigates to the next entry in the quickfix list</li><li style="list-style-type: disc"><code class="literal">:cprevious</code> (or <code class="literal">:cp</code>, <code class="literal">:cN</code>) navigates to the previous entry in the list</li></ul></div><p>Lastly, you can choose to only open the <span>quickfix</span><a id="id325844894" class="indexterm"></a> window if errors (such as compile errors) are found: <code class="literal">:cwindow</code> (or <code class="literal">:cw</code>) will toggle the quickfix window only if errors are present.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec48"></a>Location list</h3></div></div></div><p>In addition to a <span>quickfix</span><a id="id325844916" class="indexterm"></a> list, Vim also has a location list. It behaves just like a quickfix list, except that it stays local to the current window. While you can have only one quickfix list in a single Vim session, you can have as many location lists as you want.</p><p>To populate a location list, you can prefix most quickfix-operating commands with the letter <code class="literal"><span class="emphasis"><em>l</em></span></code> (such as <code class="literal">:lgrep</code> or <code class="literal">:lmake</code>).</p><p>Shortcuts also replace the <code class="literal">:c</code> prefix with the <code class="literal">:l</code> prefix:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">:lopen</code> opens the location window</li><li style="list-style-type: disc"><code class="literal">:lclose</code> closes the window</li><li style="list-style-type: disc"><code class="literal">:lnext</code> navigates to the next item in a location list</li><li style="list-style-type: disc"><code class="literal">:lprevious</code> navigates to the previous item in a location list</li><li style="list-style-type: disc"><code class="literal">:lwindow</code> toggles the quickfix window only if the errors were present</li></ul></div><p>In general, you will use a quickfix list when the results need to be accessed in multiple windows, while a location list is great for capturing output relevant to a single window.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec49"></a>Building code</h3></div></div></div><p>Building doesn't necessarily apply to Python (since there isn't much compiling going on), but it's definitely worth going over to understand how Vim deals with <span>executing</span><a id="id325845009" class="indexterm"></a> code.</p><p>Vim provides a <code class="literal">:make</code> command, which wraps around the Unix make utility. In case you're not familiar, Make is a build management solution as old as time (and if it ain't broke...) that allows you to recompile parts of a bigger program (or all of it) as needed.</p><p>Some relevant options you'd want to be aware of are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">:compiler</code> lets you specify a different compiler plugin, which also modifies the expected format output for the compiler</li><li style="list-style-type: disc">In particular, <code class="literal">:set errorformat</code> defines a set of recognized error formats</li><li style="list-style-type: disc"><code class="literal">:set makeprg</code> sets what program to execute when running <code class="literal">:make</code></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip109"></a>Note</h3><p>Want to learn more about one of these options? Don't forget that you can run <code class="literal">:help &lt;anything&gt;</code> to look up an entry in the Vim manual.</p></div><p>The two can be used in conjunction to work with any compiler. For example, if you wanted to compile a C file you're working on, you could invoke <code class="literal">gcc</code> (standard issue C compiler) by running the following:</p><pre class="programlisting"><span class="strong"><strong>:compiler gcc</strong></span>
<span class="strong"><strong>:make</strong></span></pre><p>What makes <code class="literal">:make</code> important is that it allows Vim users to implement syntax checkers, test runners, or just about anything else that spits out references to lines as a compiler plugin, giving us access to quickfix or location windows!</p><p>Terminal mode, introduced in Vim 8.1, is also a solid candidate for long-running builds, as <code class="literal">:term make</code> will call make asynchronously while you continue working on your code. See the <span class="emphasis"><em>Terminal mode</em></span> section for more about terminal mode.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec30"></a>Plugin spotlight: vim-dispatch</h4></div></div></div><p>Tim Pope supercharges the <code class="literal">:make</code> command, makes it asynchronous, and adds a whole <span>bunch</span><a id="id325868171" class="indexterm"></a> of syntactic sugar and additional commands to support its use. A big chunk of vim-dispatch became obsolete with Vim 8.1 rolling out <span>terminal</span><a id="id325868180" class="indexterm"></a> mode support, however, depending on your preferred workflow, integration with different terminal emulators can be very useful. You can get vim-dispatch from GitHub at <a class="ulink" href="https://github.com/tpope/vim-dispatch" target="_blank">https://github.com/tpope/vim-dispatch</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip110"></a>Note</h3><p>If you’re using vim-plug, you can install vim-dispatch by adding <code class="literal">Plug 'tpope/vim-dispatch'</code> to a list of your plugins and running <code class="literal">:w | source $MYVIMRC | PlugInstall</code>.</p></div><p>Here are some highlights:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">:Make</code> allows you to run a task in a different window (only if you're using <code class="literal">tmux</code>, <code class="literal">iTerm</code>, or <code class="literal">cmd.exe</code>)</li><li style="list-style-type: disc"><code class="literal">:Make!</code> kicks off a task in the background (only in <code class="literal">tmux</code>, Screen, <code class="literal">iTerm</code>, or <code class="literal">cmd.exe</code>)</li><li style="list-style-type: disc"><code class="literal">:Dispatch</code> allows you to combine <code class="literal">:compiler &lt;compiler-name&gt;</code> and <code class="literal">:make</code> into a single command, for example, <code class="literal">:Dispatch testrb test/models/user_test.rb</code></li><li style="list-style-type: disc"><code class="literal">:Dispatch</code> can also just run arbitrary commands, for example, <code class="literal">:Dispatch</code> bundle install</li></ul></div><p> </p><p>If you find yourself using built-in <code class="literal">:make</code> a lot, you may want to give vim-dispatch a shot.</p><p>Technically, you can also run tests from vim-dispatch, but since tests normally don't provide standardized output, vim-dispatch cannot automatically populate the quickfix or the location lists.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec50"></a>Testing code</h3></div></div></div><p>Test output happens to be a lot less <span>uniform</span><a id="id326124199" class="indexterm"></a> than compile errors, so your bet here is using test-runner-specific plugins you can find online. There are as many plugins as there are test runners, if not more.</p><p>In addition, terminal mode, added in Vim 8.1, provides a good way to run tests while continuing to work on your code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec31"></a>Plugin spotlight – vim-test</h4></div></div></div><p>This is the most popular test runner, as it provides a set of <span>compilers</span><a id="id326124217" class="indexterm"></a> (as well as handy mappings) for plugging into a lot of test runners. For Python, vim-test supports djangotest, django-nose, nose, nose2, pytest, and PyUnit. It's available from <a class="ulink" href="https://github.com/janko-m/vim-test" target="_blank">https://github.com/janko-m/vim-test</a>. You'll have to make sure you <span>have</span><a id="id326124230" class="indexterm"></a> the desired test runner already installed before using vim-test.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip111"></a>Note</h3><p>If you're using vim-plug, you can install vim-test by adding <code class="literal">Plug 'janko-m/vim-test'</code> to your <code class="literal">.vimrc</code> file and running <code class="literal">:w | source $MYVIMRC | PlugInstall</code>.</p></div><p>vim-test supports the following commands:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">:TestNearest</code> runs the test nearest to the cursor</li><li style="list-style-type: disc"><code class="literal">:TestFile</code> runs the tests in the current file</li><li style="list-style-type: disc"><code class="literal">:TestSuite</code> runs the entire test suite</li><li style="list-style-type: disc"><code class="literal">:TestLast</code> runs the last test</li></ul></div><p>vim-test also allows you to specify test strategy, as in, what method to use for running tests. Strategies such as make, neomake, MakeGreen, and dispatch (or <code class="literal">dispatch_background</code>) populate a quickfix window, which is exactly what you'd be looking for in a plugin like this.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>For example, if you wanted to run your tests through vim-dispatch (to run a test in a different Terminal window, for instance), you would add the following to your <code class="literal">.vimrc</code> file:</p><pre class="programlisting">let test#strategy = "dispatch"</pre><p>You can visit<a class="ulink" href="https://github.com/janko-m/vim-test" target="_blank">https://github.com/janko-m/vim-test</a>for more information about vim-test.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec51"></a>Syntax checking code with linters</h3></div></div></div><p>Syntax checking (also known as linting) has essentially <span>become</span><a id="id326438729" class="indexterm"></a> a staple in any multi-person software project. There are many linter programs available online, which support different languages and styles.</p><p>Python code has it easier than many languages out there, as it tends to adhere to a single standard—PEP8 (<a class="ulink" href="https://www.python.org/dev/peps/pep-0008/" target="_blank">https://www.python.org/dev/peps/pep-0008</a>). The most common linters that make sure the code adheres to <span>PEP8</span><a id="id326438744" class="indexterm"></a> are Pylint, Flake8, and autopep8.</p><p>Before proceeding, make sure one of these (the following examples work with Pylint) is installed on your machine, as Vim merely calls external linters.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip112"></a>Note</h3><p>If you're on a Debian-flavored distribution, you can run <code class="literal">sudo apt-get install pylint3</code> to install Pylint for Python3.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec32"></a>Using linters with Vim</h4></div></div></div><p>A lot of common linters have associated plugins, which you <span>can</span><a id="id326438770" class="indexterm"></a> use to avoid dealing with the intricacies of each linter. However, if you have to support a custom linter, Vim lets you populate a quickfix list however you want.</p><p>You can leverage Vim's <code class="literal">:make</code> command, which populates a quickfix list. By default, it runs the Unix <code class="literal">make</code> command (no surprise here), but you can override that by setting the <code class="literal">makeprg</code> variable.</p><p>Quickfix expects <code class="literal">:make</code> output to be in a particular format, and you can try to get a linter to output in a desired format. This is error-prone, and has possible compatibility issues (if the underlying linter changes).</p><p>Add the following to your <code class="literal">.vimrc</code> file to override the <code class="literal">:make</code> behavior only when working on Python files:</p><pre class="programlisting">autocmd filetype python setlocal makeprg=pylint3\ --reports=n\ --msg-      

template=\"{path}:{line}:\ {msg_id}\ {symbol},\ {obj}\ {msg}\"\ %:p
autocmd filetype python setlocal errorformat=%f:%l:\ %m</pre><p>Now, if you run <code class="literal">:make | copen</code> while in a Python file, you'll see a populated quickfix list:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/100a5e11-e02f-48e6-ab8e-36be0f3d323d.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip113"></a>Note</h3><p>If you're not accustomed to using linters, you might be wondering how to silence warnings you don't care for. For Pylint, it's done by adding a statement such as <code class="literal">disable-invalid-name,missing-docstring</code> to <code class="literal">~/.pylintrc</code> or by commenting <code class="literal"># pylint: disable=invalid-name</code> on the offending line. Each linter has its own syntax for silencing warnings.</p></div><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec33"></a>Plugin spotlight – Syntastic</h4></div></div></div><p>Syntastic is the go-to plugin when it comes to syntax checking. It supports over 100 languages (and <span>can</span><a id="id326441143" class="indexterm"></a> be extended with smaller syntax checker plugins). Syntastic is <span>available</span><a id="id326441152" class="indexterm"></a> from <a class="ulink" href="https://github.com/vim-syntastic/syntastic" target="_blank">https://github.com/vim-syntastic/syntastic</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip114"></a>Note</h3><p>If you're using vim-plug, you can install Syntastic by adding <code class="literal">Plug 'vim-syntastic/syntastic'</code> to your <code class="literal">.vimrc</code> file and running <code class="literal">:w | source $MYVIMRC | PlugInstall</code>.</p></div><p>Syntastic does not provide newbie-friendly defaults, so you may want to have the following in your <code class="literal">.vimrc</code> file:</p><pre class="programlisting">set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

let g:syntastic_python_pylint_exe = 'pylint3'</pre><p> </p><p> </p><p> </p><p> </p><p>Now, as long as you have a Python syntax checker (such as Pylint) installed on your system, you will see the following when you open a Python file:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/a4dbb5be-479d-4a39-9904-b545db0dc688.png" /></div><p>There are a few things going on here, from top to bottom:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Lines with syntactic errors are highlighted with <code class="literal">&gt;&gt;</code></li><li style="list-style-type: disc">Offending characters or strings are highlighted as well</li><li style="list-style-type: disc">A location list is open, listing everything wrong with the current file</li><li style="list-style-type: disc">A status line is displaying the error on a currently open line</li></ul></div><p>Since this is a regular location list, you can use the usual location list shortcuts to navigate (for example, <code class="literal">:lnext</code> or <code class="literal">:lprevious</code>).</p><p> </p><p>If you were to fix the error, the syntax error list updates as soon as you save the file:</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/923cba7a-1a40-4147-bafb-0427ca0032bc.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec34"></a>Plugin spotlight – ALE</h4></div></div></div><p><span class="strong"><strong>Asynchronous Lint Engine </strong></span>(<span class="strong"><strong>ALE</strong></span>) is a more recent player on the field, but it's been getting nearly as <span>much</span><a id="id326164629" class="indexterm"></a> traction as Syntastic has. Its primary selling point is that ALE displays lint errors as you type, and it runs the linters asynchronously. ALE is <span>available</span><a id="id326164637" class="indexterm"></a> from GitHub at <a class="ulink" href="https://github.com/w0rp/ale" target="_blank">https://github.com/w0rp/ale</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip115"></a>Note</h3><p>If you're using vim-plug, you can install ALE by adding <code class="literal">Plug 'w0rp/ale'</code> to your <code class="literal">.vimrc</code> file and running <code class="literal">:w | source $MYVIMRC | PlugInstall</code>. ALE requires Vim 8+ or Neovim for asynchronous calls to work.</p></div><p> </p><p>It's ready to be used out of the box, and the output looks very similar to Syntastic. Here's a screenshot of a file with ALE enabled (I've opened the location window using <code class="literal">:lopen</code>):</p><div class="mediaobject"><img src="/graphics/9781789341096/graphics/9b3a48de-fe60-439b-8121-e14c8cf2bf3e.png" /></div><p>You can see the line with an error highlighted with <code class="literal">&gt;&gt;</code>, and the status line displays the relevant <code class="literal">linmessage</code> at the bottom.</p><p>You can toggle ALE on and off by running <code class="literal">:ALEToggle</code> if you don't like to be nagged by it.</p><p>ALE is a lot more than just a linter though, and is a full-blown language server protocol client: it supports autocompletion, traveling to definitions, and so on. It's not as established and popular as, say, YouCompleteMe (see the<span class="emphasis"><em> </em></span><span class="emphasis"><em>Autocomplete </em></span>section in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Understanding the Text</em></span>)—but it has a loyal fan base and it's growing quickly.</p><p>For reference, you can jump to definitions by running <code class="literal">:ALEGoToDefinition</code> and look for references using <code class="literal">:ALEFindReferences</code>. In order to enable autocomplete, you'll need the following line in your <code class="literal">.vimrc</code> file:</p><pre class="programlisting">let g:ale_completion_enabled = 1</pre><p>You can learn more about ALE and decide whether it's a tool worth investing your time in at <a class="ulink" href="https://github.com/w0rp/ale" target="_blank">https://github.com/w0rp/ale</a>.</p></div></div></div>