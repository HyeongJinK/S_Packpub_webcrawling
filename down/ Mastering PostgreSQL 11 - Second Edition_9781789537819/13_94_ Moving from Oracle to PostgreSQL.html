<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec90"></a>Moving from Oracle to PostgreSQL</h2></div></div><hr /></div><p>So far, we have seen how the most <span>important</span><a id="id325887797" class="indexterm"></a> advanced SQL features can be ported or used in PostgreSQL. Given this introduction, it is time to take a look at migrating Oracle database systems in particular.</p><p>These days, migrating from Oracle to PostgreSQL has become really popular due to Oracle's new license and business policy. Around the world, people are moving away from Oracle <span>and</span><a id="id325872944" class="indexterm"></a> adopting PostgreSQL.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec147"></a>Using the oracle_fdw extension to move data</h3></div></div></div><p>One of my preferred methods to <span>move</span><a id="id325872891" class="indexterm"></a> people from Oracle to PostgreSQL is Laurenz Albe's <code class="literal">oracle_fdw</code> extension (<a class="ulink" href="https://github.com/laurenz/oracle_fdw" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>s</span><span>://</span><span>g</span><span>i</span><span>t</span><span>h</span><span>u</span><span>b</span><span>.</span><span>c<span>o</span><span>m</span><span>/</span><span>l</span><span>a</span><span>u</span><span>r</span><span>e</span><span>n</span><span>z</span><span>/</span><span>o</span><span>r</span><span>a</span><span>c</span><span>l</span><span>e</span><span>_</span><span>f</span><span>d</span><span>w</span></span></a>). It is a <span class="strong"><strong>foreign-data wrapper</strong></span> (<span class="strong"><strong>FDW</strong></span>) that allows you to represent a table in Oracle as a table in PostgreSQL. The <code class="literal">oracle_fdw</code> extension is <span>one</span><a id="id325565386" class="indexterm"></a> of the most sophisticated FDWs and is rock solid, well-documented, free, and open source.</p><p>Installing the <code class="literal">oracle_fdw</code> extension <span>requires</span><a id="id325565400" class="indexterm"></a> you to install the Oracle client library. Fortunately, there are already RPM packages that can be used out of the box (<a class="ulink" href="http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>://</span><span>w</span><span>w</span><span>w</span><span>.</span><span>o</span><span>r</span><span>a</span><span>c</span><span>l</span><span>e</span><span>.</span><span>c</span><span>o</span><span>m</span><span>/</span><span>t</span><span>e</span><span>c</span><span>h</span><span>n</span><span>e</span><span>t</span><span>w</span><span>o</span><span>r</span><span>k</span><span>/</span><span>t</span><span>o</span><span>p</span><span>i</span><span>c</span><span>s</span><span>/</span><span>l</span><span>i</span><span>n</span><span>u</span><span>x</span><span>x</span><span>86</span><span>-</span><span>64</span><span>s</span><span>o</span><span>f</span><span>t</span><span>-</span><span>092277</span><span>.</span><span>h</span><span>t</span><span>m</span><span>l</span></a>). The <code class="literal">oracle_fdw</code> extension needs the OCI driver to talk to Oracle. In addition to ready-made Oracle client drivers, there is also an RPM package for the <code class="literal">oracle_fdw</code> extension itself, which is provided by the community. If you are not using an RPM-based system, you might have to compile things on your own, which is clearly possible but a bit more labor-intensive.</p><p>Once the software has been installed, it can be enabled easily:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE EXTENSION oracle_fdw;</strong></span></pre><p>The <code class="literal">CREATE EXTENSION</code> clause loads the extension into your desired database. As a next step, a server can be created and users can be mapped to their counterparts on the Oracle side, as follows:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE SERVER oraserver FOREIGN DATA WRAPPER oracle_fdw </strong></span>
<span class="strong"><strong>          OPTIONS (dbserver '//dbserver.example.com/ORADB'); </strong></span>
<span class="strong"><strong>test=# CREATE USER MAPPING FOR postgres SERVER oradb </strong></span>
<span class="strong"><strong>          OPTIONS (user 'orauser', password 'orapass');</strong></span></pre><p>Then, it is time to fetch some data. My preferred way is to use the <code class="literal">IMPORT FOREIGN SCHEMA</code> clause to import the data definitions. The <code class="literal">IMPORT FOREIGN SCHEMA</code> clause will create a foreign table for each table in a remote schema and expose the data on the Oracle side, which can then be read easily.</p><p>The easiest way to make use of the schema import is to create separate schemas on PostgreSQL, which just holds the database schema. Then, data can be sucked into PostgreSQL easily using the FDW. The last section of this book, regarding migrating from MySQL, shows you an example of how this can be done with MySQL/MariaDB. Keep in mind that the <code class="literal">IMPORT FOREIGN SCHEMA</code> clause is part of the SQL/MED standard and therefore the process is the same as with MySQL/MariaDB. This applies to pretty much every FDW that supports the <code class="literal">IMPORT FOREIGN SCHEMA</code> clause.</p><p>While the <code class="literal">oracle_fdw</code> extension does most of the work for us, it still makes sense to see how datatypes are mapped. Oracle and PostgreSQL don't provide the exact same data types, so some mapping is either done by the <code class="literal">oracle_fdw</code> extension or by us manually. The <span>following</span><a id="id325856129" class="indexterm"></a> list gives an overview of how types are mapped. The left-hand column shows the Oracle types and the right-hand <span>column</span><a id="id325856138" class="indexterm"></a> presents the potential PostgreSQL counterparts:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Oracle types</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>PostgreSQL types</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">CHAR</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">NCHAR</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">VARCHAR</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">VARCHAR2</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">NVARCHAR2</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">CLOB</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">LONG</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">RAW</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">uuid</code> and <code class="literal">bytea</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BLOB</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">bytea</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BFILE</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">bytea</code> (read-only)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">LONG RAW</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">bytea</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">NUMBER</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">numeric</code>, <code class="literal">float4</code>, <code class="literal">float8</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">NUMBER(n,m)</code> with <code class="literal">m&lt;=0</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">numeric</code>, <code class="literal">float4</code>, <code class="literal">float8</code>, <code class="literal">int2</code>, <code class="literal">int4</code>, <code class="literal">int8</code>, <code class="literal">boolean</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">FLOAT</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">numeric</code>, <code class="literal">float4</code>, <code class="literal">float8</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BINARY_FLOAT</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">numeric</code>, <code class="literal">float4</code>, <code class="literal">float8</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BINARY_DOUBLE</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">numeric</code>, <code class="literal">float4</code>, <code class="literal">float8</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">DATE</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">date</code>, <code class="literal">timestamp</code>, <code class="literal">timestamptz</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TIMESTAMP</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">date</code>, <code class="literal">timestamp</code>, <code class="literal">timestamptz</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">TIMESTAMP WITH TIME ZONE</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">date</code>, <code class="literal">timestamp</code>, <code class="literal">timestamptz</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">TIMESTAMP WITH LOCAL TIME ZONE</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">date</code>, <code class="literal">timestamp</code>, <code class="literal">timestamptz</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">INTERVAL YEAR TO MONTH</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">interval</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">INTERVAL DAY TO SECOND</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">interval</code>, <code class="literal">char</code>, <code class="literal">varchar</code>, and <code class="literal">text</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">MDSYS.SDO_GEOMETRY</code></p></td><td style=""><p><code class="literal">geometry</code></p></td></tr></tbody></table></div><p> </p><p>If you want to use geometries, make sure that PostGIS is installed on your database server.</p><p>The downside of the <code class="literal">oracle_fdw</code> extension is that it <span>cannot</span><a id="id326052209" class="indexterm"></a> migrate <span>procedures</span><a id="id326052217" class="indexterm"></a> out of the box. Stored procedures are a somewhat special thing and need some manual intervention.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec148"></a>Using ora2pg to migrate from Oracle</h3></div></div></div><p>People migrated from <span>Oracle</span><a id="id326052232" class="indexterm"></a> to PostgreSQL long before FDWs existed. High license costs have plagued people for a long time, and so moving to PostgreSQL has been a natural thing to do for many years.</p><p>The alternative to the <code class="literal">oracle_fdw</code> extension is something called <span class="strong"><strong>ora2pg</strong></span>, which has <span>been</span><a id="id326052251" class="indexterm"></a> around for many years and can be downloaded for free from <a class="ulink" href="https://github.com/darold/ora2pg" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>s</span><span>://</span><span>g</span><span>i</span><span>t</span><span>h</span><span>u</span><span>b</span><span>.</span><span>c</span><span>o</span><span>m</span><span>/</span><span>d</span><span>a</span><span>r</span><span>o</span><span>l</span><span>d</span><span>/</span><span>o</span><span>r</span><span>a</span><span>2</span><span>p</span><span>g</span></a>. Ora2pg has been <span>written</span><a id="id326060930" class="indexterm"></a> in Perl and has a long tradition of new releases.</p><p>The features provided by <span>ora2pg</span><a id="id326060940" class="indexterm"></a> are stunning:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Migration of the full database schema, including tables, views, sequences, and indexes (unique, primary, foreign key, and check constraints).</li><li style="list-style-type: disc">Migration of privileges for users and groups.</li><li style="list-style-type: disc">Migration of partitioned tables.</li><li style="list-style-type: disc">Ability to export predefined functions, triggers, procedures, packages, and package bodies.</li><li style="list-style-type: disc">Migration of full or partial data (using a <code class="literal">WHERE</code> clause).</li><li style="list-style-type: disc">Full support of Oracle BLOB objects as PostgreSQL <code class="literal">bytea</code>.</li><li style="list-style-type: disc">Ability to export Oracle views as PostgreSQL tables.</li><li style="list-style-type: disc">Ability to export Oracle user-defined types.</li><li style="list-style-type: disc">Basic automatic conversion of PL/SQL code to PL/pgSQL code. Note that a fully automated conversion of everything is not possible. However, a lot of stuff can be transformed automatically.</li><li style="list-style-type: disc">Ability to export Oracle tables as FDW tables.</li><li style="list-style-type: disc">Ability to export materialized views.</li><li style="list-style-type: disc">Ability to display detailed reports about Oracle database content.</li><li style="list-style-type: disc">Assessment of the complexity of the migration process of an Oracle database.</li><li style="list-style-type: disc">Migration cost assessment of PL/SQL code from a file.</li><li style="list-style-type: disc">Ability to generate XML files to be used with Pentaho data integrator (Kettle).</li><li style="list-style-type: disc">Ability to export Oracle locator and spatial geometries into PostGIS.</li><li style="list-style-type: disc">Ability to export database links as Oracle FDW.</li><li style="list-style-type: disc">Ability to export synonyms as views.</li><li style="list-style-type: disc">Ability to export a directory as an external table or a directory for the <code class="literal">external_file</code> extension.</li><li style="list-style-type: disc">Ability to dispatch a list of SQL orders over multiple PostgreSQL connections</li><li style="list-style-type: disc">Ability to perform a <code class="literal">diff</code> between Oracle and PostgreSQL databases for test purposes.</li></ul></div><p>Using <code class="literal">ora2pg</code> looks hard at first glance. However, it is actually a lot easier than it seems. The basic concept is as follows:</p><pre class="programlisting"><span class="strong"><strong>/usr/local/bin/ora2pg </strong></span><span class="strong"><strong>-c /some_path/new_ora2pg.conf</strong></span></pre><p><code class="literal">ora2pg</code> needs a config file to run. The config file contains all the information needed to handle the process. Basically, the <span>default</span><a id="id326061032" class="indexterm"></a> config file is <span>already</span><a id="id326061041" class="indexterm"></a> really nice and it is a good starting point for most migrations. In the <code class="literal">ora2pg</code> language, a migration is a project.</p><p>The configuration will drive the entire project. When you run it, <code class="literal">ora2pg</code> will create a couple of directories with all the data that's been extracted from Oracle:</p><pre class="programlisting"><span class="strong"><strong>ora2pg --project_base /app/migration/ --init_project test_project </strong></span>
<span class="strong"><strong>Creating project test_project. </strong></span>
<span class="strong"><strong>/app/migration/test_project/ </strong></span>
<span class="strong"><strong>                    schema/ </strong></span>
<span class="strong"><strong>                            dblinks/ </strong></span>
<span class="strong"><strong>                            directories/ </strong></span>
<span class="strong"><strong>                            functions/ </strong></span>
<span class="strong"><strong>                            grants/ </strong></span>
<span class="strong"><strong>                            mviews/ </strong></span>
<span class="strong"><strong>                            packages/ </strong></span>
<span class="strong"><strong>                            partitions/ </strong></span>
<span class="strong"><strong>                            procedures/ </strong></span>
<span class="strong"><strong>                            sequences/ </strong></span>
<span class="strong"><strong>                            synonyms/ </strong></span>
<span class="strong"><strong>                            tables/ </strong></span>
<span class="strong"><strong>                            tablespaces/ </strong></span>
<span class="strong"><strong>                            triggers/ </strong></span>
<span class="strong"><strong>                            types/ </strong></span>
<span class="strong"><strong>                            views/ </strong></span>
<span class="strong"><strong>                    sources/ </strong></span>
<span class="strong"><strong>                            functions/ </strong></span>
<span class="strong"><strong>                            mviews/ </strong></span>
<span class="strong"><strong>                            packages/ </strong></span>
<span class="strong"><strong>                            partitions/ </strong></span>
<span class="strong"><strong>                            procedures/ </strong></span>
<span class="strong"><strong>                            triggers/ </strong></span>
<span class="strong"><strong>                            types/ </strong></span>
<span class="strong"><strong>                            views/ </strong></span>
<span class="strong"><strong>                    data/ </strong></span>
<span class="strong"><strong>                    config/ </strong></span>
<span class="strong"><strong>                    reports/ </strong></span>

<span class="strong"><strong>Generating generic configuration file </strong></span>
<span class="strong"><strong>Creating script export_schema.sh to automate all exports. </strong></span>
<span class="strong"><strong>Creating script import_all.sh to automate all imports. </strong></span></pre><p>As you can see, scripts are generated that can just be executed. The <span>resulting</span><a id="id326068208" class="indexterm"></a> data can then be imported in PostgreSQL nicely. Be prepared to change <span>procedures</span><a id="id326068216" class="indexterm"></a> here and there. Not everything can be migrated automatically, so manual intervention is expected.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec149"></a>Common pitfalls</h3></div></div></div><p>There are some very basic syntax <span>elements</span><a id="id326068231" class="indexterm"></a> that work in Oracle, but might not work in PostgreSQL. This section lists some of the most important <span>pitfalls</span> to take into consideration. Of course, this list is not complete by far, but it should point you in the right direction.</p><p>In Oracle, you might find the following statement:</p><pre class="programlisting"><span class="strong"><strong>DELETE mytable;</strong></span></pre><p>In PostgreSQL, this statement is wrong, since PostgreSQL requires you to use a <code class="literal">FROM</code> clause in the <code class="literal">DELETE</code> statement. The good news is that this kind of statement is easy to fix.</p><p>The next thing you might find is the following:</p><pre class="programlisting"><span class="strong"><strong>SELECT sysdate </strong></span><span class="strong"><strong>FROM dual;</strong></span></pre><p>PostgreSQL has neither a <code class="literal">sysdate</code> function nor a <code class="literal">dual</code> function. The <code class="literal">dual</code> function part is easy to fix as you can simply create a <code class="literal">VIEW</code> returning one line. In Oracle, the <code class="literal">dual</code> function works as follows:</p><pre class="programlisting"><span class="strong"><strong>SQL&gt; desc dual </strong></span>
<span class="strong"><strong>Name Null? Type </strong></span>
<span class="strong"><strong>----------------------------------------- -------- - </strong></span>
<span class="strong"><strong>DUMMY VARCHAR2(1) </strong></span>

<span class="strong"><strong>SQL&gt; select * from dual; </strong></span>

<span class="strong"><strong>D </strong></span>
<span class="strong"><strong>- </strong></span>
<span class="strong"><strong>X</strong></span></pre><p>In PostgreSQL, the same can be achieved by creating the following <code class="literal">VIEW</code>:</p><pre class="programlisting"><span class="strong"><strong>CREATE </strong></span><span class="strong"><strong>VIEW dual AS SELECT 'X' AS dummy;</strong></span></pre><p>The <code class="literal">sysdate</code> function is also easy to fix. It can be <span>replaced</span><a id="id326128460" class="indexterm"></a> with the <code class="literal">clock_timestamp()</code> function.</p><p>Another common problem is the lack of data types such as <code class="literal">VARCHAR2</code>, as well as the lack of special functions only supported by Oracle. A good way to get around these issues is to install the <code class="literal">orafce</code> extension, which provides most of the stuff that's typically needed, which included the most commonly used functions. It certainly makes sense to check out <a class="ulink" href="https://github.com/orafce/orafce" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>s</span><span>://</span><span>g</span><span>i</span><span>t</span><span>h</span><span>u</span><span>b</span><span>.</span><span>c</span><span>o</span><span>m</span><span>/</span><span>o</span><span>r</span><span>a</span><span>f</span><span>c</span><span>e</span><span>/</span><span>o</span><span>r</span><span>a</span><span>f</span><span>ce</span></a> to learn more about the <code class="literal">orafce</code> extension. It has been around for many <span>years</span><a id="id326128551" class="indexterm"></a> and is a solid piece of software.</p><p>A recent study shows that the <code class="literal">orafce</code> extension helps to ensure that 73% of all Oracle SQLs can be executed on PostgreSQL without modifications if the <code class="literal">orafce</code> extension is around (done by NTT).</p><p>One of the most common pitfalls is the way Oracle handles outer joins. Consider the following example:</p><pre class="programlisting"><span class="strong"><strong>SELECT employee_id, manager_id 
</strong></span><span class="strong"><strong>   FROM employees 
</strong></span><span class="strong"><strong>   WHERE employees.manager_id(+) = employees.employee_id;</strong></span></pre><p>This kind of syntax is not provided by PostgreSQL and never will be. Therefore, the join has to be rewritten as a proper outer join. The <code class="literal">+</code> is <span>highly</span><a id="id326132482" class="indexterm"></a> Oracle-specific and has to be removed.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec150"></a>ora_migrator – migrating from Oracle to PostgreSQL quickly</h3></div></div></div><p>My job as a PostgreSQL consultant has <span>given</span><a id="id326132497" class="indexterm"></a> me plenty of <span>opportunity</span><a id="id326132505" class="indexterm"></a> to migrate from Oracle to PostgreSQL. However, I sometimes found it hard to find the proper toolchain, that exactly suits my purpose. In general, I have never found a perfect tool to migrate simple databases fast, while not trying to migrate the hard stuff (and break it at the same time). The solution was to write my own tool. My team and I came up with a solution built on the <code class="literal">oracle_fdw</code>, which already has all of the infrastructure to predict data types on the PostgreSQL side and to load data fast and efficiently. On top of that, <code class="literal">oracle_fdw</code> is allowed to not just connect a table, but also turn a remote query into a PostgreSQL table. <code class="literal">oracle_fdw</code> is therefore a really good foundation for a migration tool.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec102"></a>How does ora_migrator work?</h4></div></div></div><p>The question that is now naturally <span>arising</span><a id="id326132530" class="indexterm"></a> is: how does <code class="literal">ora_migrator</code> really work? Let's take a look. The first thing <code class="literal">ora_migrator</code> does is connect to the Oracle system catalog and copy data into a staging schema on the PostgreSQL side. This is key to success because we don't have to parse all of the Oracle SQL and try and convert it. By accessing the system tables directly, we can compile the PostgreSQL side on our own, which is a lot easier and a lot more robust. <code class="literal">oracle_fdw</code> has all of the mechanisms to do that and we can therefore easily build on top of it.</p><p>Then, the Oracle stuff is cloned into a PostgreSQL staging schema. The idea here is that you might want to change the layout of a table and the data types. <code class="literal">oracle_fdw</code> does a good job in predicting the data structure on the PostgreSQL, but it cannot know for certain what is really needed. Therefore, it makes sense to have this intermediate step before the tables are really compiled to PostgreSQL and before the data is finally migrated.</p><p>Our website <span>shows</span><a id="id326139554" class="indexterm"></a> how <code class="literal">ora_migrator</code> works in detail: <a class="ulink" href="https://www.cybertec-postgresql.com/en/ora_migrator-moving-from-oracle-to-postgresql-even-faster/" target="_blank">https://www.cybertec-postgresql.com/en/ora_migrator-moving-from-oracle-to-postgresql-even-faster/</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note95"></a>Note</h3><p>Note that the code is open source and can be used free of charge.</p></div></div></div></div>