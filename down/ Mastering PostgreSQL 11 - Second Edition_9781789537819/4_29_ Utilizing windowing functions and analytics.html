<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec34"></a>Utilizing windowing functions and analytics</h2></div></div><hr /></div><p>Now that we have discussed ordered sets, it is time to take a <span>look</span><a id="id325565410" class="indexterm"></a> at windowing functions. Aggregates follow a fairly simple principle; take many rows and turn <span>them</span><a id="id325565398" class="indexterm"></a> into fewer, aggregated rows. A windowing function is different. It compares the current row with all rows in the group. The number of rows returned does not change.</p><p>Here is an example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT avg(production) FROM t_oil; 
    avg 
----------- 
 2607.5139  
(1 row)</strong></span>

<span class="strong"><strong>test=# SELECT country, year, production, 
              consumption, avg(production) OVER () 
 FROM t_oil 
 LIMIT 4; </strong></span><span class="strong"><strong>
country  | year  | production | consumption |       avg 
---------+-------+------------+-------------+----------  
USA      | 1965  |       9014 |      11522  | 2607.5139 
USA      | 1966  |      9579  |      12100  | 2607.5139 
USA      | 1967  |     10219  |      12567  | 2607.5139 
USA      | 1968  |     10600  |      13405  | 2607.5139  
(4 rows)</strong></span></pre><p>The average production in our dataset is around 2.6 million barrels per day. The goal of this query is to add this value as a column. It is now easy to compare the current row to the overall average.</p><p>Keep in mind that the <code class="literal">OVER</code> clause is essential. PostgreSQL is not able to process the query w<span>ithout it</span>:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT country, year, production, consumption, avg(production) FROM  t_oil; </strong></span>
<span class="strong"><strong>ERROR: column "t_oil.country" must  appear in the GROUP BY clause or be used  
       in an aggregate function 
LINE  1: SELECT country, year,  production, consumption, avg(productio...</strong></span></pre><p><span>This</span> actually makes sense because the average has to be defined precisely. The database engine cannot just guess at any value.</p><p>Â </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note31"></a>Note</h3><p>Other database engines can accept aggregate functions without an <code class="literal">OVER</code> or even a <code class="literal">GROUP BY</code> clause. However, from a logical point of view this is wrong, and on top of that, a violation of SQL.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec48"></a>Partitioning data</h3></div></div></div><p>So far, the same result can also easily be <span>achieved</span><a id="id326127522" class="indexterm"></a> using a <code class="literal">sub-select</code>. However, if you want more than just the overall average, <code class="literal">sub-selects</code> will turn your queries into nightmares due to complexity. Suppose, you don't just want the overall average but the average of the country you are dealing with. A <code class="literal">PARTITION BY</code> clause is what you need:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT country, year, production, consumption, 
              avg(production) OVER (PARTITION BY country) 
FROM t_oil; </strong></span><span class="strong"><strong>
 country  | year  | production | consumption |      avg 
----------+-------+------------+-------------+-----------  
 Canada   | 1965  |   920      |     1108    | 2123.2173 
 Canada   | 2010  |   3332     |     2316    | 2123.2173 
 Canada   | 2009  |   3202     |     2190    | 2123.2173 
 ... 
 Iran     | 1966  |   2132     |     148     | 3631.6956 
 Iran     | 2010  |   4352     |     1874    | 3631.6956 
 Iran     | 2009  |   4249     |     2012    | 3631.6956 
 ...</strong></span></pre><p>The point here is that each country will be assigned to the average of the country. The <code class="literal">OVER</code> clause defines the window we are looking at. In this case, the window is the country the row belongs to. In other words, the query returns the rows compared to all rows in this country.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note32"></a>Note</h3><p>The <code class="literal">year</code> column is not sorted. The query does not contain an explicit sort order so it might be that data is returned in a random order. Remember, SQL does not promise sorted output unless you explicitly state what you want.</p></div><p>Basically, a <code class="literal">PARTITION BY</code> clause takes any expression. Usually, most people will use a column to partition the data. Here is an example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year, production, 
              avg(production) OVER (PARTITION BY year &lt; 1990)  
FROM  t_oil 
WHERE  country = 'Canada'  
ORDER  BY year; </strong></span><span class="strong"><strong>
 year  | production |       avg 
-------+------------+----------------------- 
 1965  |        920 | 1631.6000000000000000 
 1966  |       1012 | 1631.6000000000000000 
 ... 
 1990  |       1967 | 2708.4761904761904762 
 1991  |        1983| 2708.4761904761904762 
 1992  |        2065| 2708.4761904761904762 
 ...</strong></span></pre><p>The point is that data is split using the expression. <code class="literal">year &lt; 1990</code> can return two values: <code class="literal">true</code> or <code class="literal">false</code>. Depending on the group a year is in, it will be assigned to the pre-1990 average or to the post-1990 average. PostgreSQL is really flexible here. Using functions to determine group membership is not uncommon in real-world applications.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec49"></a>Ordering data inside a window</h3></div></div></div><p>A <code class="literal">PARTITION BY</code> clause is not the only <span>possible</span><a id="id326127602" class="indexterm"></a> thing you can put into an <code class="literal">OVER</code> clause. Sometimes it is necessary to sort data inside a window. <code class="literal">ORDER BY</code> will provide data to your aggregate functions in a certain way. Here is an example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT country, year, production, 
              min(production) OVER (PARTITION BY country ORDER BY year)  
FROM   t_oil 
WHERE  year BETWEEN 1978 AND 1983 AND country IN ('Iran', 'Oman'); </strong></span>
<span class="strong"><strong>country | year | production | min 
---------+-----+------------+------ </strong></span>
<span class="strong"><strong>Iran    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1978 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>5302 </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>5302</strong></span>
<span class="strong"><strong>Iran    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1979 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>3218 </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>3218</strong></span>
<span class="strong"><strong>Iran    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1980 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>1479 </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1479</strong></span>
<span class="strong"><strong>Iran    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1981 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>1321 </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1321</strong></span>
<span class="strong"><strong>Iran    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1982 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>2397 </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1321</strong></span>
<span class="strong"><strong>Iran    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1983 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>2454 </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1321</strong></span>
<span class="strong"><strong>Oman    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1978 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>314  </strong></span><span class="strong"><strong>|  </strong></span><span class="strong"><strong>314</strong></span>
<span class="strong"><strong>Oman    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1979 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>295  </strong></span><span class="strong"><strong>|  </strong></span><span class="strong"><strong>295</strong></span>
<span class="strong"><strong>Oman    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1980 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>285  </strong></span><span class="strong"><strong>|  </strong></span><span class="strong"><strong>285</strong></span>
<span class="strong"><strong>Oman    </strong></span><span class="strong"><strong>| </strong></span><span class="strong"><strong>1981 </strong></span><span class="strong"><strong>|       </strong></span><span class="strong"><strong>330  </strong></span><span class="strong"><strong>|  </strong></span><span class="strong"><strong>285</strong></span>
<span class="strong"><strong>...</strong></span></pre><p>Two countries (<code class="literal">Iran</code> and <code class="literal">Oman</code>) are chosen from our dataset for the period <code class="literal">1978</code> to <code class="literal">1983</code>. Keep in mind, there was a revolution going on in <code class="literal">Iran</code> in <code class="literal">1979</code> so this had some impact on the production of oil. The data reflects that.</p><p>What the query does is to calculate the <span>minimum</span><a id="id326127349" class="indexterm"></a> production up to a certain point in our time series. At this point, it is a good way for SQL students to remember what an <code class="literal">ORDER BY</code> clause does inside an <code class="literal">OVER</code> clause. In this example, the <code class="literal">PARTITION BY</code> clause will create one group for each country and order data inside the group. The <code class="literal">min</code> function will loop over the sorted data and provide the required minimums.</p><p>If you are new to windowing functions, there is something you should be aware of. It really does make a difference, irrespective of whether you use an <code class="literal">ORDER BY</code> clause or not:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT country, year, production, </strong></span>
<span class="strong"><strong>          min(production) OVER (), </strong></span>
<span class="strong"><strong>          min(production) OVER (ORDER BY year) </strong></span>
<span class="strong"><strong>   FROM t_oil </strong></span>
<span class="strong"><strong>   WHERE year BETWEEN 1978 AND 1983 </strong></span>
<span class="strong"><strong>         AND country = 'Iran'; </strong></span>
<span class="strong"><strong> country | year | production  | min  | min </strong></span>
<span class="strong"><strong>---------+------+-------------+------+------ </strong></span>
<span class="strong"><strong> Iran    | 1978 |         5302| 1321 | 5302 </strong></span>
<span class="strong"><strong> Iran    | 1979 |        3218 | 1321 | 3218 </strong></span>
<span class="strong"><strong> Iran    | 1980 |        1479 | 1321 | 1479 </strong></span>
<span class="strong"><strong> Iran    | 1981 |        1321 | 1321 | 1321 </strong></span>
<span class="strong"><strong> Iran    | 1982 |        2397 | 1321 | 1321 </strong></span>
<span class="strong"><strong> Iran    | 1983 |        2454 | 1321 | 1321 </strong></span>
<span class="strong"><strong>(6 rows)</strong></span></pre><p>If the aggregate is used without <code class="literal">ORDER BY</code>, it will automatically take the minimum of the entire dataset inside your windows. This doesn't happen if there is an <code class="literal">ORDER BYÂ </code>clause. In this case, it will always be the minimum up to this point, given the order you have defined.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec50"></a>Using sliding windows</h3></div></div></div><p>So far the window we have used inside our <span>query</span><a id="id326310244" class="indexterm"></a> has been static. However, for calculations such as a moving average, this is not enough. A <span>moving</span><a id="id326310252" class="indexterm"></a> average needs a sliding window that moves along as data is processed.</p><p>Here is an example of how a moving average can be achieved:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT country, year, production,  
        min(production) 
        OVER (PARTITION BY country                             </strong></span>
<span class="strong"><strong>        ORDER BY year ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) 
FROM  t_oil 
WHERE year BETWEEN 1978 AND 1983 
      AND country IN ('Iran', 'Oman'); </strong></span><span class="strong"><strong>
country  | year  | production | min 
---------+-------+------------+------  
Iran     | 1978  |       5302 | 3218 
Iran     | 1979  |       3218 | 1479 
Iran     | 1980  |       1479 | 1321 
Iran     | 1981  |       1321 | 1321 
Iran     | 1982  |       2397 | 1321 
Iran     | 1983  |       2454 | 2397 
Oman     | 1978  |       314  | 295 
Oman     | 1979  |       295  | 285 
Oman     | 1980  |       285  | 285 
Oman     | 1981  |       330  | 285 
Oman     | 1982  |       338  | 330 
Oman     | 1983  |       391  | 338  
(12 rows)</strong></span></pre><p>The most important thing is that a moving window should be used with anÂ <code class="literal">ORDER BY</code>Â clause. Otherwise, there will be major problems.Â PostgreSQL would actually accept the query but the result would be totally wrong. Remember, feeding data to a sliding window <span>without</span><a id="id326310283" class="indexterm"></a> ordering it first will <span>simply</span><a id="id326310292" class="indexterm"></a> lead to random data.</p><p><code class="literal">ROWS BETWEEN 1 PRECEDING</code> and <code class="literal">1 FOLLOWING</code> defines the window. In this example, up to three rows will be in use: the current row, the one before, and the one after the current row. To illustrate how the sliding window works, check out the following example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT *, array_agg(id)</strong></span>
<span class="strong"><strong>                 OVER (ORDER BY id ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)  
   FROM  generate_series(1, 5) AS id; </strong></span>
<span class="strong"><strong>id  | array_agg 
----+----------- 
  1 | {1,2} 
  2 | {1,2,3} 
  3 | {2,3,4} 
  4 | {3,4,5} 
  5 | {4,5}  
(5 rows)</strong></span></pre><p>TheÂ <code class="literal">array_agg</code> function will turn a list of values into a PostgreSQL array. It will help to explain how the sliding window operates.</p><p>Actually, this trivial query has some very important aspects. What you see is that the first array contains only two values. There is no entry before <code class="literal">1</code> and therefore the array is not full. PostgreSQL does not add null entries because they would be ignored by aggregates anyway. The same happens at the end of the data.</p><p>However, sliding <span>windows</span><a id="id326310340" class="indexterm"></a> offer more. There are a <span>couple</span><a id="id326310348" class="indexterm"></a> of keywords that can be used to specify the sliding <span>window:</span></p><pre class="programlisting"><span class="strong"><strong>test=# SELECT *, 
          array_agg(id) OVER (ORDER BY id ROWS BETWEEN 
                              UNBOUNDED PRECEDING AND 0 FOLLOWING) 
FROM generate_series(1, 5) AS id;</strong></span>
<span class="strong"><strong> id |  array_agg 
----+------------- 
  1 | {1} 
  2 | {1,2} 
  3 | {1,2,3} 
  4 | {1,2,3,4} 
  5 | {1,2,3,4,5} </strong></span><span class="strong"><strong> 
(5 rows) </strong></span></pre><p>The <code class="literal">UNBOUNDED PRECEDING</code> keywords meanÂ that everything before the current line will be in the window. The counterpart to <code class="literal">UNBOUNDED PRECEDING</code> is <code class="literal">UNBOUNDED FOLLOWING</code>. Let us look at the following example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT *, 
   array_agg(id) OVER (ORDER BY id ROWS BETWEEN 2 FOLLOWING AND UNBOUNDED FOLLOWING) 
FROM generate_series(1, 5) AS id; </strong></span>
<span class="strong"><strong> id | array_agg 
----+----------- 
 1  | {3,4,5} 
 2  | {4,5} 
 3  | {5} 
 4  | 
 5  | 
(5 rows)</strong></span></pre><p>As you can see, it is also possible to use a window that is in the future. PostreSQL is very flexible here.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec51"></a>Abstracting window clauses</h3></div></div></div><p>A windowing function allows us to add columns to the <span>result</span><a id="id326561732" class="indexterm"></a> set that have been calculated on the fly. However, it is a frequent phenomenon that many columns are based on the same window. Putting the same clauses into your queries over and over again is definitely not a good idea, because your queries will be hard to read and therefore hard to maintain.</p><p>The <code class="literal">WINDOW</code> clause allows developers to pre-define a window and use it at various places in the query. Here is how it works:</p><pre class="programlisting"><span class="strong"><strong>SELECT country, year, production, 
       min(production) OVER (w), 
       max(production) OVER (w) 
FROM t_oil 
WHERE country = 'Canada' 
      AND year BETWEEN 1980 
      AND 1985 
WINDOW w AS (ORDER BY year);</strong></span>
<span class="strong"><strong>country | year  | production | min  | max 
--------+-------+------------+------+------</strong></span>
<span class="strong"><strong>Canada  | 1980  |       1764 | 1764 | 1764</strong></span>
<span class="strong"><strong>Canada  | 1981  |       1610 | 1610 | 1764</strong></span>
<span class="strong"><strong>Canada  | 1982  |       1590 | 1590 | 1764</strong></span>
<span class="strong"><strong>Canada  | 1983  |       1661 | 1590 | 1764</strong></span>
<span class="strong"><strong>Canada  | 1984  |       1775 | 1590 | 1775</strong></span>
<span class="strong"><strong>Canada  | 1985  |       1812 | 1590 | 1812</strong></span>
<span class="strong"><strong>(6 rows) </strong></span></pre><p>The example shows that <code class="literal">min</code> and <code class="literal">max</code> will use the same clause.</p><p>Of course, it is possible to have more than just one <code class="literal">WINDOW</code> clauseâPostgreSQL does not impose serious restrictions on users here.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec52"></a>Making use of on-board windowing functions</h3></div></div></div><p>Having introduced you to the <span>basic</span><a id="id326561809" class="indexterm"></a> concepts,Â it is time to take a look at which windowing functions PostgreSQL will support out of the box. You have already seen that <span>windowing</span><a id="id326561817" class="indexterm"></a> works with all standard aggregate functions. On top of those functions, PostgreSQL offers some additional functions that are exclusively for windowing and analytics.</p><p>In this section, some highly important functions will be explained and discussed.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec18"></a>The rank and dense_rank functions</h4></div></div></div><p>TheÂ  <code class="literal">rank()</code> and <code class="literal">dense_rank()</code> functions are, in my judgment, the most <span>prominent</span><a id="id326561841" class="indexterm"></a> functions in SQL. The <code class="literal">rank()</code> function returns the number of the current row <span>within</span><a id="id326561852" class="indexterm"></a> its window. Counting starts at <code class="literal">1</code>.</p><p>Here is an example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year, production, 
              rank() OVER (ORDER BY production) 
FROM  t_oil 
WHERE country = 'Other Middle East' 
ORDER BY rank 
LIMIT 7;</strong></span>
<span class="strong"><strong> year  | production | rank 
-------+------------+------ 
 2001  |  47        |  1 
 2004  |  48        |  2 
 2002  |  48        |  2 
 1999  |  48        |  2 
 2000  |  48        |  2 
 2003  |  48        |  2 
 1998  |  49        |  7  
(7 rows)</strong></span></pre><p>The <code class="literal">rank</code> column will number those tuples in your dataset. Note that many rows in my sample are equal. Therefore, the rank will jump from <code class="literal">2</code> to <code class="literal">7</code> directly, because many production values are identical. If you want to avoid that, the <code class="literal">dense_rank()</code> function is the way to go:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year, production, 
              dense_rank() </strong></span><span class="strong"><strong>OVER (ORDER BY production) 
FROM  t_oil 
WHERE country = 'Other Middle East' 
ORDER BY dense_rank 
LIMIT 7;</strong></span>
<span class="strong"><strong> year  | production | dense_rank 
-------+------------+------------ 
 2001  |         47 |          1 
 2004  |           4|          2 
 ... 
 2003  |         48 |          2 
 1998  |         49 |          3  
(7 rows)</strong></span></pre><p>PostgreSQL will pack the numbers more tightly. There will be no more gaps.</p><p>Â </p><p>Â </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec19"></a>The ntile() function</h4></div></div></div><p>Some applications require data to be <span>split</span><a id="id326561922" class="indexterm"></a> into ideally equal groups. The <code class="literal">ntile()</code> function will do exactly that for you.</p><p>The following example shows how data can be split into groups:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year, production, 
              ntile(4) </strong></span><span class="strong"><strong>OVER (ORDER BY production)</strong></span>
<span class="strong"><strong>  FROM  t_oil 
  WHERE  country = 'Iraq' 
         AND year BETWEEN 2000 AND 2006;</strong></span>
<span class="strong"><strong>year  | production | ntile 
------+------------+------- 
2003  |       1344 |    1 
2005  |       1833 |    1 
2006  |       1999 |    2 
2004  |       2030 |    2 
2002  |       2116 |    3 
2001  |       2522 |    3 
2000  |       2613 |    4  
(7 rows)</strong></span></pre><p>The query splits data into four groups. The trouble is that only seven rows are selected, which makes it impossible to create four even groups. As you can see, PostgreSQL will fill up the first three groups and make the last one a bit smaller. You can rely on the fact that the groups at the end will always tend to be a bit smaller than the rest.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note33"></a>Note</h3><p>In this example, only a handful of rows are used. In real-world applications, millions of rows will be involved and therefore it is no problem if groups are not perfectly equal.</p></div><p>The <code class="literal">ntile()</code> function is usually not used alone. Sure, it helps to assign a group ID to a row. However, in real-world applications, people want to perform calculations on top of those groups. Suppose you want to create a <code class="literal">quartile</code> distribution for your data. Here is how it works:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT grp, min(production), max(production), count(*)  
FROM  ( 
         SELECT year, production, 
                ntile(4) </strong></span><span class="strong"><strong>OVER (ORDER BY production) AS grp 
         FROM   t_oil 
         WHERE  country = 'Iraq' 
      ) AS x 
GROUP  BY ROLLUP (1);</strong></span>
<span class="strong"><strong> grp | min  | max  | count 
-----+------+------+------- 
 1   | 285  | 1228 |   12 
 2   | 1313 | 1977 |   12 
 3   | 1999 | 2422 |   11 
 4   | 2428 | 3489 |   11 
     | 285  | 3489 |   46  
(5 rows)</strong></span></pre><p>The most important thing is that the calculation cannot be done in one step. When doing SQL training courses here at Cybertec (<a class="ulink" href="https://www.cybertec-postgresql.com" target="_blank">https://<span>www.cybertec-postgresql.com</span></a>), I try to explain to students that <span>whenever</span><a id="id326014258" class="indexterm"></a> you don't know how to do it all at once, consider using a <code class="literal">sub-select</code>. In analytics, this is usually a good idea. In this example, the first thing done in the <code class="literal">sub-select</code> is the attachment of a group label to each group. Then those groups are taken and processed in the main query.</p><p>The result is already something that could be used in a real-world application (maybe as a legend located next to a graph, and so on).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec20"></a>The lead() and lag() functions</h4></div></div></div><p>While the <code class="literal">ntile()</code> function is essential for <span>splitting</span><a id="id326014285" class="indexterm"></a> a dataset into groups, theÂ Â <code class="literal">lead()</code> and <code class="literal">lag()</code> functions are here to move lines within the result set. A typical use case is to <span>calculate</span><a id="id326014300" class="indexterm"></a> the difference in production from one year to the next, as <span>shown in the following example</span>:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year, production, 
              lag(production, 1) OVER (ORDER BY year) 
</strong></span><span class="strong"><strong>       FROM  t_oil 
       WHERE country = 'Mexico' 
       LIMIT 5;</strong></span><span class="strong"><strong> year  | production | lag 
-------+------------+----- 
 1965  |        362 | </strong></span>
<span class="strong"><strong> 1966  |        370 | 362</strong></span>
<span class="strong"><strong> 1967  |        411 | 370</strong></span>
<span class="strong"><strong> 1968  |        439 | 411</strong></span>
<span class="strong"><strong> 1969  |        461 | 439</strong></span>
<span class="strong"><strong>(5 rows)</strong></span></pre><p>Before actually calculating the change in production, it makes sense to sit back and see what the <code class="literal">lag()</code> function actually does. You can see that the column is moved by one row. The data moved as defined in the <code class="literal">ORDER BY</code> clause. In my example, it means down. An <code class="literal">ORDER BY DESC</code> clause would of course have moved the data up.</p><p>Â </p><p>From this point on, the query is easy:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year, production, 
              production - lag(production, 1) OVER (ORDER BY year) 
       FROM  t_oil 
       WHERE country = 'Mexico' 
       LIMIT 3;</strong></span>
<span class="strong"><strong> year | production | ?column? 
------+------------+---------- 
 1965 |        362 | 
 1966 |        370 |      8 
 1967 |        411 |     41 </strong></span><span class="strong"><strong>
(3 rows)</strong></span></pre><p>All you have to do is to calculate the difference as you would with any other column. Note that theÂ <code class="literal">lag()</code> function has two parameters. The first one <span>indicates</span><a id="id326014386" class="indexterm"></a> which column is to be displayed. The second column tells PostgreSQL how many rows you <span>want</span><a id="id326014394" class="indexterm"></a> to move. Putting in <code class="literal">7</code> therefore, means that everything is off by seven rows.</p><p>Note that the first value is <code class="literal">Null</code> (as are all other lagged rows without a preceding value).</p><p>The <code class="literal">lead()</code> function is the counterpart of the <code class="literal">lag()</code> function; it will move rows up instead of down:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year, production, 
              production - lead(production, 1) OVER (ORDER BY year) 
       FROM  t_oil 
       WHERE country = 'Mexico' 
       LIMIT 3;</strong></span><span class="strong"><strong> year  | production | ?column? 
-------+------------+----------</strong></span>
<span class="strong"><strong> 1965  |        362 |     -8</strong></span>
<span class="strong"><strong> 1966  |        370 |    -41</strong></span>
<span class="strong"><strong> 1967  |        411 |    -28</strong></span>

<span class="strong"><strong>(3 rows)</strong></span></pre><p>Basically, PostgreSQL will also accept negative values for lead and lag columns. TheÂ <code class="literal">lag(production, -1)</code> is therefore a replacement for <code class="literal">lead(production, 1)</code>. However, it is definitely cleaner to use the right function to move data in the direction you want.</p><p>Â </p><p>So far you have seen how to lag a single column. In most applications, lagging a single value will be the standard case used by most developers. The point is, PostgreSQL can do a lot more than that. It is possible to lag entire lines:</p><pre class="programlisting"><span class="strong"><strong>test=# \x 
Expanded display is on. 
test=# SELECT year, production, 
              lag(t_oil, 1) OVER (ORDER BY year) 
       FROM  t_oil 
       WHERE country = 'USA' 
       LIMIT 3;</strong></span>
<span class="strong"><strong>-[ RECORD 1 ]------------------------------------- 
year          | 1965 
production    | 9014 
lag           | 
-[ RECORD 2 ]------------------------------------- 
year          | 1966 
production    | 9579 
lag           | ("North America",USA,1965,9014,11522) 
-[ RECORD 3 ]------------------------------------- 
year          | 1967 
production    | 10219 
lag           | ("North America",USA,1966,9579,12100)</strong></span></pre><p>The beauty here is that more than just a single value can be compared to the previous row. The trouble, though, is that PostgreSQL will return the <span>entire</span><a id="id326014475" class="indexterm"></a> row as a <span>composite</span><a id="id326014484" class="indexterm"></a> type and therefore it is hard to work with. To dissect a composite type, you can use parentheses and a star:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year, production, 
              (lag(t_oil, 1) OVER (ORDER BY year)).* 
       FROM  t_oil 
       WHERE country = 'USA' 
       LIMIT 3; 
</strong></span></pre><pre class="programlisting"><span class="strong"><strong> year | prod  | region     | country | year | prod | consumption </strong></span>
<span class="strong"><strong>------+-------+------------+---------+------+------+------------- </strong></span>
<span class="strong"><strong> 1965 | 9014  |            |         |      |      | </strong></span>
<span class="strong"><strong> 1966 | 9579  | N. America |     USA | 1965 | 9014 | 11522 </strong></span>
<span class="strong"><strong> 1967 | 10219 | N. America |     USA | 1966 | 9579 | 12100 </strong></span>
<span class="strong"><strong>(3 rows)</strong></span></pre><p>Why is that useful? Lagging an entire row will make it possible to see if the data has been inserted more than once. It is pretty simple to detect duplicate rows (or close-to-duplicate rows) in your time series.</p><p>Â </p><p>Â </p><p>Â </p><p>Â </p><p>Â </p><p>Â </p><p>Check out the following example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT * 
       FROM (SELECT t_oil, lag(t_oil) OVER (ORDER BY year) 
             FROM  t_oil 
             WHERE country = 'USA'
       ) AS x 
       WHERE t_oil = lag; </strong></span>
<span class="strong"><strong> t_oil  | lag 
--------+-----  
(0 rows)</strong></span></pre><p>Of course, the sample <span>data</span><a id="id326280974" class="indexterm"></a> does not <span>contain</span><a id="id326280983" class="indexterm"></a> duplicates. However, in real-world examples, duplicates can easily happen, and it is easy to detect them even if there is no primary key.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note34"></a>Note</h3><p>The <code class="literal">t_oil</code>Â row is really the entire row. The lag returned by the <code class="literal">sub-select</code> is also a complete row. In PostgreSQL, composite types can be compared directly in case the fields are identical. PostgreSQL will simply compare one field after the other.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec21"></a>The first_value(), nth_value(), and last_value() functions</h4></div></div></div><p>Sometimes, it is necessary to <span>calculate</span><a id="id326281010" class="indexterm"></a> data based on the first <span>value</span><a id="id326281019" class="indexterm"></a> of a <span>data</span><a id="id326281028" class="indexterm"></a> window. Unsurprisingly, the function to do that is <code class="literal">first_value()</code>:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year,  production, 
              first_value(production) OVER (ORDER BY year) 
       FROM   t_oil 
       WHERE  country = 'Canada'  
       LIMIT  4; </strong></span>
<span class="strong"><strong> year  | production | first_value 
-------+------------+------------- 
 1965  |        920 |         920 
 1966  |       1012 |         920 
 1967  |       1106 |         920 
 1968  |       1194 |         920  
(4 rows) </strong></span></pre><p>Again, a sort order is needed to tell the system where the first value actually is. PostgreSQL will then put the same value into the last column. If you want to find the last value in the window, simply use the <code class="literal">last_value()</code> function instead of the <code class="literal">first_value()</code> function.</p><p>Â </p><p>If you are not interested in the first or the last value but are looking for something in the middle, PostgreSQL provides the <code class="literal">nth_value()</code> function:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT year, production, 
              nth_value(production, 3) OVER (ORDER BY year)  
       FROM  t_oil 
       WHERE  country = 'Canada';</strong></span>
<span class="strong"><strong> year  | production | nth_value 
-------+------------+----------- 
 1965  |        920 | 
 1966  |       1012 | 
 1967  |       1106 |     1106 
 1968  |       1194 |     1106 
 ...</strong></span></pre><p>In this, the third value will be put into the last column. However, note that the first two rows are empty. The trouble is that <span>when</span><a id="id326281082" class="indexterm"></a> PostgreSQL starts <span>going</span><a id="id326281091" class="indexterm"></a> through the data, the third value is not known yet. Therefore, <code class="literal">null</code> is added. The question now is, how can we make the time <span>series</span><a id="id326281102" class="indexterm"></a> more complete and replace those two null values with the data to come?</p><p>Here is one way to do it:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT *, min(nth_value) OVER () 
FROM  ( 
         SELECT year, production, 
                nth_value(production, 3) OVER (ORDER BY year)  
         FROM  t_oil 
         WHERE  country = 'Canada' 
        ) AS x 
LIMIT  4;</strong></span>
<span class="strong"><strong> year  | production | nth_value | min 
-------+------------+-----------+------ 
 1965  |        920 |           | 1106 
 1966  |       1012 |           | 1106 
 1967  |       1106 |     1106  | 1106 
 1968  |       1194 |     1106  | 1106  
(4 rows)</strong></span></pre><p>The <code class="literal">sub-select</code> will create the incomplete time series. The <code class="literal">SELECT</code> clause on top of that will complete the data. The clue here is that <span>completing</span><a id="id326281132" class="indexterm"></a> the <span>data</span><a id="id326281141" class="indexterm"></a> might be <span>more</span><a id="id326281150" class="indexterm"></a> complex, and therefore a <code class="literal">sub-select</code> might create a couple of opportunities to add more complex logic than just doing it in one step.</p><p>Â </p><p>Â </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec22"></a>The row_number() function</h4></div></div></div><p>The last function <span>discussed</span><a id="id326281175" class="indexterm"></a> in this section is the <code class="literal">row_number()</code> function, which can simply be used to return a virtual ID. Sounds simple? Here it is:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT country, production, 
              row_number() OVER (ORDER BY production) 
       FROM   t_oil 
       LIMIT 3;</strong></span>
<span class="strong"><strong> country | production | row_number 
---------+------------+------------ </strong></span>
<span class="strong"><strong> Yemen   |         10 |         1</strong></span>
<span class="strong"><strong> Syria   |         21 |         2</strong></span>
<span class="strong"><strong> Yemen   |         26 |         3</strong></span><span class="strong"><strong>
(3 rows)</strong></span></pre><p>The <code class="literal">row_number()</code> function simply assigns a number to the row. There are definitely no duplicates.</p><p>The interesting point here is that this can be done even without an order (in case it is not relevant to you):</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT country, production, 
              row_number() OVER() 
       FROM   t_oil 
       LIMIT 3;</strong></span>
<span class="strong"><strong> country | production | row_number</strong></span>
<span class="strong"><strong>---------+------------+------------</strong></span>
<span class="strong"><strong> USA     |       9014 |         1</strong></span>
<span class="strong"><strong> USA     |       9579 |         2</strong></span>
<span class="strong"><strong> USA     |      10219 |         3</strong></span>
<span class="strong"><strong>(3</strong></span><span class="strong"><strong> rows)</strong></span></pre></div></div></div>