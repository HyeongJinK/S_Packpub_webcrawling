<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Observing deadlocks and similar issues</h2></div></div><hr /></div><p>Deadlocks are an <span>important</span><a id="id326538896" class="indexterm"></a> issue and can <span>happen</span><a id="id326538846" class="indexterm"></a> in every database I am aware of. Basically, a deadlock will happen if two transactions have to wait on each other.</p><p>In this section, you will see how this can happen. Let's suppose we have a table containing two rows:</p><pre class="programlisting"><span class="strong"><strong>CREATE TABLE t_deadlock (id int);
INSERT INTO t_deadlock VALUES (1), (2);</strong></span></pre><p>The following example shows what can happen:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">UPDATE t_deadlock</code></p><p><code class="literal">SET id = id * 10</code></p><p><code class="literal">WHERE id = 1;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">UPDATE t_deadlock</code></p><p><code class="literal">SET id = id * 10</code></p><p><code class="literal">WHERE id = 2;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">UPDATE t_deadlock</code></p><p><code class="literal">SET id = id * 10</code></p><p><code class="literal">WHERE id = 2;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Waiting on transaction <code class="literal">2</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">UPDATE t_deadlock</code></p><p><code class="literal">SET id = id * 10</code></p><p><code class="literal">WHERE id = 1;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Waiting on transaction <code class="literal">2</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Waiting on transaction <code class="literal">1</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">Deadlock will be resolved after one second</code></p><p><code class="literal">(deadlock_timeout)</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">COMMIT;</code></p></td><td style=""><p><code class="literal">ROLLBACK;</code></p></td></tr></tbody></table></div><p> </p><p>As soon as the deadlock is detected, the <span>following</span><a id="id325664412" class="indexterm"></a> error message will show up:</p><pre class="programlisting"><span class="strong"><strong>ERROR: deadlock detected</strong></span>
<span class="strong"><strong>DETAIL: Process 91521 waits for </strong></span><span class="strong"><strong>ShareLock on transaction 903; 
</strong></span><span class="strong"><strong>   blocked by process 77185.</strong></span>
<span class="strong"><strong>Process 77185 waits for ShareLock on transaction 905;</strong></span>
<span class="strong"><strong>blocked by process 91521.</strong></span>
<span class="strong"><strong>HINT: See server log for query details.</strong></span>
<span class="strong"><strong>CONTEXT: while updating tuple (0,1) in relation "t_deadlock"</strong></span></pre><p>PostgreSQL is even kind enough to tell us which row has caused the conflict. In my example, the root of all evil is a tuple <code class="literal">(0, 1)</code>. What you can see here is <code class="literal">ctid</code>, which is a unique identifier of a row in a table. It tells us about the physical position of a row inside the table. In this example, it is the first row in the first block (<code class="literal">0</code>).</p><p> </p><p> </p><p>It is even possible to query this row if it is still visible to your transaction. Here is how it works:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT ctid, * FROM t_deadlock WHERE ctid = '(0,  3)'; </strong></span>
<span class="strong"><strong>ctid   | id</strong></span>
<span class="strong"><strong>-------+----- 
(0,1)  |  10</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>Keep in mind that this query might not return a row if it has already been deleted or modified.</p><p>However, it isn't only the case that deadlocks can lead to potentially failing transactions. It can also happen that transactions are not serialized for various reasons. The <span>following</span><a id="id325861485" class="indexterm"></a> example shows what can happen. To make the example work, I assume that you've still got two rows, <code class="literal">id = 1</code> and <code class="literal">id = 2</code>:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN ISOLATION LEVEL REPEATABLE READ;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT * FROM t_deadlock;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Two rows will be returned</p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">DELETE FROM t_deadlock;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT * FROM t_deadlock;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Two rows will be returned</p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">DELETE FROM t_deadlock;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The transaction will error-out</p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">ROLLBACK; - we cannot COMMIT anymore</code></p></td><td style=""><p></p></td></tr></tbody></table></div><p> </p><p>In this example, two concurrent transactions are at work. As long as transaction 1 is just selecting data, everything is fine because PostgreSQL can easily preserve the illusion of static data. But what happens if the second transaction commits a <code class="literal">DELETE</code> command? As long as there are only reads, there is still no problem. The trouble begins when transaction 1 tries to delete or modify data, which is at this point already really dead. The only solution here for PostgreSQL is to error out due to a conflict caused by our transactions:</p><pre class="programlisting"><span class="strong"><strong>test=# DELETE FROM t_deadlock;</strong></span>
<span class="strong"><strong>ERROR: could not serialize access due to concurrent update</strong></span></pre><p>Practically, this means that end users have to be <span>prepared</span><a id="id326537609" class="indexterm"></a> to handle erroneous transactions. If something goes wrong, properly written applications must be able to try again.</p></div>