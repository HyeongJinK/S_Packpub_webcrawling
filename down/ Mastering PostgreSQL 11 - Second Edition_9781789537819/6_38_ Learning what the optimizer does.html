<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec41"></a>Learning what the optimizer does</h2></div></div><hr /></div><p>Before even attempting to <span>think</span><a id="id325631736" class="indexterm"></a> about query performance, it makes sense to familiarize yourself with what the query optimizer does. Having a deeper understanding of what is going on under the hood makes a lot of sense because it helps you see what the database is really up to and what it is doing.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec59"></a>Optimizations by example</h3></div></div></div><p>To demonstrate how the <span>optimizer</span><a id="id326536164" class="indexterm"></a> works, I have compiled an example. It is something that has been used by me over the years for PostgreSQL training. Let's assume that there are three tables, as follows:</p><pre class="programlisting"><span class="strong"><strong>CREATE TABLE a (aid int, ...);         -- 100 million rows</strong></span><span class="strong"><strong>CREATE TABLE b (bid int, ...);         -- 200 million rows </strong></span><span class="strong"><strong>CREATE TABLE c (cid int, ...);         -- 300 million rows</strong></span></pre><p>Let's further assume that those tables contain millions, or maybe hundreds of millions, of rows. In addition to that, there are indexes:</p><pre class="programlisting"><span class="strong"><strong>CREATE INDEX idx_a ON a (aid); 
CREATE INDEX idx_b ON b (bid); 
CREATE INDEX idx_c ON c (cid);
CREATE VIEW v AS SELECT * 
         FROM a, b
         WHERE aid = bid;</strong></span></pre><p>Finally, there is a view joining the first two tables together.</p><p>Let's suppose now that the end user wants to run the following query. What will the optimizer do with this query? What choices does the planner have?</p><pre class="programlisting"><span class="strong"><strong>SELECT </strong></span><span class="strong"><strong>* 
FROM  v, c</strong></span>
<span class="strong"><strong>WHERE v.aid = c.cid</strong></span>
<span class="strong"><strong>      AND cid = 4;</strong></span></pre><p>Before looking at the real <span>optimization</span><a id="id325939945" class="indexterm"></a> process, we will focus on some of the options that the planner has.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec37"></a>Evaluating join options</h4></div></div></div><p>The planner has a <span>couple</span><a id="id325939960" class="indexterm"></a> of options here, so let's take <span>this</span><a id="id325939969" class="indexterm"></a> opportunity to understand what can go wrong if trivial approaches are used.</p><p>Suppose the planner just steams ahead and calculates the output of the view. What is the best way to join 100 million  rows with 200 million rows?</p><p>In this section, a couple of (not all) join options will be discussed to show you what PostgreSQL is able to do.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch06lvl4sec1"></a>Nested loops</h5></div></div></div><p>One way to join two <span>tables</span><a id="id325946717" class="indexterm"></a> is to use a nested loop. The <span>principle</span><a id="id325946726" class="indexterm"></a> is simple. Here is some pseudo code:</p><pre class="programlisting"><span class="strong"><strong>for x in table1: </strong></span>
<span class="strong"><strong>   for y in table2: </strong></span>
<span class="strong"><strong>         if x.field == y.field </strong></span>
<span class="strong"><strong>               issue row </strong></span>
<span class="strong"><strong>         else </strong></span>
<span class="strong"><strong>               keep doing</strong></span></pre><p>Nested loops are often used if one of the sides is very small and contains only a limited set of data. In our example, a nested loop would lead to 100 million x 200 million iterations through the code. This is clearly not an option because the runtime would simply explode.</p><p>A nested loop is generally <span class="emphasis"><em>O(n2),</em></span> so it is only efficient if one side of the join is very small. In this example, this is not the case, so a nested loop can be ruled out to calculate the view.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch06lvl4sec2"></a>Hash joins</h5></div></div></div><p>The second option is a <span>hash</span><a id="id325946774" class="indexterm"></a> join. The <span>following</span><a id="id325955385" class="indexterm"></a> strategy could be applied to solve our little problem. The following listing will show, how a hash join works:</p><pre class="programlisting"><span class="strong"><strong>Hash join</strong></span>
<span class="strong"><strong></strong></span><span class="strong"><strong>Sequential</strong></span><span class="strong"><strong>scan table 1</strong></span>
<span class="strong"><strong></strong></span><span class="strong"><strong>Sequential</strong></span><span class="strong"><strong>scan table 2</strong></span></pre><p>Both sides can be hashed and the hash keys could be compared, leaving us with the result of the join. The trouble here is that all of the values have to be hashed and stored somewhere.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch06lvl4sec3"></a>Merge joins</h5></div></div></div><p>Finally, there is a merge join. The idea here is to use sorted lists to join the results. If both sides of the join are sorted, the system <span>can</span><a id="id325955426" class="indexterm"></a> just take rows <span>from</span><a id="id325955434" class="indexterm"></a> the top and see if they match and return them. The main requirement here is that the lists are sorted. Here is a sample plan:</p><pre class="programlisting"><span class="strong"><strong>Merge join </strong></span>
<span class="strong"><strong>  Sort table 1 </strong></span>
<span class="strong"><strong>     Sequential scan table 1 </strong></span>
<span class="strong"><strong>  Sort table 2 </strong></span>
<span class="strong"><strong>     Sequential scan table 2</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>To join these two tables tables (table 1 and table 2), data has to be provided in a sorted order. In many cases, PostgreSQL will just sort the data. However, there are other options to provide the join with sorted data. One way is to consult an index, as shown in the following example:</p><pre class="programlisting"><span class="strong"><strong>Merge join</strong></span>
<span class="strong"><strong></strong></span><span class="strong"><strong>Index scan table 1
    Index scan table 2
</strong></span></pre><p>One side of the join or both sides can use sorted data coming from lower levels of the plan. If the table is accessed directly, an index is the obvious choice to do that, but only if the returned result set is significantly smaller than the entire table. Otherwise, we encounter almost double the overhead because first we have to read the entire index, then the entire table. If the result set is a large portion of the table, a sequential scan is more efficient, especially if it is being accessed in the primary key order.</p><p>The beauty of a merge join is that it can handle a lot of data. The downside is that data has to be sorted or taken from an index at some point.</p><p>Sorting is <span class="emphasis"><em>O(n * log(n))</em></span>. Therefore, sorting 300 million rows to <span>perform</span><a id="id325958883" class="indexterm"></a> the <span>join</span><a id="id325958889" class="indexterm"></a> is not attractive either.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note43"></a>Note</h3><p>Note that since the introduction of PostgreSQL 10.0, all join options described here are also available in a parallel version. The optimizer will therefore not just consider those standard join options, but also evaluate whether it makes sense to do parallel queries or not.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec38"></a>Applying transformations</h4></div></div></div><p>Obviously, doing the obvious thing (joining the view first) makes no sense at all. A nested loop would send the execution time through the roof. A hash join has to hash <span>millions</span><a id="id325968024" class="indexterm"></a> of rows, and a nested loop has to sort 300 million rows. All three options are <span>clearly</span><a id="id325968033" class="indexterm"></a> unsuitable here. The way out is to apply logical transformations to make the query fast. In this section, you will learn what the planner does to speed up the query. A couple of steps will be performed.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch06lvl4sec4"></a>Inlining the view</h5></div></div></div><p>The first <span>transformation</span><a id="id325968048" class="indexterm"></a> done by the optimizer is to inline views. Here is what happens:</p><pre class="programlisting"><span class="strong"><strong>SELECT * 
</strong></span><span class="strong"><strong>FROM 
(
   SELECT * 
</strong></span><span class="strong"><strong>   FROM a, b 
</strong></span><span class="strong"><strong>   WHERE aid = bid
</strong></span><span class="strong"><strong>) AS v, c 
</strong></span><span class="strong"><strong>WHERE v.aid = c.cid 
</strong></span><span class="strong"><strong>      AND cid = 4;</strong></span></pre><p>The view is inlined and transformed to a subselect. What does this one buy us? Actually, nothing. All it does is open the door for further optimization, which will really be a game changer for this query.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch06lvl4sec5"></a>Flattening subselects</h5></div></div></div><p>The next thing is to <span>flatten</span><a id="id325971778" class="indexterm"></a> subselects, which means integrating them into the main query. By getting rid of subselects, a couple more options to optimize the query will appear.</p><p>Here is what the query will look such as after flattening the subselects:</p><pre class="programlisting"><span class="strong"><strong>SELECT * </strong></span><span class="strong"><strong>FROM a, b, c </strong></span><span class="strong"><strong>WHERE a.aid = c.cid </strong></span><span class="strong"><strong>AND aid = bid </strong></span><span class="strong"><strong>AND cid = 4;</strong></span></pre><p>It is now a normal join.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note44"></a>Note</h3><p>We could have rewritten this SQL on our own, but the planner will take care of those transformations for us anyway. The optimizer can now perform further optimizations.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec39"></a>Applying equality constraints</h4></div></div></div><p>The following <span>process</span><a id="id325971821" class="indexterm"></a> creates <span>equality</span><a id="id325971830" class="indexterm"></a> constraints. The idea is to detect additional constraints, join options, and filters. Let's take a deep breath and take a look at the following query: if <code class="literal">aid = cid</code> and <code class="literal">aid = bid</code>, we know that <code class="literal">bid = cid</code>. If <code class="literal">cid = 4</code> and all the others are equal, we know that <code class="literal">aid</code> and <code class="literal">bid</code> have to be <code class="literal">4</code> as well, which leads us to the following query:</p><pre class="programlisting"><span class="strong"><strong>SELECT * </strong></span>
<span class="strong"><strong>FROM a, b, c </strong></span>
<span class="strong"><strong>WHERE a.aid = c.cid </strong></span>
<span class="strong"><strong>        AND aid = bid </strong></span>
<span class="strong"><strong>        AND cid = 4 </strong></span>
<span class="strong"><strong>        AND bid = cid </strong></span>
<span class="strong"><strong>        AND aid = 4 </strong></span>
<span class="strong"><strong>        AND bid = 4</strong></span></pre><p> </p><p> </p><p> </p><p>The importance of this optimization cannot be stressed enough. What the planner did here was open the door for two additional indexes that were not clearly visible in the original query.</p><p>By being able to use indexes on all three columns, the query is now a lot cheaper.  The optimizer has the option to just retrieve a couple of rows from the index and use whatever join option makes sense.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec40"></a>Exhaustive searching</h4></div></div></div><p>Now that those formal transformations <span>have</span><a id="id325979838" class="indexterm"></a> been done, PostgreSQL will perform an exhaustive search. It will try out all possible plans and come up with the cheapest solution to your query. PostgreSQL knows which indexes are possible and just uses the cost model to determine how to do things in the best way possible.</p><p>During an exhaustive search, PostgreSQL will also try to determine the best join order. In the original query, the join order was fixed to <span class="emphasis"><em>A → B</em></span> and <span class="emphasis"><em>A → C</em></span>. However, using those <span>equality</span><a id="id325979853" class="indexterm"></a> constraints, we could join <span class="emphasis"><em>B → C</em></span> and join A later. All options are open to the planner.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec41"></a>Trying it all out</h4></div></div></div><p>Now that all those <span>optimizations</span><a id="id325979872" class="indexterm"></a> have been discussed, it is time to see what kind of execution plan is produced by PostgreSQL:</p><pre class="programlisting"><span class="strong"><strong>test=# explain SELECT * FROM v, c WHERE v.aid = c.cid AND cid = 4; 
                          QUERY PLAN 
---------------------------------------------------------------- 
 Nested Loop (cost=1.71..17.78 rows=1 width=12) 
   -&gt; Nested Loop (cost=1.14..9.18 rows=1 width=8) 
         -&gt; Index Only Scan using idx_a on a 
               (cost=0.57..4.58 rows=1 width=4) 
               Index Cond: (aid = 4) 
         -&gt; Index Only Scan using idx_b on b 
               (cost=0.57..4.59 rows=1 width=4) 
               Index Cond: (bid = 4) 
   -&gt; Index Only Scan using idx_c on c 
               (cost=0.57..8.59 rows=1 width=4) 
         Index Cond: (cid = 4) 
(8 rows) 
</strong></span></pre><p></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note45"></a>Note</h3><p>Note that the plans shown in this chapter are not necessarily 100% identical to what you will observe. Depending on how much data you have loaded, there might be slight variations. Costs might also depend on the physical alignment of data on the disk (order on disk). Please keep this in mind when running these examples.</p></div><p>As you can see, PostgreSQL will use three indexes. It is also interesting to see that PostgreSQL decides to go for a nested loop to join the data. This makes perfect sense because there is virtually no data coming back from the index scans. Therefore, using a loop to join things is perfectly feasible and highly efficient.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec42"></a>Making the process fail</h4></div></div></div><p>So far, you have seen what <span>PostgreSQL</span><a id="id325979902" class="indexterm"></a> can do for you and how the optimizer helps to speed up queries. PostgreSQL is pretty smart, but it needs smart users. There are some cases in which the end user cripples the entire optimization process by doing stupid things. Let's drop the view by using the following command:</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>DROP VIEW v; 
DROP VIEW</strong></span></pre><p>Now, the view has been recreated. Note that <code class="literal">OFFSET 0</code> has been added to the end of the view. Let us take a look at the following example:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>VIEW v AS SELECT *</strong></span>
<span class="strong"><strong>          FROM  a, b</strong></span>
<span class="strong"><strong>          WHERE aid = bid</strong></span>
<span class="strong"><strong>          OFFSET 0;
CREATE VIEW</strong></span></pre><p>While this view is logically equivalent to the example shown previously, the optimizer has to treat things differently. Every <code class="literal">OFFSET</code> other than <code class="literal">0</code> will change the result and therefore the view has to be calculated. The entire optimization process is crippled by adding things such as <code class="literal">OFFSET</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip46"></a>Note</h3><p>The PostgreSQL community did not dare to optimize this case of having an <code class="literal">OFFSET 0</code> in a view. People are simply not supposed to do that. We will use this just as an example to observe how some operations can cripple performance and that we, as developers, should be aware of the underlying optimization process. However, if you happen to know how PostgreSQL works, this trick can be used as optimization.</p></div><p> </p><p>Here is the new plan:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT </strong></span><span class="strong"><strong>* FROM v, c </strong></span><span class="strong"><strong>WHERE v.aid = c.cid </strong></span><span class="strong"><strong>AND cid = 4;</strong></span>
<span class="strong"><strong>                          QUERY PLAN </strong></span>
<span class="strong"><strong>---------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Nested Loop (cost=120.71..7949879.40 rows=1 width=12) </strong></span>
<span class="strong"><strong>   -&gt; Subquery Scan on v </strong></span>
<span class="strong"><strong>               (cost=120.13..7949874.80 rows=1 width=8) </strong></span>
<span class="strong"><strong>         Filter: (v.aid = 4) </strong></span>
<span class="strong"><strong>         -&gt; Merge Join (cost=120.13..6699874.80</strong></span><span class="strong"><strong> rows=100000000 width=8) </strong></span>
<span class="strong"><strong>               Merge Cond: (a.aid = b.bid) </strong></span>
<span class="strong"><strong>               -&gt; Index Only Scan using idx_a on a </strong></span>
<span class="strong"><strong>                     (cost=0.57..2596776.57 rows=100000000</strong></span><span class="strong"><strong></strong></span><span class="strong"><strong>width=4) </strong></span>
<span class="strong"><strong>               -&gt; Index Only Scan using idx_b on b </strong></span>
<span class="strong"><strong>                     (cost=0.57..5193532.33 rows=199999984 </strong></span><span class="strong"><strong>width=4) </strong></span>
<span class="strong"><strong>   -&gt; Index Only Scan using idx_c on c </strong></span>
<span class="strong"><strong>         (cost=0.57..4.59 rows=1 width=4) </strong></span>
<span class="strong"><strong>         Index Cond: (cid = 4) </strong></span>
<span class="strong"><strong>(9 rows)</strong></span></pre><p>Just take a look at the costs predicted by the planner. Costs have skyrocketed from a two-digit number to a staggering one. Clearly, this query is <span>going</span><a id="id325997347" class="indexterm"></a> to provide you with bad performance.</p><p>There are various ways to cripple performance, but it makes sense to keep the optimization process in mind.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec43"></a>Constant folding</h4></div></div></div><p>However, there are many more optimizations in <span>PostgreSQL</span><a id="id325997740" class="indexterm"></a> that take place behind the scenes and that contribute to overall good performance. One of these features is called <span class="strong"><strong>constant folding</strong></span>. The idea is to turn expressions into constants, as <span>shown</span><a id="id325997754" class="indexterm"></a> in the following example:</p><pre class="programlisting"><span class="strong"><strong>test=# explain SELECT </strong></span><span class="strong"><strong>* </strong></span><span class="strong"><strong>FROM a </strong></span><span class="strong"><strong>WHERE aid = 3 + 1;</strong></span>
<span class="strong"><strong>                          QUERY PLAN </strong></span>
<span class="strong"><strong>---------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Index Only Scan using idx_a on a </strong></span>
<span class="strong"><strong>     (cost=0.57..4.58 rows=1 width=4) </strong></span>
<span class="strong"><strong>   Index Cond: (aid = 4) </strong></span>
<span class="strong"><strong>(2 rows)</strong></span></pre><p>As you can see, PostgreSQL will try to look for <code class="literal">4</code>. As <code class="literal">aid</code> is indexed, PostgreSQL will go for an index scan. Note that our table has just one column, so PostgreSQL even figured out that all the data it needs can be found in the index.</p><p> </p><p>What happens if the expression is on the left-hand side?</p><pre class="programlisting"><span class="strong"><strong>test=# explain SELECT </strong></span><span class="strong"><strong>* </strong></span><span class="strong"><strong>FROM a </strong></span><span class="strong"><strong>WHERE aid - 1 = 3;</strong></span>
<span class="strong"><strong>                        QUERY PLAN </strong></span>
<span class="strong"><strong>------------------------------------------------------------ </strong></span>
<span class="strong"><strong> Seq Scan on a (cost=0.00..1942478.48 rows=500000 width=4) </strong></span>
<span class="strong"><strong>   Filter: ((aid - 1) = 3) </strong></span>
<span class="strong"><strong>(2 rows)</strong></span></pre><p>In this case, the index lookup code will fail and PostgreSQL has to go for a sequential scan. Keep in mind that this is a single-core plan. If the size of the table is large or if your PostgreSQL configuration is different, you might see a multi-core plan. For the sake of simplicity, this chapter only contains single-core plans to make reading easier.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec44"></a>Understanding function inlining</h4></div></div></div><p>As already outlined in this section, there are many optimizations that <span>help</span><a id="id325997863" class="indexterm"></a> speed up queries. One of them is called <span class="strong"><strong>function inlining</strong></span>. PostgreSQL is able to inline immutable SQL functions. The main idea is to reduce the number of function calls <span>that</span><a id="id326004090" class="indexterm"></a> have to be made, in order to speed things up.</p><p>Here is an example of a function that can be inlined by the optimizer:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>OR REPLACE FUNCTION ld(int)</strong></span>
<span class="strong"><strong>RETURNS numeric AS</strong></span>
<span class="strong"><strong>$$</strong></span>
<span class="strong"><strong>   SELECT log(2, $1);</strong></span>
<span class="strong"><strong>$$</strong></span>
<span class="strong"><strong>LANGUAGE </strong></span><span class="strong"><strong>'sql' IMMUTABLE;</strong></span>
<span class="strong"><strong>CREATE FUNCTION</strong></span></pre><p>The function will calculate the logarithmus <span>dualis</span> of the input value:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT ld(1024);</strong></span><span class="strong"><strong>
        ld</strong></span>
<span class="strong"><strong>---------------------</strong></span>
<span class="strong"><strong> 10.0000000000000000</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>To demonstrate how things work,we will recreate the table with less content to speed up the index creation:</p><pre class="programlisting"><span class="strong"><strong>test=# TRUNCATE a;</strong></span>
<span class="strong"><strong>TRUNCATE TABLE</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>Then, data can be added again and the index can be applied:</p><pre class="programlisting"><span class="strong"><strong>test=# INSERT </strong></span><span class="strong"><strong>INTO a </strong></span><span class="strong"><strong>SELECT </strong></span><span class="strong"><strong>* FROM generate_series(1, 10000);</strong></span>
<span class="strong"><strong>INSERT </strong></span><span class="strong"><strong>0 10000</strong></span>
<span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>INDEX idx_ld ON a (ld(aid));</strong></span>
<span class="strong"><strong>CREATE INDEX</strong></span></pre><p>As expected, the index created on the function will be used just like any other index. However, let's take a closer look at the indexing condition:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT </strong></span><span class="strong"><strong>* </strong></span><span class="strong"><strong>FROM a </strong></span><span class="strong"><strong>WHERE ld(aid) = 10;</strong></span>
<span class="strong"><strong>                          QUERY PLAN </strong></span>
<span class="strong"><strong>---------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Index Scan using idx_ld on a (cost=0.29..8.30 rows=1 width=4) </strong></span>
<span class="strong"><strong>   Index Cond: (log('2'::numeric, (aid)::numeric) = '10'::numeric) </strong></span>
<span class="strong"><strong>(2 rows)</strong></span></pre><p>The important <span>observation</span><a id="id326004683" class="indexterm"></a> here is that the <span>indexing</span><a id="id326004690" class="indexterm"></a> condition actually looks for the log function instead of the <code class="literal">ld</code> function. The optimizer has completely gotten rid of the function call.</p><p>Logically, this opens the door for the following query:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT </strong></span><span class="strong"><strong>* </strong></span><span class="strong"><strong>FROM a </strong></span><span class="strong"><strong>WHERE log(2, aid) = 10;</strong></span>
<span class="strong"><strong>                            QUERY PLAN </strong></span>
<span class="strong"><strong>----------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Index Scan using idx_ld on a (cost=0.29..8.30 rows=1 width=4) </strong></span>
<span class="strong"><strong>   Index Cond: (log('2'::numeric, (aid)::numeric) = '10'::numeric) </strong></span>
<span class="strong"><strong>(2 rows)</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec45"></a>Join pruning</h4></div></div></div><p>PostgreSQL also provides an optimization called <span class="strong"><strong>join pruning</strong></span>. The idea is to remove joins if they are not needed by the query. This can come in handy if queries are generated by some <span>middleware</span><a id="id326020387" class="indexterm"></a> or some ORM. If a join can be removed, it naturally speeds things up dramatically and <span>leads</span><a id="id326020395" class="indexterm"></a> to less overhead.</p><p>The question now is, how does join pruning work? Here is an example:</p><pre class="programlisting"><span class="strong"><strong>CREATE </strong></span><span class="strong"><strong>TABLE x (</strong></span><span class="strong"><strong>id int, </strong></span><span class="strong"><strong>PRIMARY </strong></span><span class="strong"><strong>KEY (id)</strong></span><span class="strong"><strong>);</strong></span>
<span class="strong"><strong>CREATE </strong></span><span class="strong"><strong>TABLE y (</strong></span><span class="strong"><strong>id int, </strong></span><span class="strong"><strong>PRIMARY </strong></span><span class="strong"><strong>KEY (id)</strong></span><span class="strong"><strong>);</strong></span></pre><p>First of all, two tables are created. Make sure that both sides of the join condition are actually unique. Those constraints will be important in a minute.</p><p> </p><p>Now, we can write a simple query:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT * 
FROM  x LEFT JOIN y ON (x.id = y.id) 
WHERE x.id = 3; 
                                QUERY PLAN                                  
--------------------------------------------------------------------------- 
 Nested Loop Left Join  (cost=0.31..16.36 rows=1 width=8) 
   Join Filter: (x.id = y.id) 
   -&gt;  Index Only Scan using x_pkey on x  
       (cost=0.15..8.17 rows=1 width=4) 
         Index Cond: (id = 3) 
   -&gt;  Index Only Scan using y_pkey on y  
       (cost=0.15..8.17 rows=1 width=4) 
         Index Cond: (id = 3) 
(6 rows)</strong></span></pre><p>As you can see, PostgreSQL will join those tables directly. So far, there are no surprises. However, the following query is slightly modified. Instead of selecting all the columns, it only selects those columns on the left-hand side of the join:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT x.* 
 FROM x LEFT JOIN y ON (x.id = y.id) 
 WHERE x.id = 3; 
                             QUERY PLAN                               
--------------------------------------------------------------------- 
 Index Only Scan using x_pkey on x  (cost=0.15..8.17 rows=1 width=4) 
   Index Cond: (id = 3) 
(2 rows)</strong></span></pre><p>PostgreSQL will go for a direct <span>inside</span><a id="id326025013" class="indexterm"></a> scan and <span>skip</span><a id="id326025021" class="indexterm"></a> the join completely. There are two reasons why this is actually possible and logically correct:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">No columns are selected from the right-hand side of the join; thus, looking those columns up does not buy us anything</li><li style="list-style-type: disc">The right-hand side is unique, which means that the joining cannot increase the number of rows due to duplicates on the right-hand side</li></ul></div><p>If joins can be pruned automatically, it might happen that the queries are a magnitude faster. The beauty here is that the increase in speed can be achieved by just removing columns that might not be needed by the application anyway.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec46"></a>Speedup set operations</h4></div></div></div><p>Set operations allow the results of multiple queries to be <span>combined</span><a id="id326025064" class="indexterm"></a> into a single result set. Set operators include <code class="literal">UNION</code>, <code class="literal">INTERSECT</code>, and <code class="literal">EXCEPT</code>. PostgreSQL <span>implements</span><a id="id326025083" class="indexterm"></a> all of them and offers many important optimizations to speed them up.</p><p>The planner is able to push restrictions down into the set operation, opening the door for fancy indexing and speedups in general. Let's take a look at the following query, which shows us how this works:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT * 
FROM 
(
   SELECT aid AS xid 
   FROM a 
   UNION ALL 
   SELECT bid FROM b
) AS y 
WHERE xid = 3; 
                           QUERY PLAN 
---------------------------------------------------------------- 
 Append (cost=0.29..12.89 rows=2 width=4) 
   -&gt; Index Only Scan using idx_a on a 
         (cost=0.29..8.30 rows=1 width=4) 
         Index Cond: (aid = 3) 
   -&gt; Index Only Scan using idx_b on b 
         (cost=0.57..4.59 rows=1 width=4) 
         Index Cond: (bid = 3) 
(5 rows)
</strong></span></pre><p>What you can see here is that two relations are added to each other. The trouble is that the only restriction is outside the subselect. However, PostgreSQL figures out that the filter can be pushed further down the plan. <code class="literal">xid = 3</code> is therefore attached to <code class="literal">aid</code> and <code class="literal">bid</code>, opening the option to use indexes on both tables. By avoiding the sequential scan on both tables, the query will run a lot faster.</p><p>Note that there is a <span>distinction</span><a id="id326025114" class="indexterm"></a> between the <code class="literal">UNION</code> clause <span>and</span><a id="id326025126" class="indexterm"></a> the <code class="literal">UNION ALL</code> clause. The <code class="literal">UNION ALL</code> clause will just blindly append the data and deliver the results of both tables.</p><p> </p><p>The <code class="literal">UNION</code> clause is different as it will filter out duplicates. The following plan shows how that works:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT * 
 FROM 
 (
    SELECT aid AS xid 
    FROM a 
    UNION SELECT bid 
    FROM b
) AS y 
WHERE xid = 3; 
                               QUERY PLAN 
---------------------------------------------------------------- 
 Unique (cost=12.92..12.93 rows=2 width=4) 
   -&gt; Sort (cost=12.92..12.93 rows=2 width=4) 
         Sort Key: a.aid 
         -&gt; Append (cost=0.29..12.91 rows=2 width=4) 
               -&gt; Index Only Scan using idx_a on a 
                     (cost=0.29..8.30 rows=1 width=4) 
                     Index Cond: (aid = 3) 
               -&gt; Index Only Scan using idx_b on b 
                     (cost=0.57..4.59 rows=1 width=4) 
                     Index Cond: (bid = 3) 
(8 rows) 
</strong></span></pre><p>PostgreSQL has to <span>add</span><a id="id326026797" class="indexterm"></a> a <code class="literal">Sort</code> node on top of the <code class="literal">Append</code> node to <span>ensure</span><a id="id326026812" class="indexterm"></a> that duplicates can be filtered later on.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip47"></a>Note</h3><p>Many developers who are not fully aware of the difference between the <code class="literal">UNION</code> clause and the <code class="literal">UNION ALL</code> clause. They complain about bad performance because they are unaware that PostgreSQL has to filter out duplicates, which is especially painful in the case of large datasets.</p></div></div></div></div>