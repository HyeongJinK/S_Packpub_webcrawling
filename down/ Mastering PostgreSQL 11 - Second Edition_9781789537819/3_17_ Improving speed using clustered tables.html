<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec23"></a>Improving speed using clustered tables</h2></div></div><hr /></div><p>In this section, you will learn about the <span>power</span><a id="id325634088" class="indexterm"></a> of correlation and the power of clustered tables. What is the whole idea? Consider you want to read a whole area of data. This might be a certain time range, some block, IDs, or so on.</p><p>The runtime of such queries will vary depending on the amount of data and the physical arrangement of data on the disk. So, even if you are running queries that return the same number of rows, two systems might not provide the answer within the same time span, as the physical disk layout might make a difference.</p><p>Here is an example:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN (analyze true, buffers true, timing true)    
   SELECT * 
   FROM   t_test 
   WHERE  id &lt; 10000;</strong></span>
<span class="strong"><strong>                       QUERY PLAN</strong></span>
<span class="strong"><strong>----------------------------------------------------------</strong></span></pre><p> </p><p> </p><pre class="programlisting"><span class="strong"><strong>Index Scan using idx_id on t_test 
    (cost=0.43..370.87 rows=10768 width=9) 
    (actual time=0.011..2.897 rows=9999 loops=1) </strong></span>
<span class="strong"><strong>   Index Cond: (id &lt; 10000) </strong></span>
<span class="strong"><strong>   Buffers: shared hit=85 </strong></span>
<span class="strong"><strong> Planning time: 0.078 ms </strong></span>
<span class="strong"><strong> Execution time: 4.081 ms</strong></span>
<span class="strong"><strong>(5 rows)</strong></span></pre><p>As you might remember, the data has been loaded in an organized and sequential way. Data has been added ID after ID, and so it can be expected that the data will be on the disk in a sequential order. This holds true if data is loaded into an empty table using some auto-increment column.</p><p>You have already seen <code class="literal">EXPLAIN</code> in action. In this example, <code class="literal">EXPLAIN</code> (<code class="literal">analyze true</code>, <code class="literal">buffers true</code>, and <code class="literal">timing true</code>) has been utilized. The idea is that analyze will not just show the plan but also execute the query and show us what has happened.</p><p><code class="literal">EXPLAIN</code> analyze is perfect for comparing planner estimates with what really happened. It is the best way to figure out whether the planner was correct or way off. The <code class="literal">buffers true</code> parameter will tell us how many 8 k blocks were touched by the query. In this example, a total of 85 blocks were touched. A shared hit means that data was coming from the PostgreSQL I/O cache (shared buffers). Altogether, it took PostgreSQL around 4 milliseconds to retrieve the data.</p><p>What happens if the data in your table is somewhat random? Will things change?</p><p>To create a table containing the same data but in a random order, you can simply use <code class="literal">ORDER BY random()</code>. It will make sure that the data is indeed <span>shuffled</span><a id="id325607776" class="indexterm"></a> on disk:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE TABLE t_random AS SELECT * FROM t_test ORDER BY random();  
SELECT 4000000</strong></span></pre><p>To ensure a fair comparison, the same column is indexed:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE INDEX idx_random ON t_random (id); 
CREATE INDEX</strong></span></pre><p>To function properly, PostgreSQL will need optimizer statistics. These statistics will tell PostgreSQL how much data there is, how values are distributed, and whether the data is correlated on disk. To speed things up even more, I have added a <code class="literal">VACUUM</code> call. Please note that <code class="literal">VACUUM</code> will be discussed in more depth later in this book:</p><pre class="programlisting"><span class="strong"><strong>test=# VACUUM ANALYZE t_random;  
VACUUM</strong></span></pre><p>Now, let's run the same query as previously:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN (analyze true, buffers true, timing true)  
         SELECT * FROM t_random WHERE id &lt; 10000;</strong></span>
<span class="strong"><strong>                         QUERY PLAN </strong></span>
<span class="strong"><strong>---------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Bitmap Heap Scan on t_random </strong></span>
<span class="strong"><strong>         (cost=203.27..18431.86 rows=10689 width=9) </strong></span>
<span class="strong"><strong>         (actual time=5.087..13.822 rows=9999 loops=1) </strong></span>
<span class="strong"><strong>   Recheck Cond: (id &lt; 10000) </strong></span>
<span class="strong"><strong>   Heap Blocks: exact=8027 </strong></span>
<span class="strong"><strong>   Buffers: shared hit=8057 </strong></span>
<span class="strong"><strong>   -&gt; Bitmap Index Scan on idx_random </strong></span>
<span class="strong"><strong>           (cost=0.00..200.60 rows=10689 width=0) </strong></span>
<span class="strong"><strong>           (actual time=3.558..3.558 rows=9999 loops=1) </strong></span>
<span class="strong"><strong>         Index Cond: (id &lt; 10000) </strong></span>
<span class="strong"><strong>         Buffers: shared hit=30 </strong></span>
<span class="strong"><strong> Planning time: 0.075 ms </strong></span>
<span class="strong"><strong> Execution time: 14.411 ms </strong></span>
<span class="strong"><strong>(9 rows)</strong></span></pre><p>There are a couple of things to observe here. First of all, a staggering total of 8,057 blocks were needed and the runtime has skyrocketed to over 14 milliseconds. The only thing here is that the somewhat rescued performance was the fact that data was served from the memory and not from the disk. Just imagine what it would mean if you had to access the disk 8,057 times just to answer this query. It would be a total disaster because the disk wait would certainly slow things down, dramatically.</p><p>However, there is more to see. You can even see that the plan has changed. PostgreSQL now uses a bitmap scan instead of a normal index scan. This is done to <span>reduce</span><a id="id325664418" class="indexterm"></a> the number of blocks needed in the query to prevent the even worse behavior.</p><p>How does the planner know how data is stored on the disk? <code class="literal">pg_stats</code> is a system view containing all the statistics about the content of the columns. The following query reveals the relevant content:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT tablename, attname, correlation 
       FROM  pg_stats 
       WHERE tablename IN ('t_test', 't_random') 
       ORDER BY 1, 2;</strong></span>
<span class="strong"><strong> tablename  | attname | correlation</strong></span>
<span class="strong"><strong>------------+---------+------------- 
 t_random   | id      | -0.0114944 
 t_random   | name    |   0.493675 
 t_test     | id      |          1 
 t_test     | name    |          1</strong></span>
<span class="strong"><strong>(4 rows)</strong></span></pre><p>You can see that PostgreSQL takes care of every single column. The content of the view is created by a thing called <code class="literal">ANALYZE</code>, which is vital to the performance:</p><pre class="programlisting"><span class="strong"><strong>test=# \h ANALYZE</strong></span>
<span class="strong"><strong>Command: ANALYZE</strong></span>
<span class="strong"><strong>Description: Collect statistics about a database</strong></span>
<span class="strong"><strong>Syntax:</strong></span>
<span class="strong"><strong>ANALYZE [ VERBOSE ] [ table_name [ ( column_name [, ...] ) ] ]</strong></span></pre><p>Usually, <code class="literal">ANALYZE</code> is automatically executed in the background using the auto-vacuum daemon, which will be covered later in this book.</p><p>Back to our query. As you can see, both tables have two columns (<code class="literal">id</code> and <code class="literal">name</code>). In the case of <code class="literal">t_test.id</code>, the correlation is <code class="literal">1</code>, which means that the next value somewhat depends on the previous one. In my example, numbers are simply ascending. The same applies to <code class="literal">t_test.name</code>. First, we have entries containing <code class="literal">hans</code> and then we have entries containing <code class="literal">paul</code>. All identical names are therefore stored together.</p><p>In <code class="literal">t_random</code>, the situation is quite different; a negative correlation means that data is shuffled. You can also see that the correlation for the <code class="literal">name</code> column is around 0.5. In reality, it means that there is usually no straight sequence of identical names in the table, but it rather means that names keep switching all the time when the table is read in the physical order.</p><p>Why does this lead to so many blocks being hit by the query? The answer is relatively simple. If the data we need is not packed together tightly but spread out over the table evenly, more blocks are needed to extract the same amount of information, which in turn <span>leads</span><a id="id326277304" class="indexterm"></a> to worse performance.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec24"></a>Clustering tables</h3></div></div></div><p>In PostgreSQL, there is a <span>command</span><a id="id326277319" class="indexterm"></a> called <code class="literal">CLUSTER</code> that <span>allows</span><a id="id326277331" class="indexterm"></a> us to rewrite a table in the desired order. It is possible to point to an index and store data in the same order as the index:</p><pre class="programlisting"><span class="strong"><strong>test=# \h CLUSTER  
Command: CLUSTER 
Description: cluster a table according to an index 
Syntax: 
CLUSTER [VERBOSE] table_name [ USING index_name ] 
CLUSTER [VERBOSE]</strong></span></pre><p>The <code class="literal">CLUSTER</code> command has been around for many years and serves its purpose well. But, there are some things to consider before blindly running it on a production system:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">CLUSTER</code> command will lock the table while it is running. You cannot insert or modify data while <code class="literal">CLUSTER</code> is running. This might not be acceptable on a production system.</li><li style="list-style-type: disc">Data can only be organized according to one index. You cannot order a table by postal code, name, ID, birthday, and so on, at the same time. It means that <code class="literal">CLUSTER</code> will make sense if there are search criteria, which is used most of the time.</li><li style="list-style-type: disc">Keep in mind that the example outlined in this book is more of a worst-case scenario. In reality, the performance difference between a clustered and a non- clustered table will depend on the workload, the amount of data retrieved, cache hit rates, and a lot more.</li><li style="list-style-type: disc">The clustered state of a table will not be maintained as changes are made to a table during normal operations. Correlation will usually deteriorate as time goes by.</li></ul></div><p>Here is an <span>example</span><a id="id326300004" class="indexterm"></a> of how to <span>run</span><a id="id326300013" class="indexterm"></a> the <code class="literal">CLUSTER</code> command:</p><pre class="programlisting"><span class="strong"><strong>test=# CLUSTER t_random USING idx_random; 
CLUSTER </strong></span></pre><p>Depending on the size of the table, the time needed to cluster will vary.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"></a>Making use of index-only scans</h3></div></div></div><p>So far, you have seen when an <span>index</span><a id="id326300485" class="indexterm"></a> is used and <span>when</span><a id="id326300493" class="indexterm"></a> it is not. In addition to this, bitmap scans have been discussed.</p><p>However, there is more to indexing. The following two examples will only differ slightly, although the performance difference might be fairly large. Here is the first query:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT * FROM t_test WHERE id = 34234;  
                           QUERY PLAN 
---------------------------------------------------------------- 
 Index Scan using idx_id on t_test 
   (cost=0.43..8.45 rows=1 width=9) 
   Index Cond: (id = 34234)
</strong></span></pre><p>There is nothing unusual here. PostgreSQL uses an index to find a single row. What happens if only a single column is selected?</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT id FROM t_test WHERE id = 34234; 
                         QUERY PLAN 
---------------------------------------------------------------- 
 Index Only Scan using idx_id on t_test 
   (cost=0.43..8.45 rows=1 width=4) 
   Index Cond: (id = 34234) 
(2 rows)
</strong></span></pre><p>As you can see, the plan has changed from an index scan to an index-only scan. In our example, the <code class="literal">id</code> column has been indexed, so its content is naturally in the index. There is no need to go to the table in most cases if all the data can already be taken out of the index. Going to the table is (almost) only required if additional fields are queried, which is not the case here. Therefore, the index-only scan will promise significantly better performance than a normal index scan.</p><p>Practically, it can even make sense to include an additional <span>column</span><a id="id326373326" class="indexterm"></a> into an index here and there to enjoy the benefit of this feature. In MS SQL, adding <span>additional</span><a id="id326374073" class="indexterm"></a> columns is <span>known</span><a id="id326510083" class="indexterm"></a> as <span class="strong"><strong>covering indexes</strong></span>. Since PostgreSQL 11 we have the same functionality, which uses the INCLUDE keyword in CREATE INDEX. </p></div></div>