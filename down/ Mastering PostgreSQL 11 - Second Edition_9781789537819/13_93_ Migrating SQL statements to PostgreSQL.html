<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec89"></a>Migrating SQL statements to PostgreSQL</h2></div></div><hr /></div><p>When moving from a database to PostgreSQL, it makes sense to take a look and figure out which database engine provides which kind of functionality. Moving the data and the structure itself is usually fairly easy. However, rewriting SQL might not be. Therefore, I decided to include a section <span>that</span><a id="id326435644" class="indexterm"></a> explicitly focuses on various advanced features of SQL and their availability in today's <span>database</span><a id="id326435632" class="indexterm"></a> engines.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec135"></a>Using lateral joins</h3></div></div></div><p>In SQL, a lateral join can <span>basically</span><a id="id325887814" class="indexterm"></a> be seen as some sort of loop. This allows us to <span>parameterize</span><a id="id325887822" class="indexterm"></a> a join and execute everything inside the <code class="literal">LATERAL</code> clause more than once. Here is a simple example of this:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT * 
   FROM generate_series(1, 4) AS x, 
         LATERAL (SELECT array_agg(y) 
                  FROM generate_series(1, x) AS y 
                 ) AS z; 
 x  | array_agg </strong></span>
<span class="strong"><strong>----+----------- </strong></span>
<span class="strong"><strong> 1  | {1} </strong></span>
<span class="strong"><strong> 2  | {1,2} </strong></span>
<span class="strong"><strong> 3  | {1,2,3} </strong></span>
<span class="strong"><strong> 4  | {1,2,3,4} 
(4 rows)</strong></span></pre><p>The <code class="literal">LATERAL</code> clause will be called for each <code class="literal">x</code>. To the end user, it is basically some sort of loop.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec91"></a>Supporting lateral</h4></div></div></div><p>One important SQL feature is lateral join. The following list shows which engines support <span>lateral</span><a id="id325895933" class="indexterm"></a> join and which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 9.3</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Db2 LUW</strong></span>: Supported since version 9.1 (2005)</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since 12c</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported since 2005 but using a different syntax</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec136"></a>Using grouping sets</h3></div></div></div><p>Grouping sets are very useful if we <span>want</span><a id="id325896126" class="indexterm"></a> to run more than one aggregate at the <span>same</span><a id="id325896135" class="indexterm"></a> time. Using grouping sets can speed up aggregation because we don't have to process the data more than once.</p><p>Here is an example of this:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT x % 2, array_agg(x) </strong></span>
<span class="strong"><strong>         FROM generate_series(1, 4) AS x </strong></span>
<span class="strong"><strong>         GROUP BY ROLLUP (1); </strong></span>
<span class="strong"><strong> ?column? | array_agg </strong></span>
<span class="strong"><strong>----------+----------- </strong></span>
<span class="strong"><strong>        0 | {2,4} </strong></span>
<span class="strong"><strong>        1 | {1,3} </strong></span>
<span class="strong"><strong>          | {2,4,1,3} </strong></span>
<span class="strong"><strong>(3 rows) </strong></span></pre><p>PostgreSQL offers more than just the <code class="literal">ROLLUP</code> clause. The <code class="literal">CUBE</code> and <code class="literal">GROUPING SETS</code> clauses are also supported.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec92"></a>Supporting grouping sets</h4></div></div></div><p>Grouping sets are essential for generating more than <span>just</span><a id="id325951433" class="indexterm"></a> one aggregation in a single query. The following list shows which engines support grouping sets and which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Only the <code class="literal">ROLLUP</code> clause has been supported since 5.1 (incomplete support)</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Only the <code class="literal">ROLLUP</code> clause has been supported since 5.0 (incomplete support)</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 9.5</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Db2 LUW</strong></span>: Supported since at least 1999</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since 9iR1 (around 2000)</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported since 2008</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec137"></a>Using the WITH clause – common table expressions</h3></div></div></div><p>Common table expressions are a <span>nice</span><a id="id325951804" class="indexterm"></a> way to execute things <span>inside</span><a id="id325951813" class="indexterm"></a> an SQL statement, but only once. PostgreSQL will execute all <code class="literal">WITH</code> clauses and allow us to use the results throughout the query.</p><p>Here is a simplified example of this:</p><pre class="programlisting"><span class="strong"><strong>test=# WITH x AS (SELECT avg(id) </strong></span>
<span class="strong"><strong>                  FROM generate_series(1, 10) AS id) </strong></span>
<span class="strong"><strong>   SELECT *, y - (SELECT avg FROM x) AS diff </strong></span>
<span class="strong"><strong>   FROM generate_series(1, 10) AS y </strong></span>
<span class="strong"><strong>   WHERE y &gt; (SELECT avg FROM x); </strong></span>
<span class="strong"><strong> y  | diff </strong></span>
<span class="strong"><strong>----+-------------------- </strong></span>
<span class="strong"><strong>  6 | 0.5000000000000000 </strong></span>
<span class="strong"><strong>  7 | 1.5000000000000000 </strong></span>
<span class="strong"><strong>  8 | 2.5000000000000000 </strong></span>
<span class="strong"><strong>  9 | 3.5000000000000000 </strong></span>
<span class="strong"><strong> 10 | 4.5000000000000000 </strong></span>
<span class="strong"><strong>(5 rows)</strong></span></pre><p>In this example, the <code class="literal">WITH</code> clause's <span class="strong"><strong>common table extension</strong></span> (<span class="strong"><strong>CTE</strong></span>) calculates the average value of the time series generated by the <code class="literal">generate_series</code> function. The resulting <code class="literal">x</code> can be used <span>just</span><a id="id325951906" class="indexterm"></a> like a table—all over the query. In my example, <code class="literal">x</code> is used twice.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec93"></a>Supporting the WITH clause</h4></div></div></div><p>The following list shows which <span>engines</span><a id="id325951922" class="indexterm"></a> support the <code class="literal">WITH</code> clause and which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 8.4</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Supported since 3.8.3</li><li style="list-style-type: disc"><span class="strong"><strong>Db2 LUW</strong></span>: Supported since 8 (year 2000)</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since 9iR2</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported since 2005</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note93"></a>Note</h3><p>Note that in PostgreSQL, a CTE can even support writes (<code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, and <code class="literal">DELETE</code> clauses). There is no other database I am aware of that can actually do that.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec138"></a>Using the WITH RECURSIVE clause</h3></div></div></div><p>The <code class="literal">WITH</code> clause <span>comes</span><a id="id325977771" class="indexterm"></a> in two forms:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Standard CTEs, as <span>shown</span><a id="id325977785" class="indexterm"></a> in the previous section (using the <code class="literal">WITH</code> clause)</li><li style="list-style-type: disc">A method to run recursions in SQL</li></ul></div><p>The simple form of a CTE was already covered in the previous section. In the next section, the recursive version will be covered.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec94"></a>Supporting the WITH RECURSIVE clause</h4></div></div></div><p>The following list shows which <span>engines</span><a id="id325977808" class="indexterm"></a> support the <code class="literal">WITH RECURSIVE</code> clause and which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 8.4</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Supported since 3.8.3</li><li style="list-style-type: disc"><span class="strong"><strong>Db2 LUW</strong></span>: Supported since 7 (2000)</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since 11gR2 (in Oracle, it is usually more common to use the <code class="literal">CONNECT BY</code> clause instead of the <code class="literal">WITH RECURSIVE</code> clause)</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported since 2005</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec139"></a>Using the FILTER clause</h3></div></div></div><p>When looking at the SQL standard itself, you will <span>notice</span><a id="id325981799" class="indexterm"></a> that the <code class="literal">FILTER</code> clause has been around since SQL (2003). However, not many systems <span>actually</span><a id="id325981811" class="indexterm"></a> support this highly useful syntax element.</p><p>Here is an example of this:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT count(*), </strong></span>
<span class="strong"><strong>              count(*) FILTER (WHERE id &lt; 5), </strong></span>
<span class="strong"><strong>              count(*) FILTER (WHERE id &gt; 2) </strong></span>
<span class="strong"><strong>       FROM generate_series(1, 10) AS id; </strong></span>
<span class="strong"><strong> count | count | count </strong></span>
<span class="strong"><strong>-------+-------+------- </strong></span>
<span class="strong"><strong>    10 | 4 | 8 </strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>The <code class="literal">FILTER</code> clause is useful if a condition cannot be used inside a normal <code class="literal">WHERE</code> clause because some other aggregate is in need of the data.</p><p>Before the introduction of the <code class="literal">FILTER</code> clause, the same could be achieved using a more cumbersome syntax:</p><pre class="programlisting"><span class="strong"><strong>SELECT sum(CASE </strong></span><span class="strong"><strong>WHEN .. THEN 1 ELSE 0 END) AS whatever </strong></span><span class="strong"><strong>FROM some_table;</strong></span></pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec95"></a>Supporting the FILTER clause</h4></div></div></div><p>The following list shows which <span>engines</span><a id="id325990084" class="indexterm"></a> support the <code class="literal">FILTER</code> clause and which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 9.4</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Db2</strong></span><span class="strong"><strong>LUW</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Not supported</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec140"></a>Using windowing functions</h3></div></div></div><p>Windowing and analytics have already <span>been</span><a id="id325990488" class="indexterm"></a> discussed <span>extensively</span><a id="id325990497" class="indexterm"></a> in this book. Therefore, we can jump straight into SQL compliance.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec96"></a>Supporting windowing and analytics</h4></div></div></div><p>The following list shows which <span>engines</span><a id="id325990513" class="indexterm"></a> support window functions and which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 8.4</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Db2</strong></span><span class="strong"><strong>LUW</strong></span>: Supported since version 7</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since version 8i</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported since 2005</li></ul></div><p></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note94"></a>Note</h3><p>Some other databases, such as Hive, Impala, Spark, and NuoDB, also support analytics.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec141"></a>Using ordered sets – the WITHIN GROUP clause</h3></div></div></div><p>Ordered sets are <span>fairly</span><a id="id326002901" class="indexterm"></a> new to PostgreSQL. The <span>difference</span><a id="id326002909" class="indexterm"></a> between an ordered set and a normal aggregate is that in the case of an ordered set, the way data is fed to the aggregate <span class="emphasis"><em>does</em></span> make a difference. Suppose you want to find a trend in your data—the order of the data is relevant.</p><p>Here is a simple example of calculating a median value:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT id % 2, </strong></span>
<span class="strong"><strong>         percentile_disc(0.5) WITHIN GROUP (ORDER BY id) </strong></span>
<span class="strong"><strong>   FROM generate_series(1, 123) AS id </strong></span>
<span class="strong"><strong>   GROUP BY 1; </strong></span>
<span class="strong"><strong> ?column? | percentile_disc </strong></span>
<span class="strong"><strong>----------+----------------- </strong></span>
<span class="strong"><strong>        0 | 62 </strong></span>
<span class="strong"><strong>        1 | 61 </strong></span>
<span class="strong"><strong>(2 rows)</strong></span></pre><p>The median can only be determined if there is sorted input.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec97"></a>Supporting the WITHIN GROUP clause</h4></div></div></div><p>The following list shows which <span>engines</span><a id="id326006866" class="indexterm"></a> support windows functions and which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 9.4</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Db2 LUW:</strong></span> Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since version 9iR1</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported, but the query has to be remodeled using the windowing function</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec142"></a>Using the TABLESAMPLE clause</h3></div></div></div><p>Table sampling has long <span>been</span><a id="id326013851" class="indexterm"></a> the real strength of <span>commercial</span><a id="id326013860" class="indexterm"></a> database vendors. Traditional database systems have provided sampling for many years. However, the monopoly has been broken. Since PostgreSQL 9.5, we have also had a solution to the problem of sampling.</p><p>Here's how it works:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE t_test (id int); 
CREATE TABLE 
test=# INSERT INTO t_test 
    SELECT * FROM generate_series(1, 1000000); 
INSERT 0 1000000</strong></span></pre><p>First, a table containing 1 million rows is created. Then, tests can be executed:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT count(*), avg(id) 
</strong></span><span class="strong"><strong>        FROM t_test TABLESAMPLE BERNOULLI (1); 
 count  |     avg </strong></span>
<span class="strong"><strong>--------+--------------------- </strong></span>
<span class="strong"><strong> 9802   |     502453.220873291165 </strong></span>
<span class="strong"><strong>(1 row) 
test=# SELECT count(*), avg(id) 
        FROM t_test TABLESAMPLE BERNOULLI (1); 
 count  |     avg </strong></span>
<span class="strong"><strong>--------+--------------------- </strong></span>
<span class="strong"><strong> 10082  |     497514.321959928586
(1 row)</strong></span></pre><p>In this example, the same test is executed twice. A 1% random sample is used in each case. Both average values are pretty close to 5 million, so the result is pretty good from a statistical point of view.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec98"></a>Supporting TABLESAMPLE clause</h4></div></div></div><p>The following list shows which <span>engines</span><a id="id326132468" class="indexterm"></a> support the <code class="literal">TABLESAMPLE</code> clause and which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 9.5</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Db2 LUW</strong></span>: Supported since version 8.2</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since version 8</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported since 2005</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec143"></a>Using limit/offset</h3></div></div></div><p>Limiting a result in SQL is a <span>somewhat</span><a id="id326132526" class="indexterm"></a> sad story. To <span>make</span><a id="id326139533" class="indexterm"></a> it short, every database does things somewhat differently. Although there is actually a SQL standard on limiting results, not everybody fully supports the way things are supposed to be. The correct way to limit data is to actually use the following syntax:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT </strong></span><span class="strong"><strong>* FROM t_test FETCH FIRST 3 ROWS ONLY; 
</strong></span><span class="strong"><strong> id </strong></span>
<span class="strong"><strong> ---- </strong></span>
<span class="strong"><strong>   1 </strong></span>
<span class="strong"><strong>   2 </strong></span>
<span class="strong"><strong>   3 </strong></span>
<span class="strong"><strong>(3 rows)</strong></span></pre><p>If you have never seen this syntax before, don't worry. You are definitely not alone.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec99"></a>Supporting the FETCH FIRST clause</h4></div></div></div><p>The following list shows which <span>engines</span><a id="id326139585" class="indexterm"></a> support the <code class="literal">FETCH FIRST</code> clause <span>and</span><a id="id326155742" class="indexterm"></a> which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Supported since 5.1 (usually, limit/offset is used)</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Supported since 3.19.3 (usually, limit/offset is used)</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 8.4 (usually, limit/offset is used)</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Supported since version 2.1.0</li><li style="list-style-type: disc"><span class="strong"><strong>Db2 LUW</strong></span>: Supported since version 7</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since version 12c (uses subselects with the <code class="literal">row_num</code> function)</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported since 2012 (traditionally, top-<span class="emphasis"><em>N</em></span> is used)</li></ul></div><p>As you can see, limiting result sets is quite tricky, and when you are porting a commercial database to PostgreSQL, you will most likely be confronted with some proprietary syntax.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec144"></a>Using OFFSET</h3></div></div></div><p>The <code class="literal">OFFSET</code> clause is <span>similar</span><a id="id326155811" class="indexterm"></a> to the <code class="literal">FETCH FIRST</code> clause. It is easy to use, but it has not been widely adopted. It is not as bad as in the <code class="literal">FETCH FIRST</code> clause, but it still <span>tends</span><a id="id326155826" class="indexterm"></a> to be an issue.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec100"></a>Supporting the OFFSET clause</h4></div></div></div><p>The following list shows which engines support the <code class="literal">OFFSET</code> clause <span>and</span><a id="id326155844" class="indexterm"></a> which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Supported since 5.1</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Supported since 4.0.6</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Supported since PostgreSQL 6.5</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Supported since version 2.1.0</li><li style="list-style-type: disc"><span class="strong"><strong>Db2 LUW</strong></span>: Supported since version 11.1</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since version 12c</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported since 2012</li></ul></div><p>As you can see, limiting result sets is quite tricky and, when you are porting a commercial database to PostgreSQL, you will most likely be confronted with some proprietary syntax.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec145"></a>Using temporal tables</h3></div></div></div><p>Temporal tables are provided by <span>some</span><a id="id326214782" class="indexterm"></a> database engines to <span>handle</span><a id="id326214791" class="indexterm"></a> versioning. Unfortunately, there is no such thing as out-of-the-box versioning in PostgreSQL. So, if you are moving from Db2 or Oracle, there is some work ahead of you to port the desired functionality to PostgreSQL. Basically, changing the code a bit on the PostgreSQL side is not hard. However, it does need some manual intervention—it is not a straight copy-and-paste thing anymore.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec101"></a>Supporting temporal tables</h4></div></div></div><p>The following list shows which engines support temporal tables <span>and</span><a id="id326214806" class="indexterm"></a> which don't:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>MariaDB</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>MySQL</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>PostgreSQL</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>SQLite</strong></span>: Not supported</li><li style="list-style-type: disc"><span class="strong"><strong>Db2 LUW</strong></span>: Supported since version 10.1</li><li style="list-style-type: disc"><span class="strong"><strong>Oracle</strong></span>: Supported since version 12cR1</li><li style="list-style-type: disc"><span class="strong"><strong>Microsoft SQL Server</strong></span>: Supported since 2016</li></ul></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec146"></a>Matching patterns in time series</h3></div></div></div><p>The most recent SQL standard that I <span>am</span><a id="id326218549" class="indexterm"></a> aware of (SQL 2016) provides a feature designed to find matches in time series. So far, only Oracle <span>has</span><a id="id326218557" class="indexterm"></a> implemented this functionality into their latest version of the product.</p><p>At this point, no other database vendor has followed them and added similar functionality. If you want to model this state-of-the-art technology in PostgreSQL, you have to work with the windowing function and subselects. Matching time series patterns in Oracle is pretty powerful; there is not just one type of query to achieve this in PostgreSQL.</p></div></div>