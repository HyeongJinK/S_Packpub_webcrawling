<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec31"></a>Introducing grouping sets</h2></div></div><hr /></div><p>Every advanced user of SQL should be <span>familiar</span><a id="id326602988" class="indexterm"></a> with <code class="literal">GROUP BY</code> and <code class="literal">HAVING</code> clauses. But are they also aware of <code class="literal">CUBE</code>, <code class="literal">ROLLUP</code>, and <code class="literal">GROUPING SETS</code>? If not, this chapter is a must-read.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec45"></a>Loading some sample data</h3></div></div></div><p>To make this chapter a pleasant experience for you, we will compile some sample data that has <span>been</span><a id="id326602996" class="indexterm"></a> taken from the BP energy report: <a class="ulink" href="http://www.bp.com/en/global/corporate/energy-economics/statistical-review-of-world-energy.html" target="_blank"><span>http://www.bp.com/en/global/corporate/energy-economics/statistical-review-of-world-energy/downloads.html</span></a>.</p><p>Here is the data <span>structure</span><a id="id326091111" class="indexterm"></a> that will be used:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE TABLE t_oil ( </strong></span>
<span class="strong"><strong>  region      text, </strong></span>
<span class="strong"><strong>  country     text, </strong></span>
<span class="strong"><strong>  year        int, </strong></span>
<span class="strong"><strong>  production  int, </strong></span>
<span class="strong"><strong>  consumption int </strong></span>
<span class="strong"><strong>); </strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span></pre><p>The test data can be downloaded from our website using <code class="literal">curl</code> directly:</p><pre class="programlisting"><span class="strong"><strong>test=# COPY t_oil FROM PROGRAM ' 
  curl https://www.cybertec-postgresql.com/secret/oil_ext.txt ';</strong></span>
<span class="strong"><strong>COPY 644</strong></span></pre><p>As in the previous chapter, we can download the file before importing it. On some operating systems, <code class="literal">curl</code> is not present by default or has not been installed, so downloading the file before might be an easier option for many people.</p><p>There is data for between 1965 and 2010, for 14 nations in two regions of the world:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT region, avg(production) FROM  t_oil GROUP BY region; </strong></span><span class="strong"><strong>
    region     |          avg           
---------------+----------------------- 
 Middle East   | 1992.6036866359447005 
 North America | 4541.3623188405797101 
(2 rows)</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec46"></a>Applying grouping sets</h3></div></div></div><p>The <code class="literal">GROUP BY</code> clause will turn many rows into <span>one</span><a id="id326293268" class="indexterm"></a> row per group. <span>However, if you do reporting in real life, they might also be interested in the overall average.</span> One additional line might be needed.</p><p>Here is how this can be achieved:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT region, avg(production) 
   FROM t_oil 
   GROUP BY ROLLUP (region); </strong></span><span class="strong"><strong>
    region      |          avg           
----------------+----------------------- 
 Middle East    | 1992.6036866359447005 
 North America  | 4541.3623188405797101 
                | 2607.5139860139860140 
(3 rows)</strong></span></pre><p><code class="literal">ROLLUP</code> will inject an additional line, which will <span>contain</span><a id="id326293298" class="indexterm"></a> the overall average. If you do reporting, it is highly likely that a summary line will be needed. Instead of running two queries, PostgreSQL can provide the data by running just a single query. There is also a second thing you might notice here; different versions of PostgreSQL might return data in a different order. The reason for that is, in PostgreSQL 10.0 the way those grouping sets are implemented has improved significantly. Back in 9.6 and before, PostgreSQL had to do a lot of sorting. Starting with version 10.0, it is already possible to use hashing for those operations, which will speed things up dramatically in many cases:</p><pre class="programlisting"><span class="strong"><strong>test=# explain SELECT region, avg(production) 
    FROM t_oil 
    GROUP BY ROLLUP (region); </strong></span><span class="strong"><strong>
                          QUERY PLAN                            
----------------------------------------------------------
 MixedAggregate (cost=0.00..17.31 rows=3 width=44) 
   Hash Key: region 
   Group Key: () 
   -&gt;  Seq Scan on t_oil  (cost=0.00..12.44 rows=644 width=16) 
(4 rows)</strong></span></pre><p>In case we want data to be sorted, and ensure that all versions return the data in exactly the same order, it is necessary to add an <code class="literal">ORDER BY</code> clause to the query.</p><p>Of course, this kind of operation can also be used if you are grouping by more than just one column:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT region, country, avg(production) 
    FROM t_oil   
    WHERE  country IN ('USA', 'Canada', 'Iran', 'Oman') 
    GROUP BY ROLLUP (region, country); </strong></span><span class="strong"><strong>
    region     | country |          avg           
---------------+---------+----------------------- 
 Middle East   | Iran    | 3631.6956521739130435 
 Middle East   | Oman    | 586.4545454545454545 
 Middle East   |         | 2142.9111111111111111 
 North America | Canada  | 2123.2173913043478261 
 North America | USA     | 9141.3478260869565217 
 North America |         | 5632.2826086956521739 
               |         | 3906.7692307692307692  
(7 rows)</strong></span></pre><p>In this example, PostgreSQL will inject three lines into the result set. One line will be injected for the Middle East and one for North America. On top of that, we will get a line for the overall averages. If we are building a web application, the current result is ideal because you can easily build a GUI to drill into the result set by filtering out the null values.</p><p><code class="literal">ROLLUP</code> is suitable when you instantly want to display a result. Personally, I have always used it to display final results to end users. However, if you are doing reporting, they might want to pre-calculate more data to ensure more flexibility. The <code class="literal">CUBE</code> keyword is what you might have been looking for:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT region, country, avg(production) 
  FROM t_oil   
  WHERE country IN ('USA', 'Canada', 'Iran', 'Oman') 
  GROUP BY CUBE (region, country); </strong></span>
<span class="strong"><strong>    region     | country | avg 
---------------+---------+----------------------- 
 Middle East   | Iran    | 3631.6956521739130435 
 Middle East   | Oman    | 586.4545454545454545 
 Middle East   |         | 2142.9111111111111111 
 North America | Canada  | 2123.2173913043478261 
 North America | USA     | 9141.3478260869565217 
 North America |         | 5632.2826086956521739 
               |         | 3906.7692307692307692 
               | Canada  | 2123.2173913043478261 
               | Iran    | 3631.6956521739130435 
               | Oman    |  586.4545454545454545 
               | USA     | 9141.3478260869565217 
(11 rows)</strong></span></pre><p>Note that even more rows have been added to the result. <code class="literal">CUBE</code> will create the same data as <code class="literal">GROUP BY region, country + GROUP BY region + GROUP BY country + the overall average</code>. So, the whole idea is to extract many results and various levels of aggregation at once. The resulting cube contains all possible combinations of groups.</p><p><code class="literal">ROLLUP</code> and <code class="literal">CUBE</code> are really just convenience features on top of the <code class="literal">GROUPING SETS</code> clause. With the <code class="literal">GROUPING SETS</code> clause, you can explicitly list the <span>aggregates</span><a id="id326294064" class="indexterm"></a> you want:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT region, country, avg(production) 
   FROM  t_oil 
   WHERE country IN ('USA', 'Canada', 'Iran', 'Oman') 
   GROUP BY GROUPING SETS ( (), region, country); </strong></span><span class="strong"><strong>
 region         | country |       avg 
----------------+---------+-----------------------  
 Middle East    |         | 2142.9111111111111111 
 North  America |         | 5632.2826086956521739 
                |         | 3906.7692307692307692 
                | Canada  | 2123.2173913043478261 
                | Iran    | 3631.6956521739130435 
                | Oman    |  586.4545454545454545 
                | USA     | 9141.3478260869565217 
(7 rows)</strong></span></pre><p>In this section, I went for three grouping sets: the overall average, <code class="literal">GROUP BY</code> region, and <code class="literal">GROUP BY</code> country. If you want regions and countries combined, use (<code class="literal">region</code>, <code class="literal">country</code>).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl3sec17"></a>Investigating performance</h4></div></div></div><p>Grouping sets is a <span>powerful</span><a id="id326294263" class="indexterm"></a> feature; they help to reduce the number of expensive queries. Internally, PostgreSQL will basically turn to traditional <code class="literal">GroupAggregates</code> to make things work. A <code class="literal">GroupAggregate</code> node requires sorted data, so be prepared, as PostgreSQL might do a lot of temporary sorting using the f<span>ollowing</span>:</p><pre class="programlisting"><span class="strong"><strong>test=# explain SELECT region, country, avg(production) 
   FROM   t_oil 
   WHERE  country IN ('USA', 'Canada', 'Iran', 'Oman') 
   GROUP BY GROUPING SETS ( (), region, country);                                 
                  QUERY PLAN 
--------------------------------------------------------------- 
 GroupAggregate (cost=22.58..32.69 rows=34 width=52) 
   Group Key: region 
   Group Key: () 
   Sort Key: country 
     Group Key: country 
   -&gt; Sort (cost=22.58..23.04 rows=184 width=24) 
         Sort Key: region 
         -&gt; Seq Scan on t_oil 
              (cost=0.00..15.66 rows=184 width=24) 
</strong></span></pre><pre class="programlisting"><span class="strong"><strong>              Filter: (country = ANY 
                 ('{USA,Canada,Iran,Oman}'::text[])) 
(9 rows)
</strong></span></pre><p>In PostgreSQL, hash aggregates are only supported for normal <code class="literal">GROUP BY</code> clauses involving no grouping sets. In PostgreSQL 10.0, the planner <span>already</span><a id="id326300003" class="indexterm"></a> has more options than in PostgreSQL 9.6. Expect grouping sets to be faster in the new version.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec47"></a>Combining grouping sets with the FILTER clause</h3></div></div></div><p>In real-world applications, grouping sets can often be <span>combined</span><a id="id326300019" class="indexterm"></a> with <code class="literal">FILTER</code> clauses. The <span>idea</span><a id="id326300475" class="indexterm"></a> behind the <code class="literal">FILTER</code> clause is to be able to run partial aggregates.</p><p>Here is an example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT region, 
  avg(production) AS all, 
  avg(production) FILTER (WHERE year  &lt; 1990) AS old,  
  avg(production) FILTER (WHERE year  &gt;= 1990) AS new  
FROM t_oil 
GROUP BY ROLLUP (region);</strong></span>
<span class="strong"><strong>    region     | all            | old            | new 
---------------+----------------+----------------+---------------- 
 Middle East   | 1992.603686635 | 1747.325892857 | 2254.233333333 
 North America | 4541.362318840 | 4471.653333333 | 4624.349206349 
               | 2607.513986013 | 2430.685618729 | 2801.183150183 
(3 rows)</strong></span></pre><p>The idea here is that not all columns will use the same data for aggregation. The <code class="literal">FILTER</code> clause allows you to selectively pass data to those aggregates. In this example, the second aggregate will only consider data before 1990, while the third aggregate will take care of more recent data while the first o<span>ne will get all the data.</span></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip27"></a>Note</h3><p>If it is possible to move conditions to a <code class="literal">WHERE</code> clause, it is always more desirable, as less data has to be fetched from the table. <code class="literal">FILTER</code> is only useful if the data left by the <code class="literal">WHERE</code> clause is not needed by each aggregate.</p></div><p><code class="literal">FILTER</code> works for all kinds of aggregates and offers a <span>simple</span><a id="id326373329" class="indexterm"></a> way to pivot your data. Also, <code class="literal">FILTER</code> is faster than mimicking the same <span>behavior</span><a id="id326598349" class="indexterm"></a> with <code class="literal">CASE WHEN ... THEN NULL ... ELSE END</code>. You can <span>find</span><a id="id326598361" class="indexterm"></a> some real performance comparison here: <a class="ulink" href="https://www.cybertec-postgresql.com/en/postgresql-9-4-aggregation-filters-they-do-pay-off/" target="_blank">https://www.cybertec-postgresql.com/en/postgresql-9-4-aggregation-filters-they-do-pay-off/</a>.</p><p> </p></div></div>