<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec44"></a>Enabling and disabling optimizer settings</h2></div></div><hr /></div><p>So far, the most important <span>optimizations</span><a id="id326189400" class="indexterm"></a> performed by the planner have <span>been</span><a id="id325955435" class="indexterm"></a> discussed in detail. PostgreSQL has improved a lot over the years. Still, it can happen that something goes south and users have to convince the planner to do the right thing.</p><p>To modify plans, PostgreSQL offers a couple of runtime variables that will have a significant impact on planning. The idea is to give the end user the chance to make certain types of nodes in the plan more expensive than others. What does that mean in practice? Here is a simple plan:</p><pre class="programlisting"><span class="strong"><strong>test=# explain </strong></span><span class="strong"><strong>SELECT * 
</strong></span><span class="strong"><strong>    FROM generate_series(1, 100) AS a, 
         generate_series(1, 100) AS b 
</strong></span><span class="strong"><strong>    WHERE a = b;</strong></span>
<span class="strong"><strong>                            QUERY PLAN </strong></span>
<span class="strong"><strong>----------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Merge Join (cost=119.66..199.66 rows=5000 width=8) </strong></span>
<span class="strong"><strong>   Merge Cond: (a.a = b.b) </strong></span>
<span class="strong"><strong>   -&gt; Sort (cost=59.83..62.33 rows=1000 width=4) </strong></span>
<span class="strong"><strong>         Sort Key: a.a </strong></span>
<span class="strong"><strong>         -&gt; Function Scan on generate_series a </strong></span>
<span class="strong"><strong>         (cost=0.00..10.00 rows=1000 width=4) </strong></span>
<span class="strong"><strong>   -&gt; Sort (cost=59.83..62.33 rows=1000 width=4) </strong></span>
<span class="strong"><strong>         Sort Key: b.b </strong></span>
<span class="strong"><strong>         -&gt; Function Scan on generate_series b </strong></span>
<span class="strong"><strong>         (cost=0.00..10.00 rows=1000 width=4) </strong></span>
<span class="strong"><strong>(8 rows)</strong></span></pre><p>The plan shows that PostgreSQL reads the data from the function and sorts both results. Then, a merge join is performed.</p><p> </p><p>However, what if a merge join is not the fastest way to run the query? In PostgreSQL, there is no way to put planner hints into comments as you could do in Oracle. Instead, you can ensure that certain operations are simply considered to be expensive. The <code class="literal">SET enable_mergejoin TO off</code> command will simply make merging too expensive:</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>SET enable_mergejoin TO off;</strong></span>
<span class="strong"><strong>SET</strong></span>
<span class="strong"><strong>test=# explain </strong></span><span class="strong"><strong>SELECT * 
</strong></span><span class="strong"><strong>  FROM generate_series(1, 100) AS a, 
       generate_series(1, 100) AS b 
</strong></span><span class="strong"><strong>  WHERE a = b;</strong></span>
<span class="strong"><strong>                          QUERY PLAN </strong></span>
<span class="strong"><strong>----------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Hash Join (cost=22.50..210.00 rows=5000 width=8) </strong></span>
<span class="strong"><strong>   Hash Cond: (a.a = b.b) </strong></span>
<span class="strong"><strong>   -&gt; Function Scan on generate_series a </strong></span>
<span class="strong"><strong>         (cost=0.00..10.00 rows=1000 width=4) </strong></span>
<span class="strong"><strong>   -&gt; Hash (cost=10.00..10.00 rows=1000 width=4) </strong></span>
<span class="strong"><strong>         -&gt; Function Scan on generate_series b </strong></span>
<span class="strong"><strong>         (cost=0.00..10.00 rows=1000 width=4) </strong></span>
<span class="strong"><strong>(5 rows)</strong></span></pre><p>Because <span>merging</span><a id="id325631740" class="indexterm"></a> is too expensive, PostgreSQL decided to try a hash join. As you can see, the costs are a bit higher, but the plan is still taken as <span>merging</span><a id="id325631751" class="indexterm"></a> is not desired anymore.</p><p>What happens if hash joins are turned off as well?</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>SET enable_hashjoin TO off;</strong></span>
<span class="strong"><strong>SET</strong></span>
<span class="strong"><strong>test=# explain </strong></span><span class="strong"><strong>SELECT * 
</strong></span><span class="strong"><strong>  FROM generate_series(1, 100) AS a, 
       generate_series(1, 100) AS b 
</strong></span><span class="strong"><strong>  WHERE a = b;</strong></span>
<span class="strong"><strong>                          QUERY PLAN </strong></span>
<span class="strong"><strong>----------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Nested Loop (cost=0.01..22510.01 rows=5000 width=8) </strong></span>
<span class="strong"><strong>   Join Filter: (a.a = b.b) </strong></span>
<span class="strong"><strong>   -&gt; Function Scan on generate_series a </strong></span>
<span class="strong"><strong>         (cost=0.00..10.00 rows=1000 width=4) </strong></span>
<span class="strong"><strong>   -&gt; Function Scan on generate_series b </strong></span>
<span class="strong"><strong>         (cost=0.00..10.00 rows=1000 width=4) </strong></span>
<span class="strong"><strong>(4 rows)</strong></span></pre><p>PostgreSQL will again try something else and come up with a nested loop. The costs of a nested loop are already staggering, but the planner starts to run out of options.</p><p> </p><p>What happens if nested loops are turned off as well?</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>SET enable_nestloop TO off;</strong></span>
<span class="strong"><strong>SET</strong></span>
<span class="strong"><strong>test=# explain </strong></span><span class="strong"><strong>SELECT * 
</strong></span><span class="strong"><strong>    FROM generate_series(1, 100) AS a, 
         generate_series(1, 100) AS b 
</strong></span><span class="strong"><strong>    WHERE a = b;</strong></span>
<span class="strong"><strong>                            QUERY PLAN </strong></span>
<span class="strong"><strong>----------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Nested Loop (cost=10000000000.00..10000022510.00 </strong></span>
<span class="strong"><strong>               rows=5000 width=8) </strong></span>
<span class="strong"><strong>   Join Filter: (a.a = b.b) </strong></span>
<span class="strong"><strong>   -&gt; Function Scan on generate_series a </strong></span>
<span class="strong"><strong>         (cost=0.00..10.00 rows=1000 width=4) </strong></span>
<span class="strong"><strong>   -&gt; Function Scan on generate_series b </strong></span>
<span class="strong"><strong>         (cost=0.00..10.00 rows=1000 width=4) </strong></span>
<span class="strong"><strong>(4 rows)</strong></span></pre><p>PostgreSQL will still perform a nested loop. The important part here is that off does not really mean off—it just means treat it as a very expensive thing. This is important because otherwise, the query could not be performed.</p><p>What <span>settings</span><a id="id326445188" class="indexterm"></a> influence the planner? The <span>following</span><a id="id326445196" class="indexterm"></a> switches are available:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">enable_bitmapscan = on</code></li><li style="list-style-type: disc"><code class="literal">enable_hashagg = on</code></li><li style="list-style-type: disc"><code class="literal">enable_hashjoin = on</code></li><li style="list-style-type: disc"><code class="literal">enable_indexscan = on</code></li><li style="list-style-type: disc"><code class="literal">enable_indexonlyscan = on</code></li><li style="list-style-type: disc"><code class="literal">enable_material = on</code></li><li style="list-style-type: disc"><code class="literal">enable_mergejoin = on</code></li><li style="list-style-type: disc"><code class="literal">enable_nestloop = on</code></li><li style="list-style-type: disc"><code class="literal">enable_seqscan = on</code></li><li style="list-style-type: disc"><code class="literal">enable_sort = on</code></li><li style="list-style-type: disc"><code class="literal">enable_tidscan = on</code></li></ul></div><p> </p><p>While these settings can definitely be beneficial, let's understand that these tweaks should be handled with care. They should only be used to speed up individual queries and not turn off things globally. Switching off options can turn <span>against</span><a id="id326445285" class="indexterm"></a> you fairly quickly and <span>destroy</span><a id="id326445293" class="indexterm"></a> performance. Therefore, it really makes sense to think twice before changing these parameters.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec65"></a>Understanding genetic query optimization</h3></div></div></div><p>The result of the planning process is key to <span>achieving</span><a id="id326445337" class="indexterm"></a> superior performance. As shown in this chapter, planning is far from trivial and involves various <span>complex</span><a id="id326445346" class="indexterm"></a> calculations. The more the tables are touched by a query, the more complicated planning will become. The more tables there are, the more choices the planner will have. Logically, planning time will increase. At some point, planning will take so long that performing the classical exhaustive search is not feasible anymore. On top of that, the errors made during planning are so great anyway that finding the theoretically best plan does not necessarily lead to the best plan in terms of runtime.</p><p><span class="strong"><strong>Genetic query optimization</strong></span> (<span class="strong"><strong>GEQO</strong></span>) can come to the rescue in such cases. What is <span class="strong"><strong>GEQO</strong></span>? The <span>idea</span><a id="id325622320" class="indexterm"></a> derives inspiration from nature and resembles the natural process of evolution.</p><p>PostgreSQL will approach this problem just like a traveling salesman problem and encode the possible joins as integer strings. For example, <span class="emphasis"><em>4-1-3-2</em></span> means: first, join <span class="emphasis"><em>4</em></span> and <span class="emphasis"><em>1</em></span>, then <span class="emphasis"><em>3</em></span>, and then <span class="emphasis"><em>2</em></span>. The numbers represent the relation's IDs.</p><p>At the beginning, the genetic optimizer will generate a random set of plans. Those plans are then inspected. The bad ones are discarded and new ones are generated based on the genes of the good ones. This way, potentially even better plans are generated. This process can be repeated as often as desired. At the end of the day, we are left with a plan that is expected to be a lot better than just using a random plan. GEQO can be turned on and off by adjusting the <code class="literal">geqo</code> variable as shown in the following lines:</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>SHOW geqo;</strong></span>
<span class="strong"><strong> geqo
</strong></span><span class="strong"><strong>------ 
 on</strong></span>
<span class="strong"><strong>(1 row)</strong></span>
<span class="strong"><strong>
test=# </strong></span><span class="strong"><strong>SET geqo TO off; 
SET</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>By default, the <code class="literal">geqo</code> variable kicks in if a statement exceeds a certain level of complexity, which is controlled by the following variable:</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>SHOW geqo_threshold ;</strong></span>
<span class="strong"><strong> geqo_threshold</strong></span>
<span class="strong"><strong>----------------</strong></span>
<span class="strong"><strong> 12</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>If your queries are so large that you start to reach this threshold, it certainly makes sense to play with this setting to see how plans are changed by the planner if you change those variables.</p><p>As a general rule, however, I would <span>suggest</span><a id="id325628846" class="indexterm"></a> avoiding GEQO as <span>long</span><a id="id325628853" class="indexterm"></a> as we can and try to fix things first by trying to somehow fix the join order by using the <code class="literal">join_collapse_limit</code> variable. Note that every query is different, so it certainly helps to experiment and gain <span>more</span><a id="id325641563" class="indexterm"></a> experience by learning how the planner behaves under different circumstances.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip49"></a>Note</h3><p>If you want to see what a really crazy join is, consider checking out a talk I gave in Madrid at <a class="ulink" href="http://de.slideshare.net/hansjurgenschonig/postgresql-joining-1-million-tables" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>://</span><span>d</span><span>e</span><span>.</span><span>s</span><span>l</span><span>i</span><span>d</span><span>e</span><span>s</span><span>h</span><span>a</span><span>r</span><span>e</span><span>.</span><span>n</span><span>e</span><span>t</span><span>/</span><span>h</span><span>a</span><span>n</span><span>s</span><span>j</span><span>u</span><span>r</span><span>g</span><span>e</span><span>n</span><span>s</span><span>c</span><span>h</span><span>o</span><span>n</span><span>i</span><span>g</span><span>/</span><span>p</span><span>o</span><span>s</span><span>t</span><span>g</span><span>r</span><span>e</span><span>s</span><span>q</span><span>l</span><span>-</span><span>j</span><span>o</span><span>i</span><span>n</span><span>i</span><span>n</span><span>g</span><span>-</span><span>1</span><span>-</span><span>m</span><span>i</span><span>l</span><span>l</span><span>i</span><span>o</span><span>n</span><span>-</span><span>t</span><span>a</span><span>b</span><span>l</span><span>e</span><span>s</span></a>.</p></div></div></div>