<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec71"></a>Upgrading to synchronous replication</h2></div></div><hr /></div><p>So far, asynchronous replication has <span>been</span><a id="id325935229" class="indexterm"></a> covered in reasonable detail. However, asynchronous replication means that a commit on the slave is allowed to happen after the commit on the master. If a master crashes, data that has not made it to the slave yet might be lost even if replication is occurring.</p><p>Synchronous replication is here to solve the problem—if PostgreSQL replicates synchronously, a commit has to be flushed to disk by at least one replica in order to go through on the master. Therefore, synchronous replication basically reduces the odds of data loss substantially.</p><p>In PostgreSQL, configuring synchronous replication is easy. Only two things have to be done:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Adjust the <code class="literal">synchronous_standby_names</code> setting in the <code class="literal">postgresql.conf</code> file on the master</li><li style="list-style-type: disc">Add an <code class="literal">application_name</code> setting to the <code class="literal">primary_conninfo</code> parameter in the <code class="literal">recovery.conf</code> file in the replica</li></ul></div><p>Let's get started with the <code class="literal">postgresql.conf</code> file on the master:</p><pre class="programlisting"><span class="strong"><strong>synchronous_standby_names = '' </strong></span>
<span class="strong"><strong>         # standby servers that provide sync rep </strong></span>
<span class="strong"><strong>         # number of sync standbys and comma-separated </strong></span>
<span class="strong"><strong>         # list of application_name </strong></span>
<span class="strong"><strong>         # from standby(s); '*' = all </strong></span></pre><p>If we put in <code class="literal">'*'</code>, all nodes will be considered synchronous candidates. However, in real-life scenarios, it is more likely that only a couple of nodes will be listed. Here is an example:</p><pre class="programlisting"><span class="strong"><strong>synchronous_standby_names = 'slave1, slave2, slave3'</strong></span></pre><p>Now, we have to change the <code class="literal">recovery.conf</code> file and add <code class="literal">application_name</code>:</p><pre class="programlisting"><span class="strong"><strong>primary_conninfo = '... application_name=slave2'</strong></span></pre><p>The replica will now connect to the master as <code class="literal">slave2</code>. The master will check its configuration and figure out that <code class="literal">slave2</code> is the first one in the list that makes a viable slave. PostgreSQL will, therefore, ensure that a commit on the master will only be successful if the slave <span>confirms</span><a id="id325895974" class="indexterm"></a> that the transaction is there.</p><p>Let's now assume that <code class="literal">slave2</code> goes down for some reason: PostgreSQL will try to turn one of the other two nodes into a synchronous standby. The problem is this: what if there is no other server?</p><p>In this case, PostgreSQL will wait on commit forever if a transaction is supposed to be synchronous. Yes, this is true. PostgreSQL will not continue to commit unless there are at least two viable nodes available. Remember, we have asked PostgreSQL to store data on at least two nodes—if we cannot provide enough hosts at any given point in time, it is our fault. In reality, this means that synchronous replication is best achieved with at least three nodes—one master and two slaves—as there is always a chance that one host is lost.</p><p>Talking about host failures, there is an important thing to note at this point—if a synchronous partner dies while a commit is going in, PostgreSQL will wait for it to return. Alternatively, the synchronous commit can happen with some other potential synchronous partner. The end user might not even notice that the synchronous partners change.</p><p>In some cases, storing data on just two nodes might not be enough: maybe we want to improve safety even more and store data on even more nodes. To achieve that, we can make use of the following syntax in PostgreSQL 9.6 or higher:</p><pre class="programlisting"><span class="strong"><strong>synchronous_standby_names = </strong></span>
<span class="strong"><strong>   '4(slave1, slave2, slave3, slave4, slave5, slave6)'</strong></span></pre><p>In this case, data is supposed to end up on four out of six nodes before the commit is confirmed by the master.</p><p>Of course, this comes with a price tag—keep in mind that speed will go down if we add more and more synchronous replicas. There is no such thing as a free lunch. PostgreSQL provides a couple of ways to keep the performance overhead under control, which we'll discuss in the following section.</p><p>In PostgreSQL 10.0, even more <span>functionality</span><a id="id325565411" class="indexterm"></a> has been added:</p><pre class="programlisting"><span class="strong"><strong>[FIRST] num_sync ( standby_name [, ...] )</strong></span>
<span class="strong"><strong>ANY num_sync ( standby_name [, ...] )</strong></span>
<span class="strong"><strong>standby_name [, ...]</strong></span></pre><p>The <code class="literal">ANY</code> and <code class="literal">FIRST</code> keywords have been introduced. <code class="literal">FIRST</code> allows you to set the priorities of your servers, while <code class="literal">ANY</code> gives PostgreSQL a bit more flexibility when it commits a synchronous transaction.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec110"></a>Adjusting durability</h3></div></div></div><p>In this chapter, we have seen that data is either <span>replicated</span><a id="id325638492" class="indexterm"></a> synchronously or asynchronously. However, this is not a global thing. To ensure good performance, PostgreSQL allows us to configure things in a very flexible way. It is possible to replicate everything synchronously or asynchronously, but in many cases we might want to do things in a more fine-grained way. This is exactly when the <code class="literal">synchronous_commit</code> setting is needed.</p><p>Assuming that synchronous replication, the <code class="literal">application_name</code> setting in the <code class="literal">recovery.conf</code> file, as well as the <code class="literal">synchronous_standby_names</code> setting in the <code class="literal">postgresql.conf</code> file have been configured, the <code class="literal">synchronous_commit</code> setting will offer the following options:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">off</code>: This is basically a asynchronous replication. <code class="literal">WAL</code> won't be flushed to disk on the master instantly and the master won't wait for the slave to write everything to disk. If the master fails, some data might be lost (up to three times—<code class="literal">wal_writer_delay</code>).</li><li style="list-style-type: disc"><code class="literal">local</code>: The transaction log is flushed to disk on commit on the master. However, the master does not wait on the slave (asynchronous replication).</li><li style="list-style-type: disc"><code class="literal">remote_write</code>: The <code class="literal">remote_write</code> setting already makes PostgreSQL replicate synchronously. However, only the master saves data to disk. For the slave, it is enough to send the data to the operating system. The idea is to not wait for the second disk flush to speed things up. It is very unlikely that both storage systems crash at exactly the same time. Therefore, the risk of data loss is close to zero.</li><li style="list-style-type: disc"><code class="literal">on</code>: In this case, a transaction is okay if the master and the slaves have successfully flushed the transaction to disk. The application will not receive a commit unless data is safely stored on two servers (or more, depending on the configuration).</li></ul></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">remote_apply</code>: While <code class="literal">on</code> ensures that data is safely stored on two nodes, it does not guarantee that we can simply load balance right away. The fact that data is flushed on the disk does not ensure that the user can already see the data. For example, if there is a conflict, a slave will halt transaction replay—however, a transaction log is still sent to the slave during a conflict and flushed to disk. In short, it can occur that data is flushed on the slave, even if it is not visible to the end user yet. The <code class="literal">remote_apply</code> option fixes this problem. It ensures that data must be visible on the replica so that the next read request can be safely executed on the slave, which can already see the changes made to the master and expose them to the end user. The <code class="literal">remote_apply</code> option is, of course, the slowest way to <span>replicate</span><a id="id325664443" class="indexterm"></a> data because it requires the slave to already expose the data to the end user.</li></ul></div><p>In PostgreSQL, the <code class="literal">synchronous_commit</code> parameter is not a global value. It can be adjusted on various levels, just like many other settings. We might want to do something as follows:</p><pre class="programlisting"><span class="strong"><strong>test=# ALTER DATABASE test </strong></span><span class="strong"><strong>SET synchronous_commit TO off;</strong></span>
<span class="strong"><strong>ALTER DATABASE</strong></span></pre><p>Sometimes, only a single database should replicate in a certain way. It is also possible to just synchronously replicate if we are connected as a specific user. Last but not least, it is also possible to tell a single transaction how to commit. By adjusting the <code class="literal">synchronous_commit</code> parameter on the fly, it is even possible to control things on a per-transaction level.</p><p>For example, consider the following two scenarios:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Writing to a log table where we might want to use an asynchronous commit because we want to be quick</li><li style="list-style-type: disc">Storing a credit card payment where we want to be safe so a synchronous transaction might be the desired thing</li></ul></div><p>As we can see, the very same database might have different requirements, depending on which data is modified. Therefore, changing data at the <span>transaction</span><a id="id325856182" class="indexterm"></a> level is very useful and helps to improve speed.</p></div></div>