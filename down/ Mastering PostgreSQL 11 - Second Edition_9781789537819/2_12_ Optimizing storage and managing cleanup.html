<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec19"></a>Optimizing storage and managing cleanup</h2></div></div><hr /></div><p>Transactions are an <span>integral</span><a id="id325653149" class="indexterm"></a> part of the PostgreSQL system. However, transactions come with a small price tag attached. As already shown in this chapter, it can happen that concurrent users will be presented with different data. Not everybody will get the same data <span>returned</span><a id="id325653127" class="indexterm"></a> by a query. In addition to this, <code class="literal">DELETE</code> and <code class="literal">UPDATE</code> are not allowed to actually overwrite data as <code class="literal">ROLLBACK</code> would not work. If you happen to be in the middle of a large <code class="literal">DELETE</code> operation, you cannot be sure whether you will be able to <code class="literal">COMMIT</code> or not. In addition to this, data is still visible while you perform <code class="literal">DELETE</code>, and sometimes data is even visible once your modification has long since finished.</p><p>Consequently, this means that cleanup has to happen asynchronously. A transaction cannot clean up its own mess and <code class="literal">COMMIT</code>/<code class="literal">ROLLBACK</code> might be too early to take care of dead rows.</p><p>The solution to this problem is <code class="literal">VACUUM</code>. The following code block provides you with a syntax overview:</p><pre class="programlisting"><span class="strong"><strong>test=# \h VACUUM 
</strong></span><span class="strong"><strong>Command: VACUUM
Description: garbage-collect and optionally analyze a database
Syntax:
VACUUM [ ( { FULL | FREEZE | VERBOSE | ANALYZE } [, ...] ) ] 
       [ table_name [ (column_name [, ...] ) ] ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ table_name ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] 
       ANALYZE [ table_name [ (column_name [, ...] ) ] ]
</strong></span></pre><p><code class="literal">VACUUM</code> will visit all pages that potentially contain modifications and find all the dead space. The free space found is then <span>tracked</span><a id="id325606850" class="indexterm"></a> by <span class="strong"><strong>Free Space Map</strong></span> (<span class="strong"><strong>FSM</strong></span>) of the relation.</p><p>Note that <code class="literal">VACUUM</code> will, in most cases, not shrink the size of a table. Instead, it will track and find free space inside existing storage files.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note15"></a>Note</h3><p>Tables will usually have the same size after <code class="literal">VACUUM</code>. If there are no valid rows at the end of a table, file sizes can go down in some rare cases. This is not the rule but rather the exception.</p></div><p>What this means to end <span>users</span><a id="id326342605" class="indexterm"></a> will be <span>outlined</span><a id="id326342854" class="indexterm"></a> in the <span class="emphasis"><em>Watching VACUUM at work</em></span> section of this chapter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec15"></a>Configuring VACUUM and autovacuum</h3></div></div></div><p>Back in the early <span>days</span><a id="id326343286" class="indexterm"></a> of PostgreSQL projects, people had to run <code class="literal">VACUUM</code> manually. Fortunately, this is long gone. Nowadays, administrators can <span>rely</span><a id="id326343298" class="indexterm"></a> on a <span>tool</span><a id="id326506859" class="indexterm"></a> called <span>autovacuum</span>, which is <span>part</span><a id="id326507350" class="indexterm"></a> of the PostgreSQL Server infrastructure. It automatically takes care of cleanup and works in the background. It wakes up once per minute (see <code class="literal">autovacuum_naptime = 1</code> in <code class="literal">postgresql.conf</code>) and checks whether there is work to do. If there is work, autovacuum will fork up to three worker processes (see <code class="literal">autovacuum_max_workers</code> in <code class="literal">postgresql.conf</code>).</p><p>The main question is when does autovacuum trigger the creation of a worker process?</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note16"></a>Note</h3><p>Actually, the autovacuum process does not fork processes itself. Instead, it tells the main process to do so. This is done to avoid zombie processes in the case of failure and to improve robustness.</p></div><p>The answer to this question can again be found in <code class="literal">postgresql.conf</code>:</p><pre class="programlisting"><span class="strong"><strong>autovacuum_vacuum_threshold = 50  
autovacuum_analyze_threshold = 50  
autovacuum_vacuum_scale_factor = 0.2  
autovacuum_analyze_scale_factor = 0.1</strong></span></pre><p>The <code class="literal">autovacuum_vacuum_scale_factor</code> command tells PostgreSQL that a table is worth vacuuming if 20% of data has been changed. The trouble is that if a table consists of one row, one change is already 100%. It makes absolutely no sense to fork a complete process to clean up just one row. Therefore, <code class="literal">autovacuum_vacuuum_threshold</code> says that we need 20% and this 20% must be at least 50 rows. Otherwise, <code class="literal">VACUUM</code> won't kick in. The same mechanism is used when it comes to optimizer stats creation. We need 10% and at least 50 rows to <span>justify</span><a id="id326507405" class="indexterm"></a> new <span>optimizer</span><a id="id326507414" class="indexterm"></a> stats. Ideally, autovacuum <span>creates</span><a id="id325607737" class="indexterm"></a> new <span>statistics</span><a id="id325607744" class="indexterm"></a> during a normal <code class="literal">VACUUM</code> to avoid unnecessary trips to the table.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec7"></a>Digging into transaction wraparound-related issues</h4></div></div></div><p>There are two more <span>settings</span><a id="id325607762" class="indexterm"></a> in <code class="literal">postgresql.conf</code> that are quite important to understand in order to really make use of PostgreSQL. As I have stated already, understanding <code class="literal">VACUUM</code> is key to performance:</p><pre class="programlisting"><span class="strong"><strong>autovacuum_freeze_max_age = 200000000  
autovacuum_multixact_freeze_max_age = 400000000</strong></span></pre><p>To understand the overall problem, it is important to understand how PostgreSQL handles concurrency. The PostgreSQL transaction machinery is based on the comparison of transaction IDs and the states transactions are in.</p><p>Let's look at an example. If I am transaction ID <code class="literal">4711</code> and if you happen to be <code class="literal">4712</code>, I won't see you because you are still running. If I am transaction ID <code class="literal">4711</code> but you are transaction ID <code class="literal">3900</code>, I will see you. If your transaction has failed, I can safely ignore all rows produced by your failing transaction.</p><p>The trouble is as follows: transaction IDs are finite, not unlimited. At some point, they will start to wrap around. In reality, this means that transaction number 5 might actually be after transaction number 800 million. How does PostgreSQL know what was first? It does so by storing a watermark. At some point, those watermarks will be adjusted, and this is exactly when <code class="literal">VACUUM</code> starts to be relevant. By running <code class="literal">VACUUM</code> (or autovacuum), you can ensure that the watermark is adjusted in a way that there are always enough future transaction IDs left to work with.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>Not every transaction will increase the transaction ID counter. As long as a transaction is still reading, it will only have a virtual transaction ID. This ensures that transaction IDs are not burned too quickly.</p></div><p>The <code class="literal">autovacuum_freeze_max_age</code> command defines the maximum number of transactions (age) that a table's <code class="literal">pg_class.relfrozenxid</code> field can attain before a <code class="literal">VACUUM</code> operation is forced to prevent transaction ID wraparound within the table. This value is fairly low because it also has an impact on clog cleanup (the clog or commit log is a data structure that stores two bits per transaction, which indicate whether a transaction is running, aborted, committed, or still in a subtransaction).</p><p>The <code class="literal">autovacuum_multixact_freeze_max_age</code> command configures the maximum age that a table's <code class="literal">pg_class.relminmxid</code> field can attain before a <code class="literal">VACUUM</code> operation is forced to prevent multixact ID wraparound within the table. Freezing tuples is an important <span>performance</span><a id="id325608318" class="indexterm"></a> issue and there will be more about this process in Chapter 6, <span class="emphasis"><em>Optimizing Queries for Good Performance</em></span>, where we will discuss query optimization.</p><p>In general, trying to reduce the <code class="literal">VACUUM</code> load while maintaining operational security is a good idea. A <code class="literal">VACUUM</code> instance on large tables can be expensive, and therefore keeping an eye on these settings makes perfect sense.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec8"></a>A word on VACUUM FULL</h4></div></div></div><p>Instead of normal <code class="literal">VACUUM</code>, you can also use <code class="literal">VACUUM FULL</code>. However, I really want to point out that <code class="literal">VACUUM FULL</code> actually locks the table and rewrites the <span>entire</span><a id="id325634096" class="indexterm"></a> relation. In the case of a small table, this might not be an issue. However, if your tables are large, the table lock can really kill you in minutes! <code class="literal">VACUUM FULL</code> blocks upcoming writes and therefore some people talking to your database might have the feeling that it is actually down. Hence, a lot of caution is advised.</p><p>To get rid of <code class="literal">VACUUM FULL</code>, I recommend that you <span>check</span><a id="id325634113" class="indexterm"></a> out <code class="literal">pg_squeeze</code> (<a class="ulink" href="https://www.cybertec-postgresql.com/en/introducing-pg_squeeze-a-postgresql-extension-to-auto-rebuild-bloated-tables/" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>://</span><span>w</span><span>w</span><span>w</span><span>.</span><span>c</span><span>y</span><span>b</span><span>e</span><span>r</span><span>t</span><span>e</span><span>c</span><span>.</span><span>a</span><span>t</span><span>/</span><span>i</span><span>n</span><span>t</span><span>r</span><span>o</span><span>d</span><span>u</span><span>c</span><span>i</span><span>n</span><span>g</span><span>-</span><span>p</span><span>g</span><span>_</span><span>s</span><span>q</span><span>u</span><span>e</span><span>e</span><span>z</span><span>e</span><span>-</span><span>a</span><span>-</span><span>p</span><span>o</span><span>s</span><span>t</span><span>g</span><span>r</span><span>e</span><span>s</span><span>q</span><span>l</span><span>-</span><span>e</span><span>x</span><span>t</span><span>e</span><span>n</span><span>s</span><span>i</span><span>o</span><span>n</span><span>-</span><span>t</span><span>o</span><span>-</span><span>a</span><span>u</span><span>t</span><span>o</span><span>-</span><span>r</span><span>e</span><span>b</span><span>u</span><span>i</span><span>l</span><span>d</span><span>-</span><span>b</span><span>l</span><span>o</span><span>a</span><span>t</span><span>e</span><span>d</span><span>-</span><span>t</span><span>a</span><span>b</span><span>l</span><span>e</span><span>s</span><span>/</span></a>), which can rewrite a table without blocking writes.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec16"></a>Watching VACUUM at work</h3></div></div></div><p>After this introduction, it is time to see <code class="literal">VACUUM</code> in action. I have included this section here because my practical work as a PostgreSQL <span>consultant</span><a id="id325653226" class="indexterm"></a> and supporter (<a class="ulink" href="https://www.cybertec-postgresql.com/de/" target="_blank">http://postgresql-support.de/</a>) indicates that most people only have a very vague understanding of what <span>happens</span><a id="id325653479" class="indexterm"></a> on the storage side.</p><p>To stress this point again, in most cases, <code class="literal">VACUUM</code> will not shrink your tables; space is usually not returned to the filesystem.</p><p>Here is my example that shows how to create a small table with customized autovacuum settings. The table is filled with 100,000 rows:</p><pre class="programlisting"><span class="strong"><strong>CREATE TABLE t_test (id int) WITH (autovacuum_enabled = off); 
INSERT INTO t_test 
   SELECT * FROM generate_series(1, 100000);</strong></span></pre><p>The idea is to create a simple table containing 100,000 rows. Note that it is possible to turn autovacuum off for specific tables. Usually, this is not a good idea for most applications. However, there are corner case, where <code class="literal">autovacuum_enabled = off</code> makes sense. Just consider a table whose life cycle is very short. It does not make sense to clean out tuples if the developer already knows that the entire table will be dropped within seconds. In data warehousing, this can be the case if you use tables as staging areas. <code class="literal">VACUUM</code> is turned off in this example to ensure that nothing happens in the background. Everything you see is triggered by me and not by some process.</p><p> </p><p>First of all, consider checking the size the size of the table by using the following command:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT pg_size_pretty(pg_relation_size('t_test')); 
pg_size_pretty</strong></span>
<span class="strong"><strong>----------------</strong></span>
<span class="strong"><strong> 3544 kB</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>The <code class="literal">pg_relation_size</code> command <span>returns</span><a id="id325653849" class="indexterm"></a> the size of a table in bytes. The <code class="literal">pg_size_pretty</code> command will take this number and turn it into something human readable.</p><p>Then, all rows in the table will be updated using as simple <code class="literal">UPDATE</code> statement as shown in the next listing:</p><pre class="programlisting"><span class="strong"><strong>test=# UPDATE t_test SET id = id + 1; </strong></span>
<span class="strong"><strong>UPDATE 100000</strong></span></pre><p>What happens is highly important to understand PostgreSQL. The database engine has to copy all the rows. Why? First of all, we don't know whether the transaction will be successful, so the data cannot be overwritten. The second important aspect is that a concurrent transaction might still be seeing the old version of the data.</p><p>The <code class="literal">UPDATE</code> operation will copy rows.</p><p>Logically, the size of the table will be larger after the change has been made:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT pg_size_pretty(pg_relation_size('t_test'));
 pg_size_pretty </strong></span>
<span class="strong"><strong>----------------</strong></span>
<span class="strong"><strong> 7080 kB</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>After <code class="literal">UPDATE</code>, people might try to return space to the filesystem:</p><pre class="programlisting"><span class="strong"><strong>test=# VACUUM t_test;  
VACUUM</strong></span></pre><p>As stated previously, <code class="literal">VACUUM</code> does not return space to the filesystem in most cases. Instead, it will allow space to be reused. The table, therefore, does not shrink at all:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT pg_size_pretty(pg_relation_size('t_test')); 
 pg_size_pretty </strong></span>
<span class="strong"><strong>----------------</strong></span>
<span class="strong"><strong> 7080 kB</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>However, the next <code class="literal">UPDATE</code> will not <span>make</span><a id="id325887830" class="indexterm"></a> the table grow because it will eat the free space inside the table. Only a second <code class="literal">UPDATE</code> would make the table grow again, because all the space is gone and so additional storage is needed:</p><pre class="programlisting"><span class="strong"><strong>test=# UPDATE t_test SET id = id + 1;  
UPDATE 100000 
test=# SELECT pg_size_pretty(pg_relation_size('t_test')); 
 pg_size_pretty </strong></span>
<span class="strong"><strong>----------------</strong></span>
<span class="strong"><strong> 7080 kB</strong></span>
<span class="strong"><strong>(1 row)

</strong></span><span class="strong"><strong>test=# UPDATE t_test SET id = id + 1;  
UPDATE 100000 
test=# SELECT pg_size_pretty(pg_relation_size('t_test'));
 pg_size_pretty </strong></span>
<span class="strong"><strong>----------------</strong></span>
<span class="strong"><strong> 10 MB</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>If I had to decide on a single thing you should remember after reading this book, this is it. Understanding storage is the key to performance and administration in general.</p><p>Let's run some more queries:</p><pre class="programlisting"><span class="strong"><strong>VACUUM t_test; 
UPDATE t_test SET id = id + 1;  
VACUUM t_test;</strong></span></pre><p>Again the size is unchanged. Let's see what is inside the table:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT ctid, * FROM t_test ORDER BY ctid DESC;
 ctid      | id
-----------+-------- 
...
(1327, 46) | 112
(1327, 45) | 111
(1327, 44) | 110
...
</strong></span><span class="strong"><strong>(884, 20)  | 99798
(884, 19)  | 99797
...</strong></span></pre><p>The <code class="literal">ctid</code> command is the physical <span>position</span><a id="id325895961" class="indexterm"></a> of a row on a disk. Using <code class="literal">ORDER BY ctid DESC</code>, you will basically read the table backward in the physical order. Why should you care? The reason is that there are some very small values and some very big values at the end of the table. The following listing shows how the size of the table changes when data is deleted:</p><pre class="programlisting"><span class="strong"><strong>test=# DELETE FROM t_test 
              WHERE id &gt; 99000 
                    OR id &lt; 1000;  
DELETE 1999 
test=# VACUUM t_test;  
VACUUM 
test=# SELECT pg_size_pretty(pg_relation_size('t_test')); 
 pg_size_pretty</strong></span>
<span class="strong"><strong>----------------</strong></span>
<span class="strong"><strong> 3504 kB</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>Although only 2% of the data has been deleted, the size of the table has gone down by two-thirds. The reason is that if <code class="literal">VACUUM</code> only finds dead rows after a certain position in the table, it can return space to the filesystem. This is the only case in which you will actually see the table size go down. Of course, normal users have no control over the physical position of data on the disk. Therefore, storage consumption will most likely stay somewhat the same unless all rows are deleted.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"></a>Note</h3><p>Why are there so many small and big values at the end of the table anyway? After the table is initially populated with 100,000 rows, the last block is not completely full, so the first <code class="literal">UPDATE</code> will fill up the last block with changes. This naturally shuffles the end of the table a bit. In this carefully crafted example, this is the reason for the strange layout at the end of the table.</p></div><p>In real-world applications, the impact of this <span>observation</span><a id="id325896147" class="indexterm"></a> cannot be stressed enough. There is no performance tuning without really understanding storage.</p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"></a>Limiting transactions by making use of snapshot too old</h3></div></div></div><p><code class="literal">VACUUM</code> does a good job and it will <span>reclaim</span><a id="id325896170" class="indexterm"></a> free space as needed. However, when can <code class="literal">VACUUM</code> actually clean out rows and turn them into free space? The rule is this: if a row cannot be seen by anybody anymore, it can be reclaimed. In reality, this means that <span>everything</span><a id="id325896182" class="indexterm"></a> that is no longer seen even by the oldest active transaction can be considered to be really dead.</p><p>This also implies that really long transactions can postpone cleanup for quite some time. The logical consequence is table bloat. Tables will grow beyond proportion and performance will tend to go downhill. Fortunately, starting with PostgreSQL 9.6, the database has a nice feature that allows the administrator to intelligently limit the duration of a transaction. Oracle administrators will be familiar with the <span class="strong"><strong>snapshot too old error.</strong></span> Since PostgreSQL 9.6, this error message is also available. However, it is more of a feature than an unintended side effect of bad configuration (which it actually is in Oracle).</p><p>To limit the lifetime of snapshots, you can make use of a setting in PostgreSQL's <code class="literal">config</code> file <code class="literal">postgresql.conf</code>, which has all the configuration parameters needed:</p><pre class="programlisting"><span class="strong"><strong>old_snapshot_threshold = -1 
         # 1min-60d; -1 disables; 0 is immediate</strong></span></pre><p>If this variable is set, transactions will fail after a certain amount of time. Note that this setting is on an instance level and it cannot be set inside a session. By limiting the age of a transaction, the risk of insanely long transactions will decrease drastically.</p></div></div>