<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec56"></a>Managing network security</h2></div></div><hr /></div><p>Before moving on to real-world, practical examples, I want to <span>briefly</span><a id="id326645595" class="indexterm"></a> focus on the various layers of security we will be dealing with. When dealing with security, it makes sense to keep those levels in mind in order to approach security-related issues in an organized way.</p><p>Here is my mental model:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Bind addresses</strong></span>:<code class="literal">listen_addresses</code>in the<code class="literal">postgresql.conf</code>file</li><li style="list-style-type: disc"><span class="strong"><strong>Host-based access control</strong></span>: The <code class="literal">pg_hba.conf</code> file</li><li style="list-style-type: disc"><span class="strong"><strong>Instance-level permissions</strong></span>: Users, roles, database creation, login, and replication</li><li style="list-style-type: disc"><span class="strong"><strong>Database-level permissions</strong></span>: Connecting, creating schemas, and so on</li><li style="list-style-type: disc"><span class="strong"><strong>Schema-level permissions</strong></span>: Using schema and creating objects inside a schema</li><li style="list-style-type: disc"><span class="strong"><strong>Table-level permissions</strong></span>: Selecting, inserting, updating, and so on</li><li style="list-style-type: disc"><span class="strong"><strong>Column-level permissions</strong></span>: Allowing or restricting access to columns</li><li style="list-style-type: disc"><span class="strong"><strong>Row-level security</strong></span>: Restricting access to rows</li></ul></div><p>In order to read a value, PostgreSQL has to ensure that we <span>have</span><a id="id326645665" class="indexterm"></a> sufficient permissions on every level. The entire chain of permissions has to be correct.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec85"></a>Understanding bind addresses and connections</h3></div></div></div><p>When configuring a PostgreSQL server, one of the <span>first</span><a id="id326645587" class="indexterm"></a> things that <span>needs</span><a id="id326652242" class="indexterm"></a> to be done is define remote access. By default, PostgreSQL does not accept remote connections. The important thing here is that PostgreSQL does not even reject the connection because it simply does not listen on the port. If we try to connect, the error message will actually come from the <span>operating</span><a id="id325876697" class="indexterm"></a> system <span>because</span><a id="id325876704" class="indexterm"></a> PostgreSQL does not care at all.</p><p>Assuming that there is a database server using the default configuration on <code class="literal">192.168.0.123</code>, the following will happen:</p><pre class="programlisting"><span class="strong"><strong>iMac:~ hs$ telnet 192.168.0.123 5432</strong></span>
<span class="strong"><strong>Trying 192.168.0.123... </strong></span>
<span class="strong"><strong>telnet: connect to address 192.168.0.123: Connection refused 
telnet: Unable to connect to remote host</strong></span></pre><p>Telnet tries to create a connection on port <code class="literal">5432</code> and is instantly rejected by the remote box. From the outside, it looks as if PostgreSQL is not running at all.</p><p>The key to success can be found in the <code class="literal">postgresql.conf</code> file:</p><pre class="programlisting"><span class="strong"><strong># - Connection Settings - </strong></span>

<span class="strong"><strong># listen_addresses = 'localhost' </strong></span>
<span class="strong"><strong>    # what IP address(es) to listen on; </strong></span>
<span class="strong"><strong>    # comma-separated list of addresses; </strong></span>
<span class="strong"><strong>    # defaults to 'localhost'; use '*' for all </strong></span>
<span class="strong"><strong>    # (change requires restart)</strong></span></pre><p>The <code class="literal">listen_addresses</code> setting will tell PostgreSQL which addresses to listen on. Technically speaking, those addresses are bind addresses. What does that actually mean? Suppose we have four network cards in our machine. We can listen on, say, three of those IP addresses. PostgreSQL takes requests to those three cards into account and does not listen on the fourth one. The port is simply closed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip58"></a>Note</h3><p>We have to put our server's IP address into <code class="literal">listen_addresses</code> and not the IPs of the clients.</p></div><p>If we put an <code class="literal">*</code> in, PostgreSQL will listen to every IP assigned to your machine.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip59"></a>Note</h3><p>Keep in mind that changing <code class="literal">listen_addresses</code> requires a PostgreSQL service restart. It cannot be changed on the fly without a restart.</p></div><p>However, there are <span>more</span><a id="id325876803" class="indexterm"></a> settings <span>related</span><a id="id325876812" class="indexterm"></a> to connection <span>management</span><a id="id325876821" class="indexterm"></a> that are <span>highly</span><a id="id325876829" class="indexterm"></a> important to understand. They are as follows:</p><pre class="programlisting"><span class="strong"><strong>#port = 5432 </strong></span>
<span class="strong"><strong>              # (change requires restart) </strong></span>
<span class="strong"><strong>max_connections = 100 </strong></span>
<span class="strong"><strong>              # (change requires restart) </strong></span>
<span class="strong"><strong># Note: Increasing max_connections costs ~400 bytes of </strong></span>
<span class="strong"><strong># shared memory per </strong></span>
<span class="strong"><strong># connection slot, plus lock space </strong></span>
<span class="strong"><strong># (see max_locks_per_transaction). </strong></span>
<span class="strong"><strong>#superuser_reserved_connections = 3 </strong></span>
<span class="strong"><strong>              # (change requires restart) </strong></span>
<span class="strong"><strong>#unix_socket_directories = '/tmp' </strong></span>
<span class="strong"><strong>              # comma-separated list of directories </strong></span>
<span class="strong"><strong>              # (change requires restart) </strong></span>
<span class="strong"><strong>#unix_socket_group = '' </strong></span>
<span class="strong"><strong>              # (change requires restart) </strong></span>
<span class="strong"><strong>#unix_socket_permissions = 0777 </strong></span>
<span class="strong"><strong>              # begin with 0 to use octal notation </strong></span>
<span class="strong"><strong>              # (change requires restart)</strong></span></pre><p>First of all, PostgreSQL listens to a single TCP port, the default value of which is is <code class="literal">5432</code>. Keep in mind that PostgreSQL will listen on a single port only. Whenever a request comes in, the postmaster will fork and create a new process to handle the connection. By default, up to 100 normal <span>connections</span><a id="id325876921" class="indexterm"></a> are allowed. On top of that, three additional <span>connections</span><a id="id325876930" class="indexterm"></a> are <span>reserved</span><a id="id325876938" class="indexterm"></a> for superusers. This <span>means</span><a id="id326162846" class="indexterm"></a> that we can either have 97 connections plus three superusers or 100 superuser connections.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note60"></a>Note</h3><p>Note that these connection-related settings will also need a restart. The reason for this is that a static amount of memory is allocated to shared memory, which cannot be changed on the fly.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec74"></a>Inspecting connections and performance</h4></div></div></div><p>While consulting, many <span>people</span><a id="id326162867" class="indexterm"></a> ask me whether raising the <span>connection</span><a id="id326162875" class="indexterm"></a> limit will have an impact on performance in general. The answer is: not much as there is always some overhead due to context switches and all that. It basically makes little difference how many connections there are. However, what does make a difference is the number of open snapshots. The more open snapshots there are, the more the <span>overhead</span><a id="id326162884" class="indexterm"></a> on the database side. In other words, we can increase <code class="literal">max_connections</code> cheaply.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip61"></a>Note</h3><p>If you are interested in some real-world data, consider taking a look at one of my older blog posts: <a class="ulink" href="https://www.cybertec-postgresql.com/max_connections-performance-impacts/" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>s</span><span>://</span><span>w</span><span>w</span><span>w</span><span>.</span><span>c</span><span>y</span><span>b</span><span>e</span><span>r</span><span>t</span><span>e</span><span>c</span><span>-postgresql.com</span><span>/</span><span>m</span><span>a</span><span>x</span><span>_</span><span>c</span><span>o</span><span>n</span><span>n</span><span>e</span><span>c</span><span>t</span><span>i</span><span>o</span><span>n</span><span>s</span><span>-</span><span>p</span><span>e</span><span>r</span><span>f</span><span>o</span><span>r</span><span>m</span><span>a</span><span>n</span><span>c</span><span>e</span><span>-</span><span>i</span><span>m</span><span>p</span><span>a</span><span>c</span><span>t</span><span>s</span><span>/</span></a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec75"></a>Living in a world without TCP</h4></div></div></div><p>In some cases, we might not want to use a network. It often <span>happens</span><a id="id326187164" class="indexterm"></a> that a database will only talk to a local application anyway. Maybe our PostgreSQL database has been shipped along with our application, or maybe we just don't want the risk of using a network: in this case, Unix sockets are what you need. Unix sockets are a network-free means of communication. Your application can connect through a Unix socket locally without exposing anything to the outside world.</p><p>What we need, however, is a directory. By default, PostgreSQL will use the <code class="literal">/tmp</code> directory. However, if more than one database server is running per machine, each one will need a separate data directory to live in.</p><p> </p><p>Apart from security, there are various reasons why not using a network might be a good idea. One of these reasons is performance. Using Unix sockets is a lot faster than going through the loopback device (<code class="literal">127.0.0.1</code>). If that sounds surprising, don't worry; it is for many people. However, the overhead of a real network connection should not be underestimated if you are only running very small queries.</p><p>To depict what this really means, I have included a simple benchmark.</p><p>We shall create a <code class="literal">script.sql</code> file. This is a simple script that just creates a random number and selects it. It is the most simplistic statement possible. There is nothing simpler than just fetching a number.</p><p>So, let's run this simple benchmark on a normal laptop. To do so, we shall write a small thing called <code class="literal">script.sql</code>. It will be used by the benchmark:</p><pre class="programlisting"><span class="strong"><strong>[hs@linuxpc ~]$ cat /tmp/script.sql</strong></span><span class="strong"><strong>SELECT 1</strong></span></pre><p>Then, we can simply run <code class="literal">pgbench</code> to execute the SQL over and over again. The <code class="literal">-f</code> option allows passing the name of the SQL to the script. <code class="literal">-c 10</code> means that we want ten concurrent connections to be active for 5 seconds (<code class="literal">-T 5</code>). The benchmark is running as the <code class="literal">postgres</code> user and is supposed to use the <code class="literal">postgres</code> database, which should be there by default. Note that the following examples will work on RHEL derivatives. Debian-based systems will use different paths:</p><pre class="programlisting"><span class="strong"><strong>[hs@linuxpc ~]$ pgbench -f /tmp/script.sql </strong></span>
<span class="strong"><strong>                -c 10 -T 5
</strong></span><span class="strong"><strong>-U postgres postgres 2&gt;
/dev/null transaction type: /tmp/script.sql</strong></span>
<span class="strong"><strong>scaling factor: 1 
query mode: simple 
number of clients: 10 
number of threads: 1 
duration: 5 s</strong></span>
<span class="strong"><strong>number of transactions actually processed: 871407 
latency average = 0.057 ms</strong></span>
<span class="strong"><strong>tps = 174278.158426 (including connections establishing)</strong></span>
<span class="strong"><strong>tps = 174377.935625 (excluding connections establishing)</strong></span></pre><p>As we can see, no hostname is passed to <code class="literal">pgbench</code>, so the tool connects locally to the Unix socket and runs the script as fast as possible. On this four-core Intel box, the system was able to achieve around 174,000 transactions per second.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>What happens if the <code class="literal">-h</code> localhost is added? Performance will change as you can see in the next listing.</p><pre class="programlisting"><span class="strong"><strong>[hs@linuxpc ~]$ pgbench -f /tmp/script.sql</strong></span>
<span class="strong"><strong>                  -h localhost -c 10 -T 5</strong></span>
<span class="strong"><strong>                  -U postgres postgres 2&gt;
/dev/null transaction type: /tmp/script.sql</strong></span>
<span class="strong"><strong>scaling factor: 1 
query mode: simple 
number of clients: 10 
number of threads: 1 
duration: 5 s</strong></span>
<span class="strong"><strong>number of transactions actually processed: 535251 
latency average = 0.093 ms</strong></span>
<span class="strong"><strong>tps = 107000.872598 (including connections establishing)</strong></span>
<span class="strong"><strong>tps = 107046.943632 (excluding connections establishing)</strong></span></pre><p>The throughput will drop such as a <span>stone</span><a id="id326241635" class="indexterm"></a> to <code class="literal">107000</code> transactions per second. The difference is clearly related to networking overhead.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip62"></a>Note</h3><p>By using the <code class="literal">-j</code> option (the number of threads assigned to <code class="literal">pgbench</code>), we can squeeze some more transactions out of our systems. However, it does not change the overall picture of the benchmark in my situation. In other tests, it does because <code class="literal">pgbench</code> can be a real bottleneck if you don't provide enough CPU power.</p></div><p>As we can see, networking can not only be a security issue, but also a performance issue.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec86"></a>Managing pg_hba.conf</h3></div></div></div><p>After configuring bind addresses, we can <span>move</span><a id="id326241670" class="indexterm"></a> on to the next level. The <code class="literal">pg_hba.conf</code> file will tell PostgreSQL how to authenticate people coming over the network. In general, <code class="literal">pg_hba.conf</code> file <span>entries</span><a id="id326241685" class="indexterm"></a> have the following layout:</p><pre class="programlisting"><span class="strong"><strong># local DATABASE USER METHOD [OPTIONS] 
# host DATABASE USER ADDRESS METHOD [OPTIONS] 
# hostssl DATABASE USER ADDRESS METHOD [OPTIONS] 
# hostnossl DATABASE USER ADDRESS METHOD [OPTIONS]</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>There are four types of rules that can be put into the <code class="literal">pg_hba.conf</code> file:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">local</code>: This can be used to configure local Unix socket connections.</li><li style="list-style-type: disc"><code class="literal">host</code>: This can be used for SSL and non-SSL connections.</li><li style="list-style-type: disc"><code class="literal">hostssl</code>: This is only valid for SSL connections. To make use of this option, SSL must be compiled into the server, which is the case if we are using prepackaged versions of PostgreSQL. In addition to that, <code class="literal">ssl = on</code> has to be set in the <code class="literal">postgresql.conf</code> file. This is the file when the server is started.</li><li style="list-style-type: disc"><code class="literal">hostnossl</code>: This works for non-SSL connections.</li></ul></div><p>A list of rules can be put into the <code class="literal">pg_hba.conf</code> file. Here is an example:</p><pre class="programlisting"># TYPE DATABASE USER ADDRESS METHOD
# "local" is for Unix domain socket connections only
local all all trust

# IPv4 local connections:
host all all 127.0.0.1/32 trust

# IPv6 local connections:
host all all ::1/128 trust</pre><p>You can see three simple rules. The local record says that all users from local Unix sockets for all databases are to be trusted. The trust method means that no password has to be sent to the server and people can log in directly. The other two rules say that the same applies to connections from localhost <code class="literal">127.0.0.1</code> and <code class="literal">::1/128</code>, which is an IPv6 address.</p><p>As connecting without a password is certainly not the best choice for remote access, PostgreSQL provides various authentication methods that can be used to configure <code class="literal">pg_hba.conf</code> file flexibly. Here is the list of possible authentication methods:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>trust</strong></span>: This allows authentication <span>without</span><a id="id326526861" class="indexterm"></a> providing a password. The desired user has to be available on the PostgreSQL side.</li><li style="list-style-type: disc"><span class="strong"><strong>reject</strong></span>: The connection <span>will</span><a id="id326526875" class="indexterm"></a> be rejected.</li><li style="list-style-type: disc"><span class="strong"><strong>md5 </strong></span><span class="strong"><strong>and </strong></span><span class="strong"><strong>password</strong></span>: The connections can be <span>created</span><a id="id326526896" class="indexterm"></a> using a password. md5 means that the password is sent over the <span>wire</span><a id="id326526904" class="indexterm"></a> encrypted. In the case of passwords, the credentials are sent in plain text, which should not be done on a modern system anymore. md5 is not considered safe anymore. You should use scram-sha-256 instead in PostgreSQL 10 and beyond.</li><li style="list-style-type: disc"><span class="strong"><strong>scram-sha-256</strong></span>: This setting is the <span>successor</span><a id="id326652052" class="indexterm"></a> of md5 and uses a far more secure hash than the previous version.
</li><li style="list-style-type: disc"><span class="strong"><strong>GSS </strong></span><span class="strong"><strong>and </strong></span><span class="strong"><strong>SSPI</strong></span>: This uses GSSAPI or SSPI authentication. This is only possible for TCP/IP connections. The idea here is to <span>allow</span><a id="id326652072" class="indexterm"></a> for single sign-on.</li><li style="list-style-type: disc"><span class="strong"><strong>ident</strong></span>: This obtains the <span>operating</span><a id="id326652086" class="indexterm"></a> system username of the client by contacting the ident server of the client and checking whether it matches the requested database username.</li><li style="list-style-type: disc"><span class="strong"><strong>peer</strong></span>: Suppose we are <span>logged</span><a id="id326652100" class="indexterm"></a> in as <span class="emphasis"><em>abc</em></span> on Unix. If peer is enabled, we can only log in to PostgreSQL as <span class="emphasis"><em>abc</em></span>. If we try to change the username, we will be rejected. The beauty is that <span class="emphasis"><em>abc</em></span> won't need a password in order to authenticate. The idea here is that only the database administrator can log in to the database on a Unix system and not somebody else who just has the password or a Unix account on the same machine. This only works for local connections.</li><li style="list-style-type: disc"><span class="strong"><strong>PAM</strong></span>: This uses the <span class="strong"><strong>pluggable authentication module</strong></span> (<span class="strong"><strong>PAM</strong></span>). This is especially important if you want to use a means of <span>authentication</span><a id="id326652133" class="indexterm"></a> that is not provided by PostgreSQL out of the box. To use PAM, create a file called <code class="literal">/etc/pam.d/postgresql</code> on your Linux <span>system</span><a id="id326652145" class="indexterm"></a> and put the desired PAM modules you are planning to use into the config file. Using PAM, we can even authenticate against less common components. However, it can also be used to connect to Active Directory and so on.</li><li style="list-style-type: disc"><span class="strong"><strong>LDAP</strong></span>: This configuration <span>allows</span><a id="id326652156" class="indexterm"></a> you to <span>authenticate</span><a id="id326652165" class="indexterm"></a> using <span class="strong"><strong>lightweight directory access protocol</strong></span> (<span class="strong"><strong>LDAP</strong></span>). Note that PostgreSQL will only ask LDAP for authentication; if a user is present only on the LDAP but not on the PostgreSQL side, you cannot log in. Also note that PostgreSQL has to know where your LDAP server is. All of this information has to be stored in the <code class="literal">pg_hba.conf</code> file, as outlined in the official documentation: <a class="ulink" href="https://www.postgresql.org/docs/10/static/auth-methods.html#AUTH-LDAP" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>s</span><span>://</span><span>w</span><span>w</span><span>w</span><span>.</span><span>p</span><span>o</span><span>s</span><span>t</span><span>g</span><span>r</span><span>e</span><span>s</span><span>q</span><span>l</span><span>.</span><span>o</span><span>r</span><span>g</span><span>/</span><span>d</span><span>o</span><span>c</span><span>s</span><span>/</span><span>10</span><span>/</span><span>s</span><span>t</span><span>a</span><span>t</span><span>i</span><span>c</span><span>/</span><span>a</span><span>u</span><span>t</span><span>h</span><span>-</span><span>m</span><span>e</span><span>t</span><span>h</span><span>o</span><span>d</span><span>s</span><span>.</span><span>h</span><span>t</span><span>m</span><span>l</span><span>#</span><span>A</span><span>U</span><span>T</span><span>H</span><span>-</span><span>L</span><span>D</span><span>A</span><span>P</span></a>.</li><li style="list-style-type: disc"><span class="strong"><strong>RADIUS</strong></span>: The <span class="strong"><strong>remote authentication dial-in user service</strong></span> (<span class="strong"><strong>RADIUS</strong></span>) is a <span>means</span><a id="id325874206" class="indexterm"></a> of performing single sign-on. Again, parameters are <span>passed</span><a id="id325874213" class="indexterm"></a> using configuration options.</li><li style="list-style-type: disc"><span class="strong"><strong>cert</strong></span>: This authentication <span>method</span><a id="id325874227" class="indexterm"></a> uses SSL client certificates to perform authentication, and therefore it is possible only if SSL is used. The advantage here is that no password has to be sent. The <code class="literal">CN</code> attribute of the certificate will be compared to the requested database username, and if they match, the login will be allowed. A map can be used to allow for user mapping.</li></ul></div><p>Rules can simply be listed one after the other. The important thing here is that the order does make a difference, as shown in the following example:</p><pre class="programlisting"><span class="strong"><strong>host   all   all   192.168.1.0/24   scram-sha-256</strong></span>
<span class="strong"><strong>host   all   all   192.168.1.54/32  reject</strong></span></pre><p>When PostgreSQL walks through the <code class="literal">pg_hba.conf</code> file, it will use the first rule that matches. So, if our request is coming from <code class="literal">192.168.1.54</code>, the first rule will <span>always</span><a id="id325874261" class="indexterm"></a> match <span>before</span><a id="id325874269" class="indexterm"></a> we make it to the second one. This means that <code class="literal">192.168.1.54</code> will be able to log in if the password and user are correct; therefore, the second rule is pointless.</p><p>If we want to exclude the IP, make sure that those two rules are swapped.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec76"></a>Handling SSL</h4></div></div></div><p>PostgreSQL allows us to encrypt the <span>transfer</span><a id="id325874290" class="indexterm"></a> between the server and the client. Encryption is highly beneficial, especially if we are communicating over long distances. SSL offers a simple and secure way to ensure that nobody is able to listen to your communication.</p><p>In this section, we will learn how to set up SSL.</p><p>The first thing to do is to set the <code class="literal">ssl</code> parameter to <code class="literal">on</code> in the <code class="literal">postgresql.conf</code> file when the server starts. In the next step, we can put SSL certificates into the <code class="literal">$PGDATA</code> directory. If we don't want the certificates to be in some other directory, change the following parameters:</p><pre class="programlisting"><span class="strong"><strong>#ssl_cert_file = 'server.crt'    # (change requires restart) </strong></span>
<span class="strong"><strong>#ssl_key_file = 'server.key'     # (change requires restart) </strong></span>
<span class="strong"><strong>#ssl_ca_file = ''                # (change requires restart) </strong></span>
<span class="strong"><strong>#ssl_crl_file = ''               # (change requires restart)</strong></span></pre><p>If we want to use self-signed certificates, perform the following step:</p><pre class="programlisting"><span class="strong"><strong>openssl req -new -text -out server.req</strong></span></pre><p>Answer the questions asked by OpenSSL. Make sure that we enter the local hostname as common name. We can leave the password empty. This call will generate a key that is passphrase protected; it will not accept a passphrase that is less than four characters long.</p><p>To remove the passphrase (as you must if you want <span>automatic</span><a id="id325876977" class="indexterm"></a> startup of the server), run the following commands:</p><pre class="programlisting"><span class="strong"><strong>openssl rsa -in privkey.pem -out server.key
rm privkey.pem</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>Enter the old passphrase to unlock the existing key. Now, do this to turn the certificate into a self-signed certificate and to copy the key and certificate to where the server will look for them:</p><pre class="programlisting"><span class="strong"><strong>openssl req -x509 -in server.req -text</strong></span><span class="strong"><strong>  -key server.key -out server.crt</strong></span></pre><p>After doing this, make sure that the files have the right set of permissions:</p><pre class="programlisting"><span class="strong"><strong>chmod og-rwx server.key</strong></span></pre><p>Once the proper rules have been put into the <code class="literal">pg_hba.conf</code> file, we can use SSL to connect to your server. To verify that we are indeed using SSL, consider checking out the <code class="literal">pg_stat_ssl</code> function. It will tell us every connection and whether it uses SSL or not, and it will provide some important information about encryption:</p><pre class="programlisting"><span class="strong"><strong>test=# \d pg_stat_sslView  "pg_catalog.pg_stat_ssl" 

Column       |   Type   | Modifiers 
-------------+----------+-----------  
pid          | integer  | 
ssl          | boolean  |  
version      | text     |  
cipher       | text     |  
bits         | integer  |  
compression  | boolean  |  </strong></span><span class="strong"><strong>clientdn     | text     |</strong></span></pre><p>If the <code class="literal">ssl</code> field for a process contains <code class="literal">true</code>; PostgreSQL does what we would expect it to do:</p><pre class="programlisting"><span class="strong"><strong>postgres=# select * from pg_stat_ssl; </strong></span>
<span class="strong"><strong>-[ RECORD 1 ]</strong></span>
<span class="strong"><strong>---------------------------- </strong></span>
<span class="strong"><strong>pid         | 20075</strong></span>
<span class="strong"><strong>ssl         | t </strong></span>
<span class="strong"><strong>version     | TLSv1.2</strong></span>
<span class="strong"><strong>cipher      | ECDHE-RSA-AES256-GCM-SHA384 </strong></span>
<span class="strong"><strong>bits        | 256</strong></span>
<span class="strong"><strong>compression | f </strong></span>
<span class="strong"><strong>clientdn    |</strong></span>

</pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec87"></a>Handling instance-level security</h3></div></div></div><p>So far, we have configured bind addresses and we have told PostgreSQL which means of authentication to use for which IP ranges. Up to now, the configuration was purely network-related.</p><p>In the next step, we can shift our <span>attention</span><a id="id325877141" class="indexterm"></a> to <span>permissions</span><a id="id326043243" class="indexterm"></a> at the instance level. The most important thing to know is that users in PostgreSQL exist at the instance level. If we create a user, it is not just visible inside one database; it can be seen by all the databases. A user might have permissions to access just a single database, but basically users are created at the instance level.</p><p>To those of you who are new to PostgreSQL, there is one more thing you should keep in mind: users and roles are the same thing. <code class="literal">CREATE ROLE</code> and <code class="literal">CREATE USER</code> clauses have different default values (literally, the only difference is that roles do not get the <code class="literal">LOGIN</code> attribute by default), but at the end of the day, users and roles are the same. Therefore, <code class="literal">CREATE ROLE</code> and <code class="literal">CREATE USER</code> clauses support the very same syntax:</p><pre class="programlisting"><span class="strong"><strong>test=# \h CREATE USER
Command: CREATE USER
Description: define a new database role
Syntax:
CREATE USER name [ [ WITH ] option [ ... ] ]

where option can be:

      SUPERUSER | NOSUPERUSER
    | CREATEDB | NOCREATEDB
    | CREATEROLE | NOCREATEROLE
    | INHERIT | NOINHERIT
    | LOGIN | NOLOGIN
    | REPLICATION | NOREPLICATION
    | BYPASSRLS | NOBYPASSRLS
    | CONNECTION LIMIT connlimit
    | [ ENCRYPTED ] PASSWORD 'password'
    | VALID UNTIL 'timestamp'
    | IN ROLE role_name [, ...]
    | IN GROUP role_name [, ...]
    | ROLE role_name [, ...]
    | ADMIN role_name [, ...]
    | USER role_name [, ...]
    | SYSID uid
</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>Let's discuss those syntax elements one by one. The first thing we see is that a user can be a superuser or a normal user. If somebody is marked as a <code class="literal">SUPERUSER </code>, there are no longer any restrictions that a normal user has to face. A <code class="literal">SUPERUSER</code> can drop objects (databases and so on) as they wish.</p><p>The next important thing is that it takes permissions on the instance level to create a new database.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note63"></a>Note</h3><p>Note that when somebody creates a database, this user will automatically be the owner of the database.</p></div><p>The rule is this: the creator is always automatically the owner of an object (unless specified otherwise, as can be done with the <code class="literal">CREATE DATABASE</code> clause). The beauty is that object owners can also drop an object again.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note64"></a>Note</h3><p>The <code class="literal">CREATEROLE</code>/<code class="literal">NOCREATEROLE</code> clause defines whether somebody is allowed to create new users/roles or not.</p></div><p>The next important thing is the <code class="literal">INHERIT</code>/<code class="literal">NOINHERIT</code> clause. If the <code class="literal">INHERIT</code> clause is set (which is the default value), a user can inherit permissions from some other user. Using inherited permissions allows us to use roles, which is as a good way to abstract permissions. For example, we can create the role of <code class="literal">bookkeeper</code> and make many other roles inherit from <code class="literal">bookkeeper</code>. The idea is that we only have to tell PostgreSQL once what a <code class="literal">bookkeeper</code> is allowed to do, even if we have many people working in accounting.</p><p>The <code class="literal">LOGIN</code>/<code class="literal">NOLOGIN</code> clause defines whether a role is allowed to log in to the instance.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note65"></a>Note</h3><p>Note that the <code class="literal">LOGIN</code> clause is not enough to actually connect to a database. To do that, more permissions are needed.</p></div><p> </p><p>At this point, we are trying to make it into the instance, which is basically the gate to all the databases inside the instance. Let's get back to our example: the <code class="literal">bookkeeper</code> might be marked as <code class="literal">NOLOGIN</code> because we want people to log in with their real name. All your accountants (say, Joe and Jane) might be marked as the <code class="literal">LOGIN</code> clause but can inherit all the permissions from the <code class="literal">bookkeeper</code> role. A structure such as this makes it easy to assure that all bookkeepers will have the same permissions while ensuring their individual activity is operated and logged under their separate identities.</p><p>If we are planning to run PostgreSQL with streaming replication, we can do all the transaction log streaming as a superuser. However, doing that is not recommended from a security point of view. As an assurance, that we don't have to be a superuser to stream <span>xlog</span>, PostgreSQL allows us to give replication rights to a normal user, which can then be used to do streaming. It is common practice to create a special user just for the purpose of managing streaming.</p><p>As we will see later in this chapter, PostgreSQL provides a feature called row-level security. The idea is that we can exclude rows from the scope of a user. If a user is explicitly supposed to bypass RLS, set this value to <code class="literal">BYPASSRLS</code>. The default value is <code class="literal">NOBYPASSRLS</code>.</p><p>Sometimes, it makes sense to restrict the number of connections allowed for a user. <code class="literal">CONNECTION LIMIT</code> allows us to do exactly that. Note that, overall, there can never be more connections than defined in the <code class="literal">postgresql.conf</code> file (<code class="literal">max_connections</code>). However, we can always restrict certain users to a lower value.</p><p>By default, PostgreSQL will store passwords in the system table encrypted, which is a good default behavior. However, suppose you are doing a training course and ten students are attending and everybody is connected to your box. You can be 100% certain that one of those people will forget his or her password once in a while. As your setup is not security critical, you might decide to store the password in plain text so that you can easily look it up and give it to a student. This feature might also come in handy if you are testing software.</p><p>Often, we already know that somebody will leave the organization fairly soon. The <code class="literal">VALID UNTIL</code> clause allows us to automatically lock out a specific user if his or her account has expired.</p><p>The <code class="literal">IN ROLE</code> clause lists one or more existing roles to which the new role will be immediately added as a new member. It helps to avoid additional manual steps. An alternative to <code class="literal">IN ROLE</code> is <code class="literal">IN GROUP</code>.</p><p>The <code class="literal">ROLE</code> clause will define roles that are <span>automatically</span><a id="id326043434" class="indexterm"></a> added as <span>members</span><a id="id326518204" class="indexterm"></a> of the new role.</p><p>The <code class="literal">ADMIN</code> clause is the same as the <code class="literal">ROLE</code> clause but adds <code class="literal">WITH ADMIN OPTION</code>.</p><p>Finally, we can use the <code class="literal">SYSID</code> clause to set a specific ID for the user (similar to what some Unix administrators do for usernames at the operating system level).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec77"></a>Creating and modifying users</h4></div></div></div><p>After this <span>theoretical</span><a id="id326518236" class="indexterm"></a> introduction, it is time to actually create users and see how things can be <span>used</span><a id="id326518245" class="indexterm"></a> in a practical example:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE ROLE  bookkeeper NOLOGIN;  
CREATE ROLE 
test=# CREATE ROLE  joe LOGIN;  
CREATE ROLE 
test=# GRANT  bookkeeper TO joe;  
GRANT ROLE</strong></span></pre><p>The first thing done here is that a role called <code class="literal">bookkeeper</code> is created.</p><p>Note that we don't want people to log in as <code class="literal">bookkeeper</code>, so the role is marked as <code class="literal">NOLOGIN</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip66"></a>Note</h3><p>Also note that <code class="literal">NOLOGIN</code> is the default value if you use the <code class="literal">CREATE ROLE</code> clause. If you prefer the <code class="literal">CREATE USER</code> clause, the default setting is <code class="literal">LOGIN</code>.</p></div><p>Then, the <code class="literal">joe</code> role is created and marked as <code class="literal">LOGIN</code>. Finally, the <code class="literal">bookkeeper</code> role is assigned to the <code class="literal">joe</code> role so that he can do everything a <code class="literal">bookkeeper</code> is actually allowed to do.</p><p>Once the users are in place, we can test what we have so far:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql test -U bookkeeper</strong></span><span class="strong"><strong>psql: FATAL:  role "bookkeeper" is not permitted to log in</strong></span></pre><p>As expected, the <code class="literal">bookkeeper</code> role is not allowed to log in to the system. What happens if the <code class="literal">joe</code> role tries to log in?</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql test -U joe</strong></span><span class="strong"><strong>... </strong></span><span class="strong"><strong>test=&gt;</strong></span></pre><p>This will actually work as expected. However, note that Command Prompt has changed. This is just a way for PostgreSQL to show you that you are not logged in as a superuser.</p><p>Once a user has been created, it might be necessary to modify it. One thing we might want to change is the password. In PostgreSQL, users are allowed to change their own passwords. Here is how it works:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; ALTER  ROLE  joe PASSWORD 'abc';  
ALTER  ROLE 
test=&gt; SELECT current_user;</strong></span><span class="strong"><strong> current_user 
--------------  
 joe 
(1 row)</strong></span></pre><p>The <code class="literal">ALTER ROLE</code> clause (or <code class="literal">ALTER USER</code>) will allow us to change most settings which can be set during user creation. However, there is even more to managing users. In many cases, we want to assign special parameters to a user. The <code class="literal">ALTER USER</code> clause gives us the means to do that:</p><pre class="programlisting"><span class="strong"><strong>ALTER ROLE { role_specification | ALL } </strong></span>
<span class="strong"><strong>     [ IN DATABASE database_name ] </strong></span>
<span class="strong"><strong>              SET configuration_parameter { TO | = } { value | DEFAULT } </strong></span>
<span class="strong"><strong>ALTER ROLE { role_specification | ALL } </strong></span>
<span class="strong"><strong>     [ IN DATABASE database_name ] </strong></span>
<span class="strong"><strong>              SET configuration_parameter FROM CURRENT </strong></span>
<span class="strong"><strong>ALTER ROLE { role_specification | ALL } </strong></span>
<span class="strong"><strong>     [ IN DATABASE database_name ] RESET configuration_parameter </strong></span>
<span class="strong"><strong>ALTER ROLE { role_specification | ALL } </strong></span>
<span class="strong"><strong>     [ IN DATABASE database_name ] RESET ALL</strong></span></pre><p>The syntax is fairly simple and pretty straightforward. To depict why this is really useful, I have added a real-world example. Let's <span>suppose</span><a id="id326561734" class="indexterm"></a> that Joe <span>happens</span><a id="id326561742" class="indexterm"></a> to live on the island of Mauritius. When he logs in, he wants to be in his own time zone, even if his database server is located in Europe:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; ALTER  ROLE  joe SET TimeZone = 'UTC-4';  
ALTER  ROLE 
test=&gt; SELECT now();</strong></span><span class="strong"><strong>             now 
------------------------------- 
2017-01-09 20:36:48.571584+01 
(1 row) 
 
test=&gt; q 
[hs@zenbook ~]$ psql  test  -U joe 
... 
test=&gt; SELECT now(); 
           now 
------------------------------- 
2017-01-09 23:36:53.357845+04 
(1 row)</strong></span></pre><p>The <code class="literal">ALTER ROLE</code> clause will modify the user. As soon as <code class="literal">joe</code> reconnects, the time zone will already be set for him.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip67"></a>Note</h3><p>The time zone is not changed immediately. You should either reconnect or use a <code class="literal">SET ... TO DEFAULT</code> clause.</p></div><p>The important thing here is that this is also possible for some memory parameters, such as <code class="literal">work_mem</code> and so on, which have already been covered earlier in this book.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec88"></a>Defining database-level security</h3></div></div></div><p>After configuring users at the instance level, it is <span>possible</span><a id="id326561789" class="indexterm"></a> to dig deeper and see what can be done at the database level. The first major question that arises is: we explicitly allowed Joe to log in to the database instance, but who or what allowed Joe to actually connect to one of the databases? Maybe we don't want Joe to access all the databases in your system. Restricting access to certain databases is exactly what we can achieve on this level.</p><p>For databases, the following <span>permissions</span><a id="id326561801" class="indexterm"></a> can be set using a <code class="literal">GRANT</code> clause:</p><pre class="programlisting"><span class="strong"><strong>GRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [, ...] </strong></span>
<span class="strong"><strong>     | ALL [ PRIVILEGES ] } </strong></span>
<span class="strong"><strong>    ON DATABASE database_name [, ...] </strong></span>
<span class="strong"><strong>    TO role_specification [, ...] [ WITH GRANT OPTION ]  </strong></span></pre><p>There are two major permissions on the database level that deserve close attention:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">CREATE</code>: This allows <span>somebody</span><a id="id326561842" class="indexterm"></a> to create a schema inside the database. Note that a <code class="literal">CREATE</code> clause does not allow for the creation of tables; it is about schemas. In PostgreSQL, a table resides inside a schema, so you have to get to the schema level first to be able to create a table.</li><li style="list-style-type: disc"><code class="literal">CONNECT</code>: This allows <span>somebody</span><a id="id326561858" class="indexterm"></a> to connect to a database.</li></ul></div><p>The question now is: nobody has explicitly assigned <code class="literal">CONNECT</code> permissions to the <code class="literal">joe</code> role, so where do those permissions actually come from? The answer is this: there is a thing called <code class="literal">public</code>, which is similar to the Unix world. If the world is allowed to do something, so is <code class="literal">joe</code>, who is part of the general public.</p><p>The main thing is that <code class="literal">public</code> is not a role in the <span>sense</span><a id="id326561888" class="indexterm"></a> that it can be dropped and renamed. We can simply see it as the equivalent for everybody on the system.</p><p>So, to ensure that not everybody can <span>connect</span><a id="id326561898" class="indexterm"></a> to any database at any time, <code class="literal">CONNECT</code> may have to be revoked from the general public. To do so, we can connect as superuser and fix the problem:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql  test  -U postgres</strong></span><span class="strong"><strong>... 
test=# REVOKE ALL ON DATABASE test FROM public;  
REVOKE 
test=# \q 
[hs@zenbook ~]$ psql test -U joe 
psql:  FATAL:  permission denied for database "test"  
DETAIL:  User does not have CONNECT privilege.</strong></span></pre><p>As we can see, the <code class="literal">joe</code> role is not allowed to connect anymore. At this point, only superusers have access to test.</p><p>In general, it is a good idea to revoke permissions from the <code class="literal">postgres</code> database even before other databases are created. The idea behind this concept is that those permissions won't be in all those newly created databases anymore. If somebody needs access to a certain database, rights have to be explicitly granted. Rights are not automatically there anymore.</p><p>If we want to allow the <code class="literal">joe</code> role to connect to the test database, try the following line as superuser:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql test -U postgres</strong></span><span class="strong"><strong>... 
test=# GRANT CONNECT ON DATABASE test TO bookkeeper;  
GRANT 
test=# \q 
[hs@zenbook ~]$ psql test -U joe 
...  
test=&gt;</strong></span></pre><p>Basically, there are two choices here:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">We can allow the <code class="literal">joe</code> role directly so that only the <code class="literal">joe</code> role will be able to connect.</li><li style="list-style-type: disc">Alternatively, we can <span>grant</span><a id="id326652382" class="indexterm"></a> permissions to the <code class="literal">bookkeeper</code> role. Remember, the <code class="literal">joe</code> role will inherit all the permissions from the <code class="literal">bookkeeper</code> role, so if we want all accountants to be able to connect to the database, assigning <span>permissions</span><a id="id326652401" class="indexterm"></a> to the <code class="literal">bookkeeper</code> role seems such as an attractive idea.</li></ul></div><p>If we grant permissions to the <code class="literal">bookkeeper</code> role, it is not risky because the role is not allowed to log in to the instance in the first place, so it purely serves as a source of permissions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec89"></a>Adjusting schema-level permissions</h3></div></div></div><p>Once we are done configuring the <span>database</span><a id="id326652425" class="indexterm"></a> level, it makes <span>sense</span><a id="id326652434" class="indexterm"></a> to take a look at the schema level.</p><p>Before actually taking a look at the schema, let's run a small test:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; CREATE DATABASE test;</strong></span><span class="strong"><strong>ERROR:  permission denied to create database test=&gt;  
CREATE USER  xy; 
ERROR:  permission denied to create role test=&gt;  
CREATE SCHEMA sales; 
ERROR:  permission denied for database test</strong></span></pre><p>As we can see, Joe is having a bad day and basically nothing but connecting to the database is allowed.</p><p>However, there is a small exception, and it comes as a surprise to many people:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; CREATE TABLE t_broken (id int);  
CREATE TABLE 
test=&gt; \d 
          List  of relations</strong></span><span class="strong"><strong>Schema  |   Name   | Type   | Owner 
--------+----------+--------+-------  
 public | t_broken | table  | joe 
(1 rows)</strong></span></pre><p>By default, <code class="literal">public</code> is allowed to work with the public schema, which is always around. If we are seriously interested in securing our database, make sure that this problem is taken care of. Otherwise, normal users will potentially spam your public schema with all kinds of tables and the entire setup might suffer. Also keep in mind that if somebody is allowed to create an object, this person is also its owner. Ownership means that there are automatically all <span>permissions</span><a id="id326652474" class="indexterm"></a> are automatically available to the creator, including the <span>destruction</span><a id="id326652483" class="indexterm"></a> of the object.</p><p>To take away those permissions away from <code class="literal">public</code>, run the following line as a superuser:</p><pre class="programlisting"><span class="strong"><strong>test=# REVOKE ALL ON SCHEMA public FROM public;  
REVOKE</strong></span></pre><p>From now on, nobody can put things into your public schema without permissi<span>ons any mo</span>re. The next listing is proof of that:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql test -U joe</strong></span> 
... 
<span class="strong"><strong>test=&gt; CREATE TABLE  t_data (id int);</strong></span><span class="strong"><strong>ERROR:  no schema has been selected to create in 
LINE  1: CREATE TABLE t_data (id int);</strong></span></pre><p>As we can see, the command will fail. The important thing here is the error message that will be displayed; PostgreSQL does not know where to put these tables. By default, it will try to put the table into one of the following schema:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; SHOW search_path ;</strong></span><span class="strong"><strong> search_path 
-----------------  
 "$user", public 
(1 row)</strong></span></pre><p>As there is no schema called <code class="literal">joe</code>, it is not an option and PostgreSQL will try the <code class="literal">public</code> schema. As there are no permissions, it will complain that it does not know where to put the table.</p><p>If the table is explicitly prefixed, the situation will change instantly:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; CREATE TABLE  public.t_data (id int); </strong></span><span class="strong"><strong>ERROR:  permission denied for schema public  
LINE  1: CREATE TABLE  public.t_data (id int);</strong></span></pre><p>In this case, we will get the error message you expect. PostgreSQL denies access to the <code class="literal">public</code> schema.</p><p>The next logical question now is: which <span>permissions</span><a id="id326652805" class="indexterm"></a> can be set at the schema level to give some more power to the <code class="literal">joe</code> role:</p><pre class="programlisting"><span class="strong"><strong>GRANT  { { CREATE | USAGE  } [, ...]  | ALL [ PRIVILEGES ] }  
  ON SCHEMA schema_name [, ...] 
TO role_specification [, ...]  [ WITH  GRANT  OPTION ]</strong></span></pre><p><code class="literal">CREATE</code> means that somebody can put objects into a schema. <code class="literal">USAGE</code> means that somebody is allowed to enter the schema. Note that entering the schema does not mean that something <span>inside</span><a id="id326652832" class="indexterm"></a> the schema can actually be used; those permissions have not been defined yet. Basically, this just means the user can see the system catalog for this schema.</p><p>To allow the <code class="literal">joe</code> role to access the table it has created previously, the following line will be necessary (executed as a superuser):</p><pre class="programlisting"><span class="strong"><strong>test=# GRANT USAGE ON SCHEMA public TO bookkeeper; </strong></span><span class="strong"><strong>GRANT</strong></span></pre><p>The <code class="literal">joe</code> role is now able to read its table as expected:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql test -U joe  
test=&gt; SELECT count(*) FROM t_broken; </strong></span><span class="strong"><strong> count 
------- 
     0 
(1 row)</strong></span></pre><p>The <code class="literal">joe</code> role is also able to add and modify rows because it happens to be the owner of the table. However, although it can do quite a lot of things already, the <code class="literal">joe</code> role is not yet almighty. Consider the following statement:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; ALTER TABLE t_broken RENAME TO t_useful; </strong></span><span class="strong"><strong>ERROR:  permission denied for schema public</strong></span></pre><p>Let's take a closer look at the actual error message. As we can see, the message complains about permissions on the schema, not about <span>permissions</span><a id="id326652892" class="indexterm"></a> on the table itself (remember, the <code class="literal">joe</code> role owns the table). To fix the problem, it has to be tackled on the schema and not on the table level. Run the <span>following</span><a id="id326652905" class="indexterm"></a> line as a superuser:</p><pre class="programlisting"><span class="strong"><strong>test=# GRANT CREATE ON SCHEMA public TO bookkeeper; </strong></span><span class="strong"><strong>GRANT</strong></span></pre><p>The <code class="literal">joe</code> role can now change the name of its table to a more useful name:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql test -U joe 
test=&gt; ALTER TABLE t_broken RENAME TO t_useful; </strong></span><span class="strong"><strong>ALTER TABLE</strong></span></pre><p>Keep in mind that this is necessary if DDLs are used. In my daily work as a PostgreSQL support service provider, I have seen a couple of issues where this turned out to be a problem.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec90"></a>Working with tables</h3></div></div></div><p>After taking care of bind addresses, network authentication, users, databases, and schema, we have finally made it to the table level. The following snippet shows which permissions <span>can</span><a id="id325880988" class="indexterm"></a> be set for a table:</p><pre class="programlisting"><span class="strong"><strong>GRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE </strong></span>
<span class="strong"><strong>              | REFERENCES | TRIGGER } </strong></span>
<span class="strong"><strong>    [, ...] | ALL [ PRIVILEGES ] } </strong></span>
<span class="strong"><strong>    ON { [ TABLE ] table_name [, ...] </strong></span>
<span class="strong"><strong>         | ALL TABLES IN SCHEMA schema_name [, ...] } </strong></span>
<span class="strong"><strong>    TO role_specification [, ...] [ WITH GRANT OPTION ]</strong></span></pre><p>Let me explain these permissions one by one:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">SELECT</code>: This allows you to read a table.</li><li style="list-style-type: disc"><code class="literal">INSERT</code>: This allows you to add rows to the table (this also includes copy and so on; it is not only about the <code class="literal">INSERT</code> clause). Note that if you are allowed to insert, you are not automatically allowed to read. <code class="literal">SELECT</code> and <code class="literal">INSERT</code> clauses are needed to be able to read the data you have inserted.</li><li style="list-style-type: disc"><code class="literal">UPDATE</code>: This modifies the content of a table.</li><li style="list-style-type: disc"><code class="literal">DELETE</code>: This is used to remove rows from a table.
</li><li style="list-style-type: disc"><code class="literal">TRUNCATE</code>: This allows you to use the <code class="literal">TRUNCATE</code> clause. Note that the <code class="literal">DELETE</code> and <code class="literal">TRUNCATE</code> clauses are two separate permissions because the <code class="literal">TRUNCATE</code> clause will lock the table, which is not done by the <code class="literal">DELETE</code> clause (not even if there is no <code class="literal">WHERE</code> condition).</li><li style="list-style-type: disc"><code class="literal">REFERENCES</code>: This allows the creation of foreign keys. It is necessary to have this privilege on both the referencing and referenced columns, otherwise the creation of the key won't work.</li><li style="list-style-type: disc"><code class="literal">TRIGGER</code>: This allows for the creation of triggers.</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip68"></a>Note</h3><p>The nice thing about the <code class="literal">GRANT</code> clause is that we can set permissions on all tables in a schema at the same time.</p></div><p>This greatly simplifies the process of <span>adjusting</span><a id="id325881100" class="indexterm"></a> permissions. It is also possible to use the <code class="literal">WITH GRANT OPTION</code> clause. The idea is to ensure that normal users can pass on permissions to others, which has the advantage of being able to reduce the workload of administrators quite a bit. Just imagine a system that provides access to hundreds of users; it can start to be a lot of work to manage all those people, and therefore administrators can appoint people managing a subset of the data themselves.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec91"></a>Handling column-level security</h3></div></div></div><p>In some cases, not everybody is allowed to see all the data. Just imagine a bank. Some people might see the entire information about a bank account, while others might be <span>limited</span><a id="id325881120" class="indexterm"></a> to only a subset of the data. In a real-world situation, somebody might not be allowed to read the balance column or somebody might not see the interest rates of people's loans.</p><p>Another example would be that people are allowed to see people's profiles but not their pictures or some other private information. The question now is: how <span>can</span><a id="id325881130" class="indexterm"></a> column-level security be used?</p><p>To demonstrate that, we will add a column to the existing table belonging to the <code class="literal">joe</code> role:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; ALTER TABLE t_useful ADD COLUMN name text; </strong></span><span class="strong"><strong>ALTER TABLE</strong></span></pre><p>The table now consists of two columns. The goal of the example is to ensure that a user can see only one of those columns:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; \d t_useful 
    Table  "public.t_useful"</strong></span><span class="strong"><strong> Column |   Type   | Modifiers 
--------+---------+-----------  
 id     | integer  | 
 name   | text     |</strong></span></pre><p>As a superuser, let's create a user and give it access to the schema containing our table:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE ROLE paul LOGIN; </strong></span><span class="strong"><strong>CREATE ROLE 
test=# GRANT CONNECT ON DATABASE test TO paul;  
GRANT 
test=# GRANT USAGE ON SCHEMA public TO paul;  
GRANT</strong></span></pre><p>Do not forget to give <code class="literal">CONNECT</code> rights to the new guy because earlier in the chapter, <code class="literal">CONNECT</code> was revoked from <code class="literal">public</code>. Explicit granting is therefore <span>absolutely</span><a id="id326162553" class="indexterm"></a> necessary to <span>ensure</span><a id="id326162562" class="indexterm"></a> that we can even get to the table.</p><p>The <code class="literal">SELECT</code> permissions can be given to the <code class="literal">paul</code> role:</p><pre class="programlisting"><span class="strong"><strong>test=# GRANT  SELECT (id)  ON t_useful TO paul; </strong></span><span class="strong"><strong>GRANT </strong></span></pre><p>Basically, this is already enough. It is already possible to connect to the database as user <code class="literal">paul</code> and read the column:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql test -U paul 
... 
test=&gt; SELECT id FROM t_useful;</strong></span><span class="strong"><strong>id 
---- 
(0 rows)</strong></span></pre><p>If we are using column-level permissions, there is an important thing to keep in mind; we should stop using <code class="literal">SELECT *</code>, as it does not work anymore:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; SELECT * FROM t_useful;</strong></span><span class="strong"><strong>ERROR:  permission denied for relation t_useful</strong></span></pre><p><code class="literal">*</code> still means all columns, but as there is no way to access all columns, things will error out instantly.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec92"></a>Configuring default privileges</h3></div></div></div><p>So far, a lot of stuff has already been configured. The trouble <span>naturally</span><a id="id326162630" class="indexterm"></a> arising now is, what happens if new tables are added to the system? It <span>can</span><a id="id326162638" class="indexterm"></a> be quite painful and risky to process these tables one by one and to set proper permissions. Wouldn't it be nice if those things would just happen automatically? This is exactly what the <code class="literal">ALTER DEFAULT PRIVILEGES</code> clause does. The idea is to give users an option to make PostgreSQL automatically set the desired permissions as soon as an object comes into existence. It cannot happen anymore that somebody simply forgets to set those rights.</p><p>The following listing shows the first part of the syntax specification:</p><pre class="programlisting"><span class="strong"><strong>postgres=# \h ALTER DEFAULT PRIVILEGES
Command: ALTER DEFAULT PRIVILEGES
Description: define default access privileges
Syntax:
ALTER DEFAULT PRIVILEGES
    [ FOR { ROLE | USER } target_role [, ...] ]
    [ IN SCHEMA schema_name [, ...] ]
    abbreviated_grant_or_revoke

where abbreviated_grant_or_revoke is one of:

GRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }
    [, ...] | ALL [ PRIVILEGES ] }
    ON TABLES
    TO { [ GROUP ] role_name | PUBLIC } [, ...] [ WITH GRANT OPTION ]
...</strong></span></pre><p>Basically, the syntax works similar to the <code class="literal">GRANT</code> clause and is therefore easy and intuitive to use. To show us how it works, I compiled a simple example. The idea is that if the <code class="literal">joe</code> role creates a table, the <code class="literal">paul</code> role will automatically be able to use it:</p><pre class="programlisting"><span class="strong"><strong>test=# ALTER DEFAULT PRIVILEGES FOR ROLE joe 
      IN SCHEMA public GRANT ALL ON TABLES TO paul; </strong></span><span class="strong"><strong>ALTER DEFAULT PRIVILEGES</strong></span></pre><p>Let's connect as the <code class="literal">joe</code> role now and create a table:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql  test  -U joe 
... 
test=&gt; CREATE TABLE  t_user (id serial, name  text,  passwd text); </strong></span><span class="strong"><strong>CREATE TABLE</strong></span></pre><p>Connecting as the <code class="literal">paul</code> role will <span>prove</span><a id="id326162701" class="indexterm"></a> that the table has <span>been</span><a id="id326162710" class="indexterm"></a> assigned to the proper set of permissions:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ psql test -U paul 
... 
test=&gt; SELECT * FROM  t_user;</strong></span><span class="strong"><strong> id | name | passwd 
----+------+--------  
(0 rows)</strong></span></pre></div></div>