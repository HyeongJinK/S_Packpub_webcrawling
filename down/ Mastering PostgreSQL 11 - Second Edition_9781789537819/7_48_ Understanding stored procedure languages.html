<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec50"></a>Understanding stored procedure languages</h2></div></div><hr /></div><p>When it comes to <span>stored</span><a id="id326473718" class="indexterm"></a> procedures and functions, PostgreSQL differs quite significantly from other database systems. Most database engines force you to use a certain programming language to write server-side code. Microsoft SQL Server offers Transact-SQL, while Oracle encourages you to use PL/SQL. PostgreSQL does not force you to use a certain language, but allows you to decide on what you know best and what you like best.</p><p>The reason PostgreSQL is so flexible is actually quite interesting in a historical sense too. Many years ago, one of the most well-known PostgreSQL developers, Jan Wieck, who had written countless patches back in its early days, came up with the idea of using TCL as the server-side programming language. The trouble was that nobody wanted to use TCL and nobody wanted to have this stuff in the database engine. The solution to the problem was to make the language interface so flexible that basically any language can be integrated with PostgreSQL easily. At this instance, the <code class="literal">CREATE LANGUAGE</code> clause was born. Here is the syntax of CREATE LANGUAGE:</p><pre class="programlisting"><span class="strong"><strong>test=# \h CREATE LANGUAGE 
Command:    CREATE LANGUAGE
Description: Define a new procedural language</strong></span>
<span class="strong"><strong>Syntax:</strong></span>
<span class="strong"><strong>CREATE [ OR REPLACE ] [ PROCEDURAL ] LANGUAGE name 
CREATE [ OR REPLACE ] [ TRUSTED ] [ PROCEDURAL ] 
   LANGUAGE name HANDLER call_handler 
   [ INLINE inline_handler ] [ VALIDATOR valfunction ]</strong></span></pre><p>Nowadays, many different <span>languages</span><a id="id325861484" class="indexterm"></a> can be used to write functions and stored procedures. The flexibility added to PostgreSQL has really paid off; we can now choose from a rich set of programming languages.</p><p>How exactly does PostgreSQL handle languages? If we take a look at the syntax of the <code class="literal">CREATE LANGUAGE</code> clause, we will observe a few keywords:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">HANDLER</code>: This function is actually the glue between PostgreSQL and any external language you want to use. It is in charge of mapping PostgreSQL data structures to whatever is needed by the language and helps to pass the code around.</li><li style="list-style-type: disc"><code class="literal">VALIDATOR</code>: This is the policeman of the infrastructure. If it is available, it will be in-charge of delivering tasty syntax errors to the end user. Many languages are able to parse the code before actually executing it. PostgreSQL can use that and tell you whether a function is correct or not when you create it. Unfortunately, not all languages can do this, so in some cases, you will still be left with problems showing up at runtime.</li><li style="list-style-type: disc"><code class="literal">INLINE</code>: If this is present, PostgreSQL will be able to run anonymous code blocks utilizing this handler function.</li></ul></div><p> </p><p> </p><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec78"></a>Understanding fundamentals – stored procedures versus functions</h3></div></div></div><p>Before we dig into the anatomy of a <span>stored</span><a id="id325872039" class="indexterm"></a> procedure, it is <span>important</span><a id="id325872048" class="indexterm"></a> to talk about functions and procedures in general. The term stored procedure has traditionally been used to actually talk about a function. Thus, it is essential that we understand the difference between a function and a procedure.</p><p>A function is part of a normal SQL statement and is not allowed to start or commit transactions. Here is an example:</p><pre class="programlisting"><span class="strong"><strong>SELECT func(id) FROM large_table;</strong></span></pre><p>Suppose <code class="literal">func(id)</code> is called 50 million times. If you use the function called <code class="literal">commit</code>, what exactly should happen? It is impossible to simply end a transaction in the middle of a query and launch a new one. The entire concept of transactional integrity, consistency, and so on would be violated. </p><p>A procedure, in contrast, is able to control transactions and even run multiple transactions one after the other. However, you cannot run it inside a <code class="literal">SELECT</code> statement. Instead you have to invoke <code class="literal">CALL</code>. The following listing shows the syntax of the CALL command:</p><pre class="programlisting"><span class="strong"><strong>test=# \h CALL</strong></span>
<span class="strong"><strong>Command: CALL</strong></span>
<span class="strong"><strong>Description: invoke a procedure</strong></span>
<span class="strong"><strong>Syntax:</strong></span>
<span class="strong"><strong>CALL name ( [ argument ] [, ...] )</strong></span></pre><p>Therefore, there is a fundamental distinction between functions and procedures. The terminology you will find on the internet is not always clear. However, you have to be aware of those important differences. In PostgreSQL, functions have always been around since the very beginning. However, the concept of a procedure, as outlined in this section, is new and has only been introduced in PostgreSQL 11. In this chapter, we will take a look at both functions as well as procedures. </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec79"></a>The anatomy of a function</h3></div></div></div><p>Before actually digging into a <span>specific</span><a id="id326003149" class="indexterm"></a> language, we will look into the anatomy of a typical function. For demonstration purposes, let's look at this function that just adds two numbers:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE OR REPLACE FUNCTION mysum(int, int)  
RETURNS int AS 
' 
  SELECT $1 + $2; 
' LANGUAGE 'sql';  
CREATE FUNCTION</strong></span></pre><p>The first thing to observe is that the function is written in SQL. PostgreSQL needs to know which language we are using, so we have to specify that in the definition.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note53"></a>Note</h3><p>Note that the code of the function is passed to PostgreSQL as a string (<code class="literal">'</code>). This is somewhat noteworthy because it allows a function to become a black box to the execution machinery.</p></div><p>In other database engines, the code of the function is not a string, but is directly attached to the statement. This simple abstraction layer is what gives the PostgreSQL function manager all its power.</p><p>Inside the string, you can basically use all that the programming language of your choice has to offer.</p><p>In this example, we will simply add up two numbers that have been passed to the function. Two integer variables are in use. The important part here is that PostgreSQL provides you with function overloading. In other words, the <code class="literal">mysum(int, int)</code> function is not the same as the <code class="literal">mysum(int8, int8)</code> function.</p><p>PostgreSQL sees these things as two distinct functions. Function overloading is a good feature; however, you have to be very careful not to accidentally deploy too many functions if your parameter list happens to change from time to time. Always make sure that functions that are not needed anymore are really deleted.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip54"></a>Note</h3><p>The <code class="literal">CREATE OR REPLACE FUNCTION</code> clause will not change the parameter list. You can, therefore, use it only if the signature does not change. It will either error out or simply deploy a new function.</p></div><p>Let's run the function:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT mysum(10, 20); 
 mysum 
------- 
 30  
(1 row)</strong></span></pre><p>The <span>result</span><a id="id326003827" class="indexterm"></a> here is <code class="literal">30</code>, which is not really surprising. After this introduction to function it is important to focus on the next major topic: Quoting.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec52"></a>Introducing dollar quoting</h4></div></div></div><p>Passing code to PostgreSQL as a string is very flexible. However, using single quotes can be an issue. In many programming languages, single <span>quotes</span><a id="id326003869" class="indexterm"></a> show up frequently. To be able to use these quotes, people have to escape them when passing the string to PostgreSQL. For <span>many</span><a id="id326003879" class="indexterm"></a> years, this has been the standard procedure. Fortunately, those old times have passed by and new means to pass the code to PostgreSQL are available. One of these is dollar quoting, that is shown as follows: </p><pre class="programlisting"><span class="strong"><strong>test=# CREATE OR REPLACE FUNCTION mysum(int, int)  
RETURNS int AS 
$$ 
    SELECT $1 + $2; 
$$ LANGUAGE 'sql';  
CREATE FUNCTION</strong></span></pre><p>Instead of using quotes to start and end strings, you can simply use <code class="literal">$$</code>. Currently, there are two languages that have assigned a meaning to <code class="literal">$$</code>. In Perl, as well as in bash scripts, <code class="literal">$$</code> represents the process ID. To overcome this little obstacle, we can use <code class="literal">$</code> before almost anything to start and end the string. The following example shows how that works:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE OR REPLACE FUNCTION mysum(int, int) RETURNS int AS 
$body$ 
   SELECT $1 + $2; 
$body$ LANGUAGE 'sql';  
CREATE FUNCTION</strong></span></pre><p>All this flexibility allows you to really overcome the problem of quoting once and for all. As long as the start string and the end string match, there won't be any problems at all.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec53"></a>Making use of anonymous code blocks</h4></div></div></div><p>So far, we have written the most <span>simple</span><a id="id326299990" class="indexterm"></a> stored <span>procedures</span><a id="id326299998" class="indexterm"></a> possible, and also learned to execute code. However, there is more to code execution than just full-blown functions. In addition to functions, PostgreSQL allows the use of anonymous code blocks. The idea is to run code that is needed only once. This kind of code execution is especially useful to deal with administrative tasks. Anonymous code blocks don't take parameters and are not permanently stored in the database, as they don't have a name.</p><p>Here is a simple example showing an anonymous code block in action:</p><pre class="programlisting"><span class="strong"><strong>test=# DO 
$$ 
    BEGIN 
            RAISE NOTICE 'current time: %', now(); 
    END; 
$$ LANGUAGE 'plpgsql'; 
NOTICE: current time: 2016-12-12 15:25:50.678922+01 
CONTEXT: PL/pgSQL function inline_code_block line 3 at RAISE 
DO </strong></span></pre><p>In this example, the code only issues a message and quits. Again, the code block has to know which language it uses. The string is passed to PostgreSQL using simple dollar quoting.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec54"></a>Using functions and transactions</h4></div></div></div><p>As you know, everything that PostgreSQL <span>exposes</span><a id="id326300470" class="indexterm"></a> in user land is a transaction. The same, of course, applies if you are writing functions. A function is always part of the <span>transaction</span><a id="id326300480" class="indexterm"></a> you are in. It is not autonomous, just like an operator or any other operation.</p><p>Here is an example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT now(), mysum(id, id) FROM generate_series(1, 3) AS id;
 
 now                           | mysum 
-------------------------------+------- 
 2017-10-12 15:54:32.287027+01 |    2 
 2017-10-12 15:54:32.287027+01 |    4 
 2017-10-12 15:54:32.287027+01 |    6  
(3 rows)</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>All three function calls happen in the same transaction. This is important to understand because it implies that you cannot do too much transactional flow control inside a function. What happens when the the second function call commits? It just cannot work.</p><p>However, Oracle has a mechanism that allows for autonomous transactions. The idea is that even if a transaction rolls back, some parts might still be needed and should be kept. A classic example is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Start a function to look up secret data</li><li>Add a log line to the document to state that somebody has modified this important secret data</li><li>Commit the log line but roll back the change</li><li>Preserve the information that an attempt has been made to change data</li></ol></div><p>To solve problems such as this one, autonomous <span>transactions</span><a id="id326374075" class="indexterm"></a> can be used. The idea is to be able to commit a transaction inside the main <span>transaction</span><a id="id326472880" class="indexterm"></a> independently. In this case, the entry in the log table will prevail while the change will be rolled back.</p><p>As of PostgreSQL 11.0, autonomous transactions are not implemented. However, there are already patches floating around that implement this feature. It is to be seen as to when these features make it to the core.</p><p>To give you an impression of how things will most likely work, here is a code snippet based on the first patches:</p><pre class="programlisting"><span class="strong"><strong>... 
AS  
$$  
DECLARE 
  PRAGMA AUTONOMOUS_TRANSACTION;  
BEGIN 
  FOR i IN 0..9  LOOP  
    START  TRANSACTION; 
    INSERT INTO  test1  VALUES (i);  
    IF i % 2 = 0 THEN 
      COMMIT;  
    ELSE 
      ROLLBACK;  
    END IF; 
  END LOOP; 
  RETURN 42;  
END; 
$$; 
...</strong></span></pre><p>The point of this example is to show that we can decide on-the-fly whether to commit or to roll back the autonomous transaction.</p></div></div></div>