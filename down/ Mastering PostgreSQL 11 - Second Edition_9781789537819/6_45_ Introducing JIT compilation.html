<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec48"></a>Introducing JIT compilation</h2></div></div><hr /></div><p>JIT compilation has been one of THE hot topics in PostgreSQL 11. It has been a major undertaking an the first results look promising. However, let us <span>start</span><a id="id326254737" class="indexterm"></a> with the fundamentals: What is JIT compilation all about? When you run a query, PostgreSQL has to figure out a lot of stuff at runtime. When PostgreSQL itself is compiled, it does not know, which kind of query you will run next so it has to be prepared for all kinds of scenarios.</p><p> </p><p>The core is generic meaning that it can do all kinds of stuff. However, when you are in a query, you just want to execute the current query as fast as possible—not some other random stuff. The point is: At runtime you know a lot more about what you have to do than at compile time (= when PostgreSQL is compiled). That is exactly the point: When JIT compilation is enabled, PostgreSQL will check your query and if it happens to be time consuming enough, highly optimized code for your query will be created on the fly (Just in Time).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec76"></a>Configuring JIT</h3></div></div></div><p>In order to use JIT, it has to be <span>added</span><a id="id326254761" class="indexterm"></a> at compile time. The following configure options are available:</p><pre class="programlisting"><span class="strong"><strong> --with-llvm build with LLVM based JIT support</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong> LLVM_CONFIG path to llvm-config command</strong></span></pre><p>Some Linux distributions ship an extra package containing support for JIT. If you want to make use of JIT make sure those packages are installed.</p><p>Once you have made sure, JIT is available, the following configuration parameters will be available to fine-tune JIT compilation for your queries:</p><pre class="programlisting"><span class="strong"><strong>#jit = on                               # allow JIT compilation</strong></span>
<span class="strong"><strong>#jit_provider = 'llvmjit'               # JIT implementation to use</strong></span>
<span class="strong"><strong>#jit_above_cost = 100000                # perform JIT compilation if available</strong></span>
<span class="strong"><strong>                                        # and query more expensive, -1 disables</strong></span>
<span class="strong"><strong>#jit_optimize_above_cost = 500000       # optimize JITed functions if query is</strong></span>
<span class="strong"><strong>                                        # more expensive, -1 disables</strong></span>
<span class="strong"><strong>#jit_inline_above_cost = 500000         # attempt to inline operators and</strong></span>
<span class="strong"><strong>                                        # functions if query is more expensive,</strong></span>
<span class="strong"><strong>                                        # -1 disables</strong></span></pre><p><code class="literal">jit_above_cost</code> means that JIT is only considered if the expected cost is at least 100.000. Why is that relevant? If a query is not sufficiently long the overhead of compilation can be a lot higher than the potential gain. Therefore optimization is only attempted. However, there are two more parameters: Really deep optimizations are attempted if the query is considered to be more expensive than 500.000. In this case function calls will be inlined and all that.</p><p> </p><p>At this point PostgreSQL only supports LLVM as a JIT backend. Maybe additional backends will be available in the future as well. For now LLVM does a <span>really</span><a id="id325565395" class="indexterm"></a> good job and covers most environments used in professional environments.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec77"></a>Running queries</h3></div></div></div><p>To show how the JIT works,  we shall <span>compile</span><a id="id325565410" class="indexterm"></a> a simple example. Let's begin by creating a big table, one that contains a lot of data. Remember, JIT compilation is only useful if the operation is sufficiently large. For beginners, 50 million rows should suffice. The following example shows, how to populate the table.</p><pre class="programlisting"><span class="strong"><strong>jit=# CREATE TABLE t_jit AS </strong></span>
<span class="strong"><strong>         SELECT (random()*10000)::int AS x, (random()*100000)::int AS y, (random()*1000000)::int AS z </strong></span>
<span class="strong"><strong>         FROM generate_series(1, 50000000) AS id;</strong></span>
<span class="strong"><strong>SELECT 50000000</strong></span>
<span class="strong"><strong>jit=# VACUUM ANALYZE t_jit;</strong></span>
<span class="strong"><strong>VACUUM</strong></span></pre><p>In this case, we shall use the random function to generate some data. To show, how JIT works and to make executions plans easier to read, you can turn of parallel queries. JIT works fine with parallel queries but execution plans tend to be a lot longer:</p><pre class="programlisting"><span class="strong"><strong>jit=# SET max_parallel_workers_per_gather TO 0;</strong></span>
<span class="strong"><strong>SET</strong></span>
<span class="strong"><strong>jit=# SET jit TO off;</strong></span>
<span class="strong"><strong>SET</strong></span>
<span class="strong"><strong>jit=# explain (analyze, verbose) SELECT avg(z+y-pi()), avg(y-pi()), max(x/pi()) </strong></span>
<span class="strong"><strong>              FROM   t_jit </strong></span>
<span class="strong"><strong>              WHERE  ((y+z))&gt;((y-x)*0.000001);</strong></span>
<span class="strong"><strong>                                               QUERY PLAN       </strong></span>
<span class="strong"><strong>-------------------------------------------------------------------------------------------------------</strong></span>
<span class="strong"><strong> Aggregate  (cost=1936901.68..1936901.69 rows=1 width=24) </strong></span>
<span class="strong"><strong>            (actual time=20617.425..20617.425 rows=1 loops=1)</strong></span>
<span class="strong"><strong>   Output: avg((((z + y))::double precision - '3.14159265358979'::double precision)), </strong></span>
<span class="strong"><strong>           avg(((y)::double precision - '3.14159265358979'::double precision)), </strong></span>
<span class="strong"><strong>           max(((x)::double precision / '3.14159265358979'::double precision))</strong></span>
<span class="strong"><strong>       -&gt;  Seq Scan on public.t_jit  (cost=0.00..1520244.00 rows=16666307 width=12) </strong></span>
<span class="strong"><strong>           (actual time=0.061..15322.555 rows=50000000 loops=1)</strong></span>
<span class="strong"><strong>           Output: x, y, z</strong></span>
<span class="strong"><strong>           Filter: (((t_jit.y + t_jit.z))::numeric &gt; (((t_jit.y - t_jit.x))::numeric * 0.000001))</strong></span>
<span class="strong"><strong> Planning Time: 0.078 ms</strong></span>
<span class="strong"><strong> Execution Time: 20617.473 ms</strong></span>
<span class="strong"><strong>(7 rows)</strong></span></pre><p>In this case the <span>query</span><a id="id325664436" class="indexterm"></a> took 20 seconds.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note52"></a>Note</h3><p>I have done a <code class="literal">VACUUM</code> to ensure that all hint bits and so on are properly set to ensure a fair comparison between a jitted query and a normal query.</p></div><p>Let us repeat the test with JIT enabled:</p><pre class="programlisting"><span class="strong"><strong>jit=# SET jit TO on;</strong></span>
<span class="strong"><strong>SET</strong></span>
<span class="strong"><strong>jit=# explain (analyze, verbose) SELECT avg(z+y-pi()), avg(y-pi()), max(x/pi()) </strong></span>
<span class="strong"><strong>              FROM   t_jit </strong></span>
<span class="strong"><strong>              WHERE  ((y+z))&gt;((y-x)*0.000001);</strong></span>
<span class="strong"><strong>                                                 QUERY PLAN </strong></span>
<span class="strong"><strong>------------------------------------------------------------------------------------------------------</strong></span>
<span class="strong"><strong> Aggregate (cost=1936901.68..1936901.69 rows=1 width=24) </strong></span>
<span class="strong"><strong>           (actual time=17585.788..17585.789 rows=1 loops=1)</strong></span>
<span class="strong"><strong>   Output: avg((((z + y))::double precision - '3.14159265358979'::double precision)), </strong></span>
<span class="strong"><strong>         avg(((y)::double precision - '3.14159265358979'::double precision)), </strong></span>
<span class="strong"><strong>         max(((x)::double precision / '3.14159265358979'::double precision))</strong></span>
<span class="strong"><strong>      -&gt; Seq Scan on public.t_jit (cost=0.00..1520244.00 rows=16666307 width=12) </strong></span>
<span class="strong"><strong>         (actual time=81.991..13396.227 rows=50000000 loops=1)</strong></span>
<span class="strong"><strong>         Output: x, y, z</strong></span>
<span class="strong"><strong>         Filter: (((t_jit.y + t_jit.z))::numeric &gt; (((t_jit.y - t_jit.x))::numeric * 0.000001))</strong></span>
<span class="strong"><strong> Planning Time: 0.135 ms</strong></span>
<span class="strong"><strong> JIT:</strong></span>
<span class="strong"><strong>    Functions: 5</strong></span>
<span class="strong"><strong>    Options: Inlining true, Optimization true, Expressions true, Deforming true</strong></span></pre><p> </p><p> </p><pre class="programlisting"><span class="strong"><strong>    Timing: Generation 2.942 ms, Inlining 15.717 ms, Optimization 40.806 ms, Emission 25.233 ms, </strong></span>
<span class="strong"><strong>            Total 84.698 ms</strong></span>
<span class="strong"><strong> Execution Time: 17588.851 ms</strong></span>
<span class="strong"><strong>(11 rows)</strong></span></pre><p>In this case, you can see that the <span>query</span><a id="id325896131" class="indexterm"></a> is more than 10% faster than before, which is already significant. In some cases, the benefit can be even higher. However, keep in mind that recompiling code is also associated with some additional effort so it does not make sense for any kind of query.</p></div></div>