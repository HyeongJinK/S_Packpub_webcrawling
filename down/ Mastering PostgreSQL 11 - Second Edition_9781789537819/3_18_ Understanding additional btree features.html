<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec24"></a>Understanding additional btree features</h2></div></div><hr /></div><p>In PostgreSQL, indexing is a large field and covers <span>many</span><a id="id326512134" class="indexterm"></a> aspects of database work. As I have outlined in this book already, indexing is the key to performance. There is no good performance without proper indexing. Therefore, it is worth inspecting these indexing related features in more detail.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec26"></a>Combined indexes</h3></div></div></div><p>In my job, as a professional PostgreSQL <span>support</span><a id="id326512099" class="indexterm"></a> vendor, I am often asked about the <span>difference</span><a id="id326512089" class="indexterm"></a> between combined and individual indexes. In this section, I will try to shed some light on this question.</p><p>The general rule is that if a single index can answer your question, it is usually the best choice. However, you cannot index all possible combinations of fields people are filtering on. What you can do is use the properties of combined indexes to achieve as much gain as possible.</p><p>Let's suppose we have a table containing three columns: <code class="literal">postal_code</code>, <code class="literal">last_name</code>, and <code class="literal">first_name</code>. A telephone book would make use of a combined index like this. You will see that data is ordered by location. Within the same location, data will be sorted by last name and first name.</p><p>The following table shows which operations are possible given the three column index:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Query</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Possible</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Remarks</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">postal_code = 2700 AND last_name = 'Schönig' AND first_name = 'Hans'</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is the ideal use case for this index.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">postal_code = 2700 AND</code></p><p><code class="literal">last_name = 'Schönig'</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>No restrictions.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">last_name = 'Schönig AND</code></p><p><code class="literal">postal_code = 2700</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>PostgreSQL will simply swap conditions.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">postal_code = 2700</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is just like an index on <code class="literal">postal_code</code>; the combined index just needs more space on the disk.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">first_name = 'Hans'</code></p></td><td style="border-right: 0.5pt solid ; "><p>Yes, but a different use case</p></td><td style=""><p>PostgreSQL cannot use the sorted property of the index anymore. However, in some rare cases (usually very broad tables, including countless columns), PostgreSQL will scan the entire index if it is as cheap as reading the very broad table.</p></td></tr></tbody></table></div><p> </p><p>If columns are indexed separately, you will most likely end up seeing bitmap scans. Of course, a single hand-tailored index is better.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"></a>Adding functional indexes</h3></div></div></div><p>So far, you have seen <span>how</span><a id="id326216422" class="indexterm"></a> to index the content of a column as it is. However, this might not always be what you really want. Therefore, PostgreSQL allows the creation of <span>functional</span><a id="id326216430" class="indexterm"></a> indexes. The basic idea is very simple; instead of indexing a value, the output of a function is stored in the index.</p><p>The following example shows how the cosine of the <code class="literal">id</code> column can be indexed:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE INDEX idx_cos ON t_random (cos(id));</strong></span>
<span class="strong"><strong>CREATE INDEX</strong></span>
<span class="strong"><strong>test=# ANALYZE;  
ANALYZE</strong></span></pre><p>All you have to do is put the function on the list of columns and you are done. Of course, this won't work for all kinds of functions. Functions can only be used if their output is immutable:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT age('2010-01-01 10:00:00'::timestamptz); 
           age 
------------------------- 
 6 years 9 mons 14:00:00 
(1 row)
</strong></span></pre><p>Functions such as age are not really suitable for indexing because their output is not constant. Time goes on and consequently, the output of age will change too. PostgreSQL will explicitly prohibit functions that have the potential to change their result given the <span>same</span><a id="id326453739" class="indexterm"></a> input. The <code class="literal">cos</code> function is fine in this respect because the cosine of a value will still be the <span>same</span><a id="id326453751" class="indexterm"></a> in 1,000 years from now.</p><p>To test the index, I have written a simple query to show what will happen:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT * FROM t_random WHERE cos(id) = 10;</strong></span>
<span class="strong"><strong>                         QUERY PLAN </strong></span>
<span class="strong"><strong>---------------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Index Scan using idx_cos on t_random (cost=0.43..8.45 rows=1 width=9) </strong></span>
<span class="strong"><strong>   Index Cond: (cos((id)::double precision) = '10'::double precision) </strong></span>
<span class="strong"><strong>(2 rows)</strong></span></pre><p>As expected, the functional index will be used just like any other index.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec28"></a>Reducing space consumption</h3></div></div></div><p>Indexing is nice and its main <span>purpose</span><a id="id326453901" class="indexterm"></a> is to <span>speed</span><a id="id326453915" class="indexterm"></a> up things as much as possible. As with all the good stuff, indexing comes with a price tag: space consumption. To do its magic, an index has to store values in an organized fashion. If your table contains 10 million integer values, the index belonging to the table will logically contain these 10 million integer values plus additional overhead.</p><p>A btree will contain a pointer to each row in the table, and so it is certainly not free of charge. To figure out <span>how</span><a id="id326453927" class="indexterm"></a> much space an index will need, you can ask the <code class="literal">psql</code> using the <code class="literal">di+</code> command:</p><pre class="programlisting"><span class="strong"><strong>test=# \di+ 
                         List of relations 
 Schema | Name       | Type  | Owner | Table    | Size 
--------+------------+-------+-------+----------+------- 
 public | idx_cos    | index | hs    | t_random | 86 MB 
 public | idx_id     | index | hs    | t_test   | 86 MB 
 public | idx_name   | index | hs    | t_test   | 86 MB 
 public | idx_random | index | hs    | t_random | 86 MB 
(4 rows)
</strong></span></pre><p>In my database, the staggering amount of 344 MB has been burned to store these indexes. Now, compare this to the amount of storage burned by the underlying tables:</p><pre class="programlisting"><span class="strong"><strong>test=# \d+ 
</strong></span><span class="strong"><strong>                         List of relations </strong></span>
<span class="strong"><strong> Schema | Name          | Type     | Owner | Size </strong></span>
<span class="strong"><strong>--------+---------------+----------+-------+------------ </strong></span>
<span class="strong"><strong> public | t_random      | table    | hs    | 169 MB </strong></span>
<span class="strong"><strong> public | t_test        | table    | hs    | 169 MB </strong></span>
<span class="strong"><strong> public | t_test_id_seq | sequence | hs    | 8192 bytes </strong></span>
<span class="strong"><strong>(3 rows)</strong></span></pre><p>The size of both tables combined is just 338 MB. In other words, our indexing needs more space than the actual data. In the real world, this is common and actually pretty likely. Recently, I visited a Cybertec customer in Germany and I saw a database in which 64% of the database size was made up of indexes that were never used (not a single time over the period of months). So, over-indexing can be an issue just like under-indexing. Remember, these indexes don't just consume space. Every <code class="literal">INSERT</code> or <code class="literal">UPDATE</code> must maintain the values in the indexes as well. In extreme cases, such as our example, this vastly decreases write throughput.</p><p> </p><p> </p><p>If there are just a <span>handful</span><a id="id326454099" class="indexterm"></a> of different <span>values</span><a id="id326511657" class="indexterm"></a> in the table, partial indexes are a solution:</p><pre class="programlisting"><span class="strong"><strong>test=# DROP INDEX idx_name; 
DROP INDEX 
test=# CREATE INDEX idx_name ON t_test (name) 
         WHERE name NOT IN ('hans', 'paul'); 
CREATE INDEX</strong></span></pre><p>In this case, the majority has been excluded from the index and a small, efficient index can be enjoyed:</p><pre class="programlisting"><span class="strong"><strong>test=# \di+ idx_name 
                        List of relations 
 Schema | Name     | Type  | Owner | Table  | Size 
--------+----------+-------+-------+--------+----------- 
 public | idx_name | index | hs    | t_test | 8192 bytes 
(1 row)
</strong></span></pre><p>Note that it only makes sense to exclude very frequent values that make up a large part of the table (at least 25% or so). Ideal candidates for partial indexes are gender (we assume that most people are male or female), nationality (assuming that most people in your country have the same nationality), and so on. Of course, applying this kind of trickery requires some deep knowledge of your data, but it certainly pays off.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec29"></a>Adding data while indexing</h3></div></div></div><p>Creating an index is easy. However, keep in mind that you <span>cannot</span><a id="id326511689" class="indexterm"></a> modify a table while an index is being built. The <code class="literal">CREATE INDEX</code> command will lock up the table using a <code class="literal">SHARE</code> lock to ensure that no changes happen. While this is clearly no problem for small tables, it will cause issues on large ones on production systems. Indexing a terabyte of data or so will take some time and therefore, blocking a table for too long can become an issue.</p><p>The solution to the problem is the <code class="literal">CREATE INDEX CONCURRENTLY</code> command. Building the index will take a lot longer (usually at least twice as long), but you can use the table normally during index creation.</p><p>Here is how it works:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE INDEX CONCURRENTLY idx_name2 ON t_test (name); 
CREATE INDEX</strong></span></pre><p>Note that PostgreSQL does not guarantee success if you are using the <code class="literal">CREATE INDEX CONCURRENTLY</code> command. An index can end up being marked as invalid if the operations going on on your system somehow conflict with the index creation. If you want to figure out, if indexes are invalid, use \d on the relation.</p></div></div>