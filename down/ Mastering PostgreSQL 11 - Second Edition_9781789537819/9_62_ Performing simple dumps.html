<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec62"></a>Performing simple dumps</h2></div></div><hr /></div><p>If you are running a PostgreSQL setup, there are <span>basically</span><a id="id325995113" class="indexterm"></a> two major methods to perform backups:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Logical dumps (extract an SQL script representing your data)</li><li style="list-style-type: disc">Transaction log shipping</li></ul></div><p>The idea behind transaction log shipping is to archive binary changes made to the database. Most people claim that transaction log shipping is the only real way to do backups. However, in my opinion, this is not necessarily true.</p><p> </p><p>Many people rely on <code class="literal">pg_dump</code> to simply extract a textual representation of the data. Interestingly, <code class="literal">pg_dump</code> is also the oldest method of creating a backup and has been around since the very early days of the PostgreSQL project (transaction log shipping was added much later). Every PostgreSQL administrator will become familiar with <code class="literal">pg_dump</code> sooner or later, so it is important to know how it really works and what it does.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec93"></a>Running pg_dump</h3></div></div></div><p>The first thing we want to do is <span>create</span><a id="id326015137" class="indexterm"></a> a simple <span>textual</span><a id="id326015102" class="indexterm"></a> dump:</p><pre class="programlisting"><span class="strong"><strong>[hs@linuxpc ~]$ pg_dump test &gt; /tmp/dump.sql</strong></span></pre><p>This is the most simplistic backup you can imagine. Basically, <code class="literal">pg_dump</code> logs in to the local database instance, connects to a database test, and starts to extract all the data, which will then be sent to <span>stdout</span> and redirected to the file. The beauty, here, is that the standard output gives you all the flexibility of a Unix system. You can easily compress the data using a pipe or do whatever you want to do with it.</p><p>In some cases, you might want to run <code class="literal">pg_dump</code> as a different user. All PostgreSQL client programs support a consistent set of command-line parameters to pass user information. If you just want to set the user, use the <code class="literal">-U</code> flag as follows:</p><pre class="programlisting"><span class="strong"><strong>[hs@linuxpc ~]$ pg_dump -U whatever_powerful_user test &gt; /tmp/dump.sql</strong></span></pre><p>The following set of parameters can be found in all PostgreSQL client programs:</p><pre class="programlisting"><span class="strong"><strong>... 
Connection options: 
  -d, --dbname=DBNAME database to dump 
  -h, --host=HOSTNAME database server host or 
                           socket directory 
  -p, --port=PORT database server port number 
  -U, --username=NAME connect as specified database user 
  -w, --no-password never prompt for password 
  -W, --password force password prompt (should 
                           happen automatically) 
  --role=ROLENAME do SET ROLE before dump 
...</strong></span></pre><p>You can just pass the information you want to <code class="literal">pg_dump</code>, and if you have enough permissions, PostgreSQL will fetch the data. The important thing here is to see how the program really works. Basically, <code class="literal">pg_dump</code> connects to the database and opens a large repeatable read transaction that simply reads all the data. Remember, a repeatable read ensures that PostgreSQL creates a consistent snapshot of the data, which does not change throughout the transactions. In other words, a dump is always consistent—no foreign keys will be violated. The output is a snapshot of data as it was when the dump started. Consistency is a key factor here. It also implies that changes made to the data while the dump is running won't make it to the backup anymore.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip69"></a>Note</h3><p>A dump simply reads everything—therefore, there are no separate permissions to be able to dump something. As long as you can read it, you can back it up.</p></div><p>Also note that the backup is in a <span>textual</span><a id="id326543036" class="indexterm"></a> format by default. This <span>means</span><a id="id326543047" class="indexterm"></a> that you can safely extract data from say, Solaris, and move it to some other CPU architecture. In the case of binary copies, this is clearly not possible as the on-disk format depends on your CPU architecture.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec94"></a>Passing passwords and connection information</h3></div></div></div><p>If you take a close look at the <span>connection</span><a id="id326543066" class="indexterm"></a> parameters <span>shown</span><a id="id326637159" class="indexterm"></a> in the previous section, you will notice that there is no way to pass a password to <code class="literal">pg_dump</code>. You can enforce a password prompt, but you cannot pass the parameter to <code class="literal">pg_dump</code> using a command-line option.</p><p>The reason for this is simply <span>because</span><a id="id326637176" class="indexterm"></a> the password might show up in the process table and be visible to other people. The question now is, if <code class="literal">pg_hba.conf</code>, which is on the server, enforces a password, how can the client program provide it?</p><p>There are various means of doing this. Some of them are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Making use of environment variables</li><li style="list-style-type: disc">Making use of <code class="literal">.pgpass</code></li><li style="list-style-type: disc">Using service files</li></ul></div><p>In this section, we will learn about all three methods.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec78"></a>Using environment variables</h4></div></div></div><p>One way to pass all kinds of <span>parameters</span><a id="id326637212" class="indexterm"></a> is to use environment variables. If information is not explicitly passed to <code class="literal">pg_dump</code>, it will look for the missing information in predefined environment variables. A list of all potential settings can be <span>found</span><a id="id326637225" class="indexterm"></a> at <a class="ulink" href="https://www.postgresql.org/docs/11/static/libpq-envars.html" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>s</span><span>://</span><span>w</span><span>w</span><span>w</span><span>.</span><span>p</span><span>o</span><span>s</span><span>t</span><span>g</span><span>r</span><span>e</span><span>s</span><span>q</span><span>l</span><span>.</span><span>o</span><span>r</span><span>g</span><span>/</span><span>d</span><span>o</span><span>c</span><span>s</span><span>/</span><span>11</span><span>/</span><span>s</span><span>t</span><span>a</span><span>t</span><span>i</span><span>c</span><span>/</span><span>l</span><span>i</span><span>b</span><span>p</span><span>q</span><span>-</span><span>e</span><span>n</span><span>v</span><span>a</span><span>r</span><span>s</span><span>.</span><span>h</span><span>t</span><span>m</span><span>l</span></a>.</p><p>The following overview shows some of the environment variables that are commonly needed for backups:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">PGHOST</code>: It tells the system which host to connect to</li><li style="list-style-type: disc"><code class="literal">PGPORT</code>: It defines the TCP port to be used</li><li style="list-style-type: disc"><code class="literal">PGUSER</code>: It tells a client program about the desired user</li><li style="list-style-type: disc"><code class="literal">PGPASSWORD</code>: It contains the password to be used</li><li style="list-style-type: disc"><code class="literal">PGDATABASE</code>: It is the name of the database to connect to</li></ul></div><p>The advantage of these environments is that the password won't show up in the process table. However, there's more. Consider the following example:</p><pre class="programlisting"><span class="strong"><strong>psql  -U ... -h ... -p ... -d ...</strong></span></pre><p>Given that you are a system administrator, would you really want to type a long piece of code such as this, a couple of times, every day? If you are working with the very same host again and again, just set those environment variables and connect with plain SQL. The following listing shows, how to connect:</p><pre class="programlisting"><span class="strong"><strong>[hs@linuxpc ~]$ export </strong></span><span class="strong"><strong>PGHOST=localhost</strong></span><span class="strong"><strong>[hs@linuxpc ~]$ export PGUSER=hs</strong></span><span class="strong"><strong>[hs@linuxpc ~]$ export PGPASSWORD=abc</strong></span><span class="strong"><strong>[hs@linuxpc ~]$ export PGPORT=5432</strong></span><span class="strong"><strong>[hs@linuxpc ~]$ export PGDATABASE=test</strong></span><span class="strong"><strong>[hs@linuxpc ~]$ psql</strong></span><span class="strong"><strong>psql (11.0)</strong></span><span class="strong"><strong>Type "help" for help.</strong></span></pre><p>As you can see, there are no command-line <span>parameters</span><a id="id325648453" class="indexterm"></a> anymore. Just type <code class="literal">psql</code> and you are in.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip70"></a>Note</h3><p>All applications based on the standard PostgreSQL C language client library (<code class="literal">libpq</code>) will understand these environment variables, so you can use them not only for <code class="literal">psql</code> and <code class="literal">pg_dump</code>, but for many other applications.</p></div><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec79"></a>Making use of .pgpass</h4></div></div></div><p>A very common way to store login <span>information</span><a id="id325648492" class="indexterm"></a> is via the use of <code class="literal">.pgpass</code> files. The idea is simple: put a file called <code class="literal">.pgpass</code> into your home directory and put your login information there. The format is simple:</p><pre class="programlisting"><span class="strong"><strong>hostname:port:database:username:password</strong></span></pre><p>An example would be the following:</p><pre class="programlisting"><span class="strong"><strong>192.168.0.45:5432:mydb:xy:abc</strong></span></pre><p>PostgreSQL offers some nice additional functionality, where most fields can contain <code class="literal">*</code>. Here is an example:</p><pre class="programlisting"><span class="strong"><strong>*:*:*:xy:abc</strong></span></pre><p>The * implies that on every host, on every port, for every database, the user called <code class="literal">xy</code> will use <code class="literal">abc</code> as the password. To make PostgreSQL use the <code class="literal">.pgpass</code> file, make sure that the right file permissions are in place:</p><pre class="programlisting"><span class="strong"><strong>chmod 0600 ~/.pgpass</strong></span></pre><p>Furthermore, <code class="literal">.pgpass</code> can also be used on a Windows system. In this case, the file can be found in the <code class="literal">%APPDATA%\postgresql\pgpass.conf</code> path.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl3sec80"></a>Using service files</h4></div></div></div><p>However, <code class="literal">.pgpass</code> is not the only file you can use. You can also make use of service files. Here is how it works. If you want to connect to the very same servers over and over again, you can create a <code class="literal">.pg_service.conf</code> file. It will hold all of the connection <span>information</span><a id="id325881261" class="indexterm"></a> you need.</p><p>Here is an example of a <code class="literal">.pg_service.conf</code> file:</p><pre class="programlisting"><span class="strong"><strong>Mac:~  hs$ cat .pg_service.conf</strong></span>
<span class="strong"><strong># a sample service 
[hansservice] 
host=localhost 
port=5432 
dbname=test 
user=hs 
password=abc 
 
[paulservice] 
host=192.168.0.45 
port=5432 
dbname=xyz 
user=paul 
password=cde</strong></span></pre><p>To connect to one of the services, just set the environment and connect:</p><pre class="programlisting"><span class="strong"><strong>iMac:~ hs$ export PGSERVICE=hansservice</strong></span></pre><p>A connection can now be established without passing parameters to <code class="literal">psql</code>:</p><pre class="programlisting"><span class="strong"><strong>iMac:~ hs$ psql</strong></span><span class="strong"><strong>psql (11.0)</strong></span><span class="strong"><strong>Type "help" for help. </strong></span><span class="strong"><strong>test=#</strong></span></pre><p>Alternatively, you <span>can</span><a id="id325887838" class="indexterm"></a> use the following:</p><pre class="programlisting"><span class="strong"><strong>psql service=hansservice</strong></span></pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec95"></a>Extracting subsets of data</h3></div></div></div><p>Up until now, we have <span>seen</span><a id="id325887860" class="indexterm"></a> how to dump an entire database. However, this is not what we might wish for. In many cases, we just want to extract a subset of tables or schemas.  Fortunately, <code class="literal">pg_dump</code> can help us do that while also providing a number of switches:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">-a</code>: It only dumps the data and does not dump the data structure</li><li style="list-style-type: disc"><code class="literal">-s</code>: It dumps the data structure but skips the data</li><li style="list-style-type: disc"><code class="literal">-n</code>: It only dumps a certain schema</li><li style="list-style-type: disc"><code class="literal">-N</code>: It dumps everything but excludes certain schemas</li><li style="list-style-type: disc"><code class="literal">-t</code>: It only dumps certain tables</li><li style="list-style-type: disc"><code class="literal">-T</code>: It dumps everything but certain tables (this can make sense if you want to exclude logging tables and so on)</li></ul></div><p>Partial dumps can be very useful in order to speed things up considerably.</p><p> </p></div></div>