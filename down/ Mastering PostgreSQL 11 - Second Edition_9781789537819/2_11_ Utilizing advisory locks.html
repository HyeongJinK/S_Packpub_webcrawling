<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>Utilizing advisory locks</h2></div></div><hr /></div><p>PostgreSQL has a highly efficient and <span>sophisticated</span><a id="id325654135" class="indexterm"></a> transaction machinery that is capable of handling locks in a really fine-grained and efficient way. Some years ago, some people came up with the idea of using this code to synchronize applications with each other.</p><p>Thus, advisory locks were born.</p><p>When using advisory locks, it is important to mention that they won't go away on <code class="literal">COMMIT</code> as normal locks do. Therefore, it is really important to make sure that unlocking is done properly and in a totally reliable way.</p><p>If you decide to use an advisory lock, what you really lock is a number. So, this is not about rows or data; it is really just a number. Here is how it works:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Session 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Session 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT pg_advisory_lock(15);</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT pg_advisory_lock(15);</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p>It has to wait</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">COMMIT;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>It still has to wait</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT pg_advisory_unlock(15);</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>It still waiting</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p></p></td><td style=""><p>Lock is taken</p></td></tr></tbody></table></div><p>Â </p><p>The first transaction will lock <code class="literal">15</code>. The second transaction has to wait until this number has been unlocked again. The second session will even wait after the first one has committed. This is highly important as you cannot rely on the fact that the end of the transaction will nicely and miraculously solve things for you.</p><p>If you want to unlock all locked numbers, PostgreSQL offers the <code class="literal">pg_advisory_unlock_all()</code> function to do exactly this:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT pg_advisory_unlock_all(); 
pg_advisory_unlock_all </strong></span>
<span class="strong"><strong>------------------------</strong></span>
<span class="strong"><strong>
(1 row)</strong></span></pre><p>Sometimes, you might want to see if you can get a lock and error out if it is not possible. To achieve this, PostgreSQL offers a couple of functions; to see a list of all such <span>available</span><a id="id325606864" class="indexterm"></a> functions, at the command line, enter: <code class="literal">\df *try*advisory*</code>.</p></div>