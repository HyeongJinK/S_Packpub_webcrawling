<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec72"></a>Making use of replication slots</h2></div></div><hr /></div><p>After that introduction to synchronous replication and dynamically adjustable durability, I want to focus on a feature called the <span>replication</span><a id="id326299988" class="indexterm"></a> slot.</p><p>What is the purpose of a replication slot? Let's consider the following example: there is a master and a slave. On the master, a large transaction is executed and the network connection is not fast enough to ship all the data in time. At some point, the master removes its transaction log (checkpoint). If the slave is too far behind, a re-sync is needed. As we have already seen, the <code class="literal">wal_keep_segments</code> setting can be used to reduce the risk of failing replication. The question is this: what is the best value for the <code class="literal">wal_keep_segments</code> setting? Sure, more is better, but how much is best?</p><p>Replication slots will solve this problem for us: if we are using a <span>replication</span><a id="id326234465" class="indexterm"></a> slot, a master can only recycle the transaction log once it has been consumed by all replicas. The advantage here is that a slave can never fall behind so much that a re-sync is needed.</p><p>The trouble is, suppose we shut down a replica without telling the master about it. The master would keep a transaction log forever and the disk on the primary server would eventually fill up, causing unnecessary downtime.</p><p>To reduce this risk for the master, replication slots should only be used in conjunction with proper monitoring and alerting. It is simply necessary to keep an eye on open replication slots that could potentially cause issues, or might not be in use anymore.</p><p>In PostgreSQL, there are two types of replication slot:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Physical replication slots</li><li style="list-style-type: disc">Logical replication slots</li></ul></div><p>Physical replication slots can be used for standard streaming replication. They will make sure that data is not recycled too early. Logical replication slots do the same thing. However, they are used for logical decoding. The idea behind logical decoding is to give users a chance to attach to the transaction log and decode it with a plugin. A logical transaction slot is therefore some sort of tail <code class="literal">-f</code> for database instances. It allows the user to extract changes made to the database—and therefore to the transaction log –in any format and for any purpose. In many cases, a logical replication slot is used for <span>logical</span><a id="id326234440" class="indexterm"></a> replication.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec111"></a>Handling physical replication slots</h3></div></div></div><p>To make use of <span>replication</span><a id="id326234423" class="indexterm"></a> slots, changes have to be made to the <code class="literal">postgresql.conf</code> file:</p><pre class="programlisting"><span class="strong"><strong>wal_level = logical</strong></span>
<span class="strong"><strong>max_replication_slots = 5    # or whatever number is needed</strong></span></pre><p>With physical slots, logical is not yet necessary—replica is enough. However, for logical slots, we need a higher <code class="literal">wal_level</code> setting. Then, the <code class="literal">max_replication_slots</code> setting has to be changed if we are using PostgreSQL 9.6 or below. PostgreSQL 10.0 already has the <span>improved</span><a id="id326084850" class="indexterm"></a> default setting. Basically, just put in a number that serves our purpose. My recommendation is to add some spare slots so that we can easily attach more consumers without restarting the server along the way.</p><p>After a restart, the slot can be created:</p><pre class="programlisting"><span class="strong"><strong>test=# \x</strong></span>
<span class="strong"><strong>Expanded display </strong></span><span class="strong"><strong>is on.</strong></span>

<span class="strong"><strong>postgres=# \df *create*physical*slot*</strong></span>
<span class="strong"><strong>List of functions</strong></span>
<span class="strong"><strong>-[ RECORD 1 ]------...</strong></span>
<span class="strong"><strong>Schema                | pg_catalog</strong></span>
<span class="strong"><strong>Name                  | pg_create_physical_replication_slot</strong></span>
<span class="strong"><strong>Result data type      | record</strong></span>
<span class="strong"><strong>Argument data types   | slot_name name, </strong></span>
<span class="strong"><strong>                        immediately_reserve boolean DEFAULT false, </strong></span>
<span class="strong"><strong>                        temporary boolean DEFAULT false, </strong></span>
<span class="strong"><strong>                        OUT slot_name name, </strong></span>
<span class="strong"><strong>                        OUT lsn pg_lsn</strong></span>
<span class="strong"><strong>Type                  | func</strong></span>

</pre><p>The <code class="literal">pg_create_physical_replication_slot</code> function is here to help us create the slot. It can be called with one of two parameters: if only a slot name is passed, the slot will be active when it is used for the first time. If <code class="literal">true</code> is passed as the second parameter, the slot will immediately start to conserve the transaction log:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT * FROM pg_create_physical_replication_slot('some_slot_name', true);</strong></span>
<span class="strong"><strong> slot_name       </strong></span><span class="strong"><strong>| lsn</strong></span>
<span class="strong"><strong>-----------------+--------------- 
 some_slot_name  </strong></span><span class="strong"><strong>| 0/EF8AD1D8</strong></span>

<span class="strong"><strong>(1 row)</strong></span></pre><p>To see which slots are active on the master, consider running the following SQL statement:</p><pre class="programlisting"><span class="strong"><strong>test=# \x</strong></span>
<span class="strong"><strong>Expanded display is on.</strong></span>
<span class="strong"><strong>test=# SELECT * FROM pg_replication_slots;</strong></span>
<span class="strong"><strong>-[ RECORD 1 ]-------+---------------</strong></span>
<span class="strong"><strong>slot_name           | some_slot_name</strong></span>
<span class="strong"><strong>plugin              | </strong></span>
<span class="strong"><strong>slot_type           | physical</strong></span>
<span class="strong"><strong>datoid              | </strong></span>
<span class="strong"><strong>database            | </strong></span>
<span class="strong"><strong>temporary           | f</strong></span>
<span class="strong"><strong>active              | f</strong></span>
<span class="strong"><strong>active_pid          | </strong></span>
<span class="strong"><strong>xmin                | </strong></span>
<span class="strong"><strong>catalog_xmin        | </strong></span>
<span class="strong"><strong>restart_lsn         | 0/1653398</strong></span>
<span class="strong"><strong>confirmed_flush_lsn | </strong></span></pre><p>The view will tell us a lot about the slot. It contains information about the type of slot in use, the transaction log positions, and more.</p><p>To make use of the slot, all we have to do is add it to the <code class="literal">recovery.conf</code> file:</p><pre class="programlisting"><span class="strong"><strong>primary_slot_name = 'some_slot_name'</strong></span></pre><p>Once streaming is restarted, the slot will be used directly and protect replication. If we don't want our slot anymore, we can drop it easily:</p><pre class="programlisting"><span class="strong"><strong>test=# \df *drop*slot*</strong></span>
<span class="strong"><strong>List of functions</strong></span>
<span class="strong"><strong>-[ RECORD 1 ]-------+-------------------------
Schema              | pg_catalog</strong></span>
<span class="strong"><strong>Name                | pg_drop_replication_slot</strong></span>
<span class="strong"><strong>Result </strong></span><span class="strong"><strong>data type    | void 
Argument data types | name 
Type                | normal</strong></span></pre><p>When a slot is dropped, there is no <span>distinction</span><a id="id326660001" class="indexterm"></a> between a <span>logical</span><a id="id326660010" class="indexterm"></a> and a physical slot anymore. Just pass the name of the slot to the function and execute it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip86"></a>Note</h3><p>Nobody is allowed to use the slot when it is dropped. Otherwise, PostgreSQL will error out with good reason.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec112"></a>Handling logical replication slots</h3></div></div></div><p>Logical <span>replication</span><a id="id326660509" class="indexterm"></a> slots are essential to logical replication. Due to space limitations in this chapter, it is unfortunately not possible to cover all aspects of logical replication. However, I want to outline some of the basic concepts that are essential for logical decoding and therefore, also, for logical replication.</p><p>If we want to create a replication slot, here is how it works. The function needed here takes two parameters: the first one will define the name of the <span>replication</span><a id="id326660520" class="indexterm"></a> slot, while the second one carries the plugin used to decode the transaction log. It will determine the format PostgreSQL is going to use to return the data:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT * 
</strong></span><span class="strong"><strong>FROM pg_create_logical_replication_slot('logical_slot', </strong></span><span class="strong"><strong>'test_decoding');</strong></span>
<span class="strong"><strong> slot_name     </strong></span><span class="strong"><strong>| lsn</strong></span>
<span class="strong"><strong>---------------+--------------- 
 logical_slot  </strong></span><span class="strong"><strong>| 0/EF8AD4B0</strong></span>

<span class="strong"><strong>(1 row)</strong></span></pre><p>We can check for the existence of the slot using the same command as earlier. To check what a slot really does, a small test can be created:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE TABLE t_demo (id int, name text, payload text);</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span>
<span class="strong"><strong>test=#BEGIN;</strong></span>
<span class="strong"><strong>BEGIN</strong></span>
<span class="strong"><strong>test=# INSERT </strong></span><span class="strong"><strong>INTO t_demo</strong></span>
<span class="strong"><strong>VALUES </strong></span><span class="strong"><strong>(1, 'hans', 'some data');</strong></span>
<span class="strong"><strong>INSERT </strong></span><span class="strong"><strong>0 1</strong></span>
<span class="strong"><strong>test=# INSERT </strong></span><span class="strong"><strong>INTO t_demo </strong></span><span class="strong"><strong>VALUES </strong></span><span class="strong"><strong>(2, 'paul', 'some more data');</strong></span>
<span class="strong"><strong>INSERT </strong></span><span class="strong"><strong>0 1</strong></span>
<span class="strong"><strong>test=# COMMIT;</strong></span>
<span class="strong"><strong>COMMIT</strong></span>
<span class="strong"><strong>test=# INSERT </strong></span><span class="strong"><strong>INTO t_demo </strong></span><span class="strong"><strong>VALUES </strong></span><span class="strong"><strong>(3, 'joe', 'less data');</strong></span>
<span class="strong"><strong>INSERT </strong></span><span class="strong"><strong>0 1</strong></span></pre><p>Note that two transactions were executed. The changes made to those transactions can now be extracted from the slot:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT pg_logical_slot_get_changes('logical_slot', NULL, NULL);</strong></span>
<span class="strong"><strong>                      pg_logical_slot_get_changes </strong></span>
<span class="strong"><strong>-----------------------------------------------------------------------</strong></span>
<span class="strong"><strong> (0/EF8AF5B0,606546,"BEGIN 606546") </strong></span>
<span class="strong"><strong> (0/EF8CCCA0,606546,"COMMIT 606546") </strong></span>
<span class="strong"><strong> (0/EF8CCCD8,606547,"BEGIN 606547") </strong></span>
<span class="strong"><strong> (0/EF8CCCD8,606547,"table public.t_demo: INSERT: id[integer]:1 </strong></span>
<span class="strong"><strong>    name[text]:'hans' payload[text]:'some data'") </strong></span>
<span class="strong"><strong> (0/EF8CCD60,606547,"table public.t_demo: INSERT: id[integer]:2 </strong></span>
<span class="strong"><strong>    name[text]:'paul' payload[text]:'some more data'") </strong></span>
<span class="strong"><strong> (0/EF8CCDE0,606547,"COMMIT 606547") </strong></span>
<span class="strong"><strong> (0/EF8CCE18,606548,"BEGIN 606548") </strong></span>
<span class="strong"><strong> (0/EF8CCE18,606548,"table public.t_demo: INSERT: id[integer]:3 </strong></span>
<span class="strong"><strong>   name[text]:'joe' payload[text]:'less data'") </strong></span>
<span class="strong"><strong> (0/EF8CCE98,606548,"COMMIT 606548") </strong></span>
<span class="strong"><strong>(9 rows)</strong></span></pre><p>The format used here depends on the output plugin we chose previously. There are various output plugins for PostgreSQL, such as <code class="literal">wal2json</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note87"></a>Note</h3><p>If default values are used, the logical stream will contain real values and not just functions. The logical stream has the data that ended up in the underlying tables.</p></div><p>Also, keep in mind that the slot does not return data anymore once it is consumed:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT pg_logical_slot_get_changes('logical_slot', NULL, NULL);</strong></span>
<span class="strong"><strong> pg_logical_slot_get_changes</strong></span>
<span class="strong"><strong>-----------------------------</strong></span>
<span class="strong"><strong>(0 rows)</strong></span></pre><p>The result set on the second call is therefore empty. If we want to fetch data repeatedly, PostgreSQL offers the <code class="literal">pg_logical_slot_peek_changes</code> function. It works just like the <code class="literal">pg_logical_slot_get_changes</code> function, but assures that data will still be available in the slot.</p><p>Using plain SQL is, of course, not the only way to consume a transaction log. There is also a command-line tool called <code class="literal">pg_recvlogical</code>. It can be compared to doing tail <code class="literal">-f</code> on an entire database instance and receives the flow of data in real time.</p><p>Let's start the <code class="literal">pg_recvlogical</code> command:</p><pre class="programlisting"><span class="strong"><strong>[hs@zenbook ~]$ pg_recvlogical -S logical_slot -P test_decoding 
                   -d test -U postgres --start -f -</strong></span></pre><p>In this case, the tool connects to the test database and consumes data from the <code class="literal">logical_slot</code>. <code class="literal">-f</code>  means that the stream will be sent to <code class="literal">stdout</code>. Let's kill some data:</p><pre class="programlisting"><span class="strong"><strong>test=# DELETE FROM t_demo WHERE id &lt; random()*10;</strong></span>
<span class="strong"><strong>DELETE 3</strong></span></pre><p>The changes will make it into the transaction log. However, by default, the database only cares about what the table will look like after the deletion. It knows which blocks have to be touched and so on, but it does not know what it was previously:</p><pre class="programlisting"><span class="strong"><strong>BEGIN 606549</strong></span>
<span class="strong"><strong>table public.t_demo: DELETE: (no-tuple-data)</strong></span>
<span class="strong"><strong>table public.t_demo: DELETE: (no-tuple-data)</strong></span>
<span class="strong"><strong>table public.t_demo: DELETE: (no-tuple-data)</strong></span>
<span class="strong"><strong>COMMIT 606549</strong></span></pre><p>Therefore, the output is <span>pretty</span><a id="id325622615" class="indexterm"></a> pointless. To fix that, the <span>following</span><a id="id325622624" class="indexterm"></a> line comes to the rescue:</p><pre class="programlisting"><span class="strong"><strong>test=# ALTER TABLE t_demo REPLICA IDENTITY FULL;</strong></span>
<span class="strong"><strong>ALTER TABLE</strong></span></pre><p>If the table is repopulated with data and deleted again, the transaction log stream will look as follows:</p><pre class="programlisting"><span class="strong"><strong>BEGIN 606558 </strong></span>
<span class="strong"><strong>table public.t_demo: DELETE: id[integer]:1 name[text]:'hans' </strong></span>
<span class="strong"><strong>    payload[text]:'some data' </strong></span>
<span class="strong"><strong>table public.t_demo: DELETE: id[integer]:2 name[text]:'paul' </strong></span>
<span class="strong"><strong>    payload[text]:'some more data' </strong></span>
<span class="strong"><strong>table public.t_demo: DELETE: id[integer]:3 name[text]:'joe' </strong></span>
<span class="strong"><strong>    payload[text]:'less data' </strong></span>
<span class="strong"><strong>COMMIT 606558</strong></span></pre><p>Now, all of the changes are in.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec87"></a>Use cases of logical slots</h4></div></div></div><p>There are various use cases of replication slots. The most <span>simplistic</span><a id="id325634467" class="indexterm"></a> use case is the one shown here. Data can be fetched from the server in the desired format and used to audit, debug, or simply monitor a database instance.</p><p>The next logical step of course is to take this stream of changes and use it for replication. Solutions such as <span class="strong"><strong>Bi-Directional Replication</strong></span> (<span class="strong"><strong>BDR</strong></span>) are totally based on logical <span>decoding</span><a id="id325634487" class="indexterm"></a> because changes at the binary level would not work with multi-master replication.</p><p>Finally, there is the need to upgrade without downtime. Remember, the binary transaction log stream cannot be used to replicate between different versions of PostgreSQL. Therefore, future versions of PostgreSQL will support a tool called <code class="literal">pglogical</code>, which helps to upgrade without downtime.</p></div></div></div>