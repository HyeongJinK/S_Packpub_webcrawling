<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec52"></a>Improving functions</h2></div></div><hr /></div><p>So far, you have seen how to write basic <span>functions</span><a id="id326221718" class="indexterm"></a> as well as triggers in various languages. Of course many more languages are supported. Some of the most prominent ones are PL/R (R is a powerful statistics package) and PL/v8 (which is based on the Google JavaScript engine). However, those languages are beyond the scope of this chapter (regardless of their usefulness).</p><p>In this section, we will focus on improving the performance of a function. There are a few ways in which we can speed up processing:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Reducing the number of calls</li><li style="list-style-type: disc">Using cached plans</li><li style="list-style-type: disc">Giving hints to the optimizer</li></ul></div><p>In this chapter, all three main areas will be discussed.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec84"></a>Reducing the number of function calls</h3></div></div></div><p>In many cases, performance is bad because functions are called way too often. In my personal opinion and I cannot stress this point enough: Calling things too often is the main reason for bad performance. When you create a function, you can choose from three types of functions: volatile, stable, and immutable. Here is <span>an</span><a id="id326221692" class="indexterm"></a> example:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT random(), random(); 
 random             |   random 
--------------------+------------------- 
 0.276252629235387  | 0.710661871358752 
(1 row) 
 
test=# SELECT now(), now(); 
               now              |        now 
--------------------------------+--------------------------
 2016-12-16 12:57:17.135751+01  | 2016-12-16 12:57:17.135751+01  
(1 row) 
 
test=# SELECT pi(); 
 pi 
------------------ 
 3.14159265358979 
(1 row)</strong></span></pre><p>A volatile function means that the function cannot be optimized away. It has to be executed over and over again. A volatile function can also be the reason why a certain index is not used. By default, every function is considered to be volatile. A stable function will always return the same data within the same transaction. It can be optimized and calls can be removed. The <code class="literal">now()</code> function is a good example of a stable function; within the same transaction, it returns the same data.</p><p>Immutable functions are the gold standard because they <span>allow</span><a id="id326220164" class="indexterm"></a> for most optimizations, which is because they always return the same result given the same input. As a first step to optimizing functions, always make sure that they are marked correctly by adding volatile, stable, or immutable to the end of the definition.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec72"></a>Using cached plans</h4></div></div></div><p>In PostgreSQL, a query is <span>executed</span><a id="id326220156" class="indexterm"></a> using four stages:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><span class="strong"><strong>Parser</strong></span>: This checks the syntax</li><li><span class="strong"><strong>Rewrite system</strong></span>: This take cares of rules</li><li><span class="strong"><strong>Optimizer/planner</strong></span>: This optimizes the query</li><li><span class="strong"><strong>Executor</strong></span>: This executes the plan provided by the planner</li></ol></div><p>If the query is short, the first three steps are relatively time-consuming compared to the real execution time. Therefore, it can make sense to cache execution plans. PL/pgSQL basically does all the plan caching for you automatically behind the scenes. You don't have to worry about it. PL/Perl and PL/Python will give you the choice.</p><p>The SPI interface provides functions to handle and run prepared queries, so the programmer has the choice whether a query should be prepared or not. In the case of long queries, it actually makes sense to use unprepared queries. Short queries should usually always be prepared to reduce the internal overhead.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl3sec73"></a>Assigning costs to functions</h4></div></div></div><p>From the optimizer <span>point</span><a id="id325664437" class="indexterm"></a> of view, a function is basically just like an operator. PostgreSQL will also treat the costs the same way as if it was a standard operator. The problem is just this: adding two numbers is usually cheaper than intersecting coastlines using some PostGIS-provided function. The thing is that the optimizer does not know whether a function is cheap or expensive.</p><p>Fortunately, we can tell the optimizer to make functions cheaper or more expensive:</p><pre class="programlisting"><span class="strong"><strong>test=# \h CREATE FUNCTION  
Command: CREATE FUNCTION</strong></span>
<span class="strong"><strong>Description: Define a new function</strong></span>
<span class="strong"><strong>Syntax:</strong></span>
<span class="strong"><strong>CREATE [ OR REPLACE ] FUNCTION 
... 
| COST  execution_cost 
| ROWS  result_rows 
...</strong></span></pre><p>The <code class="literal">COST</code> parameter indicates how much more <span>expensive</span><a id="id325856123" class="indexterm"></a> than a standard operator your operator really is. It is a multiplier for <code class="literal">cpu_operator_cost</code> and not a static value. In general, the default value is 100 unless the function has been written in C.</p><p>The second parameter is the <code class="literal">ROWS</code> parameter. By default, PostgreSQL assumes that a set returning function will return 1,000 rows because the system has no way to figure out precisely how many rows there will be. The <code class="literal">ROWS</code> parameter allows developers to tell PostgreSQL about the expected number of rows.</p></div></div></div>