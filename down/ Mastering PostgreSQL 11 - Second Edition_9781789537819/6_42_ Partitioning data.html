<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec45"></a>Partitioning data</h2></div></div><hr /></div><p>Given default 8 k blocks, PostgreSQL can <span>store</span><a id="id326594727" class="indexterm"></a> up to 32 TB of data inside a single table. If you compile PostgreSQL with 32 k blocks, you can even put up to 128 TB into a single table. However, large tables such as that are not necessarily convenient anymore and it can make sense to partition tables to make processing easier and, in some cases, a bit faster. Starting with version 10.0, PostgreSQL offers improved partitioning, which will offer end users significantly easier handling of data partitioning.</p><p>In this chapter, the old means of partitioning as well as the new features available as of PostgreSQL 11.0 will be covered.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec66"></a>Creating partitions</h3></div></div></div><p>First, we will take a closer look at the outdated method of partitioning data. Keep in mind that understanding this technique is important to gain a deeper overview of what PostgreSQL really does behind the scenes.</p><p>Before digging deeper into the <span>advantages</span><a id="id326594707" class="indexterm"></a> of partitioning, I want to show how partitions can be created. The entire thing starts with a parent table that we can create by using the following command:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE t_data (</strong></span><span class="strong"><strong>id serial, </strong></span><span class="strong"><strong>t date, </strong></span><span class="strong"><strong>payload text</strong></span><span class="strong"><strong>);</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span></pre><p>In this example, the parent table has three columns. The date column will be used for partitioning, but we'll cover more on that a bit later.</p><p>Now that the parent table is in place, the child tables can be created. This is how it works:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE t_data_2016 () </strong></span><span class="strong"><strong>INHERITS (t_data);</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span>
<span class="strong"><strong>test=# \</strong></span><span class="strong"><strong>d t_data_2016</strong></span>
<span class="strong"><strong>                       Table "public.t_data_2016" </strong></span>
<span class="strong"><strong> Column  | Type    | Modifiers </strong></span>
<span class="strong"><strong>---------+---------+----------------------------------------------------- </strong></span>
<span class="strong"><strong> id      | integer | not null default </strong></span>
<span class="strong"><strong>                     nextval('t_data_id_seq'::regclass) </strong></span>
<span class="strong"><strong> t       | date    | </strong></span>
<span class="strong"><strong> payload | text    | </strong></span>
<span class="strong"><strong>Inherits: t_data</strong></span></pre><p>The table is called <code class="literal">t_data_2016</code> and inherits from <code class="literal">t_data. ()</code>. This means that no extra columns are added to the child table. As you can see, inheritance means that all columns from the parents are available in the child table. Also note that the <code class="literal">id</code> column will inherit the sequence from the parent so that all children can share the very same numbering.</p><p>Let's create more tables:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE t_data_2015 () </strong></span><span class="strong"><strong>INHERITS (t_data);</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span>
<span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE t_data_2014 () </strong></span><span class="strong"><strong>INHERITS (t_data);</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>So far, all of the tables are identical and just inherit from the parent. However, there's more: child tables can actually have <span>more</span><a id="id325955404" class="indexterm"></a> columns than parents. Adding more fields is simple:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE t_data_2013 (special text) </strong></span><span class="strong"><strong>INHERITS (t_data);</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span></pre><p>In this case, a special column has been added. It has no impact on the parent; it just enriches the children and makes them capable of holding more data.</p><p>After creating a handful of tables, a row can be added:</p><pre class="programlisting"><span class="strong"><strong>test=# INSERT </strong></span><span class="strong"><strong>INTO t_data_2015 (t, payload) 
</strong></span><span class="strong"><strong>        VALUES ('2015-05-04', </strong></span><span class="strong"><strong>'some data');</strong></span>
<span class="strong"><strong>INSERT </strong></span><span class="strong"><strong>0 1</strong></span></pre><p>The most important thing now is that the parent table can be used to find all the data in the child tables:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT </strong></span><span class="strong"><strong>* FROM t_data;</strong></span>
<span class="strong"><strong> id |     t      | payload </strong></span>
<span class="strong"><strong>----+------------+----------- </strong></span>
<span class="strong"><strong>  1 | 2015-05-04 | some data </strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>Querying the parent allows you to gain access to everything below the parent in a simple and efficient manner.</p><p>To understand how PostgreSQL does partitioning, it makes sense to take a look at the plan:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT </strong></span><span class="strong"><strong>* FROM t_data;</strong></span>
<span class="strong"><strong>                              QUERY PLAN </strong></span>
<span class="strong"><strong>----------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Append (cost=0.00..84.10 rows=4411 width=40) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data (cost=0.00..0.00 rows=1 width=40) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data_2016 </strong></span>
<span class="strong"><strong>         (cost=0.00..22.00 rows=1200 width=40) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data_2015 </strong></span>
<span class="strong"><strong>         (cost=0.00..22.00 rows=1200 width=40) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data_2014 </strong></span>
<span class="strong"><strong>         (cost=0.00..22.00 rows=1200 width=40) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data_2013 </strong></span>
<span class="strong"><strong>         (cost=0.00..18.10 rows=810 width=40) </strong></span>
<span class="strong"><strong>(6 rows)</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>Actually, the process is quite simple. PostgreSQL will <span>simply</span><a id="id326287579" class="indexterm"></a> unify all tables and show us all the content from all the tables inside and below the partition we are looking at. Note that all tables are independent and are just connected logically through the system catalog.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec67"></a>Applying table constraints</h3></div></div></div><p>What <span>happens</span><a id="id326287594" class="indexterm"></a> if filters are applied to the table? What will the optimizer decide on to execute this query in the most efficient way? The following example shows us how the PostgreSQL planner will behave:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT </strong></span><span class="strong"><strong>* FROM t_data WHERE t = '2016-01-04';</strong></span>
<span class="strong"><strong>                            QUERY PLAN </strong></span>
<span class="strong"><strong>----------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Append (cost=0.00..95.12 rows=23 width=40) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data (cost=0.00..0.00 rows=1 width=40) </strong></span>
<span class="strong"><strong>         Filter: (t = '2016-01-04'::date) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data_2016 (cost=0.00..25.00 rows=6 width=40) </strong></span>
<span class="strong"><strong>         Filter: (t = '2016-01-04'::date) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data_2015 (cost=0.00..25.00 rows=6 width=40) </strong></span>
<span class="strong"><strong>         Filter: (t = '2016-01-04'::date) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data_2014 (cost=0.00..25.00 rows=6 width=40) </strong></span>
<span class="strong"><strong>         Filter: (t = '2016-01-04'::date) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data_2013 (cost=0.00..20.12 rows=4 width=40) </strong></span>
<span class="strong"><strong>         Filter: (t = '2016-01-04'::date) </strong></span>
<span class="strong"><strong>(11 rows)</strong></span></pre><p>PostgreSQL will apply the filter to all the partitions in the structure. It does not know that the table name is somehow related to the content of the tables. To the database, names are just names and have nothing to do with what you are looking for. This makes sense, of course, as there is no mathematical justification for doing anything else.</p><p>The point now is: how can we teach the database that the 2016 table only contains 2016 data, the 2015 table only contains 2015 data, and so on? Table constraints are here to do exactly that. They teach PostgreSQL about the content of those tables and therefore allow the planner to make smarter decisions than before. The feature is called <span>constraint</span><a id="id326300508" class="indexterm"></a> exclusion and helps to dramatically speed up queries in many cases.</p><p>The following listing shows how table constraints can be created:</p><pre class="programlisting"><span class="strong"><strong>test=# ALTER TABLE t_data_2013 </strong></span>
<span class="strong"><strong>   ADD CHECK (t &lt; '2014-01-01'); </strong></span>
<span class="strong"><strong>ALTER TABLE </strong></span>
<span class="strong"><strong>test=# ALTER TABLE t_data_2014 </strong></span>
<span class="strong"><strong>   ADD CHECK (t &gt;= '2014-01-01' AND t &lt; '2015-01-01'); </strong></span>
<span class="strong"><strong>ALTER TABLE </strong></span>
<span class="strong"><strong>test=# ALTER TABLE t_data_2015 </strong></span>
<span class="strong"><strong>   ADD CHECK (t &gt;= '2015-01-01' AND t &lt; '2016-01-01'); </strong></span>
<span class="strong"><strong>ALTER TABLE </strong></span>
<span class="strong"><strong>test=# ALTER TABLE t_data_2016 </strong></span>
<span class="strong"><strong>   ADD CHECK (t &gt;= '2016-01-01' AND t &lt; '2017-01-01'); </strong></span>
<span class="strong"><strong>ALTER TABLE</strong></span></pre><p>For each table, a <code class="literal">CHECK</code> constraint can be added.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip50"></a>Note</h3><p>PostgreSQL will only create the constraint if all the data in those tables is perfectly correct and if every single row satisfies the constraint. In contrast to MySQL, constraints in PostgreSQL are taken seriously and honored under any circumstance.</p></div><p>In PostgreSQL, those constraints can overlap—this is not forbidden and can make sense in some cases. However, it is usually better to have non-overlapping constraints because PostgreSQL has the option to prune more tables.</p><p>Here is what happens after adding those table constraints:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN SELECT * </strong></span><span class="strong"><strong>FROM t_data WHERE t = '2016-01-04';</strong></span>
<span class="strong"><strong>                            QUERY PLAN </strong></span>
<span class="strong"><strong>----------------------------------------------------------------- </strong></span>
<span class="strong"><strong> Append (cost=0.00..25.00 rows=7 width=40) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data (cost=0.00..0.00 rows=1 width=40) </strong></span>
<span class="strong"><strong>         Filter: (t = '2016-01-04'::date) </strong></span>
<span class="strong"><strong>   -&gt; Seq Scan on t_data_2016 (cost=0.00..25.00 rows=6 width=40) </strong></span>
<span class="strong"><strong>         Filter: (t = '2016-01-04'::date) </strong></span>
<span class="strong"><strong>(5 rows)</strong></span></pre><p>The planner will be able to remove many of the tables from the query and only keep those that potentially contain the data. The query can <span>greatly</span><a id="id325874211" class="indexterm"></a> benefit from a shorter and more efficient plan. In particular, if those tables are really large, removing them can boost speed considerably.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec68"></a>Modifying inherited structures</h3></div></div></div><p>Once in a while, data <span>structures</span><a id="id325874226" class="indexterm"></a> have to be modified. The <code class="literal">ALTER TABLE</code> clause is here to do exactly that. The question here is, how can partitioned tables be modified?</p><p>Basically, all you have to do is tackle the parent table and add or remove columns. PostgreSQL will automatically propagate those changes through to the child tables and ensure that changes are made to all the relations, as follows:</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>ALTER TABLE t_data ADD COLUMN x int;</strong></span>
<span class="strong"><strong>ALTER TABLE
<span class="strong"><strong>test=# \</strong></span><span class="strong"><strong>d t_data_2016</strong></span>
                       Table "public.t_data_2016" 
 Column  |   Type  | Modifiers 
---------+---------+----------------------------------------------------- 
      id | integer | not null default 
                     nextval('t_data_id_seq'::regclass) 
       t |    date | 
 payload |    text | 
       x | integer | 
Check constraints: 
    "t_data_2016_t_check" 
   CHECK (t &gt;= '2016-01-01'::date AND t &lt; '2017-01-01'::date) 
Inherits: t_data 
</strong></span></pre><p>As you can see, the column is added to the parent and automatically added to the child table here.</p><p>Note that this works for columns and so on. Indexes are a totally different story. In an inherited structure, every table has to be indexed separately. If you add an index to the parent table, it will only be present on the parent—it won't be deployed on those child tables. Indexing all those columns in all those tables is your task and PostgreSQL is not going to make those decisions for you. Of course, this can be seen as a feature or as a limitation. On the upside, you could say that PostgreSQL gives you all the flexibility to index things separately and therefore <span>potentially</span><a id="id325887817" class="indexterm"></a> more efficiently. However, people might also argue that deploying all those indexes one by one is a lot more work.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec69"></a>Moving tables in and out of partitioned structures</h3></div></div></div><p>Suppose you have an <span>inherited</span><a id="id325887833" class="indexterm"></a> structure. Data is partitioned by date and you want to provide the most recent years to the end user. At some point, you might want to remove some data from the scope of the user without actually touching it. You might want to put data into some sort of archive.</p><p>PostgreSQL provides a simple means to achieve exactly that. First, a new parent can be created:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE t_history (LIKE t_data);</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span></pre><p>The <code class="literal">LIKE</code> keyword allows you to create a table that has exactly the same layout as the <code class="literal">t_data</code> table. If you have forgotten which columns the <code class="literal">t_data</code> table actually has, this might come in handy as it saves you a lot of work. It is also possible to include indexes, constraints, and defaults.</p><p>Then, the table can be moved away from the old parent table and put below the new one. Here is how it works:</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>ALTER TABLE t_data_2013 NO INHERIT t_data;</strong></span>
<span class="strong"><strong>ALTER TABLE</strong></span>
<span class="strong"><strong>test=# </strong></span><span class="strong"><strong>ALTER TABLE t_data_2013 INHERIT t_history;</strong></span>
<span class="strong"><strong>ALTER TABLE</strong></span></pre><p>The entire process can, of course, be done in a single transaction to assure that the operation stays atomic.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec70"></a>Cleaning up data</h3></div></div></div><p>One advantage of <span>partitioned</span><a id="id325895962" class="indexterm"></a> tables is the ability to clean data up quickly. Let's assume that we want to delete an entire year; if the data is partitioned accordingly, a simple <code class="literal">DROP TABLE</code> clause can do the job:</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>DROP TABLE t_data_2014;</strong></span>
<span class="strong"><strong>DROP TABLE</strong></span></pre><p>As you can see, dropping a child table is easy. But what about the parent table? There are depending objects and therefore PostgreSQL naturally errors out to make sure that nothing unexpected happens:</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>DROP TABLE t_data;</strong></span>
<span class="strong"><strong>ERROR: cannot drop table t_data because other objects depend on it </strong></span>
<span class="strong"><strong>DETAIL: default for table t_data_2013 column id depends on </strong></span>
<span class="strong"><strong>   sequence t_data_id_seq </strong></span>
<span class="strong"><strong>table t_data_2016 depends on table t_data </strong></span>
<span class="strong"><strong>table t_data_2015 depends on table t_data </strong></span>
<span class="strong"><strong>HINT: Use DROP ... CASCADE to drop the dependent objects too.</strong></span></pre><p>The <code class="literal">DROP TABLE</code> clause will warn us that there are depending objects and will refuse to drop those tables. The <code class="literal">CASCADE</code> clause is needed to force PostgreSQL to actually remove those objects, along with the parent table. The following example shows us how to use a cascaded DROP TABLE:</p><pre class="programlisting"><span class="strong"><strong>test=# DROP TABLE t_data CASCADE;
</strong></span><span class="strong"><strong>NOTICE:  drop  cascades to 3 other  objects</strong></span><span class="strong"><strong>DETAIL:  drop  cascades to default for table  t_data_2013 column id drop  cascades to table  t_data_2016</strong></span><span class="strong"><strong>drop  cascades to table  t_data_2015</strong></span><span class="strong"><strong>DROP TABLE</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec71"></a>Understanding PostgreSQL 11.0 partitioning</h3></div></div></div><p>A lot of what has been added in PostgreSQL 10 and 11 will make sure that what you have seen in the "old world" is automated. This is especially true for indexing, tuple routing on insertion, and so on. However, let's go through those things in a more organized way.</p><p>For many years, the <span>PostgreSQL</span><a id="id325945147" class="indexterm"></a> community has been working on built-in partitioning. Finally, PostgreSQL 10.0 now offers the first implementation of in-core partitioning, which will be covered in this chapter. In PostgreSQL 10, the partitioning functionality was still pretty busy and therefore a lot of stuff has been improved in PostgreSQL 11 to make life even easier for people who want to use this important feature. </p><p>To show you how partitioning works, I have compiled a simple example <span>featuring</span><a id="id325945158" class="indexterm"></a> range partitioning, as follows:</p><pre class="programlisting"><span class="strong"><strong>CREATE TABLE data (</strong></span><span class="strong"><strong>   payload  integer</strong></span><span class="strong"><strong>)  PARTITION BY RANGE (payload);
</strong></span><span class="strong"><strong>CREATE TABLE negatives PARTITION</strong></span><span class="strong"><strong>  OF data FOR VALUES FROM (MINVALUE) TO (0);</strong></span><span class="strong"><strong>CREATE TABLE positives PARTITION</strong></span><span class="strong"><strong>  OF data FOR VALUES FROM (0) TO (MAXVALUE);</strong></span></pre><p>In this example, one partition will hold all negative values while the other one will take care of positive values. While creating the parent table, you can simply specify which way you want to partition data.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note51"></a>Note</h3><p>In PostgreSQL 10.0, there is range partitioning and list partitioning. Support for hash partitioning and the <code class="literal">LIKE</code> might be available as soon as PostgreSQL 11.0.</p></div><p>Once the parent table has been created, it is already time to create the partitions. To do that, the <code class="literal">PARTITION OF</code> clause has to be added. At this point, there are still some limitations (as of PostgreSQL 10). The most important one is that a tuple (a row) cannot move from one partition to the other, for example:</p><pre class="programlisting"><span class="strong"><strong>UPDATE data SET payload = -10 WHERE id = 5</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>Fortunately, this restriction has been lifted and PostgreSQL 11 is able to move a row from one partition to the other. However, keep in mind that moving data between partitions might not be the best of ideas in general. </p><p>The next important aspect is related to indexing: in PostgreSQL 10, every table (every partition) had to be indexed separately. This is not true in PostgreSQL 11 anymore. Let's try this out and see what happens:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE INDEX idx_payload ON data (payload);</strong></span>
<span class="strong"><strong>CREATE INDEX</strong></span>
<span class="strong"><strong>test=# \d positives</strong></span>
<span class="strong"><strong> Table "public.positives"</strong></span>
<span class="strong"><strong> Column | Type | Collation | Nullable | Default </strong></span>
<span class="strong"><strong>---------+---------+-----------+----------+---------</strong></span>
<span class="strong"><strong> payload | integer | | | </strong></span>
<span class="strong"><strong>Partition of: data FOR VALUES FROM (0) TO (MAXVALUE)</strong></span>
<span class="strong"><strong>Indexes:</strong></span>
<span class="strong"><strong> "positives_payload_idx" btree (payload)</strong></span></pre><p>What you can see here is that the index has also been <span>added</span><a id="id325946665" class="indexterm"></a> to the child table automatically, which is a really important <span>feature</span><a id="id325946674" class="indexterm"></a> of PostgreSQL 11 and which has widely been appreciated by users moving their applications to PostgreSQL 11 already.</p><p>Another important feature is the ability to create a default partition. To show you how that works, we can drop one of our two partitions:</p><pre class="programlisting"><span class="strong"><strong>test=# DROP TABLE negatives;</strong></span>
<span class="strong"><strong>DROP TABLE</strong></span></pre><p>Then, a default partition of the <code class="literal">data</code> table can be created easily:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE TABLE p_def PARTITION OF data DEFAULT;</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span></pre><p>All data that does not fit anywhere will end up in this default partition, which ensures that creating the right partition can never be forgotten. Experience has shown that the existence of a default partition makes applications a lot more reliable as time goes by.</p><p>The following listing shows how to insert data and where the data will finally end up:</p><pre class="programlisting"><span class="strong"><strong>test=# INSERT INTO data VALUES (1), (-1);</strong></span>
<span class="strong"><strong>INSERT 0 2</strong></span>
<span class="strong"><strong>test=# SELECT * FROM data;</strong></span>
<span class="strong"><strong> payload </strong></span>
<span class="strong"><strong>---------</strong></span>
<span class="strong"><strong> 1</strong></span>
<span class="strong"><strong> -1</strong></span>
<span class="strong"><strong>(2 rows)</strong></span>

<span class="strong"><strong>test=# SELECT * FROM positives;</strong></span>
<span class="strong"><strong> payload </strong></span>
<span class="strong"><strong>---------</strong></span>
<span class="strong"><strong> 1</strong></span>
<span class="strong"><strong>(1 row)</strong></span>

<span class="strong"><strong>test=# SELECT * FROM p_def;</strong></span>
<span class="strong"><strong> payload </strong></span>
<span class="strong"><strong>---------</strong></span>
<span class="strong"><strong> -1</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>As you can see, querying the <span>parent</span><a id="id325963218" class="indexterm"></a> tables will <span>return</span><a id="id325963226" class="indexterm"></a> all data. The various partitions will hold the data as defined by the partitioning rules.</p></div></div>