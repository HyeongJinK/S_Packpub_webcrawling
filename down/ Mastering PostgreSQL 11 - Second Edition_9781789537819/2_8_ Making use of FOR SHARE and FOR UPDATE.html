<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec15"></a>Making use of FOR SHARE and FOR UPDATE</h2></div></div><hr /></div><p>Sometimes, data is <span>selected</span><a id="id325606853" class="indexterm"></a> from the database, then <span>some</span><a id="id325606848" class="indexterm"></a> processing happens in the application, and finally, some changes are made back on the database side. This is a classic example of <code class="literal">SELECT FOR UPDATE</code>.</p><p>Here is an example that shows the way <code class="literal">SELECT</code> is often executed in the wrong way:</p><pre class="programlisting"><span class="strong"><strong>BEGIN;</strong></span>
<span class="strong"><strong>SELECT * FROM  invoice WHERE  processed = false; 
** application magic  will  happen here  **  
UPDATE invoice SET processed = true  ...  
COMMIT;</strong></span></pre><p>The problem here is that two people might select the same unprocessed data. Changes made to these processed rows will then be overwritten. In short, a race condition will occur.</p><p>To solve this problem, developers can make use of <code class="literal">SELECT FOR UPDATE</code>. Here is how it can be used. The following example will show a typical scenario:</p><pre class="programlisting"><span class="strong"><strong>BEGIN; 
SELECT * FROM invoice WHERE processed = false FOR UPDATE; 
** application magic  will  happen here  **  
UPDATE invoice SET processed = true ...  
COMMIT;</strong></span></pre><p><code class="literal">SELECT FOR UPDATE</code> will lock rows just like <code class="literal">UPDATE</code> would. This means that no changes can happen concurrently. All locks will be released on <code class="literal">COMMIT</code> as usual.</p><p>If one <code class="literal">SELECT FOR UPDATE</code> command is waiting for some other <code class="literal">SELECT FOR UPDATE</code> command, one has to wait until the other one completes (<code class="literal">COMMIT</code> or <code class="literal">ROLLBACK</code>). If the first transaction does not want to end, for whatever reason, the second transaction might <span>potentially</span><a id="id325606778" class="indexterm"></a> wait forever. To <span>avoid</span><a id="id326649917" class="indexterm"></a> this, it is possible to use <code class="literal">SELECT FOR UPDATE NOWAIT</code>.</p><p> </p><p>Here is how it works:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT ... FROM tab WHERE ... FOR UPDATE NOWAIT;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Some processing</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT ... FROM tab WHERE ... FOR UPDATE NOWAIT;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Some processing</p></td><td style=""><p><code class="literal">ERROR: could not obtain lock on row in relation tab</code></p></td></tr></tbody></table></div><p> </p><p>If <code class="literal">NOWAIT</code> is not flexible enough for you, consider using <code class="literal">lock_timeout</code>. It will contain the amount of time you want to wait on locks. You can set this on a per-session level:</p><pre class="programlisting"><span class="strong"><strong>test=# SET lock_timeout TO 5000;  
SET </strong></span></pre><p>In this, the value is set to 5 seconds.</p><p>While <code class="literal">SELECT</code> does basically no locking, <code class="literal">SELECT FOR UPDATE</code> can be pretty harsh. Just imagine the following business process: we want to fill up an airplane providing 200 seats. Many people want to book seats concurrently. In this case, the following might happen:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT ... FROM flight LIMIT 1 FOR UPDATE;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Waiting for user input</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT ... FROM flight LIMIT 1 FOR UPDATE;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Waiting for user input</p></td><td style=""><p>It has to wait</p></td></tr></tbody></table></div><p> </p><p>The trouble is that only one seat can be booked at a time. There are potentially 200 seats available but everybody has to wait for the <span>first</span><a id="id326014327" class="indexterm"></a> person. While the <span>first</span><a id="id326014338" class="indexterm"></a> seat is blocked, nobody else can book a seat even if people don't care which seat they get in the end.</p><p><code class="literal">SELECT FOR UPDATE SKIP LOCKED</code> will fix the problem. Let's create some sample data first:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE TABLE t_flight AS 
          SELECT * FROM generate_series(1, 200) AS id;  
SELECT 200</strong></span></pre><p>Now comes the magic:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT * FROM t_flight LIMIT 2 FOR UPDATE SKIP LOCKED;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT * FROM t_flight LIMIT 2 FOR UPDATE SKIP LOCKED;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>It will return <code class="literal">1</code> and <code class="literal">2</code></p></td><td style=""><p>It will return <code class="literal">3</code> and <code class="literal">4</code></p></td></tr></tbody></table></div><p> </p><p>If everybody wants to fetch two rows, we can serve 100 concurrent transactions at a time without having to worry about blocking transactions.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip11"></a>Note</h3><p>Keep in mind that waiting is the slowest form of execution. If only one transaction can be active at a time, it is pointless to buy ever more expensive servers if your real problems are caused by locking and conflicting transactions in general.</p></div><p>However, there is more. In some cases, <code class="literal">FOR UPDATE</code> can have unintended consequences. Most people are not aware of the fact that <code class="literal">FOR UPDATE</code> will have an impact on foreign keys. Let's assume that we have two tables: one to store <span>currencies</span><a id="id326300523" class="indexterm"></a> and the other to <span>store</span><a id="id326300849" class="indexterm"></a> accounts. The following listing shows an example:</p><pre class="programlisting"><span class="strong"><strong>CREATE TABLE t_currency (id int, name text, PRIMARY KEY (id));  
INSERT INTO t_currency VALUES (1, 'EUR');       
INSERT INTO t_currency VALUES (2, 'USD'); 
 
CREATE TABLE t_account (
       id           int, 
       currency_id  int         REFERENCES t_currency (id) 
                                      ON UPDATE CASCADE 
                                      ON DELETE CASCADE, 
</strong></span><span class="strong"><strong>balance      numeric); 
INSERT INTO t_account VALUES (1, 1, 100);  
INSERT INTO t_account VALUES (2, 1, 200);</strong></span></pre><p>Now, we want to run <code class="literal">SELECT FOR UPDATE</code> on the account table:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT * FROM t_account FOR UPDATE;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Waiting for user to proceed</p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">UPDATE t_currency SET id = id * 10;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Waiting for user to proceed</p></td><td style=""><p>It will wait on transaction 1</p></td></tr></tbody></table></div><p> </p><p> </p><p>Although there is a <code class="literal">SELECT FOR UPDATE</code> command on accounts, the <code class="literal">UPDATE</code> command on the currency table be will be blocked. This is necessary because, otherwise, there is a chance of breaking the foreign key constraint altogether. In a fairly complex data structure, you can therefore easily end up with contentions in an area where they are least expected (some highly important lookup tables).</p><p>On top of <code class="literal">FOR UPDATE</code>, there are <code class="literal">FOR SHARE</code>, <code class="literal">FOR NO KEY UPDATE</code>, and <code class="literal">FOR KEY SHARE</code>. The following listing describes what these modes actually mean:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">FOR NO KEY UPDATE</code>: This one is <span>pretty</span><a id="id326598340" class="indexterm"></a> similar to <code class="literal">FOR UPDATE</code>. However, the lock is weaker and, therefore, it can coexist with <code class="literal">SELECT FOR SHARE</code>.</li><li style="list-style-type: disc"><code class="literal">FOR SHARE</code>: <code class="literal">FOR UPDATE</code> is pretty <span>strong</span><a id="id326649868" class="indexterm"></a> and <span>works</span><a id="id326649877" class="indexterm"></a> on the <span>assumption</span><a id="id326649889" class="indexterm"></a> that you are definitely going to change rows. <code class="literal">FOR SHARE</code> is different because more than one transaction can hold a <code class="literal">FOR SHARE</code> lock at the same time.</li><li style="list-style-type: disc"><code class="literal">FOR KEY SHARE</code>: This behaves <span>similarly</span><a id="id325607328" class="indexterm"></a> to <code class="literal">FOR SHARE</code>, except that the lock is weaker. It will block <code class="literal">FOR UPDATE</code> but will not block <code class="literal">FOR NO KEY UPDATE</code>.</li></ul></div><p>The important thing here is to <span>simply</span><a id="id325607346" class="indexterm"></a> try things out and observe what happens. Improving locking behavior is really important as it can dramatically improve the scalability of your application.</p></div>