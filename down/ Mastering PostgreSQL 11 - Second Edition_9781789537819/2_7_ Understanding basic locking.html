<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec14"></a>Understanding basic locking</h2></div></div><hr /></div><p>In this section, you will learn <span>basic</span><a id="id326012369" class="indexterm"></a> locking mechanisms. The goal is to understand how locking works in general and how to get simple applications right.</p><p>To show how things work, a simple table can be created. For demonstration purposes, I will add one row to the table using the a simple <code class="literal">INSERT</code> command:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE TABLE  t_test (id int);  
CREATE TABLE 
test=# INSERT INTO t_test VALUES (0);  
INSERT 0 1</strong></span></pre><p>The first important thing is that tables can be read concurrently. Many users reading the same data at the same time won't block each other. This allows PostgreSQL to handle thousands of users without problems.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note7"></a>Note</h3><p>Multiple users can read the same data at the same time without blocking each other.</p></div><p> </p><p> </p><p>The question now is what happens if reads and writes occur at the same time? Here is an example. Let us assume that the table contains one row and its <code class="literal">id = 0</code>:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">UPDATE t_test SET id = id + 1 RETURNING *;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User will see <code class="literal">1</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT * FROM t_test;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p>User will see <code class="literal">0</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">COMMIT;</code></p></td><td style=""><p><code class="literal">COMMIT;</code></p></td></tr></tbody></table></div><p>
Two transactions are opened. The first one will change a row. However, this is not a problem as the second transaction can proceed. It will return the old row as it was <span>before</span><a id="id325565398" class="indexterm"></a> the <code class="literal">UPDATE</code>. This <span>behavior</span><a id="id325565410" class="indexterm"></a> is called <span class="strong"><strong>multi-version concurrency control</strong></span> (<span class="strong"><strong>MVCC</strong></span>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note8"></a>Note</h3><p>A transaction will see data only if it has been committed by the write transaction prior to the initiation of the read transaction. One transaction cannot inspect the changes made by another active connection. A transaction can see only those changes that have already been committed.</p></div><p>There is also a second important aspect—many commercial or open source databases are still (as of 2018) unable to handle concurrent reads and writes. In PostgreSQL, this is absolutely not a problem. Reads and writes can coexist.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note9"></a>Note</h3><p>Write transactions won't block read transactions.</p></div><p>After the transaction has been committed, the table will contain <code class="literal">1</code>.</p><p>What will happen if two people change data at the same time? Here is an example:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">UPDATE t_test SET id = id + 1 RETURNING *;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>It will return <code class="literal">2</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">UPDATE t_test SET id = id + 1 RETURNING *;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p>It will wait for transaction <code class="literal">1</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">COMMIT;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>It will wait for transaction <code class="literal">1</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p></p></td><td style="border-bottom: 0.5pt solid ; "><p>It will reread the row, find <code class="literal">2</code>, set the value, and return <code class="literal">3</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p></p></td><td style=""><p><code class="literal">COMMIT;</code></p></td></tr></tbody></table></div><p> </p><p>Suppose you want to count the number of hits on a website. If you run the code as outlined just now, no hit can be lost because PostgreSQL <span>guarantees</span><a id="id325856120" class="indexterm"></a> that one <code class="literal">UPDATE</code> is performed after the other.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>PostgreSQL will only lock rows affected by <code class="literal">UPDATE</code>. So, if you have 1,000 rows, you can theoretically run 1,000 concurrent changes on the same table.</p></div><p>It is also noteworthy that you can always run concurrent reads. Our two writes will not block reads.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec13"></a>Avoiding typical mistakes and explicit locking</h3></div></div></div><p>In my life as a <span>professional</span><a id="id325861483" class="indexterm"></a> PostgreSQL consultant (<a class="ulink" href="https://www.cybertec-postgresql.com" target="_blank">https://www.cybertec-postgresql.com</a>), I have seen a couple of mistakes that are repeated frequently. If <span>there</span><a id="id325873809" class="indexterm"></a> are constants in life, these <span>typical</span><a id="id325873817" class="indexterm"></a> mistakes are definitely some of the things that never change.</p><p>Here is my favorite:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 1</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Transaction 2</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">BEGIN;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT max(id) FROM product;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">SELECT max(id) FROM product;</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User will see <code class="literal">17</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>User will see <code class="literal">17</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User will decide to use <code class="literal">18</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>User will decide to use <code class="literal">18</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">INSERT INTO product ... VALUES (18, ...)</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">INSERT INTO product ... VALUES (18, ...)</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">COMMIT;</code></p></td><td style=""><p><code class="literal">COMMIT;</code></p></td></tr></tbody></table></div><p> </p><p>In this case, there will be either a duplicate key violation or two identical entries. Neither variation of the problem is all that appealing.</p><p>One way to fix the problem is to use explicit table locking. The following listing shows us the syntax definition of <code class="literal">LOCK</code>:</p><pre class="programlisting"><span class="strong"><strong>test=# \h LOCK 
Command: LOCK</strong></span>
<span class="strong"><strong>Description: lock a table</strong></span>
<span class="strong"><strong>Syntax:</strong></span>
<span class="strong"><strong>LOCK [ TABLE ] [ ONLY ] name [ * ] [, ...] [ IN lockmode MODE ] 
     [ NOWAIT ] 

where <code class="literal">lockmode</code> is one of the following:</strong></span>

<span class="strong"><strong>    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | 
    SHARE UPDATE EXCLUSIVE| SHARE | 
    SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE </strong></span></pre><p>As you can see, PostgreSQL <span>offers</span><a id="id326648433" class="indexterm"></a> eight types of <span>locks</span><a id="id325607086" class="indexterm"></a> to lock an entire table. In PostgreSQL, a lock can be as light as an <code class="literal">ACCESS SHARE</code> lock or as heavy as an <code class="literal">ACCESS EXCLUSIVE</code> lock. The following list shows what these locks do:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">ACCESS SHARE</code>: This type of <span>lock</span><a id="id325607109" class="indexterm"></a> is taken by reads and conflicts only with <code class="literal">ACCESS EXCLUSIVE</code>, which is set by <code class="literal">DROP TABLE</code> and the like. Practically, this means that <code class="literal">SELECT</code> cannot start if a table is about to be dropped. This also implies that <code class="literal">DROP TABLE</code> has to wait until a reading transaction is complete.</li><li style="list-style-type: disc"><code class="literal">ROW SHARE</code>: PostgreSQL takes this kind of <span>lock</span><a id="id325607134" class="indexterm"></a> in the case of <code class="literal">SELECT FOR UPDATE</code>/<code class="literal">SELECT FOR SHARE</code>. It conflicts with <code class="literal">EXCLUSIVE</code> and <code class="literal">ACCESS EXCLUSIVE</code>.</li><li style="list-style-type: disc"><code class="literal">ROW EXCLUSIVE</code>: This <span>lock</span><a id="id325628358" class="indexterm"></a> is taken by <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, and <code class="literal">DELETE</code>. It conflicts with <code class="literal">SHARE</code>, <code class="literal">SHARE ROW EXCLUSIVE</code>, <code class="literal">EXCLUSIVE</code>, and <code class="literal">ACCESS EXCLUSIVE</code>.</li><li style="list-style-type: disc"><code class="literal">SHARE UPDATE EXCLUSIVE</code>: This kind of <span>lock</span><a id="id325628393" class="indexterm"></a> is taken by <code class="literal">CREATE INDEX CONCURRENTLY</code>, <code class="literal">ANALYZE</code>, <code class="literal">ALTER TABLE</code>, <code class="literal">VALIDATE</code>, and some other flavors of <code class="literal">ALTER TABLE</code> as well as by <code class="literal">VACUUM</code> (not <code class="literal">VACUUM FULL</code>). It conflicts with the <code class="literal">SHARE UPDATE EXCLUSIVE</code>, <code class="literal">SHARE</code>, <code class="literal">SHARE ROW EXCLUSIVE</code>, <code class="literal">EXCLUSIVE</code>, and <code class="literal">ACCESS EXCLUSIVE</code> lock modes.</li><li style="list-style-type: disc"><code class="literal">SHARE</code>: When an index is created, <code class="literal">SHARE</code> locks <span>will</span><a id="id325628483" class="indexterm"></a> be set. It conflicts with <code class="literal">ROW EXCLUSIVE</code>, <code class="literal">SHARE UPDATE EXCLUSIVE</code>, <code class="literal">SHARE ROW EXCLUSIVE</code>, <code class="literal">EXCLUSIVE</code>, and <code class="literal">ACCESS EXCLUSIVE</code>.</li><li style="list-style-type: disc"><code class="literal">SHARE ROW EXCLUSIVE</code>: This one is set by <code class="literal">CREATE TRIGGER</code> and <span>some</span><a id="id325628515" class="indexterm"></a> forms of <code class="literal">ALTER TABLE</code> and conflicts with everything but <code class="literal">ACCESS SHARE</code>.</li></ul></div><p> </p><p> </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">EXCLUSIVE</code>: This type of lock is by far the <span>most</span><a id="id325870755" class="indexterm"></a> restrictive one. It protects against reads and writes alike. If this lock is taken by a transaction, nobody else can read or write to the table affected.</li><li style="list-style-type: disc"><code class="literal">ACCESS EXCLUSIVE</code>: This <span>lock</span><a id="id325870768" class="indexterm"></a> prevents concurrent transactions from reading and writing.</li></ul></div><p>Given the PostgreSQL locking infrastructure, one solution to the <code class="literal">max</code> problem outlined previously would be as follows. The example in the <span>listing</span><a id="id325870781" class="indexterm"></a> shows <span>how</span><a id="id325870790" class="indexterm"></a> to lock a table:</p><pre class="programlisting"><span class="strong"><strong>BEGIN; 
LOCK  TABLE  product IN ACCESS EXCLUSIVE MODE; 
INSERT INTO  product SELECT max(id) + 1, ... FROM product;  
COMMIT;</strong></span></pre><p>Keep in mind that this is a pretty nasty way of doing this kind of operation because nobody else can read or write to the table during your operation. Therefore, <code class="literal">ACCESS EXCLUSIVE</code> should be avoided at all costs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec6"></a>Considering alternative solutions</h4></div></div></div><p>There is an alternative <span>solution</span><a id="id325871399" class="indexterm"></a> to the problem. Consider an example where you are asked to write an application generating invoice numbers. The tax office might require you to create invoice numbers without gaps and without duplicates. How would you do it? Of course, one solution would be a table lock. However, you can really do better. Here is what I would do to handle the numbering problem we are trying to solve:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE TABLE t_invoice (id int PRIMARY KEY);</strong></span>
<span class="strong"><strong>CREATE TABLE
test=# CREATE TABLE  t_watermark (id int);  
CREATE TABLE
test=# INSERT INTO  t_watermark VALUES (0);  
INSERT 0  
test=# WITH  x AS (UPDATE t_watermark SET id = id + 1 RETURNING *)  
         INSERT INTO  t_invoice 
         SELECT * FROM  x RETURNING *; 
id </strong></span>
<span class="strong"><strong>----</strong></span>
<span class="strong"><strong>  1</strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p> </p><p> </p><p>In this case, I introduced a table called <code class="literal">t_watermark</code>. It contains just one row. The <code class="literal">WITH</code> command will be executed first. The row will be locked and incremented, and the new value will be returned. Only one person can do this at a time. The value returned by the CTE is then used in the invoice table. It is guaranteed to be unique. The beauty is that there is only a simple row lock on the <span>watermark</span><a id="id325873870" class="indexterm"></a> table which leads to no reads being blocked in the invoice table. Overall, this way is more scalable.</p></div></div></div>