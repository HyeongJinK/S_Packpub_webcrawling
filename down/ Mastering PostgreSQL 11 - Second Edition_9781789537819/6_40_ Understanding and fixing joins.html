<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec43"></a>Understanding and fixing joins</h2></div></div><hr /></div><p>Joins are important; everybody needs them on a regular basis. Consequently, joins are also relevant to maintaining or achieving good performance. To ensure that you <span>can</span><a id="id325955406" class="indexterm"></a> write good joins, we will also learn about joining in this book.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec62"></a>Getting joins right</h3></div></div></div><p>Before we dive into <span>optimizing</span><a id="id325955397" class="indexterm"></a> joins, it is important to take a look at some of the most common problems that arise with joins and which of them should ring alarm bells for you.</p><p>Here is an example of a simple table structure to demonstrate how joins work:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE a (aid int);</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span>
<span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE b (bid int);</strong></span>
<span class="strong"><strong>CREATE TABLE</strong></span>
<span class="strong"><strong>test=# INSERT </strong></span><span class="strong"><strong>INTO a VALUES (1), (2), (3);</strong></span>
<span class="strong"><strong>INSERT </strong></span><span class="strong"><strong>0 3</strong></span>
<span class="strong"><strong>test=# INSERT </strong></span><span class="strong"><strong>INTO b VALUES (2), (3), (4);</strong></span>
<span class="strong"><strong>INSERT </strong></span><span class="strong"><strong>0 3</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p>In the following example, you will see a simple outer join:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT </strong></span><span class="strong"><strong>* FROM a LEFT JOIN b ON (aid = bid);</strong></span>
<span class="strong"><strong> aid | bid</strong></span>
<span class="strong"><strong>-----+-----</strong></span>
<span class="strong"><strong>   1 |</strong></span>
<span class="strong"><strong>   2 |    2</strong></span>
<span class="strong"><strong>   3 |    3 
(3 rows)</strong></span></pre><p>You can see that PostgreSQL will take all rows from the left-hand side and only list the ones fitting the join.</p><p>The following example might come as a surprise to many people:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT </strong></span><span class="strong"><strong>* </strong></span><span class="strong"><strong>FROM a LEFT JOIN b </strong></span><span class="strong"><strong>ON (aid = bid AND bid = 2);</strong></span>
<span class="strong"><strong> aid | bid</strong></span>
<span class="strong"><strong>-----+-----</strong></span>
<span class="strong"><strong>   1 |</strong></span>
<span class="strong"><strong>   2 |   2
</strong></span><span class="strong"><strong>   3 |</strong></span>
<span class="strong"><strong>(3 rows)</strong></span></pre><p>No, the number of <span>rows</span><a id="id326189404" class="indexterm"></a> does not decrease—it will stay constant. Most people assume that there will only be one row in the join, but this is not true, and will lead to some hidden issues.</p><p>Consider the following query, which performs a simple join:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT avg(aid), avg(bid) 
</strong></span><span class="strong"><strong>        FROM a LEFT JOIN b</strong></span>
<span class="strong"><strong>             ON (aid = bid AND bid = 2);
          avg       |       avg 
--------------------+-------------------- 
 2.0000000000000000 | 2.0000000000000000 
(1 row) 
</strong></span></pre><p>Most people assume that the average is calculated based on a single row. However, as stated earlier, this is not the case and therefore queries such as that are often considered to be a performance problem because, for some reason, PostgreSQL does not index the table on the left-hand side of the join. Of course, we are not looking at a performance problem here—we are definitely looking at a semantic issue. It happens on a regular basis that people writing outer joins don't really know what they ask PostgreSQL to do. So, my personal advice is to always question the semantic correctness of an outer join before attacking the performance problem reported by the client.</p><p> </p><p>I cannot stress enough how important this <span>kind</span><a id="id326189436" class="indexterm"></a> of work is to ensure that your queries are correct and do exactly what is needed.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec63"></a>Processing outer joins</h3></div></div></div><p>After verifying that your <span>queries</span><a id="id326189451" class="indexterm"></a> are actually correct from a <span>business</span><a id="id326189460" class="indexterm"></a> point of view, it makes sense to check what the optimizer can do to speed up your outer joins. The most important thing is that PostgreSQL can, in many cases, reorder inner joins to speed things up dramatically. However, in the case of outer joins, this is not always possible. Only a handful of reordering operations are actually allowed:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">(A leftjoin B on (Pab)) innerjoin C on (Pac) = (A innerjoin C on (Pac)) leftjoin B on (Pab)</code></li></ul></div><p><code class="literal">Pac</code> is a predicate referencing <code class="literal">A</code> and <code class="literal">C</code>, and so on (in this case, clearly, <code class="literal">Pac</code> cannot reference <code class="literal">B</code>, or the transformation is nonsensical):</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">(A leftjoin B on (Pab)) leftjoin C on (Pac) = (A leftjoin C on (Pac)) leftjoin B on (Pab)</code></li><li style="list-style-type: disc"><code class="literal">(A leftjoin B on (Pab)) leftjoin C on (Pbc) = (A leftjoin (B leftjoin C on (Pbc)) on (Pab)</code></li></ul></div><p>The last rule only holds if the <code class="literal">Pbc</code> predicate must fail for all null <code class="literal">B</code> rows (that is, <code class="literal">Pbc</code> is strict for at least one column of <code class="literal">B</code>). If <code class="literal">Pbc</code> is not strict, the first form might produce some rows with non-null <code class="literal">C</code> columns, where the second form would make those entries null.</p><p>While some joins can be reordered, a typical type of query cannot benefit from join reordering:</p><pre class="programlisting"><span class="strong"><strong>SELECT ...</strong></span>
<span class="strong"><strong>  FROM a LEFT JOIN b ON (aid = bid)</strong></span>
<span class="strong"><strong>   LEFT JOIN c ON (bid = cid)</strong></span>
<span class="strong"><strong>   LEFT JOIN d ON (cid = did)</strong></span>
<span class="strong"><strong>...</strong></span></pre><p>The way to approach this is to check whether all outer joins are really necessary. In many cases, it happens that people write outer joins <span>without</span><a id="id326300524" class="indexterm"></a> actually <span>needing</span><a id="id326300850" class="indexterm"></a> them. Often, the business case does not even contain the necessity to use outer joins.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec64"></a>Understanding the join_collapse_limit variable</h3></div></div></div><p>During the planning process, PostgreSQL tries to <span>check</span><a id="id326445161" class="indexterm"></a> all possible join orders. In many cases, this can be pretty expensive because there can be many permutations, which naturally slows down the planning process.</p><p>The <code class="literal">join_collapse_limit</code> variable is here to give the developer a tool to actually work around these problems and define, in a more straightforward way, how a query should be processed.</p><p>To show what this setting is all about, we will now compile a little example:</p><pre class="programlisting"><span class="strong"><strong>SELECT </strong></span><span class="strong"><strong>* </strong></span><span class="strong"><strong>FROM tab1, tab2, tab3</strong></span>
<span class="strong"><strong>WHERE tab1.id = tab2.id</strong></span>
<span class="strong"><strong>      AND tab2.ref = tab3.id;</strong></span>
<span class="strong"><strong>SELECT </strong></span><span class="strong"><strong>* </strong></span><span class="strong"><strong>FROM tab1 CROSS JOIN tab2</strong></span>
<span class="strong"><strong>CROSS JOIN tab3</strong></span>
<span class="strong"><strong>WHERE tab1.id = tab2.id</strong></span>
<span class="strong"><strong>      AND tab2.ref = tab3.id;</strong></span>
<span class="strong"><strong>SELECT </strong></span><span class="strong"><strong>* </strong></span><span class="strong"><strong>FROM tab1 JOIN (tab2 JOIN tab3</strong></span>
<span class="strong"><strong>   ON (tab2.ref = tab3.id)) 
   ON (tab1.id = tab2.id);</strong></span></pre><p>Basically, these three queries are identical and treated by the planner in the same way. The first query consists of implicit joins. The last one consists only of explicit joins. Internally, the planner will inspect those requests and order joins accordingly to ensure the best runtime possible. The question here is, how many explicit joins will PostgreSQL plan implicitly? This is exactly what you can tell the planner by setting the <code class="literal">join_collapse_limit</code> variable. The default value is reasonably good for normal queries. However, if your query contains a very high number of joins, playing around with this setting can reduce planning time considerably. Reducing planning time can be essential to maintaining good throughput.</p><p>To see how the <code class="literal">join_collapse_limit</code> variable changes the plan, we will write this simple query:</p><pre class="programlisting"><span class="strong"><strong>test=# EXPLAIN WITH x AS 
( 
  SELECT * 
  FROM  generate_series(1, 1000) AS id 
) 
SELECT * 
FROM x AS a 
  JOIN x AS b ON (a.id = b.id) 
  JOIN x AS c ON (b.id = c.id) 
  JOIN x AS d ON (c.id = d.id) 
  JOIN x AS e ON (d.id = e.id) 
  JOIN x AS f ON (e.id = f.id);</strong></span></pre><p>Try running the query with different <span>settings</span><a id="id326594665" class="indexterm"></a> and see how the plan changes. Unfortunately, the plan is too long to copy here, so it is impossible to include the actual changes in this section.</p></div></div>