<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec57"></a>Digging into row-level security – RLS</h2></div></div><hr /></div><p>Up to this point, a table has <span>always</span><a id="id325876693" class="indexterm"></a> been shown as a whole. When the table contained 1 million rows, it was possible to retrieve 1 million rows from it. If somebody had the rights to read a table, it was all about the entire table. In many cases, this is not enough. Often, it is desirable that a user is not allowed to see all the rows.</p><p>Consider the following real-world example, where an accountant is doing accounting work for many people. The table containing tax rates should really be visible to everybody, as everybody has to pay the same rates. However, when it comes to the actual transactions, the accountant might want to ensure that everybody is only allowed to see his or her own transactions. Person <span class="emphasis"><em>A</em></span> should not be allowed to see person <span class="emphasis"><em>B</em></span>'s data. In addition to that, it might also make sense that the boss of a division is allowed to see all the data in his part of the company.</p><p>Row-level security has been designed to do exactly this and enables you to build multi- tenant systems in a fast and simple way. The way to configure those permissions is to come up with policies. The <code class="literal">CREATE POLICY</code> command is here to provide us with a means to write these rules:</p><pre class="programlisting"><span class="strong"><strong>test=# \h CREATE POLICY
</strong></span><span class="strong"><strong>Command:   CREATE POLICY 
Description: define a new row level security policy for a table 
Syntax: 
CREATE POLICY name ON table_name 
    [ AS {</strong></span><a class="ulink" href="" target="_blank">PERMISSIVE | RESTRICTIVE</a><span class="strong"><strong> } ] 
    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ] 
    [ TO { role_name | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ] 
    [ USING ( using_expression ) ] 
    [ WITH CHECK ( check_expression ) ]</strong></span></pre><p>To depict how a policy can be written, let's first log in as a superuser and create a table containing a couple of entries:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE TABLE t_person (gender text, name text); </strong></span><span class="strong"><strong>CREATE TABLE 
test=# INSERT INTO t_person  
  VALUES     ('male', 'joe'),  
             ('male', 'paul'),  
             ('female', 'sarah'),  
             (NULL, 'R2- D2'); 
INSERT 0 4</strong></span></pre><p>Then access is granted to the <code class="literal">joe</code> role:</p><pre class="programlisting"><span class="strong"><strong>test=# GRANT ALL ON t_person TO joe; </strong></span><span class="strong"><strong>GRANT</strong></span></pre><p>So far, everything is pretty <span>normal</span><a id="id325873176" class="indexterm"></a> and the <code class="literal">joe</code> role will be able to actually read the entire table as there is no RLS in place. But what happens if <code class="literal">ROW LEVEL SECURITY</code> is enabled for the table:</p><pre class="programlisting"><span class="strong"><strong>test=# ALTER TABLE t_person ENABLE ROW LEVEL SECURITY; </strong></span><span class="strong"><strong>ALTER TABLE</strong></span></pre><p>There is a deny all default policy in place, so the <code class="literal">joe</code> role will actually get an empty table:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; SELECT * FROM t_person;</strong></span><span class="strong"><strong> gender | name 
--------+------  
(0 rows) </strong></span></pre><p>Actually, the default policy makes a lot of sense, as users are forced to explicitly set permissions.</p><p>Now that the table is under row-level security control, policies can be written, as a superuser:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE POLICY joe_pol_1 
  ON t_person 
  FOR SELECT TO joe 
  USING  (gender = 'male');</strong></span><span class="strong"><strong>CREATE POLICY </strong></span></pre><p>Logging in as the <code class="literal">joe</code> role and selecting all the data will return just two rows:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; SELECT * FROM  t_person;</strong></span><span class="strong"><strong> gender  | name 
---------+------  
 male    | joe  
 male    | paul 
(2 rows)</strong></span></pre><p>Let's inspect the policy we have just created in a more detailed way. The first thing we see is that a policy actually has a name. It is also connected to a table and allows for certain operations (in this case, the <code class="literal">SELECT</code> clause). Then comes the <code class="literal">USING</code> clause. It basically defines what the <code class="literal">joe</code> role will be allowed to see. The <code class="literal">USING</code> clause is therefore a mandatory filter attached to <span>every</span><a id="id325565414" class="indexterm"></a> query to only select the rows our user is supposed to see.</p><p>There is also one important side node, where if there is more than just a single policy, PostgreSQL will use an <code class="literal">OR</code> condition. In short, more policies will make you see more data by default. In PostgreSQL 9.6, this was always the case. However, with the introduction of PostgreSQL 10.0, the user can choose whether conditions should be <code class="literal">OR</code> and <code class="literal">AND</code> connected:</p><pre class="programlisting"><span class="strong"><strong>PERMISSIVE | RESTRICTIVE</strong></span></pre><p>By default, PostgreSQL is <code class="literal">PERMISSIVE</code> so <code class="literal">OR</code> connections are at work. If we decide to use <code class="literal">RESTRICTIVE</code>, then those clauses will be connected with <code class="literal">AND</code>.</p><p>Now suppose that, for some reason, it has been decided that the <code class="literal">joe</code> role is also allowed to see robots. There are two choices to achieve our goal. The first option is to simply use the <code class="literal">ALTER POLICY</code> clause to change the existing policy:</p><pre class="programlisting"><span class="strong"><strong>postgres=# \h ALTER POLICY</strong></span>
<span class="strong"><strong>Command: ALTER POLICY</strong></span>
<span class="strong"><strong>Description: change the definition of a row level security policy</strong></span>
<span class="strong"><strong>Syntax:</strong></span>
<span class="strong"><strong>ALTER POLICY name ON table_name RENAME TO new_name</strong></span>

<span class="strong"><strong>ALTER POLICY name ON table_name</strong></span>
<span class="strong"><strong>    [ TO { role_name | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]</strong></span>
<span class="strong"><strong>    [ USING ( using_expression ) ]</strong></span>
<span class="strong"><strong>    [ WITH CHECK ( check_expression ) ]</strong></span></pre><p>The second option is to create a second policy, as shown in the next example:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE POLICY joe_pol_2 
  ON t_person 
  FOR SELECT TO joe 
  USING  (gender IS NULL);</strong></span><span class="strong"><strong>CREATE POLICY</strong></span></pre><p>The beauty is that those policies are simply <span>connected</span><a id="id325856125" class="indexterm"></a> using an <code class="literal">OR</code>  condition as stated before, unless <code class="literal">RESTRICTIVE</code> is used. Therefore, PostgreSQL will now return three rows instead of two:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; SELECT * FROM  t_person;</strong></span><span class="strong"><strong> gender  | name 
---------+-------  
 male    | joe  
 male    | paul 
         | R2-D2  
(3 rows)</strong></span></pre><p>The <code class="literal">R2-D2</code> role is now also included in the result, as it matches the second policy.</p><p>To depict how PostgreSQL runs the query, I have decided to include an execution plan of the query:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; explain SELECT * FROM t_person; </strong></span><span class="strong"><strong>                        QUERY PLAN </strong></span>
<span class="strong"><strong>---------------------------------------------------------- </strong></span>
<span class="strong"><strong> Seq Scan on t_person (cost=0.00..21.00 rows=9 width=64) </strong></span>
<span class="strong"><strong>   Filter: ((gender IS NULL) OR (gender = 'male'::text)) </strong></span>
<span class="strong"><strong>(2 rows)</strong></span></pre><p>As we can see, both the <code class="literal">USING</code> clauses have been added as mandatory filters to the query. We might have noticed in the syntax definition that there are two types of clauses:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">USING</code>: This clause filters rows that already exist. This is relevant to the <code class="literal">SELECT</code> and <code class="literal">UPDATE</code> clauses, and so on.</li><li style="list-style-type: disc"><code class="literal">CHECK</code>: This clause filters new rows that are about to be created, so they are relevant to the <code class="literal">INSERT</code> and <code class="literal">UPDATE</code> clauses, and so on.</li></ul></div><p>Here is what happens if we try to insert a row:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; INSERT INTO t_person VALUES ('male', 'kaarel');</strong></span><span class="strong"><strong>ERROR:  new row violates row-level security policy for table "t_person"</strong></span></pre><p>As there is no policy for the <code class="literal">INSERT</code> clause, the statement will naturally error out. Here is the policy to allow insertions:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE POLICY joe_pol_3 
           ON t_person 
           FOR INSERT TO joe 
           WITH CHECK (gender IN ('male', 'female'));</strong></span><span class="strong"><strong>CREATE POLICY</strong></span></pre><p>The <code class="literal">joe</code> role is allowed to add males and females to the table, which is shown in the following listing:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; INSERT INTO t_person VALUES ('female', 'maria');</strong></span><span class="strong"><strong>INSERT 0 1</strong></span></pre><p>However, there is also a catch; consider the following example:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; INSERT INTO  t_person VALUES ('female', 'maria') RETURNING *;</strong></span><span class="strong"><strong>ERROR:  new row violates row-level security policy for table "t_person"</strong></span></pre><p>Remember, there is only a policy to select males. The trouble here is that the <span>statement</span><a id="id326300474" class="indexterm"></a> will return a woman, which is not allowed because the <code class="literal">joe</code> role is under a male-only policy.</p><p>Only for men will the <code class="literal">RETURNING *</code> clause actually work:</p><pre class="programlisting"><span class="strong"><strong>test=&gt; INSERT INTO  t_person VALUES ('male', 'max') RETURNING *;</strong></span><span class="strong"><strong> gender  | name 
---------+------  
 male    | max 
(1 row) 
INSERT 0 1</strong></span></pre><p>If we don't want this behavior, we have to write a policy that actually contains a proper <code class="literal">USING</code> clause.</p></div>