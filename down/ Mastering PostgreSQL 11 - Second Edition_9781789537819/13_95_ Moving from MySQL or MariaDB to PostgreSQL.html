<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec91"></a>Moving from MySQL or MariaDB to PostgreSQL</h2></div></div><hr /></div><p>In this chapter, you have already learned some valuable lessons about how to move from databases such as Oracle to PostgreSQL. Migrating both MySQL and MariaDB database systems to PostgreSQL is fairly easy. The reason for this is that Oracle might be expensive and a bit cumbersome from time to time. The same applies to Informix. However, both Informix and <span>Oracle</span><a id="id326024236" class="indexterm"></a> have one <span>important</span><a id="id326024230" class="indexterm"></a> thing in common: <code class="literal">CHECK</code> constraints are honored properly and data types are <span>properly</span><a id="id326024218" class="indexterm"></a> handled. In general, we can safely <span>assume</span><a id="id326024209" class="indexterm"></a> that the data in those commercial systems is somewhat correct and doesn't violate the most basic rules of data integrity and common sense.</p><p>Our next candidate is different. Many things you know about commercial databases are not true in MySQL. The term <code class="literal">NOT NULL</code> does not mean much to MySQL (unless you explicitly use strict mode). In Oracle, Informix, Db2, and all other systems I am aware of, <code class="literal">NOT NULL</code> is a law that is obeyed under all circumstances. MySQL does not take these constraints that seriously by default (although, to be fair, this has been changed in recent versions. Strict mode was not <span class="emphasis"><em>on</em></span> by default up until very recently. However, many old databases still use the old default settings). In case of migration, this causes some issues. What are you going to do with data that is technically wrong? If your <code class="literal">NOT NULL</code> column suddenly reveals countless <code class="literal">NULL</code> entries, how are you going to handle that? MySQL doesn't just insert <code class="literal">NULL</code> values in <code class="literal">NOT NULL</code> columns. It will insert an empty string or zero based on the datatype. So, things can get pretty nasty.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec151"></a>Handling data in MySQL and MariaDB</h3></div></div></div><p>As you might imagine, and as you might have already noticed, I am far from unbiased when it comes to databases. However, I don't want to turn this into blind MySQL/MariaDB bashing. Our real goal is to see why MySQL and <span>MariaDB</span><a id="id326024162" class="indexterm"></a> can be <span>such</span><a id="id326024154" class="indexterm"></a> a pain in the long run. I am biased for a reason and I really want to point out why this is the case. All of the things we are going to see are deeply scary and have serious implications on the migration process in general. I have pointed out already that MySQL is somewhat special, and this section will try and prove my point.</p><p>Again, the following examples assume that we are using a version of MySQL/MariaDB that does not have strict mode on, which was the case when this chapter was originally written (as of PostgreSQL 9.6). As of PostgreSQL 10.0, strict mode is already on, so most of what we are are going to read here only applies to older versions of MySQL/MariaDB.</p><p>Let's get started by creating a simple table:</p><pre class="programlisting"><span class="strong"><strong>MariaDB [test]&gt; CREATE TABLE data ( </strong></span>
<span class="strong"><strong>   id integer NOT NULL, </strong></span>
<span class="strong"><strong>   data numeric(4, 2) </strong></span>
<span class="strong"><strong>); </strong></span>
<span class="strong"><strong>Query OK, 0 rows affected (0.02 sec) </strong></span>

<span class="strong"><strong>MariaDB [test]&gt; INSERT INTO data VALUES (1, 1234.5678); </strong></span>
<span class="strong"><strong>Query OK, 1 row affected, 1 warning (0.01 sec)</strong></span></pre><p>So far, there is nothing special. We have created a table consisting of two columns. The first column is explicitly marked as <code class="literal">NOT NULL</code>. The second column is supposed to contain a numeric value, which is limited to four digits. Finally, we have added a simple row. Can you see a <span>potential</span><a id="id325872906" class="indexterm"></a> landmine <span>about</span><a id="id325872915" class="indexterm"></a> to blow up? Most likely not. However, check the following listing:</p><pre class="programlisting"><span class="strong"><strong>MariaDB [test]&gt; SELECT </strong></span><span class="strong"><strong>* FROM data; 
+----+-------+ </strong></span>
<span class="strong"><strong>| id | data  | </strong></span>
<span class="strong"><strong>+----+-------+ </strong></span>
<span class="strong"><strong>| 1  | 99.99 | </strong></span>
<span class="strong"><strong>+----+-------+ </strong></span>
<span class="strong"><strong>1 row in set (0.00 sec)</strong></span></pre><p>If I remember correctly, we have added a four digit number, which should not have worked in the first place. However, MariaDB has simply changed my data. Sure, a warning is issued, but this is not supposed to happen as the content of the table does not reflect what we have actually inserted.</p><p>Let's try and do the same thing in PostgreSQL:</p><pre class="programlisting"><span class="strong"><strong>test=# CREATE </strong></span><span class="strong"><strong>TABLE data 
</strong></span><span class="strong"><strong>(</strong></span>
<span class="strong"><strong>id integer NOT NULL,</strong></span>
<span class="strong"><strong>data numeric(4, 2) 
</strong></span><span class="strong"><strong>); 
CREATE TABLE 
test=# INSERT INTO data VALUES (1, 1234.5678); 
ERROR: numeric field overflow </strong></span>
<span class="strong"><strong>DETAIL: A field with precision 4, scale 2 must round to an absolute value less than 10^2.</strong></span></pre><p>The table was created, just like earlier, but in stark contrast to MariaDB/MySQL, PostgreSQL will error out because we are trying to insert a value into the table that is clearly not allowed. What is the point in clearly defining what we want if the database engine just does not care? Suppose you have won the lottery—you might have just lost a couple of million because the system has decided what is good for you.</p><p>I have been <span>fighting</span><a id="id325887850" class="indexterm"></a> commercial <span>databases</span><a id="id325887859" class="indexterm"></a> all my life, but I have never seen similar things in any of the expensive commercial systems (Oracle, Db2, Microsoft SQL Server, and so on). They might have issues of their own, but the data is just fine in general.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec103"></a>Changing column definitions</h4></div></div></div><p>Let's see what <span>happens</span><a id="id326002904" class="indexterm"></a> if you want to modify the <span>table</span><a id="id326002913" class="indexterm"></a> definition:</p><pre class="programlisting"><span class="strong"><strong>MariaDB [test]&gt; </strong></span><span class="strong"><strong>ALTER TABLE data MODIFY data numeric(3, 2); 
Query OK, 1 row affected, 1 warning (0.06 sec) </strong></span>
<span class="strong"><strong>Records: 1 Duplicates: 0 Warnings: 1</strong></span></pre><p>You should see a problem here:</p><pre class="programlisting"><span class="strong"><strong>MariaDB [test]&gt; SELECT </strong></span><span class="strong"><strong>* FROM data; 
+----+------+ </strong></span>
<span class="strong"><strong>| id | data | </strong></span>
<span class="strong"><strong>+----+------+ </strong></span>
<span class="strong"><strong>| 1  | 9.99 | </strong></span>
<span class="strong"><strong>+----+------+</strong></span>
<span class="strong"><strong>1 row in set (0.00 sec)</strong></span></pre><p>As you can see, the data has been modified again. It should not have been there in the first place and has been changed all over again. Remember, you might have lost money again, or some other nice asset, because MySQL tried to be clever.</p><p>This is what happens in PostgreSQL:</p><pre class="programlisting"><span class="strong"><strong>test=# INSERT</strong></span><span class="strong"><strong>INTO data VALUES (1, 34.5678); 
INSERT  0 1 </strong></span>
<span class="strong"><strong>test=# SELECT * FROM data; 
 id  | data </strong></span>
<span class="strong"><strong>-----+------- </strong></span>
<span class="strong"><strong> 1   | 34.57 </strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>Let's change the column definition now:</p><pre class="programlisting"><span class="strong"><strong>test=# </strong></span><span class="strong"><strong>ALTER TABLE data ALTER COLUMN data 
</strong></span><span class="strong"><strong>    TYPE numeric(3, 2); 
ERROR: numeric field overflow </strong></span>
<span class="strong"><strong>DETAIL:  A field with precision 3, scale 2 must round to </strong></span>
<span class="strong"><strong>an absolute value less than 10^1.</strong></span></pre><p>Again, PostgreSQL will error out and it won't allow us to do nasty things to our data. The same is expected to happen in any important database. The rule is simple: PostgreSQL and others won't allow us to destroy our data. </p><p>However, PostgreSQL allows you to do one thing:</p><pre class="programlisting"><span class="strong"><strong>test=# ALTER TABLE data </strong></span>
<span class="strong"><strong>   ALTER COLUMN data </strong></span>
<span class="strong"><strong>         TYPE numeric(3, 2) </strong></span>
<span class="strong"><strong>         USING (data / 10); </strong></span>
<span class="strong"><strong>ALTER TABLE</strong></span></pre><p>We can explicitly tell the system how to behave. In this case, we explicitly told PostgreSQL to divide the content of the column by <code class="literal">10</code>. Developers can <span>explicitly</span><a id="id326191246" class="indexterm"></a> provide the rules <span>applied</span><a id="id326191257" class="indexterm"></a> to the data. PostgreSQL won't try and be smart, and it does so for good reason:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT</strong></span><span class="strong"><strong>* FROM data; 
 id  | data </strong></span>
<span class="strong"><strong>-----+------ </strong></span>
<span class="strong"><strong> 1   | 3.46 </strong></span>
<span class="strong"><strong>(1 row)</strong></span></pre><p>The data is exactly as expected.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec104"></a>Handling null values</h4></div></div></div><p>We don't want to turn this into a why <span>MariaDB</span><a id="id326436523" class="indexterm"></a> is bad chapter, but I wanted to add a <span>final</span><a id="id325895927" class="indexterm"></a> example here, which I consider to be of high importance:</p><pre class="programlisting"><span class="strong"><strong>MariaDB [test]&gt; UPDATE </strong></span><span class="strong"><strong>data SET id = NULL WHERE id = 1;
Query OK, 1 row affected, 1 warning (0.01 sec)</strong></span>
<span class="strong"><strong>Rows matched: 1 </strong></span><span class="strong"><strong>Changed: 1 </strong></span><span class="strong"><strong>Warnings: 1</strong></span></pre><p>The <code class="literal">id</code> column was explicitly marked as <code class="literal">NOT NULL</code>:</p><pre class="programlisting"><span class="strong"><strong>MariaDB [test]&gt; SELECT </strong></span><span class="strong"><strong>* FROM data; 
+----+------+ </strong></span>
<span class="strong"><strong>| id | data | </strong></span>
<span class="strong"><strong>+----+------+ </strong></span>
<span class="strong"><strong>| 0  | 9.99 | </strong></span>
<span class="strong"><strong>+----+------+ </strong></span>
<span class="strong"><strong>1 row in set (0.00 sec)</strong></span></pre><p>Obviously, MySQL and MariaDB think that null and zero are the same thing. Let me try and explain the problem with a simple analogy: if you know your wallet is empty, it is not the same as not knowing how much you have. As I am writing these lines, I don't know how much money I have with me (<code class="literal">null = unknown</code>), but I am 100% sure that it is way more than zero (I know with certainty that there is enough to refuel my beloved car on the way home from the airport, which is hard to do if you have nothing in your pocket).</p><p>Here is more scary news:</p><pre class="programlisting"><span class="strong"><strong>MariaDB [test]&gt; DESCRIBE data; 
+-------+--------------+------+-----+---------+-------+ </strong></span>
<span class="strong"><strong>| Field | Type | Null | Key | Default | Extra | </strong></span>
<span class="strong"><strong>+-------+--------------+------+-----+---------+-------+ </strong></span>
<span class="strong"><strong>| id | int(11) | NO | | NULL | | </strong></span>
<span class="strong"><strong>| data | decimal(3,2) | YES | | NULL | | </strong></span>
<span class="strong"><strong>+-------+--------------+------+-----+---------+-------+ </strong></span>
<span class="strong"><strong>2 rows in set (0.00 sec)</strong></span></pre><p>MariaDB does remember that the <span>column</span><a id="id325896174" class="indexterm"></a> is <span>supposed</span><a id="id325896183" class="indexterm"></a> to be <code class="literal">NOT NULL</code>, however it simply modifies your data again.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec105"></a>Expecting problems</h4></div></div></div><p>The main problem is that we might have trouble <span>moving</span><a id="id325943682" class="indexterm"></a> data to PostgreSQL. Just imagine that <span>you</span><a id="id325943690" class="indexterm"></a> want to move some data and there is a <code class="literal">NOT NULL</code> constraint on the PostgreSQL side. We know that MySQL does not care:</p><pre class="programlisting"><span class="strong"><strong>MariaDB [test]&gt; SELECT </strong></span>
<span class="strong"><strong>CAST('2014-02-99 10:00:00' </strong></span><span class="strong"><strong>AS datetime) AS x, 
</strong></span><span class="strong"><strong>     CAST('2014-02-09 10:00:00' </strong></span><span class="strong"><strong>AS datetime) AS y; 
+------+---------------------+ </strong></span>
<span class="strong"><strong>| x | y | </strong></span>
<span class="strong"><strong>+------+---------------------+ </strong></span>
<span class="strong"><strong>| NULL | 2014-02-09 10:00:00 | </strong></span>
<span class="strong"><strong>+------+---------------------+ </strong></span>
<span class="strong"><strong>1 row in set, 1 warning (0.00 sec)</strong></span></pre><p>PostgreSQL will definitely reject February 99 (for a good reason), but it might not accept the <code class="literal">NULL</code> value either if you have explicitly banned it (for a good reason). What you have to do in this case is somehow fix the data to make sure that it honors the rules of your data models, which are in place for a reason. You should not take this lightly because you might have to change data, which is actually wrong in the first place.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec152"></a>Migrating data and schema</h3></div></div></div><p>After trying to explain why <span>moving</span><a id="id325951436" class="indexterm"></a> to PostgreSQL is a <span>good</span><a id="id325951445" class="indexterm"></a> idea, and <span>after</span><a id="id325951453" class="indexterm"></a> outlining some of the <span>most</span><a id="id325951462" class="indexterm"></a> important issues, it is time for me to explain some of the possible options we have to finally get rid of MySQL/MariaDB.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec106"></a>Using pg_chameleon</h4></div></div></div><p>One way to <span>move</span><a id="id325951478" class="indexterm"></a> from MySQL/MariaDB to PostgreSQL is to <span>use</span><a id="id325951486" class="indexterm"></a> Federico Campoli's tool, called <code class="literal">pg_chameleon</code>, which can be downloaded for free from GitHub (<a class="ulink" href="https://github.com/the4thdoctor/pg_chameleon" target="_blank"><span>h</span><span>t</span><span>t</span><span>p</span><span>s</span><span>://</span><span>g</span><span>i</span><span>t</span><span>h</span><span>u</span><span>b</span><span>.</span><span>c</span><span>o</span><span>m</span><span>/t</span><span>h</span><span>e</span><span>4</span><span>t</span><span>h</span><span>d</span><span>o</span><span>c</span><span>t</span><span>o</span><span>r</span><span>/</span><span>p</span><span>g</span><span>_</span><span>c</span><span>h</span><span>a</span><span>m</span><span>e</span><span>l</span><span>e</span><span>o</span><span>n</span></a>). It has been explicitly designed to <span>replicate</span><a id="id325981799" class="indexterm"></a> data to <span>PostgreSQL</span><a id="id325981808" class="indexterm"></a> and does a lot of work, such as converting the schema for us.</p><p>Basically, the tool performs the following four steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><code class="literal">pg_chameleon</code> reads the schema and data from MySQL and creates a schema in PostgreSQL.</li><li>It stores MySQL's master connection information in PostgreSQL.</li><li>It creates primary keys and indices in PostgreSQL.</li><li>It replicates from MySQL/MariaDB to PostgreSQL.</li></ol></div><p>The <code class="literal">pg_chameleon</code> tool provides basic support for DDLs such as <code class="literal">CREATE</code>, <code class="literal">DROP</code>, <code class="literal">ALTER TABLE</code>, and <code class="literal">DROP PRIMARY KEY</code>. However, due to the nature of MySQL/MariaDB, it does not support all DDLs. Instead, it covers the most important features.</p><p>However, there is more to <code class="literal">pg_chameleon</code>. I have stated extensively already that data is not always the way it should be or is expected to be. The way <code class="literal">pg_chameleon</code> approaches the problem is to discard rubbish data and store it in a table called <code class="literal">sch_chameleon.t_discarded_rows</code>. Of course, this is not a perfect solution but, given the fairly low-quality input, it is the only sensible solution that comes to my mind. The idea is to let developers decide what to do with all the broken rows. There is really no way for <code class="literal">pg_chameleon</code> to decide on how to handle something that has been broken by somebody else.</p><p>Recently, a lot of development has taken place and a lot of work has gone into the tool. Therefore, it is really recommended to <span>check</span><a id="id325990064" class="indexterm"></a> out the GitHub page and read <span>through</span><a id="id325990072" class="indexterm"></a> all the documentation. Features and bug fixes are being added as we speak. Given the <span>limited</span><a id="id325990081" class="indexterm"></a> scope of this chapter, full coverage is not possible here.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip96"></a>Note</h3><p>Stored procedures, triggers, and more need special treatment and can only be handled manually. The <code class="literal">pg_chameleon</code> tool cannot process these things automatically.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch13lvl3sec107"></a>Using FDWs</h4></div></div></div><p>If we want to move from MySQL/MariaDB to PostgreSQL, there is <span>more</span><a id="id326006865" class="indexterm"></a> than one way to succeed. The <span>use</span><a id="id326006873" class="indexterm"></a> of FDWs is an alternative to <code class="literal">pg_chameleon</code> and offers a way to quickly fetch the schema as well as the data and import it into PostgreSQL. The ability to connect MySQL and PostgreSQL has <span>been</span><a id="id326006885" class="indexterm"></a> around for quite a while, and therefore FDWs are definitely a field that can be exploited to your advantage.</p><p>Basically, the <code class="literal">mysql_fdw</code> extension works just like any other FDW out there. Compared to other, lesser-known FDWs, the <code class="literal">mysql_fdw</code> extension is actually quite powerful and offers the following features:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Writing to MySQL/MariaDB</li><li style="list-style-type: disc">Connection pooling</li><li style="list-style-type: disc">The <code class="literal">WHERE</code> clause push down (which means that filters applied on a table can actually be executed remotely for better performance)</li><li style="list-style-type: disc">Column push down (only the columns needed are fetched from the remote side; older versions are used to fetch all the columns, which leads to more network traffic)</li><li style="list-style-type: disc">Prepared statements on the remote side</li></ul></div><p>The way to use the <code class="literal">mysql_fdw</code> extension is to make use of the <code class="literal">IMPORT FOREIGN SCHEMA</code> statement, which allows for moving data over to PostgreSQL. Fortunately, this is fairly easy to do on a Unix system. Let us take a look at the steps needed in detail.</p><p>The first thing we have to do is download the code from GitHub:</p><pre class="programlisting"><span class="strong"><strong>git clone https://github.com/EnterpriseDB/mysql_fdw.git</strong></span></pre><p>Then, run the following commands to compile the FDW. Note that the paths might differ on your system. For this chapter, I have assumed that both MySQL and PostgreSQL are under the <code class="literal">/usr/local</code> directory, which might not be the case on your system:</p><pre class="programlisting"><span class="strong"><strong>$ export PATH=/usr/local/pgsql/bin/:$PATH 
</strong></span><span class="strong"><strong>$ export PATH=/usr/local/mysql/bin/:$PATH 
</strong></span><span class="strong"><strong>$ make USE_PGXS=1 
</strong></span><span class="strong"><strong>$ make USE_PGXS=1 install</strong></span></pre><p>Once the <span>code</span><a id="id326013584" class="indexterm"></a> has <span>been</span><a id="id326013592" class="indexterm"></a> compiled, the FDW can be <span>added</span><a id="id326013601" class="indexterm"></a> to our database:</p><pre class="programlisting"><span class="strong"><strong>CREATE EXTENSION mysql_fdw;</strong></span></pre><p>The next step is to create the server we want to migrate:</p><pre class="programlisting"><span class="strong"><strong>CREATE SERVER migrate_me_server 
</strong></span><span class="strong"><strong>   FOREIGN </strong></span><span class="strong"><strong>DATA WRAPPER mysql_fdw 
</strong></span><span class="strong"><strong>   OPTIONS </strong></span><span class="strong"><strong>(host 'host.example.com', port '3306');</strong></span></pre><p>Once the server has been created, we can create the desired user mappings:</p><pre class="programlisting"><span class="strong"><strong>CREATE </strong></span><span class="strong"><strong>USER MAPPING FOR postgres 
</strong></span><span class="strong"><strong>   SERVER migrate_me_server 
</strong></span><span class="strong"><strong>   OPTIONS (username 'joe', password 'public');</strong></span></pre><p>Finally, it is time to do the real migration. The first thing to do is to import the schema. I suggest creating a special schema for the linked tables first:</p><pre class="programlisting"><span class="strong"><strong>CREATE SCHEMA migration_schema;</strong></span></pre><p>When running the <code class="literal">IMPORT FOREIGN SCHEMA</code> statement, we can use this schema as the target schema in which all the database links will be stored. The advantage is that we can delete it conveniently after the migration.</p><p>Once we are done with the <code class="literal">IMPORT FOREIGN SCHEMA</code> statement, we can create real tables. The easiest way to do this is to use the <code class="literal">LIKE</code> keyword that's provided by the <code class="literal">CREATE TABLE</code> clause. It allows us to copy the structure of a table and create a real, local PostgreSQL table. Fortunately, this also works if the table you are cloning is just an FDW. Here is an example of this:</p><pre class="programlisting"><span class="strong"><strong>CREATE </strong></span><span class="strong"><strong>TABLE t_customer 
</strong></span><span class="strong"><strong>    (LIKE migration_schema.t_customer);</strong></span></pre><p>Then, we can process the data:</p><pre class="programlisting"><span class="strong"><strong>INSERT </strong></span><span class="strong"><strong>INTO t_customer 
</strong></span><span class="strong"><strong>   SELECT </strong></span><span class="strong"><strong>* FROM migration_schema.t_customer</strong></span></pre><p>This is actually the point where we can correct the data, eliminate chunk rows, or do a bit of processing of the data. Given the low-quality origin of the data, it can be useful to apply constraints and so on after moving the data for the first time. It might be less painful.</p><p>Once the data has been imported, we are ready to deploy all of the constraints, indexes, and so on. At this point, you will actually <span>start</span><a id="id326132502" class="indexterm"></a> to see <span>some</span><a id="id326132510" class="indexterm"></a> nasty <span>surprises</span><a id="id326132519" class="indexterm"></a> because, as I stated previously, you can't expect the data to be rock solid. In general, migration can be pretty hard in the case of MySQL.</p></div></div></div>