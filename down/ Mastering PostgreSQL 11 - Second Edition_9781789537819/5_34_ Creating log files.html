<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec38"></a>Creating log files</h2></div></div><hr /></div><p>After taking a deep look at the <span>system</span><a id="id326373303" class="indexterm"></a> views provided by PostgreSQL, it is time to configure logging. Fortunately, PostgreSQL provides an easy way to work with log files and helps people set up a good configuration easily.</p><p>Collecting logs is important because it can point to errors and potential database problems.</p><p>The <code class="literal">postgresql.conf</code> file has all the parameters you need to provide you with all the necessary information.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec58"></a>Configuring the postgresql.conf file</h3></div></div></div><p>In this section, we will go through some of the <span>most</span><a id="id326373281" class="indexterm"></a> important entries in the <code class="literal">postgresql.conf</code> file to configure logging and see how logging can be used in the most beneficial way.</p><p>Before we get started, I want to say a few words about logging in PostgreSQL in general. On Unix systems, PostgreSQL will send log information to <code class="literal">stderr</code> by default. However, <code class="literal">stderr</code> is not a good place for logs to go because you will surely want to inspect the log stream at <span>some</span><a id="id326373258" class="indexterm"></a> point. Therefore, it really makes sense to work through this chapter and adjust things to your needs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec33"></a>Defining log destination and rotation</h4></div></div></div><p>Let's go <span>through</span><a id="id326325280" class="indexterm"></a> the <code class="literal">postgresql.conf</code> file and see what can be done:</p><pre class="programlisting"><span class="strong"><strong>#----------------------------------------------------------------- </strong></span>
<span class="strong"><strong># ERROR REPORTING AND LOGGING </strong></span>
<span class="strong"><strong>#---------------------------------------------------------------- </strong></span>

<span class="strong"><strong># - Where to Log - </strong></span>

<span class="strong"><strong>#log_destination = 'stderr' </strong></span>
<span class="strong"><strong>                    # Valid values are combinations of </strong></span>
<span class="strong"><strong>                    # stderr, csvlog, syslog, and eventlog, </strong></span>
<span class="strong"><strong>                    # depending on platform. csvlog </strong></span>
<span class="strong"><strong>                    # requires logging_collector to be on. </strong></span>

<span class="strong"><strong># This is used when logging to stderr: </strong></span>
<span class="strong"><strong>#logging_collector = off </strong></span>
<span class="strong"><strong>                    # Enable capturing of stderr and csvlog </strong></span>
<span class="strong"><strong>                    # into log files. Required to be on for </strong></span>
<span class="strong"><strong>                    # csvlogs.</strong></span>
<span class="strong"><strong># (change requires restart)</strong></span></pre><p>The first configuration option defines how the log is processed. By default, it will go to <code class="literal">stderr</code> (on Unix). On Windows, the default is <code class="literal">eventlog</code>, which is the Windows on-board tool to handle logging. Alternatively, you can choose to go with <code class="literal">csvlog</code> or <code class="literal">syslog</code>.</p><p>If you want to make PostgreSQL log files, you should go for <code class="literal">stderr</code> and turn the logging collector on. PostgreSQL will then create log files.</p><p>The logical question now is: what will the names of those log files be and where will those files be stored? Fortunately, <code class="literal">postgresql.conf</code> has the answer:</p><pre class="programlisting"><span class="strong"><strong># These are only used if logging_collector is on: </strong></span>
<span class="strong"><strong>#log_directory = 'pg_log' </strong></span>
<span class="strong"><strong>                 # directory where log files are written, </strong></span>
<span class="strong"><strong>                 # can be absolute or relative to PGDATA </strong></span>
<span class="strong"><strong>#log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log' </strong></span>
<span class="strong"><strong>                 # log file name pattern, </strong></span>
<span class="strong"><strong>                 # can include strftime() escapes</strong></span></pre><p>Furthermore, <code class="literal">log_directory</code> will tell the system where to store the log. If you are using an absolute path, you can explicitly configure where logs will go. If you prefer the logs to be in the PostgreSQL data directly, simply go for a relative path. The advantage is that the data directory will be self-contained and you can move it without having to worry.</p><p>In the next step, you can define the filename PostgreSQL is supposed to use. PostgreSQL is very flexible and allows you to use all the shortcuts provided by <code class="literal">strftime</code>. To give you an impression of how powerful this feature is, a quick count on my platform reveals that <code class="literal">strftime</code> provides 43 (!) placeholders to create the filename. Everything people usually need is certainly possible.</p><p>Once the filename has been defined, it makes sense to briefly think about cleanup. The following settings will be available:</p><pre class="programlisting"><span class="strong"><strong>#log_truncate_on_rotation = off 
#log_rotation_age = 1d 
#log_rotation_size = 10MB </strong></span></pre><p>By default, PostgreSQL will keep producing log files in case files are older than 1 day or larger than 10 MB. Additionally, <code class="literal">log_truncate_on_rotation</code> specifies if you want to append to a log file or not. Sometimes, a <code class="literal">log_filenames</code> is defined in a way that it becomes cyclic. The <code class="literal">log_truncate_on_rotation</code> parameter defines whether to overwrite or to append to the file that already exists. Given the default log file, this will, of course, not happen.</p><p> </p><p>One way to handle auto-rotation is to use something like <code class="literal">postgresql_%a.log</code>, along with <code class="literal">log_truncate_on_rotation = on</code>. <code class="literal">%a</code> means that the day of the week will be used inside the log file. The advantage here is that the day of the week tends to repeat itself every 7 days. Therefore, the log will be kept for a week and recycled. If you are aiming for weekly rotation, a 10 MB file size might not be enough. Consider turning the maximum file size off.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec34"></a>Configuring syslog</h4></div></div></div><p>Some people prefer to use <code class="literal">syslog</code> to collect log files. PostgreSQL <span>offers</span><a id="id325664421" class="indexterm"></a> the following configuration parameters:</p><pre class="programlisting"><span class="strong"><strong># These are relevant when logging to syslog: 
#syslog_facility = 'LOCAL0' 
#syslog_ident = 'postgres' 
#syslog_sequence_numbers = on 
#syslog_split_messages = on</strong></span></pre><p>One <code class="literal">syslog</code> is pretty popular among <code class="literal">sys</code> admins. Fortunately, it is easy to configure. Basically, you set a facility and an identifier. If <code class="literal">log_destination</code> is set to <code class="literal">syslog</code>, this is already everything there is to do.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec35"></a>Logging slow queries</h4></div></div></div><p>The log can also be <span>used</span><a id="id325854947" class="indexterm"></a> to track down individual slow queries. Back in the old days, this was pretty much the only way to spot performance problems.</p><p>How does it work? Basically, <code class="literal">postgresql.conf</code> has a variable called <code class="literal">log_min_duration_statement</code>. If this is set to a value greater than zero, every query exceeding our chosen setting will make it to the log:</p><pre class="programlisting"><span class="strong"><strong># log_min_duration_statement = -1</strong></span></pre><p>Most people see the slow query log as the ultimate source of wisdom. However, I would like to add a word of caution. There are many slow queries, and they just happen to eat up a lot of CPU: index creation, data exports, analytics, and so on.</p><p>Those long-running queries are totally expected and are in many cases not the root of all evil. It happens frequently that many shorter queries are to blame. Here is an example:</p><p>1,000 queries x 500 milliseconds is worse than 2 queries x 5 seconds. The slow query log can be misleading in some cases.</p><p>Still, it does not mean that it is pointless—it just means that it is a source of information and not the source of information.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec36"></a>Defining what and how to log</h4></div></div></div><p>After taking a look at some basic settings, it is time to <span>decide</span><a id="id325861484" class="indexterm"></a> what to log. By default, only errors will be logged. However, this might not be enough. In this section, you will learn about what can be logged and what a log line will look like.</p><p>By default, PostgreSQL does not log information about checkpoints. The following setting is there to change exactly that:</p><pre class="programlisting"><span class="strong"><strong>#log_checkpoints = off</strong></span></pre><p>The same applies to connections; whenever a connection is established or properly destroyed, PostgreSQL can create log entries:</p><pre class="programlisting"><span class="strong"><strong>#log_connections = off 
#log_disconnections = off</strong></span></pre><p>In most cases, it does not make sense to log connections, as extensive logging significantly slows down the systems. Analytical systems won't suffer much. However, OLTP might be seriously impacted.</p><p>If you want to see how long statements take, consider switching the following setting to on:</p><pre class="programlisting"><span class="strong"><strong>#log_duration = off</strong></span></pre><p>Let's move on to one of the most important settings. We have not defined the layout of the messages yet, and so far, the log files contain errors in the following form:</p><pre class="programlisting"><span class="strong"><strong>test=# SELECT 1 / 0;  
ERROR: division by zero</strong></span></pre><p>The log will state <code class="literal">ERROR</code>, along with the error message. Before PostgreSQL 10.0, there wasn't a timestamp, username, and so on. You had to change the value immediately to make any sense of the logs. In PostgreSQL 10.0, the default value has changed to something much more reasonable: to change that, take a look at <code class="literal">log_line_prefix</code>:</p><pre class="programlisting"><span class="strong"><strong>#log_line_prefix = '%m [%p] '  
# special values: 
#   %a = application name 
#   %u = user name 
#   %d = database name 
#   %r = remote host and port 
#   %h = remote host 
#   %p = process ID 
#   %t = timestamp without milliseconds 
#   %m = timestamp with milliseconds 
#   %n = timestamp with milliseconds (as a Unix epoch) 
#   %i = command tag 
#   %e = SQL state 
#   %c = session ID 
#   %l = session line number 
#   %s = session start timestamp 
#   %v = virtual transaction ID 
#   %x = transaction ID (0 if none) 
#   %q = stop here in non-session processes 
#   %% = '%'</strong></span></pre><p>Furthermore, <code class="literal">log_line_prefix</code> is pretty flexible and allows you to configure the log line to exactly match your needs. In general, it is a good idea to log a timestamp. Otherwise, it is close to impossible to see when something bad has happened. Personally, I also like to know the username, the transaction ID, and the database. However, it is up to you to decide on what you really need.</p><p>Sometimes, slowness is caused by bad locking behavior. Users blocking each other can cause bad performance and it is important to sort out those issues to ensure high throughput. In general, locking-related issues can be hard to track down. Basically, <code class="literal">log_lock_waits</code> can help to detect such issues. If a lock is held longer than <code class="literal">deadlock_timeout</code>, then a line will be sent to the log, provided that the following configuration variable is turned on:</p><pre class="programlisting"><span class="strong"><strong>#log_lock_waits = off</strong></span></pre><p>Finally, it is time to tell PostgreSQL what to actually log. So far, only errors, slow queries, and the like have been sent to the log. However, <code class="literal">log_statement</code> has four possible settings:</p><pre class="programlisting"><span class="strong"><strong>#log_statement = 'none' 
      # none, ddl, mod, all</strong></span></pre><p>Note that <code class="literal">none</code> means that only errors will be logged. <code class="literal">ddl</code> means that errors as well as DDLs (<code class="literal">CREATE TABLE</code>, <code class="literal">ALTER TABLE</code>, and so on) will be logged. <code class="literal">mod</code> will already include data changes, and all will send every statement to the log.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip42"></a>Note</h3><p>Be aware, <code class="literal">all</code> can lead to a lot of logging information, which can slow down your system. To give you an impression of how much impact there can be, I have compiled a blog post. It can be found at <a class="ulink" href="http://www.cybertec.at/2014/03/logging-the-hidden-speedbrakes/" target="_blank">https://www.cybertec-postgresql.com/en/logging-the-hidden-speedbrakes/</a>.</p></div><p>If you want to inspect replication in more detail, consider turning the following setting on:</p><pre class="programlisting"><span class="strong"><strong>#log_replication_commands = off </strong></span></pre><p>It will send replication-related commands to the log. For more information, visit the following website: <a class="ulink" href="https://www.postgresql.org/docs/current/static/protocol-replication.html" target="_blank">https://www.postgresql.org/docs/current/static/protocol-replication.html</a>.</p><p>It can happen quite frequently that performance problems are caused by temporary file I/O. To see which queries cause problems, the following setting can be used:</p><pre class="programlisting"><span class="strong"><strong>#log_temp_files = -1    
# log temporary files  equal  or larger 
# than  the specified size  in kilobytes; 
# -1 disables, 0 logs  all temp  files</strong></span></pre><p>While <code class="literal">pg_stat_statements</code> contains aggregated information, <code class="literal">log_temp_files</code> will point to specific queries causing issues. It usually makes sense to set this one to a reasonably low value. The correct value depends on your workload, but maybe 4 MB is already a good start.</p><p>By default, PostgreSQL will write log files in the time zone where the server is located. However, if you are running a system that is spread all over the world, it can make sense to adjust the time zone in a way that you can go and compare log entries:</p><pre class="programlisting"><span class="strong"><strong>log_timezone = 'Europe/Vienna'</strong></span></pre><p>Keep in mind that on the SQL side, you will still see the time in your local time zone. However, if this variable is set, log entries will be in a different time zone.</p></div></div></div>