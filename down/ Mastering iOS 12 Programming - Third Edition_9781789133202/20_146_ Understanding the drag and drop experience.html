<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch20lvl1sec135"></a>Understanding the drag and drop experience</h2></div></div><hr /></div><p>The drag and drop experience on iOS is <span>quite</span><a id="id325333114" class="indexterm"></a> simple to use; pick up an item on the screen, drag it somewhere else, and let it go to make the dragged item appear in the new place. However, iOS didn't have this behavior until iOS 11. And even now, its full range of capabilities is only available on the iPad. Despite this limitation, the drag and drop experience is really powerful on both the iPhone and iPad.</p><p>Users can pick up an item from any app, and move it over to any other app that implements drag and drop, as they please. And dragging items is not even limited to just a single item, it's possible for users to pick up multiple items in a single drag session. The items that a user adds to their drag session don't have to be of the same type; this makes the drag and drop experience extremely flexible and fluid. Imagine selecting some text and a picture in Safari and dragging them over to a note you're making. Both the image and the text can be added to a note in just a single gesture.</p><p>Unfortunately, apps are not able to handle drag and drop out of the box; you'll need to do a little bit of work to support this feature. At the heart of the drag and drop experience are two protocols and two new interaction classes. Let's briefly go over the protocols and classes before going more in-depth and implementing drag and drop for your augmented reality art gallery.</p><p>The first requirement for a drag and drop <span>session</span><a id="id325607234" class="indexterm"></a> is a view that can start or receive a drag session. This ability is added to a view through either <code class="literal">UIDropInteraction</code> or <code class="literal">UIDragInteraction</code>. Both interactions are subclasses of the <code class="literal">UIInteraction</code> base class. <code class="literal">UIInteraction</code> manifests itself similarly to <code class="literal">UIGestureRecognizer</code> in the sense that you create an instance of it and attach it to a view. The following figure shows the relationship between a view and the drag and drop interactions:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/3ae52933-9591-4239-ba79-ff31a74f9e14.png" /></div><p>When adding either <code class="literal">UIDragInteraction</code> or <code class="literal">UIDropInteraction</code> to <code class="literal">UIView</code>, you must also set up a delegate for the interaction you're adding. When you add <code class="literal">UIDropInteraction</code>, you must set <code class="literal">UIDropInteractionDelegate</code> on it. When you add <code class="literal">UIDragInteraction</code>, you must assign <code class="literal">UIDragInteractionDelegate</code> for it. The following figure illustrates the relationship between the interactions and their delegates:</p><p> </p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/d348f542-6ec0-431e-ab2e-e6df031487bc.png" /></div><p>Each protocol is related to a different set of responsibilities, as is suggested by their names. Let's have a look at <code class="literal">UIDragInteractionDelegate</code> first.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch20lvl2sec106"></a>Understanding UIDragInteractionDelegate</h3></div></div></div><p>Any time the user long-presses an item that has <code class="literal">UIDragInteraction</code> associated with it, a new drag <span>session</span><a id="id325612676" class="indexterm"></a> is started. This drag session uses the interaction's <code class="literal">UIDragInteractionDelegate</code> to obtain the data for the item that is being dragged, a drag preview, and more.</p><p><code class="literal">UIDragInteractionDelegate</code> only has a single required method: <code class="literal">dragInteraction(_:itemsForBeginning:)</code>. If you implement this method, your app can start supplying data to other apps. The return type for <code class="literal">dragInteraction(_:itemsForBeginning:)</code> is <code class="literal">[UIDragItem]</code>. <code class="literal">UIDragItem</code> is a container for <code class="literal">NSItemProvider</code>. The drag item is also responsible for providing a preview of the dragged item while it's being dragged. Normally, the selected view will be used, but sometimes you might want to provide a custom view for the preview. If this is the case, you can provide your own preview through <code class="literal">UIDragItem</code>.</p><p>A straightforward example of <code class="literal">dragInteraction(_:itemsForBeginning:)</code> looks as follows:</p><pre class="programlisting">func dragInteraction(_ interaction: UIDragInteraction, itemsForBeginning session: UIDragSession) -&gt; [UIDragItem] {
  let text = "Hello, world"
  let provider = NSItemProvider(object: text as NSString)
  let item = UIDragItem(itemProvider: provider)
  return [item]
}</pre><p>As mentioned before, users can add multiple objects to an existing drag session by tapping on them. Whenever the user taps a draggable item while a session is in progress, <code class="literal">dragInteraction(_:itemsForAddingTo:withTouchAt:)</code> is called on <code class="literal">UIDragInteractionDelegate</code>.</p><p>If you return an empty array in this method, the tapped item will not be added to the drag session. But if you return one or more <code class="literal">UIDragItem</code> instances, those items will be appended to the existing drag session.</p><p>A drag <span>session</span><a id="id325618077" class="indexterm"></a> can be divided into three stages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>The</strong></span><span class="strong"><strong>lift stage</strong></span>: This is the stage where the first drag item is requested, and the view that is about to be dragged is animated, so the user sees that they have started a drag session.</li><li style="list-style-type: disc"><span class="strong"><strong>The</strong></span><span class="strong"><strong>dragging stage</strong></span>: The user is now moving the drag item around.</li><li style="list-style-type: disc"><span class="strong"><strong>The</strong></span><span class="strong"><strong>end stage</strong></span>: Either a drop has been performed, or the drag session got canceled. If a session is canceled, the dragged item is animated back to its starting position.</li></ul></div><p>You can monitor and respond to each of the stages through <code class="literal">UIDragInteractionDelegate</code>. To customize the lift animation, you could implement <code class="literal">dragInteraction(_:willAnimateLiftWith:session:)</code>, for instance. For a full overview of available drag customizations, you should take a look at the documentation for <code class="literal">UIDragInteractionDelegate</code>; there are a bunch of methods available for you to implement!</p><p>Now that you know how to set up your app for dragging, let's see how dropping works.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch20lvl2sec107"></a>Understanding UIDropInteractionDelegate</h3></div></div></div><p>Similar to how <code class="literal">UIDragInteractionDelegate</code> works, <code class="literal">UIDropInteractionDelegate</code> is used to respond to different stages in the drag and drop life cycle. Even though <code class="literal">UIDropInteractionDelegate</code> has no required methods, there are at least two methods that you should implement to <span>support</span><a id="id325580997" class="indexterm"></a> drag and drop. The first method is <code class="literal">dropInteraction(_:sessionDidUpdate:)</code>.</p><p>As soon as the user moves their finger on top of a drop target, the drop target is asked whether it can handle a drop with the contents from the current drop session. To do this, <code class="literal">dropInteraction(_:canHandle:)</code> is called on the drop target. Assuming the data can be handled, <code class="literal">dropInteraction(_:sessionDidUpdate:)</code> is called next. You must return an instance of <code class="literal">UIDropProposal</code> from this method. A drop proposal lets the session know what you'd like to happen if the drop is executed at some point. For instance, you can make a copy proposal or a move proposal. The UI surrounding the contents that are being dragged will update accordingly to let the user know what will happen if they perform the drop.</p><p> </p><p> </p><p>Now let's say your app can only handle objects of a particular type. You should implement <code class="literal">dropInteraction(_:canHandle:)</code>. You can use this method to inspect whether the drop session contains items that are relevant for your app to handle. An example of this looks as follows:</p><pre class="programlisting">func dropInteraction(_ interaction: UIDropInteraction, canHandle session: UIDropSession) -&gt; Bool {
  for item in session.items {
    if item.itemProvider.canLoadObject(ofClass: UIImage.self) {
      return true
    }
  }

  return false
}</pre><p>This example searches for at least one image in the current drop session. You can use <code class="literal">canLoadObject(ofClass:)</code> on <code class="literal">NSItemProvider</code> to figure out whether the item provider contains an instance of a particular class, in this case, <code class="literal">UIImage</code>. If your app restricts drag and drop to the same application, you might not need to implement this method because you know exactly what items in your app are draggable. It is recommended that you always make sure the session can be handled by the drop target.</p><p>The second method you should <span>always</span><a id="id325581049" class="indexterm"></a> implement is <code class="literal">dropInteraction(_:performDrop:)</code>. If you don't implement this method, your app doesn't have a proper implementation of the drop interaction. Once the user drops an item onto a drop target, they expect something to happen. <code class="literal">dropInteraction(_:performDrop:)</code> is the perfect place to do so.</p><p>An example implementation of <code class="literal">dropInteraction(_:performDrop:)</code> could look as follows:</p><pre class="programlisting">func dropInteraction(_ interaction: UIDropInteraction, performDrop session: UIDropSession) {
  for item in session.items {
    if item.itemProvider.canLoadObject(ofClass: UIImage.self) {
      item.itemProvider.loadObject(ofClass: UIImage.self) { [weak self] item, error in
        // handle the item
      }
    }
  }
}</pre><p>The preceding code loops through all items in the drop session. If an item can provide an image, the image is loaded. Note that <code class="literal">loadObject(ofClass:)</code> uses a callback. This means that the data is loaded asynchronously. The dropped data could be huge and, if it were loaded and processed on the main thread by default, it would make your app freeze for a while. Because Apple made <code class="literal">loadObject(ofClass:)</code> asynchronous, your app's responsiveness is guaranteed, and your users won't notice any freezes or lag.</p><p>Just like a drag session, a drop session typically has three stages:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The session starts when a user drags content onto a drop target.</li><li style="list-style-type: disc">Performing the drop; this is when the user lifts their finger while it's on a drop target.</li><li style="list-style-type: disc">Ending the drop; the user has either dragged their finger away from the drop target, or the drop has been performed successfully.</li></ul></div><p>Apple has not defined the stages of the <span>drag</span><a id="id325581094" class="indexterm"></a> and drop experience as you have just learned them. Dividing the experience into the preceding steps is merely intended to help you to grasp the life cycle of drag and drop. If you want to learn everything about the drag and drop life cycle, make sure to check out the documentation for both <code class="literal">UIDropInteractionDelegate</code> and <code class="literal">UIDragInteractionDelegate</code>.</p><p>Alright, now that you know what drag and drop looks like in theory, let's see what it looks like in practice!</p></div></div>