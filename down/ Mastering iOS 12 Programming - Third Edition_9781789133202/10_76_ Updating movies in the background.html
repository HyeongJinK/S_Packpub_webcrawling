<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec75"></a>Updating movies in the background</h2></div></div><hr /></div><p>Almost all of the building blocks involved with <span>implementing</span><a id="id325333116" class="indexterm"></a> background fetch are in place. All you need now is a way to fetch movies from the movie database using their remote ID instead of using the movie database search API.</p><p>To enable this way of querying movies, another fetch method is required on <code class="literal">MovieDBHelper</code>. The simplest way to do this would be to copy and paste both the fetch and URL-building methods and adjust them to enable fetching movies by ID. While it might be the easiest way to go about this, it isn't the best idea. If you add another fetch method or require more flexibility later, you will be in trouble. It's much better to refactor the movie db helper so it's better suited to multiple types of requests.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec56"></a>Preparing the helper struct</h3></div></div></div><p>To maintain a clear overview of the available API endpoints, you can add a nested enum to <code class="literal">MovieDBHelper</code>. Doing this will make other parts of the code more readable, help to avoid errors, and abstract away code duplication. An associated value will be used on the enum to hold onto the ID of a movie. This is quite <span>convenient</span><a id="id325333140" class="indexterm"></a> because the movie ID is part of the API endpoint.</p><p>Add the following code inside of the <code class="literal">MovieDBHelper</code> struct:</p><pre class="programlisting">static let apiKey = "d9103bb7a17c9edde4471a317d298d7e"

enum Endpoint {
  case search
  case movieById(Int64)

  var urlString: String {
    let baseUrl = "https://api.themoviedb.org/3/"

    switch self {
    case .search:
      var urlString = "\(baseUrl)search/movie/"
      urlString = urlString.appending("?api_key=\(MovieDBHelper.apiKey)")
      return urlString
    case let .movieById(movieId):
      var urlString = "\(baseUrl)movie/\(movieId)"
      urlString = urlString.appending("?api_key=\(MovieDBHelper.apiKey)")
      return urlString
    }
  }
}</pre><p>Note that the <code class="literal">apiKey</code> constant has been changed from an instance property to a static property. Making it a static property makes it available to be used inside of the nested <code class="literal">Endpoint</code> enum. Note that the value associated with the <code class="literal">movieById</code> case is <code class="literal">Int64</code> instead of <code class="literal">Int</code>. This is required because the movie ID is a 64-bit integer type in Core Data.</p><p>With this new <code class="literal">Endpoint</code> enum in place, you can refactor the way you build the URLs as follows:</p><pre class="programlisting">private func url(forMovie movie: String) -&gt; URL? {
  guard let query = movie.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)
    else { return nil }

  var urlString = Endpoint.search.urlString
  urlString = urlString.appending("&amp;query=\(query)")

  return URL(string: urlString)
}

private func url(forMovieId id: Int64) -&gt; URL? {
  let urlString = Endpoint.movieById(id).urlString
  return URL(string: urlString)
} </pre><p>The <code class="literal">url(forMovie:)</code> method was updated to make use of the <code class="literal">Endpoint</code> enum. The <code class="literal">url(forMovieId:)</code> method is new and uses the <code class="literal">Endpoint</code> enum to obtain a movie-specific URL easily.</p><p>When you fetch data, there are some pieces of code that you will have to write regardless of the URL that will ultimately be used to fetch data. When you look at the <code class="literal">fetchRating(forMovie:)</code> method, there are a couple of things that apply to both endpoints you will eventually use to retrieve movie information. The following list is an overview of these things:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Checking whether we're working with a valid URL</li><li style="list-style-type: disc">Creating the data task</li><li style="list-style-type: disc">Extracting the JSON</li><li style="list-style-type: disc">Calling the callback</li></ul></div><p>If you think about it, the only real difference is the API response object that is used. When you examine the JSON responses returned by the search API and fetching a movie by ID, the difference is that the search API returns an array of movies where you're interested in the first result. The movie-by-id API returns the correct movie as part of the root object.</p><p>With this in mind, the refactored code should be able to retrieve the desired data using just a URL, a data-extraction strategy, and a callback. Based on this, you can write the following code:</p><pre class="programlisting">// 1
typealias IdAndRating = (id: Int?, rating: Double?)
typealias DataExtractionStrategy = (Data) -&gt; IdAndRating

// 2
private func fetchRating(fromUrl url: URL?, withExtractionStrategy extractionStrategy: @escaping DataExtractionStrategy, callback: @escaping MovieDBCallback) {
  guard let url = url else {
    callback(nil, nil)
    return
  }

  let task = URLSession.shared.dataTask(with: url) { data, response, error in
    var rating: Double? = nil
    var remoteId: Int? = nil

    defer {
      callback(remoteId, rating)
    }

    guard error == nil
      else { return }

    guard let data = data
      else { return }

    // 3  
    let extractedData = extractionStrategy(data)
    rating = extractedData.rating
    remoteId = extractedData.id
  }

  task.resume()
}</pre><p>There is quite a lot going on in the preceding snippet. Most of the code will look familiar, but some of the details might be new. Let's go over the comments in this code one by one:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>This part defines a couple of type aliases that will make the code a little bit more readable. The first alias is for a named tuple that contains the movie's ID and rating. The second alias defines the signature for the data extraction closure.</li><li>The second highlight is for <code class="literal">fetchRating(fromUrl:withExtractionStrategy:callback:)</code>. This method will be used to obtain movie data. It's marked private because it's not very useful to call this method directly. Instead, it will be called by two methods that will be implemented soon.</li><li>The data for the movie is extracted from the raw data by passing the raw data to the data extraction closure.</li></ol></div><p>Let's use this method to implement both the old way of fetching a movie through the search API and the new way that uses the movie ID to request the resource directly, as follows:</p><pre class="programlisting">func fetchRating(forMovie movie: String, callback: @escaping MovieDBCallback) {
  let searchUrl = url(forMovie: movie)
  let extractData: DataExtractionStrategy = { data in
    let decoder = JSONDecoder()

    guard let response = try? decoder.decode(MovieDBLookupResponse.self, from: data),
      let movie = response.results.first
      else { return (nil, nil) }

    return (movie.id, movie.popularity)
  }

  fetchRating(fromUrl: searchUrl, withExtractionStrategy: extractData, callback: callback)
}

func fetchRating(forMovieId id: Int64, callback: @escaping MovieDBCallback) {
  let movieUrl = url(forMovieId: id)
  let extractData: DataExtractionStrategy = { data in
    let decoder = JSONDecoder()

    guard let movie = try? decoder.decode(MovieDBLookupResponse.MovieDBMovie.self, from: data)
      else { return (nil, nil) }

    return (movie.id, movie.popularity)
  }

  fetchRating(fromUrl: movieUrl, withExtractionStrategy: extractData, callback: callback)
}</pre><p>The code duplication is minimal in these methods, which means that this attempt at refactoring the code was a huge success. If you add new ways to fetch movies, all you will need to do is obtain a URL, define how to retrieve the data you're looking for from the <code class="literal">data</code> object, and finally, kick off the fetching.</p><p>You're now finally able to fetch movies using their ID without duplicating a lot of code. The final step in implementing the background update feature is to implement the code that updates movies. Let's go!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec57"></a>Updating the movies</h3></div></div></div><p>The process of updating <span>movies</span><a id="id325607101" class="indexterm"></a> is a strange one. As you saw earlier, network requests are performed asynchronously, which means that you can't rely on the network request being finished by the time a function is finished executing. Because of this, a callback is used. The callback is then called when the network request is done.</p><p>But what happens if you need to wait for multiple requests? How do you know that all requests to update movies have been completed? Since the movie database doesn't allow developers to fetch multiple movies at once, a bunch of requests must be made. When all of these requests are complete, the background fetch <code class="literal">completionHandler</code> should be called with the result of the operation.</p><p>To achieve this, you can make use of the grand central dispatch. More specifically, you can use a dispatch group. A dispatch group keeps track of an arbitrary number of tasks, and it won't consider itself as completed until all of the tasks that are added to the group have finished executing.</p><p>This behavior is precisely what's needed to wait for all movies to be updated. Whenever we fetch a movie from the network, you can add a new task to the dispatch group that will be marked as completed once the underlying movie is updated. Finally, when all of the movies are updated, <code class="literal">completionHandler</code> can be called to inform iOS about the result of the background fetch. Let's take a step-by-step look at how to achieve this behavior. Start by adding the following code to <code class="literal">AppDelegate</code>:</p><pre class="programlisting">func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {

  let fetchRequest: NSFetchRequest&lt;Movie&gt; = Movie.fetchRequest()
  let managedObjectContext = persistentContainer.viewContext
  guard let allMovies = try? managedObjectContext.fetch(fetchRequest) else {
    completionHandler(.failed)
    return
  }
}</pre><p>This first part of the background fetch is relatively straightforward. All it does is retrieve all movie objects from the database. If this fails, <code class="literal">completionHandler</code> is called with a <code class="literal">.failed</code> status.</p><p>All the following code snippets should be added to the <code class="literal">application(_:performFetchWithCompletionHandler:)</code> method inside of <code class="literal">AppDelegate</code> in the same order as they are presented. A full overview of the implementation will be provided at the end:</p><pre class="programlisting">let queue = DispatchQueue(label: "movieDBQueue")   
let group = DispatchGroup()   
let helper = MovieDBHelper()   
var dataChanged = false </pre><p>These lines create a dispatch <span>queue</span><a id="id325609916" class="indexterm"></a> and a dispatch group. The dispatch queue represents the background thread on which the fetch operations will be executed. Next, add the following snippet:</p><pre class="programlisting">for movie in allMovies {
  queue.async(group: group) {
    group.enter()
    helper.fetchRating(forMovieId: movie.remoteId) { id, popularity in
      guard let popularity = popularity,
        popularity != movie.popularity else {
          group.leave()
          return
      }

      dataChanged = true

      managedObjectContext.persist {
        movie.popularity = popularity
        group.leave()
      }
    }
  }
}</pre><p>This part of the implementation loops through the fetched movies. For every movie, a task is added to the dispatch queue and <code class="literal">group.enter()</code> is called to tell the dispatch group that a new task has just been added. The next step is to fetch the rating. If this fails, <code class="literal">group.leave()</code> is called to tell the dispatch group that this task has finished. If the data was retrieved successfully, the movie is updated with the fetched rating. Once the managed object has persisted the changes, <code class="literal">group.leave()</code> is called, and the operation has finished.</p><p>The next and final snippet that must be added executes when all the tasks in the queue are performed; at this point, the code should check whether new data has been fetched by reading the <code class="literal">dataChanged</code> property, and based on this property, call <code class="literal">callbackHandler</code>:</p><pre class="programlisting">group.notify(queue: DispatchQueue.main) {
  if dataChanged {
    completionHandler(.newData)
  } else {
    completionHandler(.noData)
  }
} </pre><p>The <code class="literal">group.notify</code> method takes a queue and a block of code that it should execute. The queue is set to the main queue, which means that the code inside of the block is performed on the main queue. Then, the <code class="literal">dataChanged</code> variable is read, and <code class="literal">completionHandler</code> is called accordingly.</p><p>As promised, the full implementation for <code class="literal">application(_:performFetchWithCompletionHandler:)</code> is as follows:</p><pre class="programlisting">func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {

  let fetchRequest: NSFetchRequest&lt;Movie&gt; = Movie.fetchRequest()
  let managedObjectContext = persistentContainer.viewContext
  guard let allMovies = try? managedObjectContext.fetch(fetchRequest) else {
    completionHandler(.failed)
    return
  }

  let queue = DispatchQueue(label: "movieDBQueue")
  let group = DispatchGroup()
  let helper = MovieDBHelper()
  var dataChanged = false

  for movie in allMovies {
    queue.async(group: group) {
      group.enter()
      helper.fetchRating(forMovieId: movie.remoteId) { id, popularity in
        guard let popularity = popularity,
          popularity != movie.popularity else {
            group.leave()
            return
        }

        dataChanged = true

        managedObjectContext.persist {
          movie.popularity = popularity
          group.leave()
        }
      }
    }
  }

  group.notify(queue: DispatchQueue.main) {
    if dataChanged {
      completionHandler(.newData)
    } else {
      completionHandler(.noData)
    }
  }
}</pre><p>To test whether background fetching is working as expected, you can build and run your app. Then, add a new movie, so you have a movie for which the ID is stored. Finally, you can use the debug menu item in Xcode that's at the top of your screen to simulate a background refresh. This will trigger a background refresh.</p></div></div>