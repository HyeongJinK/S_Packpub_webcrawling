<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec68"></a>Wrapping the feature up</h2></div></div><hr /></div><p>All of the code is in place, and you have a better understanding of multithreading and how callbacks can be used in a multithreaded environment. Yet, if you build and run your app and add a new movie, the rating won't be displayed yet.</p><p>The following are the three reasons why this is <span>happening</span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The table view cell that shows the movie isn't updated yet.</li><li style="list-style-type: disc">The network request doesn't succeed because of App Transport Security.</li><li style="list-style-type: disc">Updates to movie objects aren't observed yet.</li></ul></div><p>Let's solve these issues in order, starting with the table view cell.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec47"></a>Adding the rating to the movie cell</h3></div></div></div><p>Currently, the <span>movie</span><a id="id325333136" class="indexterm"></a> table view displays cells that have a title. <code class="literal">UITableViewCell</code> has a built-in option to display a title and a subtitle for a cell. Open <code class="literal">Main.storyboard</code> and select the prototype cell for the movies. In the <code class="literal">Attributes Inspector</code> field, change the cell's style from basic to subtitle. This will allow you to use <code class="literal">detailTextLabel</code> on the table view cell. This is where we'll display the movie rating.</p><p>In <code class="literal">MoviesViewController</code>, add the following line to <code class="literal">tableView(_:cellForRow:atIndexPath:)</code>, right after you set the cell's title:</p><pre class="programlisting">cell.detailTextLabel?.text = "Rating: \(movie.popularity)" </pre><p>This line will put the movie's popularity rating in a string and assign it as a text for the detail text label.</p><p>If you build and run your app now, all movies should have a popularity of 0.0. Let's fix this by resolving the networking issue.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec48"></a>Understanding App Transport Security</h3></div></div></div><p>With iOS 9, Apple introduced <span class="strong"><strong>App Transport Security</strong></span> (<span class="strong"><strong>ATS</strong></span>). ATS makes <span>applications</span><a id="id325357398" class="indexterm"></a> safer and more secure by prohibiting the use of non-HTTPS resources. This is a great security feature, as it protects your users from a wide range of attacks that can be executed on regular HTTP connections.</p><p>If you paid close attention to the URL that's used to fetch movies, you may have noticed that the URL should be an HTTPS resource, so it should be fine to load this URL. However, the network requests are still blocked by ATS. Why is this?</p><p>Well, Apple has strict requirements. At the time of writing this book, the movie database uses the SHA-1 signing of certificates, whereas Apple requires SHA-2. Because of this, you will need to circumvent ATS for now. Your users should be safe regardless, since the movie database supports HTTPS, just not the version Apple considers to be secure enough.</p><p>To do this, open the <code class="literal">Info.plist</code> file and add a new dictionary key named <strong class="userinput"><code>App Transport</code></strong><strong class="userinput"><code>Security Settings</code></strong>. In this dictionary, you will need an <strong class="userinput"><code>Exception Domains</code></strong> dictionary. Add a new dictionary key named <strong class="userinput"><code>themoviedb.orgr</code></strong> to this dictionary and add two Booleans to this dictionary. Both should have <strong class="userinput"><code>YES</code></strong> as their values, and they should be named <strong class="userinput"><code>NSIncludesSubdomains</code></strong> and <span class="strong"><strong><strong class="userinput"><code>NSTemporaryExceptionAllowsInsecureHTTPLoads</code></strong></strong></span>. Refer to the <span>following</span><a id="id325357751" class="indexterm"></a> screenshot to make sure that you've set this up correctly:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/4191d89f-0da3-4963-ab54-99a7ed26e8f3.png" /></div><p>If you add a new movie to a family member now, nothing updates yet. However, if you go back to the family overview and then back to the family member, you'll see that the rating for the most recent movie is updated. Great! Now, all you need to do is make sure that we observe the managed object context for updates to the movies so they are reloaded if their rating changes.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec49"></a>Observing changes to movie ratings</h3></div></div></div><p>You're already observing the <span>managed</span><a id="id325369910" class="indexterm"></a> object context for changes, but they are only processed if the family member that is shown on the current page has updated. This logic should be replaced so that it will reload the table view if either the family member or their favorite movies change. Update the <code class="literal">managedObjectContextDidChange(_:)</code> method in <code class="literal">MoviesViewController.swift</code> as follows:</p><pre class="programlisting">@objc func managedObjectContextDidChange(notification: NSNotification) {
  guard let userInfo = notification.userInfo
    else { return }

  if let updatedObjects = userInfo[NSUpdatedObjectsKey] as? Set&lt;FamilyMember&gt;,
    let familyMember = self.familyMember,
    updatedObjects.contains(familyMember) {

    tableView.reloadData()
  }

  if let updatedObjects = userInfo[NSUpdatedObjectsKey] as? Set&lt;Movie&gt; {
    for object in updatedObjects {
      if object.familyMember == familyMember {
        tableView.reloadData()
        break
      }
    }
  }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note32"></a>Note</h3><p>The logic for observing the family member hasn't changed; its conditions simply moved from the guard statement to an <code class="literal">if</code> statement. An extra <code class="literal">if</code> statement was added for the movies. If the updated object set is a list of movies, we loop through the movies and check whether one of the movies has the current family member as its family member. If so, the table is refreshed immediately and the loop is exited.</p></div><p>It's important that the loop in the second <code class="literal">if</code> statement is set up like this because you might have just added a movie for family member A and then switched to family member B while the new movie for family member A is still loading its rating. Also, breaking out of the loop early ensures that you don't loop over any more objects than needed. All you want to do is refresh the table view if one of the current family members' favorite movies is updated.</p><p>Okay, build and run your app to take it for a spin! You'll notice that everything works as you'd want it to right now. Adding new movies triggers a network request; as soon as it finishes, the UI is updated with the new rating. Sometimes, this update will be done in an instant, but it could take a short while if you have a slow internet connection. Great! That's it for this feature.</p><p> </p></div></div>