<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch23lvl1sec156"></a>Testing the user interface with XCUITest</h2></div></div><hr /></div><p>Knowing that most of your app logic is <span>covered</span><a id="id325333110" class="indexterm"></a> with tests is great. What's not so great, however, is adding <span>your</span><a id="id325333841" class="indexterm"></a> view controllers to your logic test. Luckily, you can use <code class="literal">XCUITest</code> to easily record and write tests that focus on the user interface of an app. <code class="literal">XCUITest</code> uses the accessibility features in iOS to gain access to the user interface of your app. This means that implementing user interface tests forces you to put at least a little bit of effort into accessibility for your applications. The better your app's accessibility is, the easier it will be to write UI Tests for.</p><p><code class="literal">XCUITest</code> has two great features that we'll look at in greater detail. First of all, UI Tests help you to enhance accessibility for your apps. Secondly, it's easy to get started with UI testing because Xcode can record your tests while you navigate through your app. This can significantly benefit the amount of code that is covered by your test suite since Code Coverage also takes UI Tests into account.</p><p>Before we start recording our first UI test, let's have a quick look at accessibility.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch23lvl2sec125"></a>Making your app accessible to your tests</h3></div></div></div><p>One of the lesser thoughts about features in iOS is accessibility. The design <span>teams</span><a id="id325333873" class="indexterm"></a> at Apple work hard to ensure that iOS is accessible for everybody. This includes blind people and people with other disabilities that could somehow affect the user's ability to operate their iOS device.</p><p>Just looking at the accessibility settings in the iOS settings app makes it evident that this is a subject that Apple invests a lot of time in. If you're working on an app, Apple expects you to put in the same kind of effort. Doing this will be rewarded by more app downloads and if you're lucky, even a couple of great reviews. In their talk on iOS Accessibility from WWDC 2015, Apple even mentioned that implementing accessibility features can be helpful if you ever want to be featured in the <span class="emphasis"><em>App Store</em></span>. Only the best apps get featured by Apple, and if your app is accessible to all people, that significantly boosts your app's quality.</p><p>A common myth surrounding accessibility is that it's hard to implement or that it takes a lot of time. Some people even go so far as to say that it looks ugly or gets in the way of beautiful design. None of this is entirely correct. Sure, making your app accessible requires some effort, but the UIKit framework is very helpful when it comes to accessibility. Using standard components and keeping your user in mind while you design your app will make sure that your app is both accessible and looks good.</p><p>So, how does accessibility work on iOS? And how can we make sure our app is accessible? A fun way to experiment with this is to turn on <strong class="userinput"><code>VoiceOver</code></strong> on your device. To enable <strong class="userinput"><code><span class="strong"><strong>VoiceOver</strong></span></code></strong>, go to the <strong class="userinput"><code>Accessibility</code></strong> menu. You'll find several vision-related accessibility settings. <strong class="userinput"><code>VoiceOver</code></strong> should be the topmost one. To quickly enable and disable <span class="strong"><strong><strong class="userinput"><code>VoiceOver</code></strong></strong></span>, scroll all the way to the bottom of the settings page and select <span class="strong"><strong><strong class="userinput"><code>VoiceOver</code></strong></strong></span> as your accessibility shortcut:</p><p> </p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/cf70d9ed-6a90-46e7-b19a-c468b57dee64.png" /></div><p>This will allow you to toggle <strong class="userinput"><code>VoiceOver</code></strong> off and on by triple-clicking the home button or side button, depending on your device.</p><p>After enabling this, run the <strong class="userinput"><code>MovieTrivia</code></strong> app on your device and triple-click your home button or side button to enable <strong class="userinput"><code>VoiceOver</code></strong>. Swipe around and try to use the app. This is how a person with a visual handicap uses your app. You won't get past the loading screen because the dummy <span>questions</span><a id="id325611496" class="indexterm"></a> aren't loaded, but you should find the splash screen to be pretty accessible, especially considering no special work had to be done to achieve this. UIKit uses great default settings to make sure your app will be accessible by default.</p><p> </p><p>You can set your own accessibility information through the <strong class="userinput"><code>Identity Inspector</code></strong> in Interface Builder. You can add custom labels, hints, identifiers, and traits to your interface to aid accessibility and, coincidentally, your UI tests. The following screenshot shows the accessibility panel:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/43340973-eb3b-4d6f-b6c4-2e492ee1dbff.png" /></div><p>For most UIKit interface elements, you won't have to touch these settings yourself. UIKit will make sure that your objects have sensible defaults that automatically make your app accessible. Now that you have a little bit of background information about accessibility, let's have a look at testing the app's (accessible) UI.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch23lvl2sec126"></a>Recording UI tests</h3></div></div></div><p>Before you can record UI tests, you must add a UI <span>testing</span><a id="id325615283" class="indexterm"></a> target to the project. Follow the same steps as before to add a new testing target, but pick the iOS UI Testing Bundle this time around. If you look inside the newly-created group in your project, the structure for your UI tests looks very similar to the structure for Unit tests.</p><p>One significant difference between UI test targets and Unit test targets is that your UI tests do not have access to any code that's inside your app. A UI test can only test the interface of your app and make assertions based on that.</p><p>If you open the <code class="literal">MovieTriviaUITest.swift</code> file, you'll notice the <code class="literal">setUp()</code> and <code class="literal">tearDown()</code> methods. Also, all of the tests that must be executed are methods with the test prefix. This is all similar to what you've already seen for <code class="literal">XCUITest</code>.</p><p>One big difference is that the app is launched explicitly in the setup stage. This is because the UI test target is essentially just a different app that can interact with your main app's interface. This limitation is very interesting, and it's also the reason why it's important to make your app accessible.</p><p>To start recording a UI test in Xcode, you must start a recording session. If you're editing code in a UI test target, a new interface element is visible in the bottom-left corner of your code editor area:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/5c60fcfd-0f79-4b26-8e2b-33d7b993a8c8.png" /></div><p>Place your typing cursor inside the <code class="literal">testExample()</code> method and click the red dot. Your app is launched and anything you do is recorded as a UI test and played back when you run your tests. If you tap on the label and the activity indicator on the loading screen, Xcode produces the following Swift code in the testing method:</p><pre class="programlisting">let app = XCUIApplication()
app.staticTexts["Loading trivia questions..."].tap()
app.otherElements.containing(.activityIndicator, identifier:"In progress").element.tap()</pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>The UI test you recorded is a set of instructions that are sent to the app. In this sample, the test looks for a certain element in the app's UI and calls <code class="literal">tap()</code> on it. This test doesn't do a lot, so it's not particularly useful. To make the test more useful, we should let the app know that it should run in a special test mode so it can load questions from the JSON file instead of trying to load it from the network. To do this, you can send launch arguments to the app. Launch arguments can be used by the app to enable or disable certain functionalities. You can think of them as variables that are sent to the app when it launches.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch23lvl2sec127"></a>Passing launch arguments to your app</h3></div></div></div><p>To switch the loading of questions from the network to a <span>local</span><a id="id325618114" class="indexterm"></a> file for testing, you can pass your app a launch argument. This launch argument is then read by the app to make sure it loads questions from the JSON file like you did before in the unit tests rather than attempting to load trivia questions from the server.</p><p>To prepare for the launch argument and loading the JSON file, make sure you add it to the test target, the app target, and the UI test target. You won't need it in the UI test target just yet, but you will later, so you might as well add it to the UI test target while you're at it.</p><p>In order to pass launch arguments to the app, the <code class="literal">setUp()</code> method in the UI Test class should be modified:</p><pre class="programlisting">override func setUp() {
  super.setUp()

  continueAfterFailure = false

  let app = XCUIApplication()
  app.launchArguments.append("isUITesting")
  app.launch()
}</pre><p>The <code class="literal">XCUIApplication</code> instance that represents the app has a <code class="literal">launchArguments</code> property, which is an array of strings. You can add strings to this array before launching the app. These strings can then be <span>extracting</span> inside of the app. Modify the <code class="literal">loadTriviaQuestions(callback:)</code> method in <code class="literal">TriviaAPI.swift</code> as shown in the following code snippet:</p><pre class="programlisting">func loadTriviaQuestions(callback: @escaping QuestionsFetchedCallback) {
  if ProcessInfo.processInfo.arguments.contains("isUITesting") {
    loadQuestionsFromFile(callback: callback)
    return
  }

  // existing implementation...
}</pre><p>The preceding code should be inserted above the existing implementation of this method. The snippet checks whether we're UI testing by reading the app's launch arguments. If the UI testing argument is present, we call the <code class="literal">loadQuestionsFromFile(callback:)</code> method to load the questions from the JSON file instead of loading it from the network.</p><p>Note that it's not ideal to perform checks such as the preceding one in your production code. It's often better to wrap configuration such as this in a struct that can be modified easily. You can then use this struct throughout your app instead of directly accessing process info throughout your app. An example of such a configuration could look like this:</p><pre class="programlisting">struct AppConfig {
  var isUITesting: Bool {
    ProcessInfo.processInfo.arguments.contains("isUITesting")
  }
}</pre><p>We won't use this configuration class in this app since it's not needed for an app this small. But for your own apps, you might want to implement a configuration object regardless of app size since it leads to more maintainable code in the long run.</p><p>If you build the app right now, you should get a compiler error because <code class="literal">loadQuestionsFromFile(callback:)</code> is not implemented in the API class yet. Add the following implementation for this method:</p><pre class="programlisting">func loadQuestionsFromFile(callback: @escaping QuestionsFetchedCallback) {
  guard let filename = Bundle.main.path(forResource: "TriviaQuestions", ofType: "json"),
    let triviaString = try? String(contentsOfFile: filename),
    let triviaData = triviaString.data(using: .utf8)
    else { return }

  callback(triviaData)
}</pre><p>It's very similar to the question-loading method in the unit tests; the only difference is that it uses a different way to obtain the bundle from which the questions are loaded.</p><p>If you run your UI tests now, they will fail. The reason for this is that when the test framework starts looking for the elements it tapped before, they don't exist. This results in a test failure because the test can't tap elements that don't exist.</p><p>The test should be adjusted a bit because tapping a loader isn't very useful anyway. It's a lot more useful to make sure that buttons can be tapped and whether the UI updates accordingly. To do this, you can write a UI test that waits for the question and buttons to appear, taps them, and checks whether the UI has updated accordingly. The dummy data will be loaded in this test as well to verify that the correct question is shown and the buttons behave as they should.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch23lvl2sec128"></a>Making sure the UI updates as expected</h3></div></div></div><p>You're going to write two tests to <span>make</span><a id="id326176917" class="indexterm"></a> sure that the trivia game works as expected. The first test will test that the question and answer buttons appear and that they have the correct labels. The second test will make sure that the answers can be tapped and that the UI updates accordingly.</p><p>Instead of recording the tests, you'll write them manually. Writing tests manually gives you a bit more control and allows you to do much more than just tapping on elements. Before you do this, you should open the <code class="literal">Main.storyboard</code> file and give accessibility identifiers to the UI elements. Select the question title and give <code class="literal">UILabel</code> an identifier of <code class="literal">QuestionTitle</code>. Select each of the answers and give them the <code class="literal">AnswerA</code>, <code class="literal">AnswerB</code>, and <code class="literal">AnswerC</code> identifiers, respectively. Also, give the next button an accessibility identifier of <code class="literal">NextQuestion</code>. The following screenshot shows what the question title should look like:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/fb72090a-d776-419b-90a0-ab5684fe8a9d.png" /></div><p>Remove the existing UI test, called <code class="literal">testExample()</code>, from the <code class="literal">MovieTriviaUITests</code> class and add the one shown in the following code snippet:</p><pre class="programlisting">func testQuestionAppears() {
  let app = XCUIApplication()

  // 1
  let buttonIdentifiers = ["AnswerA", "AnswerB", "AnswerC"]
  for identifier in buttonIdentifiers {
    let button = app.buttons.matching(identifier: identifier).element

    // 2
    let predicate = NSPredicate(format: "exists == true")
    _ = expectation(for: predicate, evaluatedWith: button, handler: nil)
  }

  let questionTitle = app.staticTexts.matching(identifier: "QuestionTitle").element
  let predicate = NSPredicate(format: "exists == true")
  _ = expectation(for: predicate, evaluatedWith: questionTitle, handler: nil)

  // 3
  waitForExpectations(timeout: 5, handler: nil)
}</pre><p>Each element is selected through its accessibility identifier. You can do this because the <code class="literal">XCUIApplication</code> instance we create provides easy access to the UI elements. Next, a predicate is created that is used to check whether each element exists and an expectation is created. This expectation will continuously evaluate whether the predicate is true and once it is, the predicate will be fulfilled automatically. Lastly, the UI test will wait for all expectations to be fulfilled.</p><p>To make sure the questions are loaded correctly, you should load the JSON file as you did before. Add the following property to the test so you have a place to store the trivia questions:</p><pre class="programlisting">typealias JSON = [String: Any]
var questions: [JSON]?</pre><p>Next, add the following code to the <code class="literal">setUp()</code> method right after calling <code class="literal">super.setUp()</code> and before launching the app:</p><pre class="programlisting">guard let filename = Bundle(for: MovieTriviaUITests.self).path(forResource: "TriviaQuestions", ofType: "json"),
  let triviaString = try? String(contentsOfFile: filename),
  let triviaData = triviaString.data(using: .utf8),
  let jsonObject = try? JSONSerialization.jsonObject(with: triviaData, options: []),
  let triviaJSON = jsonObject as? JSON,
  let jsonQuestions = triviaJSON["questions"] as? [JSON]
  else { return }</pre><p>This code should look familiar to you because it's similar to the code you already used to load JSON. To make sure that the correct question is displayed, update the test method as shown here:</p><pre class="programlisting">func testQuestionAppears() {
  // existing implementation...

  waitForExpectations(timeout: 5, handler: nil)

  guard let question = questions?.first
    else { fatalError("Can't continue testing without question data...") }

  validateQuestionIsDisplayed(question)
}</pre><p>The preceding code calls <code class="literal">validateQuestionIsDisplayed(_:)</code>, but this method is not implemented yet. Add the following implementation:</p><pre class="programlisting">func validateQuestionIsDisplayed(_ question: JSON) {
  let app = XCUIApplication()
  let questionTitle = app.staticTexts.matching(identifier: "QuestionTitle").element

  guard let title = question["title"] as? String,
    let answerA = question["answer_a"] as? String,
    let answerB = question["answer_b"] as? String,
    let answerC = question["answer_c"] as? String
    else { fatalError("Can't continue testing without question data...") }

  XCTAssert(questionTitle.label == title, "Expected question title to match json data")

  let buttonA = app.buttons.matching(identifier: "AnswerA").element
  XCTAssert(buttonA.label == answerA, "Expected AnswerA title to match json data")

  let buttonB = app.buttons.matching(identifier: "AnswerB").element
  XCTAssert(buttonB.label == answerB, "Expected AnswerB title to match json data")

  let buttonC = app.buttons.matching(identifier: "AnswerC").element
  XCTAssert(buttonC.label == answerC, "Expected AnswerC title to match json data")
}</pre><p>This code is run after checking that the UI elements exist because it's run after waiting for the expectations we created. The first question is extracted from the JSON data, and all of the relevant labels are then compared to the question data using a reusable method that validates whether a specific question is currently shown.</p><p>The second test you should add is intended to check whether the game UI responds as expected. After loading a question, the test will tap on the wrong <span>answers</span><a id="id326177018" class="indexterm"></a> and then makes sure the UI doesn't show the button to go to the next question. Then, the correct answer will be selected, and the test will attempt to navigate to the next question. And of course, the test will then validate that the next question is shown:</p><pre class="programlisting">func testAnswerValidation() {
  let app = XCUIApplication()

  let button = app.buttons.matching(identifier: "AnswerA").element
  let predicate = NSPredicate(format: "exists == true")
  _ = expectation(for: predicate, evaluatedWith: button, handler: nil)
  waitForExpectations(timeout: 5, handler: nil)

  let nextQuestionButton = app.buttons.matching(identifier: "NextQuestion").element

  guard let question = questions?.first,
    let correctAnswer = question["correct_answer"] as? Int
    else { fatalError("Can't continue testing without question data...") }

  let buttonIdentifiers = ["AnswerA", "AnswerB", "AnswerC"]
  for (i, identifier) in buttonIdentifiers.enumerated() {
    guard i != correctAnswer
      else { continue }

    app.buttons.matching(identifier: identifier).element.tap()

    XCTAssert(nextQuestionButton.exists == false, "Next question button should be hidden")
  }

  app.buttons.matching(identifier: buttonIdentifiers[correctAnswer]).element.tap()
  XCTAssert(nextQuestionButton.exists == true, "Next question button should be visible")

  nextQuestionButton.tap()

  guard let nextQuestion = questions?[1]
    else { fatalError("Can't continue testing without question data...") }

  validateQuestionIsDisplayed(nextQuestion)
  XCTAssert(nextQuestionButton.exists == false, "Next question button should be hidden")
}</pre><p>The preceding code shows the entire test that validates that the UI responds appropriately to correct and incorrect answers. Tests such as these are quite verbose, but they save you a lot of manual testing.</p><p>When you test your UI like this, you can rest assured that your app will at least be somewhat accessible. The beauty in this is that both UI testing and accessibility can significantly improve your app quality and each actively aids the other.</p><p>Testing your UI is mostly a matter of looking for elements in the UI, checking their state or availability, and making assertions based on that. In the two tests you written for <span class="strong"><strong>MovieTrivia</strong></span>, we've combined expectations and assertions to test both existing UI elements and elements that might not be on screen yet. Note that your UI tests will always attempt to wait for any animations to complete before the next command is executed. This will make sure that you don't have to write asyncronous expectations for any new UI that is added to the screen with an animation.</p></div></div>