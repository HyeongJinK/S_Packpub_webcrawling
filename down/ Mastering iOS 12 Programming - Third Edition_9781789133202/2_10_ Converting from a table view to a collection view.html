<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec17"></a>Converting from a table view to a collection view</h2></div></div><hr /></div><p>Showing a user's <span>contacts</span><a id="id325337188" class="indexterm"></a> in the form of a list is a fine idea. It's functional, looks all right, and <span>people</span><a id="id325337196" class="indexterm"></a> are used to seeing data displayed in the form of a list. However, wouldn't it be nice if there was a more interesting way to display the same contact data? For instance, using bigger images for the contact photos. And instead of showing everything in a list, maybe a grid is a nice alternative.</p><p>Exciting and compelling layouts drive user engagement. Users enjoy interacting with well-designed apps, and they certainly notice when you put in a bit of extra effort. Of course, merely implementing a grid layout won't automatically make your app great but when used well, users can certainly feel more at home with your app than they would if you just stick to a table view. Every app benefits from a different kind of design and layout, so collection views are no magical solution for all apps, but they indeed are a powerful tool to master.</p><p>To show contacts in a grid layout, some of the existing code has to be cleaned up. All code and designs related to the table view must be removed. That's what you should do first. When you've cleaned up the project, you're left with a great starting point to begin implementing a collection view. The conversion process has three steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Delete all table view code.</li><li>Delete the table view from the storyboard and replace it with a collection view.</li><li>Add code for the collection view.</li></ol></div><p>Let's start off by deleting all the code in <code class="literal">ViewController.swift</code> that is related to your old table view implementation. This includes removing all extensions for conformance to <code class="literal">UITableView</code> related protocols. After doing so, you should be left with the following implementation of <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">import UIKit
import Contacts

class ViewController: UIViewController {
  var contacts = [Contact]()

  override func viewDidLoad() {
    super.viewDidLoad()

    let store = CNContactStore()
    let authorizationStatus = CNContactStore.authorizationStatus(for: .contacts)

    if authorizationStatus == .notDetermined {
      store.requestAccess(for: .contacts) { [weak self] didAuthorize, error in
        if didAuthorize {
          self?.retrieveContacts(from: store)
        }
      }
    } else if authorizationStatus == .authorized  {
      retrieveContacts(from: store)
    }
  }

  func retrieveContacts(from store: CNContactStore) {
    let containerId = store.defaultContainerIdentifier()
    let predicate = CNContact.predicateForContactsInContainer(withIdentifier: containerId)
    let keysToFetch = [CNContactGivenNameKey as CNKeyDescriptor,
                       CNContactFamilyNameKey as CNKeyDescriptor,
                       CNContactImageDataAvailableKey as 
                       CNKeyDescriptor,
                       CNContactImageDataKey as CNKeyDescriptor]

    contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)
      .map { Contact(contact: $0) }
  }
}</pre><p>You might be <span>tempted</span><a id="id325337428" class="indexterm"></a> also to remove the custom table view cell that you created in the previous chapter. You don't have to remove that for now since you can reuse the code for the <span>collection</span><a id="id325337301" class="indexterm"></a> view cell you will create later.</p><p>Now that the code is cleaned up, the user interface should also be cleaned up. Open <code class="literal">Main.storyboard</code> and delete the table view. You should now be left with an empty view controller that has no child views. Drag <code class="literal">UICollectionView</code> from the <strong class="userinput"><code>Object Library</code></strong> over to the view controller's view. Make sure this collection view covers the entire view, including the navigation bar that is visible at the top of the view. Next, use <strong class="userinput"><code>Reset to Suggested Constraints</code></strong> in the <strong class="userinput"><code>Resolve Auto Layout Issues</code></strong> menu to add the proper layout constraints for the collection view, just like you did before with the table view in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>UITableView Touch-Up</em></span>. This will pin the collection view to the top, right, bottom, and left edges of the view controller's view.</p><p> </p><p>With the collection view added to the user interface, the time has come to connect the interface and the code again. Add the following <code class="literal">@IBOutlet</code> to <code class="literal">ViewController.swift</code> so you can connect the outlet and the interface using <strong class="userinput"><code>Interface Builder</code></strong>:</p><pre class="programlisting">@IBOutlet var collectionView: UICollectionView!</pre><p>Back in the storyboard file, connect the new <code class="literal">@IBOutlet</code> to the collection view by selecting the view controller, opening the <strong class="userinput"><code><span class="strong"><strong>Connections Inspector</strong></span></code></strong>, and dragging a referencing outlet from the <strong class="userinput"><code>collectionView</code></strong> property to the collection view you just added.</p><p>You have now successfully removed the old table view implementation, and you have swapped it out for a collection view. Of course, there is more work to be done to conclude the conversion, such as creating the custom collection view cell that will hold all of the contact information.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec10"></a>Creating and implementing a custom collection view cell</h3></div></div></div><p>When you implemented the table view cell in the previous chapter, you designed a custom cell. This cell was a special kind of view that the table view reused for every contact that was visible on the screen. A collection view uses cells in a very similar way, but you can't use table view cells in a <span>collection</span><a id="id325336801" class="indexterm"></a> view and vice versa. However, both cells share a lot of functionality. For instance, they both have a <code class="literal">prepareForReuse</code> and an <code class="literal">awakeFromNib</code> method. This is why you haven't removed any code for the table view cell earlier; you can <span>reuse</span><a id="id325336816" class="indexterm"></a> the implementation code.</p><p>When you dragged the collection view onto the storyboard, it came with a default cell. This cell is a lot more flexible than a table view cell. For instance, try resizing it in your storyboard. Doing this is not possible with a table view cell, but a collection view cell will happily resize itself for you.</p><p>If you look at the <strong class="userinput"><code>Document Outline</code></strong> on the left-hand side of the window, you can see an object called <strong class="userinput"><code><span class="strong"><strong>Collection View Flow Layout</strong></span></code></strong>. This object is responsible for the collection view's layout, and you will learn a lot more about it later in the chapter when you implement your custom layout object. For now, click it so it is selected and look at the <strong class="userinput"><code><span class="strong"><strong>Size Inspector</strong></span></code></strong> on the right-hand side of the window. Set the item height property on the layout object to 90 and set the width to 110. The cell in the storyboard should automatically resize accordingly.</p><p>Now that the cell size is configured, drag an image and a label into the cell. Try to position your views as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/e0a25576-054c-4d63-a070-0d8f5f5db77e.png" /></div><p>When you have manually placed these two views, you should add <span>Auto Layout</span> constraints to make sure they are nicely positioned at all times. Use the technique you have used before to make Xcode add the constraints for you. You'll notice that Xcode didn't do a great job this time around. Instead of centering the image and the label in the cell, they are offset from the left edge of the cell. This might be fine if you don't intend on ever changing the cell size but otherwise you'll want to improve the added constraints manually. Undo this step by using <span class="emphasis"><em>Cmd</em></span> +<span class="emphasis"><em> Z</em></span> or by selecting <strong class="userinput"><code><span class="strong"><strong>Edit</strong></span></code></strong> | <strong class="userinput"><code><span class="strong"><strong>Undo</strong></span></code></strong> from the menu.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note7"></a>Note</h3><p>When adding constraints, it's important that every view can figure out its position on the screen and its size. Views always use constraints for the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values. For a view's size, either constraints or the intrinsic content size of the view are used. The intrinsic content size can be calculated by a view depending in its context. <span>UILabel</span> does this to determine its size based on its text contents.</p></div><p>When you apply the rules from the <span>information</span><a id="id325336899" class="indexterm"></a> block when adding <span>constraints</span><a id="id325336907" class="indexterm"></a> to the image view in your custom cell, you should conclude that you want to add the following constraints:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Center the image horizontally in the cell (<span class="emphasis"><em>x</em></span> position).</li><li style="list-style-type: disc">Stick the image to the top of the cell (<span class="emphasis"><em>y</em></span> position).</li><li style="list-style-type: disc">Make the image 50 points wide and 50 points tall (width and height).</li></ul></div><p>For the label, you need the following constraints:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Center the label horizontally in the cell (<span class="emphasis"><em>x</em></span> position).</li><li style="list-style-type: disc">Stick the label to the bottom of the cell (<span class="emphasis"><em>y</em></span> position).</li></ul></div><p>There is no need to set up width and height constraints for the label because these values are calculated using the intrinsic content size.</p><p>To add the required constraints to your image view, select it in the storyboard and click the <strong class="userinput"><code><span class="strong"><strong>Align</strong></span></code></strong> button in the bottom-right corner of the window. This button opens a popup that allows you to manually set up and specify constraints that align the current view to other views. For your current task, you need the <span class="strong"><strong><strong class="userinput"><code>Horizontally in Container</code></strong></strong></span> constraint to center the image. The other constraints you need are added using the <strong class="userinput"><code><span class="strong"><strong>Pin</strong></span></code></strong> button. This button is positioned next to the <strong class="userinput"><code><span class="strong"><strong>Align</strong></span></code></strong> button. The dialog that opens when clicking the <strong class="userinput"><code><span class="strong"><strong>Pin</strong></span></code></strong> button allows you to pin the selected view to edges on its superview. You can also configure the dimensions for the selected view. Set the <span class="strong"><strong><strong class="userinput"><code>Width</code></strong></strong></span> and <strong class="userinput"><code><span class="strong"><strong>Height</strong></span></code></strong> to <code class="literal">50</code> so the image is squared. Also, click the red constraint marker that represents the top anchor and set it to <code class="literal">0</code>. This pins the top of the image to the top of your cell. Refer to the following screenshot to make sure you set everything up correctly:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/528c9468-0f4c-4c7a-8f77-7b246976eea0.png" /></div><p> </p><p>For the label, you should repeat the horizontal centering step. Next, pin the label to the bottom of the cell using the same technique as you used before. Don't set up <span>constraints</span><a id="id325337047" class="indexterm"></a> for the width and height because the label will use its intrinsic content size for this. Centering the label and positioning it at the bottom of the <span>cell</span><a id="id325337056" class="indexterm"></a> provides <span>Auto Layout</span> with enough information to render your cell's layout.</p><p>Since you have kept the code for your old table view cell around, you can now use this code and turn it into a collection view cell. The collection view cell displays the same data as the table view cell did before, and they have very similar methods available. For instance, <code class="literal">prepareForReuse()</code> is available on both cells. This means that all you need to do to switch from a collection view cell to a table view cell is change its superclass from <code class="literal">UITableViewCell</code> to a <code class="literal">UICollectionViewCell</code>. However, that would leave you with a collection view cell that is called <code class="literal">ContactTableViewCell</code>, so it's a good idea also to rename the class itself. Adjust your code as follows:</p><pre class="programlisting">class ContactCollectionViewCell: UICollectionViewCell</pre><p>You can now go ahead and use this class in <strong class="userinput"><code><span class="strong"><strong>Interface Builder</strong></span></code></strong> just like you did before. Before setting up all the <code class="literal">@IBOutlet</code> connections, take a moment and rename the file for <code class="literal">ContactCollectionViewCell</code>, so the filename matches the class name.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note8"></a>Note</h3><p>To rename a file, select it in the <strong class="userinput"><code><span class="strong"><strong>File Inspector</strong></span></code></strong> on the left-hand side and press <span class="emphasis"><em>Enter</em></span>. You can now rename the file and press <span class="emphasis"><em>Enter</em></span> again to complete the renaming action.</p></div><p>With the file renamed, switch back to the storyboard and assign <code class="literal">ContactCollectionViewCell</code> as the class for the collection view cell. You can now also hook up the image and label to their <code class="literal">@IBOutlet</code> counterparts using the <strong class="userinput"><code><span class="strong"><strong>Connections Inspector</strong></span>.</code></strong> Lastly, make sure to set a reuse identifier on your cell in the <strong class="userinput"><code><span class="strong"><strong>Attributes Inspector</strong></span></code></strong>.</p><p>Collection views use delegation to retrieve cells, just like table views do. Currently, your collection view does not have a data source set up yet so if you run your app, you won't see any cells yet. If you have followed along in the previous chapter, you should be able to figure out how to implement a collection view data source. Doing this on your own would be a great exercise in navigating Apple's documentation, but you would also train your ability to apply knowledge from other, related topics to new subjects.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>When you're done, refer to the following code snippet to ensure you implemented everything correctly:</p><pre class="programlisting">import UIKit
import Contacts

class ViewController: UIViewController {
  var contacts = [Contact]()

  @IBOutlet var collectionView: UICollectionView!

  override func viewDidLoad() {
    super.viewDidLoad()

    collectionView.dataSource = self

    let store = CNContactStore()
    let authorizationStatus = CNContactStore.authorizationStatus(for: .contacts)

    if authorizationStatus == .notDetermined {
      store.requestAccess(for: .contacts) { [weak self] didAuthorize, 
      error in
        if didAuthorize {
          self?.retrieveContacts(from: store)
        }
      }
    } else if authorizationStatus == .authorized  {
      retrieveContacts(from: store)
    }
  }

  func retrieveContacts(from store: CNContactStore) {
    let containerId = store.defaultContainerIdentifier()
    let predicate = CNContact.predicateForContactsInContainer(withIdentifier: containerId)
    let keysToFetch = [CNContactGivenNameKey as CNKeyDescriptor,
                       CNContactFamilyNameKey as CNKeyDescriptor,
                       CNContactImageDataAvailableKey as 
                       CNKeyDescriptor,
                       CNContactImageDataKey as CNKeyDescriptor]

    contacts = try! store.unifiedContacts(matching: predicate, 
    keysToFetch: keysToFetch)
      .map { Contact(contact: $0) }

    DispatchQueue.main.async { [weak self] in
      self?.collectionView.reloadData()
    }
  }
}

extension ViewController: UICollectionViewDataSource {
  func collectionView(_ collectionView: UICollectionView,
                      numberOfItemsInSection section: Int) -&gt; Int {
    return contacts.count
  }

  func collectionView(_ collectionView: UICollectionView,
                      cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {
    let cell = collectionView.dequeueReusableCell(withReuseIdentifier:
      "contactCell", for: indexPath) as! ContactCollectionViewCell
    let contact = contacts[indexPath.row]
    cell.nameLabel.text = "\(contact.givenName) \(contact.familyName)"
    contact.fetchImageIfNeeded { image in
      cell.contactImage.image = image
    }

    return cell 
  }
}</pre><p><a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>UITableView Touch-Up</em></span> covers the details regarding the preceding code. It implements data source methods for <span>cell</span><a id="id325337561" class="indexterm"></a> count and <span>cell</span><a id="id325337570" class="indexterm"></a> creation. It also fetches contacts and reloads the collection view, very similar to how the table view was reloaded.</p><p>If you run the app now, it doesn't look amazing. Images are a little distorted and using plain squares doesn't help the design either. You can fix this by configuring the image view in a slightly different way to prevent it from distorting the image and to make it scale it proportionally to cover the available space.</p><p>Open your <span>Storyboard</span> and select the image view in the cell. Look for the option called <span class="strong"><strong><strong class="userinput"><code>Content Mode</code></strong></strong></span> in the <strong class="userinput"><code><span class="strong"><strong>Identity Inspector</strong></span></code></strong>. This option describes how images should be rendered in the image view. The default value for this property is <strong class="userinput"><code>Scale to Fill</code></strong>. This setting scales and distorts the image to make it cover the viewport. A better option is <strong class="userinput"><code>Aspect Fill</code></strong>. This scales the image to cover the available space while maintaining the correct aspect ratio. Try playing with the other available options as well to see what happens.</p><p>Next, look for the <span class="strong"><strong><strong class="userinput"><code>Background</code></strong></strong></span> option for the image view. Set this property to a light gray color. That will function as a nice placeholder for the real image. The final step is to set rounded corners on the image view. This option isn't easily found in <strong class="userinput"><code><span class="strong"><strong>Interface Builder</strong></span></code></strong>, so you'll add it through code. Before you do this though, make sure that <strong class="userinput"><code><span class="strong"><strong>Clips to Bounds</strong></span></code></strong> for the image view is enabled. This will make sure the rounded corner effect is visible.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip9"></a>Note</h3><p>In addition to the technique demonstrated below, you can set a <strong class="userinput"><code>User defined runtime attributes</code></strong> panel on a view using the <span class="strong"><strong><strong class="userinput"><code>Identity Inspector</code></strong></strong></span>. You can use this panel to configure properties that are normally not exposed to <strong class="userinput"><code>Interface Builder</code></strong>. To set a corner radius, you can use the following attributes: <span>Key Path:</span><code class="literal">layer.cornerRadius</code>, <code class="literal">Type: Number</code>, and <code class="literal">Value: 25</code>.</p></div><p>The best place to set the corner radius for the collection view <span>cell</span><a id="id325337693" class="indexterm"></a> is in <code class="literal">awakeFromNib()</code>. This method is only called once for each <span>cell</span><a id="id325337706" class="indexterm"></a> which makes it the perfect place to do some extra view configuration. Add the following piece of code to <code class="literal">ContactCollectionViewCell.swift</code> to implement the rounded corner effect:</p><pre class="programlisting">override func awakeFromNib() {
  super.awakeFromNib()

  contactImage.layer.cornerRadius = 25
}</pre><p>The preceding snippet only sets the corner radius for the image's layer to 25. Every view has a layer that is used for animations and rendering. When you set a corner radius on an image, you must do this on the layer instead of the view. You can also use the view's layer to add drop shadows, borders, and more.</p><p>All you need to do is assign a radius to the layer and run the app. All the other required work, such as making sure the view clips to its bounds, has already been done in <strong class="userinput"><code><span class="strong"><strong>Interface Builder</strong></span>.</code></strong> Now that you know how to improve the look of your cells, it's time to explore the collection view's layout object.</p></div></div>