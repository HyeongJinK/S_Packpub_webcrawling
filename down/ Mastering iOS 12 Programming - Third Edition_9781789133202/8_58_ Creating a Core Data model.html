<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec59"></a>Creating a Core Data model</h2></div></div><hr /></div><p>So far, you have worked on the persistence layer of your app. The next step is to create your models so you can actually store and retrieve data from your Core Data database. All models in an application that uses <span>Core</span><a id="id325357406" class="indexterm"></a> Data are represented by <code class="literal">NSManagedObject</code> subclasses. When you retrieve data from your database, <code class="literal">NSManagedObjectContext</code> is responsible for creating instances of your managed objects and populating them with the relevant fetched data.</p><p>The <span class="strong"><strong>MustC</strong></span> application requires two models: a family-member model and a movie model. When you define models, you can also define relationships. For the models in <span class="strong"><strong>MustC</strong></span>, you should define a relationship that links multiple movies to a single family member.</p><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec34"></a>Creating the models</h3></div></div></div><p>In order for Core Data to understand which models your application uses, you must define them in Xcode's model editor. Let's create a new model file so you can add your own models to the <span class="strong"><strong>MustC</strong></span> application. Create a <span>new</span><a id="id325602500" class="indexterm"></a> file, and from the file template selection screen, pick <strong class="userinput"><code>Data Model</code></strong>. Name your model file <code class="literal">MustC</code>. First, you will set up the basic models, and then see how you can define a relationship between family members and their favorite movies:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/f8522466-1ba0-4d9d-926e-b9a3ef85f47e.png" /></div><p>Your project now contains a file called <code class="literal">MustC.xcdatamodeld</code>. Open this file to go to the model editor. In the bottom-left corner of the editor, you'll find a button labeled <strong class="userinput"><code>Add Entity</code></strong>. Click this button to add a new Entity and name it <code class="literal">FamilyMember</code>.</p><p>When you select an Entity by clicking it, you can see all of its attributes, relationships, and fetched properties. Let's add a <strong class="userinput"><code>name</code></strong> property to the family member. Click on the plus ( <strong class="userinput"><code>+</code></strong> ) icon at the bottom of the empty attributes list and add a new attribute called <strong class="userinput"><code>name</code></strong>. Make sure that you select <code class="literal">String</code> as the type for this attribute:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/388e9ac3-914c-436d-afde-88e06e43b032.png" /></div><p>Click on this <span>new</span><a id="id325605892" class="indexterm"></a> property to select it. In the sidebar on the right, select the third tab to open the <strong class="userinput"><code>Data Model inspector</code></strong>. This is where you can see more detailed information on this attribute. For instance, you can configure a property to be indexed for faster lookups. You can also choose whether you want the attribute to be optional. For now, you shouldn't care too much about indexing since you're not performing lookups by family members' names, and, even if you were, a family doesn't tend to have hundreds or thousands of members. By default, the <strong class="userinput"><code>Optional</code></strong> checkbox is checked. Make sure that you uncheck this box because you don't want to store family members without a name.</p><p>Some other options you have for attributes are adding validation, adding a default value, and enabling indexing in Spotlight. For now, leave all those options in their default setting:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/b8893b13-ac32-4e44-b5ef-01e01db3c66d.png" /></div><p>In addition to a <code class="literal">FamilyMember</code> Entity, <span class="strong"><strong>MustC</strong></span> also needs a <code class="literal">Movie</code> Entity. Create this entity using the same steps as before and give it a single property: <code class="literal">title</code>. This property should be a string and it shouldn't be optional. Once you've added this property, you can set up a relationship between family members and their favorite movies.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec35"></a>Defining relationships</h3></div></div></div><p>A relationship in <span>Core</span><a id="id325606069" class="indexterm"></a> Data adds a reference to an Entity as a property on an Entity. In this case, you want to define a relationship between <code class="literal">FamilyMember</code> and <code class="literal">Movie</code>. The best way to describe this relationship is a one-to-many relationship. This means that every movie will have only one family member associated with it and every family member can have multiple favorite movies.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"></a>Note</h3><p>Configuring your data model with a one-to-many relationship from <code class="literal">Movie</code> to <code class="literal">FamilyMember</code> is not the most efficient way to define this relationship. A many-to-many relationship is likely a better fit because that would allow multiple family members to add the same movie instance as their favorite. A one-to-many relationship is used in this example to keep the setup simple and make it easy to follow along with the example.</p></div><p>Select the <code class="literal">FamilyMember</code> entity and click on the plus icon at the bottom of the <strong class="userinput"><code>Relationships</code></strong> list. Name the relationship <code class="literal">movies</code> and select <code class="literal">Movie</code> as the destination. Don't select an <strong class="userinput"><code>Inverse</code></strong> relationship yet because the other end of this relationship is not defined yet. The <strong class="userinput"><code>Inverse</code></strong> relationship will tell the model that <code class="literal">Movie</code> has a property that points back to the <code class="literal">FamilyMember</code>. Make sure that you select <strong class="userinput"><code>to many</code></strong> as the relationship type in the <span class="strong"><strong>Data Model Inspector</strong></span> panel for the <code class="literal">movies</code> property. Also, select <strong class="userinput"><code>Cascade</code></strong> as the value for the <strong class="userinput"><code>delete rule</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/ee187c87-6c5f-470c-bd79-ff5b149af3c7.png" /></div><p>The <strong class="userinput"><code>delete rule</code></strong> is a very important property to be set correctly. Not paying attention to this property could result in a lot of orphaned, and even corrupted, data in your database. For instance, setting this property to nullify simply sets the <strong class="userinput"><code>Inverse</code></strong> of the relationship to nil. This is the correct behavior when deleting a movie because deleting a movie shouldn't delete the entire family member who added this movie as their favorite. It should simply be removed from the list of favorites.</p><p>However, if a <code class="literal">FamilyMember</code> gets deleted <span>and</span><a id="id325357508" class="indexterm"></a> the relationship is nullified, you would end up with a bunch of movies that don't have a family member associated with them. In this application, these movies are worthless; they won't be used anymore because every movie only belongs to a single <code class="literal">FamilyMember</code>. For this app, it's desirable that when a <code class="literal">FamilyMember</code> gets deleted, Core Data also deletes their favorite movies. This is precisely what the cascade option does; it cascades the deletion over to the relationship's <strong class="userinput"><code>Inverse</code></strong>.</p><p>After setting the delete rule to cascade, select the <code class="literal">Movie</code> entity and define a relationship called <code class="literal">familyMember</code>. The destination should be <code class="literal">FamilyMember</code> and the <strong class="userinput"><code>Inverse</code></strong> for this relationship is <code class="literal">favoriteMovies</code>. After adding this relationship, the <strong class="userinput"><code>Inverse</code></strong> will be automatically set on the <code class="literal">FamilyMember</code> entity:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/71c93c10-5c39-42bb-8044-830052106542.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec36"></a>Using your entities</h3></div></div></div><p>As mentioned before, every model or Entity in your Core Data database is represented by an <code class="literal">NSManagedObject</code>. There are a couple of ways to create or generate <code class="literal">NSManagedObject</code> subclasses. In the simplest of setups, an <code class="literal">NSManagedObject</code> subclass contains just the properties for a certain managed object <span>and</span><a id="id325357577" class="indexterm"></a> nothing else. If this is the case, you can let Xcode generate your model classes for you.</p><p>This is actually what Xcode does by default. If you build your project now and add the following code to <code class="literal">viewDidLoad()</code> in <code class="literal">FamilyMembersViewController</code>, your project should compile just fine:</p><pre class="programlisting">let fam = FamilyMember(entity: FamilyMember.entity(), insertInto: persistentContainer.viewContext)</pre><p> </p><p>This works automatically; you don't have to write any code for your models yourself. Don't worry about what the preceding code does just yet, we'll get into that very soon. The point is that you see that a <code class="literal">FamilyMember</code> class exists in your project even though you didn't have to create one yourself.</p><p>If the default behavior doesn't suit the approach you want in your app – for instance, if you want to prevent your code from modifying your models by defining your variables as <code class="literal">private(set)</code> – you may want to create a custom subclass instead of making Xcode generate the classes for you. A custom <code class="literal">NSManagedObject</code> subclass for <code class="literal">FamilyMember</code> could look like this:</p><pre class="programlisting">class FamilyMember: NSManagedObject {   
    @NSManaged private(set) var name: String   
    @NSManaged private(set) varfavoriteMovies: [Movie]?   
} </pre><p>This custom <code class="literal">FamilyMember</code> subclass makes sure that external code can't modify the instances by making the setters on <code class="literal">FamilyMember</code> private. Depending on your application, it might be a good idea to implement this since it will ensure that your models can't accidentally change.</p><p>One final option you have is to let Xcode generate the properties for your <code class="literal">NSManagedObject</code> as an extension on a class you define. This is particularly useful if you have some custom stored properties that you'd like to define on your model or if you have a customized <code class="literal">NSManagedObject</code> subclass that you can use as the base for all of your models.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"></a>Note</h3><p>All code that Xcode generates for your Core Data models is added to the <code class="literal">Build</code> folder in Xcode's Derived Data. You shouldn't modify it, or access it directly. These files will be automatically regenerated by Xcode whenever you perform a build, so any functionality you add inside the generated files will be overwritten.</p></div><p>For the <span class="strong"><strong>MustC</strong></span> app, it's okay if Xcode generates the model definition classes since there are no custom properties that you need to add. In the model editor, select each entity <span>and</span><a id="id325357656" class="indexterm"></a> make sure that the <strong class="userinput"><code>Codegen</code></strong> field is set to <strong class="userinput"><code>Class Definition</code></strong>; you can find this field in the Data Model inspector panel:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/969fbc67-f9df-42a4-98a3-22b7399c2f0a.png" /></div><p>At this point, you are all set up to store your first data in the Core Data database.</p></div></div>