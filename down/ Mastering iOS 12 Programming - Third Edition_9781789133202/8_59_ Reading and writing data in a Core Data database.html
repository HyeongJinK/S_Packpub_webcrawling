<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec60"></a>Reading and writing data in a Core Data database</h2></div></div><hr /></div><p>The first step to implement data <span>persistence</span><a id="id325333110" class="indexterm"></a> for your app is to make sure that you can store data in the database. You have <span>defined</span><a id="id325333118" class="indexterm"></a> the models that you want to store in your database so the next step is to actually store your models. Once you have implemented a rough version of your data persistence, you will refine the code to make it more reusable. The final step will be to read data from Core Data and dynamically respond to changes in the database.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec37"></a>Understanding data persistence</h3></div></div></div><p>Whenever you want to persist a model with Core Data, you must insert a new <code class="literal">NSManagedObject</code> into an <code class="literal">NSManagedObjectContext</code>. Doing this does not immediately persist the model. It merely stages the object for persistence in the current <code class="literal">NSManagedObjectContext</code>. If you don't properly manage your managed objects and contexts, this is a potential source of bugs. For example, not persisting your managed objects results in the loss of your data once you refresh the context. Even though this might sound obvious, it could lead to several hours of frustration if you aren't aware of this and have bugs in managing your managed object context.</p><p>If you want to save managed <span>objects</span><a id="id325333146" class="indexterm"></a> correctly, you must tell the managed-object context to persist its changes to the persistent store coordinator. The persistent store coordinator will take care of persisting the data in the underlying SQLite database.</p><p>Extra care is required when you use multiple managed object contexts. If you insert an object in one managed object context and persist it, you will manually need to synchronize the changes into the other managed object contexts. Also, managed objects are not thread-safe. This means that you must make sure that you create, access, and store a managed object on a single thread at all times. The managed-object context has a helper method called <code class="literal">perform(_:)</code> to help you with this.</p><p>Inserting new objects, updating them, or adding relationships between objects should always be done using the <code class="literal">perform(_:)</code> method. The reason is that the helper method makes sure that all code in the closure you want to perform are executed on the same thread that the managed object context is on.</p><p> </p><p>Now that you're aware of how data persistence works in Core Data, it's time to start implementing the code to store family members and their favorite movies. You will implement the family member persistence first. Then you'll expand the app so you can safely add movies to family members.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec38"></a>Persisting your models</h3></div></div></div><p>The first model you will persist is the family <span>member</span><a id="id325357379" class="indexterm"></a> model. The app is already set up with a form that asks for a family member name and a delegate protocol that informs <code class="literal">FamilyMembersViewController</code> whenever the user wants to store a new family member.</p><p>Note that none of the input data is validated; usually, you'd want to add some checks that make sure that the user is not trying to insert an empty family member name, for instance. For now, we'll skip that because this type of validation isn't Core-Data-specific.</p><p>The code to persist new family members should be added to the <code class="literal">saveFamilyMember(withName:)</code> method. Add the following implementation to <code class="literal">FamilyMembersViewController</code>; we'll go over it line by line after adding the code:</p><pre class="programlisting">func saveFamilyMember(withName name: String) {
  // 1
  let moc = persistentContainer.viewContext

  // 2
  moc.perform {
    // 3
    let familyMember = FamilyMember(context: moc)
    familyMember.name = name

    // 4
    do {
      try moc.save()
    } catch {
      moc.rollback()
    }
  }
}</pre><p>The first comment in this code marks where the managed object context is extracted from <code class="literal">persistentContainer</code>. All <code class="literal">NSPersistentContainer</code> objects have a <code class="literal">viewContext</code> property. This property is used to obtain a managed object context that exists on the main thread.</p><p>The second comment marks the call to <code class="literal">perform(_:)</code>. This ensures that the new <code class="literal">FamilyMember</code> instance is created and stored on the correct thread. When you create an instance of a managed object context, you must pass the managed object context to the instance of <code class="literal">NSManagedObject</code>.</p><p>Lastly, saving the managed object context can fail, so you must wrap the call to <code class="literal">save()</code> in a <code class="literal">do {} catch {}</code> block, so it correctly handles potential errors. If the managed object context can't be saved, all unsaved changes are rolled back.</p><p>This code is all you need to persist family members. Before you implement the required code to read existing family members and respond to the insertion of new family members, let's set up <code class="literal">MoviesViewController</code> so it can store movies for a family member.</p><p>The code to store movies for a family member is very similar to the code you wrote earlier. Before you implement the following snippets, make sure that you conform <code class="literal">MoviesViewController</code> to <code class="literal">PersistenContainerRequiring</code> and import <code class="literal">CoreData</code>. Also, add a <code class="literal">persistentContainer</code> property to <code class="literal">MoviesViewController</code>.</p><p>In order to connect a new movie to a <span>family</span><a id="id325578347" class="indexterm"></a> member, you also need a variable to hold the family member in <code class="literal">MoviesViewController</code>. Add the following declaration to <code class="literal">MoviesViewController</code>:</p><pre class="programlisting">var familyMember: FamilyMember? </pre><p>After doing this, add the following implementation for <code class="literal">saveMovie(withName:)</code>:</p><pre class="programlisting">func saveMovie(withName name: String) {
  guard let familyMember = self.familyMember
    else { return }

  let moc = persistentContainer.viewContext

  moc.perform {
    let movie = Movie(context: moc)
    movie.title = name

    // 1
    let newFavorites: Set&lt;AnyHashable&gt; = familyMember.movies?.adding(movie) ?? [movie]

    // 2
    familyMember.movies = NSSet(set: newFavorites)

    do {
      try moc.save()
    } catch {
      moc.rollback()
    }
  }
}</pre><p>The most important differences between adding the movie and the family member are highlighted with comments. Note that the <code class="literal">movies</code> property on a family member is <code class="literal">NSSet</code>. This is an immutable object so you need to create a copy and add the movie to that copy. If no copy could be made because there is no set created yet, you can create a new set with the new movie in it. Next, this new updated <code class="literal">Set</code> is converted back to an <code class="literal">NSSet</code> so it can be the new value for <code class="literal">movies</code>.</p><p>As you can see, both save methods share about half of the implementation. You can make some clever use of extensions and generics in Swift to avoid writing this duplicated code. Let's refactor the app a bit.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec39"></a>Refactoring the persistence code</h3></div></div></div><p>Many iOS developers dislike the amount of boilerplate code that is involved with using <span>Core</span><a id="id325609934" class="indexterm"></a> Data. Simply persisting an object requires you to repeat several lines of code, which can become quite a pain to write and maintain over time. The approach to refactoring the persistence code presented in the following examples is heavily inspired by the approach taken in the <span class="emphasis"><em>Core Data</em></span><span>book</span> written by <span class="emphasis"><em>Florian Kugler</em></span> and <span class="emphasis"><em>Daniel Eggert</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Note</h3><p><span>If you're interested</span> in learning more about Core Data outside of what this book covers, and if you'd like to see more clever ways to reduce the amount of boilerplate code, <span>you should</span> pick up this book.</p></div><p>One pattern you can find in both save methods is the following:</p><pre class="programlisting">moc.perform {   
  // create managed object   

  do {   
    try moc.save()   
  } catch {   
    moc.rollback()   
  }   
}</pre><p>It would be great if you could write the following code to persist data instead:</p><pre class="programlisting">moc.persist {   
    // create managed object   
} </pre><p>This can be achieved by writing an extension for <code class="literal">NSManagedObjectContext</code>. Add a file called <code class="literal">NSManagedObjectContext</code> to the extensions folder, and add the following implementation:</p><pre class="programlisting">import CoreData   

extension NSManagedObjectContext {   
  func persist(block: @escaping () -&gt; Void) {
    perform {
      block()

      do {
        try self.save()
      } catch {
        self.rollback()
      }
    }
  }  
} </pre><p>The preceding code allows you to <span>reduce</span><a id="id325615328" class="indexterm"></a> the amount of boilerplate code, which is something that you should always try to achieve. Reducing boilerplate code greatly improves your code's readability and maintainability. Update both the family overview and the movie list view controllers to make use of this new persistence method.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec40"></a>Reading data with a simple fetch request</h3></div></div></div><p>The simplest way to fetch data from your <span>database</span><a id="id325617699" class="indexterm"></a> is to use a fetch request. The managed object context forwards fetch requests to the persistent store coordinator. The persistent store coordinator will then forward the request to the persistent store, which will then convert the request to a SQLite query. Once the results are fetched, they are passed back up this chain and converted to <code class="literal">NSManagedObject</code> instances.</p><p>By default, these objects are called faults. When an object is a fault, it means that the actual properties and values for the object are not fetched yet, but they will be fetched once you access them. This is an example of a good implementation of lazy variables because fetching the values is a pretty fast operation, and fetching everything up front would greatly increase your app's memory footprint because all values would have to be loaded into memory right away.</p><p>Let's take a look at an example of a simple fetch request that retrieves all <code class="literal">FamilyMember</code> instances that were saved to the database:</p><pre class="programlisting">let request: NSFetchRequest&lt;FamilyMember&gt; = FamilyMember.fetchRequest()   

let moc = persistentContainer.viewContext

guard  let results = try? moc.fetch(request)   
  else { return } </pre><p>As you can see, it's not particularly hard to fetch all of your family members. Every <code class="literal">NSManagedObject</code> has a class method that configures a basic fetch request that can be used to retrieve data. If you have large amounts of data, you probably don't want to fetch all of the persisted objects at once. You can configure your fetch request to fetch data in batches by setting the <code class="literal">fetchBatchSize</code> property. It's recommended that you use this property whenever you want to use fetched data in a table view or collection view. You should set the <code class="literal">fetchBatchSize</code> property to a value that is just a bit higher than the number of cells you expect to display at a time. This makes sure that Core Data fetches plenty of items to display while avoiding loading everything at once.</p><p>Now that you know how to fetch data, let's display some data in the family member's table view. Add a new variable called <code class="literal">familyMembers</code> to <code class="literal">FamilyMembersViewController</code>. Give this property an initial value of <code class="literal">[FamilyMember]()</code>, so you start off with an empty array of family members. Also, add the example fetch request you saw earlier to <code class="literal">viewDidLoad()</code>. Next, assign the result of the fetch request to <code class="literal">familyMembers</code> as follows:</p><pre class="programlisting">familyMembers = results  </pre><p>Finally, update the table view delegate <span>methods</span><a id="id325618112" class="indexterm"></a> so <code class="literal">tableView(_:numberOfRowsInSection:)</code> returns the number of items in the <code class="literal">familyMembers</code> array. Also, update the <code class="literal">tableView(_:cellForRowAtIndexPath:)</code> method by adding the following two lines before returning the cell:</p><pre class="programlisting">let familyMember = familyMembers[indexPath.row]   
cell.textLabel?.text = familyMember.name </pre><p>If you build and run your app now, you should see the family members you already saved. New family members won't show up right away. However, when you quit the app and run it again, new members will show up.</p><p>You could manually reload the table view right after you insert a new family member so it's always up to date but this isn't the best approach. You will see a better way to react to the insertion of new data soon. Let's finish the family member detail view first so it shows a family member's favorite movies. Add the following code to the end of the <code class="literal">prepare(for:sender:)</code> method in the overview view controller:</p><pre class="programlisting">if let moviesVC = segue.destination as? MoviesViewController {
  moviesVC.persistentContainer = persistentContainer
  moviesVC.familyMember = familyMembers[selectedIndex.row]
}</pre><p>The preceding lines of code pass the selected family member and the persistent container to <code class="literal">MoviesViewController</code> so it can display and store the current family member's favorite movies.</p><p>All you need to do to show the correct movies for a family member is use the family member's favorite movies in the <code class="literal">MovieViewController</code> class's table-view data-source methods, as follows:</p><pre class="programlisting">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt;Int {
  return familyMember?.movies?.count ?? 0
}

func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
  guard let cell = tableView.dequeueReusableCell(withIdentifier: "MovieCell"),
    let movies = familyMember?.movies
    else { fatalError("Wrong cell identifier requested or missing family member") }

  let moviesArray = Array(movies as! Set&lt;Movie&gt;)
  let movie = moviesArray[indexPath.row]
  cell.textLabel?.text = movie.title

  return cell
}</pre><p>You don't need to use a fetch request here <span>because</span><a id="id325333824" class="indexterm"></a> you can simply traverse the <code class="literal">movies</code> relationship on the family member to get their favorite movies. This isn't just convenient for you as a developer, it's also good for your app's performance. Every time you use a fetch request, you force a query to the database. If you traverse a relationship, Core Data will attempt to fetch the object from memory instead of asking the database.</p><p>Again, adding new data won't immediately trigger the table view to update its contents. We'll get to that after we take a look at how to filter data. If you want to check whether your code works, build and rerun the app so all the latest data is fetched from the database.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec41"></a>Filtering data with predicates</h3></div></div></div><p>A typical operation you'll want to perform on your database is filtering. In Core Data, you use predicates to do this. A <span class="strong"><strong>predicate</strong></span><span>describes</span> a set of rules that any object that gets <span>fetched</span><a id="id325333854" class="indexterm"></a> has to match.</p><p>When you model your data in the model editor, it's wise to think about the types of <span>filtering</span><a id="id325333863" class="indexterm"></a> you need to do. For instance, you may be building a birthday calendar where you'll often sort or filter by date. If this is the case, you should make sure that you have a Core Data index for this property. You can enable indexing with the checkbox you saw earlier in the model editor. If you ask Core Data to index a property, it will significantly improve performance when filtering and selecting data in large datasets.</p><p>Writing predicates can be confusing, especially if you try to think of them as the <code class="literal">where</code> clause from SQL. Predicates are very <span>similar</span>, but they're not quite the same. A simple predicate looks as follows:</p><pre class="programlisting">NSPredicate(format: "name CONTAINS[n] %@", "Gu") </pre><p>A predicate has a format; this format always starts with a key. This key represents the property you want to match on. In this example, it would be the name of a family member. Then, you specify the condition, for instance <code class="literal">==</code>, <code class="literal">&gt;</code>, <code class="literal">&lt;</code>, or <code class="literal">CONTAINS[n]</code>. There are more conditions available, but the ones listed are some examples of conditions you'll commonly use. Finally, you will specify a placeholder that is substituted with the true value. This placeholder is <code class="literal">%@</code> in the preceding sample. If you have written any Objective-C before you picked up this book, the <code class="literal">%@</code> placeholder might look familiar to you because it's used as a placeholder in format strings there.</p><p>The example predicate is very simple and bare; it could be the template for a search feature you're building. Usually, a simple search doesn't have to be much more complicated than this as long as there's an index added to the properties you search for.</p><p>If you have multiple predicates you want to match on, you can combine them using <code class="literal">NSCompoundPredicate</code>. This class combines different predicates using either an <code class="literal">and</code>, <code class="literal">or</code>, or <code class="literal">not</code> clause. A typical use case for this approach is when you build a complex filter in your app where the predicate is hard to express in a single statement.</p><p>To use a predicate in a fetch request, you assign it to the<code class="literal">predicate</code>property of a fetch request. Every fetch request has a predicate property that you can set. It can handle both a single predicate and a compound predicate. If you set this property before executing the fetch request, the predicate is applied to the request, and you will receive a filtered dataset instead of the full dataset.</p><p>Predicates are powerful, and they have many <span>options</span><a id="id325333934" class="indexterm"></a> available.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note27"></a>Note</h3><p>If you're <span>interested</span> in an in-depth overview of predicates and all of the ways in which you can make use of format strings, I recommend that you read <span class="emphasis"><em>Apple's Predicate Programming Guide at</em></span><a class="ulink" href="http://apple.co/2fF3qHc" target="_blank">http://apple.co/2fF3qHc</a>. It provides a well-documented overview of predicates and their applications.</p></div><p>Next up, you will learn how to respond to changes in the managed object context. For instance, when you add new family members and movies.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec42"></a>Reacting to database changes</h3></div></div></div><p>In its current state, the <span class="strong"><strong>MustC</strong></span> app doesn't update its list <span>when</span><a id="id325333973" class="indexterm"></a> a new managed object is persisted. One possible solution for this is to manually reload the table right after a new family member is inserted. Although this might work well for some time, it's not the best solution to this problem. If the app grows, you might add a functionality that imports new family members from the network. Manually refreshing the table view would be problematic because the networking logic should not be aware of the table view. Luckily, there is a better solution to react to changes in your data.</p><p>One way to respond to database changes is using <code class="literal">NSFetchedResultsController</code>. This object is perfect for listening to the insertion of new family members. A second way to respond to notifications is through notifications. You will implement this approach in <code class="literal">MoviesViewController</code>.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec28"></a>Implementing NSFetchedResultsController</h4></div></div></div><p><code class="literal">NSFetchedResultsController</code> is a helper object that specializes in fetching data and managing this data. It listens to changes in its managed object context and notifies a delegate whenever the data it has fetched changes. This is incredibly helpful because it allows you to respond to specific changes in the dataset <span>rather</span><a id="id325580650" class="indexterm"></a> than reloading the table view entirely.</p><p>Being a delegate for the fetched results controller involves the following four important <span>methods</span>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">controllerWillChangeContent(_:)</code></li><li style="list-style-type: disc"><code class="literal">controllerDidChangeContent(_:)</code></li><li style="list-style-type: disc"><code class="literal">controller(_:didChange:at:for:newIndexPath:)</code></li><li style="list-style-type: disc"><code class="literal">controller(_:didChange:atSectionIndex:for:)</code></li></ul></div><p>The first method, <code class="literal">controllerWillChangeContent(_:)</code>, is called right before the controller passes updates to the delegate. If you're using a table view with a fetched-results controller, this is the perfect method to begin updating the table view.</p><p>Next, <code class="literal">controller(_:didChange:at:for:newIndexPath:)</code> and <code class="literal">controller(_:didChange:atSectionIndex:for:)</code> are called to inform the delegate about updates to the fetched items and sections, respectively. This is where you should handle updates in the fetched data. For instance, you could insert new rows in a table view if new items were inserted in the dataset.</p><p>Finally, <code class="literal">controllerDidChangeContent(_:)</code> is called. This is the point where <span>you</span><a id="id325580702" class="indexterm"></a> should let the table view know you've finished processing the updates so all the updates can be applied to the table view's interface.</p><p>For <span class="strong"><strong>MustC</strong></span>, it doesn't make sense to implement all four methods because the table view that shows family members only has a single section. This means <code class="literal">controller(_:didChange:atSectionIndex:for:)</code> does not have to be implemented.</p><p>To use a fetched-results controller to fetch the stored family members, you need to create an instance of <code class="literal">NSFetchedResultsController</code> and assign <code class="literal">FamilyMembersViewController</code> as its delegate so it can respond to changes in the underlying data. You can then implement the delegate methods so you can respond to changes in the fetched-results dataset. Remove the <code class="literal">familyMembers</code> array from the variable declarations in <code class="literal">FamilyMembersViewController</code> and add the following <code class="literal">fetchedResultsController</code> property:</p><pre class="programlisting">var fetchedResultsController: NSFetchedResultsController&lt;FamilyMember&gt;? </pre><p>The <code class="literal">viewDidLoad</code> method should be adjusted as follows:</p><pre class="programlisting">override func viewDidLoad() {
  super.viewDidLoad()

  let moc = persistentContainer.viewContext
  let request = NSFetchRequest&lt;FamilyMember&gt;(entityName: "FamilyMember")

  request.sortDescriptors = [NSSortDescriptor(key: "name", ascending: true)]
  fetchedResultsController = NSFetchedResultsController(fetchRequest: request, managedObjectContext: moc, sectionNameKeyPath: nil, cacheName: nil)

  fetchedResultsController?.delegate = self

  do {
    try fetchedResultsController?.performFetch()
  } catch {
    print("fetch request failed")
  }
}</pre><p>This implementation initializes <code class="literal">NSFetchedResultsController</code>, assigns its delegate, and tells it to execute the fetch request. Note that the <code class="literal">sortDescriptors</code> property of the fetch request is set to an array that contains <code class="literal">NSSortDescriptor</code>. A fetched-request controller requires this property to be set, and for the list of family members, it makes sense to order family members by name.</p><p>Now that you have a fetched-results controller, you should implement the delegate methods on <code class="literal">FamilyMembersViewController</code> and make it conform to <code class="literal">NSFetchedResultsControllerDelegate</code>. Add the following extension to <code class="literal">FamilyMembersViewController.swift</code>:</p><pre class="programlisting">extension FamilyMembersViewController: NSFetchedResultsControllerDelegate {
  func controllerWillChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
    tableView.beginUpdates()
  }

  func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
    tableView.endUpdates()
  }
}</pre><p>The implementation for this extension is fairly straightforward. The table view gets notified when the fetched-result controller is about to process changes to its data and when the fetched-<span>results</span> controller is done processing changes. The bulk of the work needs to be done in <code class="literal">controller(_:didChange:at:for:newIndexPath)</code>. This method is called when an update has been processed by the fetched-result controller. In <span class="strong"><strong>MustC</strong></span>, the goal is to update a table view, but <span>you</span><a id="id325580796" class="indexterm"></a> could also update a collection view or store all of the updates in a list and do something else with them.</p><p>Let's take a look at how you can process changes to fetched data in the following method:</p><pre class="programlisting">func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {

  switch type {
  case .insert:
    guard let insertIndex = newIndexPath
      else { return }
    tableView.insertRows(at: [insertIndex], with: .automatic)
  case .delete:
    guard let deleteIndex = indexPath
      else { return }
    tableView.deleteRows(at: [deleteIndex], with: .automatic)
  case .move:
    guard let fromIndex = indexPath,
      let toIndex = newIndexPath
      else { return }
    tableView.moveRow(at: fromIndex, to: toIndex)
  case .update:
    guard let updateIndex = indexPath
      else { return }
    tableView.reloadRows(at: [updateIndex], with: .automatic)
  }
} </pre><p>This method contains quite a lot of code, but it's actually not that complex. The preceding method receives a <code class="literal">type</code> parameter. This parameter is an <code class="literal">NSFetchedResultsChangeType</code> that contains information about the kind of update that was received. The following are the four types of updates that can occur:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">insert</code></li><li style="list-style-type: disc"><code class="literal">delete</code></li><li style="list-style-type: disc"><code class="literal">move</code></li><li style="list-style-type: disc"><code class="literal">update</code></li></ul></div><p>Each of these change types corresponds to a database action. If an object was inserted, you will receive an <code class="literal">insert</code> change type. The proper way to handle these updates for <span class="strong"><strong>MustC</strong></span> is to simply pass them on to the table view. Once all updates are received, the table view will apply all of these updates at once.</p><p>If you had implemented <code class="literal">controller(_:didChange:atSectionIndex:for:)</code> as well, it would also have received a change type; however, the sections only deal with the following two types of changes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">Insert</code></li><li style="list-style-type: disc"><code class="literal">Delete</code></li></ul></div><p>Sections don't update or move, so if you implement this method, <span>you</span><a id="id325580865" class="indexterm"></a> don't have to account for all cases because you won't encounter any, other than the two listed types of changes.</p><p>If you take a close look at the implementation for <code class="literal">controller(_:didChange:at:for:newIndexPath)</code>, you'll notice that it receives two index paths. One is named <code class="literal">indexPath</code>, and the other is named <code class="literal">newIndexPath</code>. They're both optional, so you will need to make sure that you safely unwrap them if you use them. For new objects, only the <code class="literal">newIndexPath</code> property will be present. For delete and update, the <code class="literal">indexPath</code> property will be set. When an object is moved from one place in the dataset to another, both <code class="literal">newIndexPath</code> and <code class="literal">indexPath</code> will have a value.</p><p>The last thing you need to do is update the code in <code class="literal">FamilyMembersViewController</code> so it uses the fetched results controller instead of the <code class="literal">familyMembers</code> array that it used earlier. First, update the <code class="literal">prepare(for:sender:)</code> method as follows:</p><pre class="programlisting">if let moviesVC = segue.destination as? MoviesViewController,
  let familyMember = fetchedResultsController?.object(at: selectedIndex) {
  moviesVC.persistentContainer = persistentContainer
  moviesVC.familyMember = familyMember
}</pre><p> </p><p>This makes sure that a valid family member is passed to the movies view controller. Update the table view data source methods as shown in the following code. A fetched-results controller can retrieve objects based on an index path. This makes it a great fit to use in combination with table views and collection views:</p><pre class="programlisting">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
  return fetchedResultsController?.fetchedObjects?.count ?? 0
}

func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
  guard let cell = tableView.dequeueReusableCell(withIdentifier: "FamilyMemberCell"),
    let familyMember = fetchedResultsController?.object(at: indexPath)
    else { fatalError("Wrong cell identifier requested") }


  cell.textLabel?.text = familyMember.name

  return cell
}</pre><p>If you run your app now, the interface updates automatically when you add a new family member to the database. However, the list of favorite movies doesn't update yet. That page does not use a fetched-results controller so it must listen to changes to the dataset directly.</p><p>The reason <code class="literal">MoviesViewController</code> doesn't use a fetched-results controller for the movie list is that fetched-result controllers will always need to drop down all the way to your persistent store (SQLite in this app). As mentioned before, querying the database has a significant memory overhead compared to traversing the relationship between family members and their movies; it's much faster to read the <code class="literal">movies</code> property than fetching them from the database.</p><p>Whenever a managed object context changes, a notification is posted to the default <code class="literal">NotificationCenter</code>. <code class="literal">NotificationCenter</code> is used to send events inside of an app so other parts of the code can react to those events.</p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note28"></a>Note</h3><p>It can be very tempting to use notifications instead of delegates, especially if you're coming from a background that makes heavy use of events such as JavaScript. Don't do this; delegation is better-suited to most cases, and it will make your code much more maintainable. Only use notifications if you don't care who's listening to your notifications or if setting up a delegate relationship between objects would mean you'd create very complex relationships between unrelated objects just to set up the delegation.</p></div><p>Let's subscribe <code class="literal">MoviesViewController</code> to changes in the managed object context so it can respond to data changes if needed. Before you implement this, add the following method, which should be called when changes in the managed object context occur:</p><pre class="programlisting">extension MoviesViewController {
  @objc func managedObjectContextDidChange(notification: NSNotification) {
    guard let userInfo = notification.userInfo,
      let updatedObjects = userInfo[NSUpdatedObjectsKey] as? Set&lt;FamilyMember&gt;,
      let familyMember = self.familyMember
      else { return }

    if updatedObjects.contains(familyMember) {
      tableView.reloadData()
    }
  }
} </pre><p>This method reads the notification's <code class="literal">userInfo</code> dictionary to access the information that's relevant to the current list. You're interested in changes to the current <code class="literal">familyMember</code> because when this object changes, you can be pretty sure that a new movie was just inserted. The <code class="literal">userInfo</code> dictionary contains keys for the inserted, deleted, and updated objects. In this case, you should look for the updated objects because users can't delete or insert new family members in this view. If the family member was updated, the table view is reloaded so it shows the new data.</p><p>The following code subscribes <code class="literal">MoviesViewController</code> to changes in the persistent container's managed object context:</p><pre class="programlisting">override func viewDidLoad() {
  super.viewDidLoad()

  NotificationCenter.default.addObserver(self, selector: #selector(self.managedObjectContextDidChange(notification:)), name: .NSManagedObjectContextObjectsDidChange, object: nil)
}</pre><p>When the view loads, the current <code class="literal">MoviesViewController</code> instance is added as an observer to the <code class="literal">.NSManagedObjectContextObjectsDidChange</code> notification. Go ahead and build your app; you should now see the user interface update whenever you add new data to your database.</p></div></div></div>