<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec41"></a>Understanding differences in types</h2></div></div><hr /></div><p>Being aware of the available <span>types</span><a id="id325333125" class="indexterm"></a> in Swift, knowing their similarities, and, more importantly, their differences will help you make better decisions about the way you write your code. The preceding segments have listed several properties of value types and references types. More specifically, you learned a lot about classes, structs, and enums. Closures are also a reference type because they get passed around by their location in memory rather than their value, but there isn't much else to say about them in this context.</p><p>The most obvious comparison you can make is probably between structs and classes. They look very similar, but they have very different characteristics, as you have already seen. Enums are a special type altogether, they represent a value from a fixed number of possible values but are very similar to structs otherwise.</p><p>The most import difference you need to understand is the general difference between value types and reference types, and the difference between structs and classes specifically. Let's have a look at value types and reference types first, so you have the general picture. Then you'll learn about the specific differences between structs and classes.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec25"></a>Comparing value types to reference types</h3></div></div></div><p>When comparing <span>value</span><a id="id325333144" class="indexterm"></a> types to reference types, it is essential to <span>distinguish</span><a id="id325333153" class="indexterm"></a> between the differences you can see as a developer and the differences that are internal to Swift and the way your app will end up working. Knowing these details will ensure that you can make a well-informed decision that considers all the implications instead of only focusing on memory usage or developer convenience.</p><p>Let's examine the more obvious and visible differences first. Afterward, you will learn about the memory implications for each type.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec26"></a>Differences in usage</h4></div></div></div><p>Add a new page to your Playground and give it a <span>name</span><a id="id325369904" class="indexterm"></a> again. Something such as <strong class="userinput"><code>Values vs References</code></strong> would be a good name for your new page. Add the following code to your Playground:</p><pre class="programlisting">protocol PetProtocol {
  var name: String { get }
  var ownerName: String { get set }
}

class Animal {
  let name: String

  init(name: String) {
    self.name = name
  }
}

class Pet: Animal, PetProtocol {
  var ownerName: String

  init(name: String, ownerName: String) {
    self.ownerName = ownerName

    super.init(name: name)
  }
}</pre><p>This code defines a <code class="literal">PetProtocol</code> that requires two properties to exist on all objects that conform to this protocol. The <code class="literal">name</code> property is defined as a constant since it only needs it to be gettable, and <code class="literal">ownerName</code> is a variable since it requires both <code class="literal">get</code> and <code class="literal">set</code>. The code also defines an <code class="literal">Animal</code> and <code class="literal">Pet</code> class. <code class="literal">Pet</code> is a subclass of <code class="literal">Animal</code>, and it conforms to <code class="literal">PetProtocol</code> because <code class="literal">Animal</code> satisfies the <code class="literal">name</code> constant requirement and <code class="literal">Pet</code> itself satisfies the <code class="literal">ownerName</code> variable.</p><p>Try changing the <code class="literal">class</code> declarations to <code class="literal">struct</code>. Your Playground will not compile now because structs cannot inherit from other objects like classes can. This is a limitation that is sometimes frustrating because you can end up with a lot of code duplication. Imagine that, in addition to <code class="literal">Pet</code>, you would like to create more types of animals, such as a <code class="literal">WildAnimal</code>, <code class="literal">SeaCreature</code>, this would be easy to achieve with classes because you can inherit from <code class="literal">Animal</code>. This is not <span>possible</span> with structs, so you <span>would</span><a id="id325580977" class="indexterm"></a> implement all these types as structs they would need to duplicate their <code class="literal">Animal</code> logic.</p><p>Another difference between value types and reference types is how they act when they are passed around. Add the following code to your Playground:</p><pre class="programlisting">class ImageInformation {
  var name: String
  var width: Int
  var height: Int

  init(name: String, width: Int, height: Int) {
    self.name = name
    self.width = width
    self.height = height
  }
}

struct ImageLocation {
  let location: String
  let isRemote: Bool
  var isLoaded: Bool
}

let info = ImageInformation(name: "ImageName", width: 100, height: 100)
let location = ImageLocation(location: "ImageLocation", isRemote: false, isLoaded: false)</pre><p>The declarations for <code class="literal">info</code> and <code class="literal">location</code> look very similar, but their underlying types are entirely different. Try writing a function that takes both <code class="literal">ImageLocation</code> and <code class="literal">ImageInformation</code> as an argument. And then try updating the <code class="literal">isLoaded</code> property of <code class="literal">location</code> and changing the <code class="literal">name</code> of <code class="literal">info</code>. The compiler will complain when you try to set <code class="literal">isLoaded</code> because the argument for <code class="literal">ImageLocation</code> is a <code class="literal">let constant</code>. The reason for this was described earlier in the discussion on value types.</p><p>Value types are passed around by value, meaning that changing a property of the argument will change the value altogether. Arguments for a function are always constants. This might not be obvious when you use a Reference type though, because it is perfectly fine to change the <code class="literal">name</code> property on <code class="literal">ImageInformation</code> inside of a function. This is because you don't pass the entire value around when you pass a reference type to a function. You pass the reference to the memory address around. This means that instead of the value being a constant, the underlying memory address is a constant. This, in turn, means that you can change whatever is in memory as much as you like, you just can't change the address that a constant points to.</p><p>Imagine that you must drive to somebody's house and they send you the address where they live. This is what it's like to pass around a reference type. Rather than sending you their entire house, they send you the address for their house. While you are driving to their house, the house can change in many ways. The owner could paint it, replace windows, doors, anything. In the end, you will still find the house because you received the address for this house and, as long as the owner doesn't move to a different address, you will find the correct house.</p><p>If you change this analogy to use value types, the person whose house you're <span>looking</span><a id="id325604085" class="indexterm"></a> for will simply send you a full copy of their house. So rather than you driving toward their house based on the address, they won't give you an address, they will just send you their whole house. If the owner makes changes to their copy of the house, you won't be able to see them reflected on your copy of the house unless they send you a new copy. This is also true for any modifications you make to your copy of the house.</p><p>You can imagine that in some cases it can be very efficient to send somebody a copy of something rather than the address. The sample of a house might be a bit extreme, but I'm pretty sure that if you order a parcel, you would much rather receive the parcel itself than receiving an address to fetch the parcel. This sort of efficiency is what you will learn about next by comparing how value types and reference types behave in terms of memory allocation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec27"></a>Differences in memory allocation</h4></div></div></div><p>To understand how using certain data <span>types</span><a id="id325604102" class="indexterm"></a> can affect your application's performance, you need to understand how and where they are placed into your application's memory and how they are accessed. Every application uses a certain amount of the host device's RAM (Random Access Memory). The memory that an application uses can be divided into two segments: the stack and the heap.</p><p>The heap is a section of reserved memory for your application that can grow and shrink as needed. The objects that are stored on the heap are stored in no particular order and the objects themselves can grow and shrink the memory they use on the heap as needed too. This means that, sometimes, a lot of memory will have to be reshuffled to accommodate the insertion of a new object in the heap. The following image visualizes this:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/5407a41b-01c4-40fe-945c-98eda8e0d04f.png" /></div><p>As you can see, the different objects in memory get moved around inside of the heap to make sure the new object fits. This dynamic nature of the heap makes inserting objects on the heap quite slow because you never know whether the object you are about to insert will fit immediately or whether something has to be reshuffled. The ability to reshuffle memory to fit new objects or to accommodate an existing one does make it a very good fit for objects that have a variable or growing size. The type of objects that are allocated on the heap are always reference types. This means that all class instances you create will be allocated on the heap. The same is true for closures since they too are reference types. Value types, on the other hand, are always allocated on the stack.</p><p>The stack is a section of RAM with a fixed size that is available to your application. Objects in the stack are always added and removed in a fixed manner, the last object to be added to the stack will be the first object that is removed from the stack. Because the stack behaves in such a predictable way, it is a very fast and efficient way to store and retrieve objects. The stack is always in the correct order and objects are never shuffled around to facilitate new objects. The fact that value <span>types</span><a id="id325605897" class="indexterm"></a> are allocated on the stack makes them very lightweight and performant when compared to reference types.</p><p>You might think that the performance of value types makes choosing between values types and references types a no-brainer. Unfortunately, choosing the correct type isn't <span class="emphasis"><em>that</em></span> easy. The next section of this chapter will explain why, and provide you with enough information to make informed decisions about the types you use in your own apps.</p></div></div></div>