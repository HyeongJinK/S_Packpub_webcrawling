<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch25lvl1sec168"></a>Creating reusable tasks with Operations</h2></div></div><hr /></div><p>You have just learned about <code class="literal">DispatchQueues</code>, and how they <span>are</span><a id="id325333126" class="indexterm"></a> used to schedule tasks that need to be performed on a different thread. You saw how this speeds up code and how it avoids blocking the main thread. In this section, you will take this one step further. The first reason for this is because asynchronous work is better organized if it is implemented as an isolated object that can be scheduled for execution instead of having several closures that make your code less readable.</p><p>The solution to having closures all over your asynchronous code is to use <code class="literal">Operation</code> instead of a closure. And instead of queueing everything in a dispatch queue, <code class="literal">Operation</code> instances <span>are</span><a id="id325333143" class="indexterm"></a> queued on <code class="literal">OperationQueue</code>. <code class="literal">OperationQueue</code> and <code class="literal">DispatchQueue</code> are similar, but not quite the same. <code class="literal">OperationQueue</code> can schedule <code class="literal">Operations</code> on one or more <code class="literal">DispatchQueues</code>. This is important because of the way in which <code class="literal">Operations</code> work.</p><p>When using <code class="literal">OperationQueue</code>, you can execute <code class="literal">Operations</code> in parallel or serially. It is also possible to specify dependencies for <code class="literal">Operations</code>. This means that you can make sure that certain <code class="literal">Operations</code> are completed before the next operation is executed. <code class="literal">OperationQueue</code> will manage the <code class="literal">DispatchQueues</code> needed to make everything happen, and it will execute <code class="literal">Operations</code> in the order in which they become ready to execute. Moreover, code that uses <code class="literal">Operations</code> will typically be easier to maintain and understand because all work is beautifully encapsulated in isolated building blocks.</p><p>The next section will briefly cover some of the basic concepts of <code class="literal">Operations</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note59"></a>Note</h3><p>If you're looking to learn more about using <code class="literal">Operations</code> in interesting and advanced ways, make sure to check out <span class="emphasis"><em>Apple's Advanced NSOperations talk</em></span> from <span class="emphasis"><em>WWDC 2015</em></span>. All code for this talk is presented in Swift 2.0, so you'll need to translate this code to Swift 4.2 yourself, but it's definitely worth a watch.</p></div><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec135"></a>Using Operations in your apps</h3></div></div></div><p>Let's take a deep dive into <code class="literal">Operations</code> and refactor the background fetch code from the <span class="strong"><strong>MustC</strong></span> app to make it use <code class="literal">Operations</code>. To do this, you will create two <code class="literal">Operation</code> subclasses: one that fetches data and updates a <code class="literal">movie</code> object, and one that calls the completion handler once all other operations <span>are</span><a id="id325581021" class="indexterm"></a> complete.</p><p>The setup will have a single <code class="literal">OperationQueue</code> that will execute all of the instances of the fetch <code class="literal">Operation</code> subclass and a single operation that calls the background fetch completion handler. The completion operation will have all of the fetch operations as its dependencies, so it's automatically executed when all fetch operations are completed.</p><p>Whenever you create an <code class="literal">OperationQueue</code> instance, you can specify the number of concurrent <code class="literal">Operation</code> instances that can be executed on the queue. If you set this number to one, you have a serial queue that runs all operations one by one in the order in which they become ready to execute.</p><p>An operation is considered ready when all preconditions for the operation are met. A great example of this is dependencies. An operation with dependencies is not ready to execute until all of the operations that it depends on are completed. Another example is exclusivity. It's possible to configure your setup to allow only a single operation of a particular type to be running at a time. An operation that is set up like that won't become ready until no other operations of that type are running.</p><p>If you set the maximum number of concurrent operations to a higher number, it's not guaranteed that the queue will run that number of operations simultaneously. Imagine setting the maximum amount to 1,000, and you put 2,000 operations in the queue. It's not likely that you will see 1,000 operations running in parallel. The system ultimately decides how many operations it will run at the same time, but it's never more than your maximum value.</p><p>As mentioned before, you can improve the <span class="strong"><strong>MustC</strong></span> app by using <code class="literal">OperationQueue</code>. Get started with this refactor by creating an <code class="literal">OperationQueue</code> instance. You will add all download operations to this queue. Replace the implementation of <code class="literal">application(_:performBackgroundFetchWithCompletionHandler:)</code> in <code class="literal">AppDelegate</code> with the following:</p><pre class="programlisting">func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {

  let queue = OperationQueue()

  let fetchRequest: NSFetchRequest&lt;Movie&gt; = Movie.fetchRequest()
  let managedObjectContext = persistentContainer.viewContext
  guard let allMovies = try? managedObjectContext.fetch(fetchRequest) else {
    completionHandler(.failed)
    return
  }
}</pre><p>The preceding code creates an operation queue. This is the queue that will be used to fetch all movies and call the background fetch completion handler once all downloads <span>are</span><a id="id325602481" class="indexterm"></a> done. Before you can add operations to the queue, you must create the appropriate classes to contain your operation. Create a new file and name it <code class="literal">UpdateMovieOperation.swift</code>.</p><p>Every custom operation you create should subclass the <code class="literal">Operation</code> base class. The <code class="literal">Operation</code> class implements most of the glue and boilerplate code involved in managing and executing operations and queues. There <span>are</span><a id="id325602502" class="indexterm"></a> a couple of mandatory read-only variables that you need to implement for your operation. Also, you need to make sure these variables are <span class="strong"><strong>KVO (Key-Value Observing)</strong></span> compliant, so the operation queue can observe the various states your operation will go through during its lifetime. Add the following basic implementation for <code class="literal">UpdateMovieOperation</code>:</p><pre class="programlisting">import Foundation

class UpdateMovieOperation: Operation {
  override var isAsynchronous: Bool { return true }
  override var isExecuting: Bool { return _isExecuting }
  override var isFinished: Bool { return _isFinished }

  private var _isExecuting = false
  private var _isFinished = false
  var didLoadNewData = false

  let movie: Movie

  init(movie: Movie) {
    self.movie = movie
  }
}</pre><p>You'll immediately notice that this implementation overrides a couple of variables. These are the read-only variables that were mentioned earlier. The <code class="literal">isExecuting</code> and <code class="literal">isFinished</code> variables return the value of two private variables that will be mutated to reflect the operation's state later.</p><p> </p><p>Furthermore, the operation keeps track of whether new data was loaded, and <span>there</span> are a property and initializer to attach a <code class="literal">Movie</code> to the operation. So far, this operation isn't very exciting. Add the following methods to your operation so it can do something:</p><pre class="programlisting">override func start() {
  super.start()

  willChangeValue(forKey: #keyPath(isExecuting))
  _isExecuting = true
  didChangeValue(forKey: #keyPath(isExecuting))

  let helper = MovieDBHelper()
  helper.fetchRating(forMovieId: movie.remoteId) { [weak self] id,
    popularity in
    defer {
      self?.finish()
    }

    guard let popularity = popularity,
      let movie = self?.movie,
      popularity != movie.popularity
      else { return }

    self?.didLoadNewData = true

    movie.managedObjectContext?.persist {
      movie.popularity = popularity
    }
  }
}

func finish() {
  willChangeValue(forKey: #keyPath(isFinished))
  _isFinished = true
  didChangeValue(forKey: #keyPath(isFinished))
}</pre><p>Apple's guidelines state that every subclass of <code class="literal">Operation</code> should override the <code class="literal">start()</code> method and initiate the operation from there. You'll note that the superclass implementation is called first. This is because the superclass takes care of several under-the-hood tasks that must be performed to make the operation work. Next, <code class="literal">willChangeValue(forKey:)</code> and <code class="literal">didChangeValue(forKey:)</code> are called to fire the KVO notifications, so the operation queue knows when the state of the operation has changed or is about to change.</p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip60"></a>Note</h3><p>You might notice that the values of <code class="literal">isFinished</code> and <code class="literal">isExecuted</code> are not changed after calling <code class="literal">willChangeValue(forKey:)</code>. This is okay because these methods only tell any observers that reading specific properties after <code class="literal">didChangeValue(forKey:)</code> will yield a different value than before. Since <code class="literal">isFinished</code> and <code class="literal">isExecuting</code> return the value of the private properties that are changed, <code class="literal">isFinished</code> and <code class="literal">isExecuting</code> will return different values, as the observer expects.</p></div><p>Next, the code from before is used to fetch and <span>update</span><a id="id325606054" class="indexterm"></a> the movie. A <code class="literal">defer</code> block is used to call the <code class="literal">finish()</code> method when the operation is done, regardless of how the network request went. By using <code class="literal">defer</code> instead of manually calling <code class="literal">finish()</code> when appropriate, you can't forget to call <code class="literal">finish()</code> if the code changes at some point. The <code class="literal">finish()</code> method makes sure that the operation queue is notified about the operation's new status by firing the corresponding KVO notifications.</p><p>Another operation that calls the background fetch completion handler should be created. This operation should loop through all of its dependencies, check whether it's a movie update operation, and if it is, it should check whether at least one of these operations has loaded new data. After doing this, the completion handler should be called with the corresponding result, and finally, the operation should finish itself. Create a new file in the <code class="literal">Operations</code> folder and name it <code class="literal">BackgroundFetchCompletionOperation</code>. Add the following implementation:</p><pre class="programlisting">import Foundation
import UIKit

class BackgroundFetchCompletionOperation: Operation {
  override var isAsynchronous: Bool { return true }
  override var isExecuting: Bool { return _isExecuting }
  override var isFinished: Bool { return _isFinished }
  var _isExecuting = false
  var _isFinished = false

  let completionHandler: (UIBackgroundFetchResult) -&gt; Void

  init(completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {
    self.completionHandler = completionHandler

  }

  override func start() {
    super.start()
    willChangeValue(forKey: #keyPath(isExecuting))
    _isExecuting = true
    didChangeValue(forKey: #keyPath(isExecuting))

    var didLoadNewData = false

    for operation in dependencies {
      guard let updateOperation = operation as? UpdateMovieOperation else { continue }

      if updateOperation.didLoadNewData {
        didLoadNewData = true
        break
      }
    }

    if didLoadNewData {
      completionHandler(.newData)
    } else {
      completionHandler(.noData)
    }

    willChangeValue(forKey: #keyPath(isFinished))
    _isFinished = true
    didChangeValue(forKey: #keyPath(isFinished)) }
}</pre><p>The implementation for this operation is pretty similar to the movie update operation. The operation should be initialized with the completion handler that was passed to the background fetch method in <code class="literal">AppDelegate</code>, and it's called after figuring out whether new data was fetched by looping through all movie <span>update</span><a id="id325607091" class="indexterm"></a> operations. Let's see how all this comes together by updating the background fetch logic in <code class="literal">AppDelegate</code>. Add the following code to the <code class="literal">application(_:performFetchWithCompletionHandler:)</code> method, right after fetching the movies:</p><pre class="programlisting">let completionOperation = BackgroundFetchCompletionOperation(completionHandler: completionHandler)

for movie in allMovies {
  let updateOperation = UpdateMovieOperation(movie: movie)
  completionOperation.addDependency(updateOperation)

  queue.addOperation(updateOperation)</pre><pre class="programlisting">}

queue.addOperation(completionOperation)</pre><p>This code is a lot more readable than what was there before. First, the completion operation is created. Next, an update operation is created for each movie, this operation is added as a dependency for the completion operation, and it's added to the operation queue. Once all dependencies are set up, the completion operation itself is added to the queue as well. All of the movie update operations will automatically start executing simultaneously, and once they're all done, the completion operation becomes ready to execute. Once this happens, the completion operation will run and the background fetch completion handler will be called.</p><p>Even though <code class="literal">Operations</code> involve a bit more boilerplate code regarding managing execution state, you do end up with code that is a lot easier to read and understand. This chapter only covered setting up dependencies for operation, but if you study <span class="emphasis"><em>Apple's Advanced NSOperations</em></span> video that was mentioned earlier, you'll find that you can do powerful, complex, and amazing things with operations.</p></div></div>