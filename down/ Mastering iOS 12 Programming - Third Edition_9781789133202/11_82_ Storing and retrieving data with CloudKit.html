<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec80"></a>Storing and retrieving data with CloudKit</h2></div></div><hr /></div><p>CloudKit is meant to be used as a backend for your app that syncs across devices and provides a seamless experience for users. This section will go over the principles that you should keep in mind when implementing <span>CloudKit</span><a id="id325333110" class="indexterm"></a> in your app. By the end of this section, you will know precisely how storing, retrieving, and updating data in <span>CloudKit</span><a id="id325333128" class="indexterm"></a> works. You will then go on to implement CloudKit in the <span class="strong"><strong>MustC</strong></span> app by combining it with the existing Core Data database.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec60"></a>Communicating with CloudKit for the first time</h3></div></div></div><p>When your app launches for the very first time, it should immediately make itself known to <span>CloudKit</span><a id="id325333147" class="indexterm"></a> so it can subscribe to changes. Technically you don't have to do this because you can implement your own logic to retrieve data from CloudKit as you need it. However, an efficient CloudKit implementation will work flawlessly when there is no internet connection, which means that it's probably a good idea to store all data locally by writing it to a database such as Core Data.</p><p>The recommended way to subscribe to database changes is to keep track of whether your app is already subscribed locally. You can keep track of this by storing a variable in the local <code class="literal">UserDefaults</code> store. <code class="literal">UserDefaults</code> is perfect for storing variables such as this. Open <code class="literal">CloudStore.swift</code> in the <span class="strong"><strong>MustC</strong></span> project and add the following computed property to it:</p><pre class="programlisting">var isSubscribedToDatabase: Bool {
  get { return UserDefaults.standard.bool(forKey: "CloudStore.isSubscribedToDatabase") }
  set { UserDefaults.standard.set(newValue, forKey: "CloudStore.isSubscribedToDatabase") }
}</pre><p>This property proxies the standard <code class="literal">UserDefaults</code> through its custom getters and setters. A construction such as this is very convenient since it makes using this property simple and straightforward even though there's a bit more logic going on behind the scenes.</p><p>With <span>the <code class="literal">isSubscribedToDatabase</code></span> property in place, you should also implement a method that's responsible for subscribing the app to changes in the <span>CloudKit</span><a id="id325571682" class="indexterm"></a> database. Add the following implementation to <code class="literal">CloudStore.swift</code>:</p><pre class="programlisting">extension CloudStore {
  func subscribeToChangesIfNeeded(_ completion: @escaping (Error?) -&gt; Void) {
    // 1
    guard isSubscribedToDatabase == false else {
      completion(nil)
      return
    }

    // 2
    let notificationInfo = CKSubscription.NotificationInfo()
    notificationInfo.shouldSendContentAvailable = true

    // 3
    let subscription = CKDatabaseSubscription(subscriptionID: "private-changes")
    subscription.notificationInfo = notificationInfo

    // 4
    let operation = CKModifySubscriptionsOperation(subscriptionsToSave: [subscription], subscriptionIDsToDelete: [])

    // 5
    operation.modifySubscriptionsCompletionBlock = { [unowned self] subscriptions, subscriptionIDs, error in
      if error == nil {
        self.isSubscribedToDatabase = true
      }

      completion(error)
    }

    // 6
    privateDatabase.add(operation)
  }
}</pre><p>Let's go over the <span>preceding code step by step</span>, so you understand what happens in this snippet:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>If the application has already subscribed to changes, there is no need to subscribe again. This means that you can call the completion closure without any errors.</li><li>When there are changes in the database, CloudKit will send a silent push notification to the app. Silent push notifications can be used to let the app know that new data is available. This mechanism is very similar to background fetch, which is covered in <code class="literal">Chapter 10</code>, <span class="emphasis"><em>Being Proactive with Background Fetch</em></span>.</li><li>Every subscription in <span>CloudKit</span><a id="id325580584" class="indexterm"></a> is created as an instance of <code class="literal">CKDatabaseSubscription</code>. The notification settings that were configured in step two are attached to the database subscription.</li><li>This step creates an instance of <code class="literal">CKModifySubscriptionsOperation</code>. CloudKit uses a concept called <code class="literal">Operations</code> to manage the operations that you want the database to execute. Subscribing to changes is an example of such an operation, but fetching changes from the database or sending data to the database are also examples of operations. You can read more about <code class="literal">Operations</code> in <code class="literal">Chapter 25</code>, <span class="emphasis"><em>Offloading Tasks with Operations and GCD</em></span>.</li><li>This step defines a closure that is called when the operation to subscribe to changes has finished. If this operation completes without error, the app is subscribed to changes and the status is persisted to <code class="literal">UserDefaults</code>. Every CloudKit operation has one or more of these closure callbacks that you can implement to respond to certain events that can occur during an operation.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>The last step is to add the operation to the private database. Since all data will be stored in the private <code class="literal">moviesZone</code> that you created <span>earlier</span>, the appropriate database to use for the subscription is the private database.</li></ol></div><p>Your app is now subscribed to changes from the CloudKit database. The next step is to make sure your app receives and handles updates from the CloudKit server.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec61"></a>Listening for changes in the database</h3></div></div></div><p>When new data is available on the <span>CloudKit</span><a id="id325604083" class="indexterm"></a> server, it sends a notification to all subscribed apps. A great way to handle these notifications is to add a method to <code class="literal">CloudStore</code> that should be called when there are new changes in the CloudKit database. Add the following extension to <code class="literal">CloudStore.swift</code>:</p><pre class="programlisting">extension CloudStore {
  func handleNotification(_ dict: [String: AnyObject], completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {
    let notification = CKNotification(fromRemoteNotificationDictionary: dict)

    if notification.subscriptionID == "private-changes" {
      fetchDatabaseChanges { error in
        if error == nil {
          completionHandler(.newData)
        } else {
          completionHandler(.failed)
        }
      }
    }
  }
}</pre><p>This method takes a dictionary and a completion-handler as its arguments. Note that the completion-handler has one argument, which is <code class="literal">UIBackgroundFetchResult</code>. As mentioned before, CloudKit sends a silent push notification when data has changed to trigger a process that's very similar to background fetch.</p><p>The previous method uses the notification dictionary to create a <code class="literal">CKNotification</code> instance and then checks whether the notification originated through the subscription for the private database. If this is the case, the changes should be fetched and ultimately get persisted to the local database.</p><p>When you subscribe to database changes, CloudKit will notify your app when any data in the database changes. When you fetch database changes, CloudKit will not tell you what records have changed straight away. Instead, CloudKit will send you the database zones that have changed. A flexible CloudKit setup should be able to handle incoming data from different zones, which means that you might add a new zone to your database and the app should be able to handle this.</p><p>If your app receives a notification to inform it of new changes, CloudKit won't provide any additional information. Instead, it is your job to ask CloudKit for the relevant changes. Remember that you were able to request only data that has changed since a specific moment in the CloudKit dashboard? The same mechanism is used when you fetch changes for your app.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec62"></a>Retrieving changes from CloudKit</h3></div></div></div><p>To fetch changes that occurred after a certain point in time, you need to a change token along with your fetch operations. Add the following computed property to the <code class="literal">CloudStore</code> class so you can keep track of the <span>change</span><a id="id325605898" class="indexterm"></a> token that represents the last time the app fetched changes from <code class="literal">CloudKit</code>:</p><pre class="programlisting">var privateDatabaseChangeToken: CKServerChangeToken? {
  get { return UserDefaults.standard.serverChangeToken(forKey: "CloudStore.privateDatabaseChangeToken") }
  set { UserDefaults.standard.set(newValue, forKey: "CloudStore.privateDatabaseChangeToken") }
}</pre><p>This computed property uses a helper method on <code class="literal">UserDefaults</code> to store <code class="literal">CKServerChangeToken</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip34"></a>Note</h3><p>If you're curious to see how the computed property is implemented, make sure to look at the <code class="literal">UserDefaults.swift</code> file in the project from the code bundle.</p></div><p>Add the following code to <code class="literal">CloudStore.swift</code> to implement the logic to fetch database changes:</p><pre class="programlisting">extension CloudStore {
  func fetchDatabaseChanges(_ completionHandler: @escaping (Error?) -&gt; Void) {
    // 1
    let operation = CKFetchDatabaseChangesOperation(previousServerChangeToken: privateDatabaseChangeToken)

    // 2
    var zoneIds = [CKRecordZone.ID]()
    operation.recordZoneWithIDChangedBlock = { zoneId in
      zoneIds.append(zoneId)
    }

    // 3
    operation.changeTokenUpdatedBlock = { [weak self] changeToken in
      self?.privateDatabaseChangeToken = changeToken
    }

    // 4
    operation.fetchDatabaseChangesCompletionBlock = { [weak self] changeToken, success, error in
      self?.privateDatabaseChangeToken = changeToken

      if zoneIds.count &gt; 0 &amp;&amp; error == nil {
        self?.fetchZoneChangesInZones(zoneIds, completionHandler)
      } else {
        completionHandler(error)
      }
    }

    privateDatabase.add(operation)
  }
}</pre><p>The previous method retrieves only the record changes from the CloudKit database in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><code class="literal">CKFetchDatabaseChangesOperation</code> is created. This operation will retrieve changes in the database zones. The latest change token is passed to this operation to make sure it only returns data that has changed since the last successful fetch.</li><li>The fetch operation will not return all changes zones at once. Instead, every changed zone is provided one by one, so they should be stored in an array for easy access at a later time.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>At certain times in the refresh cycle, the operation will receive a <span>change</span><a id="id325606089" class="indexterm"></a> token from CloudKit. A single fetch operation might result in more than one change token. This could occur if there are many changes to be fetched from the server. In that case, the server will return the changed data in batches, allowing you to process the changes as they come in. It's essential that you store the latest token you have received from the server.</li><li>Provide a closure to the operation that should be executed when the fetch operation completes. This method also receives a change token, so you should store this token locally since that token represents the completed fetch operation. If no errors occurred and at least one database zone has changed, a new method is called. This method is responsible for fetching all changes to the database records, and you will implement it next.</li></ol></div><p>Once the server has informed the app about all of the changed zones in the database, the app should then ask CloudKit for the relevant record changes. A single operation can retrieve data across multiple zones so your app won't have to issue many requests to CloudKit if there are several zones that have changes. Add the following extension to <code class="literal">CloudStore.swift</code>:</p><pre class="programlisting">extension CloudStore {
  func fetchZoneChangesInZones(_ zones: [CKRecordZone.ID], _ completionHandler: @escaping (Error?) -&gt; Void) {
    // 1
    var fetchConfigurations = [CKRecordZone.ID: CKFetchRecordZoneChangesOperation.ZoneConfiguration]()

    for zone in zones {
      if let changeToken = UserDefaults.standard.zoneChangeToken(forZone: zone) {
        let configuration = CKFetchRecordZoneChangesOperation.ZoneConfiguration(previousServerChangeToken: changeToken, resultsLimit: nil, desiredKeys: nil)
        fetchConfigurations[zone] = configuration
      }
    }

    let operation = CKFetchRecordZoneChangesOperation(recordZoneIDs: zones, configurationsByRecordZoneID: fetchConfigurations)

    // 2
    var changedMovies = [CKRecord]()
    var changedFamilyMembers = [CKRecord]()
    operation.recordChangedBlock = { record in
      if record.recordType == "Movie" {
        changedMovies.append(record)
      } else if record.recordType == "FamilyMember" {
        changedFamilyMembers.append(record)
      }
    }

    operation.fetchRecordZoneChangesCompletionBlock = { [weak self] error in
      for record in changedMovies {
        print(record["title"])
      }

      for record in changedFamilyMembers {
        print(record["name"])
      }

      completionHandler(error)
    }

    // 3
    operation.recordZoneFetchCompletionBlock = { recordZone, changeToken, data, moreComing, error in
      UserDefaults.standard.set(changeToken, forZone: recordZone)
    }

    privateDatabase.add(operation)
  }
}</pre><p>The preceding method is quite long but it follows a flow that is similar to the other two. Let's walk through this code step by step again:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>When you fetch changes for record zones, each zone will have its own change token. This step uses another helper that was added to <code class="literal">UserDefaults</code> to conveniently store change tokens for each individual zone. The zones and their change tokens should be provided to <code class="literal">CKFetchRecordZoneChangesOperation</code> through a configuration dictionary. The operation itself is initialized with the dictionary and a list of zones that have changed.</li><li>The operation executes a callback for every changed record that it receives from the server. To make processing at a later time easier, the records for family members and movies are stored in their own lists. Note that both movies and family members are sent to the app as <code class="literal">CKRecord</code> instances. <code class="literal">CKRecord</code> has several specific CloudKit properties and methods, but otherwise, it behaves a lot like a dictionary. You will learn more about <code class="literal">CKRecord</code> instances later when you store your objects in Core Data.</li><li><code class="literal">CKFetchRecordZoneChangesOperation</code> will call a closure for every zone that it processes. This callback receives a lot of arguments, such as the database zone that the closure was called for, the corresponding change token, and whether more data is coming in. The most interesting cases are the database zone and the change token. These two properties are used to store the latest <span>change</span><a id="id325607233" class="indexterm"></a> token for the corresponding zone in <code class="literal">UserDefaults</code>.</li></ol></div><p>At this point, the <code class="literal">CloudStore</code> object contains all of the logic required to subscribe to database changes, retrieve them, and then print the objects that were fetched. To use <code class="literal">CloudStore</code>, you will need to update some code in <code class="literal">AppDelegate</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec63"></a>Configuring your AppDelegate</h3></div></div></div><p>As mentioned, silent push notifications work very similar to the way background fetch works. Just like background fetch, there is a special <code class="literal">AppDelegate</code> method that is called when a silent push notification arrives. You need to implement this method so you can handle the incoming notifications and fetch the <span>change</span><a id="id325609929" class="indexterm"></a> data from CloudKit. Add the following method to <code class="literal">AppDelegate</code>:</p><pre class="programlisting">func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {

  guard let dict = userInfo as? [String: NSObject] else {
    completionHandler(.failed)
    return
  }

  cloudStore.handleNotification(dict) { result in
    completionHandler(result)
  }
}</pre><p>This method is called by iOS when your app receives a silent push notification from CloudKit. This message doesn't do much apart from telling <code class="literal">CloudStore</code> to process the notification and then it calls <code class="literal">completionHandler</code> to inform <span>iOS</span> about the result of the fetch. As you can see, this is very similar to background fetch apart from the fact that this method is called when the CloudKit server sends a push message to the app instead of when iOS decides to do so.</p><p>Lastly, add the following code at the end of <code class="literal">application(_:didFinishLaunchingWithOptions:)</code>:</p><pre class="programlisting">cloudStore.subscribeToChangesIfNeeded { [weak self] error in
  DispatchQueue.main.async {
    application.registerForRemoteNotifications()
  }

  if error == nil {
    self?.cloudStore.fetchDatabaseChanges { fetchError in
      if let error = fetchError {
        print(error)
      }
    }
  }
}</pre><p>The preceding code takes care of telling <code class="literal">CloudStore</code> to subscribe to changes. It also registers the app for remote notifications so CloudKit can send silent push messages to the app. Note that this type of push messaging does not require you to explicitly ask the user to send them push notifications. This type of permission is only required if you want to send the user visual push notifications. You can read more about push notifications in <code class="literal">Chapter 20</code>, <span class="emphasis"><em>Implementing Rich Push Notifications</em></span>.</p><p>At this point, you can add a couple of records to your <span>CloudKit</span><a id="id325612674" class="indexterm"></a> database. Since you haven't implemented sending data to CloudKit yet, this is the best way for you to verify that your code works as expected. You should see the names of the movies and family members you have added in the CloudKit dashboard printed to the console. Once you have the app running, try adding a new family member while the app is open. You should see the name of the new family member appear in the console right after you add the record to the CloudKit dashboard. Pretty neat, right?</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note35"></a>Note</h3><p>To use the private database in CloudKit, a user that is logged in to CloudKit on their device is required. Make sure to run your app on a physical device that has a logged-in iCloud user (preferably the same account you use as your Apple developer account) or log an iCloud user in on the simulator by navigating to the Settings app on the simulator.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec64"></a>Storing data in CloudKit</h3></div></div></div><p>To store objects in CloudKit, you use <code class="literal">CKModifyRecordsOperation</code>. This operation takes a list of records that should be created, updated, or removed. Every record is connected to a certain zone, should have a unique identifier, and can have different properties associated with it. If you add a property to an object that doesn't exist in <span>CloudKit</span><a id="id325580641" class="indexterm"></a> yet, CloudKit will automatically update the data model on the server using the data you sent. You can even create entirely new models this way. You can add the following code to <code class="literal">CloudStore.swift</code> to store a very basic version of a family member's record:</p><pre class="programlisting">extension CloudStore {
  func storeFamilyMember(_ familyMember: FamilyMember, _ completionHandler: @escaping (Error?) -&gt; Void) {
    let defaultZoneId = CKRecordZone.ID(zoneName: "moviesZone", ownerName: CKCurrentUserDefaultName)
    let recordId = CKRecord.ID(recordName: UUID().uuidString, zoneID: defaultZoneId)
    let record = CKRecord(recordType: "FamilyMember", recordID: recordId)
    record["name"] = familyMember.name!

    let operation = CKModifyRecordsOperation(recordsToSave: [record], recordIDsToDelete: [])
    operation.modifyRecordsCompletionBlock = { records, recordIds, error in
      guard let records = records, error == nil else {
        completionHandler(error)
        return
      }

      print(records)
    }

    privateDatabase.add(operation)
  }
}</pre><p>The preceding code creates a zone ID and a record ID that will be used to identify the record in the database. Next, a family member record is created and the family member name is added to it. Lastly, <code class="literal">CKModifyRecordsOperation</code> is created and added to the database to send the record to CloudKit. To call this method when a new family member is added, update the <code class="literal">saveFamilyMember(withName:)</code> method in <code class="literal">FamilyMembersViewController</code> as follows:</p><pre class="programlisting">func saveFamilyMember(withName name: String) {
  let moc = persistentContainer.viewContext

  moc.persist {
    let familyMember = FamilyMember(context: moc)
    familyMember.name = name
    familyMember.uuidString = UUID().uuidString

    self.cloudStore.storeFamilyMember(familyMember) { _ in
      // no action
    }
  }
}</pre><p>This snippet passes the family member to the cloud store so it can convert it to <code class="literal">CKRecord</code> and store it in CloudKit. Try adding a new family member in the app, you should see your newly-inserted record in the console in Xcode; when you refresh the list of family members in the <span>CloudKit</span><a id="id325580678" class="indexterm"></a> dashboard, a new entry should have appeared.</p><p>This implementation of adding a family member to CloudKit is too basic because there is no way to associate one of the local family members to the family members stored in CloudKit. The next section will implement a proper local cache of the data in CloudKit by adapting the existing Core Data model a little bit so you can import data from the CloudKit server, send new family members and movies to CloudKit, and update existing family members when they add new movies to their favorites.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip36"></a>Note</h3><p>Since your app stores database change tokens in <code class="literal">UserDefaults</code>, you should delete <span class="strong"><strong>MustC</strong></span> from your device to remove the existing change tokens. This allows you to start fresh and receive all data again.</p></div></div></div>