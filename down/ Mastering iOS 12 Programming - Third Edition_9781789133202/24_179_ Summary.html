<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch24lvl1sec164"></a>Summary</h2></div></div><hr /></div><p>You learned a lot about measuring your app's performance in this chapter. You also learned how to find common issues and how to use Instruments to figure out what's going on behind the scenes for your app. In your day-to-day development cycle, you won't use Instruments or Xcode's memory debugger very often. However, familiarizing yourself with these tools can save you hours of debugging. It can even help you to discover memory leaks or slow code before you ship your app.</p><p>Â </p><p>Try to audit and measure several aspects of your app while you're developing it, and you can see how the performance of certain aspects of your app improves or degrades over time. This will help you to avoid shipping an app that's full of slow code or memory leaks. However, don't go overboard with optimizing until you encounter actual problems in your app. Prematurely optimizing your code often leads to code that is hard to maintain. The fixes you applied in this chapter are pretty simple; there were a few small bugs that could be fixed in just a few lines of code.</p><p>In addition to learning about existing instruments, you learned how to implement signposts in your app to measure your app's performance. You even learned how to create a custom instrument to visualize your signpost calls with.</p><p>Unfortunately, fixing issues in your app isn't always this easy. Sometimes, your code is as fast as it can be, yet it still takes too long and it makes scrolling your tables or collections choppy.</p><p>The next chapter will show you how to handle such cases by implementing asynchronous programming using operations and GCD.</p></div>