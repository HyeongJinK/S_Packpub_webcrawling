<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch20lvl1sec136"></a>Implementing a basic drag and drop functionality</h2></div></div><hr /></div><p>The previous section explained how <span>drag</span><a id="id325333110" class="indexterm"></a> and drop works from a theoretical point of view. This section focuses on implementing drag and drop in a sample app. First, you will learn how a simple, regular implementation of drag and drop might work. Next, you'll see how Apple has implemented drag and drop for <code class="literal">UICollectionView</code> and <code class="literal">UITableView</code>. These two components have received special treatment for drag and drop, making it even easier to implement drag and drop in apps that use these components.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch20lvl2sec108"></a>Adding drag and drop to a plain UIView</h3></div></div></div><p>Before you implement <span>drag</span><a id="id325333146" class="indexterm"></a> and drop in the <span>Augmented</span><a id="id325333155" class="indexterm"></a> Reality gallery, let's see how you can implement a simple version of drag and drop with a simple view and an image. In the code bundle for this chapter, you'll find a sample project named <strong class="userinput"><code>PlainDragDrop</code></strong>. Open the starting version for this project and run it on an iPad simulator. You should see the user interface shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/19488ff9-b887-49bb-a367-541ea8e19c82.png" /></div><p>The goal of this example is to allow users to perform the following actions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Drag the image to the drop area.</li><li style="list-style-type: disc">Drag an external image to the drop area.</li><li style="list-style-type: disc">Drag the bottom image to an external app.</li></ul></div><p>While this might sound like you are going to have to do a lot of work, it's quite simple to implement all three features at once. Simply implementing the first feature enables the other two! Quite convenient, right? You are going to implement drag and drop for this example in just three simple steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Make <code class="literal">ViewController</code> conform to <code class="literal">UIDragInteractionDelegate</code>.</li><li>Make <code class="literal">ViewController</code> conform to <code class="literal">UIDropInteractionDelegate</code>.</li><li>Add interactions to the image and drop area.</li></ol></div><p>If you feel confident that the theoretical explanation from the previous section left you with enough knowledge to implement these steps on your own, that's great! You should give implementing this on your own a go and then refer back to the following code snippets if you get stuck or to check the work you've done. If you prefer to follow along instead, that's great too.</p><p>The first step to enable <span>drag</span><a id="id325575098" class="indexterm"></a> and drop in the <span>sample</span><a id="id325578350" class="indexterm"></a> app is to make <code class="literal">DragDropViewController</code> conform to <code class="literal">UIDragInteractionDelegate</code>. To do this, you only have to implement a single method. As shown in the explanation about the drag and drop experience, the only required method on <code class="literal">UIDragInteractionDelegate</code> is <code class="literal">dragInteraction(_:itemsForBeginning:)</code>. This method requires you to provide a <code class="literal">UIDragItem</code> for the drag session. Since this example will not support dragging multiple items from the app, there is no need to implement other delegate methods.</p><p>Add the following extension to <code class="literal">DragDropViewController.swift</code> to implement <code class="literal">UIDragInteractionDelegate</code>:</p><pre class="programlisting">extension DragDropViewController: UIDragInteractionDelegate {
  func dragInteraction(_ interaction: UIDragInteraction, itemsForBeginning session: UIDragSession) -&gt; [UIDragItem] {
    guard let image = imageView.image
      else { return [] }

    let itemProvider = NSItemProvider(object: image)
    return [UIDragItem(itemProvider: itemProvider)]
  }
}</pre><p>The preceding code should look familiar to you since it closely resembles the example code from the previous section. Now that <code class="literal">DragDropViewConroller</code> conforms to <code class="literal">UIDragInteractionDelegate</code>, let's make it conform to <code class="literal">UIDropInteractionDelegate</code> as well. Add the following extension to <code class="literal">DragDropViewController.swift</code>:</p><pre class="programlisting">extension DragDropViewController: UIDropInteractionDelegate {
  func dropInteraction(_ interaction: UIDropInteraction, sessionDidUpdate session: UIDropSession) -&gt; UIDropProposal {
    return UIDropProposal(operation: .copy)
  }

  func dropInteraction(_ interaction: UIDropInteraction, performDrop session: UIDropSession) {
    guard let itemProvider = session.items.first?.itemProvider,
      itemProvider.canLoadObject(ofClass: UIImage.self)
      else { return }

    itemProvider.loadObject(ofClass: UIImage.self) { [weak self] loadedItem, error in
      guard let image = loadedItem as? UIImage
        else { return }

      DispatchQueue.main.async {
        self?.dropArea.image = image
      }
    }
  }
}</pre><p>Again, this implementation should look familiar to you. The first method, <code class="literal">dropInteraction(_:sessionDidUpdate:)</code>, returns a copy proposal since we don't want to move data around. The second method is <code class="literal">dropInteraction(_:performDrop:)</code>. This method retrieves the image from <code class="literal">itemProvider</code> that has been created in <code class="literal">UIDragInteractionDelegate</code> and sets the loaded image as the image for <code class="literal">dropArea</code>.</p><p>The next step is to add the drag and drop interaction objects to the correct views, as follows:</p><pre class="programlisting">override func viewDidLoad() {
  super.viewDidLoad()

  let dragInteraction = UIDragInteraction(delegate: self)
  imageView.addInteraction(dragInteraction)

  let dropInteraction = UIDropInteraction(delegate: self)
  dropArea.addInteraction(dropInteraction)
}</pre><p>Now that all interactions are set up, go ahead and run the app on an iPad. You'll be able to drag the bottom image to the top section, and the image will appear in the top area. If you run the Photos app alongside <strong class="userinput"><code>PlainDragDrop</code></strong>, you can drag the bottom image to the photos app, and it will be added to photos. If you drag an image from the Photos app to the top section, the image from Photos will be set as the image for the drop area. Pretty cool stuff! And it was pretty simple to cover all these cases.</p><p>Even though the iPhone <span>does</span><a id="id325604098" class="indexterm"></a> not have full drag and drop support, you can still allow a user to drag the image from the top area to the bottom area. Since the iPhone <span>does</span><a id="id325604106" class="indexterm"></a> not support a full drag and drop experience, all drag and drop interaction objects you create are disabled by default. If you want to allow users to use drag and drop in your iPhone app, you must explicitly enable the interaction objects you would like to support. Add the following code to <code class="literal">viewDidLoad</code> in <code class="literal">DragDropViewController</code> to enable the drag interaction in the <strong class="userinput"><code>PlainDragDrop</code></strong> app:</p><pre class="programlisting">dragInteraction.isEnabled = true</pre><p>Go ahead and test the app on an iPhone; you should be able to drag the top image around. Now that you know how to enable drag and drop for a plain view, let's see how you can add it to a collection view.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch20lvl2sec109"></a>Adding drag and drop to a UICollectionView</h3></div></div></div><p>A lot of iOS apps make <span>extensive</span><a id="id325606035" class="indexterm"></a> use of collections and tables. Therefore, it <span>makes</span><a id="id325606043" class="indexterm"></a> a lot of sense that, whenever Apple introduces a huge feature such as drag and drop, they take a step back and evaluate how the feature should work for collections or tables. Luckily, drag and drop was no exception and Apple truly put some thought into making drag and drop work great.</p><p>In this section, you'll implement drag and drop for the collection of images that is at the bottom of the screen for the <strong class="userinput"><code>ARGallery</code></strong> app you created in <a class="link" href="#" linkend="ch12">Chapter 12</a>, <span class="emphasis"><em>Using Augmented Reality</em></span>. You will implement the following features that use drag and drop for <code class="literal">UICollectionView</code>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Dragging photos from the collection into the AR viewport.</li><li style="list-style-type: disc">Reordering items in the collection view.</li><li style="list-style-type: disc">Adding items from external sources to the collection view.</li></ul></div><p>As a bonus, you will make sure that the first two features also work on an iPhone since these features are only used inside the app so they can be used on iPhone. Since Apple has tailored drag and drop to work perfectly with <code class="literal">UICollectionView</code>, the basic concepts for drag and drop still apply; you only have to use slightly different protocols. For instance, instead of implementing <code class="literal">UIDragInteractionDelegate</code>, you implement <code class="literal">UICollectionViewDragDelegate</code>.</p><p>The first feature, dragging photos from the collection of images to the AR Gallery, is implemented similarly to the drag and drop experience you implemented before. You will implement the relevant protocols first, and then you will implement the interactions. The code bundle for this chapter contains a slightly modified version of the <span class="strong"><strong>ARGallery</strong></span> that you built before. The modifications allow you to focus on implementing drag and drop instead of having to make minor adjustments to the existing code.</p><p>Since you should be familiar with the dropping implementation already, add the following extension to <code class="literal">ViewController.swift</code> in <code class="literal">AugmentedRealityGallery</code>:</p><pre class="programlisting">extension ViewController: UIDropInteractionDelegate {
  func dropInteraction(_ interaction: UIDropInteraction, sessionDidUpdate session: UIDropSession) -&gt; UIDropProposal {
    return UIDropProposal(operation: .copy)
  }

  func dropInteraction(_ interaction: UIDropInteraction, performDrop session: UIDropSession) {
    guard let itemProvider = session.items.first?.itemProvider,
      itemProvider.canLoadObject(ofClass: UIImage.self)
      else { return }

    itemProvider.loadObject(ofClass: UIImage.self) { [weak self] item ,error in
      guard let image = item as? UIImage
        else { return }

      DispatchQueue.main.async {
        self?.addImageToGallery(image)
      }
    }
  }
}</pre><p>Nothing crazy <span>happens</span><a id="id325607102" class="indexterm"></a> in this snippet. In fact, it's so similar to the code you <span>have</span><a id="id325607111" class="indexterm"></a> seen already that you should be able to understand what happens in this snippet on your own. The next step is to implement the <code class="literal">UICollectionViewDragDelegate</code> protocol. Add the following extension to <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">extension ViewController: UICollectionViewDragDelegate {
  func collectionView(_ collectionView: UICollectionView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -&gt; [UIDragItem] {
    let image = UIImage(named: images[indexPath.row])!
    let itemProvider = NSItemProvider(object: image)

    return [UIDragItem(itemProvider: itemProvider)]
  }
}</pre><p>The preceding implementation serves the same purpose as <code class="literal">UIDragInteractionDelegate</code>. The main difference is that you have access to the <code class="literal">IndexPath</code> of the item that was selected for dragging. You can use <code class="literal">IndexPath</code> to obtain the dragged image and create a <code class="literal">UIDragItem</code> for it. Let's set up the interaction objects for this part of the app now. Add the following lines of code to <code class="literal">viewDidLoad()</code>:</p><pre class="programlisting">collectionView.dragDelegate = self
collectionView.dragInteractionEnabled = true

let dropInteraction = UIDropInteraction(delegate: self)
arKitScene.addInteraction(dropInteraction)</pre><p>If you build and run the app now, you can drag photos into the AR gallery from the collection view at the bottom. If you run the app on an iPad, you are even able to drag images from external apps into the AR Gallery! This is quite awesome, but you're not done yet. Let's allow users to drag items from external apps into the collection, so they have easy access to it. And while we're at it, let's implement the reordering of the collection using drag and drop as well.</p><p>To implement the reordering of items in the collection view and to allow users to add external images to their collection, you must implement <code class="literal">UICollectionViewDropDelegate</code>. As you will see soon, it is possible to distinguish between a drop session that originated from within the app or outside the app. This information can be used to determine whether the user wants to reorder the collection or add an item to it. Add the following extension for <code class="literal">ViewController</code>:</p><pre class="programlisting">extension ViewController: UICollectionViewDropDelegate {
  func collectionView(_ collectionView: UICollectionView, dropSessionDidUpdate session: UIDropSession, withDestinationIndexPath destinationIndexPath: IndexPath?) -&gt; UICollectionViewDropProposal {

    if session.localDragSession != nil {
      return UICollectionViewDropProposal(operation: .move, intent: .insertAtDestinationIndexPath)
    }

    return UICollectionViewDropProposal(operation: .copy, intent: .insertAtDestinationIndexPath)
  }
}</pre><p>The preceding <span>snippet</span><a id="id325580978" class="indexterm"></a> implements <code class="literal">collectionView(_:dropSessionDidUpdate:withDestinationIndexPath:)</code>. This delegate method is pretty similar to <code class="literal">dropInteraction(_:sessionDidUpdate:)</code> except you also <span>have</span><a id="id325580993" class="indexterm"></a> access to the destination index path that the user is currently hovering their finger over. By checking whether there is a <code class="literal">localDragSession</code> on a <code class="literal">UIDropSession</code>, you can detect whether the user wants to reorder the collection or whether they are adding an item from an external source. By specifying an intent on the drop proposal, <code class="literal">CollectionView</code> knows how it should update its interface to visualize the action that is taken when the user performs the drop. Speaking of performing drops, add the following code to the <code class="literal">UICollectionViewDropDelegate</code> extension you just added:</p><pre class="programlisting">unc collectionView(_ collectionView: UICollectionView, performDropWith coordinator: UICollectionViewDropCoordinator) {
  switch coordinator.proposal.operation {
  case .copy:
    performCopy(forCollectionView: collectionView, with: coordinator)
  case .move:
    performMove(forCollectionView: collectionView, with: coordinator)
  default:
    return
  }
}</pre><p>This method is relatively simple. Depending on the proposal that is used, a different method is called. You will add the copy and move methods soon, but first, let's talk a little bit about <code class="literal">UICollectionViewDropCoordinator</code>. <code class="literal">UICollectionViewDropCoordinator</code> contains information about the items that are being dragged, the animations that should be performed, the drop proposal, and of course the drop session. When performing a drop, you make use of the coordinator to request the drag items, but also to make sure the collection view properly updates its view.</p><p>The first method you will implement is <code class="literal">performMove(forCollectionView:with:)</code> since it's the simpler of the two remaining methods to implement. Add the following snippet to the <code class="literal">UICollectionViewDropDelegate</code> extension:</p><pre class="programlisting">func performMove(forCollectionView collectionView: UICollectionView, with coordinator: UICollectionViewDropCoordinator) {
  let destinationIndexPath = coordinator.destinationIndexPath ?? IndexPath(item: 0, section: 0)

  guard let item = coordinator.items.first,
    let sourceIndexPath = item.sourceIndexPath
    else { return }

  let image = images.remove(at: sourceIndexPath.row)
  images.insert(image, at: destinationIndexPath.row)

  collectionView.performBatchUpdates({
    collectionView.deleteItems(at: [sourceIndexPath])
    collectionView.insertItems(at: [destinationIndexPath])
  })

  coordinator.drop(item.dragItem, toItemAt: destinationIndexPath)
}</pre><p>The preceding <span>snippet</span><a id="id325581044" class="indexterm"></a> uses the coordinator to retrieve the first item in the drag session. The app doesn't support dragging multiple items at once, so this is alright. Next, the item's source index path is used to remove the image that should be moved from the array of images. The destination index path is then used to add the image back into the array of images at its new location. This is done to make sure the data source is updated before updating the collection view. After the collection view is updated, <code class="literal">drop(_:toItemAt:)</code> is called on the <span>coordinator</span><a id="id325581056" class="indexterm"></a> to animate the drop action.</p><p>The final method you need to implement is <code class="literal">performCopy(forCollectionView:with:)</code>. Add the following code to the <code class="literal">UICollectionViewDropDelegate</code> extension:</p><pre class="programlisting">func performCopy(forCollectionView collectionView: UICollectionView, with coordinator: UICollectionViewDropCoordinator) {
  let destinationIndexPath = coordinator.destinationIndexPath ?? IndexPath(item: 0, section: 0)

  for item in coordinator.items {
      let dragItem = item.dragItem
      guard dragItem.itemProvider.canLoadObject(ofClass: UIImage.self) else { continue }

      let placeholder = UICollectionViewDropPlaceholder(insertionIndexPath: destinationIndexPath, reuseIdentifier: "GalleryCollectionItem")
      let placeholderContext = coordinator.drop(dragItem, to: placeholder)

      dragItem.itemProvider.loadObject(ofClass: UIImage.self) { [weak self] item, error in
          DispatchQueue.main.async {
              guard let image = item as? UIImage else {
                  placeholderContext.deletePlaceholder()
                  return
              }

              placeholderContext.commitInsertion { indexPath in
                  self?.images.insert(image, at: indexPath.row)
              }
          }
      }
  }
}</pre><p>Take a close look at <code class="literal">UICollectionViewDropPlaceholder</code> in this snippet. This class was introduced in iOS 11, and it is used to add temporary items to <code class="literal">CollectionView</code>. Because it might take a little while to load data from an item provider, you need a mechanism to update the UI while you're loading data. This is the goal of using a placeholder. When you call <code class="literal">drop(_:to:)</code> on <code class="literal">coordinator</code>, you receive a placeholder context. You use this context to either remove the placeholder if loading data from the item provider failed, or to commit the insertion if it succeeds. Once it has succeeded and you commit the insertion, you must make sure to update the collection's data source by adding the image to the image array. Otherwise, your app could crash due to data-source inconsistencies.</p><p>Since a <span>placeholder</span><a id="id325581095" class="indexterm"></a> is not part of your <code class="literal">CollectionView</code> data source, it is <span>essential</span><a id="id325581107" class="indexterm"></a> that you proceed with caution if you have a placeholder present in your <code class="literal">CollectionView</code>. For instance, your placeholder will be gone when you reload <code class="literal">CollectionView</code> before committing or removing the placeholder.</p><p>Lastly, add the following line to the <code class="literal">viewDidLoad</code> of <code class="literal">ViewController</code> to set the collection view's drop delegate:</p><pre class="programlisting">collectionView.dropDelegate = self</pre><p>At this point, you should be able to create a very nice implementation of drag and drop in your apps. However, there is more to learn on the topic since you can customize many aspects of how drag and drop works for your app.</p></div></div>