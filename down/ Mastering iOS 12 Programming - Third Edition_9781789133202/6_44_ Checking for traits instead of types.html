<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec47"></a>Checking for traits instead of types</h2></div></div><hr /></div><p>In classic OOP, you often create superclasses and <span>subclasses</span><a id="id325333114" class="indexterm"></a> to group objects with similar capabilities. If you roughly model a group of felines in the animal kingdom with classes, you end up with a diagram that looks like this:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/b865ff31-8d8d-4fc7-9748-a198add06dde.png" /></div><p>If you try to model more animals, you will find that it's a complex task because some animals share a whole bunch of traits, although they are quite far apart from each other in the class diagram.</p><p>One example would be that both cats and dogs are typically kept as pets. This means that they should optionally have an owner and maybe a home. But cats and dogs aren't the only animals kept as pets because fish, guinea pigs, rabbits, and even snakes are kept as pets. It would be tough to figure out a sensible way to restructure your class hierarchy in such a way that you don't have to redundantly add owners and homes to every pet in the hierarchy because it would be impossible to add these properties to the right classes selectively.</p><p>This problem gets even worse when you <span>write</span><a id="id325333139" class="indexterm"></a> a function or method that prints a pet's home. You would either have to make that function accept any animal or write a separate implementation of the same function for each type that has the properties you're looking for. Both don't make sense because you don't want to write the same function over and over again with just a different class for the parameter. Even if you choose to do this and you end up with a method that prints an animals home address that accepts a <code class="literal">Fish</code> instance, passing an instance of <code class="literal">GreatWhiteShark</code> to a function called <code class="literal">printHomeAddress()</code> doesn't make a lot of sense either, because sharks typically don't have home addresses. Of course, the solution to this problem is to use protocols.</p><p>In the situation described in the <span>previous</span> section, objects were mostly defined by what they <span class="emphasis"><em>are</em></span>, not by what they <span class="emphasis"><em>do</em></span>. We care about the fact that an animal is part of a particular family or type, not about whether it lives on land. You can't differentiate between animals that can fly and animals that can't because not all birds can fly. Inheritance isn't compatible with this way of thinking. Imagine a definition for a <code class="literal">Pigeon</code> struct that looks like this:</p><pre class="programlisting">struct Pigeon: Bird, FlyingType, OmnivoreType, Domesticatable </pre><p>Since <code class="literal">Pigeon</code> is a struct, you know that <code class="literal">Bird</code> isn't a struct or class; it's a protocol that defines a couple of requirements about what it means to be a bird. The <code class="literal">Pigeon</code> struct also conforms to the <code class="literal">FlyingType</code>, <code class="literal">OmnivoreType</code>, and <code class="literal">Domesticatable</code> protocols. Each of these protocols tells you something about <code class="literal">Pigeon</code> regarding its capabilities or traits. The definition explains what a pigeon is and does instead of merely communicating that it inherits from a certain type of bird. For instance, almost all birds can fly, but there are some exceptions to the rule. You could model this with classes, but this approach is tedious and might be inflexible, depending on your needs and how your code evolves over time. Setting the <code class="literal">Pigeon</code> struct up with protocols is powerful; you can now <span>write</span><a id="id325333228" class="indexterm"></a> a <code class="literal">printHomeAddress()</code> function and set it up so that it accepts any object that conforms to <code class="literal">Domesticatable</code>:</p><pre class="programlisting">protocol Domesticatable {
  var homeAddress: String? { get }
}

func printHomeAddress(animal: Domesticatable) {
  if let address = animal.homeAddress {
    print(address)
  }
} </pre><p>The <code class="literal">Domesticatable</code> protocol requires an optional <code class="literal">homeAddress</code> property. Not every animal that can be domesticated actually is. For example, think about the pigeon; some pigeons are kept as pets, but most aren't. This also applies to cats and dogs, because not every cat or dog has a home.</p><p>This approach is powerful, but shifting your mind from an object-oriented mindset, where you think of an inheritance hierarchy, to a protocol-oriented mindset, where you focus on traits instead of inheritance, isn't easy.</p><p>Let's expand the example code a bit more by defining <code class="literal">OmnivoreType</code>, <code class="literal">HerbivoreType</code>, and <code class="literal">CarnivoreType</code>. These types will represent the three main types of eaters in the animal kingdom. You can make use of inheritance inside of these protocols because <code class="literal">OmnivoreType</code> is both <code class="literal">HerbivoreType</code> and <code class="literal">CarnivoreType</code>, so you can make <code class="literal">OmnivoreType</code> inherit from both of these protocols:</p><pre class="programlisting">protocol HerbivoreType {
  var favoritePlant: String { get }
}

protocol CarnivoreType {
  var favoriteMeat: String { get }
}

protocol OmnivoreType: HerbivoreType, CarnivoreType {} </pre><p>Composing two protocols into one like you did in the <span>preceding</span><a id="id325578420" class="indexterm"></a> example is really powerful, but be careful when you do this. You don't want to create a crazy inheritance graph like you would when you do OOP; you just learned that inheritance could be wildly complex and inflexible. Imagine writing two new functions, one to print a carnivore's favorite meat and one to print a herbivore's favorite plant. Those functions would look like this:</p><pre class="programlisting">func printFavoriteMeat(forAnimal animal: CarnivoreType) {
  print(animal.favoriteMeat)
}

func printFavoritePlant(forAnimal animal: HerbivoreType) {
  print(animal.favoritePlant)
} </pre><p>The preceding code might be exactly what you would write yourself. However, neither of these methods accepts <code class="literal">OmnivoreType</code>. This is perfectly fine because <code class="literal">OmnivoreType</code> inherits from <code class="literal">HerbivoreType</code> and <code class="literal">CarnivoreType</code>. This works in the same way that you're used to in classical object-oriented programming, with the main exception being that <code class="literal">OmnivoreType</code> inherits from multiple protocols instead of just one. This means that the <code class="literal">printFavoritePlant</code> function accepts a <code class="literal">Pigeon</code> instance as its argument because <code class="literal">Pigeon</code> confirms to <code class="literal">OmnivoreType</code>, which inherits from <code class="literal">HerbivoreType</code>.</p><p>Using protocols to compose your objects like this can drastically simplify your code. Instead of thinking about complex inheritance structures, you can compose your objects with protocols that define certain traits. The beauty of this is that it makes defining new objects relatively easy.</p><p>Imagine that a new type of animal is discovered. One that can fly, swim, and lives on land. This weird new species would be really hard to add to an inheritance-based architecture since it doesn't fit in with other animals. When using protocols, you could add conformance to the <code class="literal">FlyingType</code>, <code class="literal">LandType</code>, and <code class="literal">SwimmingType</code> protocols and you'd be all set. Any methods or functions that take a <code class="literal">LandType</code> animal as an argument will happily accept your new animal since it conforms to the <code class="literal">LandType</code> protocol.</p><p>Getting the hang of this way of thinking isn't simple, and it will <span>require</span><a id="id325604084" class="indexterm"></a> some practice. But any time you're getting ready to create a superclass or subclass, ask yourself why. If you're trying to encapsulate a certain trait in that class, try using a protocol. This will train you to think differently about your objects, and before you know it, your code is cleaner, more readable, and more flexible, using protocols and checking for traits instead of taking actions based on what an object is.</p><p>As you've seen, a protocol doesn't need to have a lot of requirements; sometimes one or two are enough to convey the right meaning. Don't hesitate to create protocols with just a single property or method; as your projects grow over time and your requirements change, you will thank yourself for doing so.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec28"></a>Extending your protocols with default behavior</h3></div></div></div><p>The previous examples have mainly used variables as the <span>requirements</span><a id="id325604101" class="indexterm"></a> for protocols. One slight downside of <span>protocols</span><a id="id325580637" class="indexterm"></a> is that they can result in a bit of code duplication. For example, every object that is <code class="literal">HerbivoreType</code> has a <code class="literal">favoriteMeat</code> variable. This means that you have to duplicate this variable in every object that conforms to <code class="literal">HerbivoreType</code>. Usually, you want as little code repetition as possible, and repeating a variable over and over again might seem like a step backward.</p><p>Even though it's nice if you don't have to declare the same property over and over again, there's a certain danger in not doing this. If your app grows to a large size, you won't remember every class, subclass, and superclass all of the time. This means that changing or removing a specific property can have undesired side-effects in other classes.</p><p>Declaring the same properties on every object that conforms to a certain protocol isn't that big a deal; it usually takes just a few lines of code to do this. However, protocols can also require certain methods to be present on objects that conform to them. Declaring those over and over again can be cumbersome, especially if the implementation is the same for most objects. Luckily, you can make use of <span class="strong"><strong>protocol extensions</strong></span> to implement a certain degree of default functionality.</p><p>To explore protocol extensions, let's move the <code class="literal">printHomeAddress()</code> function into the <code class="literal">Domesticatable</code> protocol so all <code class="literal">Domesticatable</code> objects can print their own home addresses. The first approach you can take is to immediately define the method on a protocol extension without adding it to the protocol's requirements:</p><pre class="programlisting">extension Domesticatable {
  func printHomeAddress() {
    if let address = homeAddress {
      print(address)
    }
  }
} </pre><p>By defining the <code class="literal">printHomeAddress()</code> method in the protocol extension, every object that conforms to <code class="literal">Domesticatable</code> has the following method available without having to implement it with the object itself:</p><pre class="programlisting">let myPidgeon = Pigeon(favoriteMeat: "Insects", favoritePlant: "Seeds", homeAddress: "Leidse plein 12, Amsterdam")
myPidgeon.printHomeAddress() // "Leidse plein 12, Amsterdam" </pre><p>This technique is very convenient if you want to implement default behavior that's associated with a protocol. You didn't even have to add the <code class="literal">printHomeAddress()</code> method as a requirement to the protocol. However, this approach will give you some strange results if you're not careful. The following snippet shows an example of such odd results by adding a custom implementation of <code class="literal">printHomeAddress()</code> to the <code class="literal">Pigeon</code> struct:</p><pre class="programlisting">struct Pigeon: Bird, FlyingType, OmnivoreType, Domesticatable {
  let favoriteMeat: String
  let favoritePlant: String
  let homeAddress: String?

  func printHomeAddress() {
    if let address = homeAddress {
      print("address: \(address.uppercased())")
    }
  }
}

let myPigeon = Pigeon(favoriteMeat: "Insects", favoritePlant: "Seeds", homeAddress: "Leidse plein 12, Amsterdam")

myPigeon.printHomeAddress() //address: LEIDSE PLEIN 12, AMSTERDAM

func printAddress(animal: Domesticatable) {
  animal.printHomeAddress()
}
printAddress(animal: myPigeon) // Leidse plein 12, Amsterdam </pre><p>When you call <code class="literal">myPigeon.printHomeAddress()</code>, the custom implementation is used to print the address. However, if you define a function, such as <code class="literal">printAddress(animal:)</code>, that takes a <code class="literal">Domesticatable</code> object as its parameter, the default implementation provided by the protocol is used.</p><p>This happens because <code class="literal">printHomeAddress()</code> isn't a requirement of the protocol. Therefore, if you call <code class="literal">printHomeAddress()</code> on a <code class="literal">Domesticatable</code> object, the implementation from the protocol extension is used. If you use the same snippet as in the preceding section, but change the <code class="literal">Domesticatable</code> protocol as shown in the following code, both calls to <code class="literal">printHomeAddress()</code> print the same thing, that is, the custom implementation in the <code class="literal">Pigeon</code> struct:</p><pre class="programlisting">protocol Domesticatable {   
  var homeAddress: String? { get }   

  func printHomeAddress()   
} </pre><p>This behavior is likely to be <span>unexpected</span><a id="id325580750" class="indexterm"></a> in most cases, so it's <span>usually</span><a id="id325580759" class="indexterm"></a> a good idea to define all methods you use in the protocol requirements unless you're absolutely sure you want the behavior you just saw.</p><p>Protocol extensions can't hold stored properties. This means that you can't add your variables to the protocol to provide a default implementation for them. Even though extensions can't hold stored properties, there are situations where you can still add a computed property to a protocol extension to avoid duplicating the same variable in multiple places. Let's take a look at an example:</p><pre class="programlisting">protocol Domesticatable {
  var homeAddress: String? { get }
  var hasHomeAddress: Bool { get }

  func printHomeAddress()
}

extension Domesticatable {
  var hasHomeAddress: Bool {
    return homeAddress != nil
  }

  func printHomeAddress() {
    if let address = homeAddress {
      print(address)
    }
  }
} </pre><p>If you want to be able to check whether a <code class="literal">Domesticatable</code> has a home address, you can add a requirement for a <code class="literal">Bool</code> value, <code class="literal">hasHomeAddress</code>. If the <code class="literal">homeAddress</code> property is set, <code class="literal">hasHomeAddress</code> should be <code class="literal">true</code>. Otherwise, it should be <code class="literal">false</code>. This property is computed in the protocol extension, so you don't have to add this property to all <code class="literal">Domesticatable</code> objects. In this case, it makes a lot of sense to use a computed property because the way its value is computed should most likely be the same across all <code class="literal">Domesticatable</code> objects.</p><p>Implementing default behaviors in <span>protocol</span><a id="id325580808" class="indexterm"></a> extensions makes the protocol-oriented <span>approach</span><a id="id325580817" class="indexterm"></a> we've seen before even more powerful; you can essentially mimic a feature called <span class="strong"><strong>multiple inheritance</strong></span> without all the downsides of subclassing. Simply adding conformance to a protocol can add all kinds of functionality to your objects, and if the <span>protocol</span><a id="id325580829" class="indexterm"></a> extensions allow it, you won't need to add anything else to your code. Let's see how you can make protocols and extensions even more powerful with associated types.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec29"></a>Improving your protocols with associated types</h3></div></div></div><p>One more awesome aspect of protocol-oriented <span>programming</span><a id="id325580877" class="indexterm"></a> is the use of associated types. An associated type is a generic, non-existing type that can be used in your protocol like any type that does exist. The real type of this generic is determined by the compiler based on the context it's used in. This description is abstract, and you might not <span>immediately</span><a id="id325580886" class="indexterm"></a> understand why or how an associated type can benefit your protocols. After all, aren't protocols themselves a very flexible way to make several unrelated objects fit certain criteria based on the protocols they conform to?</p><p>To illustrate and discover the use of associated types, you will expand your animal kingdom a bit. What you should do is give the herbivores an <code class="literal">eat</code> method and an array to keep track of the plants they've eaten, as follows:</p><pre class="programlisting">protocol HerbivoreType {
  var plantsEaten: [PlantType] { get set }

  mutating func eat(plant: PlantType)
}

extension HerbivoreType {
  mutating func eat(plant: PlantType) {
    plantsEaten.append(plant)
  }
}</pre><p>This code looks fine at first sight. A herbivore eats plants, and this is established by this protocol. The <code class="literal">PlantType</code> protocol is defined as follows:</p><pre class="programlisting">protocol PlantType {   
  var latinName: String { get }   
} </pre><p>Let's define two different plant types and an animal that will be used to demonstrate the problem with the preceding code:</p><pre class="programlisting">struct Grass: PlantType{
  var latinName = "Poaceae"
}

struct Pine: PlantType{
  var latinName = "Pinus"
}

struct Cow: HerbivoreType {
  var plantsEaten = [PlantType]()
} </pre><p>There shouldn't be a big surprise here. Let's continue with creating a <code class="literal">Cow</code> instance and feed it <code class="literal">Pine</code>:</p><pre class="programlisting">var cow = Cow()   
let pine = Pine()   
cow.eat(plant: pine)</pre><p>This doesn't really make sense. Cows don't eat pines; they eat grass! We need some way to limit this cow's food intake because this approach isn't going to work. Currently, you can feed <code class="literal">HerbivoreType</code> animals anything that's considered a plant. You need some way to limit the types of food your cows are given. In this case, you should restrict the <code class="literal">FoodType</code> to <code class="literal">Grass</code> only, without having to define the <code class="literal">eat(plant:)</code> method for every plant type you might want to feed a <code class="literal">HerbivoreType</code>.</p><p>The problem you're facing now is that all <code class="literal">HerbivoreType</code> animals <span>mainly</span><a id="id325333253" class="indexterm"></a> eat one <span>plant</span><a id="id325333261" class="indexterm"></a> type, and not all plant types are a good fit for all herbivores. This is where associated types are a great solution. An associated type for the <code class="literal">HerbivoreType</code> protocol can constrain the <code class="literal">PlantType</code> that a certain herbivore can eat to a single type that is defined by the <code class="literal">HerbivoreType</code> itself. Let's see what this looks like:</p><pre class="programlisting">protocol HerbivoreType {
  // 1
  associatedtype Plant: PlantType

  var plantsEaten: [Plant] { get set }

  mutating func eat(plant: Plant)
}

extension HerbivoreType {
  mutating func eat(plant: Plant) {
    // 2
    print("eating a (plant.latinName)")
    plantsEaten.append(plant)
  }
} </pre><p>The first highlighted line associates the generic <code class="literal">Plant</code> type, which doesn't exist as a real type, with the protocol. A constraint has been added to <code class="literal">Plant</code> to ensure that it's a <code class="literal">PlantType</code>.</p><p>The second highlighted line demonstrates how the <code class="literal">Plant</code> associated type is used as a <code class="literal">PlantType</code>. The plant type itself is merely an alias for any type that conforms to <code class="literal">PlantType</code> and is used as the type of object we use for <code class="literal">plantsEaten</code> and the <code class="literal">eat</code> methods. Let's redefine the <code class="literal">Cow</code> struct to see this associated type in action:</p><pre class="programlisting">struct Cow: HerbivoreType {   
  var plantsEaten = [Grass]()
}</pre><p>Instead of making <code class="literal">plantsEaten</code> a <code class="literal">PlantType</code> array, it's now defined as an array of <code class="literal">Grass</code>. In the protocol and the definition, the type of plant is now <code class="literal">Grass</code>. The compiler understands this because the <code class="literal">plantsEaten</code> array is defined as <code class="literal">[Grass]</code>. Let's define a second <code class="literal">HerbivoreType</code> that eats a different type of <code class="literal">PlantType</code>:</p><pre class="programlisting">struct Carrot: PlantType {   
  let latinName = "Daucus carota"   
}   

struct Rabbit: HerbivoreType {   
  var plantsEaten = [Carrot]()   
} </pre><p>If you try to feed a <code class="literal">Cow</code> some carrots, or if you attempt to feed the <code class="literal">Rabbit</code> a <code class="literal">Pine</code>, the compiler will throw errors. The reason for this is that the associated type constraint allows you to define the type of <code class="literal">Plant</code> in each struct separately.</p><p>One side note about associated types is that it's not <span>always</span><a id="id325333408" class="indexterm"></a> possible for the compiler to correctly infer the real type for an associated type. In our current example, this would happen if we didn't have the <code class="literal">plantsEaten</code> array in the protocol. The solution would be to define a <code class="literal">typealias</code> on objects that conform to <code class="literal">HerbivoreType</code> so that the <span>compiler</span><a id="id325333426" class="indexterm"></a> understands which type <code class="literal">Plant</code> represents:</p><pre class="programlisting">protocol HerbivoreType {   
  associatedtype Plant: PlantType   

  mutating func eat(plant: Plant)   
}   

struct Cow: HerbivoreType {   
  typealias Plant = Grass   
} </pre><p>Associated types can be really powerful when used correctly, but sometimes using them can also cause you a lot of headaches because of the amount of inferring the compiler has to do. If you forget a few tiny steps, the compiler can quickly lose track of what you're trying to do, and the error messages aren't always the most unambiguous messages. Keep this in mind when you're using associated types, and try to make sure that you're as explicit as possible about <span>the type you're looking to be associated</span>. Sometimes, adding a <code class="literal">typealias</code> to give the compiler a helping hand is better than trying to get the compiler to infer everything on its own correctly.</p><p>This type of flexibility is not limited to protocols. You can also add generic properties to functions, classes, structs, and enums. Let's see how this works and how it can make your code extremely flexible.</p><p> </p></div></div>