<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch24lvl1sec163"></a>Creating your own Instrument</h2></div></div><hr /></div><p>The Instruments app <span>comes</span><a id="id325333112" class="indexterm"></a> with some great built-in tools that can be used to profile applications. While this is great, sometimes you might need something more tailor-made. Since Xcode 10, you can create your own Instruments Packages to profile your apps. Custom Instruments can use special logging that you add in your app through the <code class="literal">os_signpost</code> APIs to keep track of certain processes in your app while collecting interesting data about it. In this section, you will learn how you can add signpost logging to your app as a lightweight mechanism to measure performance in your app. Then, you'll learn how to take this data and funnel it through your own custom Instruments Package.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch24lvl2sec131"></a>Adding signpost logging to your app</h3></div></div></div><p>As a developer, you want to know exactly what your <span>app</span><a id="id325333133" class="indexterm"></a> is doing and how long your app spends on certain parts of your code. It's common to use breakpoints or print statements to do some basic debugging or logging in your app, but keeping track of many print statements in the console can be quite tedious. In iOS 12, you can use signpost logging to flag the beginning and end of a certain task and you can visualize these logs in Instruments using the built-in <strong class="userinput"><code>os_signpost instrument</code></strong>. The ossignpost instrument logs all signposts you track and shows them on a timeline. The following image shows an example of what signpost logging in Instruments looks like:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/33614e3e-69b6-4f97-9a09-c23f39fb43f9.png" /></div><p>You can see a couple of timelines, one of them is labeled <strong class="userinput"><code>Prepare Layout</code></strong>. This timeline is a custom signpost that is sent from the <span class="strong"><strong><strong class="userinput"><code>Mosaic</code></strong></strong></span> app. In the detail area, you can see more details about the signposts that were posted. The signposts that are posted by <span class="strong"><strong><strong class="userinput"><code>Mosaic</code></strong></strong></span> correspond with the calls to <code class="literal">prepare()</code> on the custom collection view layout on the collection view page. Using signposts to track the performance of the <code class="literal">prepare()</code> method is more convenient in certain ways than using the Time Profiler; the Time Profiler provides a lot of detailed information that you might not always want to see right away. In this case, you would be more interested in making sure setting up the layout doesn't take too long. Additionally, you might want to make sure that <code class="literal">prepare()</code> performs well with many different amounts of sections.</p><p> </p><p>Adding signposts to your <span>app</span><a id="id325333522" class="indexterm"></a> only takes a couple of minutes and they can give you fantastic new insights into what your app is doing. To add signposts to your app, you need an <code class="literal">OSLog</code> handle. An <code class="literal">OSLog</code> handle sounds very fancy, but it's just an instance of <code class="literal">OSLog</code> that is associated with your app. Go ahead and open <code class="literal">ListCollectionViewLayout.swift</code> in the <span class="strong"><strong><strong class="userinput"><code>Mosaic</code></strong></strong></span> project and add the following code to this file:</p><pre class="programlisting">import os.signpost

private let layoutLogger = OSLog(subsystem: "com.donnywals.layout", category: "layout")</pre><p>The preceding code imports the <code class="literal">os.signpost</code> framework and creates a log handle that will be used to track the signposts. When you create a signpost, you can flag the signpost as one of three types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Begin</li><li style="list-style-type: disc">End</li><li style="list-style-type: disc">Point of interest</li></ul></div><p>The <strong class="userinput"><code>begin</code></strong> and <strong class="userinput"><code>end</code></strong> signposts are used to flag the start and end of an operation. You will add these signposts to the <code class="literal">prepare()</code> method to track the performance of preparing the collection view layout. A <strong class="userinput"><code>point of interest</code></strong> signpost is a special kind of signpost that is used to flag interesting moments that can occur in your app. For instance, when a user taps on something or when you reach a certain special moment inside of an operation. To log a signpost, you need to obtain <code class="literal">OSSignpostID</code>. This object is used to link two begin and end signposts together so it's essential that you use the same signpost ID. To create a signpost ID, you can use one of the following two methods:</p><pre class="programlisting">let one = OSSignpostID(log: layoutLogger, object: self)
let two = OSSignpostID(log: layoutLogger)</pre><p>The first method can only be used if the <code class="literal">object</code> parameter you pass to the <code class="literal">OSSignpostID</code> initializer is a class. This way of creating a signpost ID will always return the same for any given object. So if you use this method, every time you use this initializer inside of a particular class instance, the ID will be the same.</p><p>The second method generates a random, unique signpost ID every time. So if you're using signposts with a struct, make sure to store the signpost ID so you can reuse it if needed.</p><p> </p><p>Once you have obtained your signpost ID, you can begin logging signpost events. Update the code for <code class="literal">prepare()</code> in the collection view layout as follows:</p><pre class="programlisting">override func prepare() {
  super.prepare()

  guard let numSections = collectionView?.numberOfSections, numSections != 0
    else { return }
  // 1
  let id = OSSignpostID(log: layoutLogger, object: self)
  // 2
  os_signpost(.begin, log: layoutLogger, name: "Prepare Layout", signpostID: id, "Preparing layout with numSections: %{public}@", "\(numSections)")

  // existing implementation

  // 3
  os_signpost(.end, log: layoutLogger, name: "Prepare Layout", signpostID: id, "Done preparing layout")
}</pre><p>The first comment signals the creation of a signpost ID. Since the collection view layout is a class, it can be passed to the signpost ID initializer. Once the signpost ID is created, the begin signpost is added. Every signpost is attached to a logger and has a name. The name should be the same for the begin and end signpost so the system understands that they both relate to the same event in your app. The last argument for the signpost begin and end <span>calls</span><a id="id325580585" class="indexterm"></a> is the description of the event. The description is a formatted string so you can add metadata to it through format specifiers. In this case, the <code class="literal">%{public}@</code> specifier is used to signal that a string will be added to the description. The end signpost does not have any variables associated with it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip56"></a>Note</h3><p>If you want to log a point-of-interest signpost, you log it similarly to how the begin and end signposts are logged, except you need a special kind of logger. To create a point-of-interest logger, you need to use <code class="literal">OSLog.Category.pointsOfInterest</code> as the category for the <code class="literal">OSLog</code> handle and then associate your signpost with that logger rather than your normal logger.</p></div><p>To see your signposts in Instruments, you need to run your app for <span>profiling</span> like you have done before in this chapter. Instead of selecting one of the predefined templates, select a blank template when Instruments starts up. Use the <span class="strong"><strong>+</strong></span> icon to find the <strong class="userinput"><code>os_signpost</code></strong> instrument:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/d6a7c898-05cb-4828-9e32-b465b96199c4.png" /></div><p>After locating the <strong class="userinput"><code>os_signpost</code></strong> instrument, drag it to the timeline area. You can now begin profiling your app and your signposts should appear. While this is cool, the default view combines your signposts in the detail view. You can see that every time you log <span class="emphasis"><em>Preparing layout with numSections: 2</em></span>, the count for this message is incremented and you can see the minimum, maximum, and average duration. Usually, this is plenty of information, but what if you want to see every individual signpost call in the detail view? You can achieve this by creating your own custom Instruments Package.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch24lvl2sec132"></a>Building an Instruments Package</h3></div></div></div><p>Together with signpost logging, Apple introduced the ability to define custom Instruments Package. An Instruments Package exists as an XML file that describes the type of data that your app wants to track and how to visualize it. Apple uses this approach internally as well, which means that your <span>own</span><a id="id325580990" class="indexterm"></a> Instruments Packages can build upon Apple's own instruments packages. The most interesting type of custom instrument you can create is a signpost instrument. This type of instrument takes the data you log with the <code class="literal">os_signpost</code> API and you can decide how Instruments should visualize this data.</p><p>To create an Instruments Package, add a new target to your app. Instead of selecting the type of target from the list of iOS targets, go to the macOS tab and find the Instruments Package template:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/b020e940-024d-46d0-8cce-542ee9961dd3.png" /></div><p></p><p>Name the instrument <strong class="userinput"><code>MosaicLayoutInstrument</code></strong> if you want to follow along with the steps to create your own instrument. Xcode will create a new folder in your project that has a single file in it. The extension for this file is <code class="literal">instrpkg</code>. If you open this file, you will find a little bit of XML and a lot if commented-out information to guide you in creating your <span>own</span><a id="id325607252" class="indexterm"></a> instrument. You can remove all of these comments if you want.</p><p>Every instrument has roughly three main sections in the XML:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Metadata about the instrument</li><li style="list-style-type: disc">A schema that defines the data that is tracked</li><li style="list-style-type: disc">The instrument itself</li></ul></div><p>Depending on your exact needs, you might have multiple schemas or instruments. To track signposts, you need to add an <code class="literal">&lt;os-signpost-interval-schema&gt;</code> tag to the XML file. If you type <code class="literal">os-signpost-interval-schema</code> in the XML and hit <span class="emphasis"><em>Esc</em></span>, Xcode will usually offer the option to automatically add a skeleton implementation for the implementation of the tag. The schema for this instrument will only track a single column, the number of sections that were involved in the layout calculation. Add the following implementation for the signpost interval schema:</p><pre class="programlisting">&lt;os-signpost-interval-schema&gt;
  &lt;!-- 1 --&gt;
  &lt;id&gt;signpost-schema&lt;/id&gt;
  &lt;title&gt;Layout Signpost Schema&lt;/title&gt;

  &lt;!-- 2 --&gt;
  &lt;subsystem&gt;"com.donnywals.layout"&lt;/subsystem&gt;
  &lt;category&gt;"layout"&lt;/category&gt;
  &lt;name&gt;"Prepare Layout"&lt;/name&gt;

  &lt;!-- 3 --&gt;
  &lt;start-pattern&gt;
    &lt;message&gt;"Preparing layout with numSections: "?num-sections&lt;/message&gt;
  &lt;/start-pattern&gt;

  &lt;end-pattern&gt;
    &lt;message&gt;"Done preparing layout"&lt;/message&gt;
  &lt;/end-pattern&gt;

  &lt;!-- 4 --&gt;
  &lt;column&gt;
    &lt;mnemonic&gt;num-sections&lt;/mnemonic&gt;
    &lt;title&gt;Number of Sections&lt;/title&gt;
    &lt;type&gt;string&lt;/type&gt;
    &lt;expression&gt;?num-sections&lt;/expression&gt;
  &lt;/column&gt;
&lt;/os-signpost-interval-schema&gt;</pre><p>The preceding snippet is defined in four sections:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Some metadata about the schema. The ID will be used later to refer to the schema in the instrument.</li><li>Information about how the information is logged. These fields should match the corresponding values in your app.</li><li>Patterns for the begin and end <span>messages</span><a id="id325611544" class="indexterm"></a> as they were used in your app. You use the <code class="literal">?num-sections</code> notation to indicate the location of a variable and to extract it into a new variable that can be used in your schema.</li><li>The columns that your schema contains. In this case, it's only a single column that uses <code class="literal">num-sections</code> as its identifier and corresponds with the <code class="literal">?num-sections</code> variable extracted from the begin message.</li></ol></div><p>After adding the schema, you are ready to create the instrument. Add the following implementation to the XML file, after the schema definition:</p><pre class="programlisting">&lt;instrument&gt;
  &lt;!-- 1 --&gt;
  &lt;id&gt;com.donnywals.layout-instrument&lt;/id&gt;
  &lt;title&gt;Layout Instrument&lt;/title&gt;
  &lt;category&gt;Behavior&lt;/category&gt;
  &lt;purpose&gt;Insight in layout preparation&lt;/purpose&gt;
  &lt;icon&gt;Generic&lt;/icon&gt;

  &lt;!-- 2 --&gt;  
  &lt;create-table&gt;
    &lt;id&gt;layout-table&lt;/id&gt;
    &lt;schema-ref&gt;signpost-schema&lt;/schema-ref&gt;
  &lt;/create-table&gt;

  &lt;!-- 3 --&gt;
  &lt;graph&gt;
    &lt;title&gt;Layout preparation&lt;/title&gt;
    &lt;lane&gt;
      &lt;title&gt;Prepare&lt;/title&gt;
      &lt;table-ref&gt;layout-table&lt;/table-ref&gt;

      &lt;plot-template&gt;
        &lt;instance-by&gt;num-sections&lt;/instance-by&gt;
        &lt;value-from&gt;duration&lt;/value-from&gt;
      &lt;/plot-template&gt;
    &lt;/lane&gt;
  &lt;/graph&gt;

  &lt;!-- 4 --&gt;
  &lt;list&gt;
    &lt;title&gt;Layout list&lt;/title&gt;
    &lt;table-ref&gt;layout-table&lt;/table-ref&gt;
    &lt;column&gt;num-sections&lt;/column&gt;
    &lt;column&gt;duration&lt;/column&gt;
  &lt;/list&gt;
&lt;/instrument&gt;</pre><p>The preceding snippet defines all XML needed for a basic instrument. Again, there are four sections:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Metadata about the instrument.</li><li>Every instrument uses tables that refer to schemas. In this case, a table is created that uses the <code class="literal">signpost-schema</code> schema for its data.</li><li>This section defines how the custom instrument should be drawn on the timeline. Every graph uses a table for its underlying data and then extracts the required data from the table. Note that you didn't manually define <code class="literal">duration</code> on the signpost schema. You get this property for free from the schema.</li><li>A definition is given for how the instrument should be displayed in the detail area. The format of the detail area is a table, so in this section, you define the <span>detail</span><a id="id325617701" class="indexterm"></a> area in a table-like structure.</li></ol></div><p>This is all the code you need to write a basic custom instrument. To test your instrument, select your Instrument Package target and use your Mac as the <span>target define</span>:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/920bb73a-2f61-4b25-819b-ffd2d15381ad.png" /></div><p></p><p>A special version of Instruments will launch. Pick a blank template and look for your custom instruments in the add menu:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/d7e5c1f8-5ac2-4e31-8ead-1586ca41493b.png" /></div><p></p><p>Once you have found your instrument, add it to the timeline area and profile your app. You should see all your signpost data appear as expected. The <span>detail</span><a id="id325618094" class="indexterm"></a> area should now show a single entrance for every time you call <code class="literal">prepare()</code> so you can easily compare performance between similar calls:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/0bab6fa0-4396-4bcf-a41e-45508e635920.png" /></div><p>This sample was quite simple but it does an excellent job of showing that you can do powerful things with custom instruments. If you want to learn even more about what kinds of custom instruments you can build and how you can do some custom processing on your signpost data, make sure to catch the <span class="emphasis"><em>Creating Custom Instruments</em></span><span>talk</span> from WWDC 2018.</p></div></div>