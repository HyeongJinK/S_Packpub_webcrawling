<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch19lvl1sec131"></a>Adding a Today Extension to your app</h2></div></div><hr /></div><p>In the code bundle for this chapter, you'll <span>find</span><a id="id325333114" class="indexterm"></a> a project called <span class="strong"><strong>The Daily Quote</strong></span>. It's a straightforward app that displays a different inspirational quote to the user every day. The quotes are hardcoded in the <code class="literal">Quotes.swift</code> file and the current quote is stored in the <code class="literal">UserDefaults</code> store. The UI contains just two labels to show the current quote and the person that's quoted.</p><p>Even though the project is quite simple, each file contains something interesting. If you select one of the labels in the <strong class="userinput"><code>Storyboard</code></strong> and examine its attributes, you'll find that the font for the quote itself is <strong class="userinput"><code>Title 1</code></strong> and the font for the quoted person is <strong class="userinput"><code>Caption 1</code></strong>. This is different from the default system font that you usually use. When you configure labels with these predefined styles, the text in the label will dynamically adjust based on the user's preferences. Adopting dynamic type such as this is requires only minimal effort and is great from an accessibility standpoint.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip48"></a>Note</h3><p>If your interface allows it, it's recommended that you make use of accessible type, simply because it will make your app more comfortable to use for all of your users.</p></div><p>If you look at the <code class="literal">QuoteViewController</code> class, there are only a couple of lines involved in displaying a quote. The reason this code is so simple and concise is that a great deal of preparatory work was done in the <code class="literal">Quote</code> model file. Go ahead and open that file to see what's going on.</p><p>The <code class="literal">Quotes</code> struct is set up in such a way that it can be used as a simple database. The struct contains several static properties and methods to provide quotes from a predetermined list of quotes.</p><p> </p><p> </p><p>If you were to build a similar app and put it in the App Store, you'd probably want to download the quotes from a server and store it in Core Data, because pushing an update every time you want to add or remove a couple of quotes is a lot of effort for a simple change. There are only a couple of constant instance properties present on the <code class="literal">Quote</code> struct:</p><pre class="programlisting">let text: String   
let creator: String </pre><p>These properties are the ones that <code class="literal">QuoteViewController</code> reads and displays to the user.</p><p>Furthermore, <code class="literal">UserDefaults</code> is used to store which <span>quote</span><a id="id325571683" class="indexterm"></a> should be shown for the current day. <code class="literal">UserDefaults</code> is a simple data store that stores app-related settings. It's essentially a lightweight persistence layer that you can use to store simple objects. <strong class="userinput"><code>The Daily Quote</code></strong> makes use of <code class="literal">UserDefaults</code> to store the date on which the current quote was set as well as the index in the list of <code class="literal">Quote</code> instances that points to the current quote:</p><pre class="programlisting">static var current: Quote {
  if let lastQuoteDate = userDefaults.object(forKey: "lastQuoteDate") as? Date {
    if NSCalendar.current.compare(Date(), to: lastQuoteDate, toGranularity: .day) == .orderedDescending {
      setNewQuote()
    }
  } else {
    setNewQuote()
  }

  guard let quoteIndex = userDefaults.object(forKey: "quoteIndex") as? Int,
    let quote = Quote.quote(atIndex: quoteIndex)
    else { fatalError("Could not create a quote..") }

  return quote
}

static func setNewQuote() {
  let quoteIndex = Quote.randomIndex
  let date = Date()

  userDefaults.set(date, forKey: "lastQuoteDate")
  userDefaults.set(quoteIndex, forKey: "quoteIndex")
}</pre><p>The preceding snippet illustrates the process of retrieving and storing the current <code class="literal">quote</code>. First, the code checks whether a <code class="literal">quote</code> has been set before and if so, it makes sure that the <code class="literal">quote</code> is at least a day old before generating a new one. Next, the current <code class="literal">quoteIndex</code> is retrieved from <code class="literal">UserDefaults</code> and returned as the current <code class="literal">quote</code>.</p><p>If you need a quick refresher on how to use <code class="literal">UserDefaults</code> in your app, go back to <a class="link" href="#" linkend="ch11">Chapter 11</a>, <span class="emphasis"><em>Syncing Data with CloudKit</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip49"></a>Note</h3><p>Don't use <code class="literal">UserDefaults</code> to store privacy-sensitive data. It's not considered secure; the keychain should be used for this purpose. Also, make sure that you're not storing complex or repetitive data in <code class="literal">UserDefaults</code>. It's not a database, nor is it optimized for reading and writing many times. Stick to simple, application-specific settings only.</p></div><p>Now that you are familiar with the contents of the starter project, add a new target to your project just like you have done before, but this time, select the <strong class="userinput"><code>Today Extension</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/403607ab-0428-4c5c-b56c-c74ec1ea1287.png" /></div><p>To see the default widget that Xcode generates for you, go ahead and run your extension. The first time you do this, your widget might not show up immediately. Don't worry if this is the case, build and run again, and your app should show up as a widget in the Today View.</p><p>Now let's see what kind of files and boilerplate code Xcode has generated for you. In the folder that Xcode created for your extension, you'll find a view controller, a storyboard and an <code class="literal">Info.plist</code> file. This structure is very similar to the structure that was used for the <strong class="userinput"><code>Notification Content Extension</code></strong> you created in <span>the previous chapter</span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note50"></a>Note</h3><p>You can change the size of the view controller in your Storyboard if you like, but note that the display size for the widget is taller than the visible size in the storyboard. This is due to the standard compact widget height that iOS uses for your extension. You can't influence this, so you'll need to keep in mind that you only have limited space for your extension, so you should make sure your layout is flexible enough to look good at the compact size the Today View imposes on the widget.</p></div><p>To give the labels in the extension a little bit of room to breathe, select the view controller (not the view itself) and click on the <strong class="userinput"><code>Size</code></strong> inspector. Here you'll see that the simulated size for the view controller is set to free-form and you can set a custom width and height. Leave the width as it is for now and set the height to <span class="emphasis"><em>110</em></span>. This size should be the smallest size at which our widget displays, and it gives you plenty of room to create the interface. Also, delete the default label that has been added to the interface automatically.</p><p>Drag a <code class="literal">UILabel</code> into the view and set its <span>font</span><a id="id325604086" class="indexterm"></a> to <strong class="userinput"><code>Headline</code></strong>. Click the <strong class="userinput"><code>Font</code></strong> icon in the <strong class="userinput"><code>Attributes</code></strong> inspector to change the font and select the <strong class="userinput"><code>Font</code></strong> dropdown to find the dynamic text styles. Position the label in the top-left corner using the blue helper lines and adjust its width, so it covers the available space. After doing this, add the following constraints to the label:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Leading space to Safe Area</li><li style="list-style-type: disc">Top space to Safe Area</li><li style="list-style-type: disc">Trailing space to Safe Area</li></ul></div><p>Finally, set the number of lines for the label to <span class="emphasis"><em>3</em></span> so the quote doesn't take up more than 3 lines. Now, drag out another label and position it right below the first label. Make sure this label has the same spacing from the superview's left edge and that it has the same with as the other label. Set its font style to <strong class="userinput"><code>Caption 1</code></strong>. Also, add the following constraints to this view:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Leading space to Safe Area</li><li style="list-style-type: disc">Trailing space to Safe Area</li><li style="list-style-type: disc">Vertical spacing between this label and the label above it</li></ul></div><p>Your layout in <strong class="userinput"><code>Interface Builder</code></strong> should resemble the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/f0cf0efb-7de5-46a4-bcf7-9b97a61994dc.png" /></div><p>Go ahead and rerun your extension. Your final result should look similar to the one shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/0a5ce6b2-c9f9-4b50-bb90-99a3ec83951b.png" /></div><p>Now that you have set up the layout for your extension, <span>let's some outlets to the widget view controller</span> so you can display the quote of the day inside of the widget:</p><pre class="programlisting">@IBOutlet var quoteLabel: UILabel!   
@IBOutlet var quoteCreator: UILabel! </pre><p>Open the widget's Storyboard file and connect the outlets as you've done before. Select the view controller, go to the <strong class="userinput"><code>Outlet Inspector</code></strong>, and drag from the <strong class="userinput"><code>Outlet Inspector</code></strong> to the corresponding views to connect the outlets to the view.</p><p>The next step to build this widget is to load and display the quote of the day in the widget. Since extensions do not communicate with their host apps directly, you will have to use App Groups again to implement a shared <code class="literal">UserDefaults</code> store. Sharing <code class="literal">UserDefaults</code> through App Groups will allow both your widget and app to retrieve the current quote index from <code class="literal">UserDefaults</code>, and ensures that both interfaces always show the same quote.</p><p>Create a new App Group for <strong class="userinput"><code>The Daily Quote</code></strong> and <span>make</span><a id="id325581248" class="indexterm"></a> sure the app and extension both belong to the same App Group. Also, make sure that you add <code class="literal">Quote.swift</code> to the extension target as well as the app target.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip51"></a>Note</h3><p>If you need a quick refresher on what App Groups are and how they work, go back to <a class="link" href="#" linkend="ch16">Chapter 16</a>, <span class="emphasis"><em>Streamlining Experiences with Siri</em></span> for more information.</p></div><p>After enabling App Groups and making sure the app and the extension share the <code class="literal">Quote</code> struct, add the following code to <code class="literal">TodayViewController.swift</code>:</p><pre class="programlisting">override func viewDidLoad() {
  super.viewDidLoad()

  updateWidget()
}

func updateWidget() {
  let quote = Quote.current
  quoteLabel.text = quote.text
  quoteCreator.text = quote.creator
} </pre><p>If you run the app now, you should see the current quote for the day shown in your widget, as illustrated in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/0601075e-09ba-41d9-b7be-9f26cfe86114.png" /></div><p>The widget currently loads the quote when its view controller is loaded. There are no guarantees about how and when your widget will be recreated. This means that you can't rely on <code class="literal">viewDidLoad()</code> to make sure that your widget always contains the most recent information. In the example that Xcode generated when you first created your extension, a method called <code class="literal">widgetPerformUpdate(completionHandler:)</code> can be found. This method is called regularly by the system to make sure that your widget can update its contents when needed.</p><p>The system passes a <code class="literal">completionHandler</code> to the update method that you must call to let iOS know whether your widget has loaded new data. This allows iOS to optimize the frequency and timing of calls to <code class="literal">widgetPerformUpdate(completionHandler:)</code> so your widget isn't doing more work than needed, and to <span>make</span><a id="id325581316" class="indexterm"></a> sure it updates when it's most likely to have new data. Add the following implementation for this <code class="literal">widgetPerformUpdate(completionHandler:)</code> to <code class="literal">TodayViewController.swift</code>:</p><pre class="programlisting">func widgetPerformUpdate(completionHandler: @escaping (NCUpdateResult) -&gt; Void) {
  let currentText = quoteLabel.text
  updateWidget()
  let newText = quoteLabel.text

  if currentText == newText {
    completionHandler(NCUpdateResult.noData)
  } else {
    completionHandler(NCUpdateResult.newData)
  }
} </pre><p> </p><p>The preceding method updates the widget by calling <code class="literal">updateWidget()</code>, just like <code class="literal">viewDidLoad</code> does. Before doing this, the current text for the quote is stored. After updating the widget, the new text for the quote is stored. Based on the comparison of these two strings, the callback is informed about the result of the update request.</p><p>Some widgets in the Today View have a <strong class="userinput"><code>Show More</code></strong> button that can be tapped to expand the widget. You can implement this button in your own widget by setting the <code class="literal">widgetLargestAvailableDisplayMode</code> property on the notification context to the <code class="literal">.expanded</code> value. Setting the largest display mode to expanded tells the Today View that your widget needs the ability to show contents in a larger view. The following line of code demonstrates how to set the largest available display mode:</p><pre class="programlisting">extensionContext?.widgetLargestAvailableDisplayMode = .expanded</pre><p>When the user taps the <strong class="userinput"><code>Show More</code></strong> button that is rendered after setting the largest display mode, the <code class="literal">widgetActiveDisplayModeDidChange(_:withMaximumSize:)</code> method is called on your notification extension. In this method, you can set your <code class="literal">preferredContentSize</code> of <code class="literal">TodayViewController</code> to the size you would like your widget to be. This should always be smaller than the maximum size that is passed to the method because the Today View will not make your widget any bigger than the maximum size.</p><p>The following code is a short sample implementation for <code class="literal">widgetActiveDisplayModeDidChange(_:withMaximumSize:)</code> that determines the preferred content size based on the new display mode:</p><pre class="programlisting">func widgetActiveDisplayModeDidChange(_ activeDisplayMode: NCWidgetDisplayMode, withMaximumSize maxSize: CGSize) {

  if activeDisplayMode == .compact {
    preferredContentSize = maxSize
  } else {
    preferredContentSize = CGSize(width: maxSize.width, height: 200)
  }
}</pre><p>With this information, you know everything you need to know to start implementing widgets for your own applications.</p><p> </p><p> </p></div>