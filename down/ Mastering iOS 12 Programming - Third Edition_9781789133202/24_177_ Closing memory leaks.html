<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch24lvl1sec162"></a>Closing memory leaks</h2></div></div><hr /></div><p>Usually, if you navigate around in your app, it's normal to see memory usage spike a little. More view controllers on a navigation controller's stack mean that more memory will be consumed by your app. This makes sense. When you navigate back, popping the current view controller off the navigation controller's stack, you would expect the view controller to be deallocated and the memory to be freed up.</p><p>The preceding scenario <span>describes</span><a id="id325602487" class="indexterm"></a> how <strong class="userinput"><code><span class="strong"><strong>Mosaic</strong></span></code></strong> should work. It's OK if the app uses some more <span>memory</span><a id="id325602501" class="indexterm"></a> if you're deeper in the navigation stack, but this memory should be freed up after the back button is tapped.</p><p>In the <span class="strong"><strong><strong class="userinput"><code>Mosaic</code></strong></strong></span> app, the memory keeps growing every time you navigate to a new collection view. It doesn't matter if you drill deep into the navigation stack, hit back, or scroll a lot, once memory is allocated it never seems to be deallocated. This is a problem, and you can use Instruments to dig into the app to find out what's wrong. Before you do this, though, let's have a deeper look at memory leaks, how they occur, and what the common causes are.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch24lvl2sec129"></a>Understanding what a memory leak is</h3></div></div></div><p>When your app contains a memory leak, this means that it's using more <span>memory</span><a id="id325602541" class="indexterm"></a> than it should. More specifically, the app fails to release memory that is no longer needed. A couple of scenarios exist where this could occur. Once you're aware of these scenarios, they should be quite easy to spot. If you haven't seen them before or have never even heard of them, it's easy to fall into the trap of having a memory leak in your app.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch24lvl3sec63"></a>Preventing objects from using infinite memory</h4></div></div></div><p>The first type of <span>memory</span><a id="id325604093" class="indexterm"></a> leak is one where an object is allowed to take up an endless amount of memory without any restrictions. A typical example of this is a cache. When you implement a cache that holds on to certain model objects, API responses, or other data that was expensive to obtain in the first place, it's easy to overlook the fact that you have just built yourself a memory leak.</p><p>If your user is using your app and your cache object keeps caching more and more data, the device will eventually run out of memory. This is a problem because if the app doesn't free the memory in time, it will be terminated by iOS to make sure that essential processes and other apps don't suffer because of your app's out-of-control memory usage.</p><p>Luckily, it's easy to solve issues such as these. The operating system will notify your app through <code class="literal">NotificationCenter</code> any time it needs you to free up memory. Listening to this notification and purging any cached data you can recreate or reload will prevent your app from hogging memory and, ultimately, it prevents your app from being terminated due to memory reasons.</p><p>Here is a straightforward example of an image cache class that purges its cache when memory is tight:</p><pre class="programlisting">class ImageCache: NSObject {
  var cache = [UIImage]()

  override init() {
    super.init()

    NotificationCenter.default.addObserver(self, selector: #selector(purgeCache), name: UIApplication.didReceiveMemoryWarningNotification, object: nil)
  }

  deinit {
    NotificationCenter.default.removeObserver(self, name: UIApplication.didReceiveMemoryWarningNotification, object: nil)
  }

  @objc func purgeCache() {
    cache.removeAll()
  }
}</pre><p>All you need to do is <span>listen</span><a id="id325605889" class="indexterm"></a> for the <code class="literal">UIApplication.didReceiveMemoryWarningNotification</code> notification and purge any data that you can recreate when needed. Even though it's technically not required, this sample unsubscribes the cache from the memory warning notifications when it's deallocated. Since iOS 9, the OS itself should take care of this but this behavior has proven to be somewhat unpredictable so unsubscribing explicitly avoids potential reference cycles, which is the next type of memory leak to explore.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch24lvl3sec64"></a>Avoiding reference cycles</h4></div></div></div><p>When an object contains <span>references</span><a id="id325606037" class="indexterm"></a> to other objects, you should always be careful to avoid situations where both objects continuously hold a reference to each other. For example, a relationship between a table view and its delegate or data source could become a reference cycle if the relationship isn't managed correctly. Objects can only be deallocated if no objects are referencing them anymore:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/e582215a-0d08-4b55-804e-40ceada4e2af.png" /></div><p>The preceding figure illustrates this. The view controller holds onto <code class="literal">tableView</code> and <code class="literal">tableView</code> holds onto its delegate, which is the view controller. This means that neither object can ever be deallocated because for both the view controller and <code class="literal">tableView</code>, there is always at least one object referencing each at any given time. Of course, Apple has made sure that this doesn't occur in your apps by making sure that <code class="literal">tableView</code> does not hold onto its delegate forever. You'll see how in just a second.</p><p>Another situation where a reference cycle could be created is in a closure. When you implicitly reference <code class="literal">self</code> in a closure, the compiler complains that you must explicitly refer to <code class="literal">self</code>. Doing this creates a reference to <code class="literal">self</code> inside of the closure, potentially resulting in a reference cycle. Throughout this book, you've seen a bunch of closures and they always used a <span>capture</span> list <code class="literal">self</code> was used inside of the closure:</p><pre class="programlisting">api.fetchData { [weak self] in
  self?.tableView.reloadData()
}</pre><p>The preceding example shows an <span>example</span><a id="id325607088" class="indexterm"></a> of using a capture list. The capture list is the part right before the <code class="literal">in</code> keyword. The list captures a <code class="literal">weak</code> reference to <code class="literal">self</code>, which means that no reference cycle is created between the closure and <code class="literal">self</code>. If the <code class="literal">api</code> object stores the closure in a variable and you didn't use a weak reference to <code class="literal">self</code>, you might have a reference cycle. If the <code class="literal">api</code> object itself is held onto by another object, you can be pretty sure that a reference cycle is created.</p><p> </p><p>Making the reference <code class="literal">weak</code> tells the app that the reference to <code class="literal">self</code> does not add up to the reference count of <code class="literal">self</code>. This means that if there are only weak references left to an object, it's OK to deallocate it and free the memory. Memory management and reference counts aren't simple. One way to think about this subject is that your app has an internal count of the number of objects that point to another object. For instance, if you create an instance of <code class="literal">UIView</code> inside of <code class="literal">UIViewController</code>, the reference count for <code class="literal">UIView</code> is one. When <code class="literal">UIViewController</code> is deallocated, the reference count for <code class="literal">UIView</code> becomes zero because the view controller doesn't use it anymore, meaning that it can be deallocated safely.</p><p>If <code class="literal">UIView</code> has a reference to <code class="literal">UIViewController</code> as well, both objects will keep each other around because the reference count for each instance won't ever reach zero. This is called a reference cycle. This cycle can be broken by marking at least one of the references as a <code class="literal">weak</code> reference. Since <code class="literal">weak</code> references don't contribute to the reference count, they prevent reference cycles from happening. This is how Apple has made sure that <code class="literal">tableView</code> does not create a reference cycle with its delegate or data source; the references to these objects are marked as <code class="literal">weak</code>.</p><p>As an alternative to making a reference <code class="literal">weak</code>, you can mark it as <code class="literal">unowned</code>. While weak is essentially a safe optional value, unowned makes the object implicitly unwrapped. It's often best to take the safe route and mark a captured reference as weak because your app won't crash if the <code class="literal">weak</code> referenced instance has been deallocated somehow, while it would crash if the reference is <code class="literal">unowned</code>.</p><p>Reference cycles aren't easy to understand, especially if you take into account weak references and reference-counting. It's really easy to get confused about this topic. Luckily, the <strong class="userinput"><code>Mosaic</code></strong> app contains a couple of issues with references and retain cycles so you can immediately put your newly acquired knowledge to the test.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch24lvl2sec130"></a>Discovering memory leaks</h3></div></div></div><p>To figure out why the <span>memory</span><a id="id325580740" class="indexterm"></a> usage of <strong class="userinput"><code>Mosaic</code></strong> increases every time a new screen is loaded in the app, you should profile the app using the Allocations Instruments template. When you've started a new Allocations profiling session, navigate through the app and you should see the memory usage graph rise consistently. This behavior is typical for a memory leak, so it's time to dig in deeper to figure out what exactly is going on that causes this to happen. Take a look at the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/a899bd00-36e6-4bf0-8a89-1a051610b152.png" /></div><p>If you look at the detail area in Instruments, there is a lot of information there that does not make a lot of sense. A lot of the objects that are created are not objects that you explicitly wanted to create, which makes it hard to figure out what's causing the <span>memory</span><a id="id325580763" class="indexterm"></a> problem. It's not very likely to be an issue with UIKit, for instance, and even if it is, you can't quite fix that. Luckily, you can use the search dialog in the top-right corner of the detail area to look for objects that do belong to the application code, giving you insight into what's happening with the objects that get created by the application code.</p><p>If you type the word <strong class="userinput"><code>Mosaic</code></strong> in the search box, you'll find a couple of objects, and they should all look familiar to you. In the detail area, you can now see the number of instances of a particular object that is in memory. Refer to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/3a672a10-ba50-475b-a1cc-abb7b8cc1e97.png" /></div><p> </p><p> </p><p>If you look closely, you'll find that there are way more collection view cells, collection view controllers, and collection view layouts present than you'd expect. The app can only show one collection view at a time, and when you navigate back to the list view controller, you would assume the collection view controller to be deallocated since nothing should be referencing it anymore.</p><p>When you segue to one of the collection view controllers, it's added to the <code class="literal">viewControllers</code> array on the navigation controller. This means that the navigation controller keeps a reference to each of the view controllers that are part of the navigation stack. This means that none of the view controllers in that list should be deallocated because the reference count is at least <strong class="userinput"><code>1</code></strong>.</p><p>When you pop back to the list view controller, the navigation controller removes the collection view controller from its <code class="literal">viewControllers</code> array. The result of this is that the reference count for the collection view controller is now decremented by one since the navigation controller is not referencing it anymore. This should put the reference count at 0, meaning that the collection view controller can be deallocated and the <span>memory</span><a id="id325580810" class="indexterm"></a> should be freed up.</p><p>However, something is preventing this from happening, because the collection view controller remains allocated according to the observations in Instruments. Unfortunately, Instruments does not tell you much more than the information just saw. Objects are sticking around for too long, which means that a reference cycle exists somewhere. This probably means that something is referencing the collection view controller and in turn, the collection view controller is referencing something else.</p><p>To figure out what's going on, you should probably start looking for problems in the collection view controller. The collection view controller has a delegate relationship with an object conforming to <code class="literal">ListCollectionDelegate</code>. It also acts as a delegate for the list collection view cells it displays, and it's also a delegate for the detail view. All the delegate relationships are references to other objects. These delegates could very well be causing the reference cycle. You can use Xcode to visualize all the objects in memory and see how they relate to each other. This means that it's possible to capture the state of the app's memory after browsing to several collection views, and you can see which objects are holding references to other objects. This enables you to visually identify reference cycles instead of blindly guessing.</p><p> </p><p>To visualize your app's memory usage, build and run the app in Xcode and navigate to a couple of collection views. Then open the memory view in the Debug navigator in Xcode and click the <span class="strong"><strong>Debug Memory Graph</strong></span> button in the bottom toolbar of the screen:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/1f7f50ca-9b2d-4e72-ac61-840884b2b219.png" /></div><p>After clicking this button, Xcode will show you a visual representation of all the <span>memory</span><a id="id325580848" class="indexterm"></a> that your app is using. In the toolbar on the left side of the screen, look for <code class="literal">ListCollectionViewCell</code> and click it. Xcode will show you the relationship between <code class="literal">ListCollectionViewCell</code> and other objects. At first glance, nothing unusual is happening. There is a list view controller, which holds a reference to a collection view, then there are a couple of other objects, and finally there's the collection view cell:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/4d3099ed-7280-4762-92c7-5f1ae667cd8a.png" /></div><p> </p><p>Next, click the collection view controller. When you click it, two <span>different</span><a id="id325580878" class="indexterm"></a> views could be shown to you. One of these two shows a couple of collection view cells pointing to the collection view controller and there should be a navigation controller in the graph as well:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/237ce1b6-204c-4945-8bf2-53f226732bea.png" /></div><p> </p><p> </p><p>The other situation you might see is slightly different. It also has all the <span>cells</span><a id="id325580904" class="indexterm"></a> pointing to the collection view controller, but the navigation controller is nowhere to be found, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/f64e7c76-c034-4075-87ce-c006b916ecca.png" /></div><p>This is pretty typical for a reference cycle. Objects that should be long gone stick around because somewhere, somehow, they are keeping references to each other. The memory graph reveals that the delegate relationship between the collection view controller and the collection view <span>cells</span><a id="id325580924" class="indexterm"></a> could very well be causing problems, you can begin fixing them.</p><p>In this case, the fix is pretty simple. You need to make the delegate relationship between the cell and the controller <code class="literal">weak</code>. Do this by opening <code class="literal">ListCollectionViewCell.swift</code> and changing the delegate declaration as shown:</p><pre class="programlisting">weak var delegate: CollectionItemDelegate?</pre><p> </p><p> </p><p> </p><p> </p><p>Marking the delegate as weak breaks the reference cycle because the references aren't strong anymore. This essentially tells our app that it's OK if the referenced object is deallocated. One final adjustment you must make is to constrain <code class="literal">CollectionItemDelegate</code> to class instances only. Due to the nature of value types, such as structs, you can't mark references to them as <code class="literal">weak</code>, and since protocols can be adopted by both value and reference types, the protocol must be constrained to class instances only. Update the declaration for the <code class="literal">CollectionItemDelegate</code> protocol as shown:</p><pre class="programlisting">protocol CollectionItemDelegate: class</pre><p>If you run the app now, you can safely navigate around and both the memory debugger and Instruments will prove that you no longer have any reference cycles in your app. It's possible that Instruments still tells you that your memory usage is growing. Don't worry about this too much; you did your job making sure that your code is safe and that all memory that you don't use anymore can be freed up.</p><p>The example of a reference cycle you just saw is a very common one. A common way to avoid reference cycles in delegates is to try to make all of your delegates weak by default. This prevents you from making mistakes that you might not catch right away and it's often the safest route to go. Do note that there are many ways in which a reference cycle can occur, and you should always use the appropriate tools to troubleshoot your memory issues.</p><p>Let's wrap up this exploration of Instruments by creating an Instrument of your own.</p></div></div>