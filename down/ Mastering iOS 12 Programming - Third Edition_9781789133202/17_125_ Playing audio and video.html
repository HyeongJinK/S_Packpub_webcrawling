<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch17lvl1sec117"></a>Playing audio and video</h2></div></div><hr /></div><p>To make playing <span>audio</span><a id="id325333116" class="indexterm"></a> and <span>video</span><a id="id325575035" class="indexterm"></a> files as simple and straightforward as can be, Apple has created the <code class="literal">AVFoundation</code> framework. This framework contains a lot of helper classes that provide very low-level control over how iOS plays audio and video files. You can use <code class="literal">AVFoundation</code> to build a rich, custom media player with as many features as you need for your purpose.</p><p>If you're looking for a simpler way to integrate media into your app, the <code class="literal">AVKit</code> framework might be what you need. <code class="literal">AVKit</code> contains several helpers that build upon the <code class="literal">AVFoundation</code> components to provide an excellent default player that supports many features like subtitles, Airplay, and more.</p><p>In this section, you will learn how to implement a simple video player with the <code class="literal">AVPlayerViewController</code> from the <code class="literal">AVKit</code> framework. You will also implement a more complex audio player with <code class="literal">AVFoundation</code> components that plays audio in the background and displays,  on the lock screen, the audio track currently being played.</p><p>To follow along with the samples, you should open the <code class="literal">MediaPlayback_start</code> project in this chapter's code bundle. The starter app contains a straightforward interface with a tab bar and two pages. You will implement a video player on one page, and the audio player on the other page. The audio page comes with some predefined controls and actions that you will implement later.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch17lvl2sec91"></a>Creating a simple video player</h3></div></div></div><p>The first thing you need to do to implement a <span>video</span><a id="id325581270" class="indexterm"></a> player is to obtain a video file. You can use any video that is encoded in the <code class="literal">h.264</code> format. A good sample video is the <strong class="userinput"><code>Big Buck Bunny</code></strong> sample movie that was created by the Blender Foundation. You can find this video at the following URL: <a class="ulink" href="http://bbb3d.renderfarming.net/download.html" target="_blank">http://bbb3d.renderfarming.net/download.html</a>. If you want to use this video to practice with, make sure to download the 2D version of the video.</p><p>As stated before, you will implement the video player using the <code class="literal">AVPlayerViewController</code>. This view controller provides a convenient wrapper around several components from <code class="literal">AVFoundation</code>, and also provides default video controls, so you don't have to build your entire video player from scratch, as you will do for the audio player later.</p><p>The <code class="literal">AVPlayerViewController</code> is highly configurable, which means that you can choose whether the player supports Airplay, shows playback controls, whether it should be full screen when a video plays, and more. For a complete list of configurable options, you can refer to Apple's <code class="literal">AVPlayerViewController</code> documentation.</p><p>Once you have found your test video, you should add it to the <strong class="userinput"><code>MediaPlayback</code></strong> project and ensure that the <span>video</span><a id="id325581313" class="indexterm"></a> is added to the app target. After doing this, open <code class="literal">VideoViewController.swift</code> and add the following line to import <code class="literal">AVKit</code>:</p><pre class="programlisting">import AVKit</pre><p>You should also add a property to <code class="literal">VideoViewController</code> to hold on to your video player instance. Add the following line to the <code class="literal">VideoViewController</code> class to do this:</p><pre class="programlisting">let playerController = AVPlayerViewController()</pre><p>Since the <code class="literal">AVPlayerViewController</code> is a <code class="literal">UIViewController</code> subclass, you should add it to the <code class="literal">VideoViewController</code> as a child view controller. Doing this will make sure that <code class="literal">VideoViewController</code> forwards any view controller lifecycle events, such as <code class="literal">viewDidLoad()</code>, along with any changes in trait collections and more to the video player. To do this, add the following code to the <code class="literal">viewDidLoad()</code> method in <code class="literal">VideoViewController</code>:</p><pre class="programlisting">// 1
addChild(playerController)
playerController.didMove(toParent: self)

// 2
view.addSubview(playerController.view)

let playerView = playerController.view!
playerView.translatesAutoresizingMaskIntoConstraints = false

NSLayoutConstraint.activate([
  playerView.widthAnchor.constraint(equalTo: view.widthAnchor, constant: -20),
  playerView.heightAnchor.constraint(equalTo: playerView.widthAnchor, multiplier: 9/16),
  playerView.centerXAnchor.constraint(equalTo: view.centerXAnchor),
  playerView.centerYAnchor.constraint(equalTo: view.centerYAnchor)])    </pre><p>The previous code snippet adds the video player to the video view controller as a child view controller. When you add a view controller as a child view controller, you must always call <code class="literal">didMove(toParent:)</code> on the child controller to make sure it knows that it has been added as a child view controller to another view controller. After adding the video player as a child view controller, the video player's view is added as a subview for the video view controller, and some constraints are set up to position the player view.</p><p>This is all you need to do to create an instance of the video player and make it appear in your view controller. The last step is to obtain a reference to your video file, create an <code class="literal">AVPlayer</code> that has a reference to the video file, and assign it to the player. Add the following code to do this:</p><pre class="programlisting">let url = Bundle.main.url(forResource: "samplevideo", withExtension: "mp4")!
playerController.player = AVPlayer(url: url)</pre><p>The preceding code looks for a video file called <code class="literal">samplevideo.mp4</code> and obtains a URL for that file. It then creates an instance of <code class="literal">AVPlayer</code> that points to that video file, and assigns it to the <span>video</span><a id="id325580683" class="indexterm"></a> player. The <code class="literal">AVPlayer</code> object is responsible for actually playing the video file. The <code class="literal">AVPlayerViewController</code> instance uses the <code class="literal">AVPlayer</code> instance to play the video, and manages the actual playback of the video internally.</p><p>If you run your app after adding the player this way, you will find that the video plays perfectly well, and that you have access to all the controls you might need. This is a great demonstration of how simple it is to add basic media integration to your app. The next step is a little more complex. You will directly use an <code class="literal">AVAudioPlayer</code> instance to play an audio file that is controlled through several custom media controls. The player will even play audio in the background and integrate with the lock screen to show information about the current file. In other words, you will build a simple audio player that does everything a user would expect it to do.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch17lvl2sec92"></a>Creating an audio player</h3></div></div></div><p>Before you can implement your <span>audio</span><a id="id325580748" class="indexterm"></a> player, you will need to obtain some <code class="literal">.mp3</code> files you wish to use in your player. If you don't have any audio files on your computer, you can get some files from The Free Music Archive website, available at <a class="ulink" href="https://freemusicarchive.org/about" target="_blank">https://freemusicarchive.org/about</a>, to obtain a couple of free songs that you would like to use for playback. Make sure to add them to the <strong class="userinput"><code>MediaPlayer</code></strong> Xcode project and ensure that they are included in the app target.</p><p>You will build the audio player using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Implementing the necessary controls to start and stop the player, and navigate to the next and previous songs.</li><li>Implementing the time scrubber.</li><li>Reading the file's metadata and show it to the user.</li></ol></div><p>The user interface, outlets, and actions are already set up, so make sure to familiarize yourself with the existing code before following along with the implementation of the audio player.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch17lvl3sec40"></a>Implementing basic audio controls</h4></div></div></div><p>Before you implement the <span>audio</span><a id="id325580790" class="indexterm"></a> player code, you will need to do a little bit of housekeeping. To be able to play audio, you need a list of the files that the player will play. In addition to this list, you also need to keep track of what song the user is currently playing, so you can determine the next and previous songs. Lastly, you also need to have the audio player itself. Instead of using a pre-built component, you will build your own audio player using an <code class="literal">AVAudioPlayer</code> object. The <code class="literal">AVAudioPlayer</code> is perfect for implementing a simple audio player that plays a couple of local <code class="literal">.mp3</code> files. It offers some convenient helper methods to easily adjust the player's volume, seek to a specific timestamp in the song, and more.</p><p>Define the following properties in <code class="literal">AudioViewController.swift</code>:</p><pre class="programlisting">let files = ["one", "two", "three"]
var currentTrack = 0
var audioPlayer: AVAudioPlayer!</pre><p>Make sure to replace the <code class="literal">files</code> array with the filenames that you use for your own audio files. The <code class="literal">audioPlayer</code> does not have a value yet at this point. You will set up the audio player next.</p><p>Before you can play audio, you need to obtain a reference to a media file and provide this reference to an <code class="literal">AVAudioPlayer</code> object. Any time you want to load a new media file, you will have to create a new instance of the audio player, since you can't change the current file once a file is playing. Add the following helper method to the <code class="literal">AudioViewController</code> to load the current track and create an <code class="literal">AVAudioPlayer</code> instance:</p><pre class="programlisting">func loadTrack() {
  let url = Bundle.main.url(forResource: files[currentTrack], withExtension: "mp3")!
  audioPlayer = try! AVAudioPlayer(contentsOf: url)
  audioPlayer.delegate = self
}</pre><p>This method reads the file name for the current track and retrieves the local URL for it. This URL is then used to create and set the<code class="literal">audioPlayer</code>property on the<code class="literal">AudioViewController</code>. The view controller is also assigned as the delegate for the<span>audio</span><a id="id325580853" class="indexterm"></a>player. You won't implement any of the delegate methods just yet, but you can add the following extension to make<code class="literal">AudioViewController</code>conform to the<code class="literal">AVAudioPlayerDelegate</code>protocol to ensure your code compiles:</p><pre class="programlisting">extension AudioViewController: AVAudioPlayerDelegate {

}</pre><p>You will implement one of the <code class="literal">AVAudioPlayerDelegate</code> methods when you add support for navigating to the next and previous tracks.</p><p>Add the following two methods to the audio view controller to add support for playing and pausing the current audio file:</p><pre class="programlisting">func startPlayback() {
  audioPlayer.play()
  playPause.setTitle("Pause", for: .normal)
}

func pausePlayback() {
  audioPlayer.pause()
  playPause.setTitle("Play", for: .normal)
}</pre><p>These methods are relatively straightforward. They call the audio player's <code class="literal">play()</code> and <code class="literal">pause()</code> methods and update the button's label, so it reflects the current player state. Add the following implementation for <code class="literal">playPauseTapped()</code> so the play and pause methods get called when the user taps the play/pause button:</p><pre class="programlisting">@IBAction func playPauseTapped() {
  if audioPlayer.isPlaying {
    pausePlayback()
  } else {
    startPlayback()
  }
}</pre><p>If you run the app now, you can tap the play/pause button to start and stop the currently playing file. Make sure your device is not in silent mode, because the audio for your app is muted when the device is in silent mode. You will learn how to fix this when you implement the ability to play <span>audio</span><a id="id325580907" class="indexterm"></a> in the background. The next step is to add support for playing the next and previous tracks. Add the following two implementations to <code class="literal">AudioViewController</code> to do this:</p><pre class="programlisting">@IBAction func nextTapped() {
  currentTrack += 1
  if currentTrack &gt;= files.count {
    currentTrack = 0
  }
  loadTrack()
  audioPlayer.play()
}

@IBAction func previousTapped() {
  currentTrack -= 1
  if currentTrack &lt; 0 {
    currentTrack = files.count - 1
  }
  loadTrack()
  audioPlayer.play()
}</pre><p>The preceding code adjusts the current track index, loads the new track, and immediately plays it. Note that every time the user taps on the next or previous button, a fresh audio player has to be created by calling <code class="literal">loadTrack()</code>. If you run the app now, you can play audio, pause it, and skip to the next or previous tracks.</p><p>When you allow a full song to play, it won't yet advance to the next song afterward. To implement this, you need to add an implementation for the <code class="literal">audioPlayerDidFinishPlaying(_:successfully:)</code> method from <code class="literal">AVAudioPlayerDelegate</code>. Add the following implementation to call <code class="literal">nextTapped()</code>, so the next song automatically plays when the current song finishes:</p><pre class="programlisting">func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
  nextTapped()
}</pre><p>Now that the first features are implemented, the next step is to implement the time scrubber that shows the current song's progress and allows the user to adjust the playhead's position.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch17lvl3sec41"></a>Implementing the time scrubber</h4></div></div></div><p>The user interface for the <span>audio</span><a id="id325333180" class="indexterm"></a> player app already contains a scrubber that is hooked up to the following three actions in the view controller:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">sliderDragStart()</code></li><li style="list-style-type: disc"><code class="literal">sliderDragEnd()</code></li><li style="list-style-type: disc"><code class="literal">sliderChanged()</code></li></ul></div><p>When an audio file is playing, the scrubber should automatically update to reflect the current position in the song. However, when a user starts dragging the scrubber, it should not update its position until the user has chosen the scrubber's new position. When the user is done dragging the scrubber, it should adjust itself based on the song's progress again. Any time the value for the slider changes, the audio player should adjust the playhead, so the song's progress matches that of the scrubber.</p><p>Unfortunately, the <code class="literal">AVAudioPlayer</code> object does not expose any delegate method to observe the progress of the current audio file. To update the scrubber regularly, you can implement a timer that updates the scrubber to the audio player's current position every second. Add the following property to the <code class="literal">AudioViewController</code>, so you can hold on to the timer after you have created it:</p><pre class="programlisting">var timer: Timer?</pre><p>Also, add the following two methods to <code class="literal">AudioViewController</code> as a convenient way to start the timer when the user starts dragging the scrubber, or when a file starts playing, and stop it when a user starts dragging the scrubber or to preserve resources when the playback is paused:</p><pre class="programlisting">func startTimer() {
  timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [unowned self] timer in
    self.slider.value = Float(self.audioPlayer.currentTime / self.audioPlayer.duration)
  }
}

func stopTimer() {
  timer?.invalidate()
}</pre><p>Add a call to <code class="literal">startTimer()</code> in the <code class="literal">startPlayback()</code> method and a call to <code class="literal">stopTimer()</code> in the <code class="literal">stopPlayback()</code> method. If you run the app after doing this, the scrubber will immediately begin updating its position when a song starts playing. However, scrubbing does not work yet. Add the following implementations for the scrubber actions to enable manual scrubbing:</p><pre class="programlisting">@IBAction func sliderDragStart() {
  stopTimer()
}

@IBAction func sliderDragEnd() {
  startTimer()
}

@IBAction func sliderChanged() {
  audioPlayer.currentTime = Double(slider.value) * audioPlayer.duration
}</pre><p>The preceding methods are relatively simple, but they provide a very powerful feature that immediately makes your homemade audio player feel like an audio player you might use every day. The final step for implementing the audio player's functionality is to display metadata about the current song.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch17lvl3sec42"></a>Displaying song metadata</h4></div></div></div><p>Most <code class="literal">.mp3</code> files contain metadata in the form of <code class="literal">ID3</code> tags. These metadata tags are used by applications such as iTunes to extract information about a song and display it to the user, as well as to categorize a music library or filter it. You can gain access to an audio file's metadata through code, by loading the <span>audio</span><a id="id325333262" class="indexterm"></a> file into an <code class="literal">AVPlayerItem</code> object and extracting the metadata for its internal <code class="literal">AVAsset</code> instance. An <code class="literal">AVAsset</code> object contains information about a media item, such as its type, location, and more. When you load a file using an <code class="literal">AVPlayerItem</code> object, it will automatically create a corresponding <code class="literal">AVAsset</code> object for you.</p><p>A single asset can contain loads of metadata in the metadata dictionary. Luckily, Apple has captured all of the valid <code class="literal">ID3</code> metadata tags in the <code class="literal">AVMetadataIdentifier</code> object, so once you have extracted the metadata for an <code class="literal">AVAsset</code>, you can loop over all of its metadata to filter out the data you need. The following method does this, and sets the <span>extracted</span><a id="id325333303" class="indexterm"></a> values on the <code class="literal">titleLabel</code> variable of <code class="literal">AudioViewController</code>, as shown here:</p><pre class="programlisting">func showMetadataForURL(_ url: URL) {
  let mediaItem = AVPlayerItem(url: url)
  let metadata = mediaItem.asset.metadata
  var information = [String]()

  for item in metadata {
    guard let identifier = item.identifier
      else { continue }

    switch identifier {
    case .id3MetadataTitleDescription, .id3MetadataBand:
      information.append(item.value?.description ?? "")
    default:
      break
    }
  }

  let trackTitle = information.joined(separator: " - ")
  titleLabel.text = trackTitle
}</pre><p>Make sure to add a call to this method from <code class="literal">loadTrack()</code>, and pass the audio file's URL that you obtain in <code class="literal">loadTrack()</code> to <code class="literal">showMetadataForURL(_:)</code>. If you run your app now, your basic functionality should be all there. The metadata should be shown correctly, the scrubber should work, and you should be able to skip songs or pause the playback.</p><p>Even though your media player seems to be pretty much done at this point, did you notice that the music pauses when you send the app to the background? To make your app feel more like a real audio player, you should implement background audio playback and make sure the currently playing song is presented on the user's lock screen, similar to how the native music app for iOS works. This is precisely the functionality you will add next.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch17lvl2sec93"></a>Playing media in the background</h3></div></div></div><p>On iOS, playing <span>audio</span><a id="id325333342" class="indexterm"></a> in the background requires special permissions that you can enable in your app's <strong class="userinput"><code>Capabilities</code></strong> tab. If you enable the <strong class="userinput"><code>Background modes</code></strong> capability, you can select the <strong class="userinput"><code>Audio</code></strong>, <strong class="userinput"><code>Airplay</code></strong>, and <strong class="userinput"><code>Picture in Picture</code></strong> option to make your app eligible for playing audio in the background. The following screenshot shows the enabled capability for playing audio in the background:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/69cda6da-3c41-45be-99f9-69f71d880992.png" /></div><p>If you want to add proper support for background <span>audio</span><a id="id325333414" class="indexterm"></a> playback, there are three features you need to implement:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Set up an audio session, so audio continues playing in the background.</li><li style="list-style-type: disc">Submit metadata to the "now playing" info center.</li><li style="list-style-type: disc">Respond to playback actions from remote sources, such as the lock screen.</li></ul></div><p>You can set up the audio session for your app with just two lines of code. When you create an audio session, iOS will treat the audio played by your app slightly differently. For instance, your songs will play even if the device is set to silent. It also makes sure your audio is played when your app is in the background, if you have the proper capabilities set up. Add the following code to <code class="literal">viewDidLoad()</code> to set up an audio session for the app:</p><pre class="programlisting">try? AVAudioSession.sharedInstance().setCategory(.playback, mode: .default, options: [.allowAirPlay])
try? AVAudioSession.sharedInstance().setActive(true, options: [])</pre><p>The second feature to add is to supply information about the currently playing track. All information about the currently playing media file should be passed to the <code class="literal">MPNowPlayingInfoCenter</code> object. This object is part of the <code class="literal">MediaPlayer</code> framework, and is responsible for showing the user information about the currently playing media file on the lock screen and in the command center. Before you pass information to the "now playing" info center, make sure to import the <code class="literal">MediaPlayer</code> framework at the top of the <code class="literal">AudioViewController.swift</code> file.</p><p>Next, add the following line of code to <code class="literal">viewDidLoad()</code>:</p><pre class="programlisting">NotificationCenter.default.addObserver(self, selector: #selector(updateNowPlaying), name: UIApplication.didEnterBackgroundNotification, object: nil)</pre><p>In the documentation for <code class="literal">MPNowPlayingInfoCenter</code>, Apple states that you should always pass the most recent now playing information to the info center when the app goes to the background. To do this, the <span>audio</span><a id="id325333473" class="indexterm"></a> view controller should listen to the <code class="literal">UIApplication.didEnterBackgroundNotification</code> notification, so it can respond to the app going to the background. Add the following implementation for the <code class="literal">updateNowPlaying()</code> method to the <code class="literal">AudioVideoController</code>:</p><pre class="programlisting">@objc func updateNowPlaying() {
  var nowPlayingInfo = [String: Any]()
  nowPlayingInfo[MPMediaItemPropertyTitle] = titleLabel.text ?? "untitled"
  nowPlayingInfo[MPNowPlayingInfoPropertyElapsedPlaybackTime] = audioPlayer.currentTime
  nowPlayingInfo[MPMediaItemPropertyPlaybackDuration] = audioPlayer.duration

  MPNowPlayingInfoCenter.default().nowPlayingInfo = nowPlayingInfo
}</pre><p>The preceding code configures a dictionary with metadata about the currently playing file, and passes it to the "now playing" info center. This method is called automatically when the app goes to the background, but you should also update the "now playing" information when a new song begins playing. Add a call to <code class="literal">updateNowPlaying()</code> in the <code class="literal">loadTrack()</code> method to make sure the "now playing" information is updated whenever a new track is loaded.</p><p>The next and final step is to respond to remote commands. When the user taps the play/pause button, next button, or previous button on the lock screen, this is sent to your app as a remote command. You should explicitly define the handlers that should be called by iOS when a remote command occurs. Add the following method to <code class="literal">AudioViewController</code> to add support for remote commands:</p><pre class="programlisting">func configureRemoteCommands() {
  let commandCenter = MPRemoteCommandCenter.shared()

  commandCenter.playCommand.addTarget { [unowned self] event in
    guard self.audioPlayer.isPlaying == false
      else { return .commandFailed }

    self.startPlayback()
    return .success
  }

  commandCenter.pauseCommand.addTarget { [unowned self] event in
    guard self.audioPlayer.isPlaying
      else { return .commandFailed }

    self.pausePlayback()
    return .success
  }

  commandCenter.nextTrackCommand.addTarget { [unowned self] event in
    self.nextTapped()
    return .success
  }

  commandCenter.previousTrackCommand.addTarget { [unowned self] event in
    self.previousTapped()
    return .success
  }

  UIApplication.shared.beginReceivingRemoteControlEvents()
}</pre><p>The preceding code obtains a reference to the remote command center and registers several handlers. It also calls <code class="literal">beginReceivingRemoteControlEvents()</code> on the application object to make sure it receives remote commands. Add a call to <code class="literal">configureRemoteCommands()</code> in <code class="literal">viewDidLoad()</code>, to make sure that the app begins receiving remote commands as soon as the <span>audio</span><a id="id325333526" class="indexterm"></a> player is configured.</p><p>Try to run your app and send it to the background. You should be able to control media playback from both the control center and the lock screen. The visible metadata should correctly update when you skip to the next or previous song, and the scrubber should accurately represent the current position of playback in the song.</p><p>At this point, you have implemented a reasonably complete audio player that has pretty sophisticated behaviors. The next step in your exploration of media on iOS is to discover how you can take pictures and record video.</p></div></div>