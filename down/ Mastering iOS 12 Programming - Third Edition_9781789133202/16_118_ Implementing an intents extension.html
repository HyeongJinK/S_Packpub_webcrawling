<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch16lvl1sec111"></a>Implementing an intents extension</h2></div></div><hr /></div><p>There are several ways for apps to <span>integrate</span><a id="id325333116" class="indexterm"></a> with iOS. These integrations are always built using app extensions. An app extension is an isolated section of your app that can be instantiated and used by the system as needed to provide certain functionality for users. In iOS 12, there are 25 different ways for apps to integrate with iOS. Not every app can or should implement every possible extension, but a proper integration with iOS can truly make your app stand out. The following screenshot shows a selection of available extensions in iOS 12:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/8d862cc2-2eb2-4c8d-a614-cf972aca0f38.png" /></div><p>In this chapter, you will implement an <strong class="userinput"><code>Intents Extension</code></strong> and an <strong class="userinput"><code>IntentUI Extension</code></strong>. These extensions are used to communicate with Siri and to provide a custom UI for the Siri integration. Before you implement your extensions, let's see what extensions are and how they work.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl2sec85"></a>Understanding app extensions</h3></div></div></div><p>As mentioned before, extensions are used by apps to <span>integrate</span><a id="id325333153" class="indexterm"></a> with iOS. Some extensions have their own UI, such as the <strong class="userinput"><code>IntentUI Extension</code></strong>, and others have no UI at all, such as the <strong class="userinput"><code>Intents Extension</code></strong>. Every extension has its own purpose and specializes in performing a single task.</p><p>When an extension is opened or instantiated, this happens through the extension framework itself. For instance, if you open a photo in the <strong class="userinput"><code>Photos</code></strong> app and you tap the share option, you can choose several to choose the selected photo too. If you select one of these apps, its <strong class="userinput"><code>Share Extension</code></strong> is launched. This extension then provides its own UI that is used to share the photo in a way that is supported by the share target. The following screenshot is an example of this:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/78184d70-2c1c-4cce-838d-a2c32e3c0bd7.png" /></div><p></p><p>In the preceding screenshot, a photo is shared to the <strong class="userinput"><code>Notes</code></strong> app. The Notes app itself does not launch or own the extension. This means that an extension functions completely separately from its host application. Instead, the extensions framework is responsible for managing the extension's life cycle. Because of this, extensions do not work like individual apps. Extensions usually only have a single view controller, and you have to rely on the <code class="literal">UIViewController</code> life cycle methods to configure your extension. This might seem a little bit counter-intuitive at <span>first</span><a id="id325356899" class="indexterm"></a> because, as you'll find out in a moment, extensions have their own build target and <code class="literal">Info.plist</code>, which makes them look a lot like a separate app, while they behave more like a view controller.</p><p>Extensions are added to an app through the <strong class="userinput"><code>Project</code></strong> window. If you look at the sidebar in the center window, you can see your project name and the <strong class="userinput"><code>Targets</code></strong> associated with your project. Each of these targets produces its own build product. The app target produces your app itself, for instance. You can use the <span class="strong"><strong>+</strong></span> icon at the bottom of the sidebar to add a new target to your app. Go ahead and add an extension for the Hairdressers app. Make sure to select the <strong class="userinput"><code>Intents Extension</code></strong> option and check the <strong class="userinput"><code>Include UIExtension</code></strong> checkbox as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/89727267-575a-46cd-ad0c-26139b337ef3.png" /></div><p></p><p>Now that you have an understanding of app extensions, let's see how you can implement your own <strong class="userinput"><code>Intents Extension</code></strong> to integrate the Hairdressers app with Siri.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl2sec86"></a>Configuring your extension</h3></div></div></div><p>Now that you have added your extensions to the Hairdressers project, it's time to configure the app so it can <span>integrate</span><a id="id325571678" class="indexterm"></a> with Siri. Go through the following steps to properly configure your app:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Make sure you're using a paid developer team, and make sure the app uses this paid <span>team</span> by selecting it in the project settings.</li><li style="list-style-type: disc">Enable the Siri capability in the <strong class="userinput"><code>Capabilities</code></strong> tab.</li><li style="list-style-type: disc">Add the required Privacy key to the app's <code class="literal">Info.plist</code> file.</li></ul></div><p>After configuring the project, the first step to integrate your app with Siri is to ask the user for permission to do so. Open <code class="literal">AppointmentsViewController.swift</code> and import the <code class="literal">Intents</code> framework at the top of the file as follows:</p><pre class="programlisting">import Intents</pre><p>You might have expected all of the Siri-related code to exist in the <code class="literal">SiriKit</code> framework. Instead, some parts of the Siri integration live in the <code class="literal">Intents</code> framework, because some other apps, like the <strong class="userinput"><code>Maps</code></strong> app on iOS, use intents to determine what action a user wants to perform.</p><p>After adding the import, add the following implementation for <code class="literal">viewDidAppear(_:)</code> to <code class="literal">AppointmentsViewController</code>:</p><pre class="programlisting">override func viewDidAppear(_ animated: Bool) {
  super.viewDidAppear(animated)

  INPreferences.requestSiriAuthorization { status in
    print(status == .authorized)
  }
}</pre><p>This preceding code asks for permission to use Siri in this app as soon as possible, just like Apple recommends. If permission is already granted, the permissions dialog won't be displayed, so there is no need to check for the current status prior to asking permission. For now, you have done all the required work in the app.</p><p>If you open the <code class="literal">MessageHairdresserIntent</code> folder that Xcode created when you added the extension earlier, you should see that there are two files in there: a file named <code class="literal">IntentHandler.swift</code>, and the app extension's <code class="literal">Info.plist</code>. The <code class="literal">IntentHandler</code> class is responsible for communicating with Siri to resolve, confirm, and handle the intents for which the extension is registered. The <code class="literal">Info.plist</code> is used to determine which intents can be handled by the extension.</p><p>Open the <code class="literal">Info.plist</code> file and expand the <code class="literal">NSExtension</code> key. You'll notice that <span>there</span><a id="id325580652" class="indexterm"></a> are two intent-related keys in the file: <code class="literal">IntentsRestrictedWhileLocked</code> and <code class="literal">IntentsSupported</code>. The second key contains all of the intents that can be handled by the extension. The <code class="literal">IntentsRestrictedWhileLocked</code> key specifies which of these supported keys can or can't be used without unlocking the device. SiriKit itself will lock some intents by default. Money transfers, for example, can't be done without unlocking the device, regardless of your extension settings:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/49b9f8de-def2-44e5-90b2-4ec4179be7f6.png" /></div><p>The list of intents in <strong class="userinput"><code>IntentsSupported</code></strong> is a list of intent class names that your extension is able to handle. Xcode has added a couple of example intents, but this list is not even close to being an exhaustive list of available intents. For a complete list of available intents, you should have a look at the documentation for the <code class="literal">Intents</code> framework.</p><p>The available intents range from starting a workout, to booking a restaurant reservation or requesting that another person transfers money into your bank account. Each of these intents has their own corresponding class that holds all of the properties that are used to describe the intent.</p><p>To enable message sending in Hairdressers, only the <code class="literal">INSendMessageIntent</code> is required, so you can remove the other two intents. If you want to experiment with multiple intents from the get-go, you can keep any intents that you want to play around with, or add more, if you like!</p><p>Even though Siri is quite smart when it comes to <span>resolving</span><a id="id325580699" class="indexterm"></a> intents, some apps have their own terminology for specific actions. Custom terms make resolving intents a lot harder for Siri. Luckily, you can help Siri out by adding vocabulary information to Siri.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl2sec87"></a>Adding vocabularies to your app</h3></div></div></div><p>Siri always makes an effort to understand what a user is trying to do with an app and is usually quite good at this. However, sometimes it's tough for Siri to figure out what's going on or what a user is trying to do. To help Siri figure out what a user might mean, you can provide vocabularies. A <strong class="userinput"><code><span>vocabulary</span><a id="id325580715" class="indexterm"></a></code></strong> is a set of strings that map to intents, or to parameters for the intent.</p><p>There are two ways for you to teach Siri the vocabulary for your app. One way is through a <code class="literal">.plist</code> file. This approach is mostly used for when your app has a global vocabulary that applies to all users. If your app can't supply all custom vocabularies in a static file, you can provide them dynamically. This is particularly useful if, for instance, you want to teach Siri about contacts in a messaging app.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch16lvl3sec35"></a>Adding vocabularies through a .plist file</h4></div></div></div><p>You already learned that Siri understands when a user wants to do something with your application, even if your user uses your app name as a verb. However, your app name might not be the only thing that's specific to your app. Let's see how this works for a workout app.</p><p>If, for example, a user were to tell Siri, <span class="emphasis"><em>Hey Siri, start an Ultimate Run using RunPotato</em></span>, Siri would be able to figure out what RunPotato is since it's the app that is expected to handle the intent. What it won't be able to understand instantly is what it means to <span class="emphasis"><em>start an</em></span><span><span class="emphasis"><em>Ultimate Run</em></span>.</span> This is where a custom <span>vocabulary</span><a id="id325580750" class="indexterm"></a> entry in a <code class="literal">.plist</code> makes a lot of sense.</p><p>The <code class="literal">.plist</code> that contains the vocabulary should be provided by the application itself; the corresponding extension is not able to do this. You can add a vocabulary of app-specific words, like the workout name above, by adding an extra <code class="literal">.plist</code> file to the app. To add a new <code class="literal">.plist</code> file, add a new file to your app target and select the <strong class="userinput"><code>Property List</code></strong> file type under the <strong class="userinput"><code>Resource</code></strong> header as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/8232dd31-6260-44a6-adcf-5726b701e1c7.png" /></div><p>The file you create must be named <code class="literal">AppIntentVocabulary</code>. This file contains all of the information about an app's custom vocabulary. The vocabulary <code class="literal">.plist</code> is pretty specific and verbose. This is important because its purpose is to provide a window into the vocabulary your app uses. When you created the <code class="literal">AppIntentVocabulary.plist</code> file, Xcode added a dictionary at the top level of the file. All custom <span>vocabulary</span><a id="id325580803" class="indexterm"></a> should be added to that dictionary.</p><p>To implement the example phrase shown earlier, you need a <code class="literal">Parameter Vocabularies</code> array. This array will contain <code class="literal">Parameter Vocabulary</code> items that specify the vocabulary the app uses for workout names. The first item that needs to be defined is a <code class="literal">Parameter Names</code> array. For the workout app, it would contain a single entry: <code class="literal">INStartWorkoutIntent.workoutName</code>. In addition to the parameter names, a <code class="literal">Parameter Vocabulary</code> dictionary must also be added to the entry in the <code class="literal">Parameter Vocabularies</code> array.</p><p>The <code class="literal">Parameter Vocabulary</code> dictionary has keys for the item identifier, synonyms for this identifier, a pronunciation, and even an example phrase. This is all very verbose, but it provides Siri with all of the information it needs to resolve user input for your app. The following screenshot shows an example of the entry that would be needed to make sure Siri understands what an <span class="emphasis"><em>Ultimate Run</em></span> workout is:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/5d716030-67ef-4d1f-92d6-89a0b2db60f7.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch16lvl3sec36"></a>Teaching Siri new vocabularies at runtime</h4></div></div></div><p>The second way you can teach Siri about specific content in your app is through the <code class="literal">INVocabulary</code> class. The <code class="literal">INVocabulary</code> class is used to teach Siri information that is specific to the user or changes over time.</p><p>A great example of user-specific <span>vocabulary</span><a id="id325580868" class="indexterm"></a> is a workout program that your user manually creates inside of your app. Or maybe the user's friends in a messaging app, if those friends don't match the people your user has in their list of contacts on their device.</p><p>Updating the vocabularies for an app always occurs in batches. You don't add or remove individual words or phrases for a specific string type. For example, if your user adds a new workout type to a workout application, or if they add new content in a messaging application, you must update the entire vocabulary for the parameter that the vocabulary applies to. Since the Hairdressers app uses its own list of hairdressers, Siri should learn their names so the users can message them. Add the following code to the <code class="literal">application(_:didFinishLaunchingWithOptions:)</code> method in <code class="literal">AppDelegate</code>, and don't forget to import the <code class="literal">Intents</code> framework, as follows:</p><pre class="programlisting">let hairdressers = NSOrderedSet(array: HairdressersDataSource.hairdressers)
INVocabulary.shared().setVocabularyStrings(hairdressers, of: .contactName)</pre><p>By supplying the contact names vocabulary when the app starts, it's available to Siri as soon as possible, even before the app's first screen is loaded.</p><p>If a user logs out or does something else that makes their custom vocabulary redundant or invalid, you need to make sure you delete the entire user-specific vocabulary by calling <code class="literal">removeAllVocabularyStrings()</code> on the shared <code class="literal">INVocabulary</code> class. This method of teaching vocabulary to Siri is not intended for vocabularies that are common to all users. If a vocabulary is the same for all users of your app, you should provide this vocabulary through the <code class="literal">.plist</code> file that was mentioned earlier. Now that you're completely up to speed regarding intents and vocabularies, let's see how you can start to handle the intents that Siri sends your way.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl2sec88"></a>Handling intents in your extension</h3></div></div></div><p>Handling intents can be divided into three stages. The first <span>stage</span><a id="id325580914" class="indexterm"></a> is the resolving stage. In this stage, your extension will go back and forth with Siri to figure out the correct parameters for the given intent. In this stage, Siri could ask your app to verify that a certain username exists. Your extension will then have to figure out if the given input is valid, and you'll provide Siri with a response code that tells it whether the parameter is resolved, or maybe requires a little bit more clarification on the user's end.</p><p>The second stage is expected to confirm that everything is set up correctly and all requirements for executing the action are met. The third and final stage involves actually acting on the intent and performing the desired action. Let's go through each of stages, one by one.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch16lvl3sec37"></a>Resolving the user's input</h4></div></div></div><p>When you create an intents extension, Xcode creates a <span>single</span><a id="id325580931" class="indexterm"></a> main class for your extension, named <code class="literal">IntentsExtension</code>. This is the class that serves as an entry point for your extension. It contains a <code class="literal">handler(for:)</code> method that returns an instance of <code class="literal">Any</code>. The <code class="literal">Any</code> type indicates that this method can return virtually anything and the compiler will consider it valid. Whenever you see a method signature like this, you should consider yourself on your own. Being on your own means that the Swift compiler will not help you to validate that you've returned the correct type of object from this method.</p><p>In addition to the <code class="literal">handler(for:)</code> method, Xcode has generated a lot of sample code to show how you could implement an intent handler. After quickly studying this code, you can go ahead and remove it, since you'll write your own implementation for this functionality soon.</p><p>The reason the <code class="literal">handler(for:)</code> method returns <code class="literal">Any</code> is because this method is supposed to return a handler for every intent that your app supports. If you're handling a send message intent, the handler is expected to conform to the <code class="literal">INSendMessageIntentHandling</code> protocol. Xcode's default implementation returns <code class="literal">self</code>, and the <code class="literal">IntentHandler</code> class conforms to all of the intents the extension handles by default, according to its plist file.</p><p>This default approach is not inherently wrong, but if you add an intent to your extension and forget to implement a handler method, you might return an invalid object from the <code class="literal">handler(for:)</code> method. A cleaner approach is to check the type of intent you're expected to handle, and return an instance of a class that's specialized to handle the intent. This is more maintainable, and will allow for a cleaner implementation of both the intent handler itself, and the <code class="literal">IntentHandler</code> class.</p><p>Replacing Xcode's default implementation ensures that you always return the correct object for every intent that the Hairdressers app supports. Go ahead and replace the <code class="literal">handler(for:)</code> method with the following implementation:</p><pre class="programlisting">override func handler(for intent: INIntent) -&gt; Any? {
  if intent is INSendMessageIntent {
    return SendMessageIntentHandler()
  }

  return nil
}</pre><p>The <code class="literal">SendMessageIntentHandler</code> is a class you will define and implement to handle the sending of messages. Create a new <code class="literal">NSObject</code> subclass, named <code class="literal">SendMessageIntentHandler</code>, and make it conform to <code class="literal">INSendMessageIntentHandling</code>. When you create this file, make sure it's added to the <strong class="userinput"><code>MessageHairdresserIntent</code></strong> target, and not the Hairdressers app target.</p><p>Every intent handler has different required and <span>recommended</span><a id="id325581015" class="indexterm"></a> methods. <code class="literal">INSendMessageIntentHandling</code> has just one required method: <code class="literal">handle(sendMessage:completion:)</code>. Other methods are used to confirm and resolve the intent. All of the resolve methods work in similar ways, but are used for different parameters in an intent.</p><p>Imagine you're building a messaging app that uses groups to send a message to multiple contacts at once. These groups are defined in your app and Siri wants to resolve a group name. If this occurs, Siri calls the <code class="literal">resolveGroupName(forSendMessage:with:)</code> method on the intent handler. This method is now expected to resolve the group name and inform Siri about the result by calling the callback it's been passed. Let's see how this works:</p><pre class="programlisting">let supportedGroups = ["neighbors", "coworkers", "developers"]

func resolveGroupName(forSendMessage intent: INSendMessageIntent, with completion: @escaping (INStringResolutionResult) -&gt; Void) {

  guard let givenGroupName = intent.speakableGroupName else {
    completion(.needsValue())
    return
  }

  let matchingGroups = supportedGroups.filter { group in
    return group.contains(givenGroupName)
  }

  switch matchingGroups.count {
  case 0:
    completion(.needsValue())
  case 1:
    completion(.success(with: matchingGroups.first!))
  default:
    completion(.disambiguation(with: matchingGroups))
  }
}</pre><p>To simplify the example a bit, the supported groups are defined as an array. In reality, you would use the given group name as input for a search query in Core Data, your server, or any other place where you might have stored the information about contact groups.</p><p>The method itself first makes sure that a group name is present on the intent. If it's not, a callback is used to inform Siri that a group name is required for this app. Note that this might not be desirable for all messaging apps. Actually, most messaging apps will allow users to omit the group name altogether. If this is the case, you'd call the completion handler with a successful result.</p><p>If a group name is given, it is used to filter the <code class="literal">supportedGroups</code> array. Again, most apps would query an actual database at this point. If no results are found, Siri is asked for a value. If a single result is found, the work is done. The code successfully managed to match the intent's group with a group in the app's database and Siri is informed accordingly. If more than one result was found, Siri is asked to disambiguate the results that were found. Siri will then take care of asking the user to specify which one of the provided inputs should be used to send the message to. This could happen if you ask Siri to send a message to a person named <span class="emphasis"><em>Jeff</em></span>, but you have multiple <span class="emphasis"><em>Jeffs</em></span> in your contact list.</p><p>In the case of the Hairdressers app, <span>messages</span><a id="id325581059" class="indexterm"></a> are sent to individual hairdressers that are stored in the <code class="literal">Hairdressers.plist</code> file. The <code class="literal">HairdressersDataSource</code> helper object can read the data from this <code class="literal">plist</code> and provides a simple array of hairdresser names. Since this data is currently only part of the Hairdressers app target, you will need to add it to the <strong class="userinput"><code>MessageHairdresserIntent</code></strong> target as well.</p><p>To do this, select both of the files in the <strong class="userinput"><code>Project Navigator</code></strong>, and use the <strong class="userinput"><code>File Inspector</code></strong> on the right side of the Xcode window to add these files to the <strong class="userinput"><code>MessageHairdresserIntent</code></strong> target, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/838eecd8-1383-4e9a-a3e9-fecfbcce80b0.png" /></div><p>Next, add the following extension to <code class="literal">SendMessageIntentHandler.swift</code> to implement <code class="literal">resolveRecipients(for:with:)</code>:</p><pre class="programlisting">extension SendMessageIntentHandler: INSendMessageIntentHandling {
  func resolveRecipients(for intent: INSendMessageIntent, with completion: @escaping ([INSendMessageRecipientResolutionResult]) -&gt; Void) {

    guard let recipients = intent.recipients else {
      completion([.needsValue()])
      return
    }

    let results: [INSendMessageRecipientResolutionResult] = recipients.map { person in
      let matches = HairdressersDataSource.hairdressers.filter { hairdresser in
        return hairdresser == person.displayName
      }

      switch matches.count {
      case 0: return INSendMessageRecipientResolutionResult.needsValue()
      case 1: return INSendMessageRecipientResolutionResult.success(with: person)
      default: return INSendMessageRecipientResolutionResult.disambiguation(with: [person])
      }
    }

    completion(results)
  }
}</pre><p>The preceding code should look very familiar, because it's very similar to the code for resolving a group name. The main difference is that a user can choose multiple recipients for the message, so a resolution result is created for each of the recipients that Siri passes to the <code class="literal">resolveRecipients(for:with:)</code> method. The next stage in handling the intent is to confirm the intent status.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch16lvl3sec38"></a>Confirming the intent status</h4></div></div></div><p>After you've made sure that everything is in <span>place</span><a id="id325356939" class="indexterm"></a> to eventually handle the intent, you must confirm this to Siri. Every intent handler has a <code class="literal">confirm</code> method. The signature might vary, but there is always some form of confirmation. Refer to the documentation for the intent you are handling to confirm which method you are expected to implement. When you send messages, the confirmation method is <code class="literal">confirm(sendMessage:completion:)</code>.</p><p>You can make the confirmation step as complex as you want. For example, you could check whether a message is too long, contains forbidden content, or virtually anything else. Most commonly, you'll want to make sure that the user is authenticated and allowed to send a message to the recipient.</p><p>Again, it's completely up to your best judgment to determine which conditions apply to your extension. The important takeaway for the confirm method is that you're expected to make sure that everything is in place to smoothly perform the action later.</p><p>Let's look at an example of a confirmation implementation to explore some of the possible outcomes of the confirmation stage:</p><pre class="programlisting">func confirm(sendMessage intent: INSendMessageIntent, completion: @escaping (INSendMessageIntentResponse) -&gt; Void) {

  guard let user = User.current(), user.isLoggedIn else {
    completion(INSendMessageIntentResponse(code: .failureRequiringAppLaunch, userActivity: nil))
    return
  }

  guard MessagingApi.isAvailable else {   
    completion(INSendMessageIntentResponse(code: .failureMessageServiceNotAvailable, userActivity: nil))
    return
  }

  completion(INSendMessageIntentResponse(code: .ready, userActivity: nil))
}</pre><p>The preceding implementation checks whether a current user is available, and whether they are logged in or not. If no user exists, the intent handler will inform Siri that the app should be launched so that a user can log in.</p><p>Next, the availability of the API that will eventually handle the message sending is checked. Note that the <code class="literal">user</code> and <code class="literal">api</code> classes don't exist in the example project, and should be defined by you if you decide to go with this confirmation approach. These classes simply serve as placeholder examples to demonstrate how confirmation of an intent works.</p><p>If a user must be taken to your app in order to log in or for any other reason, Siri will automatically create a user activity that's passed to <code class="literal">AppDelegate</code> in your application. You must implement <code class="literal">application(_:continue:restorationHandler:)</code> to catch and continue the user activity.</p><p>A user activity that's created by Siri has its <code class="literal">interaction</code> property set. This property contains an <code class="literal">INInteraction</code> object that reflects the action that the user attempts to complete using Siri. A good implementation of <code class="literal">application(_:continue:restorationHandler:)</code> will fulfill <span>this</span><a id="id325356998" class="indexterm"></a> interaction as soon as possible inside of the app. It's also possible to create your own user activity if you want to add custom information that Siri doesn't pass on. If you want to do this, you should pass your custom user activity to the <code class="literal">INSendMessageIntentResponse</code> initializer.</p><p>Since the Hairdressers app doesn't use an external API and the user doesn't have to log in, the <code class="literal">confirm(sendMessage:completion:)</code> method does not have to be implemented. After ensuring that everything is in place, it's time to move on to the third stage of handling an intent: performing the desired action.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch16lvl3sec39"></a>Performing the desired action</h4></div></div></div><p>Once Siri understands what the user wants to do and which parameters to use, and once your app has confirmed that everything is in <span>place</span><a id="id325357021" class="indexterm"></a> to handle the user's request, the time has finally come to execute the requested action. Once this time has come, Siri calls the <code class="literal">handle</code> method on your intent handler.</p><p>Just like the <code class="literal">confirm</code> method, every intent has their own version of this method, but they all follow a similar pattern. For sending messages, the method signature is <code class="literal">handle(intent:completion:)</code>, where the <code class="literal">intent</code> is an instance of <code class="literal">INSendMessageIntent</code>. The parameters for this method are identical to the ones in the confirmation step. The major difference is that you're now expected to handle the intent, instead of only confirming that the intent is valid.</p><p>Once you have handled the intent, you must call the completion handler with an <code class="literal">INSendMessageIntentResponse</code>. If everything goes well, you're expected to use a <code class="literal">success</code> response code. If you're unable to process the intent promptly, you must call the completion handler with an <code class="literal">inProgress</code> status code. Using the <code class="literal">inProgress</code> status code informs Siri that you're handling the intent, but it's taking a while. If you fail to handle the intent at all, you should pass a <code class="literal">failure</code> status to the completion handler.</p><p>Since the Hairdressers app uses Core Data to store all of its data, you will need to perform some additional steps to share data between the extension and the app. To do this, you must use the <strong class="userinput"><code>App Groups</code></strong> capability. <strong class="userinput"><code>App Groups</code></strong> associate multiple targets with a single, shared group, which allows <span>them</span> to access shared files or <code class="literal">UserDefaults</code> instances. To create an app group, you must enable the <strong class="userinput"><code>App Groups</code></strong> capability in the project's <strong class="userinput"><code>Capabilities</code></strong> tab, and provide a name for your group, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/d0b38055-a215-4d92-bb0f-aa67ddb5dc5c.png" /></div><p>When you have configured the app groups capability for your app, enable it for the <strong class="userinput"><code>MessageHairdresserIntent</code></strong> extension as well, and make sure to select the app group you just created to add the extension to that app group.</p><p>After doing this, you must configure the app's persistent container to use the app group for storing the database file. Add the following code to the <code class="literal">persistentContainer</code> computed property in <code class="literal">PersistentHelper</code>, right before the persistent store is loaded, to configure the persistent container properly:</p><pre class="programlisting">let containerUrl = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "YOUR.APP.GROUP.NAME")!
let databaseUrl = containerUrl.appendingPathComponent("Hairdressers.sqlite")
let description = NSPersistentStoreDescription(url: databaseUrl)
container.persistentStoreDescriptions = [description]</pre><p>Also, make sure to add the <code class="literal">PersistentHelper.swift</code> file, the <code class="literal">NSManagedObjectContext</code> extension, and the data model in <code class="literal">Hairdressers.xcdatamodeld</code>, which already exist in the app target, to the extension target.</p><p>Now that the app and its Siri extension share the Core Data store, you are ready to take the message the user is trying to send and store it in the Core Data database. Add the following code to the existing extension on <code class="literal">SendMessageIntentHandler</code>:</p><pre class="programlisting">func handle(intent: INSendMessageIntent, completion: @escaping (INSendMessageIntentResponse) -&gt; Void) {
  guard let hairdressers = intent.recipients, let content = intent.content else {
    completion(INSendMessageIntentResponse(code: .failure, userActivity: nil))
    return
  }

  let moc = PersistentHelper.shared.persistentContainer.viewContext
  moc.persist {
    for hairdresser in hairdressers {
      let message = Message(context: moc)
      message.createdAt = Date()
      message.hairdresser = hairdresser.displayName
      message.content = content
    }

    completion(INSendMessageIntentResponse(code: .success, userActivity: nil))
  }
}</pre><p>All the preceding code does is create a new <code class="literal">Message</code> object for each recipient of the message and stores it in the Core Data database. If no recipients are found, or no <span>message</span><a id="id325357148" class="indexterm"></a> exists, the operation is considered failed. If everything works out well, the operation is completed successfully.</p><p>To test your extension, click on your app target in the top of the Xcode window and select your extension. When you attempt to run it, Xcode will ask you for an app to run it with, as shown in the following screenshot. You can pick <strong class="userinput"><code>Hairdressers</code></strong> if you want, but any app will do:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/b133aa16-accd-41cc-ae34-17aa8f6b976b.png" /></div><p>Before testing the extension, make sure that you have run <span><strong class="userinput"><code>Hairdressers</code></strong></span> at least once to make sure the app has permission to be integrated with Siri.</p><p>Even though it's pretty cool that you can now use Siri to send messages, the UI that Siri shows isn't that great. In the next section, you will learn how you can add a custom UI to your Siri intent.</p></div></div></div>