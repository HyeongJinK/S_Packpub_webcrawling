<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec26"></a>Creating adaptive layouts with Auto Layout</h2></div></div><hr /></div><p>At the beginning of this chapter, you <span>learned</span><a id="id325333345" class="indexterm"></a> what adaptive layouts <span>are</span><a id="id325333353" class="indexterm"></a> and why they are essential. You <span>learned</span><a id="id325333362" class="indexterm"></a> a little bit about size classes and the <code class="literal">traitCollection</code> property. In this section, you'll deep dive into these topics by implementing an adaptive contact details page. You'll learn some best practices to implement a layout that is tailored to work well with different size classes. You will learn how to do this in code as well as storyboards because it's not always possible to define your entire layout in a storyboard. Refer to the following diagram to see what the layout is going to look like:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/eb164a9a-4009-481d-a30d-da3b755f1e3d.png" /></div><p>The detail page you're going to set up contains some information about the contact the user has tapped, and the user can add some notes for this contact. On small screens, the layout will be a simple, one-column layout. On larger screens, the layout will adapt to make good use of the screen by splitting into a two-column layout. First, you'll create this layout in <strong class="userinput"><code>Interface Builder</code></strong>. Once you're done, you will make some tweaks to the layout in code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec14"></a>Auto Layout with Interface Builder</h3></div></div></div><p>A good strategy for <span>implementing</span><a id="id325333395" class="indexterm"></a> a layout that is adaptive is to begin by setting up Auto Layout constraints that apply to all different versions of the layout. We'll call these <span class="strong"><strong>common constraints</strong></span>. These are constraints that remain active for any size class. By implementing common constraints first, you typically end up with fewer and clearer constraints than you would if you take a different approach.</p><p>When you add constraints in <strong class="userinput"><code>Interface Builder</code></strong>, they apply to all size classes by default. You can add constraints for a specific size class by activating the <strong class="userinput"><code>Vary for Traits</code></strong> option by clicking on the corresponding button in the bottom-right corner of the device preview section. Before pressing this button, make sure to select a device that has the size classes you want to work with. For instance, if you want to define constraints for a regular width and regular height, you can select any iPad.</p><p>Before you start working on the contact detail page, try to get a feel for how the <strong class="userinput"><code>Vary for Traits</code></strong> feature works. Make sure to turn the feature off before you continue and remove the label you added earlier; you'll start from scratch to implement the new layout.</p><p>The contact detail page contains a text area where the user can add some notes. When the user taps this text area, the keyboard will appear, potentially covering the notes field itself on smaller screens. This isn't great because if the keyboard covers the text area, the user cannot see what they are typing. To fix that, you can wrap the entire detail page in a scroll view, allowing the user to scroll the page whenever the keyboard covers the notes field so they can make it visible again.</p><p>Implementing a scroll view while using Auto Layout has proven to be non-trivial. Once you understand how it works and what it takes to implement a scroll view with Auto Layout properly, it all makes sense.  However, figuring it out for the first time is tough. So the first thing you'll learn is how to implement the scroll view.</p><p>You will follow the following steps to implement the full detail page:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Implement the scroll view that will contain the entire layout.</li><li>Add the big contact image and name label.</li><li>Implement variation for the contact image on large screens.</li><li>Add the bottom section of the detail page.</li><li>Adjust the bottom section of the detail page for small screens.</li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec16"></a>Implementing a scroll view with Auto Layout</h4></div></div></div><p>A <span>scroll</span><a id="id325606060" class="indexterm"></a> view is a convenient tool you can use to prevent a keyboard from <span>obscuring</span><a id="id325606069" class="indexterm"></a> contents in your app. Using a scroll view, the user can quickly decide which parts of the interface they would like to see when the keyboard overlays a portion of the view. However, a scroll view is not always trivial to configure. It must know how large its contents are to determine whether scrolling needs to be enabled and to know how far down a user can scroll. Setting this up in Auto Layout requires a little bit of practice.</p><p>When you first add the scroll view to your view in <strong class="userinput"><code>Interface Builder</code></strong>, you must make sure that you add constraints that pin the scroll view to the edges of the view controller's view. This makes sure the scroll view takes up the entire available space on the screen. Next, you should add a view to the scroll view. This view will act as a container view for all the content and will be able to inform the scroll view about its content size.</p><p>The content view should have a width that is equal to the view controller's view. This will make sure the content width is never larger than the view controller so the scroll view won't scroll on the horizontal axis. Next, the content view should have all its edges pinned to the scroll view edges. Let's go over everything you have read so far again and implement it for the detail page right away. Before you begin, make sure you uncheck <strong class="userinput"><code>Adjust Scroll View Insets</code></strong> in the <strong class="userinput"><code>Attributes Inspector</code></strong> for the entire contact detail view controller.</p><p>Now drag a scroll view from the <strong class="userinput"><code>Object Library</code></strong> and add it to the view. Resize it so it covers the entire available view; don't make it cover the navigation bar. Add constraints to the scroll view using the <strong class="userinput"><code>Add New Constraints</code></strong> menu, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/b5a90d72-510a-4880-9338-50b78d1ee2b4.png" /></div><p>Note that the <strong class="userinput"><code>Constrain to margins</code></strong> checkbox is checked. By <span>constraining</span><a id="id325607106" class="indexterm"></a> your scroll view relative to the margins of its container, you make sure that your view will not exceed the <span>Safe Area</span> bounds. This is especially important for devices like the iPhone X and Xs, where <span>part</span><a id="id325607120" class="indexterm"></a> of the view is used for the home indicator and the camera notch. The following diagram visualizes the Safe Area bounds on a landscape-oriented iPhone Xs:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/c6de56f9-ce30-43e0-9460-44c3b0390c5b.png" /></div><p>The next step is to drag a <code class="literal">UIView</code> <span>object</span> from the <strong class="userinput"><code>Object Library</code></strong> and add it to the scroll view. Manually size it so it covers the entire scroll view. Add the same constraints you added to the scroll view, so all edges of the content view are pinned to the edges of the scroll view. The content view must also have an equal width to the view controller's view. To set this up, select the content view and press <span class="emphasis"><em>Ctrl</em></span>. While holding down <span class="emphasis"><em>Ctrl</em></span>, drag to the view controller's Safe Area object. When you let go, you can now select <strong class="userinput"><code>Equal Width</code></strong> to make sure the content view always has an equal width to the main view's Safe Area. Doing this will make sure the scroll view knows the correct width for its content.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Note</h3><p>If you accidentally forget to make your constraints relative to the Safe Area margins, you can select the constraint in the <strong class="userinput"><code>Document Outline</code></strong>. Usually, either the first or second item in the <strong class="userinput"><code>Size Inspector</code></strong> for the constraint refers to the superview. If you click on this item, a drop-down menu appears, from which you can select <strong class="userinput"><code>Relative to margin</code></strong>. After choosing this option, the constraint will be relative to the Safe Area margins. Make sure to check whether the <strong class="userinput"><code>Constant</code></strong> for the constraint is still correct; you might have to update it back to the correct value. As an exercise, check the collection view from the previous chapter and make sure it is configured to use the Safe Area margins.</p></div><p>After following <span>these</span><a id="id325580641" class="indexterm"></a> steps, you should have now encountered an <span>Auto</span><a id="id325580649" class="indexterm"></a> Layout issue. This issue has appeared because the scroll view is unable to determine its height since the content view also cannot determine its height. You could say that the scroll view now has an ambiguous scroll height. Once you add some children to the container view, this problem will resolve itself. Because the container view will be able to calculate its height based on its child views, the scroll view can then use the container view's height to figure out the scroll height.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec17"></a>Laying out the image and name label</h4></div></div></div><p>The next step is to add the contact's image and its name <span>label</span><a id="id325580664" class="indexterm"></a> to the content container view. Start by dragging a <code class="literal">UIImageView</code> and <code class="literal">UILabel</code> <span>object</span> from the <strong class="userinput"><code>Object Library</code></strong>. Position them so that they both are horizontally centered in the view. Also, position them so they have about 10 points of spacing on the vertical axis. Don't forget to apply a nice light gray background color to the image. You've already seen the following two ways to add constraints:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Have Xcode add constraints for you.</li><li style="list-style-type: disc">Add constraints through the menu in the bottom-right corner.</li></ul></div><p>You'll add a third technique to that list: <span class="emphasis"><em>Ctrl</em></span> + dragging. You already used <span class="emphasis"><em>Ctrl</em></span> + dragging while setting up the scroll view, but it also works when dragging from one view to another in your design preview.</p><p>If you select the <code class="literal">UIImageView</code> <span>object</span> and drag upward while pressing <span class="emphasis"><em>Ctrl</em></span>, you can add constraints that relate to the view you started dragging from, the view you let go in, and the direction you were dragging in. Try this now; a menu such as the one in the following screenshot should appear. Press and hold <span class="emphasis"><em>Shift</em></span> and select <strong class="userinput"><code>Vertical Spacing to Top Layout Guide</code></strong> and <strong class="userinput"><code>Center Horizontally in Container</code></strong>. An <strong class="userinput"><code>Add Constraints</code></strong> option <span>should</span><a id="id325580766" class="indexterm"></a> have appeared at the bottom of the list after you selected the constraints you want to add. Click on that to add the selected constraints. Moving forward, this will be the preferred way to add constraints:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/06b183d9-33ac-454d-b8e8-d3163c2ff961.png" /></div><p>To set an appropriate width and height for the <code class="literal">UIImageView</code> <span>object</span>, press <span class="emphasis"><em>Ctrl</em></span> and drag on the image itself. If you drag and release in a horizontal direction, you can add a width constraint, and dragging vertically allows you to add a height constraint. You can't set the value though; the value will be set to whatever the current size is.</p><p>If you want to change the value of a constraint, go to the <strong class="userinput"><code>Size Inspector</code></strong> on the right-hand side of the screen and double-click on a constraint. This allows you to change the <strong class="userinput"><code>Constant</code></strong> for a constraint. When you set a size constraint, the constant will refer to that size. When setting spacing, the constant will refer to the current amount of spacing. Click on the image and correct the width and height constraints so the image will be 60 x 60 points. Update the preview by clicking on the <strong class="userinput"><code>Update Frames</code></strong> menu option at the bottom of the <strong class="userinput"><code>Interface Builder</code></strong> window located in the bottom-right area of the window.</p><p>With the image view set up, it is time to add some constraints to layout out the name label. Position the name label approximately 10 points beneath the image and make sure that it's centered. Now, press <span class="emphasis"><em>Ctrl</em></span> and drag from the label to the image view. The dialog you saw before should appear; press <span class="emphasis"><em>Shift</em></span> and add <strong class="userinput"><code>Vertical Spacing</code></strong> and <strong class="userinput"><code>Center Horizontally</code></strong> constraints. This will set up constraints that horizontally center the label relative to the image. It also adds a constraint that vertically spaces the label from the image. Finally, drag down from the label to set its vertical spacing to the container view. Modify this constraint, so the label has a spacing of 8 points to the container's bottom. This will make sure that the content view has a height, and this resolves the Auto Layout issue you saw earlier.</p><p>Change the preview to a couple of different devices, and the image and label should always appear nicely centered on every layout. The designs we saw earlier had a larger image on the iPad. This means that separate sizing constraints should be used for the iPad's larger screen. This is what the next step is about.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec18"></a>Adjusting the image and label for large screens</h4></div></div></div><p>When you click the <strong class="userinput"><code>Vary for Traits</code></strong><span>button</span><a id="id325580840" class="indexterm"></a> in <strong class="userinput"><code>Interface Builder</code></strong>, you have three <span>options</span><a id="id325580852" class="indexterm"></a> to base your variation on:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Vary on height.</li><li style="list-style-type: disc">Vary on width.</li><li style="list-style-type: disc">Vary on width and height.</li></ul></div><p>If you select width, any new constraints you add will apply to all trait collections that match the size class axis you have chosen to vary on. So if you select the iPad view and then select to vary for width only, all Xcode will present several options that your variation would apply to. The following screenshot shows an example of this:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/35255fb1-4a03-41c2-9843-752ed683302f.png" /></div><p>To make the larger image look good, you should vary both the width and height. If the larger image appears on an iPhone 6 Plus in landscape mode, it would cover too much of the screen, so the bigger image should only be shown on devices that can accommodate it on both the horizontal and vertical axis. Click on <strong class="userinput"><code>Vary for Traits</code></strong> again, and this time check the width and height boxes. You'll notice that the iPhone isn't in the list of devices anymore because a large screen iPhone has a regular width and a compact height. On the left-hand side of the <strong class="userinput"><code>Interface Builder</code></strong> window, you can find the <span>document outline</span>. In this outline, look for your image view. You can see the constraints that are added to the image view listed underneath the image view. Expand the constraints and select the width constraint. At the bottom of <strong class="userinput"><code>Attributes Inspector</code></strong> on the right-hand side of the screen, you'll find a plus icon, and a checkbox labeled <strong class="userinput"><code>Installed</code></strong>. Click on the plus symbol and navigate to the <strong class="userinput"><code>Regular width | Regular height | Any gamut</code></strong><span>(current)</span> option as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/6cb25661-3e47-475b-9a39-a682fea22b28.png" /></div><p>After doing this, an extra checkbox will appear. Uncheck it so the width constraint is not installed for the current variation. Do the same for the image's height constraint; after doing this, the image might not be visible anymore because <span>Auto Layout</span> doesn't know its dimensions. With the image view selected, go to the <strong class="userinput"><code>Size Inspector</code></strong> and set the image's size to 120 x 120. This will make the image reappear. Now, use the <span class="emphasis"><em>Ctrl</em></span> + drag technique to add width and height constraints, as you have done before. If you inspect these constraints, you'll see that they have a similar setup for their installation checkboxes as before, except that the general one is unchecked and the specific one is checked. Great! This means you've successfully set up the constraint variations for your app.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note17"></a>Note</h3><p>It is possible that the created configuration installs the constraint only based on the width size class and ignores the height size class. If this happens, click the plus icon to manually set up the correct configuration and delete the wrong one.</p></div><p>Go ahead and exit the variation mode by clicking on the <strong class="userinput"><code>Done Varying</code></strong> button and check out your layout on several screens. If the image size doesn't update automatically, select the entire view and update the frames from the <strong class="userinput"><code>Resolve Auto Layout Issues</code></strong> menu. This wraps up the layout of the top section of the detail page.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec19"></a>Laying out the bottom section</h4></div></div></div><p>The bottom section for this page looks simple, but you <span>need</span><a id="id325580989" class="indexterm"></a> to think very carefully about the way it is set up. On small screens, all of the elements should be displayed in a single column, while larger screens have two columns. The simplest way to do this is to wrap both of these sections in a container view as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/253268e8-7699-491c-8038-17c7b8a9427b.png" /></div><p>The biggest challenge you face is to make sure the scroll view's content view knows how to calculate the height of its contents. Previously, you added a constraint that pinned the label to the bottom of the content view. You should remove this constraint because it isn't needed anymore. Instead, the left column of the layout will be pinned to the bottom of the content view since it's the tallest view of the two. Remove the label's bottom constraints by selecting the label in the <strong class="userinput"><code>Document Outline</code></strong> and navigating to the <strong class="userinput"><code>Size Inspector</code></strong>. Click the <strong class="userinput"><code>Bottom Space to:</code></strong> constraint and press <span class="emphasis"><em>Backspace</em></span> to remove this constraint. Now you can manually make the content view a bit taller, so you have some space to work with.</p><p>Drag two regular views from the <strong class="userinput"><code>Object Library</code></strong> into the content view and size them so they are roughly the same size and so they meet in the middle. The views shouldn't overlap, but they also shouldn't have any space between them. Drag the left edge of the view on the left until you see the blue helper lines. Do the same for the right view but drag the right side of the view to the right side of the window. Position both views so they are positioned roughly 40 points below the label.</p><p>Now, select the view on the left and <span class="emphasis"><em>Ctrl</em></span> + drag to the name label and add a vertical spacing constraint. Then, <span class="emphasis"><em>Ctrl</em></span> + drag to the left side to pin this view's left side to the content view's leading edge. Now, select the right view and do the same, except instead of dragging left, drag right to pin the right side of the view to the content view's trailing edge. Finally, <span class="emphasis"><em>Ctrl</em></span> + drag from the left view to the right view and select the equal width constraint and vertical spacing constraint. This should leave you with two equally sized views that don't have a height yet. Lastly, <span class="emphasis"><em>Ctrl</em></span> + drag from the left view downward into the container view to pin its bottom 10 points from the bottom of the container view.</p><p>Drag six labels into the left view. Align them as they are in the design. Use the blue lines as guides for the margins, and make the labels wide enough to cover the view. Stop at the blue lines again; they help you by providing some nice margins. Press <span class="emphasis"><em>Ctrl</em></span> and drag from the first label upward to pin it to the top side of the view. Press <span class="emphasis"><em>Ctrl</em></span> and drag left into the left view to pin the label to the left side of the view, and press <span class="emphasis"><em>Ctrl</em></span> and drag right to pin it to the right side. Then, select the second label and <span class="emphasis"><em>Ctrl</em></span> + drag upward to the first label. While holding the <span class="emphasis"><em>Shift</em></span> key, select the leading, trailing, and vertical spacing constraints. Repeat this for all other labels. The final label should be pinned to the bottom of the left view.</p><p>Now, drag a label and a text field to the <span>right</span><a id="id325581066" class="indexterm"></a> side's view. Align the elements by using the blue lines again. Pin the label to the top, right, and left sides of its containing view. Drag the text field to the label and select the leading, trailing, and vertical spacing constraints. Finally, drag upward inside the text field to add a height constraint. Modify this constraint so the text field has a height of 80. Finally, press <span class="emphasis"><em>Ctrl</em></span> + drag downward to pin the bottom of the text field to the bottom of the view.</p><p>The step to create the layout is to press <span class="emphasis"><em>Ctrl</em></span> and drag the left view down into the content view. Select the vertical spacing constraint and modify the constant so the spacing is eight points. Now use the <strong class="userinput"><code>Attributes Inspector</code></strong> to make all header labels use a bold font and provide the appropriate text values for them. Refer to the design to see what the correct label values should be.</p><p>Well, that was a lot of instructions, but you should have successfully completed the layout for regular x regular devices. Try to run your app on an iPad; looks pretty good, right?</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec20"></a>Adjusting the bottom section for small screens</h4></div></div></div><p>The layout you have so far looks pretty good <span>on</span><a id="id325581095" class="indexterm"></a> the iPad. However, it's just too cramped on the iPhone in portrait mode. Let's create some room by changing it to a single-column layout. First, select iPhone view and click on the <strong class="userinput"><code>Vary for Traits</code></strong> button. This time, make sure that you only vary for the width. The easiest way to pull off a change this big is to rearrange the view first without modifying the constraints yet. Rearrange the views so they look as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/80f231aa-0a21-4b2c-a154-1f985ff7b8ca.png" /></div><p>Once you have <span>rearranged</span><a id="id325333550" class="indexterm"></a> the views, it's a good idea to add constraints that you know are missing. This isn't always straightforward but with some practice, you should get the hang of this pretty soon. Always make sure that each view can figure out its <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> position and its width and height.</p><p>In this case, the following constraints are missing:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Top view with notes to the left side of the content view</li><li style="list-style-type: disc">Vertical spacing between the top and bottom view</li><li style="list-style-type: disc">Bottom view to the right side of the content view</li></ul></div><p>Add the constraints after you have started your <strong class="userinput"><code>Vary for Traits</code></strong> by pressing <span class="emphasis"><em>Ctrl</em></span> and dragging as you have done before. You'll end up with a lot of errors and red lines. This is because you haven't disabled the constraints that were created for the two-column layout. To fix the errors, the following constraints that only apply to the two-column layout must be removed for the compact width variation:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Vertical spacing between the view with the contact information and the contact name label</li><li style="list-style-type: disc">Horizontal spacing between the former left and right view</li><li style="list-style-type: disc">Equal width constraint for the two bottom views</li></ul></div><p>To remove the mentioned constraints, select the top view and look for the <strong class="userinput"><code>Leading Space to: View</code></strong> constraint. Click this constraint and delete it to disable it for the <strong class="userinput"><code>Compact Width</code></strong> version of your layout. Make sure you are still in <strong class="userinput"><code>Vary for Traits</code></strong> mode when you do this. Otherwise, the constraint will be deleted for all size variations. Do the same for the other two constraints. You can find these constraints by selecting either of the views related to the constraint you're looking for. Finally, select the vertical spacing constraint for the top and bottom view and modify the constant to <code class="literal">8</code>; this will provide nice spacing between the two sections. You're done modifying the constraints now; no conflicts should remain, and your layout should now look good on all devices. Check out the plus-sized iPhone in particular; it will switch between the single- and two-column layouts! Pretty cool, isn't it? If you run the app in landscape on other devices, you'll notice that even though the layout is taller than the screen, the scroll view makes sure all content is accessible.</p><p>Before you deep-dive into Auto Layout on the <span>code</span><a id="id325333613" class="indexterm"></a> side, there's one last thing that needs to be fixed. Whenever the keyboard appears, the scroll view should resize so a user can still see the entire page. To do this, you need to create an <code class="literal">@IBOutlet</code> <span>object</span> for the bottom constraint of the scroll view, and then you will need to programmatically set the constant for the bottom constraint to the height of the keyboard. To get started, create a new <code class="literal">UIViewController</code> subclass (<strong class="userinput"><code>File | New | File...</code></strong>) and name it <code class="literal">ContactDetailViewController</code>. Assign this class to the contact details screen's view controller in <strong class="userinput"><code>Interface Builder</code></strong>.</p><p>Define the following <code class="literal">@IBOutlet</code> <span>object</span> in <code class="literal">ContactDetailViewController.swift</code> and connect it by dragging from the <strong class="userinput"><code>Connections Inspector</code></strong> to the scroll view's bottom constraint in the <strong class="userinput"><code>Document Outline</code></strong>:</p><pre class="programlisting">@IBOutlet var scrollViewBottomConstraint: NSLayoutConstraint!</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip18"></a>Note</h3><p>If an item is hard to find or access in the visual view hierarchy, you can look for the view or constraint in the <strong class="userinput"><code>Document Outline</code></strong>. Once you have found the thing you wish to connect to an <code class="literal">@IBOutlet</code> <span>object</span>, you can <span class="emphasis"><em>Ctrl</em></span> + drag from the outlet in the <strong class="userinput"><code>Connections Inspector</code></strong> to the item in the <strong class="userinput"><code>Document Outline</code></strong> to configure the connection.</p></div><p>Next, add the following code to <code class="literal">ContactDetailViewController.swift</code>:</p><pre class="programlisting">override func viewDidLoad() {
  super.viewDidLoad()

  NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillAppear),
                                         name: UIApplication.keyboardWillShowNotification,
                                         object: nil)

  NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide),
                                         name: UIApplication.keyboardWillHideNotification,
                                         object: nil)

}</pre><p>The preceding code subscribes the details page to keyboard notifications. Whenever the keyboard appears, the system posts a notification to an object called <code class="literal">NotificationCenter</code> that any object can listen to. Whenever the notifications are fired, a selector is executed on the view controller. This selector points to a function in the view controller. The code as it won't compile just yet because you still need to implement the <code class="literal">keyboardWillAppear</code> and <code class="literal">keyboardWillHide</code> methods. Add the following implementation for these methods:</p><pre class="programlisting">@objc func keyboardWillAppear(_ notification: Notification) {
  guard let userInfo = notification.userInfo,
    // 1
    let keyboardFrame = userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue,
    let animationDuration = userInfo[UIResponder.keyboardAnimationDurationUserInfoKey] as? Double
    else { return }

  // 2
  scrollViewBottomConstraint.constant = keyboardFrame.cgRectValue.size.height
  UIView.animate(withDuration: TimeInterval(animationDuration), animations: { [weak self ] in
    // 3
    self?.view.layoutIfNeeded()
  })
}

@objc func keyboardWillHide(_ notification: Notification) {
  guard let userInfo = notification.userInfo,
    let animationDuration = userInfo[UIResponder.keyboardAnimationDurationUserInfoKey] as? Double
    else { return }

  scrollViewBottomConstraint.constant = 0
  UIView.animate(withDuration: TimeInterval(animationDuration), animations: { [weak self ] in
    self?.view.layoutIfNeeded()
  })
}</pre><p>The preceding <span>code</span><a id="id325333724" class="indexterm"></a> snippet first reads some values from the <code class="literal">userInfo</code> dictionary on the <code class="literal">notification</code> object. The keyboard's final frame and the animation duration are extracted from this dictionary. Next, the scroll view's bottom constraint is updated so it is pushed upward by the keyboard's height. To animate this change, <code class="literal">layoutIfNeeded()</code> is called on the view controller's view inside of an animation block. Calling this method inside of an animation block ensures that the Auto Layout updates are performed with an animation.</p><p>When the keyboard hides, a similar flow is used except the scroll view's bottom constant is reset back to <code class="literal">0</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec15"></a>Using Auto Layout in code</h3></div></div></div><p>Auto Layout is a <span>technique</span><a id="id325333755" class="indexterm"></a> that can be used in <strong class="userinput"><code>Interface Builder</code></strong> as well as in code. You have created the contacts page entirely in <strong class="userinput"><code>Interface Builder</code></strong>, and that's very convenient. However, there are times when you might not be able to create the layout before the app runs. Let's call the moment of designing in <strong class="userinput"><code>Interface Builder</code></strong> the design time. At design time, it's possible that not all variables in your design are known. This means that you will need to dynamically add, remove, or update constraints when the app is running. When you do something while the app is running, you do it at runtime.</p><p>Setting up a layout visually with Auto Layout is very well supported, and <strong class="userinput"><code>Interface Builder</code></strong> even has some tools that make setting constraints programmatically fairly straightforward. If you have a very dynamic layout, you don't always know every constraint in advance. Especially if you are dealing with unpredictable data from external sources, a layout might need to change dynamically based on the available contents.</p><p>To help you with this, <strong class="userinput"><code>Interface Builder</code></strong> allows you to mark constraints as placeholder constraints in the <strong class="userinput"><code>Attributes Inspector</code></strong>. Marking a constraint as a placeholder means that it was used to create a valid layout for <strong class="userinput"><code>Interface Builder</code></strong> at design time, but you'll replace that constraint at runtime.</p><p>When you use Auto Layout in code, you can dynamically update constraints by changing the constant for a constraint at runtime. It's also possible to activate or deactivate certain constraints and to add or remove them. It doesn't matter if you created the constraints that you want to modify in code or <strong class="userinput"><code>Interface Builder</code></strong>. Any constraints that affect a view are accessible through code.</p><p>The best way to explore <span>this</span><a id="id325333798" class="indexterm"></a> is to get started with some coding. For the sake of this exercise, you will recreate the top part of the contact details page in code. This means you're going to set the constraints affecting the contact image and the contact name label as placeholder constraints in <strong class="userinput"><code>Interface Builder</code></strong>. The constraints for these views will then be added to the view controller, and you'll toggle some constraints' active states based on the current size class. The final code will also watch for changes in the size class and update the constraints accordingly if needed.</p><p>To get started, open <code class="literal">ContactDetailViewController.swift</code> and add the following two outlets to the class:</p><pre class="programlisting">@IBOutlet var contactImage: UIImageView!
@IBOutlet var contactNameLabel: UILabel!</pre><p>Now, open the <code class="literal">Main.storyboard</code> file, select your view controller, and connect the outlets in the <strong class="userinput"><code>Connections Inspector</code></strong> to the correct views. After you have connected the outlets, you should change the existing constraints that position the image and label so they become placeholder constraints instead of regular constraints. The constraints that need to be changed are the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Width constraints for the image (both regular and compact)</li><li style="list-style-type: disc">Height constraints for the image (both regular and compact)</li><li style="list-style-type: disc">Top spacing constraint for the image</li><li style="list-style-type: disc">Horizontal center constraint for the image</li><li style="list-style-type: disc">Spacing constraint between the label and the image</li><li style="list-style-type: disc">Horizontal center constraint for the label</li></ul></div><p>The vertical spacing constraint between the label and the bottom views should remain intact. To change a constraint to a placeholder, you must select it and check the placeholder checkbox in the <strong class="userinput"><code>Attributes Inspector</code></strong>. If you build and run your app after doing this, you'll end up with a mostly white view. That's okay; you have just removed some essential constraints that need to be re-added in code.</p><p>To get everything up and running again, you'll write some <span>code</span><a id="id325333852" class="indexterm"></a> to implement the eight constraints that were removed. One of the tools you can use to do so is <span class="strong"><strong>Visual Format Language (VFL)</strong></span>. This language is an expressive, declarative way to describe Auto Layout constraints. You can describe multiple constraints that affect multiple views at once, which makes this language very powerful.</p><p>A visual format string contains the following information:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Information regarding the axis on which the constraint should work:</strong></span> This is either horizontal (H), vertical (V), or not specified. The default is horizontal.</li><li style="list-style-type: disc"><span class="strong"><strong>Leading space to superview:</strong></span> This is optional.</li><li style="list-style-type: disc"><span class="strong"><strong>Affected view:</strong></span> This is required.</li><li style="list-style-type: disc"><span class="strong"><strong>Connection to another view:</strong></span> This is optional.</li><li style="list-style-type: disc"><span class="strong"><strong>Trailing space to superview:</strong></span> This is optional.</li></ul></div><p>An example of a visual format string looks like this:</p><pre class="programlisting">V:|-[contactImageView(60)]-[contactNameLabel]</pre><p>If you take this string apart piece by piece, it contains the following information:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">V:</code>: This specifies that <span>this</span><a id="id325333912" class="indexterm"></a> format string applies to the vertical axis.</li><li style="list-style-type: disc"><code class="literal">|</code>: This represents the superview.</li><li style="list-style-type: disc"><code class="literal">-</code>: This applies a standard spacing of about 8 points. This is equivalent to spacing a view in <strong class="userinput"><code>Interface Builder</code></strong> using the blue guidelines.</li><li style="list-style-type: disc"><code class="literal">[contactImageView(60)]</code>: This places the <code class="literal">contactImageView</code> and gives it a height of 60 points. The placement will be about 8 points from the top of the superview.</li><li style="list-style-type: disc"><code class="literal">-</code>: This applies another standard spacing.</li><li style="list-style-type: disc"><code class="literal">[contactNameLabel]</code>: This places <code class="literal">contactNameLabel</code> with about 8 points of spacing from <code class="literal">contactImageView</code>.</li></ul></div><p>This way of describing layouts takes some getting used to, but it's a really powerful way to describe layouts. Once you get the hang of all definitions and possibilities, you'll find that a visual format string is a very descriptive representation of the layout you're trying to create.</p><p>Time to dive right in and take a look at how to implement the entire layout for the top section of the contact details page. You'll only create the constraints for the compact size class for now and you'll add the regular constraints later.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec21"></a>Implementing the compact size layout</h4></div></div></div><p>To implement the compact size layout, you'll <span>combine</span><a id="id325349873" class="indexterm"></a> VFL and anchors. Anchors are fairly straightforward; the best way for you to understand how they work is by using them.</p><p>First, add the following two variables that will be used later to activate and deactivate the compact size constraints:</p><pre class="programlisting">var compactWidthConstraint: NSLayoutConstraint!
var compactHeightConstraint: NSLayoutConstraint!</pre><p>These variables will be set in <code class="literal">viewDidLoad</code>, and we're using implicitly unwrapped optionals for them. This means that you must set these variables before attempting to use them. If you fail to do this,  the app will crash due to an unexpected <code class="literal">nil</code> value.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note19"></a>Note</h3><p>You often want to avoid implicitly unwrapping optionals. Using optionals without implicit unwrapping enforces safety because you need to unwrap these values before attempting to use them. However, in some cases, you want your program to crash if a value isn't set; for instance, when there's no sensible way to recover from such a missing value. Scenarios like these are very rare, and you should use implicit unwrapping with great caution. In this example, it's used for brevity.</p></div><p>The following code should be added to the <code class="literal">viewDidLoad</code> method:</p><pre class="programlisting">// 1
let views: [String: Any] = ["contactImage": contactImage, "contactNameLabel": contactNameLabel]

var allConstraints = [NSLayoutConstraint]()

// 2
compactWidthConstraint = contactImage.widthAnchor.constraint(equalToConstant: 60)
compactHeightConstraint = contactImage.heightAnchor.constraint(equalToConstant: 60)

// 3
let verticalPositioningConstraints = NSLayoutConstraint.constraints(
  withVisualFormat: "V:|-[contactImage]-[contactNameLabel]",
  options: [.alignAllCenterX], metrics: nil, views: views)

allConstraints += verticalPositioningConstraints

// 4
let centerXConstraint = contactImage.centerXAnchor.constraint(equalTo: self.view.centerXAnchor)

// 5
allConstraints.append(centerXConstraint)
allConstraints.append(compactWidthConstraint)
allConstraints.append(compactHeightConstraint)

//6
NSLayoutConstraint.activate(allConstraints)</pre><p>There is a lot going on in the preceding <span>snippet</span><a id="id325349915" class="indexterm"></a> so take some time to study it closely. First, a dictionary of views is created. This dictionary is used by VFL later in step 3 to figure out which views correspond to the views mentioned in the format string. In step 2, the width and height for the image view are being set up. These constraints are configured with anchors. Every attribute that you can use for constraints can be represented with an anchor, in this case, width and height anchor, but there are also left, right, top, and bottom anchors that you can use to specify a layout with. Step 3 defines a visual format string to define the spacing between the <code class="literal">contactImage</code> <span>object</span> and the <code class="literal">contactNameLabel</code> <span>object</span>. By passing <code class="literal">.alignAllCenterX</code> to the options list for this format string, all views that participate in this string are aligned horizontally. Step 4 defines a constraint that places the image view in the middle of the view controller's view. Step 5 adds all anchor constraints to the <code class="literal">allConstraints</code> array. The final step is to call <code class="literal">NSLayoutConstraint.activate(_:)</code> to activate all constraints in the <code class="literal">allConstraints</code> array.</p><p>Try running your app on a device with a small screen; your layout should look just like it did before. The next step is to adapt this layout to larger screens by implementing the regular size layout.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec22"></a>Implementing the regular size layout</h4></div></div></div><p>In order to implement the layout for regular-sized devices, the <code class="literal">traitCollection</code> property of the <span>details</span><a id="id325349966" class="indexterm"></a> view controller is used. As mentioned earlier, the <code class="literal">traitCollection</code> property contains information about the current environment your app is running in. <span>All</span><code class="literal">UIView</code> instances, <code class="literal">UIViewControllers</code>, <code class="literal">UIWindows</code>, <code class="literal">UIPresentationControllers</code>, and <code class="literal">UIScreens</code> conform to the <code class="literal">UITraitEnvironment</code> protocol.</p><p>This protocol dictates that all objects that conform to <code class="literal">UITraitEnvironment</code> must have a <code class="literal">traitCollection</code> attribute. They must also have a <code class="literal">traitCollectionDidChange(_:)</code> method. This method is called whenever the <code class="literal">traitCollection</code> attribute changes. This could happen if a user rotates their device or when a multitasking window on the iPad changes its size. You'll use <code class="literal">traitCollection</code> and <code class="literal">traitCollectionDidChange(_:)</code> to correctly adapt the layout.</p><p>First, you must update <code class="literal">viewDidLoad</code> so it applies the correct layout for the current <code class="literal">traitCollection</code> attribute as soon as possible. Then, the code should watch for changes in the <code class="literal">traitCollection</code> attribute and update the constraints accordingly. Start by adding the following two variables to <code class="literal">ContactDetailController.swift</code>:</p><pre class="programlisting">var regularWidthConstraint: NSLayoutConstraint!
var regularHeightConstraint: NSLayoutConstraint!</pre><p>These variables will hold the larger width and height constraints for <code class="literal">contactImage</code>. Now, update <code class="literal">viewDidLoad</code> as follows; only areas where you should update the code are included in this snippet:</p><pre class="programlisting">// unchanged implementation 

compactWidthConstraint = contactImage.widthAnchor.constraint(equalToConstant: 60)
compactHeightConstraint = contactImage.heightAnchor.constraint(equalToConstant: 60)

// 1
regularWidthConstraint = contactImage.widthAnchor.constraint(equalToConstant: 120)
regularHeightConstraint = contactImage.heightAnchor.constraint(equalToConstant: 120)

// unchanged implementation

allConstraints.append(centerXConstraint)

// 2
if traitCollection.horizontalSizeClass == .compact &amp;&amp; traitCollection.verticalSizeClass == .regular {
  allConstraints.append(regularWidthConstraint)
  allConstraints.append(regularHeightConstraint)
} else {
  allConstraints.append(compactWidthConstraint)
  allConstraints.append(compactHeightConstraint)
}

NSLayoutConstraint.activate(allConstraints)</pre><p> </p><p>The first modification is to create two new anchor-based constraints. These constraints represent the image's size for larger screens. The second step is to check the current traits and make sure that both the horizontal and the vertical size classes are regular. Size classes in code work the same as they do in <strong class="userinput"><code>Interface Builder</code></strong>. When you implemented this layout in <strong class="userinput"><code>Interface Builder</code></strong>, you only wanted the image view to be bigger on devices that were of regular width and regular height, so this still applies. By selectively appending these constraints to all the constraints array, you can immediately apply the correct layout.</p><p>When a user is using an iPad, an app can suddenly change <span>from</span><a id="id325350071" class="indexterm"></a> a regular x regular environment to a compact x regular environment when multitasking is used. To adapt the layout accordingly, you need to implement the <code class="literal">traitCollectionDidChange(_:)</code> method. By implementing this method, you can check the new and old traits and decide whether to activate or deactivate certain constraints. Add the following method to <code class="literal">ContactDetailViewController</code> to implement this behavior:</p><pre class="programlisting">override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
  super.traitCollectionDidChange(previousTraitCollection)

  // 1
  guard let previousTraitCollection = previousTraitCollection,
     (previousTraitCollection.horizontalSizeClass != traitCollection.horizontalSizeClass ||
      previousTraitCollection.verticalSizeClass != traitCollection.verticalSizeClass)
    else { return}

  // 2
  if traitCollection.horizontalSizeClass == .regular &amp;&amp; traitCollection.verticalSizeClass == .regular {
    NSLayoutConstraint.deactivate([compactHeightConstraint, compactWidthConstraint])
    NSLayoutConstraint.activate([regularHeightConstraint, regularWidthConstraint])
  } else {
    NSLayoutConstraint.deactivate([regularHeightConstraint, regularWidthConstraint])
    NSLayoutConstraint.activate([compactHeightConstraint, compactWidthConstraint])
  }
}</pre><p>The first step in this code is to check whether an old trait collection exists since the method receives an optional <code class="literal">UITraitCollection</code> <span>object</span>. This means that the argument must first be unwrapped using either a <code class="literal">guard let</code> statement of an <code class="literal">if let</code> statement. In this case, <code class="literal">guard let</code> is used. In the same <code class="literal">guard</code>, the new size classes and the old ones are compared to make sure something related to the size classes has changed.</p><p>The second step is to check the new traits to see whether the app is running in a regular x regular environment. When this is the case, the compact constraints are deactivated and the regular constraints are activated. If the app is not running in a regular x regular environment, the regular constraints are deactivated and the compact constraints are activated.</p><p>Implementing an adaptive layout in code requires more work than in <strong class="userinput"><code>Interface Builder</code></strong>. However, the tools make it fairly straightforward. Most of the time, you'll find that <strong class="userinput"><code>Interface Builder</code></strong> works perfectly fine, but when you find that you need more control, you can drop down to the code level and take it from there. The layout you have implemented right now uses quite some constraints. Luckily, you can refactor the detail page to have fewer constraints by using a <code class="literal">UIStackView</code> object. The next section will show you how to do this.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec16"></a>Improving layouts with UIStackView</h3></div></div></div><p>You have learned a lot by <span>manually</span><a id="id325350137" class="indexterm"></a> configuring the entire <span>layout</span><a id="id325350146" class="indexterm"></a> for your contact detail page because you had to make some decisions about how you have set up certain constraints. Luckily, a lot of this work can be done by a powerful component called <code class="literal">UIStackView</code>. Stack views are able to lay out views that are added next to each other or on top off each other all by itself. This saves you adding constraints for the vertical spacing between labels like you have done for the contact detail information.</p><p>Since stack views can also layout objects that are next to each other and stack view can be nested, it could also take care of the two-column layout that you implemented for screens with a regular width size class. And to top it all off, you can swap the direction in which a stack view lays out its items at runtime, meaning you can change it from horizontal to vertical depending on the available space.</p><p>This will simplify a lot of the work you have already done and it makes your layout a lot more maintainable as well. To use a stack view, all you need to do is add one to your storyboard and begin adding items to it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl3sec23"></a>Containing labels in a stack view</h4></div></div></div><p>Open your <code class="literal">Main.storyboard</code> file and select a device that has a compact width, such as an iPhone Xs, for instance. Select the six labels in the contact info view and embed them in a stack view by using the <strong class="userinput"><code>Embed In</code></strong> menu as shown in the following screenshot.</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/d88f3d40-8abe-45a2-be63-ac330cb91e7f.png" /></div><p>Now find the stack view in the <strong class="userinput"><code>Document Outline</code></strong> and drag it up so that it ends up above the view that currently contains it. Once you have done this, the stack view is no longer a child view of that view so you can remove it. Move the stack view to roughly to the position that the old view was in.</p><p>The next step is to select the notes <span>label</span><a id="id325350192" class="indexterm"></a> and the text field and embed them in a <span>stack</span><a id="id325350201" class="indexterm"></a> view too using the <strong class="userinput"><code>Embed In</code></strong> menu. Drag this stack view out from its parent view as well so it ends up on the same level in the <strong class="userinput"><code>Document Editor</code></strong> as the other stack view you just created. Remove the remaining, empty view as well and position the new stack view roughly where the old view was positioned.</p><p>Select both stack views and use the <strong class="userinput"><code>Embed In</code></strong> menu once more to embed the stack views in another stack view so both stack views are placed on top of each other. You are now ready to add some constraints that position the newly created stack view. You will need to add the following constraints:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The stack view's top should be positioned 40 points below the name label's bottom.</li><li style="list-style-type: disc">The stack view's left edge should be positioned 8 points from the superview's left edge.</li><li style="list-style-type: disc">The stack view's right edge should be positioned 8 points from the superview's right edge.</li><li style="list-style-type: disc">The stack view's bottom should be positioned 8 points from the superview's bottom.</li></ul></div><p>Add these constraints using the <span class="emphasis"><em>Ctrl</em></span> + drag technique. You can either drag within the views itself or you can use the <strong class="userinput"><code>Document Outline</code></strong> for easy access by dragging from the stack view to its superview.</p><p>After you have added the constraints, your layout should resemble the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/1fd0ef9f-c6f7-47fe-98a2-4f59133a24e1.png" /></div><p>This is quite close to the layout you implemented before but it's not quite the same yet. To achieve the same effect, you're going to have to tweak some settings on the stack view. Select the stack view and look at the <strong class="userinput"><code>Attributes Inspector</code></strong>. You'll find that there are a couple of settings that you can configure. The settings you should look at for now are <strong class="userinput"><code>Spacing</code></strong>, <strong class="userinput"><code>Distribution</code></strong>, and <strong class="userinput"><code>Alignment</code></strong>. First, update the <strong class="userinput"><code>Spacing</code></strong> and set it to 16. This value controls the amount of space between each of the stack view's children. In this case, the only two children are the stack views that contain the contact's details and the notes area.</p><p>After adjusting the spacing, update the <strong class="userinput"><code>Distribution</code></strong> property so it is set to <strong class="userinput"><code>Equal Spacing</code></strong>; this will make sure that the stack view does everything it can to make sure the spacing between its children is always the same. In this case, you won't find much difference but you'll find that this property can be crucial to set in some other cases.</p><p>Lastly, set the <strong class="userinput"><code>Alignment</code></strong> to be <strong class="userinput"><code>Fill</code></strong>. This setting makes sure that items are positioned a certain way within the stack view. In this case, <strong class="userinput"><code>Leading</code></strong> makes the items stick to the left side of the stack view. Setting this value to <strong class="userinput"><code>Center</code></strong> would align them in the middle and <strong class="userinput"><code>Fill</code></strong> ensures that the stack's children are all stretched out to fill the entire width.</p><p>Once you have adjusted the stack view's configuration, you'll see that the layout looks exactly as planned for the compact size class. The regular size class still needs some work though because it doesn't lay out the bottom views in a two-column layout anymore with this setup. To fix this, select a device with a large screen and begin a <strong class="userinput"><code>Vary for Traits</code></strong> session.</p><p>Select the outer stack view and go to the <strong class="userinput"><code>Attributes Inspector</code></strong>. Using the plus icon next to the <strong class="userinput"><code>Axis</code></strong> setting, you can add a variation for the current size class configuration (regular width). Instead of setting the <strong class="userinput"><code>Axis</code></strong> to <strong class="userinput"><code>Vertical</code></strong>, you should set it to <strong class="userinput"><code>Horizontal</code></strong> and the stack view will update the view on large screens so the column is a two-column layout again.</p><p>To make sure both views are the same size, add a variation for <strong class="userinput"><code>Distribution</code></strong> as well and select <strong class="userinput"><code>Fill Equally</code></strong> instead of <strong class="userinput"><code>Equal Spacing</code></strong>. This setting ensures that all children of the stack view take the same amount of space on the layout axis. In this case, this means both child views will have the exact same width within the stack view.</p><p>You can now click <strong class="userinput"><code><span>Done varying</span></code></strong> and run your app on several devices. You'll find that the layout adapts perfectly with significantly fewer constraints in the bottom section of the app. Quite neat, right?</p></div></div></div>