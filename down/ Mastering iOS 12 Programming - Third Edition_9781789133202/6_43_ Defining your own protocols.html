<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec46"></a>Defining your own protocols</h2></div></div><hr /></div><p>Swift and <code class="literal">UIKit</code> have <span>protocols</span><a id="id325575090" class="indexterm"></a> at the core of their design. You might have noticed this when you were implementing custom <code class="literal">UIViewController</code> transitions, or when you worked on a table view or collection view. When you implement these features, you create objects that function as delegates for the transitions, table views, and collection views, <span>and conform them to specific protocols.</span> When you worked on view controller transitions in <code class="literal">Chapter 4</code>, <span class="emphasis"><em>Immersing Your Users with Animation</em></span>, you also implemented an <code class="literal">NSObject</code> subclass that conformed to <code class="literal">UIViewControllerAnimatedTransitioning</code>.</p><p>It's possible for you to define and use your own protocols. Protocols are not confined to delegate behavior only. Defining a protocol is very similar to defining a class, struct, or enum. The main difference is that a protocol does not implement or store any values on its own. It acts as a contract between whoever calls an object that conforms to a protocol and the object that claims to conform to the protocol.</p><p>Create a new <span class="emphasis"><em><strong class="userinput"><code>Playground</code></strong></em></span> (<strong class="userinput"><code>File | New... | Playground</code></strong>) if you want to follow along, or check out the Playground in this book's code bundle.</p><p>Let's implement a simple protocol that defines the expectations for any object that claims to be a pet. The protocol will be called the <code class="literal">PetType</code> protocol. Many protocols defined in <code class="literal">UIKit</code> and the Swift standard library use either <code class="literal">Type</code>, <code class="literal">Ing</code>, or <code class="literal">Able</code> as a suffix to indicate that the protocol defines a behavior rather than a concrete type. You should try to follow this convention as much as possible because it makes your code easier to understand for other developers:</p><pre class="programlisting">protocol PetType {
  var name: String { get }
  var age: Int { get set }

  func sleep()

  static var latinName: String { get }
}</pre><p>The definition for <code class="literal">PetType</code> states that any object that claims to be <code class="literal">PetType</code> must have a get-only variable (a constant) called <code class="literal">name</code>, an <code class="literal">age</code> that can be changed because it specifies both <code class="literal">get</code> and <code class="literal">set</code>, a method that makes the pet <code class="literal">sleep()</code>, and finally, a static variable that describes the Latin name of <code class="literal">PetType</code>.</p><p>Whenever you define that a <span>protocol</span><a id="id325606086" class="indexterm"></a> requires a certain variable to exist, you must also specify whether the variable should be gettable, settable, or both. If you specify that a certain method must be implemented, you write the method just as you usually would, but you stop at the first curly bracket. You only write down the method signature.</p><p>A protocol can also require that the implementer has a static variable or method. This is convenient in the case of <code class="literal">PetType</code> because the Latin name of a pet does not necessarily belong to a specific pet, but to the entire species that the pet belongs to, so implementing this as a property of the object rather than the instance makes a lot of sense.</p><p>To demonstrate how powerful a small protocol such as <code class="literal">PetType</code> can be, you will implement two pets: a cat and a dog. You'll also write a function that takes any pet and then makes them take a nap by calling the <code class="literal">sleep()</code> method.</p><p>To do this in OOP, you would create a <code class="literal">class</code> called <code class="literal">Pet</code>, and then you'd create two subclasses, <code class="literal">Cat</code> and <code class="literal">Dog</code>. The <code class="literal">nap</code> method would take an instance of <code class="literal">Pet</code>, and it would look a bit like this:</p><pre class="programlisting">func nap(pet: Pet) {   
    pet.sleep()   
} </pre><p>The object-oriented approach is not a bad one. Also, on such a small scale, no real problems will occur. However, when the inheritance hierarchy grows, you typically end up with base classes that contain methods that are only relevant to a couple of subclasses. Alternatively, you will find yourself unable to add certain functionalities to a certain class because the inheritance hierarchy gets in the way after a while.</p><p>Let's see what it looks like when you use the <code class="literal">PetType</code> protocol to solve this <span>challenge</span><a id="id325607233" class="indexterm"></a> without using inheritance at all:</p><pre class="programlisting">protocol PetType {
  var name: String { get }
  var age: Int { get set }

  func sleep()

  static var latinName: String { get }
}

struct Cat: PetType {
  let name: String
  var age: Int

  static let latinName: String = "Felis catus"

  func sleep() {
    print("Cat: ZzzZZ")
  }
}

struct Dog: PetType {
  let name: String
  var age: Int

  static let latinName: String = "Canis familiaris"

  func sleep() {
    print("Dog: ZzzZZ")
  }
}

func nap(pet: PetType) {
  pet.sleep()
}</pre><p>We just managed to implement a single <span>method</span><a id="id325607248" class="indexterm"></a> that can take both the <code class="literal">Cat</code> and <code class="literal">Dog</code> objects and makes them take a nap. Instead of checking for a class, the code checks that the pet that is passed in conforms to the <code class="literal">PetType</code> protocol, and if it does, its <code class="literal">sleep()</code> method can be called because the protocol dictates that any <code class="literal">PetType</code> must implement a <code class="literal">sleep()</code> method. This brings us to the next topic of this chapter: checking for traits instead of types.</p></div>