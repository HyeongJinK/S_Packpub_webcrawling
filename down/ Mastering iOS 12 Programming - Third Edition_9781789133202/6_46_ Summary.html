<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec49"></a>Summary</h2></div></div><hr /></div><p>In this chapter, you saw how you can leverage the power of protocols to work with an object's traits or capabilities, rather than just using its class as the only way of measuring its capabilities. Then, you saw how protocols can be extended to implement a default functionality. This enables you to compose powerful types by merely adding protocol conformance, instead of creating a subclass. You also saw how protocol extensions behave depending on your protocol requirements, and that it's wise to have anything that's in the protocol extension defined as a protocol requirement. This makes the protocol behavior more predictable. Finally, you learned how associated types work and how they can take your protocols to the next level by adding generic types to your protocols that can be tweaked for every type that conforms to your protocol. You even saw how you can apply generics to other objects, such as functions and structs.</p><p>The concepts shown in this chapter are pretty advanced, sophisticated, and powerful. To truly master their use, you'll need to train yourself <span>to think regarding traits instead of an inheritance hierarchy</span>. Once you've mastered this, you can experiment with protocol extensions and generic types. It's okay if you don't fully understand these topics right off the bat; they're completely different and new ways of thinking for most programmers with OOP experience. Now that we've explored some of the theory behind protocols and value types, in the next chapter, you will learn how you can put this new knowledge to use by shortly revisiting the <span class="strong"><strong>Hello-Contacts</strong></span> app from previous chapters to improve the code you wrote there.</p></div>