<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec67"></a>Updating Core Data objects with fetched data</h2></div></div><hr /></div><p>So far, the only thing you have stored in <span>Core</span><a id="id325357372" class="indexterm"></a> Data is movie names. You will expand this functionality by performing a lookup for a certain movie name through the movie database API. The fetched information will be used to display and store a popularity rating for the movies in the Core Data database.</p><p>A task such as this seems straightforward at first; you could come up with a flow such as the one shown in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>A user indicates their favorite movie.</li><li>The movie's popularity rating is fetched.</li><li>The movie and its rating are stored in the database.</li><li>The interface updates with the new movie.</li></ol></div><p>At first glance, this is a fine strategy; insert the data when you have it. However, it's important to consider that API calls are typically done asynchronously so the user interface stays responsive. More importantly, API calls can be really slow if your user doesn't have a good internet connection. This means that you would be updating the interface with very noticeable lag if the preceding steps are executed one by one.</p><p>The following would be a much better approach to implement the feature at hand:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The users indicates their favorite movie.</li><li>The users store the movie.</li><li>Update the interface with the new movie.</li><li>Begin popularity fetching.</li><li>Update the movie in the database.</li><li>Update the interface with the popularity.</li></ol></div><p>This approach is somewhat more complex, but it will give the user a responsive experience. The interface will respond to new movies immediately by showing them, and then automatically updates as soon as new data is retrieved. Before you can fetch the data and update the models, the Core Data model must be updated in order to store the movie's popularity rating.</p><p> </p><p>Open the Core Data model editor and select the <code class="literal">Movie</code> entity. All you have to do is add a new property and name it <span class="strong"><strong>popularity</strong></span>. Select the <code class="literal">Double</code> type for this property because the <span class="strong"><strong>popularity</strong></span> is stored as a decimal value. You have to make sure that this property is optional since you won't be able to provide a value for it straight away:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/6a1f0de6-9417-4545-8a26-df6903cc7fec.png" /></div><p>If you've worked with <span>Core</span><a id="id325602507" class="indexterm"></a> Data prior to when iOS 10 was released, this is the part where you expect to read about migrations and how you can orchestrate them. However, for simple changes such as this, we don't need to manage migrations. All you need to do is simply build and run your application to regenerate your model definitions, and for a simple change, such as the one we performed just now, Core Data will automatically manage the migration on its own.</p><p> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note30"></a>Note</h3><p>If you want to support iOS versions earlier than 10, make sure you read up on Core Data migrations. Whenever you update your models, you have to make sure that your database can properly migrate from one model version to another. During development, this isn't extremely important: you just reinstall the app whenever your models change. However, app updates will crash on launch if the Core Data model isn't compatible with the previous model.</p></div><p>Now that the model is updated, let's figure out how to implement the flow that was described earlier.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec44"></a>Implementing the fetch logic</h3></div></div></div><p>The asynchronous nature of network <span>requests</span><a id="id325604090" class="indexterm"></a> makes certain tasks, such as the one you're about to implement, quite complex. Usually, when you write code, its execution is very predictable. Your app typically runs line by line, so any line that comes after the previous one can assume that the line before it has finished executing. This isn't the case with asynchronous code. Asynchronous code is taken off the main thread and runs separately from the rest of your code. This means that your asynchronous code might run in parallel with other code. In the case of a network request, the asynchronous code might execute seconds after the function that initiated the request.</p><p>This means that you need to figure out a way to update and save movies that were added as soon as the rating has been retrieved. What's interesting about this is that once you see the code that implements this feature, it will feel natural to you that this is how it works. However, it's important that you're aware of the fact that it's not as straightforward as it may seem at first.</p><p>It's also important that you're aware of the fact that the code you're about to look at is executed on multiple threads. This means that even though all pieces of the code are defined in the same place, they are not executed on the same thread. The callback for the network request is executed on a different thread than the code that initiated the network request. You have already learned that Core Data is not thread-safe. This means that you can't safely access a Core Data object on a different thread than the thread it was created on.</p><p>If this confuses you, that's okay. You're supposed to be a bit confused right now. Asynchronous programming is not easy, and fooling you into thinking it is will cause frustration once you run into concurrency-related troubles (and you will). Whenever you work with callbacks, closures, and multiple threads, you should be aware that you're doing complex work that isn't straightforward.</p><p>Now that you understand that asynchronous code is hard, let's take a closer look at the feature you're about to implement. It's time to start implementing the network request that fetches popularity ratings for movies. You will abstract the fetching logic into a helper named <code class="literal">MovieDBHelper</code>. Go ahead and create a new helper folder in Xcode and add a new Swift file called <code class="literal">MovieDBHelper.swift</code> to it.</p><p> </p><p> </p><p>Abstracting this logic into a helper has multiple advantages. One of them is simplicity; it will keep our view controller code nice and clean. Another advantage is flexibility. Let's say that you want to combine multiple rating websites, or a different API, or compute popularity based on the number of <span>family</span><a id="id325605893" class="indexterm"></a> members who added this same title to their list; it will be easier to implement since all the logic for ratings is in a single place.</p><p>Add the following skeleton implementation to the <code class="literal">MovieDBHelper</code> file:</p><pre class="programlisting">struct MovieDBHelper {
  typealias MovieDBCallback = (Double?) -&gt; Void
  let apiKey = "YOUR_API_KEY_HERE"

  func fetchRating(forMovie movie: String, callback: @escaping MovieDBCallback) {

  }

  private func url(forMovie movie: String) -&gt; URL? {
    guard let query = movie.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)
      else { return nil }

    var urlString = "https://api.themoviedb.org/3/search/movie/"
    urlString = urlString.appending("?api_key=\(apiKey)")
    urlString = urlString.appending("&amp;query=\(query)")

    return URL(string: urlString)
  }
}</pre><p>The preceding code starts off with an interesting line:</p><pre class="programlisting">typealias MovieDBCallback = (Double?) -&gt; Void</pre><p>This line specifies the type that's used for the callback closure that's called when the rating is fetched. This callback will receive an optional <code class="literal">Double</code> as its argument. If the network request fails for any reason, the <code class="literal">Double</code> will be <code class="literal">nil</code>. Otherwise, it contains the rating for the movie that the request was created for.</p><p>The snippet also contains a dummy method that performs the fetch; you will implement this method soon. Finally, there's a method that builds a URL. This method is private because it's only supposed to be used inside of the helper struct. Note that the movie is converted to a percent-encoded string. This is required because if your user adds a movie with spaces in it, you would end up with an invalid URL if the spaces aren't properly encoded.</p><p>Before you implement <code class="literal">fetchRating(forMovie:callback)</code>, add a new file named <code class="literal">MovieDBResponse.swift</code> to the helper folder. This file will be used to define a struct that represents the response we expect to receive from the <code class="literal">Moviedb</code> API. Add the following implementation to this file:</p><pre class="programlisting">struct MovieDBLookupResponse: Codable {

  struct MovieDBMovie: Codable {
    let popularity: Double?
  }

  let results: [MovieDBMovie]
}</pre><p>The preceding code uses a nested <span>struct</span><a id="id325606077" class="indexterm"></a> to represent the movie objects that are part of the response. This is similar to what you saw in the playground example. Structuring the response this way makes the intent of this helper very obvious, which usually makes code easier to reason about. With this struct in place, let's see what the implementation of <code class="literal">fetchRating(forMovie:callback)</code> looks like in the following code:</p><pre class="programlisting">func fetchRating(forMovie movie: String, callback: @escaping MovieDBCallback) {
  guard let searchUrl = url(forMovie: movie) else {
    callback(nil)
    return
  }

  let task = URLSession.shared.dataTask(with: searchUrl) { data, response, error in
    var rating: Double? = nil

    defer {
      callback(rating)
    }

    let decoder = JSONDecoder()

    guard error == nil, let data = data,
      let lookupResponse = try? decoder.decode(MovieDBLookupResponse.self, from: data),
      let popularity = lookupResponse.results.first?.popularity
      else { return }

    rating = popularity
  }

  task.resume()
} </pre><p>This implementation looks very similar to what you experimented with earlier in the playground. The URL-building method is used to create a valid URL. If this fails, it makes no sense to attempt requesting the movie's rating, so the callback is called with a <code class="literal">nil</code> argument. This will inform the caller of this method that the execution is done and no result was retrieved.</p><p>Next, a new data task is created and <code class="literal">resume</code> is called on this task to kick it off. There is an interesting aspect to how the callback for this data task is called, though. Let's take a look at the following lines of code:</p><pre class="programlisting">var rating: Double? = nil   

defer {   
  callback(rating)   
} </pre><p>A <code class="literal">rating</code> double is created here, and it is given an initial value of <code class="literal">nil</code>. Then there's a <code class="literal">defer</code> block. The code inside of the <code class="literal">defer</code> block is called right before exiting the scope. In other words, it's executed right before the code returns from a function or closure.</p><p>Since this defer block is defined inside the callback for the data task, the callback for the <code class="literal">fetchRating(forMovie:callback:)</code> method is always called just before the data task callback is exited. This is convenient because all you must do is set the value for the rating to a double, and you don't have to manually invoke the callback for each possible way the scope can be exited. This also applies when you return because of unmet requirements. For instance, if there is an error while calling the API, you don't need to invoke the callback. You can simply return from the closure, and the callback is called automatically. This strategy can also be applied if you instantiate or configure objects temporarily and you want to perform some clean-up when the method, function, or closure is done.</p><p>The rest of the code should be fairly straightforward since most of it is nearly identical to the code used in the playground. Now that you have the networking logic down, let's take a look at how to actually update the movie object with a popularity rating.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec45"></a>Updating a movie with a popularity rating</h3></div></div></div><p>To update the movie object, you will <span>implement</span><a id="id325607230" class="indexterm"></a> the final step of the approach that was outlined <span>earlier</span>. You need to asynchronously fetch a rating from the movie database and then use that rating to update the movie. The following code should be added to <code class="literal">MoviesViewController.swift</code>, right after adding a new movie to a family member, inside of the <code class="literal">persist</code> block, approximately at line 35 (depending on how you have formatted your code):</p><pre class="programlisting">let helper = MovieDBHelper()
helper.fetchRating(forMovie: name) { rating in
  guard let rating = rating
    else { return }

  moc.persist {
    movie.popularity = rating
  }
} </pre><p>You can see that the helper abstraction provides a nice interface for the view controller. You can simply use the helper and provide it a movie to fetch the rating for with a callback and you're all set. Abstracting code like this can make maintaining your code a lot more fun in the long run.</p><p>The most surprising thing in the preceding snippet is that <code class="literal">moc.persist</code> is called again inside of the helper callback. This must be done because this callback is actually executed long after the initial persist has finished. Actually, this callback isn't even executed on the same thread as the code it's surrounded by.</p><p>To see how your code fails if you don't properly persist your model, try replacing the <code class="literal">moc.persist</code> block in the rating retrieval callback with the following code:</p><pre class="programlisting">movie.popularity = rating  
do {  
  try moc.save()  
} catch {  
  moc.rollback()  
}</pre><p>If you add a new movie now, the rating <span>will</span><a id="id325357561" class="indexterm"></a> still be fetched. However, you will suddenly run into issues when reloading your table view. This is because the managed object context was saved on a background thread. This means that the notification that informs the table view about updates is also sent on a background thread. You could resolve the issue by pushing the <code class="literal">reloadData()</code> call onto the main thread as you've done before, but in this case, doing so would only make the problem worse. Your app might work fine for a while, but once your app grows in complexity, using the same managed object context in multiple threads will most certainly cause crashes. Therefore, it's important to always make sure that you access managed objects and their contexts on the correct thread by using a construct, such as the <code class="literal">persist</code> method we implemented for this app.</p><p>Now that you have looked at all the code involved, let's see what all this threading talk means in a more visual way.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec46"></a>Visualizing multiple threads</h3></div></div></div><p>The following diagram <span>will</span><a id="id325357586" class="indexterm"></a> help you understand multiple threads:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/2bc9a772-804a-41ad-948b-8b75e170a62d.png" /></div><p>When <code class="literal">saveMovie(withName:)</code> is called, the execution is still on the main thread. The persistence block is opened, the movie is created, its name is set, a helper is created, and then <code class="literal">fetchRating(forMovie:callback:)</code> is called on the helper. This call itself is still on the main thread. However, the fetching of data is pushed to a background thread. This was discussed <span>earlier</span> when you experimented with fetching data in a playground.</p><p>The callback that's invoked by <code class="literal">dataTask</code> is called on the same background thread that the task itself is on. The code will do its thing with the JSON and finally, the callback that was passed to <code class="literal">fetchRating(forMovie:callback:)</code> is called. The code inside of this callback is executed on the background thread as well.</p><p>You can see that the set movie-rating step in the update flow is somehow pushed back to the main thread. This is because of the <code class="literal">persist</code> method that you added as an extension to the managed object context. The context uses the <code class="literal">perform</code> method internally to ensure that any code we execute inside of the <code class="literal">persist</code> block is executed on the thread the managed object context is on. Also, since the managed object context was created on the main thread, the movie rating <span>will</span><a id="id325357639" class="indexterm"></a> be set on the main thread.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note31"></a>Note</h3><p>If you didn't set the movie rating on the same thread that the managed object belongs to, you would get errors and undefined behavior. Always make sure that you manipulate Core Data objects on the same thread as their managed object context.</p></div><p>Threading is a complex subject, but it's essential for building responsive applications. Network logic is a great example of why multithreading is important. If we didn't perform the networking on a separate thread, the interface would be unresponsive for the duration of the request. If you have other operations that might take a while in your app, consider moving them onto a background thread so they don't block the user interface.</p></div></div>