<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch22lvl1sec149"></a>Implementing custom, interactive iMessage apps</h2></div></div><hr /></div><p>Sticker apps are nice, but they're not <span>particularly</span><a id="id325333114" class="indexterm"></a> interactive. You can build far more interesting and interactive applications for iMessage through the Messages framework. Some of the larger, well-known apps on iOS have been able to implement iMessage extensions that make sharing content from their apps easier. There are even people that have built games in iMessage! The Messages framework allows developers to build a wide range of extensions straight into the Messages app.</p><p>You have just seen how you can build sticker packs and how you can create a somewhat customized sticker pack by picking the app template instead of the sticker pack template in Xcode. You haven't gone in-depth into the different life cycle methods that Xcode generates for you when you create a new iMessage app.</p><p>To go into more depth with the <span class="strong"><strong>Messages</strong></span> framework, you will build an iMessage app for <span class="strong"><strong>The Daily Quote</strong></span>. You built a widget for this app in <a class="ulink" href="https://#" target="_blank"><span>Chapter</span> 19</a>, <span class="emphasis"><em>Instant Information with a Today Extension</em></span>. First, you will learn what the life cycle for an iMessage app looks like. After that, you will implement your own iMessage app.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch22lvl2sec117"></a>Understanding the iMessage app life cycle</h3></div></div></div><p>An iMessage app lives inside the <span>Messages</span><a id="id325333933" class="indexterm"></a> app, just like you would expect from an extension. As mentioned before, iMessage apps are a special kind of extension, which makes them behave a lot like apps even though they are still extensions at their core.</p><p>The main view controller for an iMessage app must always be a subclass of <code class="literal">MSMessagesAppViewController</code>. You can't have a primary view controller that is not a subclass of this class. When the user navigates to your extension through the iMessage apps drawer, this view controller is added where the keyboard would normally be placed. This size for the extension is called compact mode.</p><p>When the Messages framework instantiates your extension, the <code class="literal">willBecomeActive(with:)</code> method is called, followed by <code class="literal">didBecomeActive(with:)</code>. These methods are called after <code class="literal">viewDidLoad()</code> in the view controller life cycle, but before <code class="literal">viewWillAppear(_:)</code>. When it's time to dismiss your extension, the <code class="literal">viewWillDisappear(_:)</code> and <code class="literal">viewDidDisappear(_:)</code> life cycle methods are called. Next, <code class="literal">willResignActive(with:)</code> and <code class="literal">didResignActive(with:)</code> are called.</p><p>Once the resignation methods are called, the process for your iMessage app is killed shortly thereafter. You do not get any time to do work in the background. This is also true for other extension types. Again, even though Messages extensions behave a lot like apps, they're not.</p><p>There are two more methods <span>you</span><a id="id325571677" class="indexterm"></a> should know about for now. These methods are called whenever your iMessage app is transitioning from one display mode to another. The display mode is changed whenever the user expands the iMessage app by dragging the handle that is shown above your extension's view.</p><p>You can also trigger this transition from code by calling <code class="literal">requestPresentationStyle(_:)</code>. The life cycle methods that get called when the extension changes its size are <code class="literal">willTransition(to:)</code> and <code class="literal">didTransition(to:)</code>. The first method is called right before the transition occurs, the second is called right after.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch22lvl2sec118"></a>Implementing the custom compact view</h3></div></div></div><p>To start implementing the Messages extension for <span class="strong"><strong>The Daily Quote</strong></span>, a new extension should be added to the project. Pick the <span class="strong"><strong>Messages extension</strong></span> and name it <code class="literal">The Daily Quote Messages</code>. Enable the <span class="strong"><strong>App Groups</strong></span> capability for this extension and include <code class="literal">Quotes.swift</code> in the extension target, just like you've done before.</p><p>You will use the same view-controller containment technique <span>you</span><a id="id325580586" class="indexterm"></a> used when building the custom sticker pack. This time you will add the view controller that should be displayed to the extension's Storyboard without connecting it to <code class="literal">MessagesViewController</code>. Before you do this and create the interface, you should implement the code for the compact view. The compact view will feature a quote, the creator of the quote, and a <span class="strong"><strong>Share</strong></span> button.</p><p>Create a new <code class="literal">UIViewController</code> subclass and name it <code class="literal">CompactViewController</code>. Make sure to add it to the correct target by selecting the extension's folder before creating the new file. The setup for this view controller will be really similar to all of the other view controllers you've created for <span class="strong"><strong>The Daily Quote</strong></span> and its extensions. The view will contain two outlets, one for the quote and one for its creator. In <code class="literal">viewDidLoad()</code>, the current quote should be fetched and the labels should be populated with the correct values. I trust you to be able to do this on your own. When in doubt, check the other projects. Alternatively, check the source code in the code bundle for this chapter.</p><p>When a user taps the Share button, the current quote should be shared as a message in the active conversation. This means that <code class="literal">MessagesViewController</code> will have to be aware of the share command that occurs in <code class="literal">CompactViewController</code>. To do this, you can create a <code class="literal">QuoteSelectionDelegate</code> protocol to which <code class="literal">MessagesViewController</code> can conform.</p><p>The delegate and the share action should be implemented in <code class="literal">CompactViewController</code>, as shown in the following code snippet:</p><pre class="programlisting">var delegate: QuoteSelectionDelegate? 

@IBAction func shareTapped() {  
  delegate?.shareQuote(Quote.current)  
}</pre><p>The delegate is optional because it can't be set before the view controller is initialized. The tap action simply calls a method on the delegate and passes the current quote along with it. Create a new file to define the protocol and name it <code class="literal">QuoteSelectionDelegate</code>. The protocol should be implemented as follows:</p><pre class="programlisting">protocol QuoteSelectionDelegate {  
  func shareQuote(_ quote: Quote)  
}</pre><p>This is a simple protocol with just a single <span>method</span><a id="id325602501" class="indexterm"></a> requirement. Now, let's write all the required code in <code class="literal">MessagesViewController</code> before implementing the interface for <code class="literal">CompactViewController</code>. First of all, add the property shown in the following snippet to the message view controller so it can hold on to the compact view controller. Also, update your <code class="literal">viewDidLoad</code> implementation as follows:</p><pre class="programlisting">var compactViewController: CompactViewController?  

override func viewDidLoad() {
  super.viewDidLoad()

  compactViewController = storyboard?.instantiateViewController(withIdentifier: "CompactViewController") as? CompactViewController
  compactViewController?.delegate = self
}</pre><p>The <code class="literal">instantiateViewController(withIdentifier:)</code> method from <code class="literal">UIStoryboard</code> is used to obtain an instance of <code class="literal">CompactViewController</code> from the storyboard.</p><p>Add an extension to <code class="literal">MessagesViewController</code> so it conforms to <code class="literal">QuoteSelectionDelegate</code>. Add an empty implementation for <code class="literal">shareQuote(_:)</code> to the extension. You will implement the share functionality <span>later</span>.</p><p>Because the user can switch between the compact and expanded state as they please, it's a good idea to abstract the code to show the compact and expanded views into their own methods. Doing this will make your code easier to read, and it avoids code duplication. Add the following method to <code class="literal">MessagesViewController</code> to show the compact view controller:</p><pre class="programlisting">func showCompactView() {
  guard let compactViewController = self.compactViewController
    else { return }

  compactViewController.willMove(toParent: self)
  addChild(compactViewController)
  compactViewController.didMove(toParent: self)

  view.addSubview(compactViewController.view)
  compactViewController.view.frame = view.frame
}</pre><p>This code is very similar to what you saw when you implemented the sticker pack. The last step to show the compact view is to implement <code class="literal">willBecomeActive(with:)</code>. <code class="literal">showCompactView()</code> will be called from this <span>method</span><a id="id325605898" class="indexterm"></a> as follows:</p><pre class="programlisting">override func willBecomeActive(with conversation: MSConversation) {
  if self.presentationStyle == .compact {
    showCompactView()
  }
}</pre><p>Now, open <code class="literal">MainInterface.storyboard</code> and drag out a view controller. Add two labels and a button to this view controller. Lay them out as shown as shown in the following screenshot:</p><p> </p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/9f6ac8ef-4172-49d7-a00a-61450427832b.png" /></div><p>The quote is styled as a <code class="literal">title</code> and its maximum number of lines is set to <code class="literal">0</code> lines, so it automatically expands to fit the content. The creator is styled as <code class="literal">caption one</code>, and it's positioned below the title. The button should be laid out below the caption. Make sure to set <code class="literal">CompactViewController</code> as both the subclass and the storyboard ID for the view controller you just added. To wrap it up, connect the outlets to the views. Make sure to select <span class="strong"><strong>Touch up inside</strong></span> as the trigger action for <code class="literal">shareTapped()</code>.</p><p>If you build and run your <span>application</span><a id="id325606082" class="indexterm"></a> now, the quote for today should pop up right inside iMessage:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/3de688f7-6418-4fa5-bcaf-68d6c5f78ae7.png" /></div><p>This is all you need to do to implement the compact view. Now let's implement an expanded view for the iMessage app.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch22lvl2sec119"></a>Implementing the expanded view</h3></div></div></div><p>The expanded view for the <span>iMessage</span><a id="id325607100" class="indexterm"></a> app will be a table view that lists all of the quotes in the <code class="literal">Quote</code> struct. You will use a similar setup to the one you used before by creating a new view controller file and using the delegate protocol to communicate the selection of a quote back to <code class="literal">MessagesViewController</code>.</p><p>First, create a new <code class="literal">UITableViewController</code> subclass and name it <code class="literal">QuotesTableViewController</code>. You can remove most of the commented template code; the only methods you should keep are <code class="literal">tableView(_:cellForRowAt:)</code>, <code class="literal">tableView(_:numberOfRowsInSection:)</code>, and <code class="literal">numberOfSections(in:)</code>. In addition to the commented delegate methods, you can remove the <code class="literal">viewDidLoad()</code> and <code class="literal">didReceiveMemoryWarning()</code> methods; you don't need them.</p><p>For starters, you should implement the methods shown in the following code snippet. These methods provide the table view with its data:</p><pre class="programlisting">override func numberOfSections(in tableView: UITableView) → Int {
  return 1
}

override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) → Int {
  return Quote.numberOfQuotes
}

override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) → UITableViewCell {
  let cell = tableView.dequeueReusableCell(withIdentifier: "QuoteTableViewCell", for: indexPath)
  let quote = Quote.quote(atIndex: indexPath.row)

  cell.textLabel?.text = quote?.text
  cell.detailTextLabel?.text = quote?.creator
  return cell
}</pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><p>The preceding <span>snippet</span><a id="id325333512" class="indexterm"></a> uses a <code class="literal">numberOfQuotes</code> property on the <code class="literal">Quote</code> struct. However, this property is not defined yet. Add it to the <code class="literal">Quote</code> struct, as shown in the following code snippet:</p><pre class="programlisting">static var numberOfQuotes: Int { return quotes.count }</pre><p>The last thing you should take care of before creating and connecting the interface is the quote-selection delegate and implementing cell selection in <code class="literal">QuotesTableViewController</code>. The code to do this is pretty straightforward:</p><pre class="programlisting">var delegate: QuoteSelectionDelegate?

override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
  guard let quote = Quote.quote(atIndex: indexPath.row)
    else { return }
  delegate?.shareQuote(quote)
}</pre><p>This leaves you with a complete implementation of the table view in code. Let's create the interface in Interface Builder. Open <code class="literal">MainInterface.storyboard</code> and drag out a table view controller. Assign <code class="literal">QuotesTableViewController</code> as its class and Storyboard ID. Also, click the prototype cell and set its style to <span class="strong"><strong>Subtitle</strong></span>. The Identifier for the cell should be set to <code class="literal">QuoteTableViewCell</code>. That's all you need to do for now. Let's make sure that you display this view controller when the iMessage app is in the expanded presentation mode.</p><p>In <code class="literal">MessagesViewController</code>, update <code class="literal">willBecomeActive(with:)</code> so it can display both the expanded and compact mode as the initial view, depending on <code class="literal">presentationStyle</code>:</p><pre class="programlisting">override func willBecomeActive(with conversation: MSConversation) {
  if self.presentationStyle == .compact {
    showCompactView()
  } else if self.presentationStyle == .expanded {
    showExpandedView()
  }
}</pre><p>Since the user can manually change the display mode for the iMessage app, you will need to dynamically switch the view controller that is shown depending on the presentation style. Add the following implementation for <code class="literal">willTransition(to:)</code>:</p><pre class="programlisting">override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
  if presentationStyle == .compact {
    showCompactView()
  } else if presentationStyle == .expanded {
    showExpandedView()
  }
}</pre><p>Finally, you should take care of showing the correct view. You should always make sure to remove any existing view controllers before you show a new one. <code class="literal">showExpandedView()</code> has not been implemented yet, but if you think about what this method should do for a second, you will realize it should look very similar to the <code class="literal">showCompactView()</code> method. It's a good idea to implement a special cleanup method and refactor <code class="literal">showCompactView()</code>, so you can reuse it for <code class="literal">showExpandedView()</code>. First, add the following method that will be used to clean up the displayed view <span>controllers</span><a id="id325333602" class="indexterm"></a> when needed:</p><pre class="programlisting">func cleanupChildViewControllers() {
  for viewController in children {
    viewController.willMove(toParent: nil)
    viewController.removeFromParent()
    viewController.didMove(toParent: nil)

    viewController.view.removeFromSuperview()
  }
}</pre><p>One last thing that needs to be done before implementing the presentation of the expanded view controller is adding a property for this expanded view controller in <code class="literal">MessagesViewController</code> and updating <code class="literal">viewDidLoad()</code>, so it creates a new instance of <code class="literal">QuotesTableViewController</code> that will be used as the expanded view controller. Add the following property and the <code class="literal">viewDidLoad()</code> implementation to <code class="literal">MessagesViewController</code>:</p><pre class="programlisting">var expandedViewController: QuotesTableViewController?

override func viewDidLoad() {
  super.viewDidLoad()

  compactViewController = storyboard?.instantiateViewController(withIdentifier: "CompactViewController") as? CompactViewController
  compactViewController?.delegate = self

  expandedViewController = storyboard?.instantiateViewController(withIdentifier: "QuotesTableViewController") as? QuotesTableViewController
  expandedViewController?.delegate = self
}</pre><p>Next, let's implement the refactored view controller presentation methods:</p><pre class="programlisting">func showCompactView() {
  guard let compactViewController = self.compactViewController
    else { return }

  showViewController(compactViewController)
}

func showExpandedView() {
  guard let expandedViewController = self.expandedViewController
    else { return }

  showViewController(expandedViewController)
}

func showViewController(_ viewController: UIViewController) {
  cleanupChildViewControllers()

  viewController.willMove(toParent: self)
  addChild(viewController)
  viewController.didMove(toParent: self)

  view.addSubview(viewController.view)
  viewController.view.frame = view.frame
}</pre><p>After doing this, build and run the app to see your extension in action. It flawlessly switches between showing the list of quotes and the single daily quote.</p><p>The final step in implementing our iMessage app is to implement the <code class="literal">shareQuote(_:)</code> method. This method will compose a message that can be shared. Let's have a look at message composition and everything related to it.</p></div></div>