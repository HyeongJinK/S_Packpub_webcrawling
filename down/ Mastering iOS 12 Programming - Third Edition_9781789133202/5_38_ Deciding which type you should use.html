<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec42"></a>Deciding which type you should use</h2></div></div><hr /></div><p>Choosing the wrong type of object to use in your application can have bad implications for your app on several levels. For instance, your app could suffer from unwanted side-effects when a <span>reference</span><a id="id325333104" class="indexterm"></a> type is modified in some unexpected place. Or you could end up with a lot of duplicated logic if you use a struct instead of a class in certain places. Your app could even suffer in terms of performance when you choose a slow reference type where a value type would have been a better choice. You should always evaluate what type of object is best-suited for your current use case to make sure your code strikes a balanced trade-off between maintainability and performance.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec26"></a>When to use a reference type?</h3></div></div></div><p>A great time to use a reference type is when you are subclassing a built-in class, such as <code class="literal">UIViewController</code>. In these cases, there is no point in fighting the system because that would definitely do more harm than good. Another time to use a reference type is when you are creating your own delegate protocols.</p><p>Delegates are best implemented as weak <span>reference</span><a id="id325578353" class="indexterm"></a> types. This means that the object that acts as a delegate is referenced weakly by an object to avoid memory leaks. Because value types are passed around by making copies, it does not make sense to have a weak reference to them. In this case, your only choice is to use a reference type.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip21"></a>Note</h3><p>You can read more about memory leaks and reference cycles in <a class="link" href="#" linkend="ch24">Chapter 24</a>, <span class="emphasis"><em>Discovering Bottlenecks with Instruments</em></span>.</p></div><p>You also need a reference type if it doesn't make sense to pass around copies or something. If you think back to the example of driving to somebody's house, it makes a lot more sense to pass around the address of a house than to give everybody full copies of the house. You might consider the house as having an identity. This means that each house is <span class="emphasis"><em>unique</em></span>, there is only one house with that exact address and making copies of it makes no sense. If you are working with an object where copying it makes no sense, you likely want to implement it as a reference type, so everybody that receives an instance of that type is looking at the same instance.</p><p>One last reason to choose a <span>reference</span><a id="id325602482" class="indexterm"></a> type is if it can save you a lot of typing by subclassing. A lot of people consider subclassing bad, and you can often avoid it, but sometimes it just makes a lot more sense to work with a class hierarchy. The downside is that a lot of subclassing can lead to muddy classes that contain functionality to save typing on a couple of subclasses even though the functionality is not relevant to all subclasses. But just like many tools, subclassing can be quite convenient when used correctly; it's not inherently bad to use it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec27"></a>When to use a value type?</h3></div></div></div><p>It is often said that you should always start <span>with</span><a id="id325602497" class="indexterm"></a> a struct and change to a different type when needed. This is great advice for a lot of cases because structs are often fine for most cases. However, structs aren't the only value type, and it's always good to not default to using certain things blindly. If you need an object that represents a finite set of possible states or results, such as a network-connection state, a traffic-light state, or a limited set of valid configuration options for your app, you will likely need an enum. Regardless of the value semantics that make value types great, an enum is a great way to avoid typos and represent a state. It's often pretty clear when you should use an enum due to its nature.</p><p>Structs are used for objects that do not have an identity. In other words, it makes sense to pass copies of it around. A good example of this is when you create a struct that can communicate with the network or a database. This struct would have no identity because it's mostly a collection of properties and methods that aren't associated with a single version of the struct.</p><p>A good example of a struct is the <code class="literal">CGPoint</code> struct that you read about at the beginning of this structure. A <code class="literal">CGPoint</code> represents a location in a two-dimensional grid. It has no identity, and passing copies of it around makes sense. It only contains two properties, so it doesn't require any inheritance. These features make it a great candidate to be implemented as a value type.</p><p>If you follow the advice of always starting <span>with</span><a id="id325602538" class="indexterm"></a> a struct, try to figure out reasons for your new object to <span class="emphasis"><em>not</em></span> be a struct. If you find a good reason to not use a struct, then make it a class. Often you won't be able to find a good reason to use a class instead of a struct. If this is the case, make your new object a struct; you can always switch to using a class later. It's usually harder to switch from a class to a struct due to the stricter rules regarding mutability and the lack of subclassing for structs.</p></div></div>