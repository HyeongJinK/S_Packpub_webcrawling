<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch18lvl1sec124"></a>Scheduling and handling notifications</h2></div></div><hr /></div><p>Every <span>notification</span><a id="id325333110" class="indexterm"></a> you see on iOS has been scheduled or pushed to the user in one way or another. But before an app is even allowed to send notifications, there are a couple of things you must do. The steps you need to follow can be roughly divided as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Registering for notifications</li><li>Creating notification contents</li><li>Scheduling your notification</li><li>Handling incoming notifications</li></ol></div><p>Not every step is completely identical for local and remote notifications. When there are differences, and these will be very minor, they will be <span>described</span><a id="id325333142" class="indexterm"></a> in the relevant section. You will work on the <span class="strong"><strong>Notifications</strong></span> app that is included in the code bundle for this chapter.</p><p>The Notifications app contains a user interface that allows you to schedule different notifications for reminders that will trigger after a certain amount of time, so you can easily experiment with different notifications.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch18lvl2sec96"></a>Registering for notifications</h3></div></div></div><p>Any app that wants to present <span>notifications</span><a id="id325333797" class="indexterm"></a> has to ask the user for permission before they do so. This process is called registering for notifications. It's important that you make sure your user understands why you're asking their permission to send notifications. After all, you're interrupting your user while they're trying to achieve something in your app, and the permission alert prevents them from doing so. It's often a great idea to hold off on asking for permission to send notifications until the user does something that can be improved specifically by turning on notifications.</p><p>In the Notifications example app, a user can add reminders for certain actions that they need to perform. The best time to ask a user for permission to send them notifications is right after they create a new reminder. This will make it clear to the user that you want to send notifications to inform the user about the reminder they just added.</p><p>When you ask for permission to send notifications, you can specify the kinds of notification that you want to send the user. You can pick from the following types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Alerts</li><li style="list-style-type: disc">Badges</li><li style="list-style-type: disc">CarPlay</li><li style="list-style-type: disc">Sounds</li><li style="list-style-type: disc">Critical</li><li style="list-style-type: disc">Provisional</li></ul></div><p>The user can go into your app's page in the <span class="emphasis"><em>Settings</em></span> app at any time to change these settings. You can read these settings with the <code class="literal">UserNotifications</code> framework. By reading the current notification settings, you can inform your users about the current notification status, and ask them to turn <span>notifications</span><a id="id325333834" class="indexterm"></a> on if needed.</p><p>When you ask for a user's permission to send notifications and they deny permission to do so, or they disable notifications at a later stage, it's often a good idea to notify the user that they have notifications turned off, and then provide an easy way to turn notifications back on.</p><p>Reading the current notification settings and asking for permission to send notifications is always done through an <code class="literal">UNUserNotificationCenter</code> instance. You will typically obtain an instance of <code class="literal">UNUserNotificationCenter</code> through the static <code class="literal">current()</code> method.</p><p><code class="literal">UNUserNotificationCenter</code> is not to be confused with <code class="literal">NotificationCenter</code>. <code class="literal">UNUserNotificationCenter</code> is responsible for notifications such as push and local notifications, while <code class="literal">NotificationCenter</code> is used to send notifications internally inside your app. The user never sees or notices these notifications.</p><p>As you have learned before, it's good practice to extract certain parts of your code into a dedicated helper object. Create a new helper folder in the <strong class="userinput"><code>Notifications</code></strong> project and add a new Swift file, called <code class="literal">NotificationsHelper.swift</code>, to the group. Add the following implementation code to your new helper file:</p><pre class="programlisting">import UIKit
import UserNotifications

struct NotificationsHelper {
  let notificationCenter = UNUserNotificationCenter.current()
}</pre><p>The best moment to ask a user for permission to send them push notifications for this app is when they have just added a reminder. At this point, the user will understand exactly why they see the permission dialog, because they just performed an action that is closely related to the push <span>notifications</span><a id="id325357190" class="indexterm"></a> they will receive.</p><p>Add the following method to the notifications helper to ask the user for permission to send them notifications:</p><pre class="programlisting">func requestNotificationPermissions(_ completion: @escaping (Bool) -&gt; ()) {
  notificationCenter.requestAuthorization(options: [.badge, .sound, .alert]) { permissionGranted, error in
    completion(permissionGranted)
  }
}</pre><p>The preceding method calls the notification center's <code class="literal">requestAuthorization(options:completion:)</code>, and calls the completion closure that was passed to <code class="literal">requestNotificationPermissions(_:)</code> with the result of the permission prompt.</p><p>Before you can use the helper in the add notifications view controller to ask the user for notification permissions when they add a new reminder, you need to create an instance of the helper in <code class="literal">AddNotificationViewController</code>. Add the following property to this class:</p><pre class="programlisting">let notificationsHelper = NotificationsHelper()</pre><p>Also, add the following code to the end of the <code class="literal">createReminder(_:withComponents:inContext:)</code> method to ask the user for notification permissions after creating a new reminder:</p><pre class="programlisting">DispatchQueue.main.async { [weak self] in
  self?.notificationsHelper.requestNotificationPermissions { result in
    DispatchQueue.main.async {
      self?.enableNotificationsButton.isHidden = result
    }
  }
}</pre><p>Since the code inside of the <code class="literal">createReminder(_:withComponents:inContext:)</code> method is executed on a managed object context's queue, it's good practice to ensure that the notification prompt will be presented using the main thread, by wrapping the code in a <code class="literal">DispatchQueue.main.async</code> call. To learn more about how dispatch queues work and how you can use them, refer to <a class="link" href="#" linkend="ch25">Chapter 25</a>,Â <span class="emphasis"><em>Offloading Tasks with Operations and GCD</em></span>.</p><p>In addition to asking for notification permissions when the user adds a new reminder, permission should also be asked when the user enables the periodic drink water notification. Add the following implementation for <code class="literal">drinkWaterNotificationToggled(sender:)</code>:</p><pre class="programlisting">@IBAction func drinkWaterNotificationToggled(sender: UISwitch) {
  if sender.isOn {
    notificationsHelper.requestNotificationPermissions { [weak self] result in
      DispatchQueue.main.async {
        self?.enableNotificationsButton.isHidden = result
      }
    }
  }
}</pre><p>The add notification view contains a button that prompts the user to enable notifications for the app. This button should only be visible if the user has denied the notification permissions dialog, or if the user has turned off notifications for the app in their settings. Add the following method to the <span>notifications</span><a id="id325578422" class="indexterm"></a> helper to determine whether the user has turned off notifications for the app:</p><pre class="programlisting">func userHasDisabledNotifications(_ completion: @escaping (Bool) -&gt; ()) {
  notificationCenter.getNotificationSettings { settings in
    completion(settings.authorizationStatus == .denied)
  }
}</pre><p>The preceding code retrieves the current notification settings, and checks whether the current status is <code class="literal">.disabled</code>. There are a total of four possible authorization statuses: <code class="literal">.authorized</code>, <code class="literal">.denied</code>, <code class="literal">.notDetermined</code>, and <code class="literal">.provisional</code>. The following list describes what each status means:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">notDetermined</code> means that the app hasn't asked for permissions before.</li><li style="list-style-type: disc"><code class="literal">authorized</code> means that the app has asked for permissions and is allowed to send notifications to the user.</li><li style="list-style-type: disc"><code class="literal">denied</code> means that the app has asked for permissions to send notifications to the user, and the user denied this permission, because they either declined the permissions prompt, or they turned off notifications in their settings.</li><li style="list-style-type: disc"><code class="literal">provisional</code> means that the app is allowed to deliver quiet notifications to the <span>app</span> on a provisional basis.</li></ul></div><p>It's a good idea to read the current notification settings whenever the add notification view appears, so the button that takes the user to the settings page is always shown and hidden correctly, based on the current notification permissions. Add the following implementation for <code class="literal">viewWillAppear(_:)</code> to the <code class="literal">AddNotificationViewController</code> class:</p><pre class="programlisting">notificationsHelper.userHasDisabledNotifications { [weak self] notificationsDisabled in
  DispatchQueue.main.async {
    self?.enableNotificationsButton.isHidden = !notificationsDisabled
  }
}</pre><p>Before you test the app, add the following implementation for the <code class="literal">openSettingTapped()</code> method.</p><p>Add the following implementation for the <code class="literal">enableNotificationsTapped</code> action:</p><pre class="programlisting">@IBAction func openSettingsTapped() {
  let settingsUrl = URL(string: UIApplication.openSettingsURLString)
  UIApplication.shared.open(settingsUrl!, options: [:], completionHandler: nil)
}</pre><p>Â </p><p>The preceding implementation will take the user to the <span><span class="emphasis"><em>Settings</em></span></span> app, so they can easily enable notifications for the Notifications app. If you test the app now, you can add a new reminder, and the app will ask you for permission to send notifications. If permission is denied, the <span><span class="emphasis"><em>enable</em></span></span> button will appear at the bottom of the view. When you tap this button, you will be taken directly to the setting page, where you can again enable notifications.</p><p>The preceding code registers the app for local notifications. If you want to register the app for push notifications, you must enable the <strong class="userinput"><code>Push Notifications</code></strong> capability in the <strong class="userinput"><code>Capabilities</code></strong> tab. Note that you can only enable this capability if you're on Apple's paid developer program. Free developer accounts cannot enable this capability.</p><p>After enabling the push <span>notifications</span><a id="id325333257" class="indexterm"></a> capability, you need to add a couple of lines of code to make sure that you properly register the current device with APNS. To do this, you need to call a method on <code class="literal">UIApplication</code> that registers the current device on APNS. After calling this method, a delegate method in <code class="literal">AppDelegate</code> is called with the current device token that should be uploaded to your remote server, so you can send messages to the device through the device token.</p><p>Apple makes no guarantees about if and when a device's push token can change, so you should always register for remote notifications whenever the app launches. For the Notifications app, it makes sense to register for remote notifications as soon as the app enters the foreground, or when the user has just granted the app permission to send push notifications.</p><p>Add the following lines of code to the <code class="literal">requestNotificationPermissions(_:)</code> method in the notification helper, right after calling the completion handler:</p><pre class="programlisting">DispatchQueue.main.async {
  UIApplication.shared.registerForRemoteNotifications()
}</pre><p>Note that you must always call <code class="literal">UIApplication.shared.registerForRemoteNotifications()</code> on the main thread. Since the callback for <code class="literal">requestNotificationPermissions(_:)</code> is not guaranteed to be called on the main thread, you should manually ensure that you register for remote notifications on the main thread.</p><p>Next, implement the following methods in <code class="literal">AppDelegate</code>:</p><pre class="programlisting">func applicationDidBecomeActive(_ application: UIApplication) {
  UIApplication.shared.registerForRemoteNotifications()
}

func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
  print("received device token: \(deviceToken)")
}

func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
  print("Did not register for remote notifications: \(error.localizedDescription)")
}</pre><p>For demo purposes, the device token is printed to the console. In a real app, you should upload the device token to your server instead. You're all set to send <span>notifications</span><a id="id325333339" class="indexterm"></a> to your users now. Next, let's look at how you can create and configure notifications in your app.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch18lvl2sec97"></a>Creating notification contents</h3></div></div></div><p>Notifications typically <span>consist</span><a id="id325333354" class="indexterm"></a> of a few pieces of content. First of all, every notification has a title, a subtitle, and a message body. Not all fields have to be present, but you'll often want to provide a bit more information than just a piece of body text. You can also add media attachments to notifications. These attachments are used to provide a preview of a photo, video, or audio file that is stored locally on the device, and are great for providing better-looking, richer notifications to your user.</p><p>The biggest gap between local and remote notifications exists in the way you create them. Push notifications are always created on the server and are pushed to the device in a JSON format. Local notifications are created on the device using the <code class="literal">UNNotification</code> class. Let's look at each notification type separately.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch18lvl3sec43"></a>Creating push notifications</h4></div></div></div><p>If you ignore the <span>complexities</span><a id="id325333374" class="indexterm"></a> of setting up and <span>hosting</span><a id="id325333383" class="indexterm"></a> your own server, push notifications are actually pretty simple to create. Push notifications are always delivered using a JSON payload that your own server sends to APNS. APNS will then take care of sending your notification to the device that's intended to receive it. Let's look at a simple example of a JSON payload that could be used to inform users about a newsworthy event:</p><pre class="programlisting">{  
  "aps": {  
    "alert": {  
      "title" : "Breaking news!",  
      "body" : "iOS 12 was released"  
    },  
    "badge" : 1  
  },  
  "item_id" : "1"  
}</pre><p>This simple notification containsÂ onlyÂ a title and a body. The number<code class="literal">1</code>is added to the app icon to indicate the number of news items available. You'll notice that the notification content is placed in the<code class="literal">aps</code>dictionary. The<code class="literal">aps</code>dictionary contains the push notification's content. The<code class="literal">item_id</code>is not part of the<code class="literal">aps</code>dictionary on purpose; it's a custom property that can be read in the app so it can retrieve data about the news item from a local database, or fetch it from a backend using the ID.</p><p>If you want to send a silent push notification to trigger a background data refresh action, like CloudKit does, you should add the <code class="literal">content-available</code> key to the <code class="literal">aps</code> dictionary, specifying a value of <code class="literal">1</code>. If you want to use a custom sound for your notification, you can add a <code class="literal">sound</code> key to <code class="literal">aps</code>. The value of this key should point to an audio file that's embedded in your app. Finally, a notification can be part of a category of notifications. If this is the case, add a <code class="literal">category</code> key to the <code class="literal">aps</code> dictionary, where the value is the <span>category</span><a id="id325333576" class="indexterm"></a> identifier. For an overview of all of the possible keysÂ that can be added to the <code class="literal">aps</code> dictionary, have a look at Apple's Payload Key Reference documentation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch18lvl3sec44"></a>Creating local notifications</h4></div></div></div><p>Local notifications are created and <span>stored</span><a id="id325333594" class="indexterm"></a> locally on the device. They are very similar to push <span>notifications</span><a id="id325333603" class="indexterm"></a> in terms of the content they can contain. The way that content is created is quite different though. For instance, you can't create a local notification for content that doesn't exist yet.</p><p>In the context of a news app, this means that a server could push a news item to the application when needed. If you create the notification locally, you don't know what tomorrow's big news item will be, so you can't schedule a notification with content for this news item yet. This is an important distinction between local and push notifications that you should keep in mind when choosing whether you should create a notification locally, or if you should leave it up to a server to create the notification.</p><p>The following code snippet demonstrates the creation of a notification for a reminder. You should add this snippet to theÂ <code class="literal">NotificationsHelper</code>:</p><pre class="programlisting">func createNotificationContentForReminder(_ reminder: Reminder) -&gt; UNMutableNotificationContent {
  let content = UNMutableNotificationContent()

  content.title = "Reminder"
  content.body = reminder.title ?? ""
  content.badge = 1

  content.userInfo = ["reminder-uuid": reminder.identifier?.uuidString]

  return content
}</pre><p>This preceding code contains data that is quite similar to the JSON you saw previously. The main difference is that you create an instance of <code class="literal">UNMutableNotificationContent</code>Â and assign values to it, instead of defining the entire notification using JSON. A lot of the <span>options</span><a id="id325333630" class="indexterm"></a> that are available in the push example are also available for local notifications. You can add custom properties, such as the unique identifier for a reminder, to a <code class="literal">UNNotification</code> object's <code class="literal">userInfo</code> dictionary. You can also assign a custom sound, attachment, and more to local notifications, just as you can for push notifications.</p><p>Now that you know how to create notification contents, let's see how you can schedule them.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch18lvl2sec98"></a>Scheduling your notification</h3></div></div></div><p>In order to deliver local <span>notifications</span><a id="id325333654" class="indexterm"></a> to your users, you'll need to schedule them. This is another difference between local and push notifications. Push notifications do not need to be scheduled, because they are pushed through the server and delivered as soon as possible. When you schedule a local notification, you make use of a notification trigger. There are several notification triggers that you can use to send a notification:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Location-based</li><li style="list-style-type: disc">Calendar-based</li><li style="list-style-type: disc">Time-based</li></ul></div><p>Before you implement a proper notification to send reminders to a user, you will create a notification that is scheduled to fire a couple of seconds after creating it. You will then learn how to send a repeating notification that uses a time interval. Lastly, you will learn about calendar-based and location-based triggers.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch18lvl3sec45"></a>Scheduling a timed notification</h4></div></div></div><p>A <span>timed</span><a id="id325333682" class="indexterm"></a> notification is the <span>simplest</span><a id="id325333690" class="indexterm"></a> notification to schedule, which makes it a great candidate to explore first. Timed notifications are scheduled with an instance of <code class="literal">UNTimeIntervalNotificationTrigger</code>. The initializer for this class takes a time interval and a boolean value to indicate whether the notification should be sent to the user repeatedly. Add the following method to the <code class="literal">NotificationHelper</code>:</p><pre class="programlisting">func scheduleTimedNotificationWithContent(_ content: UNNotificationContent) {
  let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 10, repeats: false)
  let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
  notificationCenter.add(request) { error in
    if let error = error {
      print(error.localizedDescription)
    }
  }
}</pre><p>The preceding method creates a <code class="literal">trigger</code> for the notification. In this case, the notification is set up to fire after 10 seconds have passed. Next, a notification request is created. Every notification request should have an identifier. In this case, a very simple identifier is used to identify the timed notification. After creating the <span>notification</span>, it is added to the notification with a completion handler.</p><p>The <code class="literal">identifier</code> attribute for a notification should be unique for the content of the notification. The system uses this identifier to avoid sending multiple notifications with the same content. If you send multiple notifications with the same identifier, the last notification you sent will be shown to the user. If you want to display multiple notifications in the Notification Center, you should make sure that every notification you schedule has a unique identifier.</p><p>If you want to send a repeating notification to a user, you must set the <code class="literal">repeats</code> property for the time interval trigger to <code class="literal">true</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip46"></a>Note</h3><p>The minimum time interval for repeating notification is 60 seconds. Scheduling a repeating <code class="literal">trigger</code> with an interval under 60 seconds will crash your application.</p></div><p>To test the interval-based notification, you can add a call to <code class="literal">scheduleTimedNotificationWithContent(_:)</code> in <code class="literal">AddNotificationViewController</code> in the <code class="literal">addBedtimeNotification()</code> or <code class="literal">addLunchTimeNotification()</code> methods, after the following line:</p><pre class="programlisting">try? self.persistentContainer.viewContext.save()</pre><p>The following code can be added to schedule the <span>timed</span><a id="id325357214" class="indexterm"></a> notification:</p><pre class="programlisting">let content = notificationsHelper.createNotificationContentForReminder(reminder)
    notificationsHelper.scheduleTimedNotificationWithContent(content)</pre><p>If you run the app now, and schedule a reminder before going to your device's home screen or the lock screen, a notification about the reminder should appear after about 10 seconds. The following screenshot shows an example of a lunchtime reminder:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/1b1024fe-0e02-4c81-bf4f-8c7fffb4b5b8.png" /></div><p>The next notification you will explore is the calendar based notification.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch18lvl3sec46"></a>Scheduling a calendar-based notification</h4></div></div></div><p>Calendar-based <span>notifications</span><a id="id325357248" class="indexterm"></a> make use of <code class="literal">DateComponents</code> to determine when they <span>should</span><a id="id325357259" class="indexterm"></a> be fired. The only difference compared to the time-interval scheduling is in the <code class="literal">trigger</code> that is used to determine when the notification should be displayed.</p><p>Go right ahead and add the following method to <code class="literal">NotificationsHelper</code> to create a notification that is fired every hour, on the hour:</p><pre class="programlisting">func scheduleHourlyWaterReminder() {
  let content = UNMutableNotificationContent()

  content.title = "Reminder"
  content.body = "This is your reminder to drink some water every hour."

  var hourComponents = DateComponents()
  hourComponents.minute = 0

  let trigger = UNCalendarNotificationTrigger(dateMatching: hourComponents, repeats: true)
  let request = UNNotificationRequest(identifier: "water-notification", content: content, trigger: trigger)

  notificationCenter.add(request) { error in
    if let error = error {
      print(error.localizedDescription)
    }
  }
}</pre><p>The preceding code sets up a <code class="literal">trigger</code> that fires every hour when the value of the <code class="literal">minutes</code> component is <code class="literal">0</code>. Since this notification should trigger every hour, the <code class="literal">repeats</code> argument is set to true.</p><p>Since the user can choose to turn off the water reminder, you should also implement a method to remove the repeating notification. Add the following method to the notifications helper to do this:</p><pre class="programlisting">func unscheduleHourlyWaterReminder() {
  notificationCenter.removePendingNotificationRequests(withIdentifiers: ["water-notification"])
}</pre><p>Next, update <code class="literal">drinkWaterNotificationToggled(sender:)</code> in the add notifications view controller, so thatÂ <code class="literal">scheduleHourlyWaterReminder()</code> is called when the switch is on and <code class="literal">unscheduleHourlyWaterReminder()</code> is called when the switch is off.</p><p>Calendar-based notifications provide a <span>powerful</span><a id="id325357317" class="indexterm"></a> way for you to schedule both recurring and one-time-only notifications that are tied to aÂ specific moment in time that's easier to express in days, hours, weeks, or months, than in a <span>time interval.</span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch18lvl3sec47"></a>Scheduling a location-based notification</h4></div></div></div><p>The last type of <span>notification</span><a id="id325357405" class="indexterm"></a> you can schedule is a location-based notification. To set up a location-based trigger, you use Core Location to set up a region to which the trigger should belong.</p><p>A location-based trigger is actually very similar to <span>implementing</span><a id="id325357416" class="indexterm"></a> geofencing. If you need a refresher on geofences, skip back to <a class="link" href="#" linkend="ch13">Chapter 13</a>, <span class="emphasis"><em>Improving Apps With Location Services</em></span>. The main difference between a location-based notification and a geofence is that when a geofence triggers, the user is not necessarily informed about this. If a location-based notification triggers, the intent is to inform the user about it so they see a notification. Let's look at an example of how a location-based notification is set up:</p><pre class="programlisting">let coords = CLLocationCoordinate2D(latitude: 52.373095, longitude: 4.8909129)  
let region = CLCircularRegion(center: coords, radius: 1000, identifier: "quote-notification-region")  
region.notifyOnExit = false  
region.notifyOnEntry = true  
let trigger = UNLocationNotificationTrigger(region: region, repeats: false)</pre><p>The preceding snippet sets up a location-based notification, using a circular region with a radius of <code class="literal">1000</code> meters. The <code class="literal">notifyOnExit</code> and <code class="literal">notifyOnEntry</code> properties are used to specify whether the user should be notified when they enter the region, exit it, or when either event occurs.</p><p>Similar to the other <span>notification</span><a id="id325357450" class="indexterm"></a> triggers, you can choose whether the notification should be fired repeatedly, or just once.</p><p>This wraps up the exploration of all the ways for you to schedule notifications. Let's explore the last piece of the puzzle of notifications: handling incoming notifications and notification actions.</p><p>Â </p><p>Â </p><p>Â </p><p>Â </p><p>Â </p><p>Â </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch18lvl2sec99"></a>Handling notifications</h3></div></div></div><p>When a user receives a notification, it's typically displayed on the lock screen and in the Notification Center. The user can see the contents of the notification, and they have the option to tap the <span>notification</span><a id="id325357488" class="indexterm"></a> to launch the app that the notification belongs to.</p><p>In addition to tapping on a notification, users can swipe a notification to make extra buttons appear, which enable them to quickly perform an action that is related to the notification; for instance, accepting a calendar invite or quickly replying to a message. In this section, you will explore the following aspects of notification handling:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Handling notifications in your app</li><li style="list-style-type: disc">Managing pending and delivered notifications</li><li style="list-style-type: disc">Adding actions to notifications</li></ul></div><p>Properly implementing the preceding aspects can greatly enhance the value of the notifications that you send to your users.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch18lvl3sec48"></a>Handling notifications in your app</h4></div></div></div><p>Incoming notifications are most often received when the user is not using your app. This means that your app is not directly aware of the incoming notification, and doesn't get to handle it until the user taps the <span>notification</span><a id="id325357517" class="indexterm"></a> to open your application.</p><p>When your application launches due to a tapped notification, the <code class="literal">UNUserNotificationCenterDelegate</code>Â delegate protocol that belongs to the <code class="literal">UNUserNotificationCenter</code>Â object is called. This delegate is responsible for handling the incoming notification whether the app is currently in the foreground, background, or not active at all, perhaps because it's been killed by the system or force-closed by the user.</p><p>You are expected to assign aÂ <code class="literal">UNUserNotificationCenterDelegate</code>Â delegate before the app has finished launching. This means that you should set the delegate as soon as possible, so <code class="literal">application(_:didFinishLaunchingWithOptions:)</code> is a great candidate for setting the delegate.</p><p>Â </p><p>Â </p><p>When the user has tapped a notification, or selects one of the custom actions that is attached to the notification, the <code class="literal">userNotificationCenter(_:didReceive:withCompletionHandler:)</code> method is called on the notification center delegate. If the app is in the foreground and a notification is received, <code class="literal">userNotificationCenter(_:willPresent:withCompletionHandler:)</code> is called right before the notification is shown to the user. You can use this method to determine whether the notification should be shown to the user. Sometimes, it might not make sense to present a certain notification to the user if the app is already running. For instance, you wouldn't show a notification for an incoming message if the user is already looking at the new message.</p><p>Let's see what the notification center delegate methods look like when they are implemented. First, import the <code class="literal">UserNotifications</code> framework in <code class="literal">AppDelegate</code>Â and add the following code to implementation for <code class="literal">application(_:didFinishLaunchWithOptions:)</code> to set the app delegate as a delegate for the <code class="literal">UNUserNotificationCenter</code>:</p><pre class="programlisting">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {

  // existing code...

  UNUserNotificationCenter.current().delegate = self

  return true
}</pre><p>Next, add the following extension to <code class="literal">AppDelegate.swift</code> to make the app delegate conform to <code class="literal">UNUserNotificationCenterDelegate</code>:</p><pre class="programlisting">extension AppDelegate: UNUserNotificationCenterDelegate {
  func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
    let notification = response.notification
    let action = response.actionIdentifier

    let notificationTitle = notification.request.content.title
    let customAttributes = notification.request.content.userInfo

    completionHandler()
  }

  func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {
    completionHandler([.alert, .sound])
  }
}</pre><p>Both delegate methods have access to the original <span>notifications</span><a id="id325357596" class="indexterm"></a> and the notification contents. You can use this information to determine exactly which actions should be taken by your app to properly handle the notification. When a notification is tapped, <code class="literal">userNotificationCenter(_:didReceive:withCompletionHandler:)</code> is called. This method receives a <code class="literal">UNNotificationResponse</code>Â object, which provides information about the selected action, in addition to the notification information.</p><p>If your app receives a notification and it's in the foreground, <code class="literal">userNotificationCenter(_:willPresent:withCompletionHandler:)</code> allows you to determine what should happen with the notification. This method is passed a closure that you need to call to inform iOS about what should happen with the notification. If you want to handle the notification yourself, you can simply call the closure without any arguments. In the preceding snippet, the desired behavior is to display all notification alerts to the user and play the corresponding sounds.</p><p>Because you can access the original notification, you can determine whether the notification should be shown for each incoming notification individually, depending on the notification content, category, or custom attributes.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch18lvl3sec49"></a>Managing pending and delivered notifications</h4></div></div></div><p>When you learned about scheduling notifications, you saw that each <span>notification</span><a id="id325357763" class="indexterm"></a> is assigned a unique identifier. If a new notification is added with an identifier that has already been used, the new notification will overwrite the existing notification, limiting the amount of similar and duplicate notifications in the Notification Center.</p><p>This overwrite behavior applies to both delivered and pending notifications. This means that you can replace a notification that the user has already received by scheduling a second notification with the same identifier. This is especially useful if the new <span>notification</span><a id="id325357773" class="indexterm"></a> makes the old notification obsolete. For instance, consider a situation when you send push messages to update a user about the current score for a sports match. If you push each score update with the same identifier, the user will always see a single notification with the most recent score.</p><p>Â </p><p>Â </p><p>Â </p><p>Â </p><p>Â </p><p>Â </p><p>You can also remove delivered notifications by calling <code class="literal">removeDeliveredNotifications(withIdentifiers:)</code> on the notification center in your app. If your app allows the user to select the types of notification they want to receive, you could use this feature to remove all notifications of a certain type. That way, the user won't see the notifications anymore.</p><p>To update notifications that have been sent by your server, you push a new notification with the <code class="literal">apns-collapse-id</code> header set on the request that your server sends to APNS. If this header is present, the new notification will overwrite any existing notifications that have been pushed with the same <code class="literal">apns-collapse-id</code>.</p><p>Updating your notifications, instead of pushing new ones all the time, is a great way to avoid needless clutter in the Notification Center. More importantly, there won't be any duplicate, redundant, or outdated messages fighting for the user's attention.</p><p>Let's see how you can further improve the notification experience through custom actions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch18lvl3sec50"></a>Adding actions to notifications</h4></div></div></div><p>When you implemented the code to handle incoming notifications, you implemented a method called <code class="literal">userNotificationCenter(_:didReceive:withCompletionHandler:)</code>. This method contains information about the way the user chose to handle the notification. The could have tapped on the <span>notification</span><a id="id325336805" class="indexterm"></a> itself, which is the default action, or maybe they chose one of the custom actions that are associated with the notification by swiping it. Another way for users to make custom notifications appear is to 3D-Touch on it.</p><p>There are three main kinds of actions supported by notifications. The first is a background action. Background actions dismiss the <span>notification</span><a id="id325336816" class="indexterm"></a> and wake the app in the background, so it can take appropriate measures for the selected action. An example of this is accepting a calendar invite through an action. If a user accepts or declines an invite inside the notification, they don't have to be taken to the app, because the response can be handled in the background just fine.</p><p>The second type of action is a foreground action. A foreground action takes the user into the app that sent the notification. It's up to the app to handle the selected action in a way that makes sense.</p><p>Lastly, you can add text input actions to your notifications. These types of actions are basically background actions, except they take user input. A text input action is great if you're building a messaging app.</p><p>Â </p><p>All notification actions are associated with a notification category. These categories must be registered on the Notification Center at app launch. Again, the perfect place to set this up is <code class="literal">application(_:didFinishLaunchingWithOptions:)</code>. Add the following code to this method to configure a notification action that allows a user to mark one of their reminders as completed:</p><pre class="programlisting">let completeAction = UNNotificationAction(identifier: "complete-reminder", title: "Complete", options: [])

let reminderCategory = UNNotificationCategory(identifier: "reminder", actions: [completeAction], intentIdentifiers: [], options: [])

UNUserNotificationCenter.current().setNotificationCategories([reminderCategory])</pre><p>The preceding code creates a custom action that is attached to the <code class="literal">reminder</code> category. The default behavior for a notification is to handle actions in the background. If you want an action to take the user into your app, you need to add the <code class="literal">.foreground</code> option to the <code class="literal">options</code> parameter for the action. Lastly, the new category is added to the Notification Center.</p><p>Associating a category with a notification is done through the <code class="literal">categoryIdentifier</code> property of <code class="literal">UNNotificationContent</code>. Add the following line of code to the <code class="literal">createNotificationContentForReminder(_:)</code> method in <code class="literal">NotificationsHelper.swift</code> to add the reminder category to the notifications that are scheduled by the app:</p><pre class="programlisting">content.categoryIdentifier = "reminder"</pre><p>Â </p><p>Â </p><p>Â </p><p>Â </p><p>If you 3D-Touch the notifications that is sent by the app now, you're presented with a custom action:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/0694739d-79d6-4b4a-8614-aa9ec7cccea9.png" /></div><p>When the user taps on this action, <code class="literal">userNotificationCenter(_:didReceive:)</code> is called to notify your app about the fact that the user tapped on your custom action. Add the following implementation for this method to <code class="literal">AppDelegate.swift</code> to mark a reminder as completed when the user selects the <strong class="userinput"><code>Complete</code></strong> action:</p><pre class="programlisting">func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {

  let userInfo = response.notification.request.content.userInfo

  guard response.actionIdentifier == "complete-reminder",
    let identifier = userInfo["reminder-uuid"] as? String else {
      completionHandler()
      return
  }

  let fetchRequest: NSFetchRequest&lt;Reminder&gt; = Reminder.fetchRequest()
  fetchRequest.predicate = NSPredicate(format: "identifier == %@", identifier)

  let moc = PersistentHelper.persistentContainer.viewContext
  guard let results = try? moc.fetch(fetchRequest),
    let reminder = results.first else {
      completionHandler()
      return
  }

  moc.perform {
    reminder.isCompleted = true
    try! moc.save()

    completionHandler()
  }
}</pre><p>The preceding code extracts all relevant information from the notification response and uses it to find a reminder that matches the identifier that was added to the notification's <code class="literal">userInfo</code> dictionary. If a reminder was found, it's marked as completed and the managed object context is saved to persist the new reminder status.</p><p>Notification actions are a great way to add quick <span>interactions</span><a id="id325336990" class="indexterm"></a> to your notifications, and they are already a huge improvement over simply sending a plain notification. Another way to make great improvements to the way you send <span>notifications</span><a id="id325336999" class="indexterm"></a> to your users is to implement the new notification grouping that was introduced in iOS 12.</p></div></div></div>