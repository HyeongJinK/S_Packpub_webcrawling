<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch21lvl1sec142"></a>Adding your app contents to the Spotlight index</h2></div></div><hr /></div><p>If you have ever worked on a website, you must have <span>heard</span><a id="id325333110" class="indexterm"></a> something about <span class="strong"><strong>Search Engine Optimization</strong></span> (<span class="strong"><strong>SEO</strong></span>). More importantly, you will know that any website you create and publish is indexed by several search engines. All you have to do is make sure that you write semantic and structured <span>HTML</span><a id="id325333131" class="indexterm"></a> markup and any web spider will understand what your website is about and what parts of it are more important.</p><p>Search engines, such as Google, have indexed billions of web pages based on their contents and semantic markup.</p><p>Apps tend to be a <span>little</span><a id="id325333144" class="indexterm"></a> less neatly structured, and crawling them is a lot harder, if not impossible. There is no formal way to figure out what content is on screen and what this content means. Also, more importantly, a lot of content you'd want to index is only available to users who have logged in or created content of their own.</p><p>This is why Apple decided that the developers themselves probably know their app's contents best and should be in charge about how, when, and why a particular content is indexed. Even though this does put a little bit of manual burden on the developers, it gives them a considerable advantage over the automatic <span>indexing</span><a id="id325333155" class="indexterm"></a> that's done on the web. Since developers are in control, they can decide precisely which content matters most to specific users. As you'll soon see, you can index content based on the screens a user visits, which <span>means</span><a id="id325333911" class="indexterm"></a> that you will index those pages that your user may want to visit again.</p><p>Even more important than being in control is the ability to index private contents safely. The web is limited to indexing public content. If you use online email software to check your inbox or if you have an online project-management tool, you must rely on the internal search functions inside the web page for these tools. You won't find your emails or projects through a regular search query. With Spotlight indexing, your users can do just that: search through the content they own on their device. Indexing private content is secure because the data is not made available to other apps and you can't accidentally make one user's private data visible to other users due to the public indexing threshold mentioned earlier.</p><p>So how exactly do developers take control? That's the question that's answered next. You will learn about the following methods that Apple came up with to index app contents:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">NSUserActivity</code></li><li style="list-style-type: disc"><code class="literal">CSSearchableItem</code></li><li style="list-style-type: disc">Universal Links</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch21lvl2sec110"></a>Indexing your app through user activity</h3></div></div></div><p>As part of a <span>feature</span><a id="id325333942" class="indexterm"></a> set called <strong class="userinput"><code>Continuity</code></strong>, Apple launched <span>Handoff</span><a id="id325369900" class="indexterm"></a> in iOS 8. <strong class="userinput"><code>Handoff</code></strong> allows users to start an activity on one device and then continue it on another. In iOS 9, Apple introduced the ability to index these user activities in Spotlight.</p><p>There are several advantages to this because apps that support Handoff hardly need to do anything to support Spotlight indexing and vice versa. So, even though this chapter is all about search and Spotlight, you will also learn something about enabling Handoff for your app.</p><p>The philosophy behind user activities is that <span>whenever</span><a id="id325333961" class="indexterm"></a> your user interacts with your app, you create an instance of <code class="literal">NSUserActivity</code>. For Spotlight, these activities revolve solely around viewing content. Any time your user looks at a piece of content in your app is an excellent time to create a user activity and have Spotlight index it. After the user activity is added to the index, the user will be able to find it through Spotlight; when they tap on it, your app can take the user straight to the relevant section of the app, allowing the user to resume their activity.</p><p>In the previous chapters, you worked on an app called <strong class="userinput"><code>MustC</code></strong>. The <strong class="userinput"><code>MustC</code></strong> app collects data about people and their favorite movies. The app also keeps track of a rating for each of the movies. This content is great to index in Spotlight, so let's add some indexing to it.</p><p>A few additions were made since the last time you worked on this app. The app now contains a tab bar. There is a tab for the list of family members, and there is one that lists all of the movies that are added to the app. Selecting a movie will display a list of family members that have added this movie to their favorites.</p><p>An app such as <strong class="userinput"><code>MustC</code></strong> is a great candidate for indexing. You can <span>add</span><a id="id325333989" class="indexterm"></a> the separate family members, the tabs from the navigation bar, and the movies to Spotlight to make them searchable from anywhere within iOS. You will start off with the most straightforward content to track. You will add the family members and movie tabs to Spotlight when a user visits them.</p><p>To do this, you will use user activities, so you should create an activity <span>whenever</span><a id="id325334000" class="indexterm"></a> a user opens one of the two tabs. There are two places where you could implement the user activities:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">viewDidAppear()</code></li><li style="list-style-type: disc"><code class="literal">viewDidLoad()</code></li></ul></div><p>If you create the user activity in <code class="literal">viewDidAppear</code>, the user activity is pushed every time the user switches tabs or navigates back to the root view controller from another view controller. Even though it doesn't cost much to index a user activity, it seems like it's overkill to index a tab every single time a user sees it.</p><p>Even though this train of thought isn't wrong, the best way to go about indexing tabs in Spotlight is actually to create the activity in the <code class="literal">viewDidAppear()</code> method. If you put this logic in <code class="literal">viewDidLoad()</code>, it will only be executed once even though the idea of user activities is that they describe each action a user performs. In this case, inserting the same activity over and over again is the desired behavior because it accurately reflects what the user is doing inside the app.</p><p>When your app implements user activities, you should always specify them by adding an <code class="literal">NSUserActivityTypes</code> array to your app's <code class="literal">Info.plist</code> that contains the user activities your app will handle. Add this key to <code class="literal">Info.plist</code> for <strong class="userinput"><code>MustC</code></strong> and add a single item name, com.familymovies.openTab, to the activity types array.</p><p>Let's take a look at some code that indexes the family members tab. You should add it to <code class="literal">FamilyMembersViewController</code>:</p><pre class="programlisting">override func viewDidAppear(_ animated: Bool) {
  super.viewDidAppear(animated)
  let userActivity = NSUserActivity(activityType: "com.familymovies.openTab")
  userActivity.title = "Family Members"
  userActivity.isEligibleForSearch = true
  userActivity.isEligibleForPublicIndexing = true
  self.userActivity = userActivity
  self.userActivity?.becomeCurrent()
}</pre><p>The preceding code shows how to create a straightforward user activity. The activity you just created only has a title because there isn't much else to associate with it. The most important thing to note is the <code class="literal">isEligibleForSearch</code> property. This property tells the system that the user activity that is about to be set as the current activity should be indexed for searching. Other similar properties are <code class="literal">isEligibleForHandoff</code> and <code class="literal">isEligibleForPublicIndexing</code>. You used the <code class="literal">isEligibleForPrediction</code> property in <a class="link" href="#" linkend="ch16">Chapter 16</a>, <span class="emphasis"><em>Streamlining Experiences with Siri</em></span>.</p><p>It's a great idea for the activity you just created to be eligible for <span>public</span><a id="id325580695" class="indexterm"></a> indexing, so that property is set to <code class="literal">true</code>. Doing this will make the activity show up in the search results of a lot more people, given that enough people interact with it. Marking an activity as eligible for handoff allows a user to continue an activity they started on one device on another device. Since this app only works on iOS and you don't need to take multiple users with multiple devices into account, you don't have to set this property to <code class="literal">true</code>.</p><p>Finally, the user activity you just created is set as the <span>current</span><a id="id325580713" class="indexterm"></a> activity. This makes sure that iOS registers the activity and adds it to the Spotlight index. It won't be made available publicly right away due to the threshold of people that interact with this activity that must be reached before Apple will push it to all users. Even though it won't be indexed publicly, it will appear in search results locally for the current user.</p><p>If you build and run your application, the family members tab should be the first tab to appear. This means that a user activity for that view is created and indexed immediately. After opening the app, go ahead and open Spotlight by swiping down on the home screen and perform a search for the word <strong class="userinput"><code>family</code></strong>.</p><p>You'll notice that the activity you just added is listed under the <strong class="userinput"><code>MustC</code></strong> header in the Spotlight search results, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/2f9403cf-00b0-4f5f-8ea7-74eeb8eedebf.png" /></div><p>Pretty neat, right? You were able to add a simple <span>entry</span><a id="id325580744" class="indexterm"></a> in Spotlight's search <span>index</span><a id="id325580753" class="indexterm"></a> with very minimal effort. You should be able to add a similar implementation to the <strong class="userinput"><code>MustC</code></strong> app to have it index the <code class="literal">Movies</code> page. Go ahead and add a modified version of the snippet you added to <code class="literal">FamilyMembersViewController</code> to <code class="literal">MoviesListViewController</code>.</p><p>Now that both tabs show up in Spotlight, how do you make sure that the correct tab is opened when the user selects a result from Spotlight? The answer lies in one of the <code class="literal">AppDelegate</code> methods. When your app is brought to the foreground because a user selected your app as a Spotlight search result, the <code class="literal">application(_:continueUserActivity:restorationHandler:)</code> method is called. This is the same method that gets called when a user executes one of their Siri Shortcuts, so if you need a little refresher on how this method works, make sure to go back to <a class="link" href="#" linkend="ch16">Chapter 16</a>, <span class="emphasis"><em>Streamlining Experiences with Siri</em></span>.</p><p>Currently, there are only two Spotlight entries that the user can select. They either want to see the family members tab or the movies tab. The implementation of <code class="literal">application(_:continueUserActivity:restorationHandler:)</code> should inspect the user activity that it received to determine which tab should be displayed. Once this is established, a reference to the app's <code class="literal">UITabBarController</code> should be obtained and the correct tab should become active.</p><p>Since each tab contains a navigation controller, you should always make sure to pop the relevant navigation controller to its root view controller. This is needed because the user might have been looking at a detail view controller, and the app would show this detail view controller instead of the root view controller if you don't <span>ensure</span><a id="id325580803" class="indexterm"></a> that the navigation controller pops to its root view controller. Add the <span>following</span><a id="id325580811" class="indexterm"></a> code to <code class="literal">AppDelegate</code> to add this functionality:</p><pre class="programlisting">func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool {
  // 1
  guard let tabBar = window?.rootViewController as? UITabBarController
    else { return false }

  // 2
  let tabIndex: Int?
  if userActivity.title == "Family Members" {
    tabIndex = 0
  } else if userActivity.title == "Movies" {
    tabIndex = 1
  } else {
    tabIndex = nil
  }

  guard let index = tabIndex
    else { return false }

  // 3
  guard let navVC = tabBar.viewControllers?[index] as? UINavigationController
    else { return false }

  // 4
  navVC.popToRootViewController(animated: false)
  tabBar.selectedIndex = index

  return true
}</pre><p>The preceding code first obtains a reference to the tab bar controller. After doing this, the second step is to determine the correct tab index for the selected user activity. Then, the navigation view controller associated with the tab bar is grabbed. The fourth and final step is to pop the navigation controller to its root view controller and to make the correct tab bar index the currently-selected tab bar item.</p><p>At this point, two of the screens in <strong class="userinput"><code>MustC</code></strong> are indexed in Spotlight. While this is great, there are a couple more screens that can be implemented. Doing this will make the implementation for <code class="literal">application(_:continueUserActivity:restorationHandler:)</code> more complicated than it is now.</p><p>Manually creating and resuming user activities for each screen in an app is tedious and involves quite a lot of boilerplate code. You can solve this problem by utilizing an activity factory. A typical pattern in apps is to use a specific helper object called a <strong class="userinput"><code>Factory</code></strong>. The sole purpose of a factory is to act as an object that is responsible for creating objects of a particular type. This dramatically reduces boilerplate code and increases maintainability. Create a new file called <code class="literal">IndexingFactory.swift</code> in the <code class="literal">Helpers</code> folder and add the following implementation:</p><pre class="programlisting">import Foundation

struct IndexingFactory {
  enum ActivityType: String {
    case openTab = "com.familymovies.openTab"
    case familyMemberDetailView = "com.familymovies.familyMemberDetailView"
    case movieDetailView = "com.familymovies.movieDetailView"
  }

  static func activity(withType type: ActivityType, name: String, makePublic: Bool) -&gt; NSUserActivity {
    let userActivity = NSUserActivity(activityType: type.rawValue)
    userActivity.title = name
    userActivity.isEligibleForSearch = true
    userActivity.isEligibleForPublicIndexing = makePublic

    return userActivity
  }
}</pre><p>Note that this object contains an enum with three different activity types. Don't forget to add the two new activity types to the <code class="literal">NSUserActivityTypes</code> list in the app's <code class="literal">Info.plist</code>. <code class="literal">IndexingFactory</code> has a single static method in it. This method takes a couple of configuration arguments and uses these to create and return a new user activity instance. Let's see this factory in action. You can add the following code to the <code class="literal">MoviesViewController</code> class:</p><pre class="programlisting">override func viewDidAppear(_ animated: Bool) {
  super.viewDidAppear(animated)

  guard let familyMemberName = familyMember?.name
    else { return }

  self.userActivity = IndexingFactory.activity(withType: .familyMemberDetailView, name: familyMemberName, makePublic: false)
  self.userActivity?.becomeCurrent()
}</pre><p>The preceding snippet is a lot smaller than creating a user activity from scratch in every <code class="literal">viewDidAppear</code>. Also, if you decide to make changes to the way user activities are created and configured, it will be easier to refactor your code because you will only have to change a single method. Add a comparable implementation of the preceding method to the <code class="literal">MovieDetailViewController</code> class so movie pages will also be indexed by Spotlight when the user visits them.</p><p>This wraps up simple indexing with <code class="literal">NSUserActivity</code>. Next up, you will learn how to index content with the <code class="literal">CSSearchableItem</code> class and how you can use it to index content the user hasn't seen yet. You'll also see how you can associate more sophisticated data with your searchable items and how Spotlight handles updating and re-indexing contents.</p><p>Since <code class="literal">AppDelegate</code> can't handle opening user activity types that should take the user straight to a family member or movie, it's a good exercise for you to try implementing this logic yourself. For a correct implementation, you'll need to add a new <code class="literal">find</code> method to the <strong class="userinput"><code>Movie</code></strong> and <strong class="userinput"><code>FamilyMember</code></strong> classes, and you'll have to instantiate view controllers straight from a storyboard. If you get stuck implementing this, don't hesitate to look at the finished code for this chapter in the code bundle.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch21lvl2sec111"></a>Indexing with CSSearchableItem</h3></div></div></div><p>Currently, Spotlight <span>indexing</span><a id="id325580914" class="indexterm"></a> works and users can find any content they have seen before. It's even possible to select results from the Spotlight index and have the app open on the correct page. If you've taken on the challenge of implementing the handling of detail pages, your app should be able to handle the continuation of any activity that was indexed. Wouldn't it be cool if we could be a bit more proactive about indexing though? Ideally, the app would index any new <code class="literal">Family Members</code> or movies as soon as the user adds them.</p><p>This is what <code class="literal">CSSearchableItem</code> is good at. The <code class="literal">CSSearchableItem</code> class enables you to index content that the user might not have seen before. Indexing <code class="literal">CSSearchableItem</code> instances is pretty straightforward. The steps involved are similar to how you could index user activities. To index a searchable item, you should create an instance of <code class="literal">CSSearchableItem</code> and provide it with attributes that describe the indexed item. These attributes are encapsulated in an instance of <code class="literal">CSSearchableItemAttributeSet</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch21lvl3sec51"></a>Containing information in CSSearchableItemAttributeSet</h4></div></div></div><p>When you create an attributes set, it's <span>important</span><a id="id325580951" class="indexterm"></a> that you populate it correctly since it describes almost all of the important information about your item for Spotlight. You can set a title, content description, a thumbnail image, keywords, even ratings or phone numbers, GPS information, and much, much more. For a full overview of what's possible, refer to the <code class="literal">CSSearchableItemAttributeSet</code> documentation. Every time you are about to create a new item that can be indexed, you should take a look at the documentation to make sure you don't miss any attributes.</p><p>The better use you make of the available attributes, the more effectively your content can be indexed and the higher your app will rank. Therefore, it's worth putting slightly more time and effort into your search attributes because getting it wrong can be a costly mistake, especially considering the available documentation. At a minimum, you should always try to set <code class="literal">title</code>, <code class="literal">contentDescription</code>, <code class="literal">thumbnailData</code>, <code class="literal">rating</code>, and <code class="literal">keywords</code>. This isn't always relevant or even possible for the items you're indexing, but whenever possible make sure that you set these attributes.</p><p>You may have noticed that the <code class="literal">NSUserActivity</code> instances you indexed in the app didn't receive any special attributes. You just set a name and some other basic information, but you didn't have to add a description or a rating to any of the indexed objects. If you index user activities in your applications, it's worth noting that user activities can and should have attributes associated with them. All you need to do is set the <code class="literal">contentAttributeSet</code> property on the user activity. After you implement indexing through <code class="literal">CSSearchableItem</code>, you should shortly revisit user-activity indexing to make the indexed item richer and also to make sure that <code class="literal">CoreSpotlight</code> understands that the user activities and searchable items point to the same underlying index in Spotlight.</p><p>When you index items through <span>multiple</span><a id="id325580999" class="indexterm"></a> methods, it's inevitable that you run into data duplication. The <strong class="userinput"><code>MustC</code></strong> app indexes every visited screen. So, if a user visits the details page of a movie, a user activity for that movie should be created. However, you also want to index movies as they are created by the user. To avoid duplicate results in Spotlight search, <code class="literal">relatedUniqueIdentifier</code> should be added to the attributes set. Setting this attribute on a user activity makes sure that Spotlight doesn't add duplicate entries for items with the same identifier.</p><p>Let's expand <code class="literal">IndexingFactory</code> with two methods that can generate attribute sets for searchable items. Putting this functionality in <code class="literal">IndexingFactory</code> as a separate method is a good idea because, if it is set up correctly, these methods can be used to generate attributes for both user activities and searchable items. This avoids code duplication and makes it a lot easier to add or remove properties in the future. Add the following methods to the <code class="literal">IndexingFactory</code> struct. Don't forget to import <code class="literal">CoreSpotlight</code> at the top of the file:</p><pre class="programlisting">static func searchableAttributes(forMovie movie: Movie) -&gt; CSSearchableItemAttributeSet {
  do {
    try movie.managedObjectContext?.obtainPermanentIDs(for: [movie])
  } catch {
    print("could not obtain permanent movie id")
  }

  let attributes = CSSearchableItemAttributeSet(itemContentType: ActivityType.movieDetailView.rawValue)
  attributes.title = movie.title
  attributes.contentDescription = "A movie that is favorited by (movie.familyMembers?.count ?? 0) family members"
  attributes.rating = NSNumber(value: movie.popularity)
  attributes.identifier = "(movie.objectID.uriRepresentation().absoluteString)"
  attributes.relatedUniqueIdentifier = "(movie.objectID.uriRepresentation().absoluteString)"

  return attributes
}

static func searchableAttributes(forFamilyMember familyMember: FamilyMember) -&gt; CSSearchableItemAttributeSet {
  do {
    try familyMember.managedObjectContext?.obtainPermanentIDs(for: [familyMember])
  } catch {
    print("could not obtain permanent family member id")
  }

  let attributes = CSSearchableItemAttributeSet(itemContentType: ActivityType.familyMemberDetailView.rawValue)
  attributes.title = familyMember.name
  attributes.identifier = "(familyMember.objectID.uriRepresentation().absoluteString)"
  attributes.contentDescription = "Family Member with (familyMember.favoriteMovies?.count ?? 0) listed movies"
  attributes.relatedUniqueIdentifier = "(familyMember.objectID.uriRepresentation().absoluteString)"

  return attributes
}</pre><p>For both the <code class="literal">Movie</code> and <code class="literal">FamilyMember</code> objects, a set of attributes is created. This set meets Apple's recommendations as closely as possible. The objects don't have any thumbnail images or keywords that can be added to the attributes set other than the movie title or the name of a family member. Adding these to the keywords is kind of pointless because the title in itself is essentially a keyword that the item will match on.</p><p>To create an attribute set for a movie or family member, you only have to call the method that matches the object you want to index and you're good to go. Beautiful, convenient, and simple.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch21lvl3sec52"></a>Adding CSSearchableItem instances to the search index</h4></div></div></div><p>In the <span class="strong"><strong>MustC</strong></span> application, the goal is to add <span>family</span><a id="id325581056" class="indexterm"></a> members and movies to the search index as soon as the user adds them. A factory method that creates the <code class="literal">CSSearchableItemAttributeSet</code> instance that describes the item that should be indexed is already provided. However, you can't directly add these to the index. To add information to the search index manually, you need instances of <code class="literal">CSSearchableItem</code>. Every searchable item requires a unique identifier and a domain identifier.</p><p>The unique identifier is used to identify an indexed item. It's essential that you set this value to something that is unique because otherwise, Spotlight will overwrite the entry with something else that has the same identifier or you'll get duplicate entries if you combine user activities and search items like we're doing for <strong class="userinput"><code>MustC</code></strong>.</p><p>The domain identifier functions as a namespace. Within any given namespace, all entries must be unique and are identified through their unique identifier. These identifiers only have to be unique within their namespace. Think of this as streets and addresses. In a particular area, every street name is unique (domain, namespace). On each street the house number is unique (unique identifier), but the same number can occur on different streets. The domain identifier for your Spotlight entry is not only used to identify entries uniquely, it's also used to perform specific batch actions on the index, such as deleting all indexed items from a particular domain.</p><p>The domain identifier, unique identifier, and the attributes together make up a searchable item. The following code adds factory methods to <code class="literal">IndexingFactory</code> that will make it simple for the app to add items to the search index:</p><pre class="programlisting">enum DomainIdentifier: String {
  case familyMember = "FamilyMember"
  case movie = "Movie"
}

static func searchableItem(forMovie movie: Movie) -&gt; CSSearchableItem {
  let attributes = searchableAttributes(forMovie: movie)

  return searachbleItem(withIdentifier: "(movie.objectID.uriRepresentation().absoluteString)", domain: .movie, attributes: attributes)
}

static func searchableItem(forFamilyMember familyMember: FamilyMember) -&gt; CSSearchableItem {
  let attributes = searchableAttributes(forFamilyMember: familyMember)

  return searachbleItem(withIdentifier: "(familyMember.objectID)", domain: .familyMember, attributes: attributes)
}

private static func searachbleItem(withIdentifier identifier: String, domain: DomainIdentifier, attributes: CSSearchableItemAttributeSet) -&gt; CSSearchableItem {
  let item = CSSearchableItem(uniqueIdentifier: identifier, domainIdentifier: domain.rawValue, attributeSet: attributes)

  return item
}</pre><p>The preceding code defines an enum that contains domain identifiers for items that should be indexed. Note that <code class="literal">searchableItem(withIdentifier:domain:attributes:)</code> is marked as private. This is done to make sure anybody using the factory helper has to use <code class="literal">searchableItem(forFamilyMember:)</code> and <code class="literal">searchableItem(forMovie:)</code> instead. These methods are simpler to use because they only take a family member or a movie and if you use only these methods, you can rest assured that you only insert consistently configured items into the Spotlight index.</p><p>Now that everything is set up for indexing new data, let's begin with indexing family members as soon as the user creates them. Add the following code as the implementation for the <code class="literal">.insert</code> case in <code class="literal">controller(_:didChange:at:for:newIndexPath:)</code> in <code class="literal">FamilyMembersViewController</code>. Make sure that you import <code class="literal">CoreSpotlight</code> at the top of your file:</p><pre class="programlisting">guard let insertIndex = newIndexPath,
  let familyMember = fetchedResultsController?.object(at: insertIndex)
  else { return }

let item = IndexingFactory.searchableItem(forFamilyMember: familyMember)
CSSearchableIndex.default().indexSearchableItems([item], completionHandler: nil)

tableView.insertRows(at: [insertIndex], with: .automatic)</pre><p>Due to the factory methods you set up before, new items can be added to the search index with just a few lines of code. To insert an item into the search index, an instance of <code class="literal">CSSearchableIndex</code> is created, and Spotlight is told to index this item. If needed, a completion-handler can be passed to the index method. This handler is called with an optional error. If the indexing has failed, the error should tell you why Spotlight couldn't index the item, and you can retry indexing the item or take a different action. In the <strong class="userinput"><code>MustC</code></strong> app, it is assumed that the indexing succeeds and no error-handling is implemented.</p><p>Update the <code class="literal">mangedObjectContextDidChange(notification:)</code> method in <code class="literal">MoviesViewController</code> as follows to <span>index</span><a id="id325581138" class="indexterm"></a> new movies:</p><pre class="programlisting">@objc func managedObjectContextDidChange(notification: NSNotification) {
  guard let userInfo = notification.userInfo
    else { return }

  if let updatedObjects = userInfo[NSUpdatedObjectsKey] as? Set&lt;FamilyMember&gt;,
    let familyMember = self.familyMember,
    updatedObjects.contains(familyMember) {

    let item = IndexingFactory.searchableItem(forFamilyMember: familyMember)
    CSSearchableIndex.default().indexSearchableItems([item], completionHandler: nil)

    tableView.reloadData()
  }

  if let updatedObjects = userInfo[NSUpdatedObjectsKey] as? Set&lt;Movie&gt; {
    for object in updatedObjects {
      if let familyMember = self.familyMember,
        let familyMembers = object.familyMembers,
        familyMembers.contains(familyMember) {

        let item = IndexingFactory.searchableItem(forMovie: object)
        CSSearchableIndex.default().indexSearchableItems([item], completionHandler: nil)

        tableView.reloadData()
        break
      }
    }
  }
}</pre><p>Right after the movie is added to the current family member, it is added to the Spotlight index. You might argue that the item is added too early because the movie's rating has not been fetched at that point. This is <span>OK</span> because when the context is saved the second time with the ratings attached, the item is added to the index again automatically due to the save notification that Core Data sends.</p><p>If you run the app now, you should be able to go into Spotlight <span>right</span><a id="id325581160" class="indexterm"></a> after you add a family member or movie, and you should immediately be able to find the freshly added content in Spotlight. If you search for a movie you just added, you'll notice that you can see how many family members have added a certain movie to their favorites list and the rating a movie has. More importantly, there should be only a single entry for each movie because a unique identifier is used to avoid duplicate entries.</p><p>Now that you have implemented <code class="literal">CSSearchableItem</code> and <code class="literal">NSUserActivity</code> indexing, you need to make sure that both of these objects are correctly configured so you can safely combine both indexing methods.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch21lvl3sec53"></a>Safely combining indexing methods</h4></div></div></div><p>Since no unique <span>information</span><a id="id325356860" class="indexterm"></a> is associated with the user activities yet, Spotlight can't figure out that a family member that's indexed through a user activity is the same family member that was already inserted as a searchable item. To ensure that Spotlight understands this, you should add two more factory methods that create an activity item for either a family member or a movie with the correct information associated with them. Add the following methods to <code class="literal">IndexingFactory</code>:</p><pre class="programlisting">static func activity(forMovie movie: Movie) -&gt; NSUserActivity {
  let activityItem = activity(withType: .movieDetailView, name: movie.title!, makePublic: false)
  let attributes = searchableAttributes(forMovie: movie)
  attributes.domainIdentifier = DomainIdentifier.movie.rawValue
  activityItem.contentAttributeSet = attributes

  return activityItem
}

static func activity(forFamilyMember familyMember: FamilyMember) -&gt; NSUserActivity {
  let activityItem = activity(withType: .movieDetailView, name: familyMember.name!, makePublic: false)
  let attributes = searchableAttributes(forFamilyMember: familyMember)
  attributes.domainIdentifier = DomainIdentifier.familyMember.rawValue
  activityItem.contentAttributeSet = attributes

  return activityItem
}</pre><p>The most important lines to take note of are the ones where a <code class="literal">domainIdentifier</code> is set on the attributes constant. Since iOS 10, developers have been able to associate a <code class="literal">domainIdentifier</code> with user activities through <code class="literal">contentAttributeSet</code>. By adding a <code class="literal">domainIdentifier</code> to the indexed item, searchable items and user activities are unified even more. Update the <code class="literal">viewDidAppear</code> implementation for <code class="literal">MovieDetailViewController</code> as follows:</p><pre class="programlisting">override func viewDidAppear(_ animated: Bool) {  
    super.viewDidAppear(animated)  

    guard let movie = self.movie  
        else { return }  

    self.userActivity = IndexingFactory.activity(forMovie: movie)  
    self.userActivity?.becomeCurrent()  
}</pre><p>We also need to update the <code class="literal">viewDidAppear</code> method in <code class="literal">MoviesViewController</code>. You should be able to do this on your own; the code will look similar to the <span>preceding</span><a id="id325356910" class="indexterm"></a> snippet, except you're indexing a family member instead of a movie.</p><p>Now that all of your app contents are indexed in Spotlight, it's time to discuss some of the methods Spotlight uses to rate your content and the best practices you should keep in mind when you add your app's contents to Spotlight.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch21lvl3sec54"></a>Handling searchable item selection</h4></div></div></div><p>If a user taps on a search result for one of the items you <span>indexed</span><a id="id325356997" class="indexterm"></a> manually, the <code class="literal">application(_:continue:restorationHandler:)</code> method is called on <code class="literal">AppDelegate</code>. This is the same method that's used for user activities, but the internal handling is not quite the same.</p><p>In the original code to continue user activities, the user activity's title property was used to determine the appropriate action. Since searchable items don't have this property, a different approach will have to be implemented. To decide whether the user activity that is passed to <code class="literal">application(_:continue:restorationHandler:)</code> is a searchable item or a user activity, you can read the activity type. If the user activity was originally a searchable item, the activity type should be equal to <code class="literal">CSSearchableItemActivityIdentifier</code>. If you receive a user activity with this activity type, you should take action accordingly.</p><p>Update your code in <code class="literal">AppDelegate</code> as follows and make sure to import <code class="literal">CoreSpotlight</code>:</p><pre class="programlisting">func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool {

  if let identifier = userActivity.userInfo?[CSSearchableItemActivityIdentifier] as? String, userActivity.activityType == CSSearchableItemActionType {

    return handleCoreSpotlightActivity(withIdentifier: identifier)
  }

  // existing implementation
}

func handleCoreSpotlightActivity(withIdentifier identifier: String) -&gt; Bool {
  guard let url = URL(string: identifier),
    let objectID = persistentContainer.persistentStoreCoordinator.managedObjectID(forURIRepresentation: url),
    let object = try? persistentContainer.viewContext.existingObject(with: objectID)
    else { return false }

  if let movie = object as? Movie {
    return handleOpenMovieDetail(withName: movie.name!)
  }

  if let familyMember = object as? FamilyMember {
    return handleOpenFamilyMemberDetail(withName: familyMember.name!)
  }
  return false
}</pre><p>The updated version of <code class="literal">application(_:continue:restorationHandler:)</code> checks whether it received a searchable item. If it did, a special method is called. This method uses the persistent store to convert the string identifier to a managed object ID which is then used to ask the managed object context for the corresponding object. If all of this succeeds, we attempt to cast the fetched object to either a movie or a family member, and if this succeeds, one of the existing handlers is called. If none of the casts succeed, it was not possible to continue the activity, so the method returns false.</p><p>Note that this implementation assumes that you did the exercise that was proposed <span>earlier in the chapter</span> so <code class="literal">handleOpenFamilyMemberDetail(withName:)</code> and <code class="literal">handleOpenMovieDetail(withName:)</code> do not exist in the project. Refer to this chapter's code bundle to see a suggested implementation for both of these methods.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch21lvl2sec112"></a>Understanding Spotlight best practices and ratings</h3></div></div></div><p>If you implement <span>Spotlight</span><a id="id325357095" class="indexterm"></a> indexing in your app, it's beneficial for both you and your users if you adhere to best practices. Sticking with the best practices will positively affect your ratings and can <span>ultimately</span><a id="id325357104" class="indexterm"></a> drive more users to your app.</p><p>There are two best practices that you should always follow if possible. Doing so will give your app great advantages over other apps that might not stick to best practices. The two best practices you should always try to follow are:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Adding metadata to your web links</li><li style="list-style-type: disc">Registering as an indexing delegate</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch21lvl3sec55"></a>Adding metadata to your web links</h4></div></div></div><p>In the next section about Universal Links, you will learn what Universal Links are and how you should implement them in your application. Enabling Universal Links benefits your <span>Spotlight</span><a id="id325357128" class="indexterm"></a> search ranking and visibility because Spotlight can associate web resources that Apple's bots can crawl with the items you add to the Spotlight index. To associate Universal Links and your locally indexed items with each other, you should set the <code class="literal">contentUrl</code> that matches the web resource for a local item on your search attributes objects.</p><p>Doing so allows Apple to display search results for your app as public, and it can even show your Universal Links in Safari's search results. This means that it will be even easier for your users to discover and use your app. More importantly, if you associate a <code class="literal">contentUrl</code> with an indexed item, your app is also shown to people who don't have your app installed. That fact alone should persuade you to make sure that your app has online resources that mirror the public content in your app.</p><p>Once you've decided to add content URLs to your content, it's essential that you add proper, structured metadata to your web pages. If your web page has well-formatted metadata available, Spotlight will index your app's contents even if you don't manually add it. This is because Apple continuously crawls the marketing and support URLs you advertise within the App Store.</p><p>For Apple's bot to be able to discover the URLs your app can handle, it checks whether there is a Smart App Banner implemented on your web page. The Smart App Banner is visible to people who visit your website. If they already have your app installed, the banner will prompt the user to view this content in your app. If you've added a URL to the banner that your app can handle, Apple's bot can discover this link and associates it with your app.</p><p>You should always make sure that you add useful <span>metadata</span><a id="id325357152" class="indexterm"></a> to your web content. When you manually index content, you can set properties on the indexed item's attributes set to represent your data. On the web, you can't create an attribute set, so you need to embed the metadata in your page's HTML markup. If your web page contains Open Graph metadata, Apple's bots will understand how to read that metadata. Even though Open Graph metadata is a great start, Apple recommends that you implement richer and more fine-grained data for your websites.</p><p>To do this, it's recommended that you implement metadata as specified in the schema.org standards. These standards provide definitions for a wide range of different entities. For instance, you can express a product rating, pricing, or a business address through <a class="ulink" href="http://schema.org/" target="_blank">schema.org</a> definitions of these entities.</p><p>If you've implemented metadata for your app, or if you want to make sure that Spotlight can index your contents, you can use Apple's verification tools for searching. Go to <a class="ulink" href="https://search.developer.apple.com" target="_blank">https://search.developer.apple.com</a> to paste in your website's URL and verify that everything can be indexed as you expected.</p><p>Having a complete set of metadata positively impacts your rating. An obvious reason is that it's better because more information means more matches for a search query. However, a different reason is that, if a user sees a search result that provides a lot of information at a glance, it's easier for them to decide whether a specific result is relevant to them.</p><p>This quick assessment of relevancy up front makes sure that whenever a user selects a result for your app, they know for sure that they want to interact with that item. Apple measures this form of engagement to ensure that results that are tapped often and are used longer are pushed to the top.</p><p>A topic that is directly related to this is the concept of keyword stuffing. When optimizing for a search, it can be tempting to stuff a lot of keywords into your contents. Doing this will not positively impact your ratings in Spotlight. The reasoning behind this is that keyword-stuffed results will often look like spam. The preview won't be a coherent preview of contents, but it will look as if somebody tried to put as many relevant words together as they could. A result that looks poor is less likely to be tapped by a user and will be pushed down in the rankings eventually.</p><p>If users do end up tapping a keyword-stuffed item, it's unlikely that they will find what they were looking for. Often, this means that the user exits your app after just a couple of seconds, and this negatively impacts your result rating.</p><p>In other words, add as much metadata as you reasonably can, but ensure that any data you add is relevant, authentic, and exists in your app. A good preview in Spotlight and a matching experience in your app is the best way to for apps to rank highly in Spotlight.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch21lvl3sec56"></a>Registering as an indexing delegate</h4></div></div></div><p>An item you add to the <span>Spotlight</span><a id="id325357532" class="indexterm"></a> index today might change over time. Some items you add to Spotlight could even have an expiration date if you've set the <code class="literal">endDate</code> property on the item attributes. Therefore, it's important that you register your app as an indexing delegate.</p><p>The <span>indexing</span><a id="id325357547" class="indexterm"></a> delegate is used for a single purpose: re-indexing content. If you've added items that expire over time, Spotlight will ask you to index them again to make sure that the expiration date is still correct. The indexing delegate is also called if something goes wrong with the index itself; for example, if all pieces of data are lost or if the search index becomes corrupted.</p><p>The indexing delegate has two required methods: <code class="literal">searchableIndex(_:reindexAllSearchableItemsWithAcknowledgementHandler:)</code> and <code class="literal">searchableIndex(_:reindexSearchableItemsWithIdentifiers:acknowledgementHandler:)</code>.</p><p>The first method is called if the index has been lost and everything should be indexed. It's up to you to figure out how to index your entire app. In the <strong class="userinput"><code>MustC</code></strong> app, this would probably mean fetching all family members and indexing them. You could use the <code class="literal">movies</code> relationship on the family members to loop over all of the movies that are stored in the database and index them accordingly. Alternatively, you could query both entities separately and index them separately.</p><p>The second indexing delegate method receives an array of identifiers that need to be indexed and is used to re-index a specific set of items. There are several reasons for spotlight to call this method, for instance, if an item is about to expire.</p><p>After you index the required items, you should call the <code class="literal">acknowledgementHandler</code> that the <code class="literal">delegate</code> method has received. This will make sure that Spotlight understands that you have successfully executed the tasks you needed to perform. To set the indexing delegate, you set the <code class="literal">indexDelegate</code> of the search index. For most apps, the searchable index is accessed through <code class="literal">CSSearchableIndex.default()</code>.</p><p>Now that you know everything about adequately implementing Spotlight indexing, let's see how you can step up your indexing game a little bit more by implementing Universal Links.</p></div></div></div>