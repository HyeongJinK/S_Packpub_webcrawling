<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch25lvl1sec167"></a>Writing asynchronous code</h2></div></div><hr /></div><p>In <a class="ulink" href="https://#" target="_blank">Chapter 9</a>, S<span class="emphasis"><em>yncing Data with CloudKit</em></span>, you had an encounter with <span>asynchronous</span><a id="id325333120" class="indexterm"></a> code and multithreading. That chapter didn't go into much detail regarding multithreading and asynchronous code because the subject of threading is rather complex, and it's much more suited to a thorough discussion, which we're explore in this chapter.</p><p>If you're unclear on what has already been explained, feel free to go back to <a class="ulink" href="https://#" target="_blank">Chapter 9</a>, <span class="emphasis"><em>Syncing Data with CloudKit</em></span>, to review the information presented there. The biggest takeaway from that chapter is that data fetching is performed on a background thread to avoid blocking the main thread. Once a fetch request is done, a <code class="literal">callback</code> function is executed, which allows you to use the main thread to update the user interface.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec133"></a>Understanding threads</h3></div></div></div><p>You've seen the term thread a couple of times now, but you never explored them; you never really learned what a <span>thread</span><a id="id325607124" class="indexterm"></a> is or how a thread works. This section aims to make the subject of threading a lot clearer to you so you can fully understand what a thread is, and why threads are such a vital part of building apps.</p><p>A good way to think of a thread is as a stack of instructions. In iOS, your app typically starts off with a single thread – the main thread. This thread is also known as the UI thread. It's called the UI thread because the main thread is where all of the user interface elements are configured, rendered, and pushed to the screen. Anything that is related to the user interface must be executed on the main thread, so if you think of a thread as a stack of instructions that are run one by one, it's easy to see why it's so important that the main thread doesn't get stuck performing a very slow instruction:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/283e8a94-1022-4310-9788-ed376f4dc723.png" /></div><p>The preceding image shows a timeline where all code is executed on the main thread. Notice how the interface can't be updated until the <span class="strong"><strong>fetch data</strong></span> and <span class="strong"><strong>parse JSON</strong></span> instructions are completed. Also, note that fetching data takes a lot longer than displaying the interface or handling a tap. During the fetch data instruction, the app is unable to update any user interface elements or process any gestures or taps. This means that the app is practically frozen until the data is fetched and parsed.</p><p>A good, responsive application can't afford to wait for <span>slow</span><a id="id325609917" class="indexterm"></a> instructions. The interface should always respond to user input; if this isn't the case, the app feels slow, buggy, choppy, and just all-around bad.</p><p>If an app uses multiple threads, it can run various instruction stacks at the same time. Each <span class="emphasis"><em>stack</em></span> is called a <span class="emphasis"><em>thread</em></span>, and specific instructions can be performed on a different thread to ensure that the main thread remains responsive:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/da277b5b-cbb6-429c-8c8b-429e4970b370.png" /></div><p></p><p>This second figure shows a more desirable scenario. The main thread only handles tasks that are related to the user interface, such as taps, animations, and scrolling. The background thread takes care of the tasks that are not related to the user interface and could potentially take a while to finish. By removing these instructions from the main thread and placing them on a different thread, like iOS does by default for networking, you can ensure that your app remains responsive, even if the network requests take several seconds to finish or never finish at all. Your app can utilize a large number of threads for different tasks.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note57"></a>Note</h3><p>The number of threads isn't infinite, so make sure that you optimize your code as much as possible to avoid locking up several threads with slow code.</p></div><p>In <a class="ulink" href="https://#" target="_blank"><span>Chapter</span> 24</a><span class="emphasis"><em>, Discovering Bottlenecks with Instruments</em></span>, you used Instruments to locate <span>slow</span><a id="id325611541" class="indexterm"></a> code in a sample app. The slow code was an instruction on the main thread that took a very long time to complete, resulting in a frozen interface. However, threading would not have solved this particular issue. The slow code you discovered calculated the layout for a collection view. A collection view can't be rendered without calculating the layout first, so this is a scenario where it's essential to make sure that you write optimized code, instead of relying on threads for anything that's slow.</p><p>Now that you have a better understanding of threads and how they can be used, let's have a look at how to offload tasks to different threads.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch25lvl2sec134"></a>Using dispatch queues in your application</h3></div></div></div><p>A basic understanding of threads is good enough for you to <span>start</span><a id="id325612670" class="indexterm"></a> using them in your applications. However, once you start using them, there's a good chance that they suddenly become confusing again. If this happens to you, don't worry; threading is not easy. Now let's look at an example of threaded code:</p><pre class="programlisting">var someBoolean = false

DispatchQueue(label: "MutateSomeBoolean").async {
  // perform some work here
  for i in 0..&lt;100 {
      continue
  }

  someBoolean = true
}

print(someBoolean)</pre><p>The preceding snippet demonstrates how you could mutate a variable after performing a task that is too slow to execute on the main thread. In the preceding code, an instance of <code class="literal">DispatchQueue</code> is created, and it's given a label. This creates a new queue on which you can execute instructions. The queue represents the background thread from the visualization you looked at <span>earlier</span>.</p><p>Then, the <code class="literal">async</code> method on <code class="literal">DispatchQueue</code> is called with the closure that should be executed on the freshly created queue. The loop inside of this block is performed on the background thread. In the visualization from before, this would roughly compare to the fetch data and parse JSON instructions. Once the task is done, <code class="literal">someBoolean</code> is mutated.</p><p>The last line in the snippet prints the value of <code class="literal">someBoolean</code>. What do you think the value of <code class="literal">someBoolean</code> is at that point? If your answer is <code class="literal">false</code>, good job! If you thought <code class="literal">true</code>, you're not alone. A lot of people who <span>start</span><a id="id325617713" class="indexterm"></a> writing multithreaded, asynchronous code don't immediately grasp how it works.</p><p>The following image shows what the code does in the background. This should make what happens and why <code class="literal">someBoolean</code> was <code class="literal">false</code> when it got printed more obvious:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/34111c6b-9876-4c77-b17d-342dad856883.png" /></div><p>Because this code uses a background thread, the main thread can immediately move to the next instruction. This means that the for loop and the print run simultaneously. In other words, <code class="literal">someBoolean</code> is printed before it's mutated on the background thread. This is both the beauty and a caveat of using threads. When everything starts running simultaneously, it is hard to keep track of when something completes.</p><p>The preceding visualization also exposes a potential problem in the code. A variable was created on the main thread, and then it got captured in the background thread which then mutated the variable. Doing this is not recommended; your code could suffer from unintended side-effects, such as race conditions, where both the main thread and the background thread mutate a value, or worse, you could accidentally try to access a Core Data object on a different thread than the one it was created on. Core Data objects do not support being used on multiple threads so you should always try to make sure that you avoid mutating or accessing objects that are not on the same thread as the one where you access them.</p><p>So, how can you mutate <code class="literal">someBoolean</code> safely and print its value <span>after</span><a id="id325618103" class="indexterm"></a> mutating it? Well, you could use a <code class="literal">callback</code> closure to achieve this. The following code is a sample of what that would look like:</p><pre class="programlisting">func executeSlowOperation(withCallback callback: @escaping ((Bool) -  &gt; Void)) {
  DispatchQueue(label: "MutateSomeBoolean").async {
    // perform some work here
    for i in 0..&lt;100 {
      continue
    }

    callback(true)
  }
}

executeSlowOperation { result in
  DispatchQueue.main.async {
    someBoolean = result
    print(someBoolean)
  }
}</pre><p>In this snippet, the slow operation is wrapped in a function that is called with a callback closure. Once the task is complete, the callback is executed, and it is passed the resulting value from the background thread. The closure makes sure that its code is executed on the main thread. If you don't do this, the closure itself would have been executed on the background thread. It's important to keep this in mind when calling asynchronous code.</p><p>The callback-based approach is excellent if your callback should be executed when a single task is finished. However, there are scenarios where you want to complete some tasks before moving to the next task. You have already used this approach in <a class="ulink" href="https://#" target="_blank">Chapter 11</a>, <span class="emphasis"><em>Being Proactive with Background Fetch</em></span>.</p><p>Let's review the heart of the background fetch logic that was used in that chapter:</p><pre class="programlisting">func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {

  let fetchRequest: NSFetchRequest&lt;Movie&gt; = Movie.fetchRequest()
  let managedObjectContext = persistentContainer.viewContext
  guard let allMovies = try? managedObjectContext.fetch(fetchRequest) else {
    completionHandler(.failed)
    return
  }

  let queue = DispatchQueue(label: "movieDBQueue")
  let group = DispatchGroup()
  let helper = MovieDBHelper()
  var dataChanged = false

  for movie in allMovies {
    queue.async(group: group) {
      group.enter()
      helper.fetchRating(forMovieId: movie.remoteId) { id,
        popularity in
        guard let popularity = popularity, popularity !=
          movie.popularity else {
            group.leave()
            return
        }

        dataChanged = true

        managedObjectContext.persist {
          movie.popularity = popularity
          group.leave()
        }
      }
    }
  }

  group.notify(queue: DispatchQueue.main) {
    if dataChanged {
      completionHandler(.newData)
    } else {
      completionHandler(.noData)
    }
  }
}</pre><p>When you first saw this code, you were probably able to <span>follow</span><a id="id326176961" class="indexterm"></a> along, but it's unlikely that you were completely aware of how complex this method is. Multiple dispatch queues are used in this snippet. To give you an idea, this code starts off on the main thread. Then, for each movie, a background queue is used to fetch its rating. Once fetching all these ratings is complete, the managed object context's dispatch queue is used to update the movie. Think about all this switching between dispatch queues that is going on for a second. Quite complex, isn't it?</p><p>The background fetch method needs to call a completion handler when it is done fetching all the data. However, a lot of different queues are used, and it's kind of hard to tell when all the fetch operations have completed. This is where dispatch groups come in. A dispatch group can hold onto a set of tasks that are executed either serially or in parallel.</p><p>When you call <code class="literal">enter()</code> on a dispatch group, you are also expected to call <code class="literal">leave()</code> on the group. The enter call tells the group that there is unfinished work in the dispatch group. When you call <code class="literal">leave()</code>, the task is marked as completed. Once all tasks are completed, the group executes a closure on any thread you desire. In the example, <code class="literal">notify(queue:)</code> is the method used to perform the completion handler on the main queue.</p><p>It's okay if this is a bit daunting or confusing right now. As mentioned before, asynchronous programming and threads are pretty complex topics, and dispatch groups are no different.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p>The most important takeaways regarding dispatch groups are that you call <code class="literal">enter()</code> on a group to submit an unfinished task, you call <code class="literal">leave()</code> to mark the task finished, and you use <code class="literal">notify(queue:)</code> to execute a closure on the queue passed to this method once all tasks are marked as completed.</p></div><p>The approach you've seen so far makes direct use of closures to perform tasks. This causes your methods to become long and relatively complex since everything is written in line with the rest of your code. You already saw how mixing code that exists on different threads can lead to confusion because it's not very obvious which code belongs on which queue. Also, all this inline code is not particularly reusable. You can't pick up a particular task and execute it on a different queue for instance, because the code is tightly coupled to a specific dispatch queue.</p><p>You can use <code class="literal">Operations</code> to make tasks that are easy to reuse and decoupled from running on a specific queue.</p></div></div>