<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch12lvl1sec86"></a>Using ARKit Quicklook</h2></div></div><hr /></div><p>One of the great benefits that AR brings to end users is that it is now possible to preview certain objects in the real world. For instance, when you buy a new sofa, you might want to see what it looks like in the real world. Of course, it was possible to implement features such as this in iOS 11 using ARKit, and many developers have, but it wasn't as easy as it could be.</p><p>iOS users can preview content using a feature <span>called</span><a id="id325333112" class="indexterm"></a> Quicklook. <span class="strong"><strong>Quicklook</strong></span> can be used to preview certain types of content without having to launch any specific applications. This is convenient for users because they can quickly determine whether a particular document is the document they are looking for by previewing it in Quicklook.</p><p>In iOS 12, Apple added the USDZ file format to the content types that can be previewed using Quicklook. Apple's USDZ format is a 3D file format based on Pixar's USD format that is used to represent 3D objects. Using Quicklook for 3D models is not just available in apps, ARKit Quicklook can also be integrated on the web. Developers can use a special HTML tag on their web pages to link to a USDZ and Safari will display the model in an ARKit Quicklook view controller.</p><p>Before you implement your AR gallery, it's a good idea to get a feeling for how AR works on iOS by implementing the ARKit Quicklook view controller to show one of the models that Apple provides on <a class="ulink" href="https://developer.apple.com/arkit/gallery/" target="_blank">https://developer.apple.com/arkit/gallery/</a>. To download a model you like, all you need to do is navigate to this page on your Mac and click on an image. The USDZ file should start downloading automatically.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"></a>Note</h3><p>Navigate to the ARKit gallery on a device that supports ARKit and tap on one of the models to see what ARKit Quicklook in Safari looks like.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec70"></a>Implementing the ARKit Quicklook view controller</h3></div></div></div><p>After obtaining a USDZ file from Apple's gallery, also <span>make</span><a id="id325333154" class="indexterm"></a> sure to capture the image that belongs to this file. Taking a screenshot of the model should be fine for testing purposes. Make sure to prepare your image in the different required sizes by scaling your screenshot up to two and three times the size of your screenshot.</p><p>Create a new project in Xcode and pick a name for your project. The sample project in this book's code bundle is called <span class="strong"><strong>ARQuickLook</strong></span>. Add your prepared image to the <code class="literal">Assets.xcassets</code> file. Also, drag your USDZ file into Xcode and make sure to add it to the app target by checking your app's checkbox when importing the file:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/66a21ac8-524f-4973-b90b-7e2c2c4b254c.png" /></div><p>Next, open the storyboard file and drag an image view to the view controller. Add the proper constraints to the image, so it's centered in the view controller and give it a width and height of 200 points. Make <span>sure</span><a id="id325333272" class="indexterm"></a> to check the <span class="strong"><strong>User Interaction Enabled</strong></span> checkbox in the <span class="strong"><strong>Attributes Inspector</strong></span> and set your model image as the image for the image view.</p><p>After doing this, open <code class="literal">ViewController.swift</code>, add <code class="literal">@IBOutlet</code> for the image view, and connect the image in the storyboard to this outlet. If the details regarding outlets are a little bit fuzzy right now, refer to the sample project in the code bundle for a refresher. The image view in the sample project uses an outlet called <code class="literal">guitarImage</code>.</p><p>The next steps to implement Quicklook for the USDZ model are to add a tap gesture recognizer to the image view and then trigger the Quicklook view controller when a user taps on the image.</p><p>Quicklook uses <span>delegation</span> to object one or more items that it should preview from a data source. It also uses a delegate to obtain the source view from which the Quicklook preview should animate. This flow applies to all different kinds of files that you can preview using Quicklook.</p><p>To begin implementing Quicklook, you must import the <code class="literal">QuickLook</code> framework. Add the following import statement to the top of <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">import Quicklook</pre><p>Next, set up the tap-gesture recognizer for the image by adding the following code to <code class="literal">viewDidLoad()</code>:</p><pre class="programlisting">let tapGesture = UITapGestureRecognizer(target: self, action: #selector(presentQuicklook))
guitarImage.addGestureRecognizer(tapGesture)</pre><p>The next step is to implement <code class="literal">presentQuicklook()</code>. This method will create a Quicklook view controller, set the delegate and data source, and then present the Quicklook view controller to the user. Add the following implementation for this method to the <code class="literal">ViewController</code> class:</p><pre class="programlisting">@objc func presentQuicklook() {
  let previewViewController = QLPreviewController()
  previewViewController.dataSource = self
  previewViewController.delegate = self

  present(previewViewController, animated: true, completion: nil)
}</pre><p>This implementation should not contain any surprises for you. <code class="literal">QLPreviewController</code> is a <code class="literal">UIViewController</code> subclass that is responsible for displaying the content it receives from its data source. It is presented in the same way you would present any other view controller, by calling <code class="literal">present(_:animated:completion:)</code>.</p><p>The final step is to implement the data <span>source</span><a id="id325578350" class="indexterm"></a> and delegates. Add the following extensions to <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">extension ViewController: QLPreviewControllerDelegate {
  func previewController(_ controller: QLPreviewController, transitionViewFor item: QLPreviewItem) -&gt; UIView? {
    return guitarImage
  }
}

extension ViewController: QLPreviewControllerDataSource {
  func numberOfPreviewItems(in controller: QLPreviewController) -&gt; Int {
    return 1
  }

  func previewController(_ controller: QLPreviewController, previewItemAt index: Int) -&gt; QLPreviewItem {
    let fileUrl = Bundle.main.url(forResource: "stratocaster", withExtension: "usdz")!
    return fileUrl as QLPreviewItem
  }
}</pre><p>The first extension you added makes <code class="literal">ViewController</code> conform to <code class="literal">QLPreviewControllerDelegate</code>. When the preview controller is about to present the 3D model, it wants to know which view is the source for the transition that is about to happen. It's recommended to return the view that acts as a preview for the Quicklook action from this method. In this case, the preview is the image of the 3D model.</p><p>The second extension acts as the Quicklook data source. When you implement Quicklook for ARKit, you can only return a single item. So when the preview controller asks for the number of items in the preview, you should always return 1. The second method in the data <span>source</span><a id="id325602477" class="indexterm"></a> provides the item that should be previewed in the preview controller. All you need to do here is obtain the file URL for the item you wish to preview. In the sample app, the Stratocaster model from Apple's gallery is used. If your model has a different name, make sure to use the correct filename.</p><p>After obtaining the <code class="literal">URL</code> that points to the image in the app bundle, it should be returned to the preview controller as a <code class="literal">QLPreviewItem</code>. Luckily, <code class="literal">URL</code> instances can be converted to <code class="literal">QLPreviewItem</code> instances automatically.</p><p>If you run your app now, you can tap on your image of the 3D model to begin previewing it. You can preview the image on its own, or you can choose to preview it in AR. If you tap this option, the preview controller will tell you to move your device around:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/bd0fe9e5-aa3b-495e-a9aa-514cde98124f.png" /></div><p>To make a mapping of the world around you, ARKit requires some samples of the environment. When you move your device around, make sure not just to tilt it, but physically move it. Doing this will help ARKit discover trackable features in your surroundings.</p><p>Once ARKit has enough data about your surroundings, you <span>can</span><a id="id325602537" class="indexterm"></a> place the 3D model in the environment, scale it by pinching, rotate it, and move it around in the space. Note that the model is placed on a flat surface such as a table or the floor automatically rather than awkwardly floating around.</p><p>Also note that ARKit applies very realistic lighting to your object. The visual data that ARKit gathers about the environment is used to create a lighting map that is applied to the 3D model to make it properly blend in with the context in which the object was placed:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/be5fa3b1-a91c-4f24-93a2-0ae7f92f02b2.jpg" /></div><p>While playing around with ARKit like this is a lot of fun, it's even more fun to create your own AR experiences. Since ARKit supports several rendering techniques, such as SpriteKit and SceneKit, the next two sections will spend a little bit of time explaining the very basics of SpriteKit and SceneKit. You won't learn how to build complete games or worlds with these frameworks. Instead, you will learn just enough to get you started with implementing either rendering engine in an ARKit app.</p></div></div>