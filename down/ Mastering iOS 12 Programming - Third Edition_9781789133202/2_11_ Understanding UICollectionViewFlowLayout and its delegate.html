<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec18"></a>Understanding UICollectionViewFlowLayout and its delegate</h2></div></div><hr /></div><p>When you use a standard collection view, it uses a grid layout. In this grid layout, all items are evenly spaced, and all items have the same size. You can visualize this quite easily by giving the collection view cell a background color in your <span>Storyboard</span> and running your app. This standard grid layout makes adding a grid to your app a breeze. However, the standard implementation of the grid layout is not quite perfect. If you look at the grid you have set up, it should look good on, for instance, an iPhone 8 but when switching to a smaller screen such as the iPhone SE, the layout looks nothing like the beautiful grid layout you saw before. Viewing the grid on a larger screen such as an iPhone 8 Plus doesn't make it any better either. The grid would be significantly improved if every <span>cell</span><a id="id325337171" class="indexterm"></a> was sized based on the size of the screen. Let's see how this can be achieved.</p><p> </p><p>In your <span>storyboard</span>, select the <span class="strong"><strong><strong class="userinput"><code>Collection View Flow Layout</code></strong></strong></span> object in the <span class="strong"><strong><strong class="userinput"><code>Document Outline</code></strong></strong></span>. In the <strong class="userinput"><code><span class="strong"><strong>Attributes Inspector</strong></span></code></strong>, you can change several properties for the collection view's layout. For instance, you can change its scroll axis from vertical to horizontal. This is something that can't be achieved using a table view since table views only allow scrolling on their vertical axis. If you switch to the <strong class="userinput"><code><span class="strong"><strong>Size Inspector</strong></span></code></strong> for the layout object, you will find several available options to change the cell's spacing and size. As you may or may not know, the iPhone SE has a display width of 320 points, so try updating the layout's item size from 110 points wide to a width of 106 points. That should allow the grid to lay out all items with just a single pixel in between every cell. Also, update the minimum spacing for cells and lines to 1 point. This value indicates the minimum spacing for cells and lines. Note that when the layout is actually calculated, the spacing could be larger than you specified to ensure everything fits the screen nicely. Because it's a minimum spacing, cells will never be placed closer to each other than you have specified.</p><p>Try running your app on an iPhone SE now. You will notice that the layout looks great for this device. However, on larger screens the spacing between cells is a lot larger than you would like it to be, so we haven't achieved much yet. Luckily, you can adjust the cell size for your collection view items in your code as well. This means that you can use the currently available space for the collection view to determine precisely what size every cell should be to look great on all devices.</p><p>The standard layout that is used by a collection view is an instance of <code class="literal">UICollectionViewFlowLayout</code>. This object has a delegate property that conforms to the <code class="literal">UICollectionViewDelegateFlowLayout</code> protocol. This protocol specifies several methods that you can implement to take fine-grained control over your collection view's layout, allowing you to dynamically calculate cell spacing, line spacing, and cell size. For this example, dynamically calculating the cell size is the most interesting one. Since the spacing between cells should always be at least 1 point regardless of screen size, this property doesn't have to be calculated dynamically.</p><p>The requirement for the cell size can be summed up as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Three cells should fit on a single row in the grid.</li><li style="list-style-type: disc">The cell's sizing should allow for approximately 1 pixel of room between every cell in a row.</li></ul></div><p>To meet these requirements, the method from <code class="literal">UICollectionViewDelegateFlowLayout</code> that needs to be implemented is <code class="literal">collectionView(_:layout:sizeForItemAt:)</code>. This method will be used to return a size that is roughly one-third or less of the collection view's width, and that has a height of 90 points. To do this, add the following extension to your <code class="literal">ViewController</code> class:</p><pre class="programlisting">extension ViewController: UICollectionViewDelegateFlowLayout {
  func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout,
                      sizeForItemAt indexPath: IndexPath) -&gt; CGSize {

    let width = floor((collectionView.bounds.width - 2) / 3)
    return CGSize(width: width, height: 90)
  }
}</pre><p>The method in this extension is called for every cell in the collection view. This means that you can dynamically calculate the size for each collection view cell. The implementation you just added uses the <code class="literal">floor</code> function to make sure the width for each item is always one-third or less of the collection view width. To account for the 1 point spacing between each cell, 2 is subtracted from the collection view's width before dividing it by 3.</p><p>If you run your app like this, you will find that the <span>spacing</span><a id="id325369920" class="indexterm"></a> between items is nice and tight. However, if you look at this layout on an iPhone 8, you might notice that the spacing between cells on the horizontal axis does not really match the spacing between the cells on the vertical axis. You might have to look real close, but once you notice this it is hard to not see it. You can fix this by dynamically calculating the spacing between each cell and then using this value as the new minimum line spacing. The following code snippet takes care of this calculation. Add it to your <code class="literal">UICollectionViewDelegateFlowLayout</code> extension in <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout,
                    minimumLineSpacingForSectionAt section: Int) -&gt; CGFloat {

  let availableWidthForCells = collectionView.bounds.width - 2
  let totalGutterSpace = availableWidthForCells.truncatingRemainder(dividingBy: 3)
  let cellSpacing = totalGutterSpace / 2

  return 1 + cellSpacing
}</pre><p>The calculation to come up with the appropriate value is somewhat complex so breaking it down step by step helps to make sense of it. Since the spacing will never be less than 1, and there are two spacing gutters per row, these gutters are subtracted from the available width. This available width is the same width that is available for the collection view cells. Next, <code class="literal">truncatingRemainder(dividingBy:)</code> is used to find out how much space is left over after dividing it between the collection view cells. This remaining space is then divided by 2 since there are two gutters in the collection view. And lastly, because the standard spacing will always be 1, the calculated gutter width is incremented by 1.</p><p>The fact that you can take fine-grained control over a collection view's grid layout by implementing methods from <code class="literal">UICollectionViewDelegateFlowLayout</code> makes it even more powerful and flexible than its out-of-the-box implementation. You can create all kinds of grids with custom spacing, cells that have different heights or widths, and more. Sometimes all this power and flexibility isn't quite enough. Imagine, for instance, you want your grid to be a little bit more playful. Something where cells are a little bit more scattered across the screen, for instance. You can achieve this by creating your <code class="literal">UICollectionViewLayout</code> subclass.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec11"></a>Creating a custom UICollectionViewLayout</h3></div></div></div><p>Implementing a large and complex feature <span>such</span><a id="id325578349" class="indexterm"></a> as a custom collection view layout might seem like a huge challenge for most people. Creating your layout involves calculating the position for every cell that your collection view will display. You must ensure that these calculations are performed as quickly and efficiently as possible because your layout calculations directly influence the performance of your collection view. A poor layout implementation will lead to slow scrolling and a lousy user experience eventually. Luckily, the documentation that has been provided for creating a collection view layout is pretty good as a reference to figure out if you're on the right track.</p><p>If you take a look at Apple's documentation on <code class="literal">UICollectionViewLayout</code>, you can read about its role in a collection view. The available information shows that a custom layout requires you to handle layout for cells, supplementary views, and decoration views. Supplementary views are header and footer views. The <strong class="userinput"><code><span>Hello-Contacts</span></code></strong> app does not use headers and footers in its collection view so these views can be skipped. Decoration views are views that don't correspond with any data in the collection view's data source, but they are part of the collection view's layout. The purpose of these views is purely decorative, just like the name <span class="emphasis"><em>decoration view</em></span> suggests. Since these views are also not used by <strong class="userinput"><code><span class="strong"><strong>Hello-Contacts</strong></span>,</code></strong> the focus will be on the collection view cells only. This makes sure that the implementation remains simple and understandable.</p><p>In addition to listing the kinds of views you should layout, the documentation also mentions several methods that should be implemented for any custom layout. Note that not all of these methods are mandatory. For instance, any method that relates to supplementary and decoration views can be omitted if you don't need them. The methods and properties that you need to implement for your custom grid of collection view cells are the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">collectionViewContentSize</code></li><li style="list-style-type: disc"><code class="literal">layoutAttributesForElements(in:)</code></li><li style="list-style-type: disc"><code class="literal">layoutAttributesForItem(at:)</code></li><li style="list-style-type: disc"><code class="literal">shouldInvalidateLayouts(forBoundsChange:)</code></li><li style="list-style-type: disc"><code class="literal">prepare()</code></li></ul></div><p>Further down in the <span>documentation</span><a id="id325602487" class="indexterm"></a> page for <code class="literal">UICollectionViewLayout</code>, you can find some information about updating the layout. For now, you won't bother implementing this, but it's most certainly worth it to familiarize yourself with all of the available documentation. The <code class="literal">prepare()</code> method is a very interesting one. It provides a great opportunity for developers to pre-calculate a collection view's layout. Since all cells in <span class="strong"><strong><strong class="userinput"><code>Hello-Contacts</code></strong></strong></span> are the same size, the entire layout for the collection view can be calculated in <code class="literal">prepare()</code>. In this case, it's a great choice to do this due to the extremely predictable nature of the layout.</p><p>A custom collection view layout always is a subclass of <code class="literal">UICollectionViewLayout</code>. To make your layout object, create a new Cocoa Touch class and name it <code class="literal">ContactsCollectionViewLayout</code>. Make sure to have this class inherit from <code class="literal">UICollectionViewLayout</code>. The design you are going to implement in your custom layout object is shown in the following screenshot. It looks a lot like a regular horizontally scrolling layout except that the cells are distributed quite playfully, with every other row slightly offset to the right:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/e511cd77-6f3d-4e83-b90a-1d2a8c55ea3c.png" /></div><p>Since all elements in this layout have a predictable size that doesn't depend on any external factors such as the bounds of the collection view this layout belongs to, all heavy lifting can be done in the <code class="literal">prepare()</code> method. This is where all layout attributes for cells will be calculated, so they are available long before the collection view starts asking for sizes for specific cells that are about to be shown on screen.</p><p>The steps required to implement the <span>entire</span><a id="id325604097" class="indexterm"></a> custom layout are the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Pre-calculate the layout in the <code class="literal">prepare()</code> method.</li><li>Implement <code class="literal">collectionViewContentSize</code> to provide the collection view with enough information to configure scrolling.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Implement <code class="literal">layoutAttributesForElements(in:)</code> to provide layout attributes for items in a certain area.</li><li>Implement <code class="literal">layoutAttributesForItem(at:)</code> to provide information about the layout of a specific item.</li><li>Implement <code class="literal">shouldInvalidateLayout(forBoundsChange:)</code> to determine whether a certain change in a collection view's size should trigger a recalculation of the layout.</li><li>Assign the custom layout to the collection view.</li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec4"></a>Pre-calculating the layout</h4></div></div></div><p>To figure out how to calculate the layout for your collection view, you can use a playground to quickly test and iterate over your attempts at calculating a layout, without the overhead of having to run an app first. Playgrounds are a fantastic way to test, explore, and validate ideas you have quickly. Since playgrounds don't need an <span>entire</span><a id="id325606050" class="indexterm"></a> app to run, they provide immediate feedback, something you don't get when you usually build and run a project. Create a new playground by navigating to <span class="strong"><strong><strong class="userinput"><code>File</code></strong></strong></span> | <span class="strong"><strong><strong class="userinput"><code>New</code></strong></strong></span> | <span class="strong"><strong><strong class="userinput"><code>Playground</code></strong></strong></span>. Create a new playground and name it something like <code class="literal">LayoutExploration</code>.</p><p>The collection view should display as many items as possible, so the first step when calculating the layout is to determine how many cells fit on the vertical axis of the screen. The horizontal axis doesn't need to be taken into account since the horizontal axis is the scrolling axis. Imagine a collection view that has a height of 667 points, where every cell is 90 points high and there are 10 points of spacing between every cell. Using these values, you would perform the following calculation to come up with the number of cells that fit on the vertical axis of the screen:</p><pre class="programlisting">(667 + 10) / 100 = 6.77</pre><p>This means that you would fit 6.77 cells on the vertical axis of the collection view. Note that 10 is added to the height of the collection view and that the resulting value is divided by 100. This is done to properly compensate for the spacing between cells. Once you know the number of cells that fit on the vertical axis, you can also determine how many cells will exist on the horizontal axis. All you need to know is the total number of contacts that the collection view is going to display. When the collection view will show 60 cells in total, you can use the following calculation to determine the number of cells per row:</p><pre class="programlisting">60 / 6 = 10</pre><p>Note that the number of cells is not divided by 6.77 but by 6. The number of cells on the vertical axis is rounded down because cells should always fit on the screen completely, not partially. The vertical axis only fits six complete cells, so dividing by 6 is the correct way to perform the calculation.</p><p>With this information in mind, you can begin <span>setting</span><a id="id325607085" class="indexterm"></a> up the playground by defining a couple of variables. Open the playground you created earlier and add the following code to it:</p><pre class="programlisting">import UIKit

let collectionViewHeight = 667
let itemHeight = 90
let itemWidth = 100
let itemSpacing = 10
let numberOfItems = 60
let numberOfRows = (collectionViewHeight + itemSpacing) / (itemHeight + itemSpacing)
let numberOfColumns = numberOfItems / numberOfRows</pre><p>This snippet sets up all the variables that you have seen earlier. Note that <code class="literal">numberOfRows</code> does not need to be rounded down. All the input numbers have the type <code class="literal">Int</code>. Since <code class="literal">Int</code> doesn't support floating point numbers, all calculations done with <code class="literal">Int</code> are automatically rounded to the correct value. You can now use these values to write a loop that calculates the exact location for each of the 60 cells that you want to display. The following code snippet does just that:</p><pre class="programlisting">let allFrames: [CGRect] = (0..&lt;numberOfItems).map { itemIndex in
  let row = itemIndex % numberOfRows
  let column = itemIndex / numberOfRows

  var xPosition = column * (itemWidth + itemSpacing)
  if row % 2 == 1 {
    xPosition += itemWidth / 2
  }

  let yPosition = row * (itemHeight + itemSpacing)

  return CGRect(x: xPosition, y: yPosition, width: itemWidth, height: itemHeight)
}

print(allFrames)</pre><p>The preceding code creates an array of <code class="literal">CGRect</code> objects by mapping over a range. Whenever you have a list of something - in this case, a list of indexes that is created using <code class="literal">(0..&lt;numberOfItems)</code> - you can then use <code class="literal">map</code> to transform each item in that list into something else. In this case, <code class="literal">map</code> turns an <code class="literal">itemIndex</code> <span>object</span> that corresponds to one of the cells that the collection will display into a <code class="literal">CGRect</code> <span>object</span> that could be used as the <code class="literal">frame</code> <span>object</span> for a cell. This loop also takes care of that playful offset every other row <span>should</span><a id="id325609922" class="indexterm"></a> have. The <code class="literal">%</code> operator is used to determine whether the item belongs on an even or odd row and then offsets the item accordingly.</p><p>After the array of frames is created, it is printed to make sure the layout contains all the expected values. You can now run your playground by hitting <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>Enter</em></span> or clicking the play button in the bottom-left corner of the editor. After running your playground, you should see the following output in the console:</p><pre class="programlisting">[(0.0, 0.0, 100.0, 90.0), (50.0, 100.0, 100.0, 90.0), (0.0, 200.0, 100.0, 90.0), (50.0, 300.0, 100.0, 90.0), (0.0, 400.0, 100.0, 90.0), (50.0, 500.0, 100.0, 90.0), (110.0, 0.0, 100.0, 90.0), (160.0, 100.0, 100.0, 90.0), (110.0, 200.0, 100.0, 90.0), (160.0, 300.0, 100.0, 90.0), (110.0, 400.0, 100.0, 90.0), (160.0, 500.0, 100.0, 90.0), (220.0, 0.0, 100.0, 90.0), (270.0, 100.0, 100.0, 90.0), (220.0, 200.0, 100.0, 90.0), (270.0, 300.0, 100.0, 90.0), (220.0, 400.0, 100.0, 90.0), (270.0, 500.0, 100.0, 90.0), (330.0, 0.0, 100.0, 90.0), (380.0, 100.0, 100.0, 90.0), (330.0, 200.0, 100.0, 90.0), (380.0, 300.0, 100.0, 90.0), (330.0, 400.0, 100.0, 90.0), (380.0, 500.0, 100.0, 90.0), (440.0, 0.0, 100.0, 90.0), (490.0, 100.0, 100.0, 90.0), (440.0, 200.0, 100.0, 90.0), (490.0, 300.0, 100.0, 90.0), (440.0, 400.0, 100.0, 90.0), (490.0, 500.0, 100.0, 90.0), (550.0, 0.0, 100.0, 90.0), (600.0, 100.0, 100.0, 90.0), (550.0, 200.0, 100.0, 90.0), (600.0, 300.0, 100.0, 90.0), (550.0, 400.0, 100.0, 90.0), (600.0, 500.0, 100.0, 90.0), (660.0, 0.0, 100.0, 90.0), (710.0, 100.0, 100.0, 90.0), (660.0, 200.0, 100.0, 90.0), (710.0, 300.0, 100.0, 90.0), (660.0, 400.0, 100.0, 90.0), (710.0, 500.0, 100.0, 90.0), (770.0, 0.0, 100.0, 90.0), (820.0, 100.0, 100.0, 90.0), (770.0, 200.0, 100.0, 90.0), (820.0, 300.0, 100.0, 90.0), (770.0, 400.0, 100.0, 90.0), (820.0, 500.0, 100.0, 90.0), (880.0, 0.0, 100.0, 90.0), (930.0, 100.0, 100.0, 90.0), (880.0, 200.0, 100.0, 90.0), (930.0, 300.0, 100.0, 90.0), (880.0, 400.0, 100.0, 90.0), (930.0, 500.0, 100.0, 90.0), (990.0, 0.0, 100.0, 90.0), (1040.0, 100.0, 100.0, 90.0), (990.0, 200.0, 100.0, 90.0), (1040.0, 300.0, 100.0, 90.0), (990.0, 400.0, 100.0, 90.0), (1040.0, 500.0, 100.0, 90.0)]</pre><p> </p><p>If you want to run your complete playground again, click the stop button in the bottom-left corner to reset the playground and then hit play again to run it. The output you produced is not very easy to read but if you examine it closely, you should be able to see that this layout is exactly what you were looking for. All items have the correct size, the indentation works, and the items are created from top to bottom and from left to right. You have already created a placeholder file called <code class="literal">ContactsCollectionViewLayout</code>; now add the following skeleton code to it as a first step toward implementing your custom layout:</p><pre class="programlisting">import UIKit

class ContactsCollectionViewLayout: UICollectionViewLayout {
  private let itemSize = CGSize(width: 100, height: 90)
  private let itemSpacing: CGFloat = 10

  private var layoutAttributes = [UICollectionViewLayoutAttributes]()

  override var collectionViewContentSize: CGSize {
    return .zero
  }

  override func prepare() {

  }

  override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -&gt; Bool {
    return false
  }

  override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {
    return nil
  }

  override func layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? {
    return nil
  }
}</pre><p>All this code does is provide some placeholders that you will gradually replace with proper implementations. Note that <code class="literal">itemSize</code> and <code class="literal">itemSpacing</code> are defined as constants here. If you were to create your own layout and you want it to behave a bit more like <code class="literal">UICollectionViewFlowLayout</code> by allowing developers to customize the item sizes and spacing, you <span>should</span><a id="id325611550" class="indexterm"></a> make these constants variables instead.</p><p>In this case, the item size and spacing won't be modified externally so having them as constants makes sense. Because external sources don't need to modify or even access any of the defined properties, they are marked as <code class="literal">private</code>. It is considered good practice to mark properties and methods as <code class="literal">private</code> if other classes do not need to access them.</p><p>Also note that the layout is not defined as an array of <code class="literal">CGRect</code> instances, but instead it is defined as an array of <code class="literal">UICollectionViewLayoutAttributes</code>. This is the type of object that a collection view uses to describe the layout attributes of its items. You can now add the following implementation for <code class="literal">prepare()</code>:</p><pre class="programlisting">override func prepare() {
  // 1
  guard let collectionView = self.collectionView
    else { return }

  let availableHeight = Int(collectionView.bounds.height + itemSpacing)
  let itemHeight = Int(itemSize.height + itemSpacing)

  numberOfItems = collectionView.numberOfItems(inSection: 0)
  numberOfRows = availableHeight / itemHeight
  numberOfColumns = Int(ceil(CGFloat(numberOfItems) / CGFloat(numberOfRows)))

  layoutAttributes.removeAll()

  // 2
  layoutAttributes = (0..&lt;numberOfItems).map { itemIndex in
    let row = itemIndex % numberOfRows
    let column = itemIndex / numberOfRows

    var xPosition = column * Int(itemSize.width + itemSpacing)
    if row % 2 == 1 {
      xPosition += Int(itemSize.width / 2)
    }

    let yPosition = row * Int(itemSize.height + itemSpacing)

    // 3
    let indexPath = IndexPath(row: itemIndex, section: 0)
    let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath)
    attributes.frame = CGRect(x: CGFloat(xPosition), y: CGFloat(yPosition),
 width: itemSize.width, height: itemSize.height)

    return attributes
  }
}</pre><p>This implementation is very similar to the one you wrote in the playground. The first comment highlights a key difference though. Instead of using hardcoded values for the available space, the layout's <code class="literal">collectionView</code> property is used to determine the available space.</p><p>The second comment <span>shows</span><a id="id325615341" class="indexterm"></a> the code that calculates the position of every item. Just like before, <code class="literal">map</code> is used to configure the list of attributes. Note that many conversions between <code class="literal">Int</code> and <code class="literal">CGFloat</code> take place to make sure all types are used correctly. Since iOS expresses positions in a layout using <code class="literal">CGFloat</code> but the layout calculations rely on the rounding properties of <code class="literal">Int</code>, it is important to convert between types properly.</p><p>The third and last comment highlights the creation of the <code class="literal">UICollectionViewLayoutAttributes</code> instance for each item. In addition to a <code class="literal">CGRect</code> <span>instance</span> for size and positioning, <code class="literal">UICollectionViewLayoutAttributes</code> uses an <code class="literal">IndexPath</code> <span>object</span> to tie itself to the position of a certain cell. This wraps up the preparation of the layout. Next up, we will calculate <code class="literal">collectionViewContentSize</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec5"></a>Implementing collectionViewContentSize</h4></div></div></div><p>A collection view uses the <code class="literal">collectionViewContentSize</code> property from its layout to figure out the size of its contents. This property is especially important <span>because</span><a id="id325618113" class="indexterm"></a> it is used to configure and display the scrolling indicators for the collection view. It also provides the collection view with information about the direction in which scrolling should be enabled.</p><p>Implementing this property uses the number of rows and columns in the collection view. It also takes the item size and item spacing into account to come up with the size of all of its contents together. Add the following implementation for <code class="literal">collectionViewContentSize</code>:</p><pre class="programlisting">override var collectionViewContentSize: CGSize {
  let width = CGFloat(numberOfColumns) * itemSize.width + CGFloat(numberOfColumns - 1) * itemSpacing
  let height = CGFloat(numberOfRows) * itemSize.height + CGFloat(numberOfRows - 1) * itemSpacing

  return CGSize(width: width, height: height)
}</pre><p>Determining the entire size of the collection view is quite simple now because the <code class="literal">prepare()</code> method has already performed all the hard work to set up the layout.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec6"></a>Implementing layoutAttributesForElements(in:)</h4></div></div></div><p>More complex than <code class="literal">collectionViewContentSize</code> is <code class="literal">layoutAttributesForElements(in:)</code>. This method is responsible for providing a collection view with the layout <span>attributes</span><a id="id325337120" class="indexterm"></a> for several elements at once. The collection view always provides a rectangle, for which it needs layout attributes. The layout is responsible for providing these attributes to the collection view as fast as possible. It is essential that the implementation of this method is as efficient as you can get it to be; your scroll performance depends on it.</p><p>Even though there is only a small number of cells visible at a time, the collection view has a lot more content outside of its current viewport. Sometimes it is asked to jump to a particular cell, or the user scrolls extremely fast. There are many cases for the collection view to ask for all layout attributes for several cells at once. When this happens, the layout object can help the cell determine which cells should be visible for a particular rectangle. This is possible because the layout attributes do not only contain the rectangle in which a cell should be rendered, it also knows the <code class="literal">IndexPath</code> <span>object</span> that corresponds with that specific cell.</p><p>This is pretty complicated matter, and it's okay if you find this to be a little bit confusing. As long as you understand that a collection view can ask its layout which cells are present in a certain <code class="literal">CGRect</code> <span>instance</span> and how they should be rendered, you understand what <code class="literal">layoutAttributesForElements(in:)</code> does. The most straightforward implementation we can come up with for <code class="literal">layoutAttributesForElements(in:)</code> is the following:</p><pre class="programlisting">override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {
  return layoutAttributes.filter { attributes in
    return attributes.frame.intersects(rect)
  }
}</pre><p>This code filters the list of attributes and returns a new list that only contains attributes that are within the bounds of the supplied rectangle. Note that this implementation might not be the best possible implementation for your custom layout. As the number of items in the collection grows, the time to run the filter grows too. You might be better off implementing a different method to look up the correct items. This depends on your exact use case, layout, and bottlenecks.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec7"></a>Implementing layoutAttributesForItem(at:)</h4></div></div></div><p>Another way a collection view can request layout <span>attributes</span><a id="id325337477" class="indexterm"></a> for its layout is by requesting the attributes for a single item. Because the collection view does so by supplying an index path, this method is quite simple to implement. The layout you implemented assumes that only a single section exists in the collection view and the layout attributes array is sorted by index path because that's the order in which all items were inserted into the array. This means that you can use the supplied index path's row to fetch the correct layout attributes from the layout attributes array:</p><pre class="programlisting">override func layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? {
  return layoutAttributes[indexPath.row]
}</pre><p>The last remaining method to implement is <code class="literal">shouldInvalidateLayout(forBoundsChange:)</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec8"></a>Implementing shouldInvalidateLayout(forBoundsChange:)</h4></div></div></div><p>Getting the implementation for <code class="literal">shouldInvalidateLayout(forBoundsChange:)</code> is crucial to having a great collection view layout that has amazing performance. If you <span>implement</span><a id="id325337505" class="indexterm"></a> this method incorrectly, you could constantly be invalidating the layout, meaning you will need to recalculate all the time. It's also possible that the collection view will never update its layout at all, even when it should. The collection view will call this method any time its size changes. For instance, when the user rotates their device or when your app runs on an iPad, the user opens another app in multitasking mode.</p><p>The layout you have created only need to update when the number of items that fit on the vertical axis changes. The following diagram shows a scenario where invalidating the bounds isn't required because the number of items that fit on the vertical axis does not change:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/78bfe08d-83bc-4f89-9d3e-a2f7a4cf8fd8.png" /></div><p>As you can see, it would not make sense to recalculate the entire layout if the layout of the cells doesn't have to change. The best implementation for this specific layout is to calculate the new number of items on the vertical axis, checking whether this new number is different and then invalidating the layout when it is. Add the <span>following</span><a id="id325337527" class="indexterm"></a> implementation to your layout class:</p><pre class="programlisting">override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -&gt; Bool {
  guard let collectionView = self.collectionView
    else { return true }

  let availableHeight = newBounds.height - collectionView.contentInset.top - collectionView.contentInset.bottom
  let possibleRows = Int(availableHeight + itemSpacing) / Int(itemSize.height + itemSpacing)

  return possibleRows != numberOfRows
}</pre><p>This method uses a similar technique as you have seen before to determine the maximum amount of items on the vertical axis. When this new amount is different from the old amount, <code class="literal">possibleRows != numberOfRows</code> evaluates to true, and the layout will be invalidated.</p><p>This wraps up the work you have to do to set up your layout object; the time has come to see how you can use this custom layout in your project.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec9"></a>Assigning a custom layout to your collection view</h4></div></div></div><p>The final step to using your <span>custom</span><a id="id325337555" class="indexterm"></a> layout is telling your collection view to use your layout. You have already seen that you can assign a custom class to the layout for a collection view in <strong class="userinput"><code>Interface Builder</code></strong>. However, this only works when your layout inherits from <code class="literal">UICollectionViewFlowLayout</code>, which your layout does not inherit from. Luckily, you can also set your collection view's layout in code. Update your <code class="literal">viewDidLoad</code> method in <code class="literal">ViewController.swift</code> by adding the following line to it:</p><pre class="programlisting">collectionView.collectionViewLayout = ContactsCollectionViewLayout()</pre><p>This line sets your new layout as the current layout. You can now remove the <code class="literal">UICollectionViewDelegateFlowLayout</code> extension from <code class="literal">ViewController.swift</code> as it is not needed anymore.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec10"></a>Final words on the custom layout</h4></div></div></div><p>The <span>custom</span><a id="id325337596" class="indexterm"></a> layout you created in this subsection is an excellent example of how powerful collection views are. However, with great power comes great responsibility. For instance, you will need to make sure your layout is as performant as you can make it. Slower implementations will quickly lead to lousy scrolling performance, which you want to avoid at all costs. However, don't go overboard with optimizing your code right away. Think about the use case for your collection view. Maybe you won't ever display more than a certain amount of items, and you can get away with a slightly slower implementation. Or perhaps you want to reuse your layout, meaning you should make sure it works great no matter how many items you throw at it.</p><p>Being able to create fantastic collection view layouts is a skill you will most certainly want to have as it enables you to implement amazing, performant layouts that will delight your users. You know now that creating your collection view layout does not have to be extremely complex. With some careful planning and experimentation in playgrounds, you will build amazing layouts for your users in no time!</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note10"></a>Note</h3><p>Reader exercise: The layout you created is aligned to the top of the collection view and fills the screen up as much as possible. This leaves empty space at the bottom of the screen. Try to adapt the layout so that it's centered vertically, making sure the space up top matches the space at the bottom. Implementing this will involve updating your layout preparation and invalidation code. Good luck!</p></div></div></div></div>