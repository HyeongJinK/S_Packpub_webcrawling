<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec65"></a>Fetching data from the web</h2></div></div><hr /></div><p>Retrieving <span>data</span><a id="id325357372" class="indexterm"></a> from the web is something that you will often do as an iOS professional. You won't just fetch data from a <span>web</span><a id="id325357402" class="indexterm"></a> service; you'll also send data back to it. For example, you might have to make an HTTP <code class="literal">POST</code> request as part of a login flow or to update a user's profile information. Over time, iOS has evolved quite a bit in the web requests department, making it easier to use web services in apps.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note29"></a>Note</h3><p>HTTP (or HTTPS) is a protocol that almost all web traffic uses for communication between a client, such as an app, and a server. The HTTP protocol supports several methods that signal the request's intent. <code class="literal">GET</code> is used to retrieve information from a server. A <code class="literal">POST</code> request indicates the intention to push new content to a server, for instance, submitting a form.</p></div><p>When you want to perform a web request in iOS, you will typically use the <code class="literal">URLSession</code> class. The <code class="literal">URLSession</code> class makes asynchronous web requests on your behalf. This means that iOS loads data from the web on a background thread, ensuring that the user interface remains responsive throughout the entire request. If a web request is performed synchronously, the user interface is unresponsive for the duration of the network request because a thread can only do one thing at a time, so if it's waiting for a response from the network, it can't respond to touches or other user input.</p><p>If your user has a slow internet connection, a request could take <span>several</span><a id="id325602533" class="indexterm"></a> seconds. You don't want <span>your</span><a id="id325602541" class="indexterm"></a> interface to freeze for several seconds. Even a couple of milliseconds will create a noticeable drop in its responsiveness and frame rate. This can be easily avoided with <code class="literal">URLSession</code> to perform asynchronous network requests.</p><p>First, you will experiment with basic network requests in a playground. You can create a new playground or use the one provided in this book's code bundle. After you've seen the basics of <code class="literal">URLSession</code>, you'll implement a way to fetch movies from an open source movie database and put this implementation to use in the <span class="strong"><strong>MustC</strong></span> app.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec43"></a>Understanding URLSession basics</h3></div></div></div><p>The following code snippet shows a <span>sample</span><a id="id325604107" class="indexterm"></a> of a network request that loads the <a class="ulink" href="https://apple.com" target="_blank">https://apple.com</a> homepage:</p><pre class="programlisting">import Foundation

let url = URL(string: "https://apple.com")!
let task = URLSession.shared.dataTask(with: url)
{
  data, response, error in
  print(data)
  print(response)
  print(error)
}

task.resume()</pre><p>This is an elementary example: A URL is created, and then the shared <code class="literal">URLSession</code> instance is used to create a new <code class="literal">dataTask</code>. This <code class="literal">dataTask</code> is an instance of <code class="literal">URLSessionDataTask</code> and allows you to load data from a remote server. Alternatively, you could use a download task if you're downloading a file, or an upload task if you're uploading files to a web server. After creating the task, you must call resume on the task, because new tasks are always created in a suspended state.</p><p>If you run this sample in an empty playground, you'll find that the example doesn't work. Because the network request is made asynchronously, the playground finishes its execution before the network request is complete. To fix this, you should make sure that the playground runs indefinitely. Doing so will allow the network request to finish. Add the following lines to the top of the playground source file to enable this behavior:</p><pre class="programlisting">import PlaygroundSupport
PlaygroundPage.current.needsIndefiniteExecution = true</pre><p>Now that the playground runs indefinitely, you'll find that <span>there</span><a id="id325606045" class="indexterm"></a> isn't a lot of useful data printed to the console. In this case, you're not interested in the raw data, HTTP headers, or the fact that the error is <code class="literal">nil</code>. When you load data from a URL, you're often most interested in the response's body. The body of a response usually contains the string representation of the data you requested. In the case of the preceding example, the body is the HTML that makes up Apple's homepage. Let's see how you can extract this HTML from the response. Replace the data task's completion callback with the following:</p><pre class="programlisting">{ data, response, error in
  guard let data = data, error == nil
    else { return }

  let responseString = String(data: data, encoding: .utf8)
  print(responseString)
}</pre><p>The preceding callback closure makes sure that there are no errors returned by the web service and that there is data present. Then, the raw data is converted to a string, and that string is printed to the console. If you use this callback instead of the old one, you'll see the HTML for the Apple homepage printed. Simple requests to a web server like the one you just saw are relatively simple to implement with <code class="literal">URLSession</code>.</p><p>You can take more control over the request that's executed by creating a <code class="literal">URLRequest</code> instance. The example you saw is one where you let <code class="literal">URLSession</code> create the <code class="literal">URLRequest</code> on your behalf. This is fine if you want to perform a simple HTTP <code class="literal">GET</code> request with no custom headers, but if you're going to post data or include specific headers, you will need to have more control over the request that's used. Let's take a look at what a <code class="literal">GET</code> request with some parameters and a custom header looks like.</p><p>The following code uses an API key from <a class="ulink" href="https://www.themoviedb.org/" target="_blank">https://www.themoviedb.org/</a>. If you want to try this code example, create an account on their website and request an API key on your account page. Setting this up should only take a couple of minutes, and if you want to follow along with this chapter, you will need to have your own API key:</p><pre class="programlisting">let api_key = "YOUR_API_KEY_HERE"
var urlString = "https://api.themoviedb.org/3/search/movie/"
urlString = urlString.appending("?api_key=\(api_key)")
urlString = urlString.appending("&amp;query=Swift")

let movieURL = URL(string: urlString)!

var urlRequest = URLRequest(url: movieURL)
urlRequest.httpMethod = "GET"
urlRequest.setValue("application/json", forHTTPHeaderField: "Accept")

let movieTask = URLSession.shared.dataTask(with: urlRequest) { data, response, error in
  print(response)
}

movieTask.resume()</pre><p>The preceding code is a bit more <span>complicated</span><a id="id325607089" class="indexterm"></a> than the example you saw before. In this example, a more complex URL is configured that includes some HTTP <code class="literal">GET</code> parameters. The <code class="literal">httpMethod</code> for <code class="literal">URLRequest</code> is specified, and a custom header is provided to inform the receiver of this request about the type of response it would like to receive.</p><p>The flow for executing this URL request is the same as the one you saw <span>earlier</span>. However, the URL that is loaded responds with a JSON string instead of an HTML document. JSON is used by many APIs as the preferred format to pass data around on the web. In order to use this response, the raw data must be converted to a useful data structure. In this case, a dictionary will do. If you haven't seen or worked with JSON before, it's a good idea to take a step back and read up on the JSON data format because this chapter will continue under the assumption that you are at least somewhat familiar with JSON.</p><p> </p></div></div>