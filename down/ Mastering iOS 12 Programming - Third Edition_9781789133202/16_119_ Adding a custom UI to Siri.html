<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch16lvl1sec112"></a>Adding a custom UI to Siri</h2></div></div><hr /></div><p>When your user interacts with Siri, they aren't <span>always</span><a id="id325333110" class="indexterm"></a> looking at their device. But <span>when</span><a id="id325356856" class="indexterm"></a> they are, it's desirable that the experience a user has when using your app through Siri looks and feels a lot like when they're directly interacting with your app. One of the tools to achieve this is using custom vocabularies. You can use a vocabulary to map user- and app-specific terms to Siri's vocabulary, as you have seen in the previous section.</p><p>Another way we can customize the Siri experience is through an <strong class="userinput"><code>Intents UI Extension</code></strong>. Whenever you add an <strong class="userinput"><code>Intents Extension</code></strong> to your project, Xcode asks you if you also want to add a corresponding UI extension. If you select this checkbox, you don't have to do anything to add the UI extension, since it's already there. However, if you didn't check the checkbox, you should add a new <strong class="userinput"><code>Intents UI Extension</code></strong> by clicking the <span class="strong"><strong>+</strong></span> icon in the list of targets for your project, just as you did when you added the <strong class="userinput"><code>Intents Extension</code></strong> before.</p><p>A custom user interface for an intent works a lot like other UI extensions. When you create the extension, Xcode creates a storyboard, a view controller, and a <code class="literal">.plist</code> file. The <code class="literal">.plist</code> file is expected to specify all of the intents that this UI extension can handle. In the case of <strong class="userinput"><code>Hairdressers</code></strong>, this is just a single intent; <code class="literal">INSendMessageIntent</code>. Make sure to update the <code class="literal">Info.plist</code> for the UI extension accordingly.</p><p>If you intend to support multiple intents, it's often a good idea to split your extension up into various extensions, while grouping intents together based on how similar they are. This will make it easier to maintain your code in the long run, and it makes it easier to reason about the way your code and extensions work.</p><p>If you open the <code class="literal">IntentViewController</code> file, you'll find a method named <code class="literal">configureView(for:of:interactiveBehavior:context:completion:)</code>. This method is used to configure the UI extension's view, and you can remove it for now because you'll implement a slightly simpler version of this method later.</p><p>Since the UI extension is used for a messaging feature, it would be nice to show the Hairdressers that will end up receiving the message, and the message that they will receive. Add the following two <code class="literal">@IBOutlet</code> properties to the <code class="literal">IntentViewController</code>:</p><pre class="programlisting">@IBOutlet var recipientsLabel: UILabel!  
@IBOutlet var messageContentLabel: UILabel!</pre><p>After adding the outlets, add the following method to the <code class="literal">IntentViewController</code>:</p><pre class="programlisting">func configure(with interaction: INInteraction, context: INUIHostedViewContext, completion: ((CGSize) -&gt; Void)) {

  guard let messageIntent = interaction.intent as? INSendMessageIntent,
    let recipients = messageIntent.recipients
    else { return }


  recipientsLabel.text = recipients.map { $0.displayName }.joined(separator: ", ")
  messageContentLabel.text = messageIntent.content


  let viewWidth = extensionContext?.hostedViewMaximumAllowedSize.width ?? 0
  completion(CGSize(width: viewWidth, height: 100))
}</pre><p>This implementation verifies that a message intent with recipients exists, and then populates the labels you just added accordingly. The code also determines at which width the UI should be displayed. Finally, the completion handler is called with the desired size at which Siri should display the <span>custom</span><a id="id325604087" class="indexterm"></a> UI. A value of 100 should be plenty of room to accommodate the message for now.</p><p>Next, open the <span>storyboard</span><a id="id325604098" class="indexterm"></a> file for the UI extension and add two labels. Lay them out as shown in the following screenshot. Don't forget to connect the outlets for these labels as well. You can set the text style for the message label to <strong class="userinput"><code>Body</code></strong>, and the recipients label can be set to <strong class="userinput"><code>Caption</code></strong> style:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/3feffc32-e5c5-4269-86c0-59e1e4210125.png" /></div><p>After setting up the UI, run your UI extension instead of the intent extension, and try to send a message to one of the Hairdressers again.</p><p>You should see something that looks like the following UI: </p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/f70ca6c8-e7ba-4e67-a8a6-67bf214a29be.png" /></div><p>The cool part is that the <span>custom</span><a id="id325606036" class="indexterm"></a> UI appears. There is one problem though. The message transcript is now shown twice: Once by the extension, and once through Siri itself. To prevent this from happening, all you need to do is make our view controller conform to <code class="literal">INUIHostedViewSiriProviding</code>. Add this protocol to the declaration of <code class="literal">IntentViewController</code>, and add the following property as well:</p><pre class="programlisting">var displaysMessage = true</pre><p>By doing this, Siri is now aware that you render your own version of the message transcript, so there is no need for Siri to also show the message. Now that you know how to implement a Siri intent and provide a <span>custom</span><a id="id325606057" class="indexterm"></a> UI for it, it's time to take your Siri integration one step further, and have a look at Siri Shortcuts.</p></div>