<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec93"></a>Requesting a user's location</h2></div></div><hr /></div><p>As you can imagine, giving an application access to your <span>exact</span><a id="id325333116" class="indexterm"></a> location is quite a big deal. In the wrong hands, this data could allow people with malicious intentions to know exactly where you are at any given time, and abuse this knowledge in many different ways. For this reason, it's essential that you only request a user's location if you absolutely have to. Simply using it for a small feature, or to make sure a user is in some arbitrary location before they sign up for a service, might not always be a good enough reason to ask for a user's location.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec75"></a>Asking for permission to access location data</h3></div></div></div><p>When you do need access to a user's location, you have to ask <span>permission</span><a id="id325369914" class="indexterm"></a> first. Similar to how you have to add a reason for needing the camera or a user's contacts to the <code class="literal">Info.plist</code> file, you must also provide a reason for requesting location data. In the case of location data, there are two keys you can add to the <code class="literal">Info.plist</code>:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Privacy-Location When In Use Usage Description (<code class="literal">NSLocationWhenInUseUsageDescription</code>)</li><li style="list-style-type: disc">Privacy-Location Always And When In Use Usage Description (<code class="literal">NSLocationAlwaysAndWhenInUseUsageDescription</code>)</li></ul></div><p>When your app asks for permission to use a user's location data, they have the option to only allow your app access to their location when the app is in use, or they can choose to allow your app to access their location all the time, even when the app is in the background. You can also configure the type of access that you want to ask yourself. If you only need the user's location when they are using the app, make sure to configure your permission request properly, so the user isn't asked to provide their location to your app when it's in the background.</p><p>After adding the required keys to the <code class="literal">Info.plist</code> file in the LocationServices app, you will need to write some code to ask the user for permission to use their location. Before doing this, let's quickly examine the sample project's structure and content, so you are aware of what information can be found where.</p><p> </p><p>First, open the <code class="literal">Main.storyboard</code> file in the project. You will find a tab bar controller with two view controllers in it. Throughout this chapter, you will implement the features to populate these view controllers with appropriate data. Next, look at the <code class="literal">AppDelegate</code> implementation. The implementation here follows the Dependency Injection pattern that you have seen used in earlier projects, so there shouldn't be any surprises for you here. Now, go ahead and examine the view controllers. The<code class="literal">GeofenceViewController</code>is the one you will work on first, to make the user's current location appear on the screen.</p><p>You will notice that a lot of code has already been implemented in this view controller. Examine the existing code for a bit, and you'll find that all the code makes calls to empty methods in <code class="literal">LocationHelper.swift</code>. Most of your focus in this chapter will be on implementing the Core Location code required to work with a user's location data, so the UI work has already been set up. As you add code to <code class="literal">LocationHelper</code>, you'll find that the user interface for LocationServices comes to life bit by bit.</p><p>Now that you have a better understanding of how the LocationServices app was set up, let's see what steps are involved in asking the user for permission to use their location. Since this app will eventually track location changes in the background, you should ask the user access to their location even when the app is in the background. To do this, add the following <code class="literal">viewDidAppear(_:)</code>code to <code class="literal">GeofenceViewController</code>:</p><pre class="programlisting">locationHelper.askPermission { [weak self] status in
  if status == .authorizedAlways {
    self?.showCurrentLocation()
  } else {
    // handle the case where you don't always have access
  }
}</pre><p>This is the first view controller the user will see, so asking the <span>user</span><a id="id325609982" class="indexterm"></a> for their location as soon is this view appears is a good idea. If it's not obvious that you will be prompting the user for their location, it's often a good idea to inform the user about why you are going to ask them for location permissions before actually showing the location access dialog. To actually make the permission dialog appear, you will need to add some code to <code class="literal">LocationHelper.swift</code>.</p><p> </p><p>All location service-related requests are performed through an instance of <code class="literal">CLLocationManager</code>. The location manager is responsible for obtaining the user's GPS location, asking for permission to access the user's location, and more. When the location manager receives updates about the user's location, authorization status, or other events, it will notify its delegate. A location manager delegate should conform to the <code class="literal">CLLocationManagerDelegate</code> protocol. Note that the <code class="literal">LocationHelper</code> already conforms to <code class="literal">CLLocationManagerDelegate</code>, and that an instance of <code class="literal">CLLocationManager</code> is already created on this object. All that's left to do is assign the helper as the delegate for the location manager. Add the following line at the end of the <code class="literal">init()</code> method in <code class="literal">LocationHelper</code> to set it as the location manager delegate:</p><pre class="programlisting">locationManager.delegate = self</pre><p>Next, add the following implementation for the <code class="literal">askPermission(_:)</code> method:</p><pre class="programlisting">func askPermission(_ completion: @escaping (CLAuthorizationStatus) -&gt; Void) {
  let authorizationStatus = CLLocationManager.authorizationStatus()
  if authorizationStatus != .notDetermined {
    completion(authorizationStatus)
  } else {
    askPermissionCallback = completion
    locationManager.requestAlwaysAuthorization()
  }
}</pre><p>This implementation checks whether a current authorization status exists. If it does, the completion callback is called with the current status. If the current status has not been determined yet, the location manager is asked to request authorization to access the <span>user</span><a id="id325615330" class="indexterm"></a> location using the <code class="literal">requestAlwaysAuthorization()</code> method. This will prompt the user for their location permissions. The reason you need to have permanent access to a user's location in this app is to ensure you can implement geofencing later in this chapter. Add the following method to the <code class="literal">CLLocationManagerDelegate</code> to retrieve the user's response to the authorization prompt:</p><pre class="programlisting">func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
  askPermissionCallback?(status)
  askPermissionCallback = nil
}</pre><p> </p><p> </p><p> </p><p> </p><p>The preceding code immediately passes the user's response to the stored completion callback that was passed to <code class="literal">askPermission(_:)</code>. After calling the callback, it is set to <code class="literal">nil</code> to avoid accidentally calling it again. At this point, you have done all the work required to request access to a user's location. Let's see how you can retrieve a user's current location next.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec76"></a>Obtaining a user's location</h3></div></div></div><p>Once your app has access to location data, you can use the <span>location</span><a id="id325618084" class="indexterm"></a> manager to begin observing a user's location, the direction in which a user is heading, and more. For now, you will focus on obtaining the user's current location. The <code class="literal">GeofenceViewController</code> already contains a method, called <code class="literal">showCurrentLocation()</code>, that is responsible for asking the location helper for a current location. If you examine this method closely, you'll find that it also asks the location helper for a location name by calling <code class="literal">getLocationName(for:_:)</code> and passing the obtained location to this method. The <code class="literal">showCurrentLocation()</code> method also uses the obtained location to focus a map view on the user's location by calling <code class="literal">setRegion(_:animated:)</code> on the map view.</p><p>Since the view controller is already fully prepared to handle location updates, all you need to do is add the proper implementations for <code class="literal">getLatestLocation(_:)</code> and <code class="literal">getLocationName(for:_:)</code>. Begin by adding the following implementation for <code class="literal">getLatestLocation(_:)</code>:</p><pre class="programlisting">func getLatestLocation(_ completion: @escaping (CLLocation) -&gt; Void) {
  if let location = trackedLocations.last {
    completion(location)
  } else if CLLocationManager.locationServicesEnabled() {
    latestLocationObtainedCallback = completion
    locationManager.startUpdatingLocation()
  }
}</pre><p>The preceding method first checks whether a location has already been obtained. If it has, then the latest obtained location is returned. If there is no existing location, the code checks whether location services are enabled. It's always good practice to check whether the location service you are about to use is actually available. If location services are available, the completion callback is stored in the helper, and the location manager is told to start monitoring the user's location by calling <code class="literal">startUpdatingLocation()</code>.</p><p> </p><p> </p><p>Calling <code class="literal">startUpdateLocation()</code> will make the <span>location</span><a id="id325581029" class="indexterm"></a> observer continuously monitor the user's GPS location, and will send any relevant updates to its delegate by calling <code class="literal">locationManager(_:didUpdateLocations:)</code>. This method will always receive one or more new locations that the manager has obtained, where the latest location will be the last item in the list of obtained locations. Add the following implementation for this method to the <code class="literal">CLLocationManagerDelegate</code> extension of <code class="literal">LocationHelper</code>:</p><pre class="programlisting">func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
  latestLocationObtainedCallback?(locations.last!)
  latestLocationObtainedCallback = nil
  locationManager.stopUpdatingLocation()

  trackedLocations += locations
}</pre><p>The implementation for <code class="literal">locationManager(_:didUpdateLocations:)</code> is fairly straightforward: the latest location is passed to the callback, and the callback is removed to prevent subsequent location updates from triggering the callback unexpectedly. Also, the location manager is told to stop monitoring the user's location by calling <code class="literal">stopUpdatingLocation()</code>. Lastly, the obtained locations are stored for later use.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note43"></a>Note</h3><p>It's always good practice to make the location manager stop monitoring location updates if you won't be needing updates any time soon. Monitoring location updates has a pretty significant impact on battery life, so you shouldn't spend more time tracking a user's location than needed.</p></div><p>Now that you can retrieve the user's location, the last step is to also retrieve the location name, by implementing <code class="literal">getLocationName(for:_:_)</code> in the <span>location</span><a id="id325581074" class="indexterm"></a> helper. Add the following implementation for this method to the location helper:</p><pre class="programlisting">func getLocationName(for location: CLLocation, _ completion: @escaping (String) -&gt; Void) {
  let geocoder = CLGeocoder()
  geocoder.reverseGeocodeLocation(location) { placemarks, error in
    guard error == nil else {
      completion("An error ocurred: \(error?.localizedDescription ?? "Unknown error")")
      return
    }

    completion(placemarks?.first?.name ?? "Unkown location")
  }
}</pre><p>The preceding code uses a <code class="literal">CLGeocoder</code> to find a placemark that corresponds with the user's current location. Note that this feature uses an internet connection, so the name lookup will only work if the user has an internet connection. Regular GPS-related features do not require internet access, so your app can monitor and track a user's location even if they don't have an active internet connection.</p><p>Try running your app now—you should be able to see the user's current location on the map, and the location name, latitude, and longitude should be displayed on the screen as well. Now that you know how to obtain a user's location, let's see how you can efficiently subscribe your app to follow changes in a user's location.</p></div></div>