<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec34"></a>Adding vibrancy to animations</h2></div></div><hr /></div><p>A lot of <span>animations</span><a id="id325333104" class="indexterm"></a> on iOS look bouncy and feel natural. For instance, when an object starts moving in the real world, it rarely does so smoothly. Often, something moves because something else applied an initial force to it, causing it to have a certain momentum. Spring <span>animations</span><a id="id325333112" class="indexterm"></a> help you to apply this sort of real-world momentum to your animations.</p><p>Spring animations are usually configured with an initial speed. This speed is the momentum an object should have when it begins moving. All spring animations require a damping to be set on them. The value of this property specifies how much an object can overflow its target value. A smaller damping will make your animation feel more bouncy because it will float around its end value more drastically.</p><p>The easiest way to explore spring animations is by slightly refactoring the animation you just created for the drawer. Instead of using an <code class="literal">easeOut</code> animation when a user taps the <strong class="userinput"><code>Toggle Drawer</code></strong> button, you can use a spring animation instead. The following code shows the changes you need to make to <code class="literal">setUpAnimation()</code>:</p><pre class="programlisting">func setUpAnimation() {
  guard animator == nil || animator?.isRunning == false
    else { return }

  let spring: UISpringTimingParameters
  if self.isDrawerOpen {
    spring = UISpringTimingParameters(dampingRatio: 0.8, initialVelocity: CGVector(dx: 0, dy: 10))
  } else {
    spring = UISpringTimingParameters(dampingRatio: 0.8, initialVelocity: CGVector(dx: 0, dy: -10))
  }

  animator = UIViewPropertyAnimator(duration: 1, timingParameters: spring)

  animator?.addAnimations { [unowned self] in
    if self.isDrawerOpen {
      self.drawer.transform = CGAffineTransform.identity
    } else {
      self.drawer.transform = CGAffineTransform(translationX: 0, y: -305)
    }
  }

  // ...
}</pre><p>When you implement a spring animation, you use a special initializer for <code class="literal">UIViewPropertyAnimator</code>. Since you can't pass animations to this initializer, you must add them by calling <code class="literal">addAnimations(_:)</code>. Adding spring animations did not require a considerable code change, but try running the app and tapping on the toggle button. The drawer will now feel more realistic because its animation curve is not as static as it was before.</p><p>Play around with the values for the spring damping and the velocity, if you use some extreme values you'll get interesting results. Keep in mind that the damping should be a value between <code class="literal">0</code> and <code class="literal">1</code> and that a value closer to <code class="literal">1</code> will make your animation bounce less.</p><p>The animation that is executed by the pan recognizer doesn't feel great at this point. It's very static and doesn't take into account how fast a user is panning on the drawer. When the user ends their pan gesture, you can set the sprint timing's <code class="literal">initialVelocity</code> based on the actual pan velocity. This will make the animation feel even more realistic because it will now use the actual pan speed as the initial speed for animation:</p><pre class="programlisting">@objc func didPanOnDrawer(recognizer: UIPanGestureRecognizer) {
  // ...
  default:
    drawerPanStart = 0
    let currentVelocity = recognizer.velocity(in: drawer)
    let spring = UISpringTimingParameters(dampingRatio: 0.8, initialVelocity: CGVector(dx: 0, dy: currentVelocity.y))

    animator?.continueAnimation(withTimingParameters: spring, durationFactor: 0)
    let isSwipingDown = currentVelocity.y &gt; 0
    if isSwipingDown == !isDrawerOpen {
      animator?.isReversed = true
    }
  }
}</pre><p> </p><p> </p><p> </p><p> </p><p>As you've just seen, the use of spring <span>animations</span><a id="id325578347" class="indexterm"></a> can benefit your <span>animations</span><a id="id325578420" class="indexterm"></a> and they are not very hard to add to your apps. While they might not always be the best solution, their ease of implementation makes spring animations a worthy candidate to experiment with to determine whether your animation needs a spring.</p><p>While the animation you have just implemented is pretty lifelike and realistic, your animations might need even more realism. The next section covers UIKit Dynamics, which is a special method of animating objects that uses a physics engine and can detect collisions between objects.</p></div>