<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec48"></a>Adding flexibility with generics</h2></div></div><hr /></div><p>Programming with generics is not always easy, but it does make your code extremely flexible. When you use something such as generics, you are always making a trade-off between the <span>simplicity</span><a id="id325333104" class="indexterm"></a> of your program and the <span>flexibility</span><a id="id325333170" class="indexterm"></a> of your code. Sometimes it's worth it to introduce a little bit of complexity to allow your code to be written in ways that were otherwise impossible.</p><p>For instance, consider the <code class="literal">Cow</code> struct you saw before. To specify the generic associated type on the <code class="literal">HerbivoreType</code> protocol, a type alias was added to the <code class="literal">Cow</code> struct. Now imagine that not all cows like to eat grass. Maybe some cows prefer flowers, corn, or something else. You would not be able to express this using the type alias.</p><p>To represent a case where you might want to use a different type of <code class="literal">PlantType</code> for every cow instance, you can add a generic to the <code class="literal">Cow</code> itself. The following snippet shows how you can do this:</p><pre class="programlisting">struct Cow&lt;Plant: PlantType&gt;: HerbivoreType {
  var plantsEaten = [Plant]()
}</pre><p>Between <code class="literal">&lt;</code> and <code class="literal">&gt;</code>, the generic type name is specified as <code class="literal">Plant</code>. This generic is constrained to the <code class="literal">PlantType</code> type. This means that any type that will act as <code class="literal">Plant</code> has to conform to <code class="literal">PlantType</code>. The protocol will see that <code class="literal">Cow</code> has a generic <code class="literal">Plant</code> type now, so there is no need to add a type alias. When you create an instance of <code class="literal">Cow</code>, you can now pass every instance its own <code class="literal">PlantType</code>:</p><pre class="programlisting">let grassCow = Cow&lt;Grass&gt;()
let flowerCow = Cow&lt;Flower&gt;()</pre><p>Applying <span>generics</span><a id="id325604099" class="indexterm"></a> to object instances like this is more common than you might think. An <code class="literal">Array</code> instance uses generics to determine what kind of elements it contains. The following two lines of code are identical in functionality:</p><pre class="programlisting">let strings = [String]()
let strings = Array&lt;String&gt;()</pre><p>The first line uses a convenient syntax to create an array of strings. The second line uses the <code class="literal">Array</code> initializer and explicitly specifies the type of element it will contain.</p><p>Sometimes, you might find yourself writing a function or method that can benefit from a <span>generic</span><a id="id325605893" class="indexterm"></a> argument or return type. An excellent example of a generic function is <code class="literal">map</code>. With <code class="literal">map</code>, you can transform an array of items into an array of different items. You can define your own simple version of <code class="literal">map</code> as follows:</p><pre class="programlisting">func simpleMap&lt;T, U&gt;(_ input: [T], transform: (T) -&gt; U) -&gt; [U] {
  var output = [U]()

  for item in input {
    output.append(transform(item))
  }

  return output
}</pre><p><code class="literal">simpleMap(_:transform:)</code> has two <span>generic</span><a id="id325606048" class="indexterm"></a> types, <code class="literal">T</code> and <code class="literal">U</code>. These names are common placeholders for generics, so they make it clear to anybody reading this code that they are about to deal with generics. In this sample, the function expects an input of <code class="literal">[T]</code>, which you can read as an array of <span class="emphasis"><em>something</em></span>. It also expects a closure that takes an argument, <code class="literal">T</code>, and returns <code class="literal">U</code>. You can interpret this as the closure taking an element out of that array of something, and it transforms it into something else. The function finally returns an array of <code class="literal">[U]</code>, or in other words, an array of <span class="emphasis"><em>something else</em></span>.</p><p>You would use <code class="literal">simpleMap(_:transform:)</code> as follows:</p><pre class="programlisting">let result = simpleMap([1, 2, 3]) { item in
  return item * 2
}

print(result) // [2, 4, 6]</pre><p>Generics are not always easy to understand, and it's okay if they take you a <span>little</span><a id="id325607084" class="indexterm"></a> while to get used to. They are a powerful and complex topic that we could write many more pages about. The best way to get into them is to use them, practice them, and read as much as you can about them. For now, you should have more than enough to think about and play with.</p><p>Note that generics are not limited to structs and functions. You can also add generics to your enums and classes in the same way you add them to a struct.</p></div>