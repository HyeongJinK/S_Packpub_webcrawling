<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec52"></a>Properly separating concerns</h2></div></div><hr /></div><p>Before you can improve your project <span>structure</span><a id="id325333104" class="indexterm"></a> with value types and protocols, it's a good idea to improve upon your structure in general. We haven't really thought about the reuse possibilities of certain aspects of the <span class="strong"><strong>Hello-Contacts</strong></span> app, which results in code that's harder to maintain in the long run. This is especially true for larger projects that are built over an extended period of time.</p><p>If you take a look at the source code for this project in the book's code bundle, you'll find that the project was slightly modified. First, <span>all the</span> project files were put together in sensible groups. Doing so makes it easier for you to navigate your project's files, and it creates a natural place for certain files, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/ab912849-a611-4e14-91b7-4b9df7ec2dcb.png" /></div><p> </p><p>The structure applied in this project is merely a suggestion; if you feel that a different structure would suit you better, go ahead and make the change. The most important part is that you've thought about your project structure and set it up in a way that makes sense to you and helps you navigate your project.</p><p>With this improved folder structure, you may notice that there's a natural separation between certain files. Some files help with transitions, a model file, several view controllers and more. By separating files into groups, you've given yourself an overview of the file types in your project, and each file belongs to a certain group that describes its place in your app. This makes it easier for other developers (and yourself) to browse the code in your project. Now that your project's file <span>structure</span><a id="id325609920" class="indexterm"></a> is solid, let's refactor some code.</p><p>The file we will refactor first is <code class="literal">ViewController.swift</code>. This file contains the code for the contacts overview screen. Currently, this view controller fetches contacts, acts as a delegate and data source for the collection view, and takes care of the animations that play when a user taps on a cell.</p><p>You may consider this to be okay. Ideally, any given class shouldn't be responsible for that many things at once. What if you need to create a second kind of overview page; how can you reuse the code that fetches contacts? What if you want to add the bouncing cell image animation to another image? These are two scenarios that are pretty likely to happen at some point in the future. Let's extract the contact-fetching code and the animation code and place them in their own structs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec30"></a>Extracting the contact-fetching code</h3></div></div></div><p>Start off by creating a new Swift file called <code class="literal">ContactFetchHelper.swift</code>. After <span>creating</span><a id="id325609980" class="indexterm"></a> the file, add it to a new folder called <code class="literal">Helpers</code>. First, you will extract all the contact-fetching code to the <code class="literal">ContactFetchHelper</code> struct. Then, you'll refactor <code class="literal">ViewController.swift</code> by replacing all contact-fetching code, so it uses the new <code class="literal">ContactFetchHelper</code>. The following code shows the implementation for <code class="literal">ContactFetchHelper</code>:</p><pre class="programlisting">import Contacts

struct ContactFetchHelper {
  // 1
  typealias ContactFetchCallback = ([Contact]) -&gt; Void

  let store = CNContactStore()

  // 2
  func fetch(withCallback callback: @escaping
    ContactFetchCallback) {
    if CNContactStore.authorizationStatus(for: .contacts) == .notDetermined {
      store.requestAccess(for: .contacts, completionHandler:
        {authorized, error in
          if authorized {
            self.retrieve(withCallback: callback)
          }
      })
    } else if CNContactStore.authorizationStatus(for: .contacts) == .authorized {
      retrieve(withCallback: callback)
    }
  }

  // 3
  private func retrieve(withCallback callback: ContactFetchCallback) {
    let containerId = store.defaultContainerIdentifier()

    let keysToFetch =
      [CNContactGivenNameKey as CNKeyDescriptor,
       CNContactFamilyNameKey as CNKeyDescriptor,
       CNContactImageDataKey as CNKeyDescriptor,
       CNContactImageDataAvailableKey as CNKeyDescriptor,
       CNContactEmailAddressesKey as CNKeyDescriptor,
       CNContactPhoneNumbersKey as CNKeyDescriptor,
       CNContactPostalAddressesKey as CNKeyDescriptor]

    let predicate = CNContact.predicateForContactsInContainer(withIdentifier: containerId)

    guard let retrievedContacts = try? store.unifiedContacts(matching:
      predicate, keysToFetch: keysToFetch) else {
        // call back with an empty array if we fail to retrieve contacts
        callback([])
        return
    }

    let contacts: [Contact] = retrievedContacts.map { contact in
      return Contact(contact: contact)
    }

    callback(contacts)
  }
}</pre><p>This simple struct now contains all the required logic to fetch contacts. Let's go through some of the most interesting parts of code in <span>the <code class="literal">ContactsFetchHelper</code></span> struct.</p><p>The first highlight points to an alias, named <code class="literal">ContactFetchCallback</code>, for a closure that receives an array of <code class="literal">Contact</code> instances and returns nothing. This is the closure that is passed to the <code class="literal">fetch(withCallback:)</code> method, and it's called after the fetch is performed.</p><p>The <code class="literal">fetch(withCallback :)</code> method is the method that should be called whenever you want to fetch contacts. The only argument it takes is a closure that will be called when the contacts are fetched. The fetch method performs the same authorization check that was in the view controller's <code class="literal">viewDidLoad</code> method before.</p><p>The third point of interest is a private method, called <code class="literal">retrieve(withCallback:)</code>, that retrieves the contacts. The <code class="literal">fetch(withCallback:)</code> method calls this method and passes it the <code class="literal">callback</code> that it received. Once <code class="literal">retrieve(withCallback:)</code> has retrieved the contacts, it calls the <code class="literal">callback</code> with the array of fetched contacts.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"></a>Note</h3><p>The <code class="literal">ContactFetchCallback</code> that <code class="literal">fetch(withCallback:)</code> receives is marked as <code class="literal">@escaping</code>. This keyword indicates that the supplied closure will escape the scope it was passed to. In this example, <code class="literal">callback</code> is passed to the scope of <code class="literal">fetch(withCallback:)</code>, which in turn passes this closure to the scope of <code class="literal">retrieve(withCallback:)</code>.</p></div><p>In <code class="literal">ViewController.swift</code>, all you need to do is use the following code to retrieve contacts:</p><pre class="programlisting">let contactFetcher = ContactFetchHelper()   
contactFetcher.fetch { [weak self] contacts in   
    self?.contacts = contacts   
    self?.collectionView.reloadData()   
} </pre><p>You can delete the <code class="literal">retrieveContacts</code> method entirely, and the preceding snippet replaces the code that checked for permissions in <code class="literal">viewDidLoad</code>. Also, because the <code class="literal">Contacts</code> framework is not used directly anymore, you can remove its <code class="literal">import</code> at the top of the file. You have now successfully extracted the contact-fetching code into a struct, and you're using a <code class="literal">typealias</code> to make your code more readable. This is already a big win for maintainability and reusability. Now, let's extract the bounce animation code as well.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec31"></a>Extracting the bounce animation</h3></div></div></div><p>The process of extracting the bounce animation is a <span>little</span><a id="id325618116" class="indexterm"></a> more complicated than the process of extracting the contact-fetching code. The purpose of extracting this bounce animation is to make it so that it becomes possible to make other objects in other sections of the app bounce, just like the contact cell's image does.</p><p>To figure out what the bounce animation helper should do and how it should work, it's a great idea to think about how you want to use this helper at the call site. <span>The</span><span class="strong"><strong>call site</strong></span> is defined as the place where you plan to use your helper. So, in this case, the call site is considered the <code class="literal">ViewController</code>. Let's write some pseudocode to try to determine what you will program later:</p><pre class="programlisting">let onBounceComplete = { [weak self] finished in   
    self?.performSegue(withIdentifier: "contactDetailSegue", sender: self)   
}   

let bounce = BounceAnimationHelper(targetView: cell.contactImage, onComplete: onBounceComplete) </pre><p>This looks pretty good already, and in reality, it's very close to the actual code you could end up with later. All you really want to do at the call site is configure a bounce animation by passing it a view to perform the bounce on and to have some control over what should happen once the animation is completed. The following two points should be considered before writing the <code class="literal">BounceAnimationHelper</code> implementation:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">It's not possible to set the bounce duration – is this acceptable?</li><li style="list-style-type: disc">You have no control over the start time of the animation, so manually starting it would be nice.</li></ul></div><p>To address the first point, you could implement two initializers: one that uses a default duration and another where the users of the helper can specify their own duration. Doing this makes use of Swift's <span>powerful method overloading</span>, which enables developers to write multiple initializers for the same object. This also allows developers to write methods with the same name but a different signature due to different parameter names.</p><p>The second point of concern is valid, and the helper should be written in a way that requires manually starting the animation, so it feels more like <code class="literal">UIViewPropertyAnimator</code>. Theoretically speaking, you could add a <code class="literal">Bool</code> value to the initializer that enables users of the helper to choose whether the animation should start automatically. This would make it less similar to <code class="literal">UIViewPropertyAnimator</code> so in this case manually calling a method to start the animation is preferred. The calling code you should end up with is shown in the following code snippet. You can go ahead and add it to the <code class="literal">ViewController.swift</code> file in place of the current bounce animation. You'll implement the helper shortly:</p><pre class="programlisting">let onBounceComplete: BounceAnimationHelper.BounceAnimationComplete = { [<span>unowned</span> self] position in   
    self.performSegue(withIdentifier: "detailViewSegue", sender: self)  
}   

let bounce = BounceAnimationHelper(targetView: cell.contactImage, onComplete: onBounceComplete)   
bounce.startAnimation() </pre><p>Note that the preceding snippet explicitly defines the type of the <code class="literal">onBounceComplete</code> callback. This type will be a <code class="literal">typealias</code> on the helper you're about to implement.</p><p>Now that the call site is all finished, let's <span>take</span><a id="id325580813" class="indexterm"></a> a look at the implementation of <code class="literal">BounceAnimationHelper</code>. Create a new Swift file called <span class="strong"><strong>BounceAnimationHelper</strong></span> and add it to the <code class="literal">Helpers</code> folder. Start by defining a struct named <code class="literal">BounceAnimationHelper</code> in the corresponding Swift file. Next, define a <code class="literal">typealias</code> for the completion handler and specify the properties we need in the struct, as follows:</p><pre class="programlisting">import UIKit

struct BounceAnimationHelper {
  typealias BounceAnimationComplete = (UIViewAnimatingPosition) -&gt; Void

  let animator: UIViewPropertyAnimator
} </pre><p>The initial implementation for the struct is pretty bare. A <code class="literal">typealias</code> is defined that passes a <code class="literal">UIViewAnimatingPosition</code> into a closure that has no return value. The struct also holds onto a <code class="literal">UIViewPropertyAnimator</code>, so its <code class="literal">startAnimation()</code> can be called whenever the helper's <code class="literal">startAnimation()</code> is called.</p><p>Next, let's add the two initializers that were described <span>earlier</span>. One with a default duration for the bounce effect and one with a custom duration. The second initializer is empty for now; you will implement it in a minute:</p><pre class="programlisting">init(targetView: UIView, onComplete: @escaping BounceAnimationComplete) {
  self.init(targetView: targetView, onComplete: onComplete, duration: 0.4)
}

init(targetView: UIView, onComplete: @escaping BounceAnimationComplete, duration: TimeInterval) {

}</pre><p>These two initializers provide the APIs you were looking for. The first initializer calls out to the second with a default <code class="literal">duration</code> value of <code class="literal">0.4</code>. Doing this allows you to write the animation in a single initializer. It is common to have multiple initializers on an object that all trickle down to a single initializer; the designated initializer. The designated initializer is responsible for setting up and configuring all properties of an object. The following code shows the implementation for the designated initializer. It replaces the empty initializer you saw in the previous snippet:</p><pre class="programlisting">init(targetView: UIView, onComplete: @escaping BounceAnimationComplete, duration: TimeInterval) {
  let downAnimationTiming = UISpringTimingParameters(dampingRatio: 0.9, initialVelocity: CGVector(dx: 20, dy: 0))

  // 1
  self.animator = UIViewPropertyAnimator(duration: duration/2, timingParameters: downAnimationTiming)

  self.animator.addAnimations {
    // 2
    targetView.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)
  }

  self.animator.addCompletion { position in
    let upAnimationTiming = UISpringTimingParameters(dampingRatio: 0.3, initialVelocity:CGVector(dx: 20, dy: 0))

    let upAnimator = UIViewPropertyAnimator(duration: duration/2, timingParameters: upAnimationTiming)

    upAnimator.addAnimations {
      targetView.transform = CGAffineTransform.identity
    }

    // 2
    upAnimator.addCompletion(onComplete)

    upAnimator.startAnimation()
  }
}</pre><p>This snippet is very similar to the old animation; the main differences are <span>highlighted</span> with comments. Instead of hardcoding a duration, half of the total duration of the bounce animation is used for the downward motion, and the other half is for the upward motion. Also, instead of using the cell's image directly, the specified <code class="literal">targetView</code> is used as the animation target.</p><p>Finally, instead of passing an inline <code class="literal">callback</code> to the <code class="literal">upAnimator</code> closure's completion, the <code class="literal">onComplete</code> closure that was passed to the initializer is passed to <code class="literal">upAnimator</code>. Note that the down animation isn't started in the initializer; this should be implemented in a separate method:</p><pre class="programlisting">func startAnimation() {   
  animator.startAnimation()   
} </pre><p>Add the preceding method to <code class="literal">BounceAnimationHelper</code> and run your app. The contact images should bounce just like they did before, except the animation is reusable now and the code in <code class="literal">ViewController.swift</code> looks a lot cleaner.</p><p>With the cleaned-up <code class="literal">ViewController</code> in place, let's see where <span class="strong"><strong>Hello-Contacts</strong></span> could benefit from protocols.</p></div></div>