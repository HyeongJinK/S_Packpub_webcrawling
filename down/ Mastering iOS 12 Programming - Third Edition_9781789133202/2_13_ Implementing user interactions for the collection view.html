<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec20"></a>Implementing user interactions for the collection view</h2></div></div><hr /></div><p>In the <span>previous</span><a id="id325337165" class="indexterm"></a> chapter, you saw how to implement several <span>interactions</span><a id="id325337174" class="indexterm"></a> with a table view by implementing several of its delegate methods. Any time the user interacts with a cell, the table view calls a delegate method to see what exactly should happen as a response to this interaction. Collection views have incredibly similar capabilities, except for a few details. For instance, implementing reordering on a collection view requires a little bit more work than it does for a table view, as you will see shortly. Also, collection view cells cannot be swiped on to reveal actions to, for instance, delete a cell like you can with a table view cell. Similar functionality can be added to collection views though, and this section will show you exactly how.</p><p>You will learn how to implement the following interactions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Cell selection</li><li style="list-style-type: disc">Cell deletion</li><li style="list-style-type: disc">Cell reordering</li></ul></div><p>Cell selection is the simplest feature to implement. The delegate method for this is called when the user taps on a cell. This is the first interaction you will learn about.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec12"></a>Enabling cell selection for your collection view</h3></div></div></div><p>Implementing cell <span>selection</span><a id="id325337285" class="indexterm"></a> for a collection view is almost identical to implementing it on a table view. With the knowledge you have gained in the previous chapter, you should be able to implement basic cell <span>selection</span><a id="id325337397" class="indexterm"></a> on your own. To keep this section interesting, you won't implement the same alert as you did in the previous chapter. Because users like to see some feedback when they tap something that they can interact with, it's a great idea to add a little animation to your collection view cells to make them bounce a little bit when they are tapped.</p><p>Add the following <code class="literal">UICollectionViewDelegate</code> extension to <code class="literal">ViewController.swift</code>. Don't forget to set your view controller as the delegate for your collection view in <code class="literal">viewDidLoad()</code>:</p><pre class="programlisting">extension ViewController: UICollectionViewDelegate {
  func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
    guard let cell = collectionView.cellForItem(at: indexPath) as? ContactCollectionViewCell
      else { return }

    UIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseOut], animations: {
      cell.contactImage.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)
    }, completion: { _ in
      UIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseIn], animations: {
        cell.contactImage.transform = .identity
      }, completion: nil)
    })
  }
}</pre><p>This snippet implements a simple animation using <code class="literal">UIView.animate</code>. In <a class="ulink" href="" target="_blank">Chapter 4, Immersing your users with animation</a>, you will learn more about animations, and you'll see other, more powerful ways to enable rich interactions to your app.</p><p>Note that the collection view is asked for the tapped cell using an index path. Since this method returns a <code class="literal">UICollectionViewCell?</code> <span>object</span>, you need to make sure that a cell was found and you must also cast it to a <code class="literal">ContactCollectionViewCell</code> <span>object</span> to access the contact image. If no cell exists at the requested index path or if the obtained cell is not a <code class="literal">ContactCollectionViewCell</code> <span>object</span>, the method is aborted.</p><p> </p><p>If the cell is retrieved successfully, the animation is performed. The <code class="literal">animate</code> method takes several parameters that you will learn more about later. <a class="ulink" href="" target="_blank">Chapter 4, Immersing your users with animation</a> covers animation in depth, and you will be up to speed with what exactly is going on in this bounce animation in no time. For now, you might want to go ahead and run the app to see your bounce animation in action. If your animation doesn't work, double-check that you have set <code class="literal">ViewController</code> as the collection view's delegate.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec13"></a>Allowing users to delete cells</h3></div></div></div><p>Any good contacts app enables users to <span>remove</span><a id="id325336824" class="indexterm"></a> contacts. The previous version of <span class="strong"><strong>Hello-Contacts</strong></span> used a swipe gesture on a table view cell to delete a cell. Swiping a cell made a button appear that the user could tap and the corresponding <code class="literal">UITableViewDelegate</code> method was called.</p><p>Unfortunately, <code class="literal">UICollectionViewDelegate</code> does not specify a similar delegate method for deleting cells. This means that you'll need to do a little more work to implement cell deletion for a collection view. A very simple implementation would be to have the user long-press on a cell, ask them whether they want to delete the contact, and reload the collection view if needed. This would work but the deleted contact would quickly disappear, and the whole thing would look quite choppy.</p><p>Luckily, <code class="literal">UICollectionView</code> defines several methods that you can use to update the collection view's contents in a very nice way. For instance, when you delete a cell from the collection view, you can have the remaining cells animate to their new positions. This looks way better than simply reloading the entire collection view without an animation. Good iOS developers will always make sure that they go the extra mile to find a nice, smooth way to transition between interface states. So animating cells when deleting one is a great thing to have.</p><p>If you look at Apple's documentation on <code class="literal">UICollectionView</code>, you'll find that there is a lot of information available about collection views. If you scroll all the way down to the <span class="strong"><strong><strong class="userinput"><code>Symbols</code></strong></strong></span> section, there is a subsection named <span class="strong"><strong><strong class="userinput"><code>Inserting, Moving and Deleting</code></strong><strong class="userinput"><code><strong class="userinput"><code>item</code></strong>s</code></strong></strong></span>. Perfect, this is precisely the kind of information you need to implement cell deletion. More specifically, the <code class="literal">deleteItems(_:)</code> method looks like it's exactly what you need to get the job done.</p><p>The requirements for the cell <span>deletion</span><a id="id325336880" class="indexterm"></a> feature are the following:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The user long-presses on a cell.</li><li>An action sheet appears to verify whether the user wants to delete this cell.</li><li>If the user confirms the deletion, the cell is removed, and the layout animates to its new state. The contact is also removed from the contacts array.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note11"></a>Note</h3><p>To detect certain user interactions such as double-tapping, swiping, pinching, and long-pressing, you make use of gesture recognizers. A gesture recognizer is a special object provided by <code class="literal">UIKit</code> that can detect certain gestures. When such a gesture occurs, it calls a selector (method) on a target object. This method can then perform a specific task in response to the gesture.</p></div><p>To keep things simple, you should add a gesture recognizer to the collection view as a whole. Adding the gesture recognizer to the whole collection view rather than its cells is a lot simpler because you can reuse a single recognizer, and figuring out information about the tapped cell and responding to the long-press is easier to do from the view controller than the tapped cell itself.</p><p>In a moment, you'll see how to find the tapped cell in the collection view. First, set up the recognizer by adding the following lines to <code class="literal">viewDidLoad()</code> in <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">let longPressRecognizer = UILongPressGestureRecognizer(target: self, action: #selector(self.userDidLongPress(_:)))
collectionView.addGestureRecognizer(longPressRecognizer)</pre><p>The first line sets up the long-press gesture recognizer. The target given to the gesture recognizer is <code class="literal">self</code>. This means that the current instance of <code class="literal">ViewController</code> is used to call the action on. The action is the second argument for the gesture recognizer. The selector passed to it refers to the method that is called when the user performs the gesture.</p><p>The second line adds the <span>gesture</span><a id="id325336935" class="indexterm"></a> recognizer to the collection view. This means that the gesture recognizer will only detect long-presses that occur within the collection view. When a long-press occurs on the collection view, the gesture recognizer will inform the <code class="literal">ViewController</code> of this event by calling <code class="literal">userDidLongPress(_:)</code> on it.</p><p>Now that your gesture recognizer is set up and you know a bit about how it works, add the following implementation of <code class="literal">userDidLongPress(_:)</code> to <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">@objc func userDidLongPress(_ gestureRecognizer: UILongPressGestureRecognizer) {
  // 1
  let tappedPoint = gestureRecognizer.location(in: collectionView)
  guard let indexPath = collectionView.indexPathForItem(at: tappedPoint),
    let tappedCell = collectionView.cellForItem(at: indexPath)
    else { return }

  // 2
  let confirmationDialog = UIAlertController(title: "Delete contact?", message: "Are you sure you want to delete this contact?", preferredStyle: .actionSheet)

  let deleteAction = UIAlertAction(title: "Yes", style: .destructive, handler: { [weak self] _ in
    // 3
    self?.contacts.remove(at: indexPath.row)
    self?.collectionView.deleteItems(at: [indexPath])
  })

  let cancelAction = UIAlertAction(title: "No", style: .default, handler: nil)

  confirmationDialog.addAction(deleteAction)
  confirmationDialog.addAction(cancelAction)

  // 4
  if let popOver = confirmationDialog.popoverPresentationController {
    popOver.sourceView = tappedCell
  }

  present(confirmationDialog, animated: true, completion: nil)
}</pre><p>Note that this method is prefixed with <code class="literal">@objc</code>. This is required because selectors are a dynamic feature that originated in Objective-C. The <code class="literal">userDidLongPress(_:)</code> method must be exposed to the Objective-C runtime by prefixing it with <code class="literal">@objc</code>.</p><p>The first step in the implementation of this method is to obtain some information about the cell that was tapped. By taking the location at which the long-press occurred inside of the collection view, it is possible to determine the index path that corresponds with this long press. The index path can then be used to obtain a reference to the cell that the user was long-pressing on. Note that the <span>user</span><a id="id325336978" class="indexterm"></a> can also long-press outside of a cell. If this happens, the <code class="literal">guard</code> will cause the method to return early because there will be no index path that corresponds to the long-press location. If everything is fine, the code continues to the second step in this method.</p><p>To display an action sheet to the user, an instance of <code class="literal">UIAlertController</code> is created. You have already seen this object in action in the previous chapter when it was used to show an alert when the user tapped on a table view cell. The main difference between the alert implementation and this implementation is <code class="literal">preferredStyle</code>. Since this alert should show as an action sheet, the <code class="literal">.actionSheet</code> style is passed as the preferred style. This style will make an action sheet pop up from the bottom of the screen.</p><p>In the delete action for this action sheet, the contact is removed from the contacts array that is used as a data source. After updating the data source, the cell is removed from the collection view using <code class="literal">deleteItems(at:)</code>. When you update the items in a collection view, it is imperative to make sure that you update the data source first. If you don't do this, the app is likely to crash due to internal inconsistency exceptions. To see this crash occur, reverse the order of commands in the delete action.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"></a>Note</h3><p>Whenever you update a collection view in a way that moves or deletes its contacts, <span class="emphasis"><em>always</em></span> make sure to update the underlying data source <span class="emphasis"><em>first</em></span>. Not doing this will crash your app with an internal inconsistency error.</p></div><p>The fourth and last step before presenting the action sheet is some defensive programming. Larger screens, such as an iPad screen, display action sheets as popover views instead of action sheets. You can detect whether an action sheet will be shown as a popover by checking the <code class="literal">popoverPresentationController</code> <span>object</span> on the alert controller instance you have created. If a <code class="literal">popoverPresentationController</code> <span>object</span> exists, the action sheet will be presented as a popover and requires a <code class="literal">sourceView</code> <span>object</span> to be set. Not setting the <code class="literal">sourceView</code> <span>object</span> on a popover crashes your app, so it's better to provide a <code class="literal">sourceView</code> <span>object</span> than have your app crash when <span>something</span><a id="id325337783" class="indexterm"></a> unexpected happens.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note13"></a>Note</h3><p>When you display an action sheet, make sure to check whether a <code class="literal">popoverPresentationController</code> <span>object</span> exists and if it does, make sure to set a <code class="literal">sourceView</code> or <code class="literal">sourceRect</code> <span>object</span>. Devices with larger screens present action sheets as popovers and not setting a source for the popover crashes your app.</p></div><p>This wraps up implementing cell deletion for the collection view. You can try long-pressing on a contact cell now to see your action sheet appear. Deleting a contact should nicely animate the update. Even though it took a little bit more effort to implement cell deletion for collection view than it did for table view, it wasn't too bad. Next up is cell reordering.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec11"></a>Reordering cells in a collection view</h4></div></div></div><p>Since collection views don't have the same <span>awesome</span><a id="id325337830" class="indexterm"></a> reordering API that table <span>views</span><a id="id325337840" class="indexterm"></a> have, you'll need to do a little bit of extra work again to get this to work. Doing extra work doesn't mean that implementing reordering is extremely complex, quite the opposite. There are some nice delegate methods available that aid greatly in implementing reordering for your collection view.</p><p>It will take a couple of steps to implement reordering for your collection view. Apple's documentation for <code class="literal">UICollectionView</code> lists several methods that relate to collection view reordering. Every method has its place in the reorder interaction, and you are expected to call each one at the right time on the collection view. Two methods from this list are of special interest:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">endInteractiveMovement()</code></li><li style="list-style-type: disc"><code class="literal">beginInteractiveMovementForItem(at:)</code></li></ul></div><p>These two methods are interesting because when you call these on your collection view, the collection view will then call methods on its data source. When you end the interactive movement, the data source is asked to update its underlying dataset by moving an item from its old index path to a new index path. When you call <code class="literal">beginInteractiveMovementForItem(at:)</code>, the data source is asked whether the currently selected item is allowed to be reordered.</p><p>Collection views do not keep track of moving cells around on its own; you must implement this yourself. You can do this by adding a pan gesture recognizer but, coincidentally, the long-press gesture recognizer can also track movements the user makes with their finger.</p><p>To reuse the existing long-press gesture recognizer, you will need to refactor it a little bit. To differentiate between wanting to delete or move a cell, an edit button should be added to the collection view. The user can then tap this button to toggle between edit mode and normal mode. When the collection view is in edit mode, it allows cell reordering and otherwise it allows users to delete items.</p><p>To implement reordering, you will perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Refactor the long-press handler to differentiate between reordering and deleting cells.</li><li>Implement the sequence of method calls for cell reordering based on the gesture recognizer's state.</li><li>Implement the data source methods that allow cell reordering.</li><li>Add the edit button to the navigation bar.</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec12"></a>Refactoring the long-press handler</h4></div></div></div><p>Since the existing long-press handler will now have two <span>different</span><a id="id325337895" class="indexterm"></a> actions depending on the view controller's <code class="literal">isEditing</code> state, it's a wise idea to split the long-press handler into several methods that will be called depending on the desired action. The handler itself will still ensure that a valid cell and index path exist. But after that, it will forward to another method to perform further actions. Update your code as shown to refactor the long-press handler:</p><pre class="programlisting">@objc func userDidLongPress(_ gestureRecognizer: UILongPressGestureRecognizer) {
  let tappedPoint = gestureRecognizer.location(in: collectionView)
  guard let indexPath = collectionView.indexPathForItem(at: tappedPoint),
    let tappedCell = collectionView.cellForItem(at: indexPath)
    else { return }

  if isEditing {
    beginReorderingForCell(tappedCell, atIndexPath: indexPath, gestureRecognizer: gestureRecognizer)
  } else {
    deleteContactForCell(tappedCell, atIndexPath: indexPath)
  }
}

func beginReorderingForCell(_ cell: UICollectionViewCell, atIndexPath indexPath: IndexPath, gestureRecognizer: UILongPressGestureRecognizer) {

}

func deleteContactForCell(_ tappedCell: UICollectionViewCell, atIndexPath indexPath: IndexPath) {
 // The existing cell deletion code goes here
}</pre><p>First, the <code class="literal">isEditing</code> property on the view controller is used to determine what should happen when the user long-presses. If this property is <code class="literal">true</code>, <code class="literal">beginReorderingForCell(_:atIndexPath:gestureRecognizer:)</code> is called. You will implement this method later to support reordering. If <code class="literal">isEditing</code> is <code class="literal">false</code>, <code class="literal">deleteContactForCell(_:atIndexPath:)</code> is called to perform the delete action you have already implemented.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec13"></a>Implementing the reordering method calls</h4></div></div></div><p>The second step to <span>implement</span><a id="id325337978" class="indexterm"></a> cell reordering is to call the correct <code class="literal">UICollectionView</code> methods at the right times. To do so, the long-press gesture's state is tracked and used to inform the collection view about the current state of the reorder life cycle it should be in. Add the following implementation for <code class="literal">beginReorderingForCell(_:atIndexPath:gestureRecognizer:)</code>:</p><pre class="programlisting">func beginReorderingForCell(_ cell: UICollectionViewCell, atIndexPath indexPath: IndexPath, gestureRecognizer: UILongPressGestureRecognizer) {
  switch gestureRecognizer.state {
  case .began:
    collectionView.beginInteractiveMovementForItem(at: indexPath)
    UIView.animate(withDuration: 0.2, delay: 0, options: [.curveEaseOut], animations: {
      cell.transform = CGAffineTransform(scaleX: 1.1, y: 1.1)
    }, completion: nil)
  case .changed:
    let position = gestureRecognizer.location(in: collectionView)
    collectionView.updateInteractiveMovementTargetPosition(position)
  case .ended:
    collectionView.endInteractiveMovement()
  default:
    collectionView.endInteractiveMovement()
  }
}</pre><p>You can use a gesture recognizer's <code class="literal">state</code> property to find out more about the state it is in and take action based on this state. In this case, when the gesture begins, the collection view should enable its interactive movement mode for the pressed index path. To inform the user that the cell is being dragged, it is also made slightly larger using an animation.</p><p>When the recognizer updates, and it's in the <code class="literal">changed</code> state, the collection view should update accordingly. The collection view is informed about the position of the user's finger so it can update the visible cells to make room for the cell that is now hovering at a new location.</p><p>If the gesture is <code class="literal">ended</code>, or in another state, the interactive movement is ended. This means that the collection view will ask the data source to update its underlying data and the interface is animated to its new state. Since the collection view communicates with its data source for cell reordering, the next logical step is to update the data source, so it allows items to be reordered, and to make it persist the changes made by the user into the underlying data storage.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec14"></a>Implementing the data source methods</h4></div></div></div><p>To support cell reordering, you must <span>implement</span><a id="id325338021" class="indexterm"></a> two <code class="literal">UICollectionViewDataSource</code> methods. The first method is <code class="literal">collectionView(_:moveItemAt:)</code>. This method is called to determine whether the currently selected item can be moved around. The second method you must implement is <code class="literal">collectionView(_:moveItemAt:to:)</code>. This method is called to tell the data source that it must commit the changes made by the user to the underlying data store. Let's jump straight into the implementation code. The following methods should be added to your <code class="literal">UICollectionViewDataSource</code> extension in <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">func collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: IndexPath) -&gt; Bool {
  return true
}

func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
  let movedContact = contacts.remove(at: sourceIndexPath.row)
  contacts.insert(movedContact, at: destinationIndexPath.row)
}</pre><p>The first method always returns true because every item in the collection view can be reordered. The second method moves the reordered contact from its old position in the dataset to the new position. This is very similar to what you have done before to implement table view reordering. The last step to enable cell reordering is implementing the edit button in the navigation bar. When the user taps this button, the collection view enters edit mode, and the contacts can be dragged around after long-pressing them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec15"></a>Adding the edit button</h4></div></div></div><p>Adding an edit button to a navigation bar is <span>fairly</span><a id="id325338058" class="indexterm"></a> straightforward. Add the following code to the <code class="literal">viewDidLoad()</code> method of <code class="literal">ViewController</code>:</p><pre class="programlisting">navigationItem.rightBarButtonItem = editButtonItem</pre><p>If you build and run your app now, you can immediately begin dragging contacts around to reorder them. However, it's not really obvious that cells are in a different state after entering edit mode. The home screen on an iPhone does a great job at indicating when it's in edit mode. The icons begin to wiggle so the user knows they can now be moved around freely.</p><p>For now, an animation like that is a little bit too advanced so, for now, the cells will just be given a different background color to indicate that they are now in a different state. Add the following code to <code class="literal">ViewController</code> to update the cell's background color:</p><pre class="programlisting">override func setEditing(_ editing: Bool, animated: Bool) {
  super.setEditing(editing, animated: animated)

  for cell in collectionView.visibleCells {
    UIView.animate(withDuration: 0.2, delay: 0, options: [.curveEaseOut], animations: {
      if editing {
        cell.backgroundColor = UIColor(red: 0.9, green: 0.9, blue: 0.9, alpha: 1)
      } else {
        cell.backgroundColor = .clear
      }
    }, completion: nil)
  }
}</pre><p>This updates all currently visible cells. However, because the collection view proactively keeps some off-screen cells in memory, you need to make sure to update those as well. You can implement <code class="literal">collectionView(_:willDisplay:forItemAt:)</code> to configure a cell right before it becomes visible to the user. This method is great for updating cells that are loaded but haven't become visible yet. Implement the following method on your <code class="literal">UICollectionViewDelegate</code> extension:</p><pre class="programlisting">func collectionView(_ collectionView: UICollectionView, willDisplay cell: UICollectionViewCell, forItemAt indexPath: IndexPath) {
  if isEditing {
    cell.backgroundColor = UIColor(red: 0.9, green: 0.9, blue: 0.9, alpha: 1)
  } else {
    cell.backgroundColor = .clear
  }
}</pre><p>That's it! Try running your app now to see all your hard work come together. Even though not every feature was as simple to implement on a collection view as it was on a table view, they are truly similar and the benefits of being able to create your own custom layout make the collection view one of the most important components to master in iOS.</p></div></div></div>