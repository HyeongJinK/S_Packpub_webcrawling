<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec94"></a>Subscribing to location changes</h2></div></div><hr /></div><p>One way of subscribing to changes in a user's <span>location</span><a id="id325333110" class="indexterm"></a> has already been covered in the previous section of this chapter. When you call <code class="literal">startUpdatingLocation()</code> on a location manager, it will automatically subscribe to the user's location. This method of tracking a user's location is excellent if you need very detailed reporting on a user's location, but usually, you don't need this level of detail. More importantly, using this kind of location tracking for an extended period will drain the user's battery.</p><p>Luckily, there are better ways to listen to location changes. One way is to subscribe to locations that the user visits by calling <code class="literal">startMonitoringVisits()</code>. This method is used if you aren't interested in the user's detailed movement but only want to know whether the user spent an extended period in a particular area. This type of tracking of a user's location is perfect if you need a low-power way to track very rough location changes. This kind of tracking even works well if your app is running in the background, because your app will automatically be woken up or launched if a visit event occurs.</p><p>If your app is relaunched due to a location-related event, then <code class="literal">UIApplication.LaunchOptionsKey.location</code> will be present in the application's launch options dictionary. When it is, you are expected to create an instance of a location manager and assign it a delegate to receive the relevant location update.</p><p> </p><p> </p><p>If the visits monitoring is a bit too inaccurate for your purposes but you don't need continuous location tracking, you can use significant location change tracking. This type of tracking triggers when a user has moved a significant distance over time, providing your app with updates only when the user is truly moving. This is a lot more power efficient than making your app track the user's location even when their current location hasn't changed. Just like visits tracking, significant location changes will wake up your app or even relaunch it when they occur. When an event is delivered to the app like this, you should re-enable the significant location changes monitoring. Let's implement significant location changes in the LocationServices sample app to see exactly how they work .</p><p>If you look at <code class="literal">SignificantChangesViewController</code>, you'll note that the view controller is fully set up to begin monitoring significant location changes. The <code class="literal">monitorSignificantChanges(_:)</code> method, defined on the location helper, takes a callback that's called every time a significant <span>location</span><a id="id325333156" class="indexterm"></a> change occurs. Every time new location data is retrieved, the table view is reloaded to display the latest available data. Since significant location updates can wake the app up with a special key in the app's launch options, let's update <code class="literal">AppDelegate</code> so it can handle this scenario. Add the following code <code class="literal"><span>application(_:didFinishLaunchingWithOptions:)</span></code> right before the return statement:</p><pre class="programlisting">if launchOptions?[UIApplication.LaunchOptionsKey.location] != nil {
  locationHelper.monitorSignificantChanges { _ in
    // continue monitoring
  }
}</pre><p>Since <code class="literal">AppDelegate</code> already has a reference to the location helper, all it needs to do is re-enable significant location changes monitoring. This small change to <code class="literal">AppDelegate</code> is quite powerful because it allows your app to respond to changes in the user's location even when the app is not running. Let's implement the appropriate code in the location helper next.</p><p>Add the following implementation for <code class="literal">monitorSignificantLocationChanges(_:)</code> to <code class="literal">LocationHelper</code>:</p><pre class="programlisting">func monitorSignificantChanges(_ locationHandler: @escaping (CLLocation) -&gt; Void) {
  guard CLLocationManager.significantLocationChangeMonitoringAvailable()
    else { return }

  significantChangeReceivedCallback = locationHandler
  locationManager.startMonitoringSignificantLocationChanges()
  isTrackingSignificantLocationChanges = true
}</pre><p>This method is very similar to the location helper methods you have seen before. When a significant location change is detected, the location manager calls <code class="literal">locationManager(_:didUpdateLocations:)</code> on its delegate. Since this method is already implemented, you should update the implementation as follows:</p><pre class="programlisting">func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
  latestLocationObtainedCallback?(locations.last!)
  latestLocationObtainedCallback = nil

  if isTrackingSignificantLocationChanges == false {
    locationManager.stopUpdatingLocation()
  }

  significantChangeReceivedCallback?(locations.last!)

  trackedLocations += locations
}</pre><p>Note that the location manager is only told to stop updating the user's location when significant location tracking is not active. When you call <code class="literal">stopUpdatingLocation()</code>, the location manager will cease to deliver any location updates to this delegate method. Also, note that <code class="literal">significantChangeReceivedCallback</code> is not removed after calling it. The reason for this is that the caller of <code class="literal">monitorSignificantChanges(_:)</code> is interested in continuous location updates, so any time this method is called, the <code class="literal">SignificantChangesViewController</code> view controller that initiated significant location tracking should always be called.</p><p>One last thing you need to do, so your app receives significant <span>location</span><a id="id325580586" class="indexterm"></a> changes while it's not in the foreground, is to set the <code class="literal">allowsBackgroundLocationUpdates</code> property to <code class="literal">true</code>. Add the following line of code to the location helper's <code class="literal">init()</code>:</p><pre class="programlisting">locationManager.allowsBackgroundLocationUpdates = true</pre><p>In addition to subscribing to significant location changes or visits, you can also respond to the user entering or leaving a certain area with geofences.</p><p> </p></div>