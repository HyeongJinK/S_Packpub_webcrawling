<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch23lvl1sec154"></a>Testing logic with XCTest</h2></div></div><hr /></div><p>Even if you haven't <span>written</span><a id="id325333110" class="indexterm"></a> any tests before, you might <span>have</span><a id="id325333841" class="indexterm"></a> thoughts or ideas about it. To start testing code, you don't need to have a computer science degree or spend days studying the absolute best way to test your code. In fact, the chances are that you're already testing your code and you don't even know it.</p><p>So, what does it mean to test your code? That's what this section aims to make clear. You will first read about the different types of tests you can write. Then, you'll learn what <code class="literal">XCTest</code> is and how you can set up a test suite for an app. Finally, you'll learn how to optimally test some actual code and how code can be refactored to make it more testable.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch23lvl2sec122"></a>Understanding what it means to test code</h3></div></div></div><p>When you test <span>your</span><a id="id325333859" class="indexterm"></a> code, you're essentially making sure that certain input produce the desired output. A very basic example of a test would be to make sure that calling a method that increments its input by a given value produces the output you expect.</p><p>Any time you launch your application in a simulator or on a device and test whether you can perform specific actions in an app, you are testing your code. Any time you print something to the console to verify that the expected value is printed, you are also testing your code. Once you think about testing this way, a concept that might have sounded hard before actually does not seem as complicated as you may have thought. So if using your app is a way of testing it, then what should you write tests for?</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch23lvl3sec57"></a>Determining which tests to write</h4></div></div></div><p>When you start testing, it's often hard to decide what logic you want to test and what logic you don't want to test. Reasons for this could include certain logic being too trivial, too hard, or just not important enough to test. This statement implies that you do not have to test absolutely every line of code in your app and that is intentional. Sometimes it's simply not reasonable to write tests for a certain part of your code. For instance, you don't have to test that <code class="literal">UIKit</code> behaves as it should; it's Apple's job to make sure that the frameworks they ship are bug-free.</p><p> </p><p>Determining what to <span>test</span><a id="id325333884" class="indexterm"></a> is important, and the longer you defer deciding whether you will add tests for a particular piece of logic, the harder it will be to write tests for it. A simple rule of thumb is that you don't need to test Apple's frameworks. It's safe to assume that Apple makes sure that any code they ship is tested and if it contains bugs, there's not much you can do to fix it anyway. Moreover, you don't want your tests to fail where Apple's tests should have.</p><p>What you should at least test is the <span class="emphasis"><em>call-site</em></span> of your methods, structs, and classes. You can think of the call-site as the methods that other objects use to perform tasks. It's a good practice to make anything that's not used by the call-site of your objects private, meaning that outside code can't access that part of the code. <span>More on this later</span> when you learn more about refactoring code to make it more testable.</p><p>You should also test code that you might consider too trivial to write tests for. These parts of your code are likely to receive the <span class="emphasis"><em>too trivial</em></span> treatment in other parts of the development process too. This usually causes you and your coworkers to pay less and less attention to this trivial piece of code, and before you know it, a bug gets introduced that might not be spotted until the app is in the App Store. Writing trivial tests for trivial code takes very little time and saves you from minor oversights that could lead to massive complications.</p><p>A few simple guidelines that you should follow when you write tests are:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Test trivial code; this usually requires minimal effort.</li><li style="list-style-type: disc">Test the call-site of your objects; these tests will ensure that your public APIs are consistent and work as expected.</li><li style="list-style-type: disc">Don't test Apple's frameworks or any other dependencies; doing this is the responsibility of the framework vendor.</li></ul></div><p>Once you've determined what you should test, it's time to start writing the actual tests. However, if you've heard about testing before, you might have heard of terms such as integration tests, unit tests, sanity tests, and a couple of others. The next segment explains a couple of the most important and well-known types of testing.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch23lvl3sec58"></a>Choosing the correct test type</h4></div></div></div><p>When you write tests, it's often a good idea to ask yourself what kind of <span>test</span><a id="id325333932" class="indexterm"></a> you're writing. The kind of test you want to write will typically guide you toward the way your test should be structured and scoped. Having tests that are well-scoped, structured, and focused will ensure that you're building a stable test suite that properly tests your code without unintended side-effects that influence the quality of your tests.</p><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch23lvl4sec0"></a>Unit tests</h5></div></div></div><p>Probably the most well-known type of test is the unit test. A lot of people call virtually any test they write to test their code a unit test, which is probably why this is such a well-known term for testing. Another reason for unit tests being so popular is that it's a very sensible test type.</p><p>A <span>unit</span><a id="id325333956" class="indexterm"></a> test is intended to make sure that an isolated <span>object</span><a id="id325333962" class="indexterm"></a> works as expected. This isolated object will usually be a class or struct, but it could just as well be a standalone method. It's important that unit tests do not rely on any other test or object. It's perfectly fine to set up an environment that has all the preconditions you need for your unit test, but none of this setup should be accidental. For instance, you shouldn't accidentally test other objects or depend on the order in which your tests are executed.</p><p>When you write a unit test, it's not uncommon to create instances of models that are stored in an array to represent a dummy database or fake REST APIs. Creating such a list of dummy data is done to ensure that a unit test does not fail due to external factors such as a network error. If your test should depend on certain external factors, you are probably writing an <span class="emphasis"><em>integration test</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch23lvl4sec1"></a>Integration tests</h5></div></div></div><p>An <span>integration</span><a id="id325333984" class="indexterm"></a> test ensures that a certain part of <span>your</span><a id="id325333990" class="indexterm"></a> code can integrate with other components of the system. Similar to unit tests, an integration test should never rely on other tests. This is important for any test you write. Whenever a test depends on certain preconditions, they must be set up within the test itself. If your test does depend on other tests, this dependency might not be obvious at first, but it can make your tests fail in weird and unexpected ways.</p><p>Because no test can depend on another test, integration tests require a little more setup than unit tests. For example, you might want to set up an API helper, fetch some data from the API, and feed it into a database. A test such as this verifies that the API helper can cooperate with the database layer. Both layers should have their separate unit tests to ensure they work in isolation while the integration test ensures that the database and API can work together. There are many other types of test that you can write or learn about, but for now integration tests and unit tests provide an excellent starting point.</p><p> </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch23lvl3sec59"></a>Isolating tests</h4></div></div></div><p>Assumptions are a considerable risk when you're testing. Any time you assume anything about the environment you're testing in, your test is not reliable. If you're just getting into writing tests, it's tempting to make assumptions such as <span class="emphasis"><em>I'm testing on the simulator and my test user is always logged in so my tests can be written under the assumption that a logged-in user exists</em></span>. This assumption makes a lot of sense to a lot of people, but what if one of your tests logs the current user out?</p><p>When this happens, a lot of your <span>tests</span><a id="id325334017" class="indexterm"></a> will fail due to assumptions that you made about the test environment. More importantly, these tests might fail even if the code they're testing works flawlessly.</p><p>As mentioned before, tests should test a single thing in your app. They should rely on as little outside code as possible, and they should be properly focused. A typical pattern that people use to structure their tests and improve reliability is the 3-As or AAA approach. The name of this pattern is short for Arrange, Act, and Assert. The following is an explanation for each of the As.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch23lvl4sec2"></a>Arrange</h5></div></div></div><p>The arrange step is all about preparation. Make <span>sure</span><a id="id325334034" class="indexterm"></a> a logged-in user exists, populate the (in-memory) database, create instances of your fake API or other helpers. You essentially arrange everything to be in place for your testing environment. Note that this step should not involve too much setup. If you find yourself writing a lot of code in the arrange step, your test might be too broad. Or the code you're testing relies on too many other pieces of code. You can't always avoid this, but if it happens, make sure you consider refactoring your code and test to keep the quality on par with what you're trying to achieve.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch23lvl4sec3"></a>Act</h5></div></div></div><p>In the act step, you set everything for your test in motion. You call <span>methods</span><a id="id325334049" class="indexterm"></a> on the object you're testing, you feed it data, and you manipulate it. This is where you take your code for a proverbial spin. Don't perform too many actions in succession though; too much acting will lead to problems during the next step, assert.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch23lvl4sec4"></a>Assert</h5></div></div></div><p>The final A in the 3-As approach is assert. During the <span>assert</span><a id="id325580647" class="indexterm"></a> step, you make sure that the state of the object you're testing is as you'd expect. Act and assert can be used multiple times in a single test. For instance, you might want to assert that doing something once places the object in a particular state and that doing it again places the object in another state. Or possibly that the state stays the same. Just as with the other two steps, if you're asserting a lot of things, or if you're acting and asserting over and over again in a test, the chances are that your test is too broad. This can't always be avoided, but long tests with a lot of acting and asserting are often an indication of testing too much at once.</p><p>Reading about testing can be quite dull, and it tends to get abstract quickly, so let's leave the theory for now. You will set up a test suite for an existing project in Xcode and start writing some tests, so all of the information you've taken in so far becomes a bit more tangible.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch23lvl2sec123"></a>Setting up a test suite with XCTest</h3></div></div></div><p>In this section, you'll work on a test suite for a new app: <span class="strong"><strong>MovieTrivia</strong></span>. You'll find the basic <span>setup</span><a id="id325580668" class="indexterm"></a> for this project in this book's code bundle. If you open the project, there are some view controllers, an <code class="literal">Info.plist</code> file, and all the other files you would normally expect to find in a project. There's also a JSON file in the project named <code class="literal">TriviaQuestions.json</code>. This file contains a couple of dummy questions that you can load by uncommenting a bit of code in <code class="literal">LoadTriviaViewController.swift</code>.</p><p>By default, <code class="literal">LoadTriviaViewController.swift</code> attempts to <span>load</span><a id="id325580693" class="indexterm"></a> questions from a non-existing web server. This is intentional, to demonstrate how one would normally set up a project like this. Since you don't have a web server at your disposal right now, you can swap out the dummy networking code for the JSON file to test this app.</p><p>Before you write tests or perform any optimization, you must add a test target to the project. You add a test target in the same way you added extensions before. The only difference is that you select a different type of target. When adding a test target, you should pick the <strong class="userinput"><code>iOS Unit Testing Bundle</code></strong> template. The following screenshot shows the correct template you should select:</p><p> </p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/ce25de34-9f0d-4b1b-837a-d936d1c3af65.png" /></div><p>After adding the target, Xcode adds a new folder to your project. If you choose the default name for the test target, it's called <code class="literal">MovieTriviaTests</code>. You should add all the tests you write for this project to the test target.</p><p>If you think about when you used files in multiple targets with extensions, you might expect that you would need to add all of the files you want to write tests for to both of the targets. Fortunately, this isn't the case. When you write tests, you can import the entire app as a testable target, enabling you to write tests for all of the code in the app target.</p><p>If you look inside the <code class="literal">MovieTriviaTests</code> folder that Xcode created when you added the unit test target, you'll find a single file called <code class="literal">MovieTriviaTests.swift</code>. This file contains a couple of hints about what tests should look like for your test suite. First of all, note that the test class inherits from <code class="literal">XCTestCase</code>. All of your test classes should inherit from this <code class="literal">XCTestCase</code> so they can be identified as a test.</p><p> </p><p>One of the methods you'll find in the test template is the <code class="literal">setUp()</code> method. This method is executed before every test in the file and helps you to fulfill the first stage of the AAA pattern in testing: <span>Arrange</span>. You use this method to ensure that all of the preconditions for your test are met. You could make sure that your user is logged in or that your database is populated with test data. Of course, the depth of your setup in this method depends on the unit of code for which you're writing a test.</p><p>Also, note that there are two <span>methods</span><a id="id325580759" class="indexterm"></a> prefixed with <code class="literal">test</code> in the test class. These <span>methods</span><a id="id325580772" class="indexterm"></a> are executed as tests, and they are expected to perform the act and assert steps. The majority of work should be performed in these <code class="literal">test</code> methods. Do note that it's often better to have multiple short test methods rather than a single test method that tests everything. The larger the methods, the harder it will be to maintain and debug your tests.</p><p>Finally, you'll find a <code class="literal">tearDown()</code> method. This method is intended to give you an opportunity to clean up after yourself. When you have inserted dummy data into your database, it's often desirable to remove this data when your tests have completed. This will ensure a clean slate for the next test that runs, and it minimizes the chances that your first test accidentally influences the second test that runs. As mentioned before, tests should never depend on other tests. This means that you also don't want to pollute other tests by leaving traces of previous tests.</p><p>Note that <code class="literal">setUp()</code> and <code class="literal">tearDown()</code> should be specific to the unit you're testing. This means that you can't put all of your tests in a single class. Separating tests into several classes is a good thing. You should create a test class for every unit of code that you're testing. One test class should typically not test more than a single class or struct in your app. If you're writing an integration test, there might be more than one class involved in the test, but you should still make sure that you're only testing a single thing, which is the integration between the classes involved in the integration you're testing.</p><p>Now that you have a test suite in place, let's see how you can write tests for the existing code in the <span class="strong"><strong>MovieTrivia</strong></span> app and how the app can be refactored to be tested appropriately.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch23lvl2sec124"></a>Optimizing code for testability</h3></div></div></div><p>Now that the project has a test target, it's time to start <span>adding</span><a id="id325580810" class="indexterm"></a> some tests to it. Before you add tests, you should determine what to test. Take some time to look at the app and the code and try to think of things to test. Assume that the app is finished and that the trivia questions are loaded from a server.</p><p> </p><p>Some of the things you might have thought of to test are:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Making sure that we can display the data we load from the network</li><li style="list-style-type: disc">Testing that selecting the correct answer triggers the expected code</li><li style="list-style-type: disc">Testing that choosing a wrong answer triggers the expected code</li><li style="list-style-type: disc">Ensuring that the first question is displayed after we show the last one</li><li style="list-style-type: disc">Testing that the question index increments</li></ul></div><p>If you came up with most of the tests on this list, good job. You've successfully identified a lot of good test cases. But how do you test these cases? The project has been made hard to test intentionally, but let's see what tests can be written without refactoring the app right away.</p><p>Remove the test class that Xcode has generated for you and create a new one called <code class="literal">LoadQuestionsTest</code>. Use the following bit of boilerplate code in this file's implementation as a starting point for the tests:</p><pre class="programlisting">import XCTest
@testable import MovieTrivia

typealias JSON = [String: Any]

class LoadQuestionsTest: XCTestCase {
  override func setUp() {
    super.setUp()
  }

  func testLoadQuestions() {

  }
}</pre><p>Note the <code class="literal">@testable import MovieTrivia</code> line at the top of the file. This line imports the entire app target so you can access it in your tests. Before you implement the test body for <code class="literal">testLoadQuestions</code>, it's wise to think about what this method should test. If you look at the code in the app target, the trivia questions are loaded in the <code class="literal">viewDidAppear(_:)</code> method of <code class="literal">LoadTriviaViewController</code>. Once the questions are loaded, the app moves on to the next screen. An important detail is that the <code class="literal">triviaJSON</code> property on <code class="literal">LoadTriviaViewController</code> is set once the questions are loaded.</p><p> </p><p>Based on this information, you could write a test that creates an instance of <code class="literal">LoadTriviaViewController</code>, makes it appear, so the questions will load, and then waits until <code class="literal">triviaJSON</code> has a value to verify that the questions were successfully loaded. Writing a test that fits this description would involve many moving parts, way more than you should be comfortable with. <span class="strong"><strong>MovieTrivia</strong></span> uses storyboards, so to obtain an instance of <code class="literal">LoadTriviaViewController</code>, the storyboard would have to be involved. This means that any changes or mistakes in the user interface would cause the logic test that checks whether data is loaded to fail. This is not desirable because this test should only verify whether it's possible to load data, not whether the user interface updates once the load completes.</p><p>This is a great moment to start refactoring some code and make it more testable. The first piece of code that should be revamped for testability is the question-loading code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch23lvl3sec60"></a>Introducing the question loader</h4></div></div></div><p>To make <span class="strong"><strong>MovieTrivia</strong></span> more testable, you should <span>create</span><a id="id325580939" class="indexterm"></a> a special helper that can load questions. The helper will go to the network and fetch the questions. Once the data is loaded, a callback is called to notify the object that initiated the request about the loaded questions. Because you already know that you're going to write tests for the new helper, you should think of a way to make sure that the helper works with both an offline and an online implementation, so the tests don't have to depend on an internet connection to work.</p><p>Because tests should rely on as few outside factors as possible, removing the networking layer from this test would be great. This means that the helper needs to be split into two parts. One part is the helper itself. The other part would be a data-fetcher. The data-fetcher should conform to a protocol that defines the interface that a data-fetcher must have, so you can choose to inject either an online or offline fetcher into the helper.</p><p>If the preceding explanation seems a little bit abstract and confusing to you, that's OK. The following code samples will show you the process of separating the different helpers step by step. Add a new Swift file to the application target and call it <code class="literal">QuestionsLoader.swift</code>. Then add the following implementation to it:</p><pre class="programlisting">typealias QuestionsLoadedCallback = (JSON) -&gt; Void

struct QuestionsLoader {
  func loadQuestions(callback: @escaping QuestionsLoadedCallback) {
    guard let url = URL(string: "http://questions.movietrivia.json")
      else { return }

    URLSession.shared.dataTask(with: url) { data, response, error in
      guard let data = data,
        let jsonObject = try? JSONSerialization.jsonObject(with: data, options: []),
        let json = jsonObject as? JSON
        else { return }

      callback(json)
    }
  }
}</pre><p>This struct defines a method to load questions with a callback. This is already nice and a lot more testable than before. You can now isolate the question loader and test it separated from the rest of the app. A test for the helper in its current state would look like the test shown in the following code snippet:</p><pre class="programlisting">func testLoadQuestions() {
  let questionsLoader = QuestionsLoader()
  let questionsLoadedExpectation = expectation(description: "Expected the questions to be loaded")
  questionsLoader.loadQuestions { _ in
    questionsLoadedExpectation.fulfill()
  }

  waitForExpectations(timeout: 5, handler: nil)
}</pre><p>The preceding test creates an <span>instance</span><a id="id325580968" class="indexterm"></a> of <code class="literal">QuestionLoader</code> and sets up an <code class="literal">expectation</code>. An expectation is used when you expect something to happen in your test eventually. Since <code class="literal">QuestionLoader</code> loads its questions asynchronously, you can't expect the questions to be loaded by the time this test method is done executing. The callback that's called when the questions are loaded is used to fulfill the expectation in this test. To make sure that the test waits for the expectation to be fulfilled, <code class="literal">waitForExpectations(timeout:handler:)</code> is called after <code class="literal">loadQuestions(callback:)</code>. If the expectation isn't fulfilled within the five-second timeout that is specified, the test fails.</p><p> </p><p>Examine this test closely; you should be able to see all of the As that you read about earlier. The first A, arrange, is where the loader and expectation are created. The second A, act, is when <code class="literal">loadQuestions(callback:)</code> is called. The final A, assert, is inside the callback. This test doesn't validate whether the data passed to the callback is valid, but you'll get to that later.</p><p>Separating the loader into its own object is great but is still has one problem. There is no way to configure whether it loads data from a local file or the network. In a production environment, the question loader would load data from the network, which would make the test for the question loader depend on the network as well. This isn't ideal because a test that depends on the network might fail for reasons you can't control.</p><p>This can be improved by utilizing some protocol-oriented programming and the dependency-injection pattern. This means that you should define a protocol that defines the public API for a networking layer. Then you should implement a networking object in the app target that conforms to the protocol. <code class="literal">QuestionsLoader</code> should have a property that holds anything that conforms to the networking protocol. The test target should have its own object that conforms to the networking protocol so you can use that object to provide <code class="literal">QuestionsLoader</code> with mock data.</p><p>By setting the test up like this, you can take the entire networking logic out of the equation and arrange tests in such a way that the networking doesn't matter. The mock networking layer will respond with valid, reliable responses that can be used as test input.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch23lvl3sec61"></a>Mocking API responses</h4></div></div></div><p>It's common practice to mock API <span>responses</span><a id="id325356867" class="indexterm"></a> when you're testing. In this segment, you will implement the mock API that was described before to improve the quality and reliability of the <strong class="userinput"><code>MovieTrivia</code></strong> test suite. First, let's define the networking protocol. Create a new file in the app target and name it <code class="literal">TriviaAPIProviding</code>:</p><pre class="programlisting">typealias QuestionsFetchedCallback = (JSON) -&gt; Void

protocol TriviaAPIProviding {
  func loadTriviaQuestions(callback: @escaping QuestionsFetchedCallback)
}</pre><p>The protocol only requires a single method. If you want to expand this app later, everything related to the Trivia API must be added to the protocol to make sure that you can create both an online version of your app and an offline version for your tests. Next, create a file named <code class="literal">TriviaAPI</code> and add the following implementation to it:</p><pre class="programlisting">struct TriviaAPI: TriviaAPIProviding {
  func loadTriviaQuestions(callback: @escaping QuestionsFetchedCallback) {
    guard let url = URL(string: "http://questions.movietrivia.json")
      else { return }

    URLSession.shared.dataTask(with: url) { data, response, error in
      guard let data = data,
        let jsonObject = try? JSONSerialization.jsonObject(with: data, options: []),
        let json = jsonObject as? JSON
        else { return }

      callback(json)
    }
  }
}</pre><p>Lastly, update the <code class="literal">QuestionsLoader</code> struct with the following implementation:</p><pre class="programlisting">struct QuestionsLoader {
  let apiProvider: TriviaAPIProviding

  func loadQuestions(callback: @escaping QuestionsLoadedCallback) {
    apiProvider.loadTriviaQuestions(callback: callback)
  }
}</pre><p>The question loader now has an <code class="literal">apiProvider</code> that it uses to load questions. Currently, it delegates any load call over to its API provider, but you'll update this code soon to make sure that it converts the raw JSON data that the API returns to question models.</p><p>Update the <code class="literal">viewDidAppear(_:)</code> method of <code class="literal">LoadTriviaViewController</code> as shown in the following code snippet. This implementation uses the loader struct instead of directly loading the data inside the view controller:</p><pre class="programlisting">override func viewDidAppear(_ animated: Bool) {
  super.viewDidAppear(animated)

  let apiProvider = TriviaAPI()
  let questionsLoader = QuestionsLoader(apiProvider: apiProvider)
  questionsLoader.loadQuestions { [weak self] json in
    self?.triviaJSON = json
    self?.performSegue(withIdentifier: "TriviaLoadedSegue", sender: self)
  }
}</pre><p>The preceding code is not only more testable, it's also a lot cleaner. The next step is to create the mock API in the test target so you can use it to provide the question loader with data.</p><p>The JSON file in the app <span>target</span><a id="id325356929" class="indexterm"></a> should be removed from the app target and added to the test target. You can leave it in the app folder but make sure to update the <strong class="userinput"><code>Target Membership</code></strong>, so the JSON file is only available in the test target. Now add a new Swift file named <code class="literal">MockTriviaAPI</code> to the test target and add the following code to it:</p><pre class="programlisting">struct MockTriviaAPI: TriviaAPIProviding {
  func loadTriviaQuestions(callback: @escaping QuestionsFetchedCallback) {

    guard let filename = Bundle(for: LoadQuestionsTest.self).path(forResource: "TriviaQuestions", ofType: "json"),
      let triviaString = try? String(contentsOfFile: filename),
      let triviaData = triviaString.data(using: .utf8),
      let jsonObject = try? JSONSerialization.jsonObject(with: triviaData, options: []),
      let triviaJSON = jsonObject as? JSON
      else { return }

    callback(triviaJSON)
  }
}</pre><p>This code fetches the locally-stored JSON file from the test bundle. To determine the location of the JSON file, one of the test classes is used to retrieve the current bundle. This is not the absolute best way to retrieve a bundle because it relies on an external factor to exist in the test target. However, structs can't be used to look up the current bundle. Luckily, the compiler will throw an error if the class that is used to determine the bundle is removed so the compiler would quickly error and the mistake can be fixed. After loading the file, the callback is called, and the request has been successfully handled. Now update the test in <code class="literal">LoadQuestionsTest</code>, so it used the mock API as follows:</p><pre class="programlisting">func testLoadQuestions() {
  let mockApi = MockTriviaAPI()
  let questionsLoader = QuestionsLoader(apiProvider: mockApi)
  let questionsLoadedExpectation = expectation(description: "Expected the questions to be loaded")
  questionsLoader.loadQuestions { _ in
    questionsLoadedExpectation.fulfill()
  }

  waitForExpectations(timeout: 5, handler: nil)
}</pre><p>A lot of apps have way more complex interactions than the one you're testing now. When you get to implementing more complex scenarios, the main ideas about how to architect your app and tests remain the same, regardless of application complexity. Protocols can be used to define a common interface for certain objects. Combining this with dependency-injection like you did for <code class="literal">QuestionsLoader</code> helps to isolate the pieces of your code that you're testing, and it enables you to swap out pieces of code to make sure that you don't rely on external factors if you don't have to.</p><p>So far, the test suite is not particularly useful. The only thing that's tested at this point is whether <code class="literal">QuestionsLoader</code> passes requests on to the <code class="literal">TriviaAPIProviding</code> object and whether the callbacks are called as expected. Even though this technically qualifies as a test, it's much better also to test whether the loader object can convert the loaded data into question objects that the app can display.</p><p>Testing whether <code class="literal">QuestionsLoader</code> can convert JSON into a <code class="literal">Question</code> model is a test that's a lot more interesting than just testing whether the callback is called. A refactor such as this might make you wonder whether you should add a new test or modify the existing test.</p><p>If you choose to add a new test, your test suite will cover a simple case where you only test that the callback is called and a more complex case that ensures the loader can convert JSON data to models. When you update the existing test, you end up with a test that validates two things. It would make sure that the callback is called but also that the data is converted to models.</p><p>While the implications for both choices are similar, the second choice sort off assumes that the callback will be called. You always want to limit your assumptions when writing tests and there's no harm in adding more tests when you add more features. However, if the callback does not get called, none of the tests will work. So in this case, you can work with a single test that makes sure the callback is called and that the loader returns the expected models.</p><p>The test you should end up with will have a single expectation and multiple assertions. Writing the test like this makes sure that the expectation for <code class="literal">callback</code> is fulfilled when the callback is called, and at the same time you can use assertions to ensure that the data that's passed to <code class="literal">callback</code> is valid and correct.</p><p>By making <code class="literal">QuestionsLoader</code> create instances of a <code class="literal">Question</code> model rather than using it to return a dictionary of JSON data, it not only makes the test more interesting, it also improves the app code by making it a lot cleaner.</p><p>Right now, the app uses a dictionary of JSON data to display questions. If the <span>JSON</span><a id="id325357004" class="indexterm"></a> changes, you would have to update the view controller's code. If the app grows, you might be using the JSON data in multiple places, making the process of updating quite painful and error-prone. This is why it's a much better idea to use the <code class="literal">Codable</code> protocol to convert raw API responses to <code class="literal">Question</code> models. Using Codable objects means you can get rid of the JSON dictionaries in the view controllers, which is a vast improvement.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch23lvl3sec62"></a>Using models for consistency</h4></div></div></div><p>Adding a question model to <span class="strong"><strong>MovieTrivia</strong></span> involves quite a bit of refactoring. First, you must define the <code class="literal">Question</code> model. Create a new Swift file named <code class="literal">Question</code> and add the following implementation to it:</p><pre class="programlisting">struct Question: Codable {
  let title: String
  let answerA: String
  let answerB: String
  let answerC: String
  let correctAnswer: Int
}</pre><p>If you followed along with <a class="ulink" href="https://#" target="_blank"><span>Chapter</span> 10</a>, <span class="emphasis"><em>Fetching and Displaying Data from the Network</em></span>, this model should look somewhat familiar. The <code class="literal">Question</code> struct conforms to the <code class="literal">Codable</code> protocol. Since the dummy <span>JSON</span><a id="id325357062" class="indexterm"></a> data contains a list of questions, you'll want to define a <code class="literal">Codable</code> object that contains the response as well:</p><pre class="programlisting">struct QuestionsFetchResponse: Codable {
    let questions: [Question]
}</pre><p>Now that the <code class="literal">Question</code> model and the response container are in place, a couple of changes must be made to the existing code. First of all, <code class="literal">typealias</code> in the <code class="literal">TriviaAPIProviding</code> protocol should be modified as follows:</p><pre class="programlisting">typealias QuestionsFetchedCallback = (Data) -&gt; Void</pre><p>Next, update the implementation of the TriviaAPI for the <code class="literal">URLSession</code> callback in <code class="literal">loadTriviaQuestions(callback:)</code> as follows:</p><pre class="programlisting">URLSession.shared.dataTask(with: url) { data, response, error in
  guard let data = data
    else { return }

  callback(data)
}</pre><p>Also, update <code class="literal">MockTriviaApi</code> so it executes its callback with data instead of a JSON dictionary:</p><pre class="programlisting">func loadTriviaQuestions(callback: @escaping QuestionsFetchedCallback) {

  guard let filename = Bundle(for: LoadQuestionsTest.self).path(forResource: "TriviaQuestions", ofType: "json"),
    let triviaString = try? String(contentsOfFile: filename),
    let triviaData = triviaString.data(using: .utf8)
    else { return }

  callback(triviaData)
}</pre><p>The <code class="literal">QuestionsLoadedCallback</code><code class="literal">typealias</code> in <code class="literal">QuestionsLoader</code> should be updated to the following definition:</p><pre class="programlisting">typealias QuestionsLoadedCallback = ([Question]) -&gt; Void</pre><p>And lastly, the implementation for <code class="literal">loadQuestions(callback:)</code> should be updated as follows:</p><pre class="programlisting">func loadQuestions(callback: @escaping QuestionsLoadedCallback) {
  apiProvider.loadTriviaQuestions { data in
    let decoder = JSONDecoder()
    decoder.keyDecodingStrategy = .convertFromSnakeCase
    guard let questionsResponse = try? decoder.decode(QuestionsFetchResponse.self, from: data)
      else { return }

    callback(questionsResponse.questions)
  }
}</pre><p>This wraps up the changes for the API. However, there still is some refactoring to be done in the view controllers. Rename the <code class="literal">triviaJSON</code> property on <code class="literal">LoadTriviaViewController</code> to the following:</p><pre class="programlisting">var questions: [Question]?</pre><p>Make sure you replace all occurrences of <code class="literal">triviaJSON</code> with the new questions array. Also, make sure you change the following line in <code class="literal">prepare(for:sender:)</code>:</p><pre class="programlisting">questionViewController.triviaJSON = triviaJSON</pre><p>Change this line to:</p><pre class="programlisting">questionViewController.questions = questions</pre><p>In <code class="literal">QuestionViewController</code>, change the type of <code class="literal">questions</code> to <code class="literal">[Question]</code> and remove the <code class="literal">triviaJSON</code> property. At this point, you can clear all of the JSON-related code from the guards in this class. You should be able to do this on your own since the compiler should guide you with errors. If you get stuck, look at the finished project in the code bundle.</p><p>By now, you should be able to run the tests, and they should pass. To run your tests, click the Product menu item and select Test. Alternatively, press <span class="emphasis"><em>Cmd + U</em></span> to run your tests. The tests run fine, but currently, the test doesn't test whether all of the questions in the JSON data got converted to Question models. To make sure this conversion worked, you can load the JSON file in the test, count the number of questions in the <span>JSON</span><a id="id325357266" class="indexterm"></a> file, and assert that it matches the number of questions in the callback.</p><p>Update the <code class="literal">testLoadQuestions()</code> method as shown in the following code snippet:</p><pre class="programlisting">func testLoadQuestions() {
  let apiProvider = MockTriviaAPI()
  let questionsLoader = QuestionsLoader(apiProvider: apiProvider)
  let questionsLoadedExpectation = expectation(description: "Expected the questions to be loaded")
  questionsLoader.loadQuestions { questions in
    guard let filename = Bundle(for: LoadQuestionsTest.self).path(forResource: "TriviaQuestions", ofType: "json"),
      let triviaString = try? String(contentsOfFile: filename),
      let triviaData = triviaString.data(using: .utf8),
      let jsonObject = try? JSONSerialization.jsonObject(with: triviaData, options: []),
      let triviaJSON = jsonObject as? JSON,
      let jsonQuestions = triviaJSON["questions"] as? [JSON]
      else { return }

    XCTAssert(questions.count &gt; 0, "More than 0 questions should be passed to the callback")
    XCTAssert(jsonQuestions.count == questions.count, "Number of questions in json must match the number of questions in the callback.")

    questionsLoadedExpectation.fulfill()
  }

  waitForExpectations(timeout: 5, handler: nil)
}</pre><p>This test loads the dummy JSON file and uses XCTAssert to make sure that more than zero questions were passed to the callback and that the number of questions in the JSON file matches the number of questions that were loaded.</p><p><code class="literal">XCTAssert</code> takes a Boolean expression and a description. If the assertion fails, the description is shown. Adding good descriptions will help you to quickly figure out which assertion in your test has made your test fail.</p><p>This new version of the load-questions test is a small addition to the test suite but has <span>vast consequences</span>. By improving the test suite, you have improved the quality of the app because you can now prove that the question loader correctly transforms JSON into model objects. By adding model objects, you have improved the code in the view controllers as well. Instead of reading raw JSON, you are now reading properties from a model. And lastly, these changes have made your view controllers a lot cleaner.</p><p>One more metric that has improved by refactoring your code is the amount of code that is covered by the test suite. You can measure the percentage of code your test suite covers with Xcode's built-in code coverage-tracking. You'll learn how to use this tool next.</p></div></div></div>