<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec40"></a>Knowing what types are available</h2></div></div><hr /></div><p>To write great code, you need to learn what tools are <span>available</span><a id="id325333104" class="indexterm"></a> in your toolbox. This applies to building apps and understanding the features <code class="literal">UIKit</code> has to offer, but it also applies to the language you use to write software in. Different languages come with various features, best practices, pros, and cons. The deeper your understanding of the language you work with, the better the decisions you can make about the code you write. As mentioned before, Swift's type system is one of the features that makes Swift such an excellent language for both experts and beginners to develop in.</p><p> </p><p>Before you dive into the details of Swift's types and how they compare to each other, it's essential that you know what types Swift has to offer you. On a high level, you can argue that Swift has two types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Reference types</li><li style="list-style-type: disc">Value types</li></ul></div><p>Let's have a closer look at each type to see what they mean, how they work, and how you can use them.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec23"></a>Reference types</h3></div></div></div><p>The types you have seen so far in this book were mostly, if not all, <span>reference</span><a id="id325581014" class="indexterm"></a> types. Two types of objects are classified as <span>reference</span><a id="id325581022" class="indexterm"></a> types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Classes</li><li style="list-style-type: disc">Closures</li></ul></div><p>You have seen both of these object types in this book already. For instance, all <code class="literal">UIViewController</code> subclasses you have created are reference types. All closures that you used as callbacks or to perform animations in are also reference types.</p><p>So what does it mean if something is a reference type, and why should it matter to you? Well, reference types come with behavior that can be both convenient and very frustrating depending on what you are trying to achieve in your code.</p><p>One feature that is unique to reference types and classes is the ability to subclass. The only type that can inherit functionality from another object is a class. This will be covered in more depth when you learn about the differences between types, but it's good to be aware of this information already. Let's examine reference types up close by writing some code in a Playground.</p><p>Create a new Playground project in Xcode and give it a name. Then add the following code to it:</p><pre class="programlisting">class Pet {
  var name: String

  init(name: String) {
    self.name = name
  }
}

func printName(for pet: Pet) {
  print(pet.name)
}

let cat = Pet(name: "Misty")
printName(for: cat)</pre><p>It's likely that you're not too excited about this little snippet of code. All it does is define a new <code class="literal">Pet</code> class, make an instance of it, and then it passes that instance into <code class="literal">printName(for:)</code>. However, this code is extremely well-suited to illustrating what a <span>reference</span><a id="id325580654" class="indexterm"></a> type is.</p><p>When you call <code class="literal">printName(for: cat)</code>, you pass a <span class="emphasis"><em>reference</em></span> to your cat instance to <code class="literal">printName(for:)</code>. This means that it is possible for anybody who gets ahold of this <span>reference</span><a id="id325580675" class="indexterm"></a> to make changes to the object that is referenced. If this sounds confusing, that's okay.</p><p>Add the following code to the Playground you have created and then run it:</p><pre class="programlisting">func printName2(for pet: Pet) {
  print(pet.name)
  pet.name = "Jeff"
}

let dog = Pet(name: "Bingo")
printName2(for: dog) // Bingo
print(dog.name)</pre><p>What do you notice in the console after running this? If you noticed that the dog's name changes from <code class="literal">Bingo</code> to <code class="literal">Jeff</code>, you have just observed what it means <span>to pass a reference to something around</span>. Since <code class="literal">printName2(for:)</code> received a reference to your <code class="literal">Pet</code> instance, it was able to change its name. If you have programmed in other languages, this might be obvious to you. If not, this might be very surprising.</p><p>One more thing you should note is that <code class="literal">dog</code> was declared as a constant. Regardless, you were allowed to change the name of your instance from <span class="emphasis"><em>Bingo</em></span> to <span class="emphasis"><em>Jeff</em></span>. If you think this is obvious, add the following code to your Playground and run it:</p><pre class="programlisting">import UIKit
let point = CGPoint(x: 10, y: 10)
point.x = 10</pre><p>This code is very similar to what you did with the <code class="literal">Pet</code> instance. You make a constant instance of a thing, and then you change one of its properties. This time, however, when you try to run your Playground, you should see an error along the lines of:</p><pre class="programlisting"><span class="strong"><strong>Cannot assign to property:'point' is a 'let' constant</strong></span>.</pre><p>Even though the code you implemented so far is pretty small, it does a great job of demonstrating reference types. You have currently seen two properties of a reference type in action:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Anybody that receives an instance of a reference type can mutate it</li><li style="list-style-type: disc">You can change properties on a reference type, even if the property that holds onto the reference type is declared as a constant</li></ul></div><p>These two characteristics are typical of reference types. The reason reference types work like this is that a variable or constant that is assigned a reference type <span class="emphasis"><em>does not contain or own</em></span> the object. The constant or variable only points to an address in memory where the instance is stored.</p><p>Any time you create an instance of a <span>reference</span><a id="id325580757" class="indexterm"></a> type, it is written to RAM where it will exist at a particular address. RAM is a special type of memory that is used by computers, such as an iPhone, to temporarily store data in that is used by a certain program. When you assign an instance of a <span>reference</span><a id="id325580766" class="indexterm"></a> type to a property, the property will have a <span class="strong"><strong>pointer</strong></span> to the memory address for this instance. Have another look at the following line of code:</p><pre class="programlisting">let dog = Pet(name: "Bingo")</pre><p>The <code class="literal">dog</code> constant now points to a particular address in memory where the <code class="literal">Pet</code> instance is stored. You are allowed to change properties on the <code class="literal">Pet</code> instance as long as the underlying memory address isn't changed. In fact, you could theoretically put something entirely different at that memory address, and <code class="literal">let dog</code> won't care because it still points to the same address.</p><p>For this same reason, it is possible for <code class="literal">printName2(for:)</code> to change a pet's name. Instead of passing it an instance of <code class="literal">Pet</code>, you pass it the memory address at which the instance is expected to exist. It's okay for <code class="literal">printName2(for:)</code> to make changes to the <code class="literal">Pet</code> instance because it doesn't change the underlying address in memory.</p><p>If you tried to assign a new instance to <code class="literal">dog</code> by typing the following, you would get an error:</p><pre class="programlisting">dog = Pet(name: "Nala")</pre><p>The reason this would error is that you can't change the memory address <code class="literal">dog</code> points to since it's a constant. The following image should clarify this a little bit more by visualizing what it means to pass around a reference type:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/e0342224-61e0-4058-bfde-04640faa0319.png" /></div><p>Now that you know what a <span>reference</span><a id="id325580841" class="indexterm"></a> type is and how it works, you might have already <span>concluded</span><a id="id325580850" class="indexterm"></a> that the <code class="literal">CGPoint</code> you saw in the preceding example must be a value type. Let's see what value types are all about next.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec24"></a>Value types</h3></div></div></div><p>In the examples for <span>references</span><a id="id325580868" class="indexterm"></a> types, you saw the <span>following</span><a id="id325580876" class="indexterm"></a> snippet of code:</p><pre class="programlisting">import UIKit
let point = CGPoint(x: 10, y: 10)
point.x = 10</pre><p>At first sight, you might expect a value type to be a special kind of class because it looks like this snippet creates an instance of a class call <code class="literal">CGPoint</code>. You would be right in your observation, but your conclusion is wrong. <code class="literal">CGPoint</code> is not a class at all. Classes are inherently reference types, and they can't ever be something else. So what are value types, then?</p><p>There are two types of objects that are considered to be value types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Structs</li><li style="list-style-type: disc">Enums</li></ul></div><p>These two types are both very different, so let's make sure that you understand the basics of value types first, and then you'll learn what each of these two types is.</p><p>Let's have a look at the <code class="literal">Pet</code> example again, but use a struct instead of a class. Create a new Playground page in Xcode by opening the <strong class="userinput"><code>Project Navigator</code></strong> in your playground project and clicking the plus symbol in the bottom-left corner. This will allow you to add a new page to your Playground.</p><p>Add the <span>following</span><a id="id325581058" class="indexterm"></a> code to your <span>new</span><a id="id325581066" class="indexterm"></a> page:</p><pre class="programlisting">struct Pet {
  var name: String
}

func printName(for pet: Pet) {
  print(pet.name)
  pet.name = "Jeff"
}

let dog = Pet(name: "Bingo")
printName(for: dog)
print(dog.name)</pre><p>You will immediately notice that Xcode complains. The error you should see in the console tells you that <code class="literal">pet</code> is a <code class="literal">let</code> constant and you are not allowed to change its name. You can turn <code class="literal">pet</code> into a variable by updating <code class="literal">printName</code> as follows:</p><pre class="programlisting">func printName(for pet: Pet) {
  var pet = pet
  print(pet.name)
  pet.name = "Jeff"
}</pre><p>If you run your Playground now, make sure to look at the console closely. You'll notice that the pet's name remains unchanged in the second print. This demonstrates one of the key features of a value type. Instead of passing a reference to an address in memory around, a copy of the object is passed around. This explains why you aren't allowed to change properties on a value type that is assigned to a constant. Changing that property would change the value type's value, and it would, therefore, change the value of the constant. This also means that when you pass <code class="literal">dog</code> to <code class="literal">printName</code>, you pass a copy of the <code class="literal">Pet</code> instance to <code class="literal">printName</code>, meaning that any changes made to the instance are local to the <code class="literal">printName</code> function and won't be applied to <code class="literal">dog</code> in this case.</p><p>This behavior <span>makes</span><a id="id325581123" class="indexterm"></a> using value <span>types</span><a id="id325581131" class="indexterm"></a> extremely safe because it's tough for other objects or functions to make unwanted changes to a value type. And if you define something as a constant, it truly is a constant. Another characteristic of value types is that they're typically very fast and lightweight because they can exist on the <code class="literal">Stack</code> while reference types exist on the <code class="literal">Heap</code>. You'll learn more about this <span>later</span> when we compare reference types and value types.</p><p>Now that you have a basic understanding of value types, let's have a look at the specific value types: structs and enums.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec24"></a>Understanding structs</h4></div></div></div><p>Structs are similar to <span>classes</span><a id="id325581161" class="indexterm"></a> in the way you define them. If you look at the <code class="literal">Pet</code> class you defined earlier, it might be easy to miss the fact that it's a struct. If you pay close attention, you will notice one big difference though. You didn't have to write an initializer for the struct! Swift can automatically generate initializers for structs. This is <span>extremely</span><a id="id325581173" class="indexterm"></a> convenient and can save you a lot of typing for larger structs.</p><p>Structs also can't inherit functionality from other objects. This means that structs always have a very flat and transparent set of properties and methods. This allows the compiler to make optimizations to your code that make structs extremely lightweight and fast.</p><p>A struct can, however, conform to protocols. The Swift standard library is full of protocols that define features for many of the built-in types, such as <code class="literal">Array</code>, <code class="literal">Dictionary</code>, and <code class="literal">Collection</code>. Most of these built-in types are implemented as structs that adopt one or more protocols.</p><p>One last thing you need to understand about structs is that they are very strict about whether they can be modified. Consider a struct that looks as follows:</p><pre class="programlisting">struct Car {
  var gasRemaining: Double

  func fillGasTank() {
    gasRemaining = 1
  }
}</pre><p>This struct will cause the compiler to throw an error. A struct itself is immutable by default, which means you cannot change any of its values. It's up to you to make it explicit to the compiler when a method can mutate, or change, a struct. You do this by adding the <code class="literal">mutating</code> keyword to a function, as follows:</p><pre class="programlisting">mutating func fillGasTank() {
  gasRemaining = 1
}</pre><p>When you <span>create</span><a id="id325581212" class="indexterm"></a> a constant instance of <code class="literal">Car</code> and call <code class="literal">fillGasTank()</code> on it, the <span>compiler</span><a id="id325581225" class="indexterm"></a> will error again. If you call a mutating function on a <code class="literal">let</code> instance, you mutate the instance, meaning the value of the property would change. Because of this, you can only call mutating functions on variable properties.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec25"></a>Understanding enums</h4></div></div></div><p>An <span>enum</span><a id="id325581244" class="indexterm"></a> is a type that holds a finite set of predefined values. Enums are often used to represent a particular state or result of an operation. The best way to learn what this means is to look at an example of an <span>enum</span><a id="id325581251" class="indexterm"></a> that represents the state of a traffic light:</p><pre class="programlisting">struct TrafficLight {
  var state: TrafficLightState
  // ...
}

enum TrafficLightState {
  case green, yellow, red
}</pre><p>This sample shows a <code class="literal">TrafficLight</code> struct that has a <code class="literal">state</code> property. The type of this property is <code class="literal">TrafficLightState</code>, which is an enum. The <code class="literal">TrafficLightState</code> defines three possible states for a traffic light. This is very convenient because an enum such as this eliminates the possibility of a bad state because the compiler can now enforce that you never end up with an invalid value.</p><p>Enums can also contain properties and methods, just like structs can. However, an enum can also have an <span class="emphasis"><em>associated value</em></span>. This means that each possible case can have a representation in a different type, such as a <code class="literal">String</code>. If you modify <code class="literal">TrafficLightState</code> as shown here, it will have a <code class="literal">String</code> as its <code class="literal">rawValue</code>:</p><pre class="programlisting">enum TrafficLightState: String {
  case green, yellow, red
}</pre><p>If Swift can infer the raw value, you don't have to do anything more than add the type of the raw value to the enum's type declaration. In this sample, the raw value for the <code class="literal">green</code> enum case will be the "green" string. This can be convenient if you need to map your enum to a different type, for instance, to set it as a label's text.</p><p>Just like structs, enums cannot inherit <span>functionality</span><a id="id325581309" class="indexterm"></a> from other objects, but they can conform to protocols. You make an <span>enum</span><a id="id325333272" class="indexterm"></a> conform to a protocol with an extension, just like you would do for classes and structs.</p><p>This wraps up the exploration of value types. Now that you know what value types and reference types are, let's explore some of their differences!</p><p> </p><p> </p></div></div></div>