<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch24lvl1sec161"></a>Discovering slow code</h2></div></div><hr /></div><p>Whenever you find that your app is <span>slow</span><a id="id325333112" class="indexterm"></a> or choppy, there's a good chance that something in your code is taking longer than it should, especially if your memory usage appears to be within reasonable range. For instance, if your app uses less than 50 MB, memory is not likely to be an issue for your app, so seeking the problem in your code's performance makes a lot of sense.</p><p>To discover where your code is lacking in the performance department, it's a great idea to profile your app in Instruments, by either selecting <strong class="userinput"><code>Product</code></strong> | <strong class="userinput"><code>Profile</code></strong> in Xcode's toolbar or by pressing <span class="emphasis"><em>Cmd </em></span>+ <span class="emphasis"><em>I</em></span>. To figure out what the code is doing, you need to select the <strong class="userinput"><code>Time Profiler</code></strong> template when Instruments asks you which template you want to use. This template measures how long certain blocks of code take to run.</p><p>To record a profiling session of our app, make sure that a device is connected to your Mac and make sure that it's selected as the device that your app will run on by selecting your iOS device from the list of devices and simulators in the scheme toolbar menu in Xcode. Once you've selected your device, start profiling the app. When Instruments launches, pick the <strong class="userinput"><code>Time Profiler</code></strong> template and hit record. Now use the app to navigate to a collection and begin scrolling until the app starts acting choppy and scroll some more. After seeing the app stutter a couple of times, there should be enough data to begin filtering out what's going on. Press the stop button to stop the recording session.</p><p>If you take a look at the data Instruments has recorded, you'll notice a graph that has a bunch of peaks. This part of the timeline is marked CPU, and if you hit <span class="emphasis"><em>Cmd</em></span> + a couple of times to zoom in on this timeline, you'll notice that these spikes seem to last longer and longer as the scrolling becomes choppier and choppier. This is a great clue to investigate a bit more. Something must be going on that makes these peaks last longer <span>every</span><a id="id325333149" class="indexterm"></a> time they occur.</p><p>In the bottom section of the Instruments window, you'll find an overview of the code in the app that was executed while the recording session was active. The code is separated by thread and since you saw the user interface lagging, you can be pretty sure that something on the main thread is slow. If you drill down into the list of method calls by a couple of levels, you won't find much useful information. It doesn't even look like most of the executed code is part of the app's code, as you can see in the following screenshot:</p><p> </p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/f3a75a35-e91c-4563-a2e7-9f8e7fafa733.png" /></div><p>To make sure the code you're <span>interested</span><a id="id325369909" class="indexterm"></a> in is pulled to the surface, you should apply a couple of filtering options. If you click on the <strong class="userinput"><code>Call Tree</code></strong> button in the bottom of the window, you can select <strong class="userinput"><code>Invert Call Tree</code></strong> and <strong class="userinput"><code>Hide System Libraries</code></strong>:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/588d6b90-7067-4105-a58e-683585bf4e90.png" /></div><p></p><p>The <strong class="userinput"><code>Invert Call Tree</code></strong> option inverts the tree of method calls. The default tree starts at <code class="literal">main</code> and works its way down to the method calls in your app code. When you invert this tree, your app code will be at the top and works its way down to <code class="literal">main</code>. By checking <strong class="userinput"><code>Hide System Libraries</code></strong>, you make sure that all code shown in the detail view belongs to your app. The call tree is a lot more readable after applying this filter:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/6561dcb5-3fc8-4ce3-94e5-21811c201df7.png" /></div><p>When you examine the call tree, it's immediately clear that the issue is in the collection view layout. On the left side of the detail area, the percentage of time spent in a certain method is outlined, and you can see that a considerable portion of time is spent in <code class="literal">ListCollectionViewLayout.createSizeLookup()</code>. This method appears to be much slower than it should be.</p><p>It's probably tempting to <span>immediately</span><a id="id325580581" class="indexterm"></a> point at the <code class="literal">createSizeLookup()</code> method and call it slow. It would be hard to blame you if you did, that method is a pretty rough one because it's computing an entire layout. However, the layout should be computed pretty efficiently. Unfortunately, you can't prove this with the data in Instruments. If you could see the time that each method call takes, you would be able to verify the claim that <code class="literal">createSizeLookup()</code> is not slow.</p><p> </p><p>What can be proved, though, is that <code class="literal">createSizeLookup()</code> is called way more often than it should be. If you add a <code class="literal">print</code> statement at the start of this method, you'll see that there are hundreds of prints as you scroll through the list. If you dig deeper and figure out when <code class="literal">createSizeLookup()</code> is called exactly, you'll find two places:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">In <code class="literal">prepare()</code></li><li style="list-style-type: disc">In <code class="literal">rectForThumbAtIndex(_:)</code></li></ul></div><p>This is strange because <code class="literal">rectForThumbAtIndex(_:)</code> is called in a loop inside of the <code class="literal">prepare</code> method after the size lookup has already been generated.</p><p>More importantly, as the number of items in the collection grows, the number of items to loop over grows too. It's very likely that this extraneous call to <code class="literal">createSizeLookup()</code> is the source of the bug. You should be able to remove the call to <code class="literal">createSizeLookup()</code> from <code class="literal">rectForThumbAtIndex(_:)</code> without problems because the lookup is already created before the items are iterated, so it's safe to assume that the lookup exists when <code class="literal">rectForThumbsAtIndex(_:)</code> is called. Remove the call to <code class="literal">createSizeLookup()</code> and run your app on the device. Make sure to do plenty of scrolling to verify that the bug was fixed.</p><p>To make sure that everything is fixed, you should use Instruments again to see what the Time Profiler report looks like now. Start a new Time Profiler session in Instruments and repeat the steps you performed before. Navigate to a collection and scroll down for a while so the app loads lots of new pages.</p><p>Looking at the result of the measurements now, the percentage of time spent in <code class="literal">createSizeLookup()</code> has dramatically decreased. It has decreased so much that it's not even visible as one of the heaviest methods anymore. The app performs way better now and you have acquired the measurements to prove it.</p><p>Now that the scrolling <span>performance</span><a id="id325611497" class="indexterm"></a> issue is solved, you can navigate the app, and everything is working smoothly. But if you take a look at the memory usage in Xcode, the memory usage still goes up every time you navigate to a new item in the table view. This means that the app probably has another problem in the form of a memory leak. Let's see how to discover and fix this leak with Instruments and Xcode.</p><p> </p></div>