<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec57"></a>Understanding the Core Data Stack</h2></div></div><hr /></div><p>Before you dive right into the project and add <span>Core</span><a id="id325602483" class="indexterm"></a> Data to it, let's take a look at how Core Data actually works, what it is, and what it isn't. In order to make efficient use of Core Data, it's essential that you know what you're working with.</p><p>When you work with Core Data, you're actually utilizing a stack of layers that starts with managed objects and ends with a data store. This is often a SQLite database, but there are different storage options you can use with Core Data, depending on your application needs. Let's take a quick look at the layers involved with Core Data and discuss their roles in an application briefly:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/3a7f4c34-b12d-4b3e-80d4-054c77e44d50.png" /></div><p>At the top-right of this diagram is the <code class="literal">NSManagedObject</code> class. When you use Core Data, this is the object you'll interact with most often since it's the base class for all <span>Core</span><a id="id325602509" class="indexterm"></a> Data models your app contains. For instance, in the app you will build in this chapter, the family member and movie models are subclasses of <code class="literal">NSManagedObject</code>.</p><p>Each managed object belongs to an <code class="literal">NSManagedObjectContext</code>. The managed object context is responsible for communicating with the persistent store coordinator. Often, you'll only need a single managed object context and a single Persistent Store Coordinator. However, it is possible to use multiple persistent store coordinators and multiple managed object contexts. It's even possible to have multiple managed object contexts for the same persistent store coordinator.</p><p>A setup with multiple managed object contexts can be particularly useful if you're performing costly operations on your managed objects; for example, if you're importing or synchronizing large amounts of data. Usually, you will stick to using a single managed object context and a single persistent store coordinator because most apps don't needÂ more than one.</p><p>The persistent store coordinator is responsible for communicating with the persistent store. In most scenarios, the persistent store uses SQLite as its underlying storage database. However, you can also use other types of storage, such as an in-memory database. An in-memory database is especially useful if you're writing unit tests or if your app has no need for long-term storage. More information on testing can be found in <code class="literal">Chapter 23</code>, <span class="emphasis"><em>Ensuring App Quality with Tests</em></span>.</p><p>If you've worked with MySQL, SQLite, or any other relational database, it is tempting to think of Core Data as a layer on top of a relational database. Although this isn't entirely false since Core Data can use SQLite as its underlying storage, Core Data does not work the same as using SQLite directly; it's an abstraction on top of this.</p><p>One example of a difference between SQLite and <span>Core</span><a id="id325604099" class="indexterm"></a> Data is the concept of primary keys. Core Data doesn't allow you to specify your own primary keys. Also, when you define relationships, you don't use foreign keys. Instead, you simply define the relationship and Core Data will figure out how to store this relationship in the underlying database. You will learn more about this <span>later</span>. It's important to know that you should not directly translate your SQL experiences to Core Data. If you do, you will run into issues, simply because Core Data is not SQL. It just so happens that SQLite is one of the ways that data can be stored but the similarities really do end right there.</p><p>To recap, all core <span>data</span><a id="id325604115" class="indexterm"></a> apps have a <span class="strong"><strong>persistent store</strong></span>. This store is backed by an in-memory database or a SQLite database. A <span class="strong"><strong>persistent store coordinator</strong></span> is <span>responsible</span><a id="id325605900" class="indexterm"></a> for communicating with the <span class="strong"><strong><span>persistent</span> store</strong></span>. The object communicating with the <span class="strong"><strong>persistent store coordinator</strong></span> is the <span class="strong"><strong>managed object context</strong></span>. An <span>application</span><a id="id325606051" class="indexterm"></a> can have multiple <span class="strong"><strong>managed object context</strong></span> instances talking to the same <span class="strong"><strong>persistent store coordinator</strong></span>. The objects that a <span class="strong"><strong>managed object context</strong></span> retrieves from the <span class="strong"><strong>persistent store coordinator</strong></span> are <span class="strong"><strong>managed objects</strong></span>.</p><p>Now that you have an overview of the Core Data stack and where all the parts involved with its usage belong, let's add the Core Data stack to the <span class="strong"><strong>MustC</strong></span> application.</p></div>