<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch21lvl1sec143"></a>Increasing your app's visibility with Universal Links</h2></div></div><hr /></div><p>A Universal Link is very similar to a deep link. <strong class="userinput"><code>Deep links</code></strong><span>allow</span><a id="id325333116" class="indexterm"></a> apps to link users straight into a certain section of an application. Before Universal Links, developers had to use a custom URL scheme to create their deep links.</p><p>You might have seen a URL with a custom scheme in the past. These URLs are easily recognized and look as follows:</p><pre class="programlisting">mustc://FamilyMember/jack </pre><p>It's evident that this isn't a regular web URL because web URLs start with a scheme of either <code class="literal">http://</code> or <code class="literal">https://</code>. An application can register itself as capable of opening URLs with a certain scheme. So, the <strong class="userinput"><code>MustC</code></strong> app we've been working on could manifest itself as a handler of <code class="literal">mustc://</code><code class="literal">URLs</code>.</p><p>However, there are a couple of downsides to this approach. First and foremost, this URL isn't shareable at all. You can't send this URL to any friends that don't have the same app installed. If you were to send this URL to somebody and they didn't have the corresponding app installed, they wouldn't be able to open this URL. This is inconvenient because, for others to access the same content, assuming the content is publicly available on the web, users would have to share a different URL that points to the website. But sharing a link to the website usually means that the content is shown in Safari instead of the app, even if it's installed.</p><p>Another problem with custom URL schemes is that any app can register as being capable of opening a certain URL scheme. This means that you could create an application that registers as being capable of opening URLs with any scheme you can come up with and unfortunately, iOS offers the users no control over which application opens what URL scheme.</p><p>Universal Links were introduced in iOS 9 to solve all of the problems that exist with custom URL schemes and more. First of all, a <span>Universal</span><a id="id325369911" class="indexterm"></a> Link looks identical to a regular web link. A Universal Link is similar to a regular web link. If you've found a great news article on the web and you share it with somebody who has installed the app that belongs to the news website the link is from, the link will redirect straight to the corresponding app. Safari does not open intermediately; no attempts are made to redirect you from a web page to a custom URL scheme. The user merely is taken from the place where they tap the link, right to the app.</p><p>Also, not every app can register as capable of opening a Universal Link. Any app that claims to be able to open a certain Universal Link must be accompanied by the server that hosts the website. This means that, if your app claims to be able to open links from a certain domain, you must own that domain. Apple uses a verification file that you must host on the same domain that your app wants to handle links for, to make sure that your app does not try to open links on behalf of another app or website.</p><p>Apart from security benefits, Universal Links also provide a more unified, seamless experience for your users. With Universal Links, Apple didn't just open the door to a better, easier way to link to content inside your app; it also opened up an API that makes it easy for your app and website to share login information securely. Just like tying the links for your app and website together, you can also tie your app to the login credentials stored in Safari for your app. Any user that logs into your website through Safari can automatically be logged into your app.</p><p>Now that you're aware of the great features and possibilities of Universal Links, let's see how this all works on the server side.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch21lvl2sec113"></a>Preparing your server for Universal Links</h3></div></div></div><p>Setting up <span>Universal</span><a id="id325571682" class="indexterm"></a> Links on the server side has been made as <span>straightforward</span><a id="id325575089" class="indexterm"></a> as possible by Apple. All you have to do is host a file on your server that can prove the connection between your app and your server. This is done through a file called the <code class="literal">apple-app-site-association</code> file.</p><p>The <code class="literal">apple-app-site-association</code> file contains a dictionary of information that describes exactly how your app is tied to your site. Let's have a look at an example of an <code class="literal">apple-app-site-association</code> file. The example illustrates the implementation for a recipe app where users can browse and search recipes:</p><pre class="programlisting">{   
  "applinks": {   
    "apps": [],   
    "details": {   
      "6QA73RGQR2.com.donny.recipes": {   
        "paths": [   
          "/recipes/*/",   
          "/search/"   
        ]   
      }   
    }   
  }   
} </pre><p>Let's go over this configuration file bit by bit. Firstly, some mandatory dictionary keys are set up. The <code class="literal">applinks</code> key tells Apple that this part of the association file applies to Universal Links. Inside this key, an empty <code class="literal">apps</code> array is defined. This array does not need to have any content in it for a <span>simple</span><a id="id325580584" class="indexterm"></a> integration. The <code class="literal">details</code> key is a dictionary that contains the actual configuration.</p><p>Your app identifier <span>should</span><a id="id325580901" class="indexterm"></a> be added as a key for the <code class="literal">details</code> dictionary. The prefix you see in front of the app identifier is your team identifier. You can find your team identifier in the Apple Developer portal.</p><p>There is also a <code class="literal">paths</code> array inside the dictionary that's associated to the bundle identifier key. This array specifies all the paths on our website that your app should handle. Imagine that your website's base URL is <code class="literal">https://www.donnysrecipes.com/</code>. For this URL, <code class="literal">https://</code> is the scheme, <code class="literal">www.donnysrecipes.com</code> is the domain, and anything after the trailing <code class="literal">/</code> is called the path.</p><p>The example configuration handles the <code class="literal">/recipes/*/</code> and <code class="literal">/search/</code> paths. The <code class="literal">*</code> in <code class="literal">/recipes/*/</code> represents a wildcard value that could be anything. In other words, the config is set up to handle URLs such as <code class="literal">https://www.donnysrecipes.com/recipes/10/</code>, <code class="literal">https://www.donnysrecipes.com/recipes/20/</code>, or any other URL that looks similar.</p><p>The <code class="literal">/search/</code> path is a bit more interesting. No wildcard values were specified for this path, yet the app will be able to handle URLs such as <code class="literal">https://www.donnysrecipes.com/search/?q=macaroni</code>. That final part in the URL, <code class="literal">?q=macaroni</code>, is called the query string and you don't need to specify that you want to match on that because it's not part of the path.</p><p>Once you have <span>created</span><a id="id325604100" class="indexterm"></a> and configured your <code class="literal">apple-app-site-association</code> file, you need to upload it to your server. It's important that you host the association file in a way that makes it accessible on a URL similar to <code class="literal">https://www.donnysrecipes.com/apple-app-site-association</code>. In other words, the path to this verification file on your server should be <code class="literal">/apple-app-site-association</code>.</p><p>Now that the server is ready to <span>communicate</span><a id="id325605891" class="indexterm"></a> to Apple that your app can open links for your site, it's time to see how you can set up your app to handle Universal Links.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch21lvl2sec114"></a>Handling Universal Links in your app</h3></div></div></div><p>With all parts in place, you can <span>now</span><a id="id325606034" class="indexterm"></a> set your app up to handle Universal Links. In the previous sections of this chapter, a lot of work was done to handle user activities nicely. The setup you created for this will serve as a foundation for handling Universal Links.</p><p>Whenever an application is expected to open a Universal Link, the <code class="literal">application(_:open:options:)</code> method is called on <code class="literal">AppDelegate</code>. This method receives the URL it's expected to open. If the URL can't be opened, this method is expected to return <code class="literal">false</code>. If this method does manage to handle the URL, it should return <code class="literal">true</code>.</p><p>Any application that handles Universal Links must have the <strong class="userinput"><code>Associated Domains</code></strong> capability enabled in the Capabilities tab. To do this, go to the <strong class="userinput"><code>Capabilities</code></strong> tab in your project settings and allow <strong class="userinput"><code>Associated Domains</code></strong>. For every domain that you want to handle Universal Links for, you need to create a new <code class="literal">applinks:</code> entry. The following screenshot shows an example configuration:</p><p> </p><p> </p><p> </p><p> </p><p> </p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/1d64378f-5003-4a6e-9aaf-edd17a37c706.png" /></div><p>When the <code class="literal">application(_:open:options:)</code> you are <span>expected</span> to map the URL is passed to this method to a view in the application and take the user to that specific view. This process is <span>called</span><a id="id325607101" class="indexterm"></a> routing, and it's a well-known technique throughout programming languages and platforms.</p><p>Let's assume that your application received the following URL:</p><pre class="programlisting">https://www.familymoviesapp.com/familymember/dylan/ </pre><p>Just by looking at this URL, you probably have a vague idea of what should happen if an application is asked to open this URL. The user should be taken to a family member screen that shows the detail page for Dylan.</p><p>When you receive a URL such as this in <code class="literal">AppDelegate</code>, three separate parts exist on the URL. One is the <code class="literal">scheme</code>; this property tells you which URL scheme, for example <code class="literal">https://</code>, was used to navigate to the app. Usually, the scheme isn't relevant to your app unless you're handling multiple custom URL schemes. Second, there is the host, for example <code class="literal">example.com</code>. This property describes the domain that the URL belongs to. Again, this is usually not relevant unless your app handles links from multiple hosts. Finally, there is the <code class="literal">pathComponents</code> property. <code class="literal">pathComponents</code> is an array of components that are found in the path for the URL. Printing <code class="literal">pathComponents</code> for the example URL gives the following output:</p><pre class="programlisting">["/", "familymember", "dylan"]</pre><p>The first component can usually be ignored because it's just <code class="literal">/</code>. The second and third components are a lot more interesting. They tell you more about the route that needs to be resolved. Going back to the <strong class="userinput"><code>MustC</code></strong> example, you could handle URLs in that app easily with the code that already exists in <code class="literal">AppDelegate</code> to navigate to family member and movie pages. The following code shows how:</p><pre class="programlisting">func application(_ app: UIApplication, open URL: URL, options:
  [UIApplication.OpenURLOptionsKey : Any] = [:]) -&gt; Bool {
  let pathComponents = URL.pathComponents
  guard pathComponents.count == 3
    else { return false }

  switch(pathComponents[1], pathComponents[2]) {
  case ("familymember", let name):
    return handleOpenFamilyMemberDetail(withName: name)
  case ("movie", let name):
    return handleOpenMovieDetail(withName: name)
  default:
    return false
  }
}</pre><p>A switch with powerful pattern-matching is used to <span>check</span><a id="id325609928" class="indexterm"></a> whether the second component in the URL points to a family member or a movie and we parse the third component into a variable called <code class="literal">name</code>. If one of these matches, we call the existing methods; if nothing matches, we return <code class="literal">false</code> to indicate that we couldn't open the URL.</p><p>Earlier, you saw this URL: <code class="literal">https://www.donnysrecipes.com/search/?q=macaroni</code>. With <code class="literal">pathComponents</code>, you can easily gain access to the path of the URL. But how do you get the final part of the URL? Well, that's a little harder. You can get the <code class="literal">query</code> property for a URL, but then you get a single string in the form of <code class="literal">q=macaroni</code>. What you want is a dictionary where <code class="literal">q</code> is a key and <code class="literal">macaroni</code> is a value. The following extension on <code class="literal">URL</code> implements a naive method to create such a dictionary:</p><pre class="programlisting">extension URL {
  var queryDict: [String: String]? {
    guard let pairs = query?.components(separatedBy: "&amp;")
      else { return nil }

    var dict = [String: String]()

    for pair in pairs {
      let components = pair.components(separatedBy: "=")
      dict[components[0]] = components[1]
    }

    return dict
  }
}</pre><p>First, the query string is retrieved. Then the string is separated on the <code class="literal">&amp;</code> character because multiple key-value pairs in the query string are expected to be separated with that character. The code loops over the resulting array and separates each string on the <code class="literal">=</code> character. The first item in the resulting array is used as the dictionary key and the second item is the value. Each key and value are added to a dictionary, and finally, that dictionary is returned. This allows you to get the value for <code class="literal">q</code>, shown as follows:</p><pre class="programlisting">URL.queryDict!["q"] </pre><p>Great job! This is all that's needed to implement Universal Links in your app and to enhance discoverability for your users.</p></div></div>