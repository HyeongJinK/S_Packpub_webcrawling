<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec13"></a>UITableViewDelegate and interactions</h2></div></div><hr /></div><p>So far, the <code class="literal">ViewController</code> class has implemented the <code class="literal">UITableViewDelegate</code> protocol but none of the delegate methods have been implemented yet. Any time certain interactions occur on a table view, such as tapping a cell or swiping on a cell, the table view will attempt to call the corresponding delegate methods to inform the delegate about the action that occurred.</p><p>The <code class="literal">UITableViewDelegate</code> protocol does not specify any <span>required</span><a id="id325337432" class="indexterm"></a> methods, which is why it has been possible to conform to this protocol without actually doing work. Usually, you will want to implement at least one method from <code class="literal">UITableViewDelegate</code> because simply displaying a list without responding to any interactions is quite boring. Let's go ahead and explore some of the methods from <code class="literal">UITableViewDelegate</code> to create a better experience for <span class="strong"><strong>Hello-Contacts</strong></span>. If you take a look at the documentation for <code class="literal">UITableViewDelegate</code>, you'll notice that it has a large collection of delegate methods that you can implement in your app.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note5"></a>Note</h3><p>You can hold the <span class="emphasis"><em>Alt</em></span> key when clicking on a class, struct, enum, or protocol name to navigate to the documentation for the type you clicked on.</p></div><p>The documentation for <code class="literal">UITableViewDelegate</code> lists methods for configuring cell height, content-indentation level, cell-selection, and more. There are also methods that you can implement to get notified when the table view is about to display a cell or is about to stop displaying one. You can handle cell-selection, cell-highlighting, reordering cells, and even deleting them. One of the more common methods to implement is <code class="literal">tableView(_:didSelectRowAt:)</code>. After you have implemented this method, you'll also implement cell-reordering and -removal.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec7"></a>Responding to cell-selection</h3></div></div></div><p>Cell-selection refers to a user tapping on a cell. In order to respond to cell-selection, the <code class="literal">UITableViewDelegate</code> method called <code class="literal">tableView(_:didSelectRowAt:)</code> should be implemented. In <span class="strong"><strong>Hello-Contacts</strong></span>, <code class="literal">ViewController</code> already has an extension implemented to make it conform to <code class="literal">UITableViewDelegate</code> so all you need to do is implement <code class="literal">tableView(_:didSelectRowAt:)</code> in the extension.</p><p> </p><p> </p><p>Since a table view will call methods on its delegate <span>whenever</span><a id="id325337687" class="indexterm"></a> they are implemented, you don't need to tell the table view that you want to respond to cell-selection. This automatically works if the table view has a delegate, and if the delegate implements <code class="literal">tableView(_:cellForRowAt:)</code>. The implementation you'll add to <span class="strong"><strong>Hello-Contacts</strong></span>, for now, is a very simple one. When the user taps a cell, the app displays an alert. In <a class="link" href="#" linkend="ch03">Chapter 3</a>, <span class="emphasis"><em>Creating a Detail Page</em></span>, you will learn how to perform more meaningful actions such as displaying a detail page. Add the following code to the <code class="literal">UITableViewDelegate</code> extension in <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
  let contact = contacts[indexPath.row]
  let alertController = UIAlertController(title: "Contact tapped",
                                          message: "You tapped \(contact.givenName)",
                                          preferredStyle: .alert)

  let dismissAction = UIAlertAction(title: "Ok", style: .default, handler: { action in
    tableView.deselectRow(at: indexPath, animated: true)
  })

  alertController.addAction(dismissAction)
  present(alertController, animated: true, completion: nil)
}</pre><p>The <code class="literal">tableView(_:cellForRowAt:)</code> method receives two arguments, the first is the table view that called this delegate method. The second argument is the index path at which the selection occurred. The implementation you wrote for this method uses the index path to retrieve the contact that corresponds with the tapped cell so the contact name can be shown in an alert. You could also retrieve the contact's name from the tapped cell. However, this is not considered good practice because your cells and the underlying data should be as loosely-coupled as possible. When the user taps the <strong class="userinput"><code>Ok</code></strong> button in the alert, the table view is told to deselect the selected row. If you don't deselect the selected row, the last tapped cell will always remain highlighted. Note that the alert is displayed by calling <code class="literal">present(_:animated:completion:)</code> on the view controller. Any time you want to make a view controller display another view controller, such as an alert controller, you use this method.</p><p>Even though this setup is not extremely complex, there is some interesting stuff going on. The delegation pattern is a very powerful one when implemented correctly. Especially in the case of a table view, you can add a lot of functionality simply by implementing the delegate methods that correspond to the desired behavior. Because the table view's delegate could be any object that conforms to <code class="literal">UITableViewDelegate</code>, you could split up <code class="literal">ViewController</code> and <code class="literal">UITableViewDelegate</code> entirely. Doing so would enable you to reuse your delegate implementation across multiple table views. For now, I'll leave it as an exercise for you to do this. Attempting such a refactor will certainly help you to increase your understanding of delegation and its powers.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip6"></a>Note</h3><p>Try to extract your delegate and/or data source for the table view to a separate class or struct. This will allow you to reuse your code, and you will gain a deeper understanding of what delegation is and how it works.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec8"></a>Implementing cell-deletion</h3></div></div></div><p>Now that you know how to respond to cell-selection, let's have a look at a <span>slightly</span><a id="id325578352" class="indexterm"></a> more advanced topic – cell-deletion. Deleting data from a table view is a feature that many apps implement. If you have ever used the mail app on iOS, you might have noticed that several actions appear when a user swipes either right or left on a table-view cell. These swipe actions are a great feature to implement for <span class="strong"><strong>Hello-Contacts</strong></span> so users can swipe over contacts and easily delete them. Of course, we won't be actually deleting contacts from a user's address book, but it would be possible to implement this if you truly wanted to.</p><p>In this example, you'll learn how to delete contacts from the array of contacts that is used to populate the table view. To implement support for cell-deletion, you need to implement another method from <code class="literal">UITableViewDelegate</code>. The method you need to implement is <code class="literal">tableView(_:trailingSwipeActionsConfigurationForRowAt:)</code>. This <span>delegate</span> method is called when a user swipes over a table view cell and returns the actions should be shown when the cell moves sidewards. A good example of this is found in the mail app on iOS.</p><p> </p><p> </p><p>Add the following implementation of <code class="literal">tableView(_:trailingSwipeActionsConfigurationForRowAt:)</code> to the <code class="literal">UITableViewDelegate</code> extension for <code class="literal">ViewController</code>:</p><pre class="programlisting">func tableView(_ tableView: UITableView,
               trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {

  // 1
  let deleteHandler: UIContextualActionHandler = { [weak self] action, view, callback in
    self?.contacts.remove(at: indexPath.row)`
    callback(true)
  }

  // 2
  let deleteAction = UIContextualAction(style: .destructive,
                                        title: "Delete", handler: deleteHandler)

  // 3
  return UISwipeActionsConfiguration(actions: [deleteAction])
}</pre><p>If you run the app now and swipe from right to left over a table view cell, a delete button will appear from underneath the cell. In the code snippet, the first step is to set up a delete-handler that takes care of the actual deletion of the contact. This handler is a closure that is passed to the <code class="literal">UIContextualAction</code> instance that is created in step two. You have seen closures passed directly to method calls already, for instance as completion-handlers. However, you can also store a closure in a variable. This allows you to reuse your closure in several places and can make your code more readable. The third and last step is to create an instance on <code class="literal">UISwipeActionsConfiguration</code> and pass it the actions that you want to display. Since you can pass an array of actions, it is possible to show multiple actions when the user swipes over a cell. In this case, only a single action is added – the delete action.</p><p>Currently, tapping the delete button doesn't do much. While the contact is removed from the underlying data source, the table view itself doesn't update. Table views don't automatically stay in sync with their data sources. Add the following <code class="literal">deleteHandler</code> implementation to make sure the table view updates when the user taps the <strong class="userinput"><code>delete</code></strong> button:</p><pre class="programlisting">let deleteHandler: UIContextualActionHandler = { [weak self] action, view, callback in
  self?.contacts.remove(at: indexPath.row)
  self?.tableView.beginUpdates()
  self?.tableView.deleteRows(at: [indexPath], with: .fade)
  self?.tableView.endUpdates()
  callback(true)
}</pre><p>This new version of <code class="literal">deleteHandler</code> ensures that the table view updates itself by removing the row that the user has decided to remove. Note that the contacts array is updated before updating the table view. When you update the table view like this, it will verify that it is in sync with the data source, which is the contacts array in this case. If the data source does not contain the expected amount of sections or rows, your app will crash. So whenever you update a table view, make sure to update the data source first. Also, note the calls to <code class="literal">beginUpdates</code> and <code class="literal">endUpdates</code>. These methods make sure that the table view doesn't reload in the middle of being manipulated. This is especially useful if you're performing a lot of complex updates, such as moving cells, inserting new ones, and removing old ones all at the same time.</p><p>With cell-deletion out of the way, let's have a look at reordering cells.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec9"></a>Allowing the user to reorder cells</h3></div></div></div><p>In some applications, it makes sense for <span>users</span><a id="id325604100" class="indexterm"></a> to be able to reorder cells that are shown in a table view, such as in a to-do list application or a grocery list. Implementing cell-reordering takes a couple of steps. First, a table view needs to be put in editing mode. When a table view is in editing mode, the user can begin sorting cells visually. Typically, a button in the top right or left corner of the screen is used to enter and exit the editing mode. The easiest way to make space for a button is by wrapping your <code class="literal">ViewController</code> in a <code class="literal">UINavigationController</code>. Doing this makes a navigation bar appear at the top of the screen that has space for a title, back button, and also for custom buttons such as the <strong class="userinput"><code><span class="strong"><strong>Edit</strong></span></code></strong>/<strong class="userinput"><code><span class="strong"><strong>Done</strong></span></code></strong> button we need to make the table view enter and exit the editing mode.</p><p>Placing the table view in editing mode is actually really simple if you know how. Every <code class="literal">UIViewController</code> instance has a <code class="literal">setEditing(_:animated:)</code> method. If you override this method, you can use it as an entry point to call <code class="literal">setEditing(_:animated:)</code> on the table view so it enters edit mode. Once this is implemented, you need to implement <code class="literal">tableView(_:moveRowAt:to:)</code> from <code class="literal">UITableViewDelegate</code> to commit the reordered cells to your data source by updating the contacts array.</p><p>First, open <code class="literal">Main.storyboard</code> so you can wrap the view controller in a navigation controller. When you have selected the view controller in your storyboard, click <span class="strong"><strong><strong class="userinput"><code>Editor | <strong class="userinput"><code>Embed In</code></strong></code></strong></strong></span> | <span class="strong"><strong><strong class="userinput"><code><strong class="userinput"><code>Navigation Controller</code></strong></code></strong></strong></span> in the menu bar at the top of the screen. This will automatically embed the view controller in a navigation controller and configure everything as needed. To add the <strong class="userinput"><code><span class="strong"><strong>Edit</strong></span></code></strong>/<strong class="userinput"><code><span class="strong"><strong>Done</strong></span></code></strong> button, open <code class="literal">ViewController.swift</code> and add the following code to <code class="literal">viewDidLoad</code>:</p><pre class="programlisting">navigationItem.rightBarButtonItem = editButtonItem</pre><p>This line adds a <code class="literal">UIBarButtonItem</code> that automatically toggles itself and calls <code class="literal">setEditing(_:animated:)</code> on the view controller. Since it's set as <code class="literal">rightBarButtonItem</code>, it will appear on the right side of the navigation bar. If you go ahead and build the app now, you'll see that you have a button that toggles between a label that says <strong class="userinput"><code><span class="strong"><strong>Edit</strong></span></code></strong> and <strong class="userinput"><code><span class="strong"><strong>D</strong></span></code></strong><span class="strong"><strong><strong class="userinput"><code>one</code></strong></strong></span>. To put the table view in edit mode, you must override the <code class="literal">setEditing(_:animated:)</code> method in <code class="literal">ViewController.swift</code>, as follows:</p><pre class="programlisting">override func setEditing(_ editing: Bool, animated: Bool) {
  super.setEditing(editing, animated: animated)

  tableView.setEditing(editing, animated: animated)
}</pre><p>What this method does should be self-explanatory. Go ahead and run the app now. If you tap the <span class="strong"><strong><strong class="userinput"><code>Edit</code></strong></strong></span> button, every cell suddenly displays a red circle – while this is interesting, it's not quite what's needed. Cells don't show reorder controls when in edit mode by default. Open <code class="literal">Main.storyboard</code> again and select your prototype cell. In the <strong class="userinput"><code><span class="strong"><strong>Attributes inspector</strong></span></code></strong>, you'll find a checkbox named <span class="strong"><strong><strong class="userinput"><code>Shows Re-order controls</code></strong></strong></span>. You want to make sure this checkbox is checked so you can reorder cells.</p><p>The final step to implementing this <span>feature</span><a id="id325337580" class="indexterm"></a> is adding <code class="literal">tableView(_:moveRowAt:to:)</code> in the <code class="literal">UITableViewDelegate</code> extension in <code class="literal">ViewController.swift</code>. This method will make sure that the contacts array is updated in the same way the cells are, ensuring that the table view and data source remain nicely in sync. Add the following code to the <code class="literal">UITableViewDelegate</code> extension in <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
  let contact = contacts.remove(at: sourceIndexPath.row)
  contacts.insert(contact, at: destinationIndexPath.row)
}</pre><p>Even though it's only two lines, this code updates the data source by moving a contact from its old position in the array to its new position. You now have everything in place to correctly reorder cells in a table view. Go ahead and try it out!</p></div></div>