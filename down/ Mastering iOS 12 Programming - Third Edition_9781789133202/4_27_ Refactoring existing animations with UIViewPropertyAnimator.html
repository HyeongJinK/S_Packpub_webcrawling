<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec32"></a>Refactoring existing animations with UIViewPropertyAnimator</h2></div></div><hr /></div><p>So far, you have seen <span>animations</span><a id="id325333345" class="indexterm"></a> that were implemented using the <code class="literal">UIView.animate</code> method. These <span>animations</span><a id="id325333356" class="indexterm"></a> are quite simple to implement and mostly follow the following format:</p><pre class="programlisting">UIView.animate(withDuration: 1.5, animations:   
{   
    myView.backgroundColor = UIColor.red()   
}) </pre><p>You have already seen this method implemented in slightly more complex ways, including one that used a closure that was executed upon completion of the animation. For instance, when a user taps on one of the contacts in the <span class="strong"><strong>Hello-Contacts</strong></span> app, the following code is used to animate a bounce effect:</p><pre class="programlisting">UIView.animate(withDuration: 0.1, delay: 0, options: [.curveEaseOut], animations:   
{  
    cell.contactImage.transform = CGAffineTransform(scaleX: 0.9, y:   
    0.9)  
}, completion: { finished in  
    UIView.animate(withDuration: 0.1, delay: 0, options:   
    [.curveEaseIn], animations:   
{  
        cell.contactImage.transform = CGAffineTransform.identity  
    }, completion: { [weak self] finished in  
        self?.performSegue(withIdentifier: "detailViewSegue", sender: self)  
    })  
})</pre><p>It's not particularly pleasing to look at this code. The <span>indentation</span><a id="id325606076" class="indexterm"></a> is all over the place, and a lot is going on in a dense piece of code. If you dissect this code, you will find that the entire animation was implemented in a single method call. While this might be <span>convenient</span><a id="id325606085" class="indexterm"></a> for small animations, it's not very readable. This is especially true if the animation is more complex or if you want to chain several animations, which is the case for the preceding bounce animation.</p><p>One reason to favor <code class="literal">UIViewPropertyAnimator</code> over the implementation you just saw is readability. Let's see what the same bounce animation looks like when it's refactored to use <code class="literal">UIViewPropertyAnimator</code>:</p><pre class="programlisting">// 1
let downAnimator = UIViewPropertyAnimator(duration: 0.1, curve: .easeOut) {  
    cell.contactImage.transform = CGAffineTransform(scaleX: 0.9, y: 0.9)  
}  

let upAnimator = UIViewPropertyAnimator(duration: 0.1, curve: .easeIn) {  
    cell.contactImage.transform = CGAffineTransform.identity  
}  

// 2
downAnimator.addCompletion { _ in  
    upAnimator.startAnimation()  
}  

upAnimator.addCompletion { [weak self] _ in  
    self?.performSegue(withIdentifier: "detailViewSegue", sender: self)  
}  

// 3
downAnimator.startAnimation()</pre><p>The first thing you should notice is how much longer this code is. The old implementation was only 9 lines, the new one is 17 lines if you count all the blank lines. The second thing you'll notice is how much more readable the code has become. Code readability is something you should never underestimate. You can write great code, but if you come back to it a week later and find yourself struggling with that great piece of code due to bad readability, your code suddenly isn't as great as it was when you first wrote it.</p><p>While it's great that <code class="literal">UIViewPropertyAnimator</code> makes your code more readable, it still doesn't teach you much about animations. Let's dissect the preceding implementation to see what's happening.</p><p>The first section of the <span>preceding</span><a id="id325607107" class="indexterm"></a> code is all about <span>creating</span><a id="id325607115" class="indexterm"></a> instances of <code class="literal">UIViewPropertyAnimator</code>. The <code class="literal">UIViewPropertyAnimator</code> class has several initializers. The simplest initializer takes no arguments, the duration property can be set later, and by calling the <code class="literal">addAnimation</code> method, new animations can be added to the animator. However, that version of the animator would be too basic for <span class="strong"><strong>Hello-Contacts</strong></span>.</p><p> </p><p>The example code uses a version of <code class="literal">UIViewPropertyAnimator</code> that accepts a timing function to make the final bounce animation more lively. If you look at the sample code, the first argument passed to the <code class="literal">UIViewPropertyAnimator</code> initializer is the duration of the animation in seconds. The second argument controls the timing function. A timing function describes how an animation should progress over time. For instance, the <code class="literal">easeIn</code> option describes how an animation starts off at a slow pace and speeds up over time. The following diagram describes some of the most commonly used timing functions:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/b5d37ae3-2159-411f-8f26-493e12181617.png" /></div><p>In these graphs, the <span class="emphasis"><em>horizontal</em></span> axis represents the animation's progress. For each graph, the animation timeline is described from left to right on the x-axis. The animation's progress is visualized on the y-axis from bottom to top. At the bottom-left point, the animation hasn't started yet. At the right of the graph, the animation is completely done. The vertical axis represents time.</p><p>The final argument that is passed to the <code class="literal">UIViewPropertyAnimator</code> initializer is an optional argument for the animation that you wish to execute. This is quite similar to the <code class="literal">UIView.animate</code> way of doing things; the most significant difference is that you can add more <span>animations</span><a id="id325609940" class="indexterm"></a> after creating the animator, meaning that <code class="literal">nil</code> can be passed as the argument for the animations and you can add <span>animations</span><a id="id325611490" class="indexterm"></a> you wish to execute at a later time. This is quite powerful because you're even allowed to add new animations to <code class="literal">UIViewPropertyAnimator</code> while an animation is running!</p><p>The second section in the sample code you saw earlier adds completion closures to the animators. The completion closures both receive a single argument. The received argument describes at what point in the animation the completion closure was called. This property will usually have a value of <code class="literal">.end</code>, which indicates that the animation ended at the end position. However, this isn't always true because you can finish animations halfway through the animation if you desire. You could also reverse an animation, meaning that the completion position would be <code class="literal">.start</code>.</p><p> </p><p> </p><p>Once the completion closure is added, and the property animators are fully configured, the final step is to start the animation by calling <code class="literal">startAnimation()</code> on an animator object. Once the <code class="literal">startAnimation()</code> method is called, the animation begins executing immediately. If needed, you can make the animation start with a delay by calling <code class="literal">startAnimation(afterDelay:)</code>.</p><p>After replacing the animation in <code class="literal">collectionView(_:didSelectItemAt:)</code> with the <code class="literal">UIViewPropertyAnimator</code> version of the tap animation, you should be able to replace the remaining <code class="literal">UIView.animate</code> animations in the project. There are two animations in <code class="literal">ViewController.swift</code> that are used to animate the changing background color for the collection-view cell when you enter or exit edit mode.</p><p>There are also two <span>animations</span><a id="id325615336" class="indexterm"></a> in <code class="literal">ContactDetailViewController.swift</code> that you <span>could</span><a id="id325617704" class="indexterm"></a> replace. However, this animation is so short and simple that creating an instance of <code class="literal">UIViewPropertyAnimator</code> for it might be a bit much. However, as an exercise, it would be nice to try to find the simplest implementation possible to replace the <code class="literal">UIView.animate</code> calls in the <code class="literal">ContactDetailViewController</code> class.</p><p>Refer to this book's code bundle if you get stuck replacing the animations or want to see the solution to this challenge.</p></div>