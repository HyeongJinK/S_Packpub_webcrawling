<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec35"></a>Adding dynamism with UIKit Dynamics</h2></div></div><hr /></div><p>Most apps <span>implement</span><a id="id325333130" class="indexterm"></a> simple animations, like the ones you <span>saw</span><a id="id325333139" class="indexterm"></a> in the last couple of sections. However, some animations might need even more realism. This is what UIKit Dynamics is for. With UIKit Dynamics, you can place one or more views in a scene that uses a physics engine to apply certain forces to the views it contains. For instance, you can apply gravity to a particular object, causing it to fall off the screen. You can even have objects bumping into each other, and if you assign a mass to your views, this mass is taken into account when two objects crash into each other. When you apply a certain force to an object with very little mass, it will be displaced more than an object with a lot of mass, just like you would expect in the real world.</p><p>Let's take a little break from building <span class="strong"><strong>Hello-Contacts</strong></span> and use a separate app to implement a nice, little physics experiment! Create a new project and name it <strong class="userinput"><code>Cradle</code></strong>. Make sure to configure the project so it only runs in landscape orientation. In <code class="literal">Main.storyboard</code>, make sure to set the preview to landscape and add three square views to the view controller's view. Make each view about 100 x 100 points and give them a background color. Normally, you would set up constraints to position these views. However, since you're just experimenting right now and the resulting code will be a lot simpler if you don't set up constraints, you can skip setting up constraints for now.</p><p> </p><p>Your layout should look similar to the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/e5e636e5-29a9-4a88-bbef-bc5d82339329.png" /></div><p>Create instances of <code class="literal">@IBOutlet</code> in <code class="literal">ViewController.swift</code> for the views you just added and connect them to the storyboard in the same way you did before. You can name the outlets <code class="literal">square1</code>, <code class="literal">square2</code>, and <code class="literal">square3</code> if you want to follow along with the code samples.</p><p>The simplest thing you can <span>implement</span><a id="id325333390" class="indexterm"></a> at this point is to set up a scene that <span>contains</span><a id="id325333399" class="indexterm"></a> the three squares and apply some gravity to them. This will cause the squares to fall off the screen because they'll start falling once gravity is applied and there is no floor to stop the squares from dropping off the screen.</p><p>To set up a scene like the one described here, add the following property to <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">var animator: UIDynamicAnimator!</pre><p>Then, in <code class="literal">viewDidLoad()</code>, add the following:</p><pre class="programlisting">override func viewDidLoad() {  
  super.viewDidLoad()  

  let squares: [UIDynamicItem] = [square1, square2, square3]  
  animator = UIDynamicAnimator(referenceView: view)  
  let gravity = UIGravityBehavior(items: squares)  
  animator.addBehavior(gravity)  
}</pre><p>If you test your app now, you'll notice that your views start falling immediately. Setting up a simple scene such as this is easy with UIKit Dynamics. The downside of this simple example is that it's not particularly interesting to look at. Before you add features to make this sample more interesting, let's see what the preceding four lines of code do.</p><p> </p><p>The views in a dynamic scene must be of the <code class="literal">UIDynamicItem</code> type. <code class="literal">UIView</code> can be used as <code class="literal">UIDynamicItem</code>, so by adding them to a list that has <code class="literal">[UIDynamicItem]</code> works automatically. Then, you create an instance of <code class="literal">UIDynamicAnimator</code> and you tell it the view to which it will apply its physics engine. The last step is to configure and apply a behavior. This sample uses <code class="literal">UIGravityBehavior</code> but there are several other behaviors you can use in your scenes.</p><p>For instance, you can create <code class="literal">UIAttachmentBehavior</code> to attach an item to another item or to some point on the screen. The following code implements an attachment behavior for every square on the screen and attaches it to the top of the screen. This will cause the squares to fall for a moment and then they will bounce and swing a little until they eventually come to a standstill. You can add the following code to <code class="literal">viewDidLoad()</code> to implement this:</p><pre class="programlisting">var nextAnchorX = 250

for square in squares {
  let anchorPoint = CGPoint(x: nextAnchorX, y: 0)
  nextAnchorX -= 30
  let attachment = UIAttachmentBehavior(item: square, attachedToAnchor: anchorPoint)
  attachment.damping = 0.7
  animator.addBehavior(attachment)
}</pre><p>Every square is set up with a slightly different attachment point in this example. Note that the attachment behavior has a <code class="literal">damping</code> property. This damping is similar to the damping that is used in spring animations. Try experimenting with the value for <code class="literal">attachment.damping</code> to see what it does.</p><p>If you run the app now, you'll note that every square is attached to an invisible point on the screen that keeps it from falling. Some things are still missing though. The squares can now simply cross over each other. It would be a lot cooler if they bumped into each other instead.</p><p>All you need to do is add the following two lines to <code class="literal">viewDidLoad()</code>:</p><pre class="programlisting">let collisions = UICollisionBehavior(items: squares)  
animator.addBehavior(collisions)</pre><p>Are you convinced that UIKit Dynamics are cool yet? I thought so; it's amazing how much you can do with just a little bit of code. Let's add some mass to the squares and make them more elastic to see whether this has any effect on how the squares collide.</p><p> </p><p>Update the <code class="literal">for</code> loop from before by adding the following code:</p><pre class="programlisting">for square in squares {  
  //…  

  let dynamicBehavior = UIDynamicItemBehavior()  
  dynamicBehavior.addItem(square)  
  dynamicBehavior.density = CGFloat(arc4random_uniform(3) + 1)  
  dynamicBehavior.elasticity = 0.8  
  animator.addBehavior(dynamicBehavior)  
}</pre><p>The preceding code <span>should</span><a id="id325607110" class="indexterm"></a> augment what you already <span>have</span><a id="id325607118" class="indexterm"></a> in the loop; it shouldn't replace the existing logic. By setting a <code class="literal">density</code> on <code class="literal">UIDynamicItemBehavior</code>, the engine can derive the mass of an item. This will change how the physics engine treats the item when it collides with another item.</p><p>If you build and run now, you won't see a huge difference. However, you can tell that the animation has changed because the variables that go into the physics simulation have changed. Even though this example was very simple, you should be able to implement some interesting behaviors by creating an animator and playing around with the different behaviors you can add to it. Have a look at Apple's documentation for a full overview of all available behaviors and possibilities.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note20"></a>Note</h3><p>Even though the UIKit Dynamics physics engine is powerful and performant, you should not use it to build games. If you want to build a game, have a look at SpriteKit. It has a similar, powerful physics engine except the framework is a lot better optimized for building games.</p></div><p>The last stop on your journey through animation land is view-controller transitions! Let's dive right in.</p></div>