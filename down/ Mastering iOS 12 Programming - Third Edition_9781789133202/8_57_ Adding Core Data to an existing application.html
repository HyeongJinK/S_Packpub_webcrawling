<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec58"></a>Adding Core Data to an existing application</h2></div></div><hr /></div><p>When you create a new project in Xcode, Xcode asks whether you want to add <span>Core</span><a id="id325333110" class="indexterm"></a> Data to your application. If you check this checkbox, Xcode will automatically generate some boilerplate code that sets up the Core Data stack. For practicing purposes, <span class="strong"><strong>MustC</strong></span> was set up without Core Data so you'll have to add this to the project yourself. Start by opening <code class="literal">AppDelegate.swift</code> and add the following <code class="literal">import</code> statement:</p><pre class="programlisting">import CoreData </pre><p>Next, add the following <code class="literal">lazy</code> variable to the implementation of <code class="literal">AppDelegate</code>:</p><pre class="programlisting">private lazy var persistentContainer: NSPersistentContainer = {
      let container = NSPersistentContainer(name: "MustC")
      container.loadPersistentStores(completionHandler: { (storeDescription, error) in
        if let error = error {
          fatalError("Unresolved error (error), (error.userInfo)")
        }
      })
      return container
  }()</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Note</h3><p>If you declare a variable as <code class="literal">lazy</code>, it won't be initialized until it is accessed. This is particularly useful for variables that are expensive to initialize, rely on other objects, or are not always accessed. The fact that the variable is initialized just in time comes with a performance penalty since the variable needs to be set up the first time you access it. In certain cases this is fine, but in other cases, it might negatively impact the user experience. When used correctly, <code class="literal">lazy</code> variables can offer great benefits.</p></div><p>The preceding code snippet creates an instance of <code class="literal">NSPersistentContainer</code>. The persistent container is a container for the persistent store coordinator, persistent store, and managed object context. This single object manages different parts of the Core Data stack, and it ensures that everything is set up and managed correctly.</p><p>If you let Xcode generate the <span>Core</span><a id="id325369899" class="indexterm"></a> Data code for your app, it adds a similar property to create an <code class="literal">NSPersistentContainer</code>. Xcode also adds a method called <code class="literal">saveContext()</code> to <code class="literal">AppDelegate</code>. This method is used in <code class="literal">applicationWillTerminate(_:)</code> to perform a last-minute save of changes and updates when the application is about to terminate. Since you're setting up Core Data manually, this behavior isn't added by Xcode so it must be added by you manually.</p><p>Instead of placing the <code class="literal">saveContext()</code> method in <code class="literal">AppDelegate</code>, you will add this method as an extension to <code class="literal">NSPersistentContainer</code>. This makes it easier for other parts of your code to use this method, without having to rely on <code class="literal">AppDelegate</code>.</p><p>Create a new folder in the <strong class="userinput"><code>Project Navigator</code></strong> and name it <code class="literal">Extensions</code>. Also, create a new Swift file and name it <code class="literal">NSPersistentContainer.swift</code>. Add the following implementation to this file:</p><pre class="programlisting">import CoreData

extension NSPersistentContainer {
  func saveContextIfNeeded() {
    if viewContext.hasChanges {
      do {
        try viewContext.save()
      } catch {
        let nserror = error as NSError
        fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
      }
    }
  }
} </pre><p>This code adds a new method to <code class="literal">NSPersistentContainer</code> instances by extending it. This is really convenient because it decouples the save method from <code class="literal">AppDelegate</code> entirely. This is much nicer than the default save mechanism provided for Core Data apps by Xcode. Add the following implementation of <code class="literal">applicationWillTerminate(_:)</code> to <code class="literal">AppDelegate</code> to save the context right before the app terminates:</p><pre class="programlisting">func applicationWillTerminate(_ application: UIApplication) {   
    persistentContainer.saveContextIfNeeded()   
}</pre><p>Now, whenever the application terminates, the persistent store will check whether there are any changes to the managed object context that the <code class="literal">viewContext</code> property points to. If there are any changes, an attempt to save them is made. If this attempt fails, the app will crash with a <code class="literal">fatalError</code>. In your own app, you might want to handle this scenario a bit more gracefully. It could very well be that failing to save data before the app terminates is no reason to crash in your app. You can modify the error-handling implementation of <code class="literal">saveContextIfNeeded()</code> if you think a different behavior is more appropriate for your app.</p><p>Now that you have the <span>Core</span><a id="id325602477" class="indexterm"></a> Data stack set up, you need a way to provide this stack to the view controllers in the app. A common technique to achieve this is <span>called</span><span class="emphasis"><em>dependency injection</em></span>. In this case, dependency injection means that <code class="literal">AppDelegate</code> will pass the persistent container to <code class="literal">FamilyMemberViewController</code>, which is the first view controller in the app. It then becomes the job of <code class="literal">FamilyMemberViewController</code> to pass the persistent container to the next view controller that depends on it, and so forth.</p><p>In order to inject the persistent container, you need to add a property to <code class="literal">FamilyMembersViewController</code> that holds the persistent container. Don't forget to import Core Data at the top of the file and add the following code:</p><pre class="programlisting">var persistentContainer: NSPersistentContainer!</pre><p>Now, in <code class="literal">AppDelegate</code>, modify the <code class="literal">application(_:didFinishLaunchingWithOptions:)</code> method as follows:</p><pre class="programlisting">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {

  if let navVC = window?.rootViewController as? UINavigationController,
    let initialVC = navVC.viewControllers[0] as? FamilyMembersViewController {

    initialVC.persistentContainer = persistentContainer
  }

  return true
} </pre><p>Even though this code does exactly what it should, you can make one major improvement. You know that there might be more view controllers that depend on a persistent container. You also learned that checking whether something is a certain type is something you should generally avoid. As an exercise, attempt to improve the code by adding a protocol called <code class="literal">PersistenContainerRequiring</code>. This protocol should add a requirement for an implicitly-unwrapped <code class="literal">persistentContainer</code> property. Make sure that <code class="literal">FamilyMembersViewController</code> conforms to this protocol and fix the implementation of <code class="literal">application(_:didFinishLaunchingWithOptions:)</code> as well so it uses your new protocol.</p><p>You have just put down the foundation that is required to use <span>Core</span><a id="id325611550" class="indexterm"></a> Data in your app. Before you can use Core Data and store data in it, you must define what data you would like to save by creating your data model. <span>Let's go over how to do this next</span>.</p></div>