<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec66"></a>Working with JSON in Swift</h2></div></div><hr /></div><p>The following snippet shows how you can convert raw data to a JSON dictionary. Working with <span>JSON</span><a id="id325333110" class="indexterm"></a> in Swift can be a little tedious at times, but overall, it's an alright experience. Let's look at an example:</p><pre class="programlisting">guard let data = data,   
  let json = try? JSONSerialization.jsonObject(with: data, options: [])   
  else { return }   

print(json) </pre><p>The preceding snippet converts the raw data that is returned by a URL request to a JSON object. The print statement prints a readable version of the response data, but it's not quite ready to be used. Let's see how you gain access to the first available movie in the response.</p><p>If you look at the type of object returned by the <code class="literal">jsonObject(with:options:)</code> method, you'll see that it returns <code class="literal">Any</code>. This means that you must typecast the returned object to something you can work with, such as an array or a dictionary. When you inspect the JSON response that the API returned, for instance by using print to make it appear in the console like you did with Apple's homepage HTML, you'll notice that there's a dictionary that has a key called <code class="literal">results</code>. The <code class="literal">results</code> object is an array of movies. In other words, it's an array of <code class="literal">[String: Any],</code> because every movie is a dictionary, where strings are the keys and the value can be a couple of different things, such as <code class="literal">Strings</code>, <code class="literal">Int</code>, or <code class="literal">Booleans</code>. With this information, you can access the first movie's title in the <span>JSON</span><a id="id325333154" class="indexterm"></a> response, as shown in the following code:</p><pre class="programlisting">guard let data = data,
  let json = try? JSONSerialization.jsonObject(with: data, options: []),
  let jsonDict = json as? [String: AnyObject],
  let resultsArray = jsonDict["results"] as? [[String: Any]]
  else { return }

let firstMovie = resultsArray[0]
let movieTitle = firstMovie["title"] as! String
print(movieTitle)</pre><p>Working with dictionaries to handle JSON isn't the best experience. Since the JSON object is of the <code class="literal">AnyObject</code> type and you need to typecast every element in the dictionary you want to access, there's a lot of boilerplate code you need to add. Luckily, Swift has better ways to create instances of objects from the JSON data. The following example shows how you can quickly create an instance of a <code class="literal">Movie</code> struct without having to cast all the keys in the <span>JSON</span><a id="id325357384" class="indexterm"></a> dictionary to the correct types for the <code class="literal">Movie</code> struct.</p><p>First, let's define two structs, one for the <code class="literal">Movie</code> itself, and one for the response that contains the array of <code class="literal">Movie</code> instances:</p><pre class="programlisting">struct MoviesResponse: Codable {
  let results: [Movie]
}

struct Movie: Codable {
  let id: Int
  let title: String
  let popularity: Float
}</pre><p>Next, you can use the following snippet to quickly convert the raw data from a URL request to an instance of <code class="literal">MoviesResponse</code>, where all movies are converted to instances of the <code class="literal">Movie</code> struct:</p><pre class="programlisting">let decoder = JSONDecoder()  
guard let data = data,  
    let movies = try? decoder.decode(MoviesResponse.self, from: data)  
    else { return }  

print(movies.results[0].title)</pre><p>You might notice that both <code class="literal">MoviesResponse</code> and <code class="literal">Movie</code> conform to the <code class="literal">Codable</code> protocol. The <code class="literal">Codable</code> protocol was introduced in Swift 4, and it allows you to easily encode and decode data objects. The only requirement is that all properties of a <code class="literal">Codable</code> object conform to the <code class="literal">Codable</code> protocol. A lot of built-in types, such as <code class="literal">Array</code>, <code class="literal">String</code>, <code class="literal">Int</code>, <code class="literal">Float</code>, and <code class="literal">Dictionary</code> conform to <code class="literal">Codable</code>. Because of this, you can easily convert an encoded JSON object into a <code class="literal">MoviesResponse</code> instance that holds <code class="literal">Movie</code> instances.</p><p>By default, each property name should correspond to the key of the <span>JSON</span><a id="id325575089" class="indexterm"></a> response it is mapped to. However, sometimes you might want to customize this mapping. For instance, the <code class="literal">poster_path</code> property in the response we've been working with so far would be best mapped to a <code class="literal">posterPath</code> property on the <code class="literal">Movie</code> struct. The following example shows how you would tackle these circumstances:</p><pre class="programlisting">struct Movie: Codable {  

    enum CodingKeys: String, CodingKey {  
        case id, title, popularity  
        case posterPath = "poster_path"  
    }  

    let id: Int  
    let title: String  
    let popularity: Float  
    let posterPath: String?  
}</pre><p>By specifying a <code class="literal">CodingKeys</code> enum, you can override how the keys in the <span>JSON</span><a id="id325580579" class="indexterm"></a> response should be mapped to your <code class="literal">Codable</code> object. You must cover all keys that are mapped, including the ones you don't want to change. As you've seen, the <code class="literal">Codable</code> protocol provides powerful tools for working with data from the network. Custom key mapping makes this protocol even more powerful because it allows you to shape your objects exactly how you want them instead of having the URL responses dictate the structure to you.</p><p>If the only conversion you need to apply in the coding keys is converting from snake case (<code class="literal">poster_path</code>) to camel case (<code class="literal">posterPath</code>), you don't have to specify the coding keys yourself. The <code class="literal">JSONEncoder</code> object can automatically apply this type of conversion when decoding data if you set its <code class="literal">keyDecodingStrategy</code> to <code class="literal">.convertFromSnakeCase</code>, as shown in the following code:</p><pre class="programlisting">let decoder = JSONDecoder()
decoder.keyDecodingStrategy = .convertFromSnakeCase</pre><p>Try implementing this in your playground and remove <code class="literal">CodingKeys</code> from the <code class="literal">Movie</code> object to ensure your JSON decoding still works.</p><p>Now let's move on to storing fetched data in the Core Data database.</p><p> </p><p> </p></div>