<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec11"></a>Fetching a user's contacts</h2></div></div><hr /></div><p>The introductory section of this <span>chapter</span><a id="id325337651" class="indexterm"></a> informed you that you would use <code class="literal">Contacts.framework</code> to retrieve that app user's contacts and show this in a table view. To display a list of contacts, you must have access to the user's address book. Apple does a great job of protecting the user's privacy, so you can't read any of their contacts' data without asking the user for permission. Similar restrictions apply to access the user's camera, location, photos, and more.</p><p>Whenever you need access to privacy-sensitive information, you are required to specify this in your app's <code class="literal">Info.plist</code> file. This file keeps track of many of your app's properties, such as its display name, supported interface orientations, and, in the case of accessing a user's contacts, <code class="literal">Info.plist</code> also contains information about why you need access to the user's contacts.</p><p>To add this information to <code class="literal">Info.plist</code>, open it from the list of files in the <span class="strong"><strong><strong class="userinput"><code>Project Navigator</code></strong></strong></span> on the left. Once opened, hover over the word <strong class="userinput"><code><span class="strong"><strong>Information Property List</strong></span></code></strong> at the top of the file. A plus icon should appear, clicking it adds a new empty item with a search field to the list. When you begin typing <code class="literal">Privacy – contacts</code>, Xcode will filter out options for you until there is only one left for you to pick. This option, called <strong class="userinput"><code>Privacy – Contacts Usage Description</code></strong>, is the correct option to choose for this case. The value for this newly-added key should describe the reason that you need access to the specified piece of information for. In this case, <span class="emphasis"><em>reads c</em></span><span class="emphasis"><em>ontacts and shows them in a list</em></span> should be sufficient explanation. When the user is asked for permission to access their contacts, the reason you specified here will be shown, so make sure you add an informative message.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note3"></a>Note</h3><p>Whenever you need access to photos, Bluetooth, the camera, and the microphone, make sure to check whether a privacy key in <code class="literal">Info.plist</code> is required. If you don't provide this key, your app will crash and will not make it past Apple's review process.</p></div><p>Now that you have configured your app so it <span>specifies</span><a id="id325369912" class="indexterm"></a> that it wants to access contact data, let's get down to writing some code. Before you can read contacts, you must make sure that the user has given the appropriate permissions for you to access contact data. To do this, the code must first read the current permission status. Once this is done, the user must either be prompted for permission to access contacts, or the contacts must be fetched. Add the following code to <code class="literal">ViewController.swift</code>, we'll cover the details for this code after you have implemented it:</p><pre class="programlisting">import UIKit
// 1
import Contacts

class ViewController: UIViewController {

  override func viewDidLoad() {
    super.viewDidLoad()

    let store = CNContactStore()
    let authorizationStatus = CNContactStore.authorizationStatus(for: .contacts)

    // 2
    if authorizationStatus == .notDetermined {
      // 3
      store.requestAccess(for: .contacts) { [weak self] didAuthorize, 
      error in
        if didAuthorize {
           self?.retrieveContacts(from: store)
        }
      }
    } else if authorizationStatus == .authorized {
        retrieveContacts(from: store)
    }
  }

  func retrieveContacts(from store: CNContactStore) {
    let containerId = store.defaultContainerIdentifier()
    let predicate = CNContact.predicateForContactsInContainer(withIdentifier: containerId)
    // 4
    let keysToFetch = [CNContactGivenNameKey as CNKeyDescriptor,
                       CNContactFamilyNameKey as CNKeyDescriptor,
                       CNContactImageDataAvailableKey as 
                       CNKeyDescriptor,
                       CNContactImageDataKey as CNKeyDescriptor]

    let contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)

    // 5
    print(contacts)
  }
}</pre><p> </p><p> </p><p>In the preceding code, the first step is to import the <code class="literal">Contacts</code> framework into the current file. If you don't do this, the compiler won't be able to understand <code class="literal">CNContactStore</code> or <code class="literal">CNContact</code> because these classes are part of the <code class="literal">Contacts</code> framework.</p><p>The second step is to check the value of the current authorization status. For this example, only the <code class="literal">notDetermined</code> and <code class="literal">authorized</code> statuses are relevant. However, the user can also deny access to their address book. In that case, the authorization status would be <code class="literal">denied</code>. If the status has not been determined yet, the user is asked for permission. When the app already has access, the contacts are fetched right away.</p><p>In the third step, permission is asked to <span>access</span><a id="id325578419" class="indexterm"></a> the user's contacts. The request access method takes a completion-handler as its last argument. In asynchronous programming, completion-handlers are used often. It allows your app to perform some work in the background and then call the completion-handler when the work is completed. You will find completion-handlers throughout <code class="literal">Foundation</code>, <code class="literal">UIKit</code>, and many other frameworks. If you implement a very simple function of your own that takes a callback, it might look as follows:</p><pre class="programlisting">func doSomething(completionHandler: (Int) -&gt; Void) {
  // perform some actions
  var result = theResultOfSomeAction
  completionHandler(result)
}</pre><p>Calling a completion-handler looks just like calling a function. The reason for this is that a completion-handler is a block of code, called a closure. <span class="strong"><strong>Closures</strong></span> are a lot like functions because they both contain a potentially reusable block of code that is expected to be executed when called. You will find plenty of examples of closures and completion-handlers in this book because they are ubiquitous in iOS, and programming in general.</p><p>Step <span>four</span> in the big chunk of code you added created a list of keys that you'll need to render a list of contacts. Since these keys are of the <code class="literal">String</code> type and you must provide a list of <code class="literal">CNKeyDesriptor</code> later, you can use <code class="literal">as CNKeyDescriptor</code> to convert these <code class="literal">String</code> values to <code class="literal">CNKeyDescriptor</code> values. Note that this won't always work because not every type is convertible to a specific other type. For example, you wouldn't be able to do this type of conversion with <code class="literal">UIViewController</code>.</p><p> </p><p>Finally, when the contacts are fetched, they are printed to the console. Of course, you'll want to update this so that the contacts aren't printed in the console, but rendered in the table view. You might notice the <code class="literal">try!</code> keyword before fetching the contacts. This is done because fetching contacts could fail and throw an error.</p><p>In Swift, you are expected to make the right decision in regards to handling errors. By using <code class="literal">try!</code>, you inform the compiler that you are 100%, sure that this fetch call will never fail. This is fine for now so you can focus on the essential bits, but when you're writing an app that is expected to make it to production, you might want to handle errors more gracefully. A good practice is to use a <code class="literal">do {} catch {}</code> block for code that could <span>throw</span><a id="id325604083" class="indexterm"></a> an error. The following code shows a basic example of such a construct:</p><pre class="programlisting">do {
  let contacts = try store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)
  print(contacts)
} catch {
  // something went wrong
  print(error) // there always is a "free" error variable inside of a catch block
}</pre><p>If you run the app with the code you added, the app will immediately ask for permission to access contacts. If you allow access, you will see a list of contacts printed to the console, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/debb4054-2346-4449-a2f6-8a8672bf683b.png" /></div><p>Now that you have the user's contact list, let's see how you can make the contacts appear in your table view!</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec4"></a>Creating a custom UITableViewCell to show contacts</h3></div></div></div><p>To display contacts in your table view, you must set up a <span>few</span><a id="id325605890" class="indexterm"></a> more things. First, you are going to need a table-view cell that displays contact information. All code for a custom table view cell should live in a <code class="literal">UITableViewCell</code> subclass. The design for your custom cell can be made in <span class="strong"><strong><strong class="userinput"><code>Interface Builder</code></strong></strong></span>. When you make a design in <span class="strong"><strong><strong class="userinput"><code>Interface Builder</code></strong></strong></span>, you can connect your code and the design using <code class="literal">@IBOutlet</code>. <code class="literal">@IBOutlet</code> is a connection between an object in the visual layout and a variable in your code.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec0"></a>Designing a table-view cell</h4></div></div></div><p>Open your app's storyboard in <strong class="userinput"><code><span>Interface</span><a id="id325606053" class="indexterm"></a> Builder</code></strong> and look for <code class="literal">UITableViewCell</code> in the <strong class="userinput"><code>Object Library</code></strong>. When you drag it into the table view that you have already added, your new cell is added as a <span class="strong"><strong>prototype cell</strong></span>. A <span>prototype</span><a id="id325606073" class="indexterm"></a> cell functions as a blueprint for all cells the table view is going to display. That's right; you only need to set up a single cell to display many. You'll see how this works when you implement the code for your table-view cell. First, let's focus on the layout.</p><p>After dragging <code class="literal">UITableViewCell</code> to the table view, find and drag out <code class="literal">UILabel</code> and <code class="literal">UIImageView</code>. Both views should be added to the <span class="emphasis"><em>prototype cell</em></span>. Arrange the label and image as shown in the following screenshot. After doing this, use the <strong class="userinput"><code><span class="strong"><strong>reset to suggested constraints</strong></span></code></strong> feature you have used before to add Auto Layout constraints to the label and image. When you select both views after adding the constraints, you should see the same blue lines that are present in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/80aad630-a548-4ea4-936a-b5f073826756.png" /></div><p>The blue lines from the image are a visual representation of the constraints that were added to lay out your label and image. In the image, you can see a constraint that offsets the label from the left side of the cell. Between the label and the image, you can see a constraint that defines the spacing between these two views. The line that runs through the cell horizontally shows that the label and image are centered on the vertical axis.</p><p> </p><p>You can use <span class="strong"><strong><strong class="userinput"><code>Document Outline</code></strong></strong></span> on the left side of <span class="strong"><strong><strong class="userinput"><code>Interface Builder</code></strong></strong></span> to explore these constraints. The table-view cell design is now complete, it's time to implement the <code class="literal">UITableViewCell</code> subclass and create some <code class="literal">@IBOutlets</code> to connect design and code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec1"></a>Creating the table-view cell subclass</h4></div></div></div><p>To create a new <code class="literal">UITableViewCell</code> subclass, you need to <span>create</span><a id="id325607234" class="indexterm"></a> a new file (<span class="strong"><strong><strong class="userinput"><code>File</code></strong></strong></span> | <span class="strong"><strong><strong class="userinput"><code>New</code></strong></strong></span> | <span class="strong"><strong><strong class="userinput"><code>File</code></strong></strong></span>) and choose a <code class="literal">Cocoa Touch</code> file. Name the file <code class="literal">ContactTableViewCell</code> and select <code class="literal">UITableViewCell</code> as the superclass for your file, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/1dbc4033-6f7e-4943-9551-ff6f345237a2.png" /></div><p>When you open the newly-created file, you'll see that two <span>methods</span><a id="id325337713" class="indexterm"></a> were added to the <code class="literal">ContactTableViewCell</code> for you. These methods are <code class="literal">awakeFromNib()</code> and <code class="literal">setSelected(_:animated:)</code>. The <code class="literal">awakeFromNib()</code> method is called the very first time an instance of your class is created. This method is the perfect place to do some initial setup that should only be performed once for your cell.</p><p>The second method in the template is <code class="literal">setSelected(_:animated:)</code>, you can use this method to perform some customizations for the cell when a user taps on it. You could, for instance, change the text or background color for a cell there. For now, delete both methods from the class and replace its contents with the following code:</p><pre class="programlisting">@IBOutlet var nameLabel: UILabel!
@IBOutlet var contactImage: UIImageView!</pre><p>The preceding code should be the entire body for the <code class="literal">ContactTableViewCell</code> class. The variables in the class are annotated with <code class="literal">@IBOutlet</code>; this means that those variables can be connected with your prototype cell in <span class="strong"><strong><strong class="userinput"><code>Interface Builde</code></strong><strong class="userinput"><code>r</code></strong></strong></span>. To do this, open <code class="literal">Main. storyboard</code>, select your prototype cell and look for the <strong class="userinput"><code><span class="strong"><strong>Identity Inspector</strong></span></code></strong> in the sidebar on the right. Set the <span class="strong"><strong><strong class="userinput"><code>class</code></strong></strong></span> property for your cell to <code class="literal">ContactTableViewCell</code>, as shown in the following screenshot. Setting this makes sure that your layout and code are correctly connected:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/80731f9f-81f5-4b29-b161-cbf1c21224a7.png" /></div><p>Next, select the table view cell that you added to the table view. Open the <strong class="userinput"><code><span class="strong"><strong>Connections Inspector</strong></span> </code></strong>in the right sidebar. Under the <span class="strong"><strong><strong class="userinput"><code>Outlets</code></strong></strong></span> header, you'll find a list of names. Among those names, you can find the <code class="literal">nameLabel</code> and <code class="literal">contactImage</code> you added to <code class="literal">ContactTableViewCell</code>. Drag from the circle next to the <code class="literal">nameLabel</code> towards the label inside of your cell. By doing this, you connect the <code class="literal">@IBOutlet</code> that was created in code to its counterpart in the layout. Perform the same steps outlined in the preceding <span>paragraph</span><a id="id325337818" class="indexterm"></a> for the image, as shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/78cdbae4-8766-4247-8aa1-be37907d8ec2.png" /></div><p>The last step is to provide a reuse-identifier for your cell. The table view uses the reuse-identifier so it can reuse instances of table-view cells. Cell-reuse is an optimization feature that will be cover in depth later in this chapter.</p><p>To set the reuse-identifier, open the <strong class="userinput"><code>Attributes inspector</code></strong> after selecting your cell. In the <span class="strong"><strong><strong class="userinput"><code>Attributes inspector</code></strong></strong></span>, you'll find, and an input field labeled <strong class="userinput"><code><span class="strong"><strong>Identifier</strong></span></code></strong>. Set this field to the <strong class="userinput"><code><span class="strong"><strong>ContactTableViewCell</strong></span></code></strong> value.</p><p>With your layout fully set up, we need to take a couple more steps to make the table view show a list of contacts by assigning it a data source and delegate.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec5"></a>Displaying the list of contacts</h3></div></div></div><p>One easily-overlooked fact about the table <span>view</span><a id="id325337904" class="indexterm"></a> is that no matter how simple it might seem to use one in your app, it's one of the more complex components of <code class="literal">UIKit</code>. Some of the complexity is exposed when you add a table view to a regular view controller instead of using <code class="literal">UITableViewController</code>. For instance, you had to manually set up the layout, so your table view covered the viewport. Then, you had to manually set up a prototype cell to display data in.</p><p>The next step toward displaying contacts to your user is providing the table view with information about the contents it should show. To do this, you must implement the data source and delegate for the table view. These properties use advanced concepts that you may have seen before, you probably just weren't aware of them yet. Let's make sure you know exactly what is going on.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec2"></a>Protocols and delegation</h4></div></div></div><p>Throughout <span>the</span><a id="id325337928" class="indexterm"></a> iOS SDK and the <code class="literal">Foundation</code> framework, a design pattern named <span class="emphasis"><em>delegation</em></span> is used. Delegation allows an object to have another object perform work on its behalf. When implemented correctly, it's a great <span>way</span><a id="id325337944" class="indexterm"></a> to separate concerns and decouple code within your app. The following figure illustrates how <code class="literal">UITableView</code> uses delegation for its data source using <code class="literal">UITableViewDataSource</code>:</p><div class="mediaobject"><img src="/graphics/9781789133202/graphics/d55fa8f2-0bdd-4837-8a56-8ba6362241ef.png" /></div><p>The <span>table</span><a id="id325337969" class="indexterm"></a> view uses the help of two objects to function correctly. One is <code class="literal">delegate</code>, and the other is <code class="literal">dataSource</code>. Any time you use a table view, you must configure these two objects yourself. When the time comes for the table view to render its contents, it asks <code class="literal">dataSource</code> for information about the data to display. <code class="literal">delegate</code> comes into play when a user interacts with the items in the table view.</p><p>If you look at the documentation for <code class="literal">UITableView</code>, you can find the <code class="literal">delegate</code> property. The type for <code class="literal">delegate</code> is <code class="literal">UITableViewDelegate?</code>. This tells you two things about <code class="literal">delegate</code>. First of all, <code class="literal">UITableViewDelegate</code> is a protocol. This means that any object can act as a delegate for a table view, as long as it implements the <code class="literal">UITableViewDelegate</code> protocol. Second, the question mark behind the type name tells you that the delegate is an <code class="literal">Optional</code> property. An <code class="literal">Optional</code> property either has a value of the specified type, or it is <code class="literal">nil</code>. The table view's delegate is <code class="literal">Optional</code> because you do not <span class="emphasis"><em>have</em></span><span class="emphasis"><em>to</em></span> set it to create a functioning table view.</p><p>A protocol, such as <code class="literal">UITableViewDelegate</code>, defines a set of properties and methods that must be implemented by any type that wants to conform to the protocol. Not all methods must be explicitly implemented by conforming objects. Sometimes, a protocol extension provides a reasonable default implementation. You can read more about this in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Writing Flexible Code With Protocols And Generics</em></span>.</p><p>In addition to <code class="literal">delegate</code>, <code class="literal">UITableView</code> has a <code class="literal">dataSource</code> property. The data source's type is <code class="literal">UITableViewDataSource?</code>, and just like <code class="literal">UITableViewDelegate</code>, <code class="literal">UITableViewDataSource</code> is a protocol. However, <code class="literal">UITableViewDelegate</code> only has optional methods, meaning you don't need to implement any methods to conform to <code class="literal">UITableViewDelegate</code>. <code class="literal">UITableViewDataSource</code> does have required methods. The methods that need to be implemented are used to provide the table view with just enough information to be able to display the correct amount of cells with the right content in them.</p><p>If this is the first time you're learning about protocols and delegation, you might feel a little bit lost right now. That's OK; you'll get the hang of it soon. Throughout this book, your understanding of topics such as these will improve bit by bit. You will even learn about a concept called protocol-oriented programming! For now, it's important that you understand that a table view asks a different object for the data it needs to show and that it also uses a different object to handle certain user interactions.</p><p>We can break the flow of displaying contents in a table view down into a couple of steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The table view needs to reload the data</li><li>The table view checks whether a <code class="literal">dataSource</code> is set, and asks it for the number of sections it should render</li><li>Once the number of sections is passed back to the table view, the <code class="literal">dataSource</code> is asked for the number of items for each section</li><li>With knowledge about the number of sections and items that need to be shown, the table view asks its <code class="literal">dataSource</code> for the cells it should display</li><li>After receiving all of the configured cells, the table view can finally render these cells to the screen</li></ol></div><p>These steps should give you a little bit more insight into how a table view uses another object to figure out the contents it should render. This pattern is compelling because it makes the table view an extremely flexible component. Let's put some of this newfound knowledge to use!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec3"></a>Conforming to the UITableViewDataSource and UITableViewDelegate protocols</h4></div></div></div><p>To set up the <span>table</span><a id="id325580669" class="indexterm"></a> view's delegate and data source, you need to create an <code class="literal">@IBOutlet</code> for the <span>table</span><a id="id325580681" class="indexterm"></a> view in <code class="literal">ViewController.swift</code>. Add the following line to your <code class="literal">ViewController</code> class, just before <code class="literal">viewDidLoad()</code>:</p><pre class="programlisting">@IBOutlet var tableView: UITableView!</pre><p>Now, using the same technique as you used before when connecting outlets for your table view cell, select the table view in <code class="literal">Main.storyboard</code> and use the <strong class="userinput"><code>Connections Inspector</code></strong> to connect the outlet to the table view.</p><p>To make <code class="literal">ViewController</code> both the delegate and the data source for its table view, it will have to conform to both protocols. It is a best practice to create an <code class="literal">extension</code> whenever you make an object conform to a protocol. Ideally, you make one <code class="literal">extension</code> for each protocol you want to implement. Doing this helps to keep your code clean and maintainable.</p><p>Add the following two extensions to <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">extension ViewController: UITableViewDataSource {
  // extension implementation
}
extension ViewController: UITableViewDelegate {
  // extension implementation
}</pre><p>After doing this, your code contains an error. That's because none of the required methods from <code class="literal">UITableViewDataSource</code> have been implemented yet. There are two methods you need to implement to conform to <code class="literal">UITableViewDataSource</code>. These methods are <code class="literal">tableView(_:numberOfRowsInSection:)</code> and <code class="literal">tableView(_:cellForRowAt:)</code>.</p><p>Let's go ahead and fix the error Xcode is showing by adjusting the code a little bit. This is also a great time to refactor the contact-fetching code a little bit. You will want to access the fetched contacts in multiple places, so the list should be an instance variable on the view controller. Also, if you're adding code to create cells anyway, you might as well make them display the correct information.</p><p>Add the following updates to <code class="literal">ViewController.swift</code>:</p><pre class="programlisting">class ViewController: UIViewController {

  var contacts = [CNContact]()

  // viewDidLoad
  // retrieveContacts
}

extension ViewController: UITableViewDataSource {
  // 1
  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    return contacts.count
  }

  // 2
  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    // 3
    let cell = tableView.dequeueReusableCell(withIdentifier: "ContactTableViewCell") as! ContactTableViewCell
    let contact = contacts[indexPath.row]

    cell.nameLabel.text = "\(contact.givenName) \(contact.familyName)"

    // 4
    if contact.imageDataAvailable == true, let imageData = contact.imageData {
      cell.contactImage.image = UIImage(data: imageData)
    }

    return cell
  }
}</pre><p>The preceding code completes the implementation of <code class="literal">UITableViewDataSource</code>. Let's go over the commented sections of code to clarify them a little bit:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Since this table view only has a single section, the number of contacts as returned for the number of items in every section. This is OK because we know that there will always be just a single section. When you build an app that shows a table view with multiple sections, you would have to implement the <code class="literal">numberOfSections</code> property to inform the table view about the number of sections it needs to render.</li><li style="list-style-type: disc">This method is responsible for creating and configuring one of the <code class="literal">ContactTableViewCell</code> cells you created earlier.</li><li style="list-style-type: disc">Earlier in this chapter, you learned that cells are reused, that's why you had to set a reuse-identifier in the storyboard. Here, the reuse-identifier is used to ask for a cell to display a fetched contact in. Reusing cells that have been scrolled off screen is a performance optimization that enables a table view to display vast amounts of items without choppy scrolling or consuming tons of memory. The <code class="literal">dequeueReusableCell(withIdentifier:)</code> method has <code class="literal">UITableViewCell</code> as its return type. Therefore, you need to cast the result of that method to be the cell you set up in <span class="strong"><strong><strong class="userinput"><code>Interface Builder</code></strong></strong></span> earlier. In this case, that is <code class="literal">ContactTableViewCell</code>.</li><li style="list-style-type: disc">The last step safely extracts image data from the contact if it's available. If it is, the image data is used to set up an image for the cell.</li></ul></div><p>This doesn't wrap up the refactoring of fetching contacts just yet. Contacts are being fetched, but the array of contacts you added to <code class="literal">ViewController</code> earlier is not set up correctly yet, the fetched contacts are not attached to this array. In its current state, the last couple of lines in <code class="literal">retrieveContacts</code> look as follows:</p><pre class="programlisting">let contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)
print(contacts)</pre><p>Change these lines to the following code:</p><pre class="programlisting">contacts = try! store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch)
DispatchQueue.main.async { [weak self] in
  self?.tableView.reloadData()
}</pre><p>With this update, the result of <span>fetching</span><a id="id325580823" class="indexterm"></a> contacts is assigned to the variable you <span>created</span><a id="id325580832" class="indexterm"></a> earlier. Also, the table view is instructed to reload its data. Note that this is wrapped in a <code class="literal">DispatchQueue.main.async</code> call. Doing this ensures that the UI is updated on the main thread. Since iOS 11, your app will crash if you don't perform UI work on the main thread. If you want to learn more about this, have a look at <a class="link" href="#" linkend="ch25">Chapter 25</a>, <span class="emphasis"><em>Offloading Tasks with Operations and GCD</em></span>, it covers threading in more depth.</p><p>There is one more step before you're done. The table view is not aware of its <code class="literal">dataSource</code> and <code class="literal">delegate</code> yet. You should update the <code class="literal">viewDidLoad()</code> method to assign the table view's <code class="literal">dataSource</code> and <code class="literal">delegate</code> properties. Add the following lines to the end of <code class="literal">viewDidLoad()</code>:</p><pre class="programlisting">tableView.delegate = self
tableView.dataSource = self</pre><p>Now go ahead and run your app. If you're running your app on the simulator, or you don't have any images assigned to your contacts, you won't see any images. You can add images to contacts in the simulator by dragging images from your Mac onto the simulator and saving them in the photo library. From there, you can add pictures to contacts the same way you would do it on a real device. If you have a lot of contacts on your device, but don't have an image for everybody, you might encounter an issue when scrolling. Sometimes, you might see a picture of a different contact than the one you expect! This is a performance optimization that is biting you. Let's see what's going on and how to fix this bug.</p></div></div></div>