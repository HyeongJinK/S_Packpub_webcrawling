<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec32"></a>Deconstructing an advanced .gitlab-ci.yml file</h2></div></div><hr /></div><p>Now that we've configured GitLab to run <span>continuous</span><a id="id325277253" class="indexterm"></a> integration and continuous deployment with our example project, it's worth exploring a more advanced <code class="literal">.gitlab-ci.yml</code> file and breaking it down to make sure that we understand what all of the components do.<span> </span><span>To this end, here's an example file that uses more jobs and more advanced parameters:</span></p><pre class="programlisting">image: bitnami/laravel:latest

services:
  - postgres:9.6

variables:
  POSTGRES_DATABASE: postgres
  POSTGRES_PASSWORD: password
  DB_HOST: postgres
  DB_USERNAME: root

stages:
  - test
  - package
  - deploy

php_unit_test:
  stage: test
  script:
    - cp .env.example .env
    - composer install
    - php artisan key:generate
    - php artisan migrate
    - vendor/bin/phpunit
  cache:
    key: composer
    paths:
      - vendor/

js_unit_test:
  stage: test
  script:
    - npm install
    - npm run test

package_upload:
  stage: package
  script:
    - composer install
    - npm install
    - webpack
  cache:
    key: composer
    paths:
      -vendor/
    policy: pull
  artifacts:
    paths:
      - public/
    expire_in: 1 week
    only:
      - tags

deploy_production:
  stage: deploy
  script:
    - composer install
    - npm install
    - webpack
    - .composer/vendor/bin/envoy run deploy
  environment:
    name: production
    url: http://192.168.0.1
  when: manual
  only:
    - master</pre><p><span>Let's break some parts of this down:</span></p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The header of the <code class="literal">.gitlab-ci.yml</code> file defines an image to use from the Docker Registry (<code class="literal">image: bitnami/laravel:latest</code>), as well as defining a <code class="literal">service</code> (in this case, the <code class="literal">postgres:9.6</code> image, also from the Docker registry). This service container will be attached directly to our Laravel image to provide a database without needing to set up a database as part of a <code class="literal">before_script</code> each time a job is run:</li></ol></div><pre class="programlisting">      image: bitnami/laravel:latest

      services:
        - postgres:9.6</pre><p> </p><p> </p><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The variables that are declared all relate to our database and will be used in the jobs so that we can connect to our database service image. Of particular note is the <code class="literal">DB_HOST</code> parameter, which simply specifies <code class="literal">postgres</code> as the hostname. This is because with GitLab CI, any services that are connected are referred to by their image name, in this case, <code class="literal">postgres</code>:</li></ol></div><pre class="programlisting">      variables:
        POSTGRES_DATABASE: postgres
        POSTGRES_PASSWORD: password
        DB_HOST: postgres
        DB_USERNAME: root</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Next, we define three stages that we want: <code class="literal">test</code>, <code class="literal">package</code>, and <code class="literal">deploy</code>. These stages will be run sequentially (and any errors in an earlier stage will cause the whole pipeline to be canceled):</li></ol></div><pre class="programlisting">      stages:
        - test
        - package
        - deploy</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>During the <code class="literal">test</code> stage, we'll have two separate jobs that can be run simultaneously (provided there are enough available Runners). <code class="literal">php_unit_test</code> and <code class="literal">js_unit_test</code> don't depend on one another, so they can safely be run together without causing problems. Both jobs are quite similar in that they have mostly the same parameters, although their scripts each perform very different functions. The big difference between the two is that <code class="literal">php_unit_test</code> also contains a <code class="literal">cache</code> section, which means that after the job is finished, the entire <code class="literal">vendor/</code> directory will be zipped up and stored under the <code class="literal">composer</code> key for reuse in future jobs and pipelines. This helps reduce the time taken to build and execute subsequent runs of this job and any other jobs that use the same cache. Once both jobs are finished (and both are successful), the next stage can begin:</li></ol></div><pre class="programlisting">      php_unit_test:
        stage: test
        script:
          - cp .env.example .env
          - composer install
          - php artisan key:generate
          - php artisan migrate
          - vendor/bin/phpunit
        cache:
          key: composer
          paths:
            - vendor/

      js_unit_test:
        stage: test
        script:
          - npm install
          - npm run test</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>The <code class="literal">package_upload</code> job is the only component of the <code class="literal">package</code> stage, and consists of a script that installs all of the required dependencies and compiles all the front-nd elements. To speed up this process, we use the <code class="literal">cache</code> key, which should download the cache <span>used</span><a id="id325174326" class="indexterm"></a> in the earlier <code class="literal">php_unit_test</code> if it's available. For this example, we've also set the <code class="literal">policy</code> to <code class="literal">pull</code> to demonstrate it. This means that while it will download any available cache stored under the <code class="literal">composer</code> key, it will not re-upload any files once the job has finished. This task will also only operate on tagged commits, which is handy if you're doing versioned releases of software. Once all of the scripts have been executed, all of the files in the <code class="literal">public/</code> directory will be packaged and uploaded as artifacts and stored for up to a week:</li></ol></div><pre class="programlisting">      package_upload:
        stage: package
        script:
          - composer install
          - npm install
          - webpack
        cache:
          key: composer
          paths:
            -vendor/
          policy: pull
        artifacts:
          paths:
            - public/
          expire_in: 1 week
          only:
            - tags</pre><p> </p><p> </p><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>The last stage to run is <code class="literal">deploy_production</code>, which will only be available if the preceding stages have completed successfully. Note that if a job (such as <code class="literal">package_upload</code>) doesn't run because it isn't a tagged release, the stage can still be considered to have run successfully. The <code class="literal">deploy_production</code> task will run a script that installs all of the dependencies and prepare any necessary files and then deploy itself (the last command in the <code class="literal">script</code> array). Given that we are provided with a name and a URL under the <code class="literal">environment</code> parameter, you can find the status of the deployment in the GitLab web user interface for the project under <strong class="userinput"><code>Operations </code></strong>| <strong class="userinput"><code>Environments</code></strong>, and then under the name provided (<code class="literal">production</code>). There will also be links to the deployed application in the project user interface so that you can inspect it once it's live. Please note that this job will only run when code is pushed to the master branch:</li></ol></div><pre class="programlisting">      deploy_production:
        stage: deploy
        script:
          - composer install
          - npm install
          - webpack
          - .composer/vendor/bin/envoy run deploy
        environment:
          name: production
          url: http://192.168.0.1
        when: manual
        only:
          - master</pre></div>