<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec34"></a>Summary</h2></div></div><hr /></div><p>By now, you should have a firm grip on the basics of continuous integration and continuous delivery, as done by GitLab. We started out in this chapter by exploring the concept of CI/CD and giving you a crash course in it.</p><p>Next up, we ran through the process of installing a GitLab Runner. Don't forget that the Runner is the platform where your CI/CD stages are actually executed;Â you can have many of them per project or per GitLab installation to help parallelize the work. We looked at their installation on Ubuntu and CentOS, and manually installing one via a binary. This was followed up by configuring the Runner in the GitLab web UI and then registering it on the Runner host so that it knew which GitLab URL to connect to and set up the registration token it would need.</p><p>After we finished configuring Runners, we updated our sample project with some tests to give it a reason to need a CI/CD platform. This was followed by a dive into the required <code class="literal">.gitlab-ci.yml</code> file, which outlines how the pipelines work for your project. We looked at jobs and a lot of the parameters you can supply to properly configure jobs in GitLab CI. We then set up our own <code class="literal">.gitlab-ci.yml</code> file for use with our sample project and pushed it to GitLab. From here, we investigated some of the web UIs for GitLab's CI/CD to help familiarize the user with how they can keep an eye on their projects.</p><p>In the next chapter, we'll look at porting your projects from GitHub and other Git hosting platforms, as well as moving over from other version control systems such as Subversion.</p></div>