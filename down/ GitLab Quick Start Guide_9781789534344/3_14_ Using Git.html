<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch03lvl1sec20"></a>Using Git</h2></div></div><hr /></div><p>In the first chapter, we explored the concept of version control systems and introduced Git as a tool for distributed version control. We also looked briefly at how Gitworks under the hood. However, so far, we haven't explored how to use git, which is a major prerequisite for most users who'll be working with GitLab.</p><p>One thing to recognize is the life cycle of Git work and the stages it can go through. There are four separate parts: your working directory, the index or staging area, committing to the local repository, and pushing to remote repositories:</p><div class="mediaobject"><img src="/graphics/9781789534344/graphics/10f48552-d150-40b8-8a77-bf33f1e25181.png" /></div><p>The working directory or working copy consists of your local files and any changes you've made to them. The working directory is created from your commit history by git, which reconstructs it from its storage of blobs (binary large objects). When you change branches, Git looks in its database for the reference to that branch, finds all of the related objects, and turns them back into files for you to view and edit.</p><p>Next up are the index or staged files. These get added to when you run <code class="literal">git add</code> and can be thought of as a preview of your next commit. What happens behind the scenes is this: Githas a file called the index, which can be visualized as a list of all the available files in the working copy, their modification times, and three sets of references. When you run <code class="literal">git add</code>, it creates blob objects representing the changes and stores them, keeping a reference to the blobs representing the changes made. This way, you can continue editing a file, but when you commit, only the changes up to when you ran <code class="literal">git add</code> will be kept. The reference is known as the index reference, but the index files also keep a reference to the local copy version and the working copy version so that when it does a checksum over a file, it can tell if it's changed from the index version of the local copy version.</p><p>The local repository or local copy version of your Gitrepository represents the committed code. This is a database of all the commits, branches, references, and so on, and a library of all the blobs representing changes and files. When you run <code class="literal">git commit</code>, all of the changes from the working copy are stored as a reference in this database, and you can start working on new changes again.</p><p>Lastly, we have the remote repository. This is a copy of the repository that is held by someone else, whether on a coworker's computer or a code hosting platform such as GitLab. When you run a <code class="literal">git push</code> command, your changes are packaged and sent over the wire or air to the other repository, where they are integrated. You can also run a <code class="literal">git pull</code> command, which reaches out to a local repository and grabs any changes that have been made in those repositories that are not yet mirrored in your local copy.</p><p>Overall, it seems like a pretty complicated workflow, which is why I've created this handy graph to illustrate the basic operations that you can perform and how they relate to these stages:</p><div class="mediaobject"><img src="/graphics/9781789534344/graphics/1cfb171c-69c8-4ddb-91e7-1dc8c6acd00d.png" /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec17"></a>Git commands</h3></div></div></div><p>I've introduced a few Git commands while discussing how Gitworks, but haven't actually explained properly how to use them, so let's do a very brief introduction to the basic usage of Git.</p><p>The first command you'll need when starting a new project is <span class="strong"><strong><code class="literal">git init</code></strong></span>. This initializes a new Gitrepository, and you'll notice that it creates a <code class="literal">.git</code> folder so that you can start your project (this is hidden by default on Unix-based and Windows operating systems).</p><p>The other situation you might find yourself in is working on an existing project and needing to create a local repository. This can be done with the <span class="strong"><strong><code class="literal">git clone</code></strong></span> command. You specify a URL with a protocol (such as <code class="literal">https://</code> or <code class="literal">git://</code>) and Gitfetches all of the information for that repository before putting it in a folder for that project. It also constructs a working copy from the latest commit on master so that you can begin working on the files immediately.</p><p><span class="strong"><strong><code class="literal">git add</code></strong></span> is logically the next command you might need when you've changed some files or added a new file to the project. As discussed previously, this adds it to the staging area/index, but there's some neat ways you can go about this. By itself, it returns a snarky message saying <strong class="userinput"><code>Nothing specified, nothing added.</code></strong>, but you can supply a file path after that to add a particular file to the index. You can also supply a period (<code class="literal">git add .</code>) and it'll add all of the files in the current directory to the index. You can also use the asterisk character as a wildcard, for example, <code class="literal">git add meerkats/*</code>, which adds all of the files in the <code class="literal">meerkats</code> directory to the staging area, but nothing else. You can also specify a number of file paths, separating them with spaces. If you need to add a file path that contains a space, make sure that you surround it in quotation marks so as not to confuse the poor program. Lastly, you can also run <code class="literal">git add -i</code> to run an interactive prompt, which shows you the status of the working copy and index and lets you choose files to stage or unstage. It even lets you patch files, selectively staging only parts of the changes you've made rather than the entire file.</p><p>Why would we need all of these different ways of adding filautomatically merge your changes with the remote repository  es to staging? One common reason is to separate the work that's been done into separate commits with identifying comments/messages so that people looking over the history of the repository have a better understanding of what each chunk of changes meant without having to view the changelogs individually. Another common reason is just to break up a really large change into multiple bite-sized chunks for easy reviewing. You may also have important secrets, configuration files, compiled work, or vendor libraries that you don't want to commit with your code and so you can avoid adding those files into your staging area or local repository.</p><p><span class="strong"><strong><code class="literal">git commit</code></strong></span> will allow you to commit all of the files you put into staging to the local repository. Since staging has already created the blobs representing the content of your files, all it needs to do is save the index state into the Gitdatabase and then you're ready to go again. It's recommended that you run this command as <code class="literal">git commit -m "MESSAGE"</code>, replacing the content in the quotation marks with a relevant message to help future collaborators (and future you) understand your thought process behind the commit.</p><p>As mentioned previously, <span class="strong"><strong><code class="literal">git push</code></strong></span> will take your local content and <span class="emphasis"><em>push</em></span> it to a remote repository, whether that's another colleague's computer or a code hosting platform like GitLab. You can do this by specifying <code class="literal">git push &lt;remote&gt; &lt;branch&gt;</code>. You have to configure a remote repository first, which you can do with <span class="strong"><strong><code class="literal">git remote add origin &lt;url&gt;</code></strong></span>. Make sure that the URL has the protocol as well (<code class="literal">git://</code>, <code class="literal">https://</code>, and so on). You can also change out <code class="literal">origin</code> for another name if you want to have multiple remote repositories. We'll look at branching or branch commands shortly, but until then you can use <code class="literal">git push origin master</code> to push the main stream of work to your main configured remote repository. You can also run <code class="literal">git push origin --all</code> to push all of your local changes on different branches to the remote repositories. One thing to keep in mind is that Gitwill automatically merge your changes with the remote repository  as long as your local copy is ahead of the remote repository. If there are later commits on the remote repository than your local copy, the merge will fail because, by default, Gitwon't let you rewrite the history of a repository, only append new data to it.</p><p>You can use <span class="strong"><strong><code class="literal">git pull</code></strong></span> to fetch any remote changes and automatically integrate them into the current repository. Be warned: if there are any conflicts with content coming from the remote repository, you'll need to resolve them before continuing.</p><p>If we have multiple people working on the same project and committing/sharing code, how can we prevent them from getting out of sync with each other's copies and then being unable to merge remote changes? This is where branching comes in handy. The <span class="strong"><strong><code class="literal">git branch</code></strong></span> command can be specified with a branch name such as <code class="literal">git branch 53-changing-font-colour</code>. This will create a new branch called <span class="strong"><strong>53-changing-font-colour</strong></span> that you can then swap to and work on separately from the main code. Once you're done, you could merge this code back into the master branch. Git relies heavily on its lightweight branching model to prevent conflicts and allow for better collaboration. Behind the scenes, a Git branch is a reference to a particular commit, and adding new commits moves the branch pointer forward, but forks off from the main (<span class="emphasis"><em>master</em></span>) branch. In this way, they are lightweight and still connected to the entire history of the local repository:</p><div class="mediaobject"><img src="/graphics/9781789534344/graphics/c628db3a-2bd6-4a14-9b2b-63291e108491.png" /></div><p>Once you've created a new branch, you still need to swap to it. This can be done with the powerful <span class="strong"><strong><code class="literal">git checkout</code></strong></span> command. Specifying a branch name like <code class="literal">git checkout 53-changing-font-colour</code> will <span class="emphasis"><em>check out</em></span> that branch from the repository, effectively swapping over your working directory and index to match the commit that was branched from. Any new commits you make will be applied to that branch, until you choose to <code class="literal">git checkout another-branch</code>.</p><p>If you want to create a new branch and swap to it immediately, you can use <code class="literal">git checkout -b branch-name-here</code> instead as a shortcut. <code class="literal">git checkout</code> also has the powerful ability to revert changed files and files that have been added to the staging index. If you run <code class="literal">git checkout — &lt;filename&gt;</code>, it will revert that file back to the status at the last point. Keep in mind that this will only work on files that have already been saved and committed to Git; new files can't be removed with this shortcut. This can save you a heap of time editing files back to their previous state.</p><p>If you've done some work and are happy with it, you may want to merge it back into the master branch of the code. You can do this with the aptly named <span class="strong"><strong><code class="literal">git merge</code></strong></span> command. You swap to the branch you want to merge into, and then run <code class="literal">git merge branch-name-to-merge</code>. Let's say you have a situation like the following one:</p><div class="mediaobject"><img src="/graphics/9781789534344/graphics/9b419eef-2d4e-4d60-8f03-228399d9fd45.png" /></div><p>When you're on the master branch and run <code class="literal">git merge 54-bugfix</code>, behind the scenes, Git grabs those two commits and then finds their closest common ancestor:</p><div class="mediaobject"><img src="/graphics/9781789534344/graphics/9c7ad298-9484-4fb6-b973-2038f56bbb91.png" /></div><p>Git then attempts a three-way merge using the ancestor, the commit to be merged into, and the commit to merge in. This creates a new commit from all three, which your master branch is now pointing at:</p><div class="mediaobject"><img src="/graphics/9781789534344/graphics/5f8c22d4-e410-4bfc-8575-506816c85f75.png" /></div><p>The <span class="strong"><strong><code class="literal">git status</code></strong></span> command shows you the current state of changes in the working directory and index, showing you a list of what files are currently staged in the index and what files are in the working directory that differ from the previous commit. Running <code class="literal">git status</code> does a full update of the index, lodging any differences based on the modification times of the files.</p><p>The last command worth mentioning in this overview of git is <span class="strong"><strong><code class="literal">git diff</code></strong></span>. <code class="literal">git diff</code> can be used by itself or you can append a file path (including wildcards) to show what has changed (the difference) between a file in the working copy and the last committed version. This can be useful for reviewing your changes before staging or committing them.</p></div></div>