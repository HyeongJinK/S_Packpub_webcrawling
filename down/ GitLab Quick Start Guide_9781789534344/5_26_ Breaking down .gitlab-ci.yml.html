<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec30"></a>Breaking down .gitlab-ci.yml</h2></div></div><hr /></div><p>Continuous integration and continuous deployment in GitLab is described <span>and</span><a id="id325315424" class="indexterm"></a> defined by a project's <code class="literal">.gitlab-ci.yml</code> file. The file format is <span class="strong"><strong>YAML</strong></span> (an acronym of <span class="strong"><strong>yet Another markup language</strong></span>), which is a human-readable text file that's used for storing data, and can be converted into digital representations by a computer. This <span>document</span><a id="id325488373" class="indexterm"></a> is stored in the root directory of your repository and outlines all of the stages and work required for the CI/CD to run.</p><p>A basic <code class="literal">.gitlab-ci.yml</code> file might look something like this:</p><pre class="programlisting">before_script:
<span></span>- apt-get update -qq &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -y -qq ca-certificates git php php-xml
<span></span>- php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
<span></span>- php composer-setup.php
<span></span>- php composer.phar install

phpunit:
<span></span>script:
<span></span>- vendor/bin/phpunit tests/ROT13FormatterTest</pre><p>Because of the plain text format of YAML, along with the descriptive names, you can read the preceding code and have a rough idea of what happens. We can guess that <code class="literal">before_script</code> runs first, which runs a number of shell commands, followed by something called <code class="literal">phpunit</code>, which runs a script as well. However, we're still a bit in the dark about it all, so let's explore GitLab CI jobs, as well as some of the keywords.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec43"></a>Jobs</h3></div></div></div><p>A <span class="emphasis"><em>job</em></span> in <code class="literal">.gitlab-ci.yml</code> is a task or set of tasks that <span>must</span><a id="id325277156" class="indexterm"></a> be completed by a Runner. They are top-level entities within the <code class="literal">.gitlab-ci.yml</code> file, which are given an arbitrary name that's decided on by the author. It's a good practice to make the name descriptive to help summarize the purpose of jobs and make them easy to understand by others who might need to review or work with your CI/CD pipeline.</p><p>One thing that's important to note is that jobs are <span>run</span><a id="id325214142" class="indexterm"></a> independently of each other within the Runner, and thus different jobs can be picked up by different Runners. Jobs in the same stage (discussed as follows) can also be run in parallel on other Runners, allowing large pipelines to be broken down and completed faster than having to run everything in a sequential manner.</p><p>Under the job key/name, there are a number of different parameters/keywords that can be used to help define the job.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec6"></a>The script parameter</h4></div></div></div><p>The most common parameter to a job, <code class="literal">script</code> is used to define any commands that should be <span>run</span><a id="id325214166" class="indexterm"></a> in the job. In our preceding example, we have the following:</p><pre class="programlisting">phpunit:
<span></span>script:
<span></span>- vendor/bin/phpunit tests/ROT13FormatterTest</pre><p>In the <code class="literal">phpunit</code> job, we have the <code class="literal">scripts</code> parameter, which tells GitLab to execute <code class="literal">vendor/bin/phpunit tests/ROT13FormatterTest</code>. It's worth noting that commands with special characters (such as a colon, brackets, ampersand, greater/less than, and so on) could be interpreted as part of the YAML, so it's prudent to wrap any such commands in single or double quotes to ensure that they are run as a command.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec7"></a>The before_script and after_script parameters</h4></div></div></div><p>These are scripts that you choose to be <span>run</span><a id="id325488408" class="indexterm"></a> before the job is executed or after the job is executed. These can also be defined at the top level of the YAML file (where jobs are defined) and they'll apply to all jobs in the <code class="literal">.gitlab-ci.yml</code> file. <code class="literal">before_scripts</code> is executed before all jobs, including deploy tasks, but is <span>run</span><a id="id325488432" class="indexterm"></a> after artefacts have been restored (more on that shortly). <code class="literal">after_script</code> is run at the end of the job, even after failed jobs. This can be handy for cleaning up after a job has run.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec8"></a>The stage parameter</h4></div></div></div><p>Stages are <span>defined</span><a id="id325488462" class="indexterm"></a> at the top level of the YAML file and are used to define separate blocks of jobs, which can be executed in parallel. They also define the order in which stages are run. In each job, the <code class="literal">stage</code> parameter can be used to define which build stage a job is in, thus grouping together similar jobs and allowing for jobs to depend on other jobs having finished. The following is an example of defining and using stages:</p><pre class="programlisting">stages:
<span></span>- build
<span></span>- test
<span></span>- deploy

job 1:
<span></span>stage: build
<span></span>script: npm run build dependencies

job 2:
<span></span>stage: build
<span></span>script: npm run build artifacts

job 3:
<span></span>stage: test
<span></span>script: npm run test

job 4:
<span></span>stage: deploy
<span></span>script: npm run deploy</pre><p>In this case, we have defined three stages: <code class="literal">build</code>, <code class="literal">test</code>, and <code class="literal">deploy</code>. All of the jobs attached to the <code class="literal">build</code> stage can be run in parallel, and if they all succeed, the jobs with the <code class="literal">test</code> stage that have been identified will be run. Assuming they pass, the <code class="literal">deploy</code> jobs will then be run. If any job fails at an earlier stage, no further stages will be executed and the pipeline will be marked as failed.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec9"></a>The image parameter</h4></div></div></div><p>The <code class="literal">image</code> parameter is used to specify which <span>Docker</span><a id="id325214520" class="indexterm"></a> image should be used when running a job. This can be specified as a parameter within a job, or at the top level to indicate a Docker image to be used by all jobs. Note that <code class="literal">image</code> parameters specified within each job will override the global <code class="literal">image</code> definition.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec10"></a>The services parameter</h4></div></div></div><p>This parameter is used to specify extra <span>Docker</span><a id="id325214541" class="indexterm"></a> containers that can be connected to the test image to provision services. This is very handy for setting up databases to connect to, rather than needing to install your database engine on each build run. You can also specify this parameter in the top level (but it will be overriden by local definitions).</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec11"></a>The only and except parameters</h4></div></div></div><p>The <code class="literal">only</code> and <code class="literal">except</code> job parameters are <span>used</span><a id="id325214567" class="indexterm"></a> to limit when a specific job is run. <code class="literal">only</code> is used to limit a job being executed to a specified branch or tag names, while <code class="literal">except</code> is the opposite: the job will always be run unless it's on a specified branch or tag. The value for this parameter can be defined with a regular <span>expression</span><a id="id325214582" class="indexterm"></a> or a special keyword such as <span class="emphasis"><em>branches</em></span> to refer to all branches, <span class="emphasis"><em>tags</em></span> to refer to all tags, and so on. For more reserved keywords for <code class="literal">only</code> and <code class="literal">except</code>, please refer to the GitLab CI documentation online.</p><p>Please note that <code class="literal">only</code> and <code class="literal">except</code> don't have to be mutually exclusive either; you can use a combination of them to have more fine-grained control over when a job will be executed. An example of this is as follows:</p><pre class="programlisting">job:
<span></span>only:
<span></span>- /^iss-.*$/
<span></span>except:
<span></span>- tags</pre><p>In this case, the job will only be run on references where the label starts with <code class="literal">iss-</code>, and will not run on any tags that have been pushed to the repository.</p><p>There are more complex ways to use <code class="literal">only</code> and <code class="literal">except</code>, but they are beyond the scope of this quick start guide. More information can be found in the GitLab CI documentation (<a class="ulink" href="https://docs.gitlab.com/ee/ci/" target="_blank">https://docs.gitlab.com/ee/ci/</a><a class="ulink" href="https://docs.gitlab.com/ee/ci/" target="_blank">).</a></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec12"></a>The tags parameter</h4></div></div></div><p>You can specify a tag or tags in <span>this</span><a id="id325217459" class="indexterm"></a> parameter, which will limit this job to only being executed on Runners that also have the same tag. Please note that the tags are additive, so if you specify multiple tags, the job will only be executed on a Runner that has all of those tags present:</p><pre class="programlisting">job:
<span></span>tags:
<span></span>- php
<span></span>- postgres</pre><p>The preceding job will only be executed on Runners that have both the <code class="literal">php</code> and the <code class="literal">postgres</code> tag.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec13"></a>The allow_failure parameter</h4></div></div></div><p><span>This</span><a id="id325217495" class="indexterm"></a> parameter requires a Boolean response, either true or false. When false, the pipeline will execute as normal and any failures in that job will halt the rest of the pipeline. However, when set to true, that particular job can fail without stopping later tasks. The pipeline will still show green, but will have a <span class="emphasis"><em>CI build passed with warnings</em></span> message displayed to alert users to the failed stage.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec14"></a>The when parameter</h4></div></div></div><p>The <code class="literal">when</code> parameter can be <span>one</span><a id="id325217517" class="indexterm"></a> four values, and controls under which conditions a job is run. The possible values are as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">on_success</code>: The default behavior; a job will only be executed if the preceeding jobs/stages have passed</li><li style="list-style-type: disc"><code class="literal">on_failure</code>: The job will only run if at least one job earlier in the pipeline has failed</li><li style="list-style-type: disc"><code class="literal">always</code>: The task will always be executed, on both success and failures</li><li style="list-style-type: disc"><code class="literal">manual</code>: A task that requires manual intervention to be started, such as from the GitLab web UI</li></ul></div><p>One example use case of <code class="literal">when</code> is as follows:</p><pre class="programlisting">stages:
<span></span>- build
<span></span>- cleanup_build

build_job:
<span></span>stage: build
<span></span>script:
<span></span>- webpack

cleanup_build_job:
<span></span>stage: cleanup_build
<span></span>script:
<span></span>- rm /dist/*
<span></span>when: on_failure</pre><p>In the preceding case, the <code class="literal">build</code> job is always executed and attempts to use webpack to build our JavaScript assets, but if it fails, the <code class="literal">cleanup_build_job</code> task will be run, deleting any files that were created by the former task.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec15"></a>The environment parameter</h4></div></div></div><p>The environment parameter is used to <span>specify</span><a id="id325225831" class="indexterm"></a> a particular environment to which a job will be deployed. Environments are discussed in the <span class="emphasis"><em>Environments</em></span> section later in this chapter. The environment key can contain multiple other keys, most commonly <code class="literal">name</code> and <code class="literal">url</code>. The <code class="literal">name</code> sub-key defines a name for an environment to which the code will be deployed. You can track this using the GitLab web user interface by going to <strong class="userinput"><code>Project</code></strong> | <strong class="userinput"><code>Operations</code></strong> | <strong class="userinput"><code>Environments</code></strong>. While you can create new environments in the web user interface, it's recommended that you define them first in the <code class="literal">.gitlab-ci.yml</code> file, which will automatically create them in the web UI on its first run. The <code class="literal">url</code> parameter will be exposed in multiple parts of the GitLab web user interface as links and buttons that can be used to access the environment.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec16"></a>The cache parameter</h4></div></div></div><p>To speed up build processes, you can cache <span>certain</span><a id="id325225877" class="indexterm"></a> files and directories between jobs and between different pipeline executions using the <code class="literal">cache</code> keyword. This is a more <span>advanced</span><a id="id325235174" class="indexterm"></a> strategy, but is really useful to reduce turnaround time in your CI/CD pipelines if you want builds to be tested, packaged, or deployed rapidly. The <code class="literal">cache</code> parameter can take a few different parameters itself to help define the caching rules. Please note that caching can be defined locally (per-job) or globally, and that local caches will override any global declarations.</p><p>To manually clear caches, you can open the GitLab web user interface for your project and navigate to <strong class="userinput"><code>CI/CD</code></strong> | <strong class="userinput"><code>Pipelines</code></strong> using the menus on the left. From here, click the <strong class="userinput"><code>Clear Runner Caches</code></strong> button.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch05lvl4sec0"></a>cache – paths</h5></div></div></div><p>This is an array of paths to files and/or <span>directories</span><a id="id325235206" class="indexterm"></a> that should be cached. You can also use the asterisk wildcard character (<span class="strong"><strong>*</strong></span>). This is demonstrated in the following code snippet:</p><pre class="programlisting">build:
  cache:
  paths:
    - binaries/*.apk
    - .config</pre><p> </p><p> </p><p> </p><p> </p><p>In the preceding example, we cache the <code class="literal">.config</code> file as well as any <code class="literal">.apk</code> files in the <code class="literal">binaries</code> directory.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch05lvl4sec1"></a>cache – key</h5></div></div></div><p>This takes a string that can be <span>used</span><a id="id325249458" class="indexterm"></a> to create separate caches for different jobs or branches, like so:</p><pre class="programlisting">test:
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - binaries/</pre><p>In this example, we use an inbuilt default variable provided by GitLab CI –<code class="literal">CI_COMMIT_REF_SLUG</code>– that is equal to the branch/tag name of the commit. In this case, GitLab CI will maintain a separate cache for each branch. Next up, let's look at jobs with different paths cached:</p><pre class="programlisting">stages:
  - build
  - test

build_job:
  stage: build
  script: npm run build
  cache:
    key: build-key
    paths:
      - public/

test_job:
  stage: test
  script: npm run test
  cache:
    key: test-key
    paths:
     - vendor/</pre><p> </p><p> </p><p>Without a <code class="literal">key</code> value, this would mean that the second job to run (<code class="literal">test_job</code>) would reuse the cache from <code class="literal">build_job</code> and at the end of its run would cache the <code class="literal">vendor/</code> directory. This cache will overwrite the existing cache from <code class="literal">build_job</code>, which means that next time the pipeline runs, the cache will only contain the <code class="literal">vendor/</code> directory (as that was the only thing defined to be cached by the last running job) and the cache will be useless to <code class="literal">build_job</code>. To prevent this happening, we use a separate cache key, which means that each time the pipeline is run, <code class="literal">build_job</code> will grab the cache stored under the <code class="literal">build-key</code> value and <code class="literal">test_job</code> will use the cache stored under <code class="literal">test-key</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch05lvl4sec2"></a>cache – untracked</h5></div></div></div><p>This is a simple helper option that <span>you</span><a id="id325276332" class="indexterm"></a> can set to <code class="literal">true</code> in order to cache any files that are untracked by git at the end of a job run. This is handy for caching the output left over from package installations or program compilation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch05lvl4sec3"></a>cache – policy</h5></div></div></div><p>Under default circumstances, the <span>cache</span><a id="id325276352" class="indexterm"></a> is downloaded before every job and then re-uploaded at the end of the job. This is equivalent to setting the following:</p><pre class="programlisting">job:
  cache:
    policy: push-pull</pre><p>You may have a pipeline with jobs that would use a cache but not alter the contents of the cache. A good example is having one job that downloads all of the required packages and builds assets, and then subsequent jobs that simply run tests. In these cases, you can set <code class="literal">policy: pull</code>, which will download the cache at the start of the job but skip the uploading phase to save time. Conversely, if you have a job that always creates the contents of a cache, you can set <code class="literal">policy: push</code>, which will skip the download phase but always run the upload step at the end of the job.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec17"></a>The artifacts parameter</h4></div></div></div><p>The <code class="literal">artifacts</code> parameter is used to define a list of files <span>and</span><a id="id325419816" class="indexterm"></a> directories that should be <span>attached</span><a id="id325419825" class="indexterm"></a> to a job after success. They are packaged and sent to the GitLab instance (either your self-hosted one or GitLab.com) and become available for download through the web user interface.</p><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch05lvl4sec4"></a>artifacts – paths</h5></div></div></div><p>Much like with caching, you specify an array of paths, which can include <span>wildcards</span><a id="id325419860" class="indexterm"></a> like so:</p><pre class="programlisting">package:
  artifacts:
    paths:
      - public/
      - tests/*.html</pre><p>In this case, everything in the <code class="literal">public/</code> directory as well as any HTML files in the <code class="literal">tests/</code> directory will be zipped, uploaded, and made available for download in the web user interface.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch05lvl4sec5"></a>artifacts – name</h5></div></div></div><p>By default, any uploaded files will be stored in a <code class="literal">.zip</code> archive titled <code class="literal">artifacts.zip</code>. You can use the <code class="literal">name</code> parameter to change the default filename (it will still end with <code class="literal">.zip</code>), as <span>demonstrated</span><a id="id325424547" class="indexterm"></a> in the following code:</p><pre class="programlisting">package:
  artifacts:
    name: cool_project_name</pre><p>In the preceding example, every time this job is completed, a zipped file called <code class="literal">cool_project_name.zip</code> will be uploaded to GitLab and made available for download in the web UI. However, this is not the limit of the naming parameter. You can use built-in GitLab variables such as <code class="literal">CI_JOB_NAME</code> (the name of the currently running GitLab CI job) or <code class="literal">CI_COMMIT_REF_NAME</code> (the name of the branch/tag) to create dynamically named artifacts like in this example:</p><pre class="programlisting">package:
  artifacts:
    name: "$CI_JOB_NAME-$CI_COMMIT_REF_NAME"</pre><p>The preceding example will label every artifact with the current job name (in this case, <code class="literal">package</code>) and the current git branch name, separated by a hyphen and followed by <code class="literal">.zip</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch05lvl4sec6"></a>artifacts – untracked</h5></div></div></div><p>Much like the <code class="literal">untracked</code> key in the <code class="literal">cache</code> section, <code class="literal">artifacts:untracked</code> is a boolean variable that can be <span>set</span><a id="id325457272" class="indexterm"></a> to <code class="literal">true</code> in order to collect all untracked files and upload them as artifacts.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch05lvl4sec7"></a>artifacts – when</h5></div></div></div><p>The <code class="literal">when</code> key can have <span>one</span><a id="id325457293" class="indexterm"></a> of three different values and controls under what circumstances artifacts are uploaded:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">on_success</code>: Only upload artifacts when the job is successful (default).</li><li style="list-style-type: disc"><code class="literal">on_failure</code>: Only upload artifacts when the job fails. This is useful if you want to examine failed builds.</li><li style="list-style-type: disc"><code class="literal">always</code>: Upload artifacts, regardless of whether the job succeeds or not.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch05lvl4sec8"></a>artifacts – expire_in</h5></div></div></div><p>The <code class="literal">expire_in</code> sub-parameter is provided with a string defining <span>how</span><a id="id325487029" class="indexterm"></a> long artifacts should be kept for in the GitLab instance. If this is not specified, it defaults to the instance setting, which is 30 days by default for self-hosted GitLab or forever for GitLab.com projects. Some examples of strings that you can provide include the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">42 weeks</li><li style="list-style-type: disc">42 days</li><li style="list-style-type: disc">42 mins 42 secs</li><li style="list-style-type: disc">2 mos 1 day</li><li style="list-style-type: disc">42 years 6 mos 6 hrs</li><li style="list-style-type: disc">1 week and 2 days</li></ul></div><p>Keep in mind that the job that deletes old artifacts is run on an hourly basis, so units of time less than one hour might not be effective. There is also a <strong class="userinput"><code>Keep</code></strong> button in the GitLab web user interface that can be used to keep an artifact forever and override the specified time value.</p><p> </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec18"></a>The variables parameter</h4></div></div></div><p>You can store variables per job or globally <span>using</span><a id="id325497046" class="indexterm"></a> the <code class="literal">variables</code> keyword. The value for <code class="literal">variables</code> should be an array of key/value pairs that can be represented by strings or integers (for both key and value), although typically the key will be an all-capitalized string for ease of recognition. Any variables used should be of a non-sensitive nature; they are not considered an appropriate method for storing secrets. Locally defined variables will override their globally defined counterparts, but to have a job run with no access to globally defined variables, you should redeclare it with an empty array like so:</p><pre class="programlisting">cool_job_name:
  variables: {}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl3sec19"></a>Other parameters</h4></div></div></div><p>So far, we've covered the majority of the <span>parameters</span><a id="id325497074" class="indexterm"></a> that are available to jobs, including a bunch of ones that can be used at the top level to apply to all jobs. It's worth noting that there are other ones such as dependencies, coverage, and so on that are beyond the scope of this book, but can be found in the GitLab CI documentation online. Let's move on to creating a <code class="literal">.gitlab-ci.yml</code> file for our project so that we can start testing our commits.</p></div></div></div>