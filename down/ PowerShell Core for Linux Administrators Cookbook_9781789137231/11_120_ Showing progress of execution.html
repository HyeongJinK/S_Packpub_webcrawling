<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec119"></a>Showing progress of execution</h2></div></div><hr /></div><p>The whole point of automation is that it helps handle repetitive, tedious, and long-running tasks. For instance, the mailbox backup script that I spoke <span>about</span><a id="id325585846" class="indexterm"></a> in the previous recipe, <span class="emphasis"><em>Displaying an interactive menu</em></span>, took a long time to back up large mailboxes. Sometimes, staring at a terminal that seems to do nothing is unnerving—not to mention not knowing whether the script is actually doing something or not.</p><p>This is where writing progress comes into the picture. Here is the task: count 25 seconds and write progress for the percentage of time elapsed.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec312"></a>How to do it…</h3></div></div></div><p>This is a percentage-based progress writing. Therefore, we need to know the total time beforehand. We will calculate the percentage based on the elapsed time, and we will pass it to the <code class="literal">Write-Progress</code> cmdlet, which we will use to write the progress of our task. Follow these steps to get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a new <code class="literal">.ps1</code> file using Visual Studio Code.</li><li>Enter the following content into the file:</li></ol></div><pre class="programlisting">$TotalTime = 25
$CurrentTime = 0

do {
    Write-Progress -Activity 'Counting to 25' -Status "Elapsed time: $CurrentTime seconds" -PercentComplete ($CurrentTime / $TotalTime * 100)
    Start-Sleep 1
    $CurrentTime++
} until ($CurrentTime -eq $TotalTime)</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Switch to a terminal emulator (the <strong class="userinput"><code>Integrated Terminal</code></strong> does not show progress) and launch PowerShell.</li><li>Call the script and watch its progress.</li></ol></div><p>Here is a screenshot of what the progress looks like:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/34ed6a4a-59d9-4f4e-834d-9150ea130526.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec313"></a>How it works…</h3></div></div></div><p>This cmdlet is designed to show the progress of tasks on the console. In our case, there are three parts to the progress:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The activity (mandatory)</li><li style="list-style-type: disc">The current status</li><li style="list-style-type: disc">The progress bar</li></ul></div><p>The progress bar is enabled using the <code class="literal">PercentComplete</code> parameter. The current <code class="literal">Status</code> is also dynamic, just like <code class="literal">PercentComplete</code>. The activity is mandatory (without which there would be no point in writing the progress anyway), and does not change until the end of the activity.</p><p>In a production scenario, we either use a status cmdlet (such as <code class="literal">Get-MailboxExportRequestStatistics</code>, in the case of mailbox export) or the count to calculate the total completion percentage, and supply the values to the parameters of <code class="literal">Write-Progress</code>. <code class="literal">Write-Progress</code> is usually used with a suitable looping construct, since the progress has to be rewritten based on the progress of the task. Therefore, in the case of cmdlets that are accompanied by a statistics cmdlet, we begin the task outside of the loop and then get its statistics within the loop, the values of which are assigned to the progress parameters.</p><p> </p><p>In the case of count and other such quantifiable tasks, we <span>perform</span><a id="id325892272" class="indexterm"></a> the tasks within the loop. For instance, when copying items from one location to another, we would list out all the paths (recursively), calculate the total size of the content being transferred (and assign it to say, <code class="literal">$TotalSize</code>), use a <code class="literal">foreach</code> loop to copy the files from the source to the destination, and, within the <code class="literal">foreach</code> loop, right after the <code class="literal">Copy-Item</code> cmdlet, we would, say, add to <code class="literal">$TransferredSize</code> the <code class="literal">Length</code> of the file we just transferred. <code class="literal">PercentComplete</code> would be calculated as <code class="literal">$TransferredSize / $TotalSize * 100</code>:</p><pre class="programlisting">foreach ($Item in $AllPaths) {
    Copy-Item $Item.Path $DestinationPath
    $TransferredSize += $Item.Length
    Write-Progress -Activity 'Copying files' -Status "Copied $($Item.Name) to $DestinationPath" -PercentComplete ($TransferredSize / $TotalSize * 100)
}</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec314"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Writing a more complex loop on a predefined array</em></span> recipe in <a class="link" href="#" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Flow Control Using Branches and Loops</em></span></li></ul></div></div></div>