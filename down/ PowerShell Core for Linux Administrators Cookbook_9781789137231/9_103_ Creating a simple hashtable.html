<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec104"></a>Creating a simple hashtable</h2></div></div><hr /></div><p>To be honest, if you followed the course of this book <span>without</span><a id="id326022685" class="indexterm"></a> skipping recipes, you have already seen a few hashtable demonstrations. However, it has not been shown in this light so far. So, off we go.</p><p> </p><p>You would like to create a list of processes and the amount of working set each of them uses. You would like to access each of the processes by name. You do not require any detail from the process table other than the working set. As an example, show the amount of working set used by <code class="literal">pwsh</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec276"></a>How to do it…</h3></div></div></div><p>The script is a simple three-liner: </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Initialize a hashtable</li><li>List out all the processes</li><li>Add the process name as well as the working set to the new array you created</li></ol></div><p>The following script can accomplish this task:</p><pre class="programlisting">$Processes = @{}
Get-Process | ForEach-Object { $Processes[$PSItem.Name] = $PSItem.WS/1MB }
$Processes['pwsh']</pre><p>Optionally, you can also go for a <code class="literal">foreach</code> looping construct instead of the <code class="literal">Foreach-Object</code> cmdlet.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec277"></a>How it works…</h3></div></div></div><p>What we just created was an associative array, also known as a hashtable. These are arrays with named elements. Instead of accessing the values using an index, we use a name.</p><p>In this recipe, we associate the process name to the working set of each of the processes running in the system.</p><p>The first step is to initialize a hashtable. An array is initialized using <code class="literal">@()</code>, whereas a hashtable is initialized using <code class="literal">@{}</code>. The next step is to add data as we would to an array. However, when adding content to an array, we simply add the values. In the case of hashtables, though, each value must be accompanied by a name. Therefore, we use the <code class="literal">$Variable['Name'] = Value</code> format.</p><p>In this recipe, we add content to the hashtable using a <code class="literal">Foreach-Object</code> loop. And when it comes to calling an element, we call it as <code class="literal">$Variable['Name']</code>.</p><p>Content can also be modified. For instance, if you would like to manually modify the working set value for <code class="literal">pwsh</code> or <code class="literal">code</code>, you could use the following:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/cb0c0c67-179b-4308-bbd6-784a19f1c6a0.png" /></div><p>The syntax dictates using quotes around the <span>name</span><a id="id325892152" class="indexterm"></a> within the square brackets, and, when assigning values to element names, using quotes when the name contains non-alphanumeric characters (as demonstrated in the cases of <code class="literal">pwsh</code> and <code class="literal">code</code>).</p><p>You can also manually create a hashtable. Here is how to do this:</p><pre class="programlisting">$Hashtable = @{
    pwsh     = 12
    inkscape = 23
    atom     = 15
}</pre></div></div>