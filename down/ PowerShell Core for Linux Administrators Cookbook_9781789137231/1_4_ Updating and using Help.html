<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec13"></a>Updating and using Help</h2></div></div><hr /></div><p>Help documentation is very important in PowerShell, regardless of whether a certain <span>cmdlet</span><a id="id326345029" class="indexterm"></a> is packaged by providers such as Microsoft, VMware, or Citrix, or community-created. Help is not a switch in PowerShell. PowerShell uses the <code class="literal">Get-Help</code> cmdlet (pronounced command-let) to fetch the Help information enclosed within cmdlets.</p><p>By default, PowerShell is installed with minimal <span>Help</span><a id="id326345010" class="indexterm"></a> information, which contains only the description and the parameters. In this recipe, we will update Help and learn to get Help by using cmdlets, specific parameters, or certain keywords.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec19"></a>Getting ready</h3></div></div></div><p>To go through this recipe, you must have PowerShell 6 installed on your computer, and you must have administrator privileges available. To install PowerShell, refer the <span class="emphasis"><em>Installing PowerShell</em></span> recipe in this chapter.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec20"></a>How to do it…</h3></div></div></div><p>To update the Help files for the locally installed PowerShell modules, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Type <code class="literal">exit</code> to exit PowerShell. This is so that you can relaunch PowerShell with elevated privileges. This is required for some of the modules, based on the permissions used to install them.</li><li>Enter <code class="literal">sudo pwsh</code> (or <code class="literal">sudo pwsh-preview</code>) to launch PowerShell as a superuser.</li><li>At the <strong class="userinput"><code>PS&gt;</code></strong> prompt, run <code class="literal">Update-Help</code>.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Wait for the update progress bar to appear. The bar will fill as the Help files download onto your computer:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137231/graphics/888846ee-75bd-4cd0-ac6d-44355a2271e2.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Use <code class="literal">exit</code> to exit PowerShell as a superuser, and launch PowerShell as a regular user.</li></ol></div><p>We can now proceed and fetch <span>Help</span><a id="id326312419" class="indexterm"></a> information for other cmdlets.</p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>At the command prompt, enter the <span>following</span><a id="id325892282" class="indexterm"></a> command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Write-Host</strong></span></pre><p> </p><p>You will get an output similar to the following:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/9e2adedc-9bc2-4cc0-8421-1f3cc68d5286.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Next, gather different levels of Help information by using the following commands:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Write-Host -Full</strong></span></pre><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Write-Host -Examples</strong></span></pre><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Write-Host -Online</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Pass a different cmdlet as a parameter to <code class="literal">Get-Help</code>. Note the two groups of parameters:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Get-Command</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Compare the outputs of the different commands you ran.</li><li>Now, look for Help information for the specific parameter of <code class="literal">Write-Host</code> (the second command in the following code is for reference; this states what the first command means to PowerShell):</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; get-help write-host -par foregroundcolor</strong></span>
<span class="strong"><strong>PS&gt; # Verbose version: Get-Help -Name Write-Host -Parameter ForegroundColor</strong></span></pre><p> </p><p>Now let's look for a certain keyword within the Help information:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Convert the output of <code class="literal">Get-Help Get-Command</code> into text, one string at a time, rather than putting in the entirety of the Help information as a single string:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; get-help get-command | out-string -s</strong></span>
<span class="strong"><strong>PS&gt; # Verbose version: Get-Help Get-Command | Out-String -Stream</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Pipe this to the <code class="literal">Select-String</code> cmdlet to perform a grep-like operation:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; get-help get-command | out-string -s | select-string 'wildcard'</strong></span>
<span class="strong"><strong>PS&gt; # Verbose version: Get-Help -Name Get-Command | Out-String -Stream | Select-String -Pattern 'wildcard'</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>This gives you an output of a line that contains <code class="literal">wildcard</code>:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137231/graphics/c0c7c684-5102-48e3-a274-9422a1510041.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec21"></a>How it works…</h3></div></div></div><p>It is inconvenient to leave your Terminal to read <span>Help</span><a id="id325896388" class="indexterm"></a> online. We would prefer to have all of the Help available locally. PowerShell can potentially work on low-memory devices such as Raspberry, but saving all of the Help in the limited space we have is not advisable. This is one of the reasons PowerShell comes with minimal Help by default. The reason updating Help requires elevated privileges is that the <span>Help</span><a id="id325898616" class="indexterm"></a> information is stored within the shell. Therefore, non-administrators may not be able to update Help without administrator intervention.</p><p>As a general practice, cmdlets come pre-packaged with Help information, and <code class="literal">Get-Help</code> works like the <code class="literal">man</code> command in Linux. The output of <code class="literal">Get-Help</code> has the name of the cmdlet, the syntax to use with the cmdlet, the alias(es) available for the cmdlet and more online Help if required. <code class="literal">-Full</code> and <code class="literal">-Examples</code> are (mutually exclusive) switches that tell PowerShell about the level of Help you need.</p><p> </p><p>The groups of parameters, as seen in the case of <code class="literal">Get-Command</code>, under <code class="literal">SYNTAX</code>, are called parameter sets. They tell us which parameters can be used together. Parameters not appearing in the same parameter set cannot be used together. For example, you cannot use <code class="literal">-Noun</code> and <code class="literal">-Name</code> with <code class="literal">Get-Command</code> at the same time; it wouldn't be logical to do so.</p><p>If the Help information seems elaborate, and you would like to learn about a specific parameter of a cmdlet, you can specify that parameter, and the Help will be filtered accordingly. Since the output of most PowerShell cmdlets is objects, it is easy to select the necessary object and discard the rest from the output. Also note that this is the recommended approach to fetch Help that's specific to a certain parameter.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note6"></a>Note</h3><p>PowerShell, in general, is case-insensitive. Therefore, <code class="literal">Noun</code> and <code class="literal">noun</code>, or <code class="literal">Parameter</code> and <code class="literal">parameter</code>, mean the same thing to it. The use of CamelCase is the general convention in PowerShell. With the almost ubiquitous tab completion, this is a cakewalk.</p></div><p>Next, let's talk about searching <span>Help</span><a id="id325901995" class="indexterm"></a> for specific keywords. PowerShell outputs objects. However, at the end, when the content comes to the host, the content can be processed by Linux commands such as <code class="literal">grep</code>. Therefore, to search <span>Help</span><a id="id325905964" class="indexterm"></a> for specific keywords, you could always pipe the output to <code class="literal">grep</code>. If you would like to go the PowerShell way (especially if you go by the write once, run everywhere philosophy), this requires minor modifications. First, we fetch the Help; the output is an object (so that it can be processed further if needed). We convert this into a string using <code class="literal">Out-String</code>, since search is nothing but string matching.</p><p>PowerShell cmdlets output single or multiple instances of objects (we will discuss objects in more detail in the <span class="emphasis"><em>Understanding objects</em></span> recipe). <code class="literal">Out-String</code> waits for all of the <code class="literal">Get-Help</code> commands to be processed and converts the output into a single concatenated string. To break the string into chunks, we use the <code class="literal">-Stream</code> switch, which instructs <code class="literal">Out-String</code> to not concatenate the output. This way, each paragraph is processed separately. Next, we use the <code class="literal">Select-String</code> cmdlet, along with the search keyword to perform keyword matching. The output of this is the chunk (paragraph, in this case) with the keyword.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec22"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Working with aliases</em></span> recipe</li><li style="list-style-type: disc">The <span class="emphasis"><em>Updating and using Help</em></span> recipe</li><li style="list-style-type: disc">The <span class="emphasis"><em>Running cmdlets with minimal keystrokes</em></span> recipe in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Preparing for Administration using PowerShell</em></span></li></ul></div><p> </p><p> </p><p> </p></div></div>