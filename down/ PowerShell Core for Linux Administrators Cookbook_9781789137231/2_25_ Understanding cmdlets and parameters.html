<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec33"></a>Understanding cmdlets and parameters</h2></div></div><hr /></div><p>Most of our scripting and administration is going to revolve around running cmdlets and chaining them. In some situations, we run a cmdlet expecting it to work a certain way, only to find out that <span>the</span><a id="id326064198" class="indexterm"></a> cmdlet threw an error, or worse, did something undesirable.</p><p><span>The</span><a id="id326063940" class="indexterm"></a> key to getting cmdlets to do what we want them to do is to eliminate ambiguity. In this recipe, we will learn to construct commands contextually and effectively.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec92"></a>Getting ready</h3></div></div></div><p>Read the Help section of <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introducing PowerShell Core</em></span>. Let us understand the notifications used in the help information that <code class="literal">Get-Help</code> shows.</p><p>While this may not be an exhaustive guide to using the help information, it should cover most of your daily help document reading needs. The idea is to show you the notations. These notations may appear in several combinations (parameter values in curly braces, surrounded by square brackets, for example):</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Notation</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Meaning</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-Parameter &lt;DataType&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>No square brackets: Mandatory parameter, named. The parameter must be called by name and a value of <code class="literal">DataType</code> must be specified.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[-Parameter &lt;DataType&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Square brackets around the parameter-data-type-pair: Optional parameter, although it must be called by name, and a value of <code class="literal">DataType</code> must be passed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[-Parameter] &lt;DataType&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Square brackets around the parameter name: Positional parameter. You can simply pass a value of <code class="literal">DataType</code> to the cmdlet, as long as the value is at the position shown by the parameter in the help text. The parameter need not be called by name as long as the position is right.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">[[-Parameter] &lt;DataType&gt;]</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Square brackets around the parameter name, and another pair of square brackets around the parameter-data-type-pair: Positional parameter, which is optional.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-Parameter &lt;DataType[]&gt;</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>Square brackets after DataType: Multi-valued parameter. This parameter accepts multiple values as input, each pair of values separated by a comma.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">-Parameter</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>No data type: Switch parameter. Calling the parameter makes the switch <code class="literal">$true</code>, and not calling it uses the default value for the switch. To disable the switch, set it to false, such as <code class="literal">-Parameter:$false</code>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">-Parameter {Value1 | Value2 | Value3}</code></p></td><td style=""><p>Values surrounded by curly braces: Parameter that accepts predefined values as input. In this case, you would call the parameter <code class="literal">-Parameter Value1</code>, or <code class="literal">-Parameter Value2</code>. In other words, this parameter does not accept arbitrary values.</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note31"></a>Note</h3><p>Bash champions take note: PowerShell needs a comma separating the values in a multi-valued parameter. Therefore, if you would like to call <code class="literal">Remove-Item</code> on three files, you would enter <code class="literal">Remove-Item file1, file2, file3</code>. If only a space separates the values (like Bash's input), PowerShell will consider the three values as values to three positional parameters and would either throw an error or do something you did not want it to, based on the cmdlet you call. In general, use of named parameters is recommended.</p></div><p>In general, anything surrounded by square brackets is optional. Anything surrounded by curly braces indicates predefined parameter values (the pipe separates each value). The data type followed by an empty pair of square brackets indicates an array of that data type. And the position of the parameter is to be noted.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip32"></a>Note</h3><p>Notice the combination: <code class="literal">Required</code> is false, there is a default value as shown in the text below the parameter name, and the position is <code class="literal">1</code>. This means that you can simply call the cmdlet, and it would run itself against the default value for its first parameter. The example used here is <code class="literal">Get-ChildItem</code>.</p></div><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec93"></a>How to do it…</h3></div></div></div><p>That was a long <span class="emphasis"><em>Getting ready</em></span> section. Let us now put this knowledge to use:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Run a <span>command</span><a id="id325669220" class="indexterm"></a> to get a list of files and <span>directories</span><a id="id325671196" class="indexterm"></a> in the current location:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Let us now add a <code class="literal">.</code> to indicate the current location:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem .</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Compare the output of the last two commands.</li><li>Let us go with the following:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path .</strong></span></pre><p>Is the output the same as that of the last two commands?</p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Run the following and note the values for each of the keys:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Get-ChildItem -Parameter Path</strong></span>

-Path &lt;String[]&gt;
    Specifies a path to one or more locations. Wildcards are permitted. The default location is the current directory (`.`).

    Required?                    false
    Position?                    1
    Default value                Current directory
    Accept pipeline input?       True (ByPropertyName, ByValue)
    Accept wildcard characters?  true</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Create a file in the current location, called <code class="literal">file1</code> by calling the parameter by name:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help New-Item</strong></span>

.
.
SYNTAX
    New-Item [[-Path] &lt;String[]&gt;] [-Confirm] [-Credential &lt;PSCredential&gt;] [-Force] [-ItemType &lt;String&gt;] -Name &lt;String&gt; [-UseTransaction] [-Value &lt;Object&gt;] [-WhatIf] [&lt;CommonParameters&gt;]

    New-Item [-Path] &lt;String[]&gt; [-Confirm] [-Credential &lt;PSCredential&gt;] [-Force] [-ItemType &lt;String&gt;] [-UseTransaction] [-Value &lt;Object&gt;] [-WhatIf] [&lt;CommonParameters&gt;]</pre><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>We have two possibilities: <code class="literal">Path</code> and <code class="literal">Name</code>. Look for information on <code class="literal">Path</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help New-Item -Parameter Path</strong></span>

-Path &lt;String[]&gt;
    Specifies the path of the location of the new item. Wildcard characters are permitted.

    You can specify the name of the new item in Name , or include it in Path .

    Required?                    true
    Position?                    0
    Default value                None
    Accept pipeline input?       True (ByPropertyName)
    Accept wildcard characters?  false</pre><p>If we use <code class="literal">Name</code>, we have to call it by name (no pun intended). If not, we can specify the name as part of <code class="literal">Path</code> (no alliteration intended either).</p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Let us use <code class="literal">Path</code> first. <code class="literal">-Path</code> need not be written, since it is a positional parameter:</li></ol></div><pre class="programlisting"><span class="strong"><strong><span>PS&gt; New-Item file1</span></strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Try the same operation with <code class="literal">Name</code>. This time, mention the parameter name:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Item -Name file2</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>If you would like, create a third file, by calling <code class="literal">Path</code> by name:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Item -Path file3</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>List out the contents of the current location:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path .</strong></span></pre><p>The files are present.</p><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Let us now delete the files:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Remove-Item</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Mention the filenames as paths:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Remove-Item file1</strong></span></pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>List the contents of the directory:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path .</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>Let us delete multiple files in one shot. And this time, let us call the parameter by name:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Remove-Item -Path file2, file3</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="16" type="1"><li>Let us now create a directory. We need to use a parameter called <code class="literal">ItemType</code>, which has predefined values, based on the provider (we are using <code class="literal">FileSystem</code>):</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Item -Path test-dir -ItemType Directory</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="17" type="1"><li>Create three new files, like so:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Item test-dir/file1, test-dir/file2 -ItemType File</strong></span>
<span class="strong"><strong>PS&gt; New-Item test-dir/child-dir -ItemType Directory</strong></span>
<span class="strong"><strong>PS&gt; New-Item test-dir/child-dir/file3 -ItemType File</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="18" type="1"><li>Now, let us delete the contents. Wait for a <span>confirmation</span><a id="id326313822" class="indexterm"></a> prompt to appear after <span>running</span><a id="id326313831" class="indexterm"></a> the command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Remove-Item -Path test-dir</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="19" type="1"><li>Read the prompt. It says something about the <code class="literal">Recurse</code> parameter.</li><li>Choose <code class="literal">L</code> and press <span class="emphasis"><em>Enter</em></span> to abort the process.</li><li>Enter the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Remove-Item -Path test-dir -Recurse</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="22" type="1"><li>That was quiet! List out the contents of the current directory to ensure <code class="literal">test-dir</code> is gone:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem</strong></span></pre><p>The directory is indeed gone.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec94"></a>How it works…</h3></div></div></div><p>Working with cmdlets is simple. There are two kinds of parameters: named and positional.</p><p>Positional parameters work based on the position. They are programmed in such a way that PowerShell understands their logical sequence and performs its actions. For instance, when moving items, the general way of working is to call the command and pass the source first and then the destination.</p><p>Therefore, the following would mean that you want to move the <code class="literal">GitHub</code> directory to <code class="literal">Code</code>: </p><pre class="programlisting"><span class="strong"><strong><span>PS&gt; Move-Item /home/ram/Documents/GitHub /home/ram/Documents/Code/</span></strong></span></pre><p> Many PowerShell cmdlets are programmed to understand this.</p><p>Named parameters, on the other hand, are to be called by name. Help text shows them without any brackets surrounding them. Calling the positional parameters by name is optional—you are allowed to simply pass the values. However, be careful with what position or sequence you mention them in.</p><p>The best practice is to always pass parameter values, calling them by name when writing scripts. When running quick commands, on the other hand, you may omit calling positional parameters by name in the interest of speed.</p><p>Some parameters have predefined value validation added to them. These parameters accept only those values that have been defined in them. For instance, <code class="literal">ItemType</code> only accepts <code class="literal">File</code>, <code class="literal">Directory</code>, <code class="literal">SymbolicLink</code>, <code class="literal">Junction</code>, and <code class="literal">HardLink</code> as values, at the time of writing this section.</p><p>And then, there are switch parameters. <code class="literal">Recurse</code> is an example. When you call these parameters with no value, the parameters assume <code class="literal">True</code> in most cases. When you have to set them to <code class="literal">False</code>, you mention <code class="literal">-Parameter:$false</code> (for example, <code class="literal">-Confirm:$false</code>). If you do not call the switch parameter, the parameter goes with the default value specified in the cmdlet.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec95"></a>There's more…</h3></div></div></div><p>If you would like to create the <span>files</span><a id="id326314065" class="indexterm"></a> and directories again, don't run four commands. Run the following two:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Item test-dir/child-dir -ItemType Directory -Force</strong></span>
<span class="strong"><strong>PS&gt; New-Item ./test-dir/file1, ./test-dir/file2, ./test-dir/child-dir/file3</strong></span></pre><p> </p><p>The parameter, <code class="literal">Force</code>, creates <code class="literal">test-dir</code> when creating <code class="literal">child-dir</code>.</p><p>Go ahead and delete the entire directory if you want to, without the <code class="literal">Recurse</code> parameter. At the <span>confirmation</span><a id="id326314220" class="indexterm"></a> prompt, press <span class="emphasis"><em>Enter</em></span> (<code class="literal">Y</code> is the default response).</p></div></div>