<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec114"></a>Working with structured and unstructured files</h2></div></div><hr /></div><p>In this modern world, we tend to deal with a lot <span>of</span><a id="id325585869" class="indexterm"></a> information. In some cases, the <span>data</span><a id="id326229534" class="indexterm"></a> is stored in a structured way (for example, CSV, XML, JSON, and so on). And in some other cases, the data is stored in an unstructured away, such as log files, <code class="literal">.txt</code>, and so on.</p><p>We have already been dealing with unstructured files so far in this book. PowerShell works well with either type of file. Where PowerShell really stands out is how it handles structured data, and, by extension, structured files. In many cases, in fact, a simple one-liner is sufficient for PowerShell to parse data into an object.</p><p>We had an interesting situation once at work. One of our clients uses a certain MDM application. At one point, the email application that is part of the MDM suite started crashing on the users. The users found that reinstalling the app fixed the crash. And one of the IT managers at the client's wanted a list of users who reinstalled the application. Upon checking the logs, we found something interesting: the log files were <code class="literal">.log</code> files, and the files had single lines of entries, which had some characters in the beginning, after which the log pretty much looked like valid JSON. The <code class="literal">08-mdm-reinstall-log.log</code> file, within the <code class="literal">ch10</code> directory of the code repository of the book contains a sample log that looks similar to what we got on the server. The report that needs to be extracted from this data should have the timestamp, the username, and the email address of the user. Here is a line from the log file:</p><pre class="programlisting">2018-09-06T00:09:45.351-0500 - CORE Exchange[Body: DeviceActionEvent {"eventTypeId":"979dba5297b4c8c8a9fb59d25f33fd2a","timestamp":1536210585273,"tenantId":1,"tenantGuid":"5b73c758-57af-47b2-a6d4-d7b6c52cb5e5","externalTenantId":"S650643799","correlationId":"7876c65b-2ba4-7648-9a94-1ef6fb492c3b","hostName":"svrbbp.mydomain.com","version":"5.63.87-SNAPSHOT","severity":"CLEARED","tags":["device_action","user","userdevice"],"userDeviceInfo":{"enrollmentType":"MDM_CONTROLS","perimeterUuid":"afa57869b-3f76-7e74-98d8-ab725136a663","userInfo":{"userGuid":"af78905c-806f-49a8-b491-3f3fc26564e5","userName":"NBFA091","emailAddress":"Joyce.Rose@mydomain.com"},"deviceInfo":{"deviceOSFamily":"ios","id":1332,"udid":"4a7783999478577b7746dc774657b992","guid":"6657bc4e-19d5-b4bc-b05c-2e3c63190a11"},"perimeterState":"ENROLLED"},"deviceActionType":"INSTALL_APP"}] </pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec302"></a>How to do it…</h3></div></div></div><p>This is, in fact, very simple. Here is the high-level flow of what we want to do:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Loop through each line of the log. We will use <code class="literal">Get-Content</code> and the <code class="literal">foreach</code> loop construct for this.</li><li>Perform a simple string manipulation to get the timestamp.</li><li>Parse the JSON to get the username as well as the email address.</li></ol></div><p>Here is the script that will perform this operation.</p><pre class="programlisting">$AllLogLines = Get-Content ./ch10/08-mdm-reinstall-log.log
$UserTable = @()

foreach ($Line in $AllLogLines) {
    $Timestamp = ($Line.Split(' '))[0]

    $Line = $Line -replace ".+(DeviceActionEvent)\ \{", '{'
    $Line = $Line -replace '\]$'

    # Alternatively: $Line = $Line | Select-String -Pattern '(\{.*})' | ForEach-Object { $PSItem.Matches | ForEach-Object { $PSItem.Value } }

    $JsonData = ConvertFrom-Json $Line
    $UserInfo = $JsonData.userDeviceInfo.userInfo

    $Record = [ordered]@{
        Timestamp       = Get-Date $Timestamp -Format d
        Username        = $UserInfo.userName
        EmailAddress    = $UserInfo.emailAddress 
    }

    $UserTable += New-Object -TypeName psobject -Property $Record
}
$UserTable = $UserTable | Sort-Object Username -Unique | Sort-Object Timestamp
$UserTable</pre><p> </p><p>Run the script and you should see a table with the required information. Optionally, you can export this into a CSV file. You know how.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note70"></a>Note</h3><p>If you run the script as it is, it is important that you run it at the terminal. If you plan to run this script from Visual Studio Code, change the first line of the script to <code class="literal">$AllLogLines = Get-Content ./08-mdm-reinstall-log.log</code> by removing <code class="literal">ch10/</code> to avoid errors.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec303"></a>How it works…</h3></div></div></div><p>The first step in the script is to read the contents of the log file. <code class="literal">Get-Content</code> reads the content, each line in the file being a separate element in a string array. Next, we initialize the variable that will contain our object. We use the <code class="literal">foreach</code> loop construct to perform operations on each of the log lines.</p><p>Now to a single log entry. The first thing we do here is split the log at whitespace, and pick the first element in it, because the structure of the log line tells us that the timestamp is in the beginning. We use the split method within the string object and pick the timestamp.</p><p>Next, we perform a couple of simple string replacement operations (or the single alternative operation) using the replace operator (or <code class="literal">Select-String</code> in the case of the alternative method). This is to remove the non-JSON part of the log line. (You can always perform a syntax check online on any of the JSON entries. There are several services, such as <a class="ulink" href="https://jsonlint.com/" target="_blank">https://jsonlint.com/</a> and <a class="ulink" href="https://codebeautify.org/jsonvalidator" target="_blank">https://codebeautify.org/jsonvalidator</a>, available to help you. If not, simply follow what your code editor tells you.)</p><p>The magic really happens at the <code class="literal">ConvertFrom-Json</code> line, where PowerShell quite effortlessly parses the JSON <span>data</span><a id="id325898622" class="indexterm"></a> and converts it into an object with the keys and values being the properties and property values, respectively. Now, <code class="literal">$JsonData</code> has the <span>complete</span><a id="id325898666" class="indexterm"></a> JSON content within it. We now have two ways: either inspect the <code class="literal">$JsonData</code> variable using the Visual Studio Code debugger, or simply format the JSON using an online service and then go down property by property. I took the former approach, by adding a breakpoint and using the Visual Studio Code debugger. Note the left-hand bar. We will learn more about this process at a later point:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/addddba9-2d56-4866-9c9b-b55d760096c8.png" /></div><p>We then create an ordered hashtable, with the keys being the property names and the values being the values of the keys. We transpose the hashtables in every iteration into a custom PowerShell object, which we finally call at the end of the script to show the table.</p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec304"></a>There's more…</h3></div></div></div><p>This is just the tip of the iceberg. Read through the <span class="emphasis"><em>Adding custom properties to an object recipe </em></span>in <a class="link" href="#" linkend="ch05">Chapter 5</a>, <span class="emphasis"><em>Using Variables and Objects</em></span>, to learn how to work with PowerShell objects and make your scripts much more efficient than you are used to.</p></div></div>