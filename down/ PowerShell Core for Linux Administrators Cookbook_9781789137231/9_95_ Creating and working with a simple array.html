<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec96"></a>Creating and working with a simple array</h2></div></div><hr /></div><p>In this recipe, we will see how to initialize a simple array and <span>work</span><a id="id326641181" class="indexterm"></a> with it. And here is the scenario. You have, let's say, a unique requirement. You want to know the process that is consuming the least of the processor time. To this, you add the top five processes consuming the most processor time. Information on how much of <span>what</span><a id="id326641149" class="indexterm"></a> is being used is not necessary; just the name would suffice.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec253"></a>How to do it…</h3></div></div></div><p>We will first get the process consuming the least CPU and assign it to a variable:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Now, run the following to get the process consuming the least processor time and assign it to a variable:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $Process = get-process | sort-object cpu | select-object -fi 1 -expand processname</strong></span>
<span class="strong"><strong>PS&gt; # Verbose version: $Process = Get-Process | Sort-Object CPU | Select-Object -First 1 -ExpandProperty ProcessName</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Next, select the top five processes using the most CPU and add them to this list. Also, call the variable to see the contents, and get the count:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $Process += get-process | sort-object cpu | select-object -last 5 -expand processname</strong></span>
<span class="strong"><strong>PS&gt; # Verbose version: $Process += Get-Process | Sort-Object CPU | Select-Object -Last 5 -ExpandProperty ProcessName</strong></span>

<span class="strong"><strong>PS&gt; "These are the $($Process.Count) processes you asked for:"; $Process</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>That was a single string, and not helpful at all. Let's now create a script at the terminal and run it:</li></ol></div><pre class="programlisting">$Process=@()
$Process+=Get-Process|Sort-Object CPU |Select-Object-ExpandProperty ProcessName -First 1
$Process+=Get-Process|Sort-Object CPU |Select-Object-ExpandProperty ProcessName -Last 5
"These are the $($Process.Count) processes you asked for:"; $Process
</pre><p> </p><p>Alternatively, use the following:</p><pre class="programlisting">$Process = , (Get-Process | Sort-Object CPU | Select-Object -ExpandProperty ProcessName -First 1) $Process += Get-Process | Sort-Object CPU | Select-Object -ExpandProperty ProcessName -Last 5
"These are the $($Process.Count) processes you asked for:"; $Process</pre><p>In both the cases, you should get six processes, as expected.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec254"></a>How it works…</h3></div></div></div><p>This recipe was aimed at initializing and adding content to an array. We used two cases here. In the first case, we added the name of one process to a variable, and tried to add five more to it. However, the value assigned to the variable at the end of it turned out to be a string, not an array as we may have expected. This happened because the <code class="literal">+</code> operator, when used with strings, concatenates strings. <code class="literal">$Process</code> was a string; we never told PowerShell that we wanted an array.</p><p>In the third step, we initialized an array using <code class="literal">@()</code>. And then, we used the <code class="literal">+=</code> assignment operator to add content to the now-empty array. Remember that you must use the <code class="literal">+=</code> assignment operator when adding content to the empty array; using the <code class="literal">=</code> operator will again assign a string to the variable, because the <code class="literal">=</code> assignment operator replaces content within the variable.</p><p>In the alternate method, we used a <span>shorter</span><a id="id325905960" class="indexterm"></a> way of telling PowerShell that <code class="literal">$Process</code> is an array; we used a comma, followed by the expression we would like to evaluate. Then, we used the <code class="literal">+=</code> assignment operator to add the <span>top</span><a id="id325905975" class="indexterm"></a> five CPU hogs to the variable.</p><p>At the output line, we used a subexpression operator (<code class="literal">$()</code>) to show the process count.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec255"></a>There's more…</h3></div></div></div><p>This is a little note on using multidimensional arrays in PowerShell. We did not include a recipe for it because, while multidimensional arrays are supported in PowerShell, there are very limited practical applications to them; a hashtable or a PowerShell custom object is preferred (and more efficient).</p><p> </p><p>Multidimensional arrays in PowerShell are of two types:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Jagged multidimensional array</li><li style="list-style-type: disc">Non-jagged multidimensional array</li></ul></div><p>A jagged array is one whose members contain a non-uniform number of members, such as the following:</p><pre class="programlisting"> 1,  2,  3,  4,  5
 6,  7,  8
 9, 10, 11, 12, 13, 14
15, 16, 17, 18
19, 20</pre><p>It can be created using the following syntax:</p><pre class="programlisting">$JaggedArray = @(
    (1, 2, 3, 4, 5),
    (6, 7, 8),
    (9, 10, 11, 12, 13, 14),
    (15, 16, 17, 18),
    (19, 20)
)</pre><p>We also have non-jagged arrays in PowerShell:</p><pre class="programlisting"> 1,  2,  3,  4,  5
 6,  7,  8,  9, 10
11, 12, 13, 14, 15
16, 17, 18, 19, 20</pre><p> They need to be initialized as a new object:</p><pre class="programlisting">$MultiDimensionalArray = New-Object -TypeName "int[,]" 4, 5
$Count = 1

for ([int]$i = 0; $i -lt 4; $i++) {
    for ([int]$j = 0; $j -lt 5; $j++) {
        $MultiDimensionalArray[$i,$j] = $Count
        $Count++
    }
}

# Access a random member from within the array:
$MultiDimensionalArray[2,3]</pre><p> </p></div></div>