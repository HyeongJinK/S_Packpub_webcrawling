<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec39"></a>Recording the cmdlets run on the PowerShell console</h2></div></div><hr /></div><p>Often, there are situations in which you <span>perform</span><a id="id325585874" class="indexterm"></a> a series of tasks on your PowerShell console and, after quite some trial and error, come across a solution. And then you wish you had recorded everything you did on the console. You could still copy content from the console, so you try to scroll up. But you can only go so far. Your command history (a little like Bash history) can help you, but sometimes, that feels limited as well.</p><p>A few months ago, we were troubleshooting a sync issue between two of their software update distribution systems, which were supposed to work in sync. After some of us were done beating around the GUI, we decided to pick PowerShell to fix the issue. We ran a series of commands and, after a few hours of fighting with the systems, they yielded and we were back up and running.</p><p>Our managers asked for all of the steps that we took to achieve this, so that they could be documented for future use. Of course, I cannot tell you all of the steps that we took—because of the scope of this book and the agreements with our clients—but I can tell you what can help in such situations.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec111"></a>How to do it…</h3></div></div></div><p>Start PowerShell at the Terminal or use the <strong class="userinput"><code>PowerShell Integrated Console</code></strong> on Visual Studio Code:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Run the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Start-Transcript -Path ./command-transcript.txt</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>You can also simply run the cmdlet without any arguments; it would automatically create a text file with an auto-generated filename. Get the current system date and time:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Date</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>List out all of the files and directories in the current location:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem .</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Create a new directory:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Item test-transcript -ItemType Directory</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Create a new file within the directory:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Item -Path test-transcript/testing-transcript.txt -ItemType File</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Add content to the file:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; @'</strong></span>
<span class="strong"><strong>In publishing and graphic design, lorem ipsum is a placeholder text commonly used to demonstrate the visual form of a document without relying on meaningful content (also called greeking).</strong></span>
<span class="strong"><strong>Replacing the actual content with placeholder text allows designers to design the form of the content before the content itself has been produced.</strong></span>
<span class="strong"><strong>—Wikipedia</strong></span>
<span class="strong"><strong>'@ | Out-File ./test-transcript/testing-transcript.txt -Append</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Delete the directory:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Remove-Item -Path ./test-transcript -Recurse</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Stop recording what you did:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Stop-Transcript</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>You should have now received the location of the transcript file. Read the contents of the file:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content -Path ./command-transcript.txt</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/53633431-175c-4cb6-b539-a19dd92a947d.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec112"></a>How it works…</h3></div></div></div><p>A transcript created by running <code class="literal">Start-Transcript</code> stores all of your actions and the console output of all of the commands you ran in a text file. The transcript also contains some other useful information <span>pertaining</span><a id="id325905997" class="indexterm"></a> to the context the commands were run in.</p><p>A transcript file is a little more than a history file, in that the former contains the output of the commands, apart from the commands themselves.</p><p>The <code class="literal">Start-Transcript</code> cmdlet does not require any argument at all; it can create a text file at the user's home, with a unique name to ensure that no other transcript is rewritten. In other words, <code class="literal">Path</code> is an optional parameter.</p><p>This concludes this chapter about preparing for administration using PowerShell. <span>It's</span> time to crack your knuckles and refill your coffee mug. Did I tell you coffee speeds up thinking in PowerShell? It is a placebo, you say? Let's not get into an argument right now.</p></div></div>