<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec69"></a>Introduction</h2></div></div><hr /></div><p>Over the last few chapters, we attempted to build a foundational understanding of how PowerShell works. In this chapter, we turn from the taxiway to the runway. Starting with this chapter, we will work with the recipes much faster, given that we have set the foundation in understanding and using PowerShell already.</p><p>Before we go any further, the one thing that is left before we push the throttle levers is knowing about the operators we are going to be using. So, here is an overview of them before we jump into the recipes. Over the next few recipes (and possibly a couple of chapters), we will try to use each of these operators in our operations.</p><p>Operators are something we have all already <span>studied</span><a id="id326348049" class="indexterm"></a> at some point or another. Operators in PowerShell can be classified into the following nine categories:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Arithmetic operators</li><li>Assignment operators</li><li>Comparison operators</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Logical operators</li><li>Redirection operators</li><li>Split and Join operators</li><li>Type operators</li><li>Unary operators</li><li>Special operators</li></ol></div><p>Instead of going into too much theory, run the following code to see how the operators work. This should be enough to introduce us to the functionality of operators. We will put them to real use in the upcoming recipes. Here is a general explanation for each of the operators.</p><p>Arithmetic operators perform arithmetic operators such as addition and division. In PowerShell, we use them in the same way that they are used in mathematics. These operators work on two or more operands. Therefore, to add two numbers in PowerShell, you would do the following:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; 5 + 71</strong></span></pre><p>Assignment operators assign values from their right to the <span>operand</span><a id="id325945943" class="indexterm"></a> to their left, either directly (<code class="literal">=</code>) or after a modification (<code class="literal">+=</code>):</p><pre class="programlisting"><span class="strong"><strong>PS&gt; $Number = 5</strong></span>
<span class="strong"><strong>PS&gt; $Number += 71</strong></span></pre><p>Comparison <span>operators</span><a id="id325945979" class="indexterm"></a> compare two operands and return a Boolean output. In most languages, we use <code class="literal">&gt;</code> for greater than and <code class="literal">==</code> for equals. In PowerShell, they have been abbreviated, and are used along with a hyphen, as follows:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">&gt;</code>is denoted as<code class="literal">-gt</code></li><li style="list-style-type: disc"><code class="literal">&gt;=</code> is denoted as <code class="literal">-ge</code></li><li style="list-style-type: disc"><code class="literal">!=</code> is denoted as <code class="literal">-ne</code></li></ul></div><p>To check if 5 is greater than 2 in PowerShell, run the following code:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; 5 -gt 2</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note47"></a>Note</h3><p>In PowerShell, we use the automatic variables <code class="literal">$true</code> and <code class="literal">$false</code> to indicate TRUE and FALSE, respectively. This is the recommended approach as opposed to using <code class="literal">1</code> and <code class="literal">0</code> to mean TRUE and FALSE.</p></div><p> </p><p>There are other comparison operators in PowerShell, apart from the regular logical comparison operators we are used to in other languages. Two examples are <code class="literal">-match</code> and <code class="literal">-like</code>. (Their inverses are <code class="literal">-notmatch</code> and <code class="literal">-notlike</code>.) They have case-sensitive variants as well, such as <code class="literal">-cmatch</code> and <code class="literal">-cnotlike</code>. By default, matching operations in PowerShell are case-insensitive. However, if you would still like to explicitly make an operation case-insensitive, you could use the <code class="literal">-imatch</code> or <code class="literal">-inotlike</code> operators. Here are a few examples:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; 'Hello world!' -like '*world*'</strong></span></pre><pre class="programlisting"><span class="strong"><strong>PS&gt; 'Hello world!' -cmatch 'world' # Notice the absence of wildcards.</strong></span></pre><p>Bitwise <span>operators</span><a id="id326071494" class="indexterm"></a> (such as <code class="literal">-bor</code> and <code class="literal">-band</code>) fall under this category as well.</p><p>Another important subclass is regarding Containment operators. They look for <span>elements</span><a id="id326185248" class="indexterm"></a> within an array, like so:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; 'Hello', 'world', 'is', 'a', 'great', 'phrase' -contains 'world'</strong></span></pre><p>PowerShell supports logical <span>operators</span><a id="id326185265" class="indexterm"></a> as well. A few examples are <code class="literal">-and</code>, <code class="literal">-or</code>, <code class="literal">-nand</code>, and <code class="literal">-xor</code>.</p><p>Redirection operators redirect output to other streams or files. The <span>operators</span><a id="id326185288" class="indexterm"></a> are very similar to what we are used to in Bash. A couple of examples are <code class="literal">&gt;</code> (which sends the output to the file and overwrites the content if the file had any) and <code class="literal">&gt;&gt;</code> (which appends the output to the specified file). </p><p>Split and Join <span>operators</span><a id="id326348020" class="indexterm"></a> (surprise!) split strings and join substrings. <code class="literal">PowerShell rocks -split ''</code> would give you two elements, <code class="literal">PowerShell</code> and <code class="literal">Rocks</code>; the space would be used up in the split.</p><p>There are two type operators in PowerShell:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">-is</code> verifies if a certain object is of the specified type</li><li style="list-style-type: disc"><code class="literal">-as</code> tries to change the object to the specified type</li></ul></div><p>A cast operator performs an action similar to <code class="literal">-as</code>:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; ('13 July 2018' -as [datetime])</strong></span>
<span class="strong"><strong>PS&gt; ([datetime]'13 July 2018')</strong></span></pre><p>These convert the object type and also let us use the member properties and methods of the resultant object type. Pipe these to <code class="literal">Get-Member</code> to see if the object type has been modified.</p><p>Unary <span>operators</span><a id="id326348276" class="indexterm"></a> are operators such as <code class="literal">++</code> and <code class="literal">--</code>, which work on a single operand.</p><p> </p><p>An <span>array</span><a id="id326348296" class="indexterm"></a> subexpression operator—denoted by <code class="literal">@()</code>—initializes an array. Let's take an example of a pangram:</p><pre class="programlisting">PS&gt; # Create an array of strings and add them to a variable. 
<span class="strong"><strong>PS&gt; 'a', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog' | ForEach-Object { $Pangram += $PSItem }</strong></span>
<span class="strong"><strong>PS&gt; $Pangram # Call the variable</strong></span></pre><p>As you can see, the entire chunk of text came out as a single element, <code class="literal">aquickbrownfoxjumpsoverthelazydog</code>. To initialize <code class="literal">$Pangram</code> as an array instead, we can use the Array Subexpression Operator like so:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; $Pangram = @() # Initialize $Pangram as an array</strong></span>
<span class="strong"><strong>PS&gt; 'a', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog' | ForEach-Object { $Pangram += $PSItem }</strong></span>
<span class="strong"><strong>PS&gt; $Pangram # Call the variable</strong></span></pre><p>Alternatively, we can <span>leverage</span><a id="id326348835" class="indexterm"></a> the comma operator:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Remove-Variable Pangram # Delete the variable</strong></span>
<span class="strong"><strong>PS&gt; 'a', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog' | ForEach-Object { $Pangram += , $PSItem }</strong></span>
<span class="strong"><strong>PS&gt; $Pangram # Call the variable</strong></span></pre><p>To call a specific element from an array, use the index operator. To fetch the <span>third</span><a id="id326348861" class="indexterm"></a> word from the <code class="literal">$Pangram</code> array, use the following command:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; $Pangram[2]</strong></span></pre><p>A <span>subexpression</span><a id="id326352518" class="indexterm"></a> operator—denoted by <code class="literal">$()</code>—makes PowerShell execute the subexpression (the expression within the parentheses following the <code class="literal">$</code>) first, and then the rest of the expression. For instance, to see what time it would be six hours from now, and display the same within a string, we would use the following expression:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; "Six hours from now, it would be $((Get-Date).AddHours(6))."</strong></span></pre><p>Here, <code class="literal">(Get-Date).AddHours(6)</code> was executed first, and then it was shown as part of the string we specified.</p><p>The <span>range</span><a id="id326642224" class="indexterm"></a> operator—denoted by <code class="literal">..</code>—creates an array with the elements specified, within the range specified. To create an array of numbers from 43 to 67, use the following code:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; 43..67</strong></span></pre><p> </p><p>Also, try <code class="literal">[char]97..[char]106</code> to get all of the ASCII characters within the range.</p><p>Special operators are operators <span>such</span><a id="id326642252" class="indexterm"></a> as the dot-sourcing operator, the member access operator, the call operator, the formatting operator, the pipeline operator, and so on. We have already used the dot-sourcing operator and the member access operator (both: <code class="literal">.</code>), the call operator (<code class="literal">&amp;</code>), and the pipeline operator (<code class="literal">|</code>). We will cover the formatting operator (<code class="literal">-f</code>) in our recipes in this chapter.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip48"></a>Note</h3><p>Run <code class="literal">Get-Help about_Operators</code> with or without <code class="literal">-Online</code> to find out more.</p></div></div>