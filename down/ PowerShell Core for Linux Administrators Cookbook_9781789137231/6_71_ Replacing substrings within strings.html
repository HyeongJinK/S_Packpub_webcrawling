<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec75"></a>Replacing substrings within strings</h2></div></div><hr /></div><p>Now that we know how to match strings, we should also be <span>able</span><a id="id326066258" class="indexterm"></a> to replace substrings in a string.</p><p>The situation for this recipe is that one of your friends has subscribed to this aggregator that sends him blog posts in plain text. (I know—how great would that be for you, and so horrible for the maintainers of commercial websites!) The issue, though, is that the aggregator sends her only one file with all the content loaded into it. You can see the file and understand that it is, in fact, Markdown with YAML, and agree to help her make the file pure Markdown so that it can be rendered into clean HTML.</p><p>The file for use in this recipe is available in this book's GitHub repository.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec204"></a>How to do it…</h3></div></div></div><p>The contents of the file are something like this:</p><pre class="programlisting">...
The post is quite long for a read. Let's give ourselves a break here, and resume in the next post.

---
title: Enter PowerShell
date: '2017-04-04 12:00'
tags:
- windows
- powershell
---

In the last post, we spoke about how it was a challenge to get data using the CLI, for programmatic use.</pre><p> </p><p>To start with the operation of stripping the YAML out, you first need to load the content into PowerShell. Follow these steps to complete this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Get the content into the session:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $String = Get-Content ./ch06/06-rawcontent.txt -Raw</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>In case you got the file with CRLF (carriage return and line feed, which is mostly the case with Windows) instead of LF (most *nix systems), replace CRLF with LF:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $String = $String -replace '\r\n', '\n'</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>All we have to do now is replace <code class="literal">title:</code> with <code class="literal">#</code>, and remove the leading and trailing YAML boundaries:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $String = $String -replace '---\ntitle:', '#'</strong></span>
<span class="strong"><strong>PS&gt; $String = $String -replace '((^#|\n#)\s.+\n)(.+\n)+-{3}\n', '$1'</strong></span>
<span class="strong"><strong>PS&gt; $String | Out-File ./ch06/06-puregfm.md</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Perform a <code class="literal">diff</code> to see the difference between the files:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; diff ./ch06/06-rawcontent.txt ./ch06/06-puregfm.md</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip51"></a>Note</h3><p>You can use the Git commands from within PowerShell. As established earlier, PowerShell does not interfere with the shell commands, and so all Bash commands work as Bash commands themselves; syntax and everything.</p></div><p>I simply replaced the contents in the input file with the output so that I can use <code class="literal">git diff</code>. Here is the first <span>heading</span><a id="id325898676" class="indexterm"></a> that's replaced by PowerShell:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/f48065a6-f494-461c-860a-63eb60a796ad.png" /></div><p>And here is another screenshot to show that the replacement happened within the rest of the text as well:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/96e2f48f-c6da-4891-bf50-cc6e88bc4037.png" /></div><p> </p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec205"></a>How it works…</h3></div></div></div><p>To understand the entirety of how this worked, you will need to know about regular expressions.</p><p>First, there are important considerations when using the <code class="literal">Get-Content</code> cmdlet. The output of the cmdlet is <span class="emphasis"><em>not</em></span> a single string, but an array of strings. PowerShell terminates a string at a line break when using <code class="literal">Get-Content</code>. Therefore, PowerShell will be unable to match newline characters. Using the <code class="literal">-Raw</code> switch imports the content as a single string; we need the entire text as a single block. However, now, the <code class="literal">^</code> anchor works only for the beginning of the entire text. To compensate for this, we use <code class="literal">^#|\n#</code> in the regex to match the first-level <span>heading</span><a id="id325905978" class="indexterm"></a> notation.</p><p>The <code class="literal">-replace</code> operator is similar to the <code class="literal">Replace()</code> method that's available in strings, except that the operator supports regular expressions, while the method does not. The operator takes the matching string as the first argument and the replacement string as the second, and replaces all occurrences of the matching string with the replacement string. The replacement string can be a simple string, as in the case of <code class="literal">#</code>, or one or more of the matched patterns. In the latter case, we use the <code class="literal">$</code> notation to replace the group.</p><p>Note that <code class="literal">$1</code> should be a literal string to denote a match in the regular expression; ensure that you don't use the expanding string or a variable notation. Use single quotes only.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note52"></a>Note</h3><p>A brief note on the regex used in this recipe: the first matching-and-replacement was simple: three hyphens, followed by a newline, followed by <code class="literal">title:</code>.</p></div><p>For the second operation, we create logical groups:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">(Beginning with # <span class="emphasis"><em>or</em></span> newline followed by #), followed by a white space, followed by any number of any character (other than a newline), and a newline. These are post titles, and we want them retained.</li><li style="list-style-type: disc">Any number of zero or more characters (other than newline) followed by a newline, followed by three hyphens followed by a newline.</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec206"></a>There's more…</h3></div></div></div><p>Try out the same recipe with <code class="literal">Get-Content ./path/to/file.txt | Out-String -Stream</code> to learn more <span>about</span><a id="id325906066" class="indexterm"></a> the <code class="literal">-Stream</code> switch.</p></div></div>