<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec105"></a>Performing simple tasks on a hashtable</h2></div></div><hr /></div><p>Now that we know how to create a hashtable, we can <span>start</span><a id="id325677262" class="indexterm"></a> working with it. The scenario for us here is this. You need to create a verbose report of all the processes currently running on your computer. The report should have the following information:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The number of processes running on the computer</li><li style="list-style-type: disc">Whether PowerShell is running on the computer</li><li style="list-style-type: disc">Processes sorted by name</li><li style="list-style-type: disc">Average working set used</li></ul></div><p>In addition, you also need to count the number of processes after removing <code class="literal">pwsh</code> from it, and then clear the hashtable.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec278"></a>How to do it…</h3></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a report template</li><li>Fill in the values from queries using the methods that are part of the hashtable object</li></ol></div><p>Here is the script that will help you accomplish the tasks. Create a new PS1 file and add the following content to it.</p><p>The script is available as <code class="literal">10-New-ProcessReport.ps1</code> within the <code class="literal">ch09</code> directory of the code repository that accompanies the book:</p><pre class="programlisting">$Processes = @{}
Get-Process | ForEach-Object { $Processes[$PSItem.Name] = $PSItem.WS/1MB }

$Report = "The computer is currently running $($Processes.Count) processes."

if ($Processes.Contains('pwsh')) {
    $Report += "`n`nPowerShell is also running at the moment."
    $Processes.Remove('pwsh')
}
else {
    $Report += "`n`nPowerShell is not running at the moment."
}

$Report += "`n`nFollowing is the list of processes currently running, sorted by name:"

$Report += "`n`n$(($Processes.GetEnumerator() | Sort-Object Name).Name -join "`n")"

$Report += "`n`nThe average working set used is $(($Processes.Values | Measure-Object -Average).Average) MB. There are $($Processes.Count) processes running, apart from PowerShell."

$Processes.Clear()

$Report += "`n`n$($Processes.Count) processes left after clearing the list."

$Report</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec279"></a>How it works…</h3></div></div></div><p>The first two lines in the script have already been seen: they initialize a hashtable and add the processes to the hashtable. The rest of the script simply uses the members of the hashtable to give us the necessary information. For instance, <code class="literal">Count</code> is a property within the object. The <code class="literal">Contains()</code> method looks for the key, <code class="literal">pwsh</code>, and reports <code class="literal">True</code> or <code class="literal">False</code> based on whether it finds the key. The <code class="literal">Remove()</code> method removes the element identified by the key.</p><p>If you simply call <code class="literal">$Processes</code>, the list will be unsorted. In order to sort the keys or values, we use the <code class="literal">GetEnumerator()</code> method, so that PowerShell treats the hashtable as an object with two properties (<code class="literal">Name</code> and <code class="literal">Value</code>). Only then will you be able to sort the hashtable by name or value.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note61"></a>Note</h3><p>If you create a hashtable manually and call the hashtable to see its keys and values, you will see that they are not sorted in any particular way. When manually creating a hashtable, if you would like to control the sequence of the key-value pairs, use the (ordered) cast operator when initializing the hashtable (<code class="literal">[ordered]@{}</code> instead of the plain <code class="literal">@{}</code>). </p></div><p>We can also call only the names or the values. When applicable, you can also perform <span>arithmetic</span><a id="id326140837" class="indexterm"></a> operations on the values using the <code class="literal">Measure-Object</code> cmdlet.</p><p>Clearing the hashtable is as simple as calling the <code class="literal">Clear()</code> method from within the hashtable object.</p><p>Call <code class="literal">$Processes | Get-Member</code> to list out all the properties and methods of the object:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/99b04462-fb5e-4363-a70b-e1cce1f69d19.png" /></div><p>That brings us to the end of this chapter, and a little closer to being comfortable with PowerShell scripting. As noted before, where PowerShell really excels is in handling structured data. Everything is an object.</p></div></div>