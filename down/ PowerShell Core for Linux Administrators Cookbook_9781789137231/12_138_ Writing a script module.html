<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch12lvl1sec136"></a>Writing a script module</h2></div></div><hr /></div><p>A module in PowerShell is a package that may contain functions/cmdlets, variables, aliases, providers, and so on. Modules extend the capabilities of PowerShell, and can be as simple as containing just one wrapper <span>function</span><a id="id325892165" class="indexterm"></a> or as complex as allowing the user to completely manage their entire cloud infrastructure. At its core, PowerShell is only an engine; the shafts, the wheels, the body, and so on are all due to the modules.</p><p>Modules can be of different kinds, based on how they are constructed. Some examples include Binary Module, Script Module, and Manifest Module.</p><p>The focus of this recipe (and, really this book) is the Script Module.</p><p>Convert the <code class="literal">10-New-File.ps1</code> script into a module so that the users get the ability to generate filenames, as well as create files. Make changes to the script in such a way that the users see only the <code class="literal">New-File</code> cmdlet. Finally, use the <code class="literal">Generate</code> switch parameter to generate the filenames.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec352"></a>How to do it…</h3></div></div></div><p>We will create a script module with two functions. We will call one function from another. The latter function will be exposed for use. Follow these steps to get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Start a new PowerShell session.</li><li>Create a copy of the <code class="literal">10-New-File.ps1</code> file and call it <code class="literal">11-New-File.psm1</code>.</li><li>Replace the contents of the file with the following:</li></ol></div><pre class="programlisting">function New-FileName {
    param (
        # The name of the file
        [Parameter(Mandatory=$false)]
        [string]
        $Prefix='File',

        # The number of files to be generated
        [Parameter(Mandatory=$false, Position=1)]
        [int]
        $Count=1
    )

    begin {
        $InitCount = 1
    }

    process {
        while ($InitCount -le $Count) {
            Write-Output $Prefix$InitCount
            $InitCount++
        }
    }
}

function New-File {
    [CmdletBinding(
        SupportsShouldProcess=$true,
        DefaultParameterSetName='File'
    )]
    param (
        # The path to the file (or the name)
        [Parameter(Mandatory=$true, Position=0, ValueFromPipeline, ParameterSetName='File')]
        [string[]]
        $Path,

        # Whether files need to be generated
        [Parameter(Mandatory=$true, ParameterSetName='Generate')]
        [switch]
        $Generate,

        # Number of files to be generated
        [Parameter(Mandatory=$false, ParameterSetName='Generate')]
        [int]
        $Count=1
    )
    begin {
        Write-Host "$(Get-Date)"
    }
    process {
        if ($Generate) {
            $Path = New-FileName -Count $Count
        }
        foreach ($Item in $Path) {
            if ($PSCmdlet.ShouldProcess("$PsScriptRoot", "Create $Path")) {
                New-Item -Path $Item -ItemType File
            }
        }
    }
    end {}
}</pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Next, add the following to the end of the file:</li></ol></div><pre class="programlisting">Export-ModuleMember New-File</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Load the module:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Import-Module ./ch12/11-New-File.psm1</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Try to call the <code class="literal">New-FileName</code> function (it will not autocomplete).</li><li>Call the <code class="literal">New-File</code> cmdlet with the <code class="literal">Generate</code> switch:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-File -Generate -Count 4</strong></span></pre><p>Optionally, remove the <code class="literal">if</code> block for <code class="literal">ShouldProcess</code> if you do not want to be prompted each time a file is created. Of course, let the <code class="literal">New-Item</code> line remain.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec353"></a>How it works…</h3></div></div></div><p>Script Modules are almost like scripts. When loading a PowerShell script, you would call the script with the <code class="literal">.</code> calling operator, and then use the functions within. In the case of a module, though, you use the <code class="literal">Import-Module</code> cmdlet. A module could be a collection of functions that have been saved as a <code class="literal">psm1</code> file. As already mentioned, a module can be a simple one like the module we discussed in this recipe, or one that is much more complex and has many, many components.</p><p>In this recipe, the module exports only one member, which is the <code class="literal">New-File</code> cmdlet; the <code class="literal">New-FileName</code> function is not exposed for use. This is done using the <code class="literal">Export-ModuleMember</code> cmdlet. Had the cmdlet not been used, both functions would have been exported. The <code class="literal">New-FileName</code> function calls the <code class="literal">New-FileName</code> cmdlet from within it.</p><p>When loading the module, we provide the complete path to the module file. If you would like to load the module without giving the complete path, save the module file in one of the paths in <code class="literal">$env:PsModulePath</code>. PowerShell <span>looks</span><a id="id325901964" class="indexterm"></a> for module files within these paths and loads them simply by name.</p><p>The other benefit of saving the module file in one of the <code class="literal">$env:PsModulePath</code> paths is that <code class="literal">Get-Module -ListAvailable</code> (the modules available to be loaded) will show your custom module as well.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec354"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Installing modules from the repository</em></span> recipe from <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introducing PowerShell Core</em></span></li></ul></div></div></div>