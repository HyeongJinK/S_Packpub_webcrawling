<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec122"></a>Working with a script block</h2></div></div><hr /></div><p>Again, script blocks are nothing new to us. We have, in fact, used <span>script</span><a id="id325892132" class="indexterm"></a> blocks at several places in this book, such as the <code class="literal">Foreach-Object</code> cmdlet. Think of script blocks as somewhere in between a script and a function.</p><p>Implement the same functionality as the <code class="literal">Start-Count</code> function, but using a script block.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec320"></a>How to do it…</h3></div></div></div><p>The process is simple:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a copy of the <code class="literal">06-Start-Count.ps1</code> file.</li><li>Replace the first line with <code class="literal">$MyScriptBlock= {</code>. The file should now look like the following:</li></ol></div><pre class="programlisting">$MyScriptBlock = {
    param ($TotalTime = 25)

    $CurrentTime = 0

    while ($CurrentTime -le $TotalTime) {
        Write-Progress -Activity "Counting to $TotalTime" -Status "Elapsed time: $CurrentTime seconds" -PercentComplete ($CurrentTime / $TotalTime * 100)
        Start-Sleep 1
        $CurrentTime++
    }
}</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now, call the script with the dot calling operator so that the variable is loaded into the session.</li><li>Call the variable with the <code class="literal">&amp;</code> calling operator to run the script. Optionally, pass a value to the <code class="literal">TotalTime</code> parameter:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; . ./ch11/07-Start-Count.ps1</strong></span>
<span class="strong"><strong>PS&gt; &amp; $MyScriptBlock 10</strong></span>
<span class="strong"><strong>PS&gt; # Verbose version: &amp; $MyScriptBlock -TotalTime 10</strong></span></pre><p>Here is what the run will look like:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/49b63d46-e7fe-42bf-8ee3-cfa3749750ec.png" /></div><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec321"></a>How it works…</h3></div></div></div><p>A script block is essentially a series of PowerShell instructions, packaged within curly braces. These allow for a different level of flexibility by having the capability to be assigned to a variable. In this recipe, we assigned a script block to a variable. We do not change anything otherwise, including the parameter we defined in the function. This is to show that a <span>script</span><a id="id326624802" class="indexterm"></a> block is not very different from a function or a script file.</p><p>If, at the terminal, after calling the script file with a dot calling operator, you simply run <code class="literal">$MyScriptBlock</code>, the output will show the entire script block without the outermost opening and closing braces. This may give you the impression that this is nothing but a string. However, when you run <code class="literal">$MyScriptBlock | Get-Member</code>, you would be shown the type name as <code class="literal">System.Management.Automation.ScriptBlock</code>.</p><p>A script block, just like a function, can accept parameter input as well, and the syntax is no different from that of a param block within a function or a script file.</p><p>When calling the script block, you call it with the ampersand calling operator. This way, you instruct PowerShell that the variable has to be executed, and not just displayed on the host.</p><p>Alternatively, you can use the following code:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Invoke-Command $MyScriptBlock -args 10</strong></span>
<span class="strong"><strong>PS&gt; # Verbose version: Invoke-Command -ScriptBlock $MyScriptBlock -ArgumentList 10</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note73"></a>Note</h3><p>The <code class="literal">ArgumentList</code> or the <code class="literal">args</code> parameter may seem confusing at first. In our case, the script block has only one argument, <code class="literal">TotalTime</code>. It was, therefore, simple to use <code class="literal">ArgumentList</code>. In cases where there are multiple parameters specified in the script block, you would specify only the values to the script block parameters, in the order of the appearance of the arguments.</p></div><p>Note that if you use the ampersand calling operator, you will be able to call the parameters by name; this will not work with <code class="literal">Invoke-Command</code>, as noted in the information block. Therefore, using a calling operator is preferred over <code class="literal">Invoke-Command</code> in most cases.</p><p>Script blocks are useful when you write functions that accept input in the form of a script block, which will be executed when necessary. Two examples of these would be the <code class="literal">Invoke-Command</code> and <code class="literal">Start-Job</code> cmdlets.</p><p> </p></div></div>