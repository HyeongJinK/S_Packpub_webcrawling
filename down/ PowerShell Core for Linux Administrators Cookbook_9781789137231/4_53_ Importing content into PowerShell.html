<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec59"></a>Importing content into PowerShell</h2></div></div><hr /></div><p>Administrators managing multiple computers need to have <span>some</span><a id="id325906061" class="indexterm"></a> sort of input fed into cmdlets so that they can automate tasks. While most Linux administrators are familiar with sending input to files, the important point with PowerShell is that, apart from taking file-based input (read: <code class="literal">Get-Content</code>),  PowerShell is also capable of importing input. This imported input is a PowerShell object.</p><p>In this recipe, we will look at two kinds of import cmdlets and learn how to work with them.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec163"></a>How to do it…</h3></div></div></div><p>In the <span class="emphasis"><em>Parsing input from text to object</em></span> recipe in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introducing PowerShell Core</em></span>, we used <code class="literal">Import-Csv</code> to import a comma-separated values file to convert the data contained within to a PowerShell object. Let's recapitulate what we learned, but this time, now that we know how to work with objects, we will use the imported content in some way.</p><p>Before we import the content, let's first export some content into a CSV file. This way, we will have some relevant content to manipulate:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Navigate to the location where you created the files for this chapter. List the contents of the directory. While this book uses (and recommends) complete cmdlets even at the console (using tab-completion, of course), feel free to use aliases if you want:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | Select-Object Name, FullName, CreationTime, LastWriteTime, Extension, Length</strong></span></pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Export the contents to a CSV file:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | Select-Object Name, FullName, CreationTime, LastWriteTime, Extension, Length | Export-Csv ./file-list.csv</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Open the file in a spreadsheet processor such as LibreOffice Calc, or even a text editor, to view its contents:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content ./file-list.csv</strong></span></pre><p>That was a plain text representation of the object returned by <code class="literal">Get-ChildItem</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Import the contents of the CSV file to convert this text into an object:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Import-Csv ./file-list.csv</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Find the type of the object returned by this command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Import-Csv ./file-list.csv | Get-Member</strong></span></pre><p>The object type is <code class="literal">System.Management.Automation.PSCustomObject</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Check if this is the same as that returned by <code class="literal">Get-ChildItem</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem . | Get-Member</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>The object returned by <code class="literal">Import-Csv</code> is different. Is it possible to treat it just like we do other objects? Get the <code class="literal">CreationTime</code> using the member access operator:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; (Import-Csv ./file-list.csv).CreationTime</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Get just the year:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; (Import-Csv ./file-list.csv).CreationTime.Year</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Find the type of object returned by the previous command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; (Import-Csv ./file-list.csv).CreationTime | Get-Member</strong></span>

    TypeName: System.String</pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Attempt to convert the <code class="literal">LastWriteTime</code> into a <code class="literal">DateTime</code> object. Pick just the first record, though:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Date (Import-Csv ./file-list.csv | Select-Object CreationTime -First 1).CreationTime</strong></span></pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="11" type="1"><li>What if we had to retain all of the objects within the object returned by <code class="literal">Get-ChildItem</code>, including their object types?</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | Export-Clixml ./file-list.xml</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="12" type="1"><li>Now, import the contents of the XML to the session:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Import-Clixml ./file-list.xml</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="13" type="1"><li>Find out the type name of the object returned by the import command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Import-Clixml ./file-list.xml | Get-Member</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="14" type="1"><li>Pick the <code class="literal">CreationTime</code> property and find its type:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; (Import-Clixml ./file-list.xml).CreationTime | Get-Member</strong></span>

    TypeName: System.DateTime</pre><div class="orderedlist"><ol class="orderedlist arabic" start="15" type="1"><li>Pick just the year:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; (Import-Clixml ./file-list.xml).CreationTime.Year</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec164"></a>How it works…</h3></div></div></div><p>Importing content from a CSV is a straightforward process. The columns in a CSV are separated by commas. PowerShell creates an object from the input content, with each column making a property of a PowerShell custom object. Operations that we perform on objects can be performed on the <code class="literal">PSCustomObject</code>, however, the only limitation with <code class="literal">Import-Csv</code> is that the properties cannot be multi-valued, nor can they have other sub-properties within them. There could be ways to achieve multi-valued properties with CSV, but they would involve some manipulation after the object is imported within PowerShell. One such way is to separate the values of the property with a delimiter, and then, after the import, split the delimited value.</p><p>On the other hand, a <span class="strong"><strong>CLIXML</strong></span> (<span class="strong"><strong>Common Language Infrastructure XML</strong></span>) is a complete .NET object. When a PowerShell object is exported to CLIXML, the object is retained as it is. That is, the CLIXML retains all of the properties (of theoretically any depth), and the methods that were part of the output object. In other words, it can be said that a CLIXML export is almost lossless in terms of the members of the object.</p></div></div>