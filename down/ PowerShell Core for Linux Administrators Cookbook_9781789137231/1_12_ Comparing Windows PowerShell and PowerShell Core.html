<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec21"></a>Comparing Windows PowerShell and PowerShell Core</h2></div></div><hr /></div><p>Windows PowerShell and PowerShell Core are <span>two</span><a id="id325898669" class="indexterm"></a> different implementations. The former is based on a <span>larger</span><a id="id325898663" class="indexterm"></a> framework, the .NET Framework. The latter, on the other hand, is a more modern framework, the .NET Core. PowerShell Core is cross-platform since its parent is. Windows PowerShell, on the other hand, is Windows-only, but has more capabilities than PowerShell at the time of writing this book.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip17"></a>Note</h3><p>The PowerShell that this book talks about is the cross-platform PowerShell Core. This is referred to as PowerShell. The PowerShell that is Windows-specific is referred to as Windows PowerShell.</p></div><p>Windows PowerShell leverages the internal components and the architectural model of Windows, with its capabilities enhanced by WinRM as well as Windows Management Instrumentation. In fact, most of the differences exist because of the inherent differences between Windows and Unix-like operating systems.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec48"></a>Support for snap-ins</h3></div></div></div><p>PowerShell will not support the legacy version of modules, also known as <span class="strong"><strong>snap-in</strong></span><span class="strong"><strong>s</strong></span>. Many of the snap-ins of old have been repackaged to be binary modules. Therefore, the <span>unavailability</span><a id="id326645564" class="indexterm"></a> of snap-ins should not be of much concern. Future development of these binary modules should, in theory, work on either PowerShell, provided that the host supports the API calls that are part of the binaries. For example, let's <span>imagine</span><a id="id325892276" class="indexterm"></a> that the Windows Active Directory module was repackaged into a binary PowerShell module. This module would run on Windows PowerShell as well as PowerShell on Windows. However, since Windows Active Directory does not run on Linux, the module would not work with PowerShell on Linux.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec49"></a>Convenience aliases</h3></div></div></div><p>One important point to note is that <span>commands</span><a id="id325892258" class="indexterm"></a> such as <code class="literal">ls</code> and <code class="literal">mkdir</code> are aliases in Windows PowerShell, which means that running <code class="literal">ls</code> on Windows PowerShell would run <code class="literal">Get-ChildItem</code> in the background (this is also true for PowerShell on Windows). In Linux, however, running <code class="literal">ls</code> from within PowerShell would run the actual <code class="literal">ls</code> command; <code class="literal">ls</code> is not an alias in PowerShell on Linux—it is the command itself, whose output would be plain text. You can validate this by running <code class="literal">ls | Get-Member</code> on PowerShell on Linux, and comparing it with PowerShell on Windows as well as Windows PowerShell (it is, therefore, good to stick to the best practice of not using aliases in scripts):</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/7c0269e3-ec61-4113-84e0-328554de2fc0.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"></a>Note</h3><p>PowerShell knows whether it is running on Linux, Windows, or macOS by means of the values of the automatic variables <code class="literal">IsLinux</code>, <code class="literal">IsWindows</code>, and <code class="literal">IsMacOS</code>. On any system, only one of these variables has the value <code class="literal">True</code>. When PowerShell sees that <code class="literal">IsLinux</code> is <code class="literal">True</code>, it would run Linux commands instead of the convenience aliases that were initially created to facilitate Linux administrators. For more information on these automatic variables, read the <span class="emphasis"><em>Configuring built-in variables</em></span> recipe.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec50"></a>PowerShell Workflows</h3></div></div></div><p>Windows administrators who are used to <span>PowerShell</span><a id="id325885504" class="indexterm"></a> Workflows in Windows PowerShell need to note that they are absent in PowerShell. PowerShell Workflows were a little advanced (to put it nicely) and were used in specific scenarios where multiple cmdlets were to be run in parallel, or activities had to, say, survive a reboot. Workflows work on the Windows Workflow Foundation, which is not cross-platform. Therefore, PowerShell Workflows will not run on PowerShell. However, the unavailability of PowerShell Workflows is no deal-breaker. Workflows were not used much either.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec51"></a>PowerShell Desired State Configuration</h3></div></div></div><p><span class="strong"><strong>Desired State Configuration</strong></span> (<span class="strong"><strong>DSC</strong></span>) is a work in <span>progress</span><a id="id325901994" class="indexterm"></a> at the time of writing this book. As of now, there are two code bases of DSC resources: LCM for Linux, which is managed by Microsoft's Unix team, and DSC Resources for Windows PowerShell, which was written by the <span>PowerShell</span><a id="id325905958" class="indexterm"></a> team. It could be some time before the DSC code base becomes cross-platform.</p></div></div>