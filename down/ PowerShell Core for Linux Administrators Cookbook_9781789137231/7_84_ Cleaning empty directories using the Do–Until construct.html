<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec87"></a>Cleaning empty directories using the Do–Until construct</h2></div></div><hr /></div><p>It is easy to confuse <code class="literal">Do–While</code> and <code class="literal">Do–Until</code>, since they share a lot of similarities. However, the difference <span>between</span><a id="id325892162" class="indexterm"></a> them is in fact pretty clear. The <code class="literal">Do–While</code> loop executes as long as the outcome of the condition check is <code class="literal">$true</code>, and exits the moment it becomes <code class="literal">$false</code>. <code class="literal">Do–Until</code> is the opposite: the loop continues as long as the condition check returns <code class="literal">$false</code>, and stops the moment the condition check returns <code class="literal">$true</code>.</p><p>Let's use the same scenario of cleaning up empty folders, this time using the <code class="literal">Do–Until</code> loop.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec231"></a>Getting ready</h3></div></div></div><p>To work with this recipe, let's create a few empty directories within <code class="literal">$HOME/random</code>. Use the input file that is part of the Git repository of this book to create the directories:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content ./ch07/08-input-file.txt | ForEach-Object { New-Item $($PSItem -replace '\.', "$HOME/random") -ItemType Directory }</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec232"></a>How to do it…</h3></div></div></div><p>You will need to rerun the command to create the empty directories. Follow these steps to get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open a new file and paste the following content into it:</li></ol></div><pre class="programlisting">$Iteration = 0
do {
    $AllDirectories = (Get-ChildItem -Path $HOME/random -Recurse -Directory).FullName
    $EmptyDirectories = $AllDirectories | Where-Object {(Get-ChildItem $PSItem).Count -eq 0}
    $EmptyDirectories | Remove-Item
    $Count = $EmptyDirectories.Count

    Write-Output "Iteration $Iteration`nRemoved the following $Count directories. '$Count = 0' is $($Count -eq 0)"
    $EmptyDirectories
    $Iteration++
} <span class="strong"><strong>until</strong></span> ($Count <span class="strong"><strong>-eq</strong></span> 0)</pre><p> </p><p> </p><p> </p><p> </p><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Note the change in behavior this time and compare it with the run of <code class="literal">Do–While</code>.</li></ol></div><p>Note how there was an empty iteration 5, just like with the <code class="literal">Do–While</code> loop:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/a039be4b-74ee-4fed-ae32-1a497b5de07b.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec233"></a>How it works…</h3></div></div></div><p>This time, it was made evident in the interactive <span>output</span><a id="id325585853" class="indexterm"></a> how it works. The first run happened without checking for the condition. At the end of the run, the condition was checked for. <code class="literal">9</code> is greater than <code class="literal">0</code>, and not equal. The outcome was <code class="literal">$false</code>, so the loop continued. It went on this way until the count came down to <code class="literal">0</code> (making the outcome of the condition <code class="literal">$true</code>), at which point, the loop exited. Essentially, the loop statement was: Go on until the count becomes zero.</p></div></div>