<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec94"></a>Performing base conversions</h2></div></div><hr /></div><p>The previous recipe was a simple <span>conversion</span><a id="id325585864" class="indexterm"></a> using a cast operator and string addition. Next, we will look at converting an integer into multiple bases, such as octal, hexadecimal, and binary strings.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec250"></a>How to do it…</h3></div></div></div><p>The input will be taken as a string. The output would also be string, but with octal, hexadecimal, and binary representations. We will use a .NET accelerator for this:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open a new PowerShell file and type the following:</li></ol></div><pre class="programlisting">$InputString = Read-Host "Enter an integer"

Write-Host "Octal representation: " -NoNewline
Write-Host "$([Convert]::ToString($InputString, 8))"

Write-Host "Hexadecimal representation: " -NoNewline
Write-Host "$([Convert]::ToString($InputString, 16))"

Write-Host "Binary representation: " -NoNewline
Write-Host "$([Convert]::ToString($InputString, 2))"</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Run the script and enter an integer to get the octal, hexadecimal, and binary representations of it.</li></ol></div><p> </p><p>Do not forget to try negative numbers as well:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/e512071f-9a2c-45f0-a22f-b844219ed963.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec251"></a>How it works…</h3></div></div></div><p>This recipe leverages the <code class="literal">[System.Convert]</code> .NET accelerator. The input and the output of the script are strings.</p><p>The <code class="literal">ToString()</code> method accepts input in the form of <code class="literal">int64</code>. When only one argument is passed, the integer is output as it is, except the object type is no longer <code class="literal">int</code>, but <code class="literal">string</code>. The optional second argument passed to the method is the base: <code class="literal">2</code> stands for decimal, <code class="literal">8</code> stands for octal, and <code class="literal">16</code> stands for hexadecimal.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec252"></a>There's more…</h3></div></div></div><p>When I was learning PowerShell, I came across a recipe, <span class="emphasis"><em>Work with Numbers as Binary</em></span>, in the book <span class="emphasis"><em>Windows PowerShell Cookbook</em></span> by Lee Holmes, where he showed how file attribute flags worked in PowerShell. To see <span>what</span><a id="id326667233" class="indexterm"></a> attributes are available in PowerShell for files and directories, and see their decimal and binary representations, enter the following at the PowerShell prompt:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; [Enum]::GetValues([System.IO.FileAttributes]) | Select-Object `</strong></span>
<span class="strong"><strong>@{ n = 'Property'; e = { $_ } }, `</strong></span>
<span class="strong"><strong>@{ n = 'Integer'; e = { [int]$_ } }, `</strong></span>
<span class="strong"><strong>@{ n = 'Hexadecimal'; e = { [Convert]::ToString([int]$_, 16) } }, `</strong></span>
<span class="strong"><strong>@{ n = 'Binary'; e = { [Convert]::ToString([int]$_, 2) } }</strong></span></pre><p> </p><p> </p><p>This is what the command gives you:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/e219533b-60e2-4c60-8c4f-294bda7ab7ed.png" /></div><p>That brings us to the end of this chapter. Basic arithmetic calculations have been omitted since they are no different from any of the most common languages.</p></div></div>