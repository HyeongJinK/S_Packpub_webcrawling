<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec110"></a>Searching for content</h2></div></div><hr /></div><p>It is uncommon for a Linux administrator to be <span>unfamiliar</span><a id="id325885502" class="indexterm"></a> with <code class="literal">grep</code>, <code class="literal">sed</code>, and <code class="literal">awk</code>. PowerShell has similar functionalities built in, although these cmdlets and operators deal with text as objects, rather than as plain strings. There are little nuances that we would need to remember when working with PowerShell. In this recipe, we will look at searching for content in files from within PowerShell. The <code class="literal">Select-String</code> cmdlet, our string-related operators, such as <code class="literal">like</code> and <code class="literal">match</code>, and the object-based pipeline collectively help us with this.</p><p>Imagine you have a collection of markdown files. These files contain PowerShell code blocks. You have to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Find the PowerShell code blocks present in the files within the directory. Show the filename, the line number, and the match, each on a separate line.</li><li>Contextually show what each of those code blocks is for. This time, use the properties from within the returned object, and show the output as a table.</li><li>List out all the files that contain the word <code class="literal">command</code> in them. Show how many times the word appears in each of the files. Exclude the first cheatsheet for the first chapter.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>List out all the files that contain the word <code class="literal">PowerShell</code> (case-sensitive) in them.</li><li>Place all of this content in a single text file, so that it can be sent as a report.</li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec290"></a>Getting ready</h3></div></div></div><p>You need some text files for this recipe. The easiest way to do it is to clone the repository for the book, and use the cheatsheets. Another way is to download a few text files to work with. In the latter case, you would need to modify the script to suit your search strings, filenames, and extensions. This recipe assumes that you have the repository cloned.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec291"></a>How to do it…</h3></div></div></div><p>The task here is primarily to look for text patterns. We use the following script to accomplish these tasks (it is recommended that you view this script in a code editor—the file is available as <code class="literal">04-Search-FileForPattern.ps1</code> within the <code class="literal">ch10</code> directory):</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip64"></a>Note</h3><p>Modify the values for <code class="literal">$ReportPath</code> and <code class="literal">$CheatsheetPath</code> to suit your setup and preferences.</p></div><pre class="programlisting">$ReportPath = "$HOME/random/FileSearchReport.txt"
$CheatsheetPath = "$HOME/Documents/code/github/powershell/cheatsheets"

if (!(Test-Path $ReportPath)) {
    New-Item $ReportPath -ItemType File -Force
}

"Here are the PowerShell code blocks present within the cheatsheets." | Out-File $ReportPath
Select-String '```powershell' $CheatsheetPath/*.md | 
    ForEach-Object {
        $PSItem = $PSItem -split ':'
        Write-Output "File Name: $($PSItem[0])"
        Write-Output "Line number: $($PSItem[1])"
        Write-Output "Pattern: $($PSItem[2])`n"
    } | Out-File $ReportPath -Append

&lt;# Verbose version:
Select-String -Pattern '```powershell' -Path $CheatsheetPath/*.md
#&gt;

"Here is a contextual report of all the PowerShell code blocks:" | Out-File $ReportPath -Append
Select-String '```powershell' $CheatsheetPath/*.md -Context 2, 2 |
    Select-Object Path, LineNumber, `
    @{ Name = "Before"; Expression = { $PsItem.Context.PreContext -join "`n" } }, `
    @{ Name = "After"; Expression = { $PsItem.Context.PostContext -join "`n" } } |
        Format-List | Out-File $ReportPath -Append

"Here are the files that contain the word, 'command' in them, except the cheatsheet for the first chapter:" | Out-File $ReportPath -Append
Select-String 'command' $CheatsheetPath/*.md -Exclude '*chapter-01.md' |
    Group-Object Path |
        Select-Object Name, Count |
            Format-Table -AutoSize | Out-File $ReportPath -Append

"Here are the files that contain the word, 'PowerShell' in them." | Out-File $ReportPath -Append
Select-String -CaseSensitive 'PowerShell' $CheatsheetPath/*.md -Exclude '*chapter-01.md' | 
    Select-Object Path -Unique | 
        Format-Table -AutoSize | Out-File $ReportPath -Append</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec292"></a>How it works…</h3></div></div></div><p>The script may seem fairly long, and complicated. However, if you look at it piece by piece, there are four pieces to it. And here is how each of them works.</p><p>The first piece introduces you to <span>searching</span><a id="id326633939" class="indexterm"></a> for patterns in files. We already saw <code class="literal">Select-String</code> in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introducing PowerShell Core</em></span>, where we looked for a certain string within the Help documentation. That was when a certain string content was passed through the pipeline to <code class="literal">Select-String</code>. In this recipe, however, we leverage the file-handling capabilities of the cmdlet by passing the file path(s) as well as the pattern that we are looking for. <code class="literal">Select-String</code> returns the matches as an array, each element being the complete line that contains the pattern. In our case, the line and the match are the same, since the pattern in question itself appears as a line in the files.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note65"></a>Note</h3><p>A little note on markdown and code blocks: <code class="literal">```powershell</code> tells the GitHub-Flavored Markdown renderer that the content that follows is a code block, and that it is PowerShell code. <code class="literal">```</code> itself stands for the code fence. When the name of the language follows, it aids in syntax highlighting.</p></div><p> </p><p>Since this result is in the form of an array, we are able to use <code class="literal">Foreach-Object</code> on it. Within the script block, we split the results at <code class="literal">:</code>, and display the contents in a meaningful manner, all using string manipulation.</p><p>The majority of the second piece is simply the definition of the calculated properties. (So much for formatting!) What is important is that the results that are shown on the screen are simply formatted textual representation of the actual result object; a concise way of showing the <code class="literal">Path</code>, the <code class="literal">LineNumber</code>, and the <code class="literal">Line</code> that contains the pattern. The piece demonstrates leveraging the object model to get the path, the line number, and two lines before and after the matched line. Two lines is defined in <code class="literal">Select-String</code>, using the <code class="literal">Context</code> parameter. The first number that appears after <code class="literal">-Context</code> is the number of lines before the one that contains the pattern in question, and the second is the number of lines after. The <code class="literal">PreContext</code> and <code class="literal">PostContext</code> properties are arrays themselves (because PowerShell treats each line as a separate string). Therefore, we <code class="literal">join</code> the elements with a newline character. Finally, we format the content as a list, since that would make the most sense in this situation. If you would rather export this as a CSV file, use a different character for <code class="literal">-join</code>, and replace <code class="literal">Format-List</code> with <code class="literal">Export-Csv</code>.</p><p>The third piece leverages <code class="literal">Group-Object</code> so that it shows us the number of matches with <code class="literal">Count</code> in its output. We also use the <code class="literal">Exclude</code> parameter in <code class="literal">Select-String</code> and specify the file we would like to exclude. This matches the complete path of the file; therefore, you either give the complete path, or use a wildcard, depending on the context.</p><p>The fourth piece is similar to the third, except that we are not concerned about the count. Therefore, we simply pick the <code class="literal">Path</code> property from the output of <code class="literal">Select-String</code>, and use the <code class="literal">Unique</code> parameter of <code class="literal">Select-Object</code> to show a file only once, not once per match. Also, we use the <code class="literal">CaseSensitive</code> parameter in <code class="literal">Select-String</code>, for case-sensitive pattern matching.</p></div></div>