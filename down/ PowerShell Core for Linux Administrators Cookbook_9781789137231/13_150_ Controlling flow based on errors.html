<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec147"></a>Controlling flow based on errors</h2></div></div><hr /></div><p>There are situations where <span>errors</span><a id="id325585873" class="indexterm"></a> can be handled by scripts. For instance, let's say that you are trying to create a file at a certain location during an operation. Say you want to save this file within the Logs directory within your home directory. Your home directory does not contain a Logs directory just yet. You want to make your script handle the creation of the directory if it encounters <code class="literal">ItemNotFoundException</code>.</p><p> </p><p>You have the lab directory that you created for use with this book. You need to create a log file within a directory called <code class="literal">LogDir</code>, situated within the lab directory. If <code class="literal">LogDir</code> does not exist, the script should create it upon encountering the appropriate exception.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec372"></a>How to do it…</h3></div></div></div><p>The first step for creating actions depending on the situation is identifying the situation itself. In this case, it is specifically identifying the exception. Follow these steps to get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Run the following command to find the name of the exception:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Item random/log.log</strong></span>
<span class="strong"><strong>PS&gt; $Error | select *</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Look for the following line: <code class="literal">Exception : System.IO.DirectoryNotFoundException: Could not find a part of the path</code>. The exception that occurred here is <code class="literal">System.IO.DirectoryNotFoundException</code>.</li><li>Now, create a new script file and add the following content to it:</li></ol></div><pre class="programlisting">function New-LogFile {
    param (
        # The path to the log file
        [Parameter(Mandatory=$false)]
        [string]
        $Path = "$HOME/random/LogDir",

        # The name of the log file
        [Parameter(Mandatory=$false)]
        [string]
        $Name = 'MyLog.log'
    )

    try {
        New-Item "$Path/$Name" -ItemType File -ErrorAction Stop
    }
    catch [System.IO.DirectoryNotFoundException] {
        New-Item $Path -ItemType Directory -Force
        New-LogFile
    }
    catch {
        "Some error other than DirectoryNotFound"
    }
}</pre><p> </p><p> </p><p>The script should now execute without errors.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec373"></a>How it works…</h3></div></div></div><p>Errors can be broadly classified into two kinds: terminating and non-terminating errors. In this recipe, we used the <code class="literal">try</code>–<code class="literal">catch</code> construct to handle errors and actions related to them. The <code class="literal">catch</code> statement executes in case of errors in the <code class="literal">try</code> block, but only if the error in the <code class="literal">try</code> block is terminating. In our situation, though, the error returned upon not finding that the directory is a non-terminating error. For the <code class="literal">catch</code> block to be executed, we need to make the error a terminating one.</p><p>There are two ways to handle this. Either set the <code class="literal">$ErrorActionPreference</code> variable to <code class="literal">Stop</code>, or explicitly make errors generated by the <code class="literal">New-Item</code> statement terminate. The latter approach is recommended (and used in this recipe,) since that gives us better control over error handling – we should choose which errors should be terminating errors. To make errors from a specific statement terminate, we must apply the common parameter <code class="literal">ErrorAction</code> and set <code class="literal">Stop</code> as its value. We place the statement, along with the <code class="literal">ErrorAction</code> parameter, in the <code class="literal">try</code> block.</p><p>We write two <code class="literal">catch</code> blocks: one specifically for the error caused by the directory that doesn't exist, and another that's a catch-all <code class="literal">catch</code> block. In the first <code class="literal">catch</code> block, we specify the name of the exception. Within this block, we specify the action to be taken upon this exception being thrown.</p><p>Now, when the script is executed and the function is called, PowerShell promptly goes to the first <code class="literal">catch</code> block and creates the directory, and calls the function again.</p><p>If you would like to see the flow of the script, enter <span>debug</span><a id="id325892286" class="indexterm"></a> mode with the <code class="literal">Step</code> parameter. Refer to the <span class="emphasis"><em>Running a script in debug mode</em></span> recipe for more information.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec374"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Running a script in debug mode</em></span> recipe</li></ul></div><p> </p></div></div>