<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec27"></a>Configuring automatic variables</h2></div></div><hr /></div><p>Perhaps nothing contributes to efficiency like configurability. Configuring a <span>system</span><a id="id325669219" class="indexterm"></a> is a way of tuning it to your taste. You are the only one who knows what works best for you. Therefore, the more configurable a system is, the better it can be tweaked to your preference. Automatic variables in PowerShell are one of the first steps to customization in PowerShell (profiles are the other; we shall look into them shortly). In this recipe, we will list out all of the automatic variables and configure some of them to our requirements.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec68"></a>Getting ready</h3></div></div></div><p>Read the <span class="emphasis"><em>Listing the various providers in PowerShell</em></span> recipe of <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introducing PowerShell Core</em></span>, to learn how to use the various providers in PowerShell.</p><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec69"></a>How to do it…</h3></div></div></div><p>Let's first list out the variables we have. This can be done in two ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Using a cmdlet</li><li style="list-style-type: disc">Using a provider</li></ul></div><p>Let us first look at using the cmdlet to list out the variables built into PowerShell:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open a Terminal window. If you have one open, restart PowerShell.</li><li>Find the cmdlet that works with variables:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Command -Noun Variable</strong></span></pre><p>Remember that the noun in a cmdlet is always singular. Therefore, it would be <code class="literal">Variable</code> and not <code class="literal">Variables</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>There are five cmdlets that deal with variables. We want to fetch a list of all variables already existing in a new session of PowerShell. Let us pick <code class="literal">Get-Variable</code> and fetch help information for it:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Get-Variable</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>This is the cmdlet that we need to list out all of the variables predefined in the current scope:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Variable</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip26"></a>Note</h3><p>Any variables you define would be listed here. Hence, it is important that you start a fresh session of PowerShell to see what variables have been predefined.</p></div><p>Let's now use a PowerShell provider to list out the variables defined in the current scope:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>List out the PowerShell providers. We looked at providers in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introducing PowerShell Core</em></span>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-PsProvider</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Change the location to the <code class="literal">Variable:</code> drive of the <code class="literal">Variable</code> provider. This is done using <code class="literal">Set-Location</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Set-Location Variable:</strong></span></pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now, let us list out all of the available child items of the <code class="literal">Variable:</code> drive:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem</strong></span></pre><p>The output of this was identical to that of <code class="literal">Get-Variable</code>, called without an argument.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec70"></a>How it works…</h3></div></div></div><p>PowerShell is built with some variables that control its behavior, and <span>administrators</span><a id="id325892151" class="indexterm"></a> are allowed to modify some of them to suit their needs. Some variables, however, cannot be modified; they are contextual and add some amount of flexibility (or modularity, as the case might be) to the shell.</p><p>One such example would be <code class="literal">$PWD</code>, which contains the path of the present directory. This variable changes itself based on the execution of <code class="literal">Set-Location</code>. Values cannot be explicitly assigned to such variables; setting values explicitly would have no effect on the behavior of the shell.</p><p>Some variables, on the other hand, accept values and let us control the execution of commands and scripts. We shall look at an example in the next recipe.</p></div></div>