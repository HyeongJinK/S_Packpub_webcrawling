<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec111"></a>Working with locations</h2></div></div><hr /></div><p>Without a doubt, working with <span>locations</span><a id="id325898665" class="indexterm"></a> is an important aspect of scripting when working with files and directories. This recipe deals with file and directory objects, their properties, and a few cmdlets that help with paths.</p><p> </p><p>The scenario for this recipe is that you need to find the location where the script is running from. You need to find the complete path of the script. Also, similar to the lab setup script, create a new path (do not create the files yet) within the home directory, and create dummy file paths within the new directory (again, no actual files yet). The important point to remember is that this script should be platform-agnostic; it should run without errors on Windows, Linux, and macOS environments. Also, you have a group of users using your computer. Find out which among those users has a directory called <code class="literal">random</code> within their home directory. (Launch PowerShell with <code class="literal">sudo</code> for this task.)</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec293"></a>How to do it…</h3></div></div></div><p>The last point is important here, because the <code class="literal">home</code> directory is located in entirely different locations on Linux and Windows (macOS behaves similarly to Linux in this regard). Also important is the fact that a space in Unix-like systems is specified with a backslash, which is an escape character here. On Windows, the backslash is the path separator.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip66"></a>Note</h3><p>In many (or perhaps most) situations, it does not matter whether you use the <code class="literal">/</code> or the <code class="literal">\</code> character as the path separator in PowerShell on Windows or on Windows PowerShell. However, as with any situations, using a forward slash on Windows as the path separator could cause errors in scripts.</p></div><p>This is the flow we will use for this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>In the first part of the script, call for the present working directory.</li><li>In the second part, call for the complete path of the script.</li><li>Next, use <code class="literal">New-Item</code> to create files within a directory, using <code class="literal">Join-Path</code> to create complete paths</li></ol></div><p>Type in and run the following script:</p><pre class="programlisting">"The script is located within:"
$PSScriptRoot

Read-Host "Press Enter to continue"

"Here is the complete path to the script that was run:"
$PSCommandPath

Read-Host "Press Enter to continue"

"Here are the file paths asked for, as per the scenario:"
'random-text.txt', 'himalayas.jpg', 'crunched-numbers.csv', 'screenshot-001.png', 'screenshot-002.png', 'screenshot-003.png', 'demo.doc', 'my-plugin.rb' | ForEach-Object { Join-Path -Path $HOME -ChildPath $PSItem }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Finally, list out the paths to <code class="literal">random</code> from within <code class="literal">/home</code>; in other words, the list of directories within <code class="literal">/home</code> that contain <code class="literal">random:</code></li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; exit</strong></span>
<span class="strong"><strong>$ sudo pwsh</strong></span>
<span class="strong"><strong>PS&gt; Resolve-Path /home/*/random/ | Split-Path -Parent | Split-Path -Leaf</strong></span></pre><p>Now, to how it all worked.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec294"></a>How it works…</h3></div></div></div><p>The current location, or the present working <span>directory,</span><a id="id325905963" class="indexterm"></a> can be gotten in different ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">By calling the <code class="literal">$pwd</code> automatic variable</li><li style="list-style-type: disc">By calling the <code class="literal">Get-Location</code> cmdlet at the terminal (this will not work within a script)</li><li style="list-style-type: disc">Using the <code class="literal">$PSScriptRoot</code> automatic variable, when calling for a location within a script</li></ul></div><p>Also, there is an automatic variable called <code class="literal">$PSCommandPath</code>, which stores the location of a script being executed. Again, if you call this variable at the terminal, it will not give you any value.</p><p>When creating paths, in order to eliminate possibilities of errors in resolution, it is best to use the <code class="literal">Join-Path</code> cmdlet, with the necessary arguments. Based on the system the script is being run on, <code class="literal">Join-Path</code> will use the right path separator and create the complete path. <code class="literal">Join-Path</code> works with other PowerShell providers as well; therefore, it will work with, for example, the <code class="literal">Variable</code> provider or even the Windows Registry. Use the <code class="literal">Resolve</code> switch parameter to check whether the path that was created after joining the path and the child path exists or not. <code class="literal">Join-Path</code> is particularly useful when creating a certain directory at multiple parent paths; for instance, when you want to complete a child path, <code class="literal">TestDir</code>, under <code class="literal">/home</code>, <code class="literal">/etc</code>, <code class="literal">/var</code>, and <code class="literal">/boot</code>:</p><pre class="programlisting">Join-Path /home, /etc, /var, /boot -ChildPath TestDir</pre><p>When creating multiple files under the new demo directory, we used a single parent path, and multiple child paths. The <code class="literal">ChildPath</code> parameter accepts only a single string, and therefore we send an array of the string into the pipeline, and then use <code class="literal">Foreach-Object</code> for the <code class="literal">ChildPath</code>:</p><pre class="programlisting"># Create a single path at multiple parent paths:
Join-Path /home, /etc, /var, /boot -ChildPath TestDir

# Create multiple child paths at a parent directory:
'file1.txt', 'file2.txt', 'file3.txt' | ForEach-Object { Join-Path -Path $HOME/dir/ -ChildPath $PSItem }</pre><p>At the fourth step, we use the <code class="literal">Resolve-Path</code> cmdlet along with a wildcard for the directory name. This returns output, such as <code class="literal">/home/ram/random</code>. We need <code class="literal">ram</code> in this example. For this, we use the <code class="literal">Split-Path</code> cmdlet; we pick the <code class="literal">Parent</code> at the first step, thereby picking <code class="literal">/home/ram</code>, and then we pick the <code class="literal">Leaf</code> (or the child directory), which is now <code class="literal">ram</code> in this example.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec295"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Listing the various providers in PowerShell</em></span> recipe from <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introducing PowerShell Core</em></span></li></ul></div></div></div>