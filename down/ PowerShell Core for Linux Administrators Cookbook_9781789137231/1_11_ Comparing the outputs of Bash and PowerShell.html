<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec20"></a>Comparing the outputs of Bash and PowerShell</h2></div></div><hr /></div><p>PowerShell and Bash are both shells, and are <span>capable</span><a id="id325962794" class="indexterm"></a> of interacting with the kernel. Just like Bash can run on Windows, PowerShell can now run on Linux. While almost all of the aspects of which shell is better than the other is debatable, and the choice of shell is simply a matter of personal preference today, it is true that PowerShell is as powerful as .NET Core can get.</p><p>The primary difference between the two shells is that PowerShell outputs objects, while Bash returns text. Manipulation of the output in Bash involves manipulating text first, and then running further commands on the manipulated text to fetch the desired output. PowerShell, on the other hand, handles content as objects and, by design, requires comparatively less manipulation.</p><p>Structured data, as noted by Jeffrey Snover (the inventor of Windows PowerShell), is getting more popular as days pass, and structured data is where PowerShell shines the most.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec44"></a>Getting ready</h3></div></div></div><p>In this recipe, we are going to pick one example to show you how simple and efficient it is to handle file metadata using PowerShell, primarily since the output is an object. We will list the files and folders within our home directory, along with the date and time of modification using both <code class="literal">ls</code> in Bash and <code class="literal">Get-ChildItem</code> in PowerShell.</p><p>We will use PowerShell to run the Linux commands as well.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec45"></a>How to do it…</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>At the Bash prompt, enter <code class="literal">ls -l</code> to list all of the files, along with the metadata that the command shows by default:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137231/graphics/414841e9-0e58-4a51-b90f-270b73f1a053.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Go to the Terminal that has PowerShell running and type in <code class="literal">Get-ChildItem</code> at the prompt:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137231/graphics/4d4c0626-e93e-4e4b-9cf7-1e31347e1550.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now, let's pick only the name of the folders and the last modified date and time. This is done in Bash by passing the output of <code class="literal">ls -l</code> to <code class="literal">awk</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>ls -l | awk '{print $6, $7, $8, $9}'</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/3dc56e84-021c-4d27-8ccc-7279a75ddda2.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Next, let's pick the same information on PowerShell as well:</li></ol></div><pre class="programlisting"><span class="strong"><strong>Get-ChildItem | select LastWriteTime, Name</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/d7fd2118-a189-43e1-9bf3-3fd32d26c808.png" /></div><p>As you may have noticed, the <span>output</span><a id="id325901976" class="indexterm"></a> is very similar in both cases. However, with PowerShell, you can see the names of the columns as well, which means that you do not have to look for further documentation. Also, the selection of columns is simpler in PowerShell; no text manipulation is required. On the other hand, in Bash, we can use the <code class="literal">awk</code> command to manipulate the text output.</p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Let's go one step further and create a subdirectory with a space in the name:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ mkdir 'test subdirectory'</strong></span>
<span class="strong"><strong>$ ls -l | awk '{print $6, $7, $8, $9}'</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/0d2fbd46-e03d-4037-ab75-dd17e68921f0.png" /></div><p>Note that what should have been <strong class="userinput"><code>test subdirectory</code></strong> appears as <strong class="userinput"><code>test</code></strong>. Compare this with the output from PowerShell:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/c170beeb-a312-4c81-a326-8f362a67df7f.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec46"></a>How it works…</h3></div></div></div><p>PowerShell reads content from the filesystem as objects, not as text. Therefore, you perform a selection of the desired columns (or, as we shall later see, properties) directly. Bash, on the other hand, outputs text, columns from which are manipulated using a delimiter.</p><p>To demonstrate that this is the case, we <span>created</span><a id="id325905997" class="indexterm"></a> a new subdirectory with a space in its name, and we performed the column selection just like we did before, only in this case we did not get the complete name of the new subdirectory. This is because the name contained a whitespace, which is a delimiter in <code class="literal">awk</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"></a>Note</h3><p>Comparing Bash and PowerShell is like comparing apples and oranges—in more ways than one. However, understanding the differences helps us leverage each of the tools to our benefit.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec47"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Selecting columns from the output</em></span> recipe from <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Passing Data Through the Pipeline</em></span></li></ul></div></div></div>