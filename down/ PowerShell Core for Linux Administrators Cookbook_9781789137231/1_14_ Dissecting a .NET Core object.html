<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec23"></a>Dissecting a .NET Core object</h2></div></div><hr /></div><p>This is a tangential recipe, in case you are <span>interested</span><a id="id326185280" class="indexterm"></a> in seeing how PowerShell has been implemented.</p><p>.NET Core works on a cross-platform standard Common Language Infrastructure. Therefore, it has been possible to encapsulate the internal workings of Linux using .NET Core. As we will see in future chapters, PowerShell is object-oriented, just like .NET Core. For this demonstration, we will pick a simple system class called <code class="literal">System.IO.DirectoryInfo</code> to show information about a certain directory. We will also compare the output of the .NET Core object to the output of a PowerShell cmdlet, which also shows information about a certain directory.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip23"></a>Note</h3><p>You do not have to remember the names of the .NET Core classes or methods, or their syntax to work with PowerShell; that is the whole point of the existence of PowerShell. However, if you need information on the .NET libraries and the classes, extensive help documentation is available online ().</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec56"></a>Getting ready</h3></div></div></div><p>Every object has members—properties and methods. In case you're new to the concepts of object-oriented programming, properties are qualities of an object (what the object has), and methods are the capabilities of an object (what the object can do). Therefore, to quote (arguably) the most overused example of properties and methods: if a car is an object, its height, its color, and so on would be its properties, while accelerating, braking, and so on would be the methods that the object supports.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec57"></a>How to do it…</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>With PowerShell, .NET Core is also installed as a dependency. Let's create an object in PowerShell that will call a .NET class and its default constructor. This constructor requires an argument:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Object -TypeName System.IO.DirectoryInfo -ArgumentList $HOME</strong></span></pre><p>Here, <code class="literal">/home/ram</code> is my home directory. Replace <span>this</span><a id="id326071485" class="indexterm"></a> path with yours.</p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Use the <code class="literal">Get-Item</code> cmdlet with the same argument as before, and see what you get:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Item $HOME</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Close! Now, let's look at the members of the output object we just received by using <code class="literal">Get-Member</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Item $HOME | Get-Member</strong></span></pre><p>This will list a series of members (properties, methods) that are part of the output. We're primarily concerned about the very first line for now.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec58"></a>How it works…</h3></div></div></div><p>Note the very first line of the output, <code class="literal">TypeName: System.IO.DirectoryInfo</code>. That is the exact type name we used when we created the .NET object:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/e8ff0b55-89ab-4334-9fd7-d393b6e88525.png" /></div><p>This proves that the same task of showing information on the current working directory can be achieved by either calling a .NET constructor or by running a <span>PowerShell</span><a id="id325885505" class="indexterm"></a> cmdlet, the implication being that PowerShell cmdlets are simply encapsulated .NET code. In essence, <code class="literal">Get-Item</code> calls the <code class="literal">System.IO.DirectoryInfo</code> class under the hood, with the arguments passed along with the cmdlet.</p><p>Like they say: "If the C# guys can do it, so can you."</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec59"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">System.IO.DirectoryInfo</code> .NET <span>class</span><a id="id325892158" class="indexterm"></a> (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/api/system.io.directoryinfo?redirectedfrom=MSDN&amp;view=netframework-4.7.2" target="_blank">https://docs.microsoft.com/en-us/dotnet/api/system.io.directoryinfo?redirectedfrom=MSDN&amp;view=netframework-4.7.2</a>)</li></ul></div><p> </p></div></div>