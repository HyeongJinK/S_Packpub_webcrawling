<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec19"></a>Parsing input from text to object</h2></div></div><hr /></div><p>Moving to the object model from <span>text</span><a id="id325905970" class="indexterm"></a> could seem a little daunting at first. However, with PowerShell, it is not very hard to switch to the new model, especially given that PowerShell can convert text into objects given the right tools. In this recipe, we will look at two of the ways that PowerShell converts textual data into objects.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec39"></a>Getting ready</h3></div></div></div><p>Before we dive into the recipe, let's give ourselves a little introduction to how text-to-object parsing is handled. One way is to use .NET's built-in functionality, and the second way involves using a cmdlet to perform the conversion based on a delimiter.</p><p>The basic requirement for this recipe is simple: you simply need PowerShell installed on your computer. We will edit the file within PowerShell. If you would be more comfortable using a text editor instead, that works as well. Most Linux distributions pack a text editor. If not, use your package manager to install Vim, Nano, Gedit, Visual Studio Code, Atom, or any other text/code editor.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec40"></a>How to do it…</h3></div></div></div><p>First, we will look at converting text into an object from a plain text input at the Terminal. This involves using what is known as a PowerShell Type Accelerator. A PowerShell Type Accelerator is an alias for .NET classes. Using these, we can call .NET classes and use many of their functionalities within PowerShell:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Let's take plain text as input and convert the text into a date object. To check what sort of object your input is, use the <code class="literal">Get-Member</code> cmdlet:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; '21 June 2018' | Get-Member</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"></a>Note</h3><p>Enclosing any text within single quotes defines the text as a non-expanding literal string. No explicit definition is required in this case.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The <code class="literal">TypeName</code> says <code class="literal">System.String</code>. This confirms that what we entered was plain text. Now, let's use a Type Accelerator (or, more specifically, a cast operator) and convert this text into a <code class="literal">DateTime</code> object. The accelerator for this purpose is <code class="literal">[DateTime]</code>; place this accelerator before the literal string:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; [DateTime]'21 June 2018'</strong></span>

Thursday, 21 June 2018 00:00:00</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Next, find the <code class="literal">TypeName</code> of the object that was returned:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; [DateTime]'21 June 2018' | Get-Member</strong></span>

   TypeName: System.DateTime</pre><p>Voila, the string has been successfully parsed into date and time!</p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>It is also possible to achieve the same result with the <code class="literal">Get-Date</code> cmdlet when it is called with the <span>text</span><a id="id325677264" class="indexterm"></a> argument:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Date '21 June 2018'</strong></span>

Thursday, 21 June 2018 00:00:00</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Similarly, the <code class="literal">TypeName</code> would be as follows:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Date '21 June 2018' | Get-Member</strong></span>

   TypeName: System.DateTime</pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Just like we did in the previous recipe, we can now manipulate the object to show information in a more meaningful way. For instance, if you care only about the year, you would write the following:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; (Get-Date '21 June 2018').Year</strong></span>
2018</pre><p>The other way of converting text into an object is to use cmdlets that perform such tasks. PowerShell packs a few converter cmdlets, one of which is <code class="literal">Import-Csv</code>. You may have noticed that PowerShell usually generates output in a tabular format. This is a simple representation of objects. The <code class="literal">Import-Csv</code> cmdlet converts data in a delimited row-and-column structure into objects, where each row is an instance of the object itself, and each column is a property of the object:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>To demonstrate this, let's create a CSV file with the following content in it. At the PowerShell prompt, type/paste in the following:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; @'</strong></span>
<span class="strong"><strong>WS,CPU,Id,SI,ProcessName</strong></span>
<span class="strong"><strong>161226752,23.42,1914,1566,io.elementary.a</strong></span>
<span class="strong"><strong>199598080,77.84,1050,1040,gnome-shell</strong></span>
<span class="strong"><strong>216113152,0.67,19250,1566,atom</strong></span>
<span class="strong"><strong>474685440,619.05,1568,1566,Xorg</strong></span>
<span class="strong"><strong>1387864064,1890.29,15720,1566,firefox</strong></span>
<span class="strong"><strong>'@ | Out-File sample.csv</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip15"></a>Note</h3><p>You could perform the same operation using the <code class="literal">touch</code> command and the text editor of your choice. The goal is to get the content into the sample file.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Next, read the contents of the file using PowerShell:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content ./sample.csv</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>That looks like simple text. Let's look at the type name of the <span>object</span><a id="id326071450" class="indexterm"></a> to confirm that this is indeed plain text. Type in the following:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content ./sample.csv | Get-Member</strong></span>

   TypeName: System.String</pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>That is a plain and simple string. Now, let's convert the content into a simple object. This is done using <code class="literal">Import-Csv</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Import-Csv ./sample.csv</strong></span></pre><p> </p><p>That should give you a list-like output, like so:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/9d78574f-859a-47e8-84ff-7385b2581597.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>To confirm that the output is objects, list out its members:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137231/graphics/b3e338e7-2988-4028-9986-ce83c1fd217f.png" /></div><p> </p><p> </p><p> </p><p>In general, the content is a custom object, which is denoted by <code class="literal">PSCustomObject</code>. The columns we had in the CSV are of type <code class="literal">NoteProperty</code>, as shown by <code class="literal">MemberType</code>.</p><p>A <code class="literal">NoteProperty</code> is a generic property whose characteristics are similar to those of a string. While most properties are inherited from .NET, <code class="literal">NoteProperty</code> is custom-created within PowerShell as a name-value pair.</p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>If you would rather look at the content as a table, format the content as a table. You can do this by using the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Import-Csv ./sample.csv | Format-Table</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/437f2e5a-283c-4f53-8097-1b69b67e35bd.png" /></div><p>We have successfully converted text into an object. However, note that this is just a <span>simple</span><a id="id326581010" class="indexterm"></a> conversion, and that the output of <code class="literal">Import-Csv</code> is still string-like. Although all of the content is now string-based objects, these are easier to handle in PowerShell.</p><p>Also note that <code class="literal">Format-Table</code> and other <code class="literal">Format-*</code> cmdlets output strings. These are among the handful of PowerShell cmdlets that do not generate a .NET object. Therefore, do not use any of these format cmdlets if you would like to process an object further. The format cmdlets should only be used at the end of the pipeline.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec41"></a>How it works…</h3></div></div></div><p>Type accelerators are another form of encapsulation of .NET code in PowerShell. Recall the first recipe in this chapter, wherein we created a .NET object within PowerShell. We used the PowerShell command <code class="literal">New-Object -TypeName System.IO.DirectoryInfo -ArgumentList '/home/ram'</code> to get information on a home directory: we created a new instance of <code class="literal">System.IO.DirectoryInfo</code> and passed an argument to it. That was a lot of code to write. To accelerate this process, we could use <code class="literal">[IO.DirectoryInfo]'/home/ram'</code> (<code class="literal">System</code> is the default namespace; PowerShell will understand it without us explicitly mentioning it when calling accelerators), which outputs the same object as the former command.</p><p>With <code class="literal">Import-Csv</code>, on the other hand, the process is a simple conversion of data from text into name-value pairs. This is similar to using <code class="literal">ConvertFrom-Text</code> with a <code class="literal">Delimiter</code> parameter. This way, we instruct PowerShell to convert each row of text into instances of the object: the first row in the row-column structure is taken as the property name, and the rest of the rows are data. The cells are separated using a delimiter, which was a comma in the case of the CSV file.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec42"></a>There's more…</h3></div></div></div><p>Look for more conversion cmdlets that are built into PowerShell. This can be done using the <code class="literal">Get-Command -Verb ConvertFrom</code> command.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec43"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">More about type <span>accelerators</span><a id="id325589925" class="indexterm"></a> in the Hey, Scripting Guy! Blog (<a class="ulink" href="https://blogs.technet.microsoft.com/heyscriptingguy/2013/07/08/use-powershell-to-find-powershell-type-accelerators/" target="_blank">https://blogs.technet.microsoft.com/heyscriptingguy/2013/07/08/use-powershell-to-find-powershell-type-accelerators/</a>)</li><li style="list-style-type: disc">The <span class="emphasis"><em>Understanding Here-Strings</em></span> recipe from <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Working with Strings</em></span></li><li style="list-style-type: disc">The different kinds of members (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.psmembertypes?view=pscore-6.0.0" target="_blank">https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.psmembertypes?view=pscore-6.0.0</a>) in PowerShell</li></ul></div><p> </p></div></div>