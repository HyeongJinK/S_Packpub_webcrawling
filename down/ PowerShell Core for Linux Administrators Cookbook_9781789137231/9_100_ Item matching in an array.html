<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch09lvl1sec101"></a>Item matching in an array</h2></div></div><hr /></div><p>In the <span class="emphasis"><em>Searching for an item in an array</em></span> recipe, we searched for a specific name <span>using</span><a id="id326260610" class="indexterm"></a> the <code class="literal">contains</code> comparison operator. This way, we looked for a complete element, without wildcards or regex.</p><p>In this recipe, we will use wildcard and regex matching to find elements that match a pattern.</p><p>Build on the <span class="emphasis"><em>Accessing and manipulating array items </em></span>recipe<span class="emphasis"><em> </em></span>and look for individuals whose last names end with <code class="literal">son</code>. Perform this search using the <code class="literal">like</code> and the <code class="literal">match</code> comparison operators.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec269"></a>How to do it…</h3></div></div></div><p>The flow is simple. All we have to do is replace the <code class="literal">contains</code> operator with <code class="literal">like</code> or <code class="literal">match</code>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the names from the text file.</li><li>Look for the elements that end with <code class="literal">son</code> within the newly constructed array.</li><li>Flip the first and last names so the format is <code class="literal">LastName, FirstName</code>:</li></ol></div><pre class="programlisting">$Names = Get-Content ./ch09/02-names.txt
$Names = $Names -match 'son$'

# or $Names = $Names -like '*son'

$NewNames = @()

foreach ($Name in $Names) {
    $Name = $Name -split ' '
    $NewName = $Name[1], $Name[0] -join ', '

    $NewNames += $NewName
}
$NewNames</pre><p>Alternatively, you could swap the second and the third steps and use a slightly different approach:</p><pre class="programlisting">$Names = Get-Content ./ch09/02-names.txt
$NewNames = @()

foreach ($Name in $Names) {
    $Name = $Name -split ' '
    $NewName = $Name[1], $Name[0] -join ', '

    $NewNames += $NewName
}
"Using the match operator:"
$NewNames -match 'son,'

"Using the like operator:"
$NewNames -like '*son,*'</pre><p>Depending on the number of elements in the array, the processing time in the second approach may be higher given that PowerShell would have to swap positions of the first and last names a greater number of times.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec270"></a>How it works…</h3></div></div></div><p>The <code class="literal">match</code> and <code class="literal">like</code> comparison operators can take input as single elements or as arrays. When the operators are used on arrays, the comparison operation runs on each of the elements of the array. Think of this as being equivalent to the <code class="literal">Where-Object</code>-based filtration. In other words, <code class="literal">$NewNames -match 'son'</code> is very similar to <span>using</span><a id="id325885496" class="indexterm"></a><code class="literal">$NewNames | Where-Object { $PsItem -match 'son' }</code>.</p><p> </p><p>That brings us to performing some more complex filtration; when such a need arises, use the <code class="literal">Where-Object</code> cmdlet instead of a plain <code class="literal">match</code> or <code class="literal">like</code> on the array. Performing Boolean <code class="literal">AND</code> or <code class="literal">OR</code> operations with plain matching and multiple conditions will only produce a Boolean output. For instance, if you are using the name list supplied with the chapter, the output to the following would only be <code class="literal">True</code>:</p><pre class="programlisting">$NewNames -match 'son,' -and $NewName -notmatch 'Erick'</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl2sec271"></a>There's more…</h3></div></div></div><p>Find the individuals in the list whose last names end with <code class="literal">son</code>, and whose first names do not contain <code class="literal">Erick</code>.</p></div></div>