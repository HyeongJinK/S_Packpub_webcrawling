<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec16"></a>Finding and installing PowerShell modules</h2></div></div><hr /></div><p>Loosely coupling the components is one of the keys to the success of a framework. PowerShell follows this principle as well. All cmdlets are packaged within <span>PowerShell</span><a id="id326638677" class="indexterm"></a> modules. The modules can be first-party provided, created by you, or created by other software vendors.</p><p> </p><p>Initially, extending PowerShell capabilities was done using snap-ins. With <span>PowerShell</span><a id="id325892131" class="indexterm"></a> 2.0, PowerShell modules were introduced. One other place that Microsoft has gotten it right is advocating the use of modules over snap-ins. The installation of PowerShell modules, which could have been a hassle in the past, has been streamlined today. PowerShell now comes pre-packaged with a package manager called <code class="literal">PowerShellGet</code>, which connects to the official Microsoft <span>PowerShell</span><a id="id325885496" class="indexterm"></a> Gallery (<a class="ulink" href="https://www.powershellgallery.com" target="_blank">https://www.powershellgallery.com</a>). The PowerShell Gallery is an online repository that contains modules, scripts, and other utilities that have been created by providers—as well as the community—that administrators can download and install to extend PowerShell's capabilities.</p><p>While it is possible to download PowerShell modules from third-party sites, our focus in this book will be on the PowerShell Repository.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec28"></a>How to do it…</h3></div></div></div><p>We will start by finding cmdlets that work with modules, and proceed to work with these modules:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Launch PowerShell by running <code class="literal">pwsh</code> on the Terminal.</li><li>Look for commands that work with modules:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; get-command -no module PS&gt; # Verbose version: Get-Command -Noun 'Module'</strong></span></pre><p>The output should look something like this:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/3c1baad1-d2d0-498f-930b-5f71c0f8aac6.png" /></div><p> </p><p>Pick <code class="literal">Find-Module</code> for this task. If you would like to, use the <code class="literal">Get-Help</code> cmdlet to learn about what <code class="literal">Find-Module</code> does.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Search for a module to help you work with <code class="literal">Docker</code> containers:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137231/graphics/9120e47b-6981-46e0-b3b6-4581481d85f5.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Now, install the module. You will need to use superuser privileges to install the Docker module. Use the following command to install Docker without having to exit the current PowerShell session:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; sudo pwsh -c install-module docker</strong></span></pre><p>If you would rather use a new session and call the <code class="literal">Install-Module</code> cmdlet from within it, terminate the current PowerShell session and launch a new one with <code class="literal">sudo</code>:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/8ba54b57-8b3e-4add-b9ea-cc5219c6c21f.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>To update a module, use the <code class="literal">Update-Module</code> cmdlet:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Update-Module docker</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>To uninstall a module <span>from</span><a id="id326071481" class="indexterm"></a> the machine, use the <code class="literal">Uninstall-Module</code> cmdlet:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Uninstall-Module docker</strong></span></pre><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>To load a certain module into the current session, use the <code class="literal">Import-Module</code> cmdlet. You do not need elevated privileges to load or unload a module to or <span>from</span><a id="id326185254" class="indexterm"></a> the session:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Import-Module docker</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>To remove a module from the session, use the <code class="literal">Remove-Module</code> cmdlet:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Remove-Module docker</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec29"></a>How it works…</h3></div></div></div><p>Hundreds of modules, scripts, and Desired State Configuration resources have been registered with the <code class="literal">PSGallery</code> repository. Microsoft now recommends using this repository for module management. Using the <code class="literal">Find-Module</code> cmdlet, PowerShell makes a connection to the repository and gets a list of all available modules. Then, it runs a search on the returned results based on the criteria you mention.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip10"></a>Note</h3><p>In PowerShell, <code class="literal">Find</code> usually means working with the internet, and <code class="literal">Get</code> is usually used to get objects from the local machine.</p></div><p>You can also find scripts that can perform repetitive tasks. To find scripts, use the <code class="literal">Find-Script</code> cmdlet. It works similar to the <code class="literal">Find-Module</code> cmdlet, except that it finds individual scripts rather than modules.</p><p>Installation of modules is a simple process of pulling the modules down <span>from</span><a id="id326222327" class="indexterm"></a> the repository, similar to <code class="literal">npm</code> or <code class="literal">chocolatey</code>. These tasks are taken care of by the <code class="literal">PowerShellGet</code> module, which ships with PowerShell. Installing, updating, and uninstalling PowerShell modules may require elevated privileges.</p><p>To load the capabilities of a module into the PowerShell session, use <code class="literal">Import-Module</code>. PowerShell modules have members such as cmdlets, functions, aliases, and so on for sessions. <code class="literal">Import-Module</code> loads these members into the session. By default, the sessions are unloaded when exiting the session. However, if you would like to manually unload them, use the <code class="literal">Remove-Module</code> cmdlet. <code class="literal">Remove-Module</code> does not remove the entire module; it just unloads it.</p><p> </p><p>The modules are installed in one of the <code class="literal">$env:PsModulePath</code> directories. You don't need to specify the path to modules that are installed this way. If the module files are saved elsewhere, you will need to specify the path to the module's <code class="literal">psd1</code> or <code class="literal">psm1</code> file when calling <code class="literal">Import-Module</code>. Also, some modules enable automated loading. Just call a cmdlet from the module, and the module will auto-import.</p><p><code class="literal">Import-Module</code> has parameters such as <code class="literal">-Prefix</code> and <code class="literal">-NoClobber</code>. The <code class="literal">-Prefix</code> parameter adds the specified prefix to the nouns of all of the cmdlets in the module. For instance, <code class="literal">Import-Module docker -pre dm</code> will import the Docker cmdlets as <code class="literal">Invoke-dmDockerCommand</code> instead of <code class="literal">Invoke-DockerCommand</code>. The <code class="literal">-NoClobber</code> switch helps in cases where there may be cmdlet name conflicts; it prevents the already loaded cmdlets from being replaced by the ones from the module being imported.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec30"></a>There's more…</h3></div></div></div><p>Try installing the module in portable mode, by first saving the module using <code class="literal">Save-Module</code> and then calling <code class="literal">Import-Module</code> with the path to the module file as the parameter.</p><p>You can also get the list of directories from which PowerShell discovers modules. At the prompt, type the following and press the <span class="emphasis"><em>Enter</em></span> key<span class="emphasis"><em>:</em></span></p><pre class="programlisting"><span class="strong"><strong>PS&gt; $env:PSModulePath</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec31"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Writing a script module</em></span> recipe in <a class="link" href="#" linkend="ch12">Chapter 12</a>, Advanced Concepts of Functions</li><li style="list-style-type: disc">The <span class="emphasis"><em>Calling a PowerShell script</em></span> recipe in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Preparing for Administration using PowerShell</em></span></li></ul></div></div></div>