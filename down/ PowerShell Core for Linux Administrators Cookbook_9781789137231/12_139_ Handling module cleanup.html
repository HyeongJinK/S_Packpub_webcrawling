<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch12lvl1sec137"></a>Handling module cleanup</h2></div></div><hr /></div><p>In the case of a simple script module, you may not <span>necessarily</span><a id="id325892280" class="indexterm"></a> need to handle module cleanup. However, when you write more complex modules, it is necessary that the module members be cleaned up when the module is removed.</p><p>Set up the cleanup of the custom module you created in the previous recipe, <span class="emphasis"><em>Writing a script module</em></span>; simply write a host output stating that the module has been cleaned up. The cleanup should take place upon invoking <code class="literal">Remove-Module</code>. You also need to ensure that the the module cleanup happens, even if the PowerShell session is terminated without invoking <code class="literal">Remove-Module</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec355"></a>How to do it…</h3></div></div></div><p>Add the following block to the end of your module file and save the file:</p><pre class="programlisting">$MyInvocation.MyCommand.ScriptBlock.Module.OnRemove = {
    Write-Output "Module cleaned up."
}

Register-EngineEvent PowerShell.Exiting {
    Remove-Module '12-New-File'
}</pre><p>Remove the module from the session to see what this does.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec356"></a>How it works…</h3></div></div></div><p>Members of a module share private state. In the case of simple script modules like the one in this recipe, it is not quite necessary to perform explicit cleanup. However, it is good to know how it can be done. </p><p> </p><p> </p><p>There are two aspects to consider:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The module is unloaded using the <code class="literal">Remove-Module</code> cmdlet</li><li style="list-style-type: disc">The PowerShell session is terminated without the user running <code class="literal">Remove-Module</code></li></ul></div><p>To perform a task (or tasks) upon running the <code class="literal">Remove-Module</code> cmdlet on the module in question, you must create a script block with the cmdlets that should be run during the module removal. This script block is then assigned to the <code class="literal">$MyInvocation.MyCommand.ScriptBlock.Module.OnRemove</code> object. In our case, we do not perform a real cleanup; we simply display a line that says that the module has been cleaned up. This <code class="literal">Write-Host</code> line can be replaced with actual cleanup commands, as and when required.</p><p>The second situation is if the module was never removed, but the <span>PowerShell</span><a id="id325585863" class="indexterm"></a> session was terminated. Termination of the session is an engine event, and tasks to be invoked in such situations should be sent to the engine. Therefore, we use the <code class="literal">Register-EngineEvent</code> cmdlet with the <code class="literal">PowerShell.Exiting</code> identifier. Here, we simply add the <code class="literal">Remove-Module</code> cmdlet, which in turn invokes the <code class="literal">$MyInvocation.MyCommand.ScriptBlock.Module.OnRemove</code> script block, thereby gracefully handling the cleanup.</p></div></div>