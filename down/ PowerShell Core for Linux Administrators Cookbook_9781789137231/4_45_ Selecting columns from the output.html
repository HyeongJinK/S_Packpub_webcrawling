<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec51"></a>Selecting columns from the output</h2></div></div><hr /></div><p>When my brother saw me exploring <code class="literal">awk</code>, he said, "Boy, have we overused this command!". Of course, not everything displayed on the screen is important—or even necessary. In this recipe, we <span>will</span><a id="id326264112" class="indexterm"></a> learn how to separate columns in PowerShell without using the Linux command <code class="literal">awk</code>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec138"></a>Getting ready</h3></div></div></div><p>Go to a directory that has some files that we can play with. If you do not have such a directory, create one and create some files in there. Let the files be of different extensions so that we can use them in future recipes as well.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip38"></a>Note</h3><p>If you have not already, clone the Git repository, which you can find at <a class="ulink" href="https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook" target="_blank">https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook</a>. There is a quick-and-dirty script called <code class="literal">Initialize-PacktPs6CoreLinuxLab.ps1</code> under the <code class="literal">ch04</code> directory. Run the script to get the necessary files.</p></div><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec139"></a>How to do it…</h3></div></div></div><p>The <code class="literal">awk</code> command works with text, and, based on the delimiters in the output text, separates the output into columns. This separated output is displayed as columns again when you use the <code class="literal">print</code> function, like in C. PowerShell works a little differently.</p><p>Let's get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>If you haven't create any files yet, please do so. Here are some commands you could use to create the files:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Item ./random/cities -ItemType Directory -Force</strong></span>
<span class="strong"><strong>PS&gt; Set-Location ./random/</strong></span>
<span class="strong"><strong>PS&gt; New-Item random-text.txt, himalayas.jpg, crunched-numbers.csv, bangalore.jpg, screenshot-001.png, screenshot-002.png, screenshot-003.png, demo.doc, my-plugin.rb, ./cities/mumbai.html, ./cities/nyc.html, ./cities/cairo.html, ./cities/dubai.html, ./cities/paris.html -ItemType File</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>You may also want to download some real multimedia content, just so we get the <code class="literal">length</code> (file size) property for future use. Just download any random images or media files.</li><li>Navigate to the location where you saved the files. I have them in a directory called <code class="literal">random</code> in my home directory. You would, too, if you used the <code class="literal">Initialize-PacktPs6CoreLinuxLab.ps1</code> script:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Set-Location ./random/</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip39"></a>Note</h3><p>Use tab-completion to complete the cmdlet, as well as the path.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>List out the contents in the current location:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path .</strong></span></pre><p> </p><p>A sample output is shown in the following screenshot:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/cc8d9918-e35c-4f16-8158-a381b80a6e51.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Let us say that you don't need the <code class="literal">Mode</code> column:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | Select-Object LastWriteTime, Length, Name</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note40"></a>Note</h3><p>It's important to note that, by using <code class="literal">Select-Object</code>, you are stripping the object of the properties that you did not call with <code class="literal">Select-Object</code>. Therefore, the object returned at the end of the preceding command would not have properties such as <code class="literal">CreationTime</code>, <code class="literal">FullName</code>, and so on, anymore.</p></div><p> </p><p>Here is the output of the preceding command:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/34a2226e-ac01-4a4a-a7e9-ba68fac5d0be.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip41"></a>Note</h3><p>As you may have noticed, <code class="literal">Select-Object</code> does not follow the naming or capitalization convention that PowerShell uses. Why is that? Run <code class="literal">Get-Command select</code> to find out.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>This sequence does not really make sense in the <span>current</span><a id="id325909561" class="indexterm"></a> context. Shuffle the columns:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | Select-Object Name, Length, LastWriteTime</strong></span></pre><p> </p><p>Note how the output columns are rearranged compared to the previous output:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/19705cac-dfc3-4479-9153-481bf28f020d.png" /></div><p>That looks much better.</p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Now, change the column name of <code class="literal">LastWriteTime</code> to <code class="literal">Modified</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | Select-Object Name, Length, @{Name='Modified'; Expression={$_.LastWriteTime}}</strong></span></pre><p>Note the name of the last column now, and compare it with the previous output.</p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Now, pick just the year—not the entire date:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | Select-Object Name, Length, @{Name='Modified'; Expression={$_.LastWriteTime.Year}}</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>See how many days have passed since the last change:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | select Name, Length, @{Name='DaysSinceModification'; Expression={[math]::Round(((Get-Date) - $_.LastWriteTime).TotalDays)}}</strong></span></pre><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec140"></a>How it works…</h3></div></div></div><p>If you ran <code class="literal">Get-Command select</code>, you would have <span>understood</span><a id="id326096676" class="indexterm"></a> by now that <code class="literal">select</code> is in fact an alias for <code class="literal">Select-Object</code>. As already established, PowerShell outputs objects. These objects are then formatted using built-in formatting rules that are shown on the screen in a certain way.</p><p>When we use <code class="literal">Select-Object</code>, we override the formatting rules by specifying which objects need to be shown to us. While the primary objective of <code class="literal">Select-Object</code> is to pick the columns we need, the cmdlet also allows us to sequence the output columns.</p><p>PowerShell also gives us the freedom to modify the name of the columns that are returned. In such a case, we use a hashtable to specify the name that we want, and what data we want shown under the column. You can even perform calculations on the data that's returned, and make this a calculated property. At the last step, we subtract the date of last modification from the current date, pick the total number of days that have passed since, and then use the <code class="literal">Round</code> method of the <code class="literal">[math]</code> accelerator to get a rounded figure of the number of days since the last modification.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec141"></a>There's more…</h3></div></div></div><p>Try <code class="literal">Select-Object</code> with other cmdlets such as <code class="literal">Get-Command</code> to select only the columns that you need.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec142"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Creating a simple hash table </em></span>recipe in <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Using Arrays and and Hashtables</em></span></li><li style="list-style-type: disc">Read the recipe, <span class="emphasis"><em>Filtering Objects</em></span>, to know more about the automatic variable, <code class="literal">$_</code></li></ul></div></div></div>