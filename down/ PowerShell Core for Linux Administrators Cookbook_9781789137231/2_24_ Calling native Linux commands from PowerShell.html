<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec32"></a>Calling native Linux commands from PowerShell</h2></div></div><hr /></div><p>In <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introducing PowerShell Core</em></span>, we saw <span>how</span><a id="id326185240" class="indexterm"></a> native Linux commands were not convenience aliases in PowerShell on Linux, but the commands themselves. In this recipe, we will demonstrate using Linux commands at the PowerShell prompt. Remember, we used a Bash Terminal to run the <code class="literal">ls -l</code> and <code class="literal">awk</code> commands to list the contents of a directory and separate the columns in the output in the recipe, <span class="emphasis"><em>Comparing the outputs of Bash and PowerShell</em></span> in <a class="link" href="#" linkend="ch01">Chapter 1</a>, <span class="emphasis"><em>Introducing PowerShell Core</em></span>. We will perform the same operation on the <code class="literal">home</code> directory, from within PowerShell, without using any of the PowerShell cmdlets.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec88"></a>Getting started</h3></div></div></div><p>It is recommended that you have a Windows PC with PowerShell installed on it (Windows PowerShell would also do) in order to compare the output and see if we encounter any errors.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec89"></a>How to do it…</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>At the PowerShell prompt, type in the following command to list the contents of the directory:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; ls -l</strong></span></pre><p>You see the familiar output (albeit without any of the colors if your Terminal emulator uses colors for filenames).</p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Let us now look at the .NET type name of the output. For this, we need to use the <code class="literal">Get-Member</code> cmdlet:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; ls -l | Get-Member</strong></span></pre><p>PowerShell displays <code class="literal">TypeName: System.String</code>, which is consistent with what we saw in the aforementioned recipe.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>If you have a Windows PC with PowerShell (or Windows PowerShell), run the same command on it:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; ls -l | Get-Member</strong></span></pre><p> </p><p>Notice the .NET type name here; it is <code class="literal">System.IO.DirectoryInfo</code> and, if you scroll down the console a little, you will also see <code class="literal">System.IO.FileInfo</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>At the PowerShell on Windows (or Windows PowerShell) prompt, type the following:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; ls -l</strong></span></pre><p>You will receive an error, stating that there was no value given to the parameter, <code class="literal">LiteralPath</code>:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/45e7358a-6ca5-44fb-a0ca-91425ca6a1bb.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>At the PowerShell prompt on the Windows PC, enter the following and press the <span class="emphasis"><em>Tab</em></span> key on your keyboard, instead of <span class="emphasis"><em>Enter</em></span>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; ls -l</strong></span></pre><p>You will see that the parameter name was completed to <code class="literal">LiteralPath</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Press the <span class="emphasis"><em>Esc</em></span> key to clear the command line.</li><li>Come back to Linux and, at the PowerShell prompt, type in the following and press the <span class="emphasis"><em>Tab</em></span> key:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; ls -l</strong></span></pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Nothing happens. Now, enter the following and press the <span class="emphasis"><em>Tab</em></span> key:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -l</strong></span></pre><p>The parameter name was completed to <code class="literal">-LiteralPath</code>. Let us take one more step and conclude this recipe.</p><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>At the PowerShell prompt on Windows, run the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Alias ls</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/09b4ac04-acc0-44b7-9761-24c98e8d65e1.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Switch back to Linux and run the same command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Alias ls</strong></span></pre><p> </p><p>You receive an error stating that there is no such alias:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/478241e0-aead-47fe-9e66-f07ed3569c39.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec90"></a>How it works…</h3></div></div></div><p>When we run any of the Linux commands on <span>PowerShell</span><a id="id325898625" class="indexterm"></a> on Linux, PowerShell does not call the convenience aliases that were created for the benefit of Linux administrators, when Windows PowerShell was launched; these convenience aliases have not been included in PowerShell on Linux. PowerShell, instead, runs the actual Linux commands and shows the output on the console. Piping the output to other Linux commands work the same way as they do on Bash, when running them on PowerShell on Linux.</p><p>The first point to note is that <code class="literal">ls -l</code> is an actual command in Linux, and it returns the list of files and directories in the current directory, in a table format. When the same command is run on PowerShell on Windows, we receive an error, since PowerShell on Windows interprets <code class="literal">ls</code> as <code class="literal">Get-ChildItem</code> and <code class="literal">-l</code> as the incomplete but definitive call to <code class="literal">-LiteralPath</code> and returns an error that the literal path was not specified.</p><p>When we run <code class="literal">Get-Alias</code> on <code class="literal">ls</code> on both operating systems, PowerShell on Linux returns an error, while PowerShell on Windows shows the underlying PowerShell cmdlet.</p><p> </p><p> </p><p>The other point that pins down this fact is that the output of <code class="literal">ls</code> is a string, as opposed to a system object, when the same <code class="literal">ls</code> is run on PowerShell on Windows. On Windows, PowerShell calls <code class="literal">Get-ChildItem</code> under the hood and the output shown is that of <code class="literal">Get-ChildItem</code>. This is supported by the type name in the output of <code class="literal">Get-Member</code>, which is from the <code class="literal">System.IO</code> namespace. On the other hand, on Linux, running <code class="literal">Get-Member</code> on <span>the</span><a id="id325905957" class="indexterm"></a> output of <code class="literal">ls</code> simply returns <code class="literal">System.String</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec91"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">about_Aliases (<a class="ulink" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases?view=powershell-6" target="_blank">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases?view=powershell-6</a>)</li></ul></div></div></div>