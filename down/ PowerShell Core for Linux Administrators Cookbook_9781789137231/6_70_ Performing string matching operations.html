<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec74"></a>Performing string matching operations</h2></div></div><hr /></div><p>Matching operations are mostly performed using the <code class="literal">-like</code>, <code class="literal">-notlike</code>, <code class="literal">-match</code>, and <code class="literal">-notmatch</code> operators. These also come in case-sensitive (<code class="literal">-clike</code>, <code class="literal">-cnotmatch</code>) and <span>forced</span><a id="id325901965" class="indexterm"></a> case-insensitive (<code class="literal">-inotlike</code>, <code class="literal">-imatch</code>) variants.</p><p>We have a situation for this recipe.</p><p>One of your friends works for a travel agency and gets an automated CSV file of sites that contain great articles of categories including travel, and lifestyle. (The aggregator service that creates this CSV file has its own algorithms to decide what is great, and does not care about disagreements.) This list is delivered to the agency every day at 7 AM. The list, however, only contains the names of the sites and their home page links. BBC may or may not feature in the list for the day. If the list contains BBC, he wants a query that will fetch the links to all Travel stories from the home page. Here is a sample:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col /><col /></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Name</strong></span></p></td><td style="border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>HomeURL</strong></span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BBC</p></td><td style="border-bottom: 0.5pt solid ; "><p><a class="ulink" href="http://www.bbc.com/" target="_blank">http://www.bbc.com/</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reuters</p></td><td style="border-bottom: 0.5pt solid ; "><p><a class="ulink" href="https://in.reuters.com/" target="_blank">https://in.reuters.com/</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Associated Press</p></td><td style="border-bottom: 0.5pt solid ; "><p><a class="ulink" href="https://www.ap.org/en-gb/" target="_blank">https://www.ap.org/en-gb/</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Philippine News</p></td><td style="border-bottom: 0.5pt solid ; "><p><a class="ulink" href="http://www.pna.gov.ph/" target="_blank">http://www.pna.gov.ph/</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Al Jazeera</p></td><td style="border-bottom: 0.5pt solid ; "><p><a class="ulink" href="http://www.aljazeera.net/portal" target="_blank">http://www.aljazeera.net/portal</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bloomberg</p></td><td style="border-bottom: 0.5pt solid ; "><p><a class="ulink" href="https://www.bloomberg.com/" target="_blank">https://www.bloomberg.com/</a></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>The Hindu</p></td><td style=""><p><a class="ulink" href="https://www.thehindu.com/" target="_blank">https://www.thehindu.com/</a></p></td></tr></tbody></table></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec201"></a>How to do it…</h3></div></div></div><p>This task involves PowerShell visiting a web page and picking up the links. You can use the <code class="literal">Invoke-WebRequest</code> cmdlet for this. To add perspective, <code class="literal">Invoke-WebRequest</code> shares many similarities with <code class="literal">curl</code> and <code class="literal">wget</code>. This recipe also involves the use of a simple <code class="literal">if</code> statement. The syntax and working of the statement will be covered in the <span class="emphasis"><em>Flow Control using Branches and Loops </em></span>chapter.</p><p> </p><p>You ask your friend to save the CSV with the same name at the home location. You will take care of deleting the file after processing. You send him the steps, which are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Import the CSV file into the session and save it in a variable:</li></ol></div><pre class="programlisting">$CsvImport=Import-Csv./ch06/05-sitelist.csv</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Next, you find out if BBC features in the list by using an <code class="literal">if</code> block:</li></ol></div><pre class="programlisting">if ($CsvImport.Name -contains 'BBC') { "Process the file." }</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Use <code class="literal">Invoke-WebRequest</code> within the script block to retrieve the links:</li></ol></div><pre class="programlisting">$Uri = ($CsvImport | Where-Object Name -EQ 'BBC').HomeURL
(Invoke-WebRequest -Uri $Uri).Links | Select-Object href</pre><p>Now that you have the links, you filter the links that contain <code class="literal">/travel/</code> in them. You notice that there are links such as <code class="literal">/travel/</code>, as well as <a class="ulink" href="http://www.bbc.com/travel/" target="_blank">http://www.bbc.com/travel/</a>, which takes you to the Travel page.</p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Filter out only the articles: they may be stories, photos, or <span>other</span><a id="id326066274" class="indexterm"></a> forms of content:</li></ol></div><pre class="programlisting">(Invoke-WebRequest -Uri $Uri).Links | Where-Object {$PSItem.href -Like '*/travel/*' -and $PSItem.href -NotLike '*/travel/'} | Select-Object href -Unique</pre><p>However, you would like a simpler way to filter the links:</p><pre class="programlisting">(Invoke-WebRequest -Uri $Uri).Links | Where-Object href -match '/travel/.+' | Select-Object -ExpandProperty href -Unique</pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Build the complete script. Place the links in a text file:</li></ol></div><pre class="programlisting">$CsvImport = Import-Csv ./ch06/05-sitelist.csv
if ($CsvImport.Name -contains 'BBC') {
    $Uri = ($CsvImport | Where-Object Name -EQ 'BBC').HomeURL
    (Invoke-WebRequest -Uri $Uri).Links |
    Where-Object href -match '/travel/.+' |
    Select-Object -ExpandProperty href -Unique
}
Remove-Item ./ch06/05-sitelist.csv</pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Send your friend the instructions on how to run the script.</li></ol></div><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec202"></a>How it works…</h3></div></div></div><p>The <code class="literal">-Like</code> operator matches wildcard characters and sees if the given substring is present in the string. On the other hand, the <code class="literal">-Match</code> operator matches regular expression patterns to validate strings. The <code class="literal">-contains</code> operator sees if the specified element exists in the given array.</p><p>The <code class="literal">Invoke-WebRequest</code> cmdlet gives out an object that contains several properties. <code class="literal">Links</code> contains more properties within itself (<code class="literal">Links : {@{outerHTML...</code>). Expand this property and get its members:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Invoke-WebRequest -Uri 'http://www.bbc.com' | Select-Object -ExpandProperty Links | Get-Member</strong></span></pre><p>However, for ease of use, we will pick the entire <code class="literal">Links</code> property:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; (Invoke-WebRequest -Uri 'http://www.bbc.com').Links</strong></span></pre><p>At the first step after importing the file, we check whether the <code class="literal">$CsvImport.Name</code> array contains BBC. Then, we use the <code class="literal">-Like</code> operator to find <code class="literal">/travel/</code>. We include everything that contains <code class="literal">/travel/</code>, and then exclude the strings that end with <code class="literal">/travel/</code>. However, in this particular situation, this seems like a query that's a little longer than what is required:</p><pre class="programlisting"># ...
<span class="strong"><strong>Where-Object {$PSItem.href -Like '*/travel/*' -and $PSItem.href -NotLike '*/travel/'}</strong></span>
# ...</pre><p>Therefore, we will use regular expression matching to get only those links that have <code class="literal">/travel/</code>, followed by any character <span>other</span><a id="id326082342" class="indexterm"></a> than null:</p><pre class="programlisting"># ...
<span class="strong"><strong>Where-Object href -match '/travel/.+'</strong></span>
# ...</pre><p>You then select only the links (and not the column header) and send the output to a file, and delete the input file to clean up.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec203"></a>There's more…</h3></div></div></div><p>There is an automatic variable, <code class="literal">$Matches</code>, which contains all of the matches that are found during an operation:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; "Hey, there! I'm using PowerShell." -match "([a-z]+)'([a-z]+)"</strong></span></pre><p> </p><p>Calling <code class="literal">$Matches</code> now would list out the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The complete match (<code class="literal">I'm</code>, in this case)</li><li style="list-style-type: disc">The groups (pattern within the parentheses: <code class="literal">I</code> and <code class="literal">m</code>, in our case)</li></ul></div><p>The would be listed out as a hashtable. (You will <span>learn</span><a id="id326083367" class="indexterm"></a> more about hashtables in <a class="link" href="#" linkend="ch09">Chapter 9</a>, <span class="emphasis"><em>Using Arrays and Hashtables</em></span>; for now, think of them as a simple tabular representation of a list.)</p></div></div>