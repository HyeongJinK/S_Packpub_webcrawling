<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch16lvl1sec180"></a>Data formatting examples with PowerShell</h2></div></div><hr /></div><p>Before getting into the formatting examples, let's read a dataset <span>from</span><a id="id325892275" class="indexterm"></a> the table using .NET class libraries. PowerShell always works seamlessly with .NET integration. PowerShell has a set of cmdlets that allow you to control which properties are displayed for particular objects.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl2sec479"></a>Getting ready</h3></div></div></div><p>Let's get started with the following configuration:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Prepare the dataset using .NET class libraries</li><li>Run the script from the PowerShell console</li><li>Work with the output using format cmdlets</li></ol></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl2sec480"></a>How to do it…</h3></div></div></div><p>In this section, we'll discuss the steps to perform data formatting on the sample data:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Define the variables.</li><li>Prepare the database connection string.</li><li>Instantiate the <code class="literal">System.Data.SqlClient.SqlConnection</code> .NET class library.</li><li>Open the connection, and the instance will be ready to use.</li><li>Prepare the SQL query to run on the defined connection.</li><li>Create a subobject called <code class="literal">$cmd</code> for the main object <code class="literal">$ConnStr</code>.</li><li>Execute the SQL using the <code class="literal">ExecuteReader()</code> method.</li><li>Load the result set into the table variable.</li><li>Format the output with the formatting cmdlets.</li><li>The following script takes care of the aforementioned tasks. Now, save the following content in the <code class="literal">/tmp/DataFormatSample.ps1</code> file:</li></ol></div><pre class="programlisting">#Define Input variables
$dataSource = "10.2.6.50"
#Define the login credentials for SQL authentication
$user = "SA"
$pwd = "thanVitha@2015"
#Define the database name from which the data is going to be read
$database = "PacktPub"
#Build the connection string
$connStr = "Server=$dataSource;uid=$user; pwd=$pwd;Database=$database;Integrated Security=False;"
#Prepare the query
$query = "SELECT * FROM TaskManagerDump"
#Instantiate the sqlConnection namespace
$Conn = New-Object System.Data.SqlClient.SqlConnection
$Conn.ConnectionString = $connStr
#Open the connection
$Conn.Open()
#Create sub-objects to the Main object $Conn
$cmd = $Conn.CreateCommand()
#Assign the Query text to a $command object
$cmd.CommandText = $query
#Execute the adapter
$resultset = $cmd.ExecuteReader()
#Create an object DataTable namespace
$table = new-object "System.Data.DataTable"
#Load the data to the table
$table.Load($resultset)
$table |Where-Object {$_.ProcessName -match "pwsh"}
#$table |Where-Object {$_.ProcessName -match "pwsh"} | format-table -autosize
#$table |Where-Object {$_.ProcessName -match "pwsh"} | format-list
#$table |Where-Object {$_.ProcessName -match "pwsh"} | format-table $format
#$table | Where-Object {$_.ProcessName -match "pwsh"}| format-table $format | Out-File /tmp/output.txt
$Conn.Close()</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch16lvl2sec481"></a>How it works…</h3></div></div></div><p>In this section, let's discuss the various available methods to format table output. .NET libraries are used to invoke SQL to read data from a SQL instance. The steps include building a connection string; preparing the T-SQL; creating the dataset; creating the <code class="literal">DataAdapter</code>, and filling the <code class="literal">DataAdapter</code>. Once data is in <code class="literal">DataTable</code>, you can transform the data in several ways by using PowerShell pipe concepts, along with the built-in cmdlets.</p><p>Let's dive deep into the .NET Class libraries to <span>understand</span><a id="id325906038" class="indexterm"></a> more about querying SQL Server. The class libraries are further divided into Connected classes and Disconnected classes. Let's look at these in detail:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Connected classes</strong></span>: Using connected architecture, you <span>can</span><a id="id325906055" class="indexterm"></a> connect to the database, gather data, and close the connection:</li><li style="list-style-type: disc"><code class="literal">SqlConnection</code>: Connects to the SQL Server .NET data provider in order to establish and manage the connection to the target database.</li><li style="list-style-type: disc"><code class="literal">SqlCommand</code>: Contains the details necessary to issue a T-SQL command against a SQL Server database.</li><li style="list-style-type: disc"><code class="literal">SqlDataAdapter</code>: Provides a bridge between the connected classes and disconnected classes. This class includes the Fill and Update methods. Use the <code class="literal">Fill</code> method to populate a <code class="literal">DataSet</code> or <code class="literal">DataTable</code> object. Use the <code class="literal">Update</code> method to propagate the updated data in a <code class="literal">DataSet</code> or <code class="literal">DataTable</code> object to the database.</li><li style="list-style-type: disc"><span class="strong"><strong>Disconnected classes</strong></span>: Using disconnected architecture, you <span>can</span><a id="id325909517" class="indexterm"></a> build a connection to the database, get all the data into an object, and reuse the same connection, if needed:</li><li style="list-style-type: disc"><code class="literal">DataTable</code>: Stores the data returned by your query. The data is stored in rows and columns, similar to how data is stored in a database table.</li></ul></div><p> </p><p>The output of the Powershell script is stored in a variable called <code class="literal">$table</code>:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; $table=/tmp/DataFormatSample.PS1                                   </strong></span>
<span class="strong"><strong>PS&gt; $table</strong></span></pre><p>Using the <code class="literal">Format-Table</code> option, the output is displayed as a table. When the number of properties increases, the output becomes nearly impossible to understand. In such a case, the output can be handled better using the <code class="literal">Wrap</code> parameter:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; $table=/tmp/DataFormatSample.PS1 </strong></span>
<span class="strong"><strong>PS&gt; $table |Format-Table</strong></span>
<span class="strong"><strong>PS&gt; $table |Format-Table -AutoSize</strong></span></pre><p>In the following example, the columns are overridden with a custom value. Each column is defined with the definite width, and the values of the fields are displayed based on the defined property:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; $format = @{Expression={$_.Id};Label="ProcessId";width=5},              </strong></span>
<span class="strong"><strong>&gt;&gt; @{Expression={$_.ProcessName};Label="Name"; width=4},                                   </strong></span>
<span class="strong"><strong>&gt;&gt; @{l="WS";e={$_.WorkingSet/1024};width=10},                                              </strong></span>
<span class="strong"><strong>&gt;&gt; @{l="StartTime";e={$_.StartTime};width=20},                                             </strong></span>
<span class="strong"><strong>&gt;&gt; @{l="UserProcessorTime";e={$_.UserProcessorTime};width=20}                              </strong></span>
<span class="strong"><strong>PS&gt; $table|Format-Table $format</strong></span></pre><p>Using the <code class="literal">Format-List</code> clause, the output is displayed as a list of properties in which each property appears on a new line:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; $table=/tmp/DataFormatSample.PS1                                       </strong></span>
<span class="strong"><strong>PS&gt; $table |Format-List</strong></span></pre><p>By using the <code class="literal">sort-object</code> cmdlet, the sort operation is based on the listed column's property value. In the following example, the <code class="literal">WorkingSet</code> column is sorted in descending order:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; /tmp/DataFormatSample.PS1|Sort-Object WorkingSet -Descending|Format-Table -AutoSize </strong></span></pre><p>The <code class="literal">Select-Object</code> cmdlet creates new, custom objects that contain the properties from the objects you use to create them:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; /tmp/DataFormatSample.PS1|Select-Object -Last 2 </strong></span>
<span class="strong"><strong>PS&gt; /tmp/DataFormatSample.PS1|Select-Object -First 2 </strong></span></pre><p> </p></div></div>