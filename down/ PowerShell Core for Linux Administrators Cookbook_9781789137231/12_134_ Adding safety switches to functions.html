<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch12lvl1sec132"></a>Adding safety switches to functions</h2></div></div><hr /></div><p>It is common to hear the phrase – PowerShell <span>looks</span><a id="id325892276" class="indexterm"></a> out for you, when anyone talks about how PowerShell is friendly. What they really mean is that PowerShell has several functionalities that help you not mess up. This is achieved by using methods such as the <code class="literal">ShouldProcess</code> method, or, in other words, the <code class="literal">WhatIf</code> parameter. Also, in cases where what you are going to do with the function is drastic, you could also add a <code class="literal">Confirm</code> parameter to it.</p><p>Supporting both of these functionalities can be tricky sometimes. In this recipe, you will add a <code class="literal">WhatIf</code> switch to the file creation process so that the user knows what would happen if they ran the cmdlet, and add a <code class="literal">Confirm</code> switch to ask the user whether they would really like to create the files.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec343"></a>How to do it…</h3></div></div></div><p>There are two requirements here. We will add the functionalities to the same function, <code class="literal">New-File</code>.</p><p>Open a new file window, copy the contents of the <code class="literal">06-New-File.ps1</code> file, and make some changes so that the script looks like this:</p><pre class="programlisting">function New-File {
    [CmdletBinding(
        ConfirmImpact='High',
        SupportsShouldProcess=$true
    )]
    param (
        # The path to the file (or the name)
        [Parameter(Mandatory=$true, Position=0)]
        [string[]]
        $Path
    )
    begin {
        Write-Host "$(Get-Date)"
    }
    process {
        foreach ($Item in $Path) {
            if ($PSCmdlet.ShouldProcess("$PsScriptRoot", "Create $Path")) {
                New-Item -Path $Item -ItemType File
            }
        }
    }
    end {}
}</pre><p>Run the script and call the function with three file-names as parameters. Dot-source the script; don't just call it. Alternatively, you could run the script using the <span class="emphasis"><em>F5</em></span> key when in Visual Studio Code:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; . ./ch12/07-New-File.ps1
PS&gt; New-File file1.txt, file2.txt -WhatIf
PS&gt; New-File file1.txt, file2.txt</strong></span></pre><p>Here is a screenshot of the output for the cmdlet being run with and without <code class="literal">-WhatIf</code>:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/06a94ed6-d8e7-441c-84b1-44d835647e4c.png" /></div><p>Optionally, remove the files you just created if you answered <code class="literal">Y</code> to the confirmation prompt.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl2sec344"></a>How it works…</h3></div></div></div><p>PowerShell is capable of making changes to your system in such a drastic way that sometimes it is simply scary—this is no different than any other shell, such as Bash. Therefore, there are two <span>very</span><a id="id326191981" class="indexterm"></a> important functionalities built into PowerShell that help ensure that you do not accidentally do what you did not intend to.</p><p>The first among these capabilities is the <code class="literal">ShouldContinue</code> capability, or the <code class="literal">Confirm</code> parameter. As the name suggests, it asks you whether the operation should continue. In order to ask this, though, it needs some information that is useful to you. We will get to that in a moment.</p><p>The first change compared to <code class="literal">06-New-File.ps1</code>, as you may have noticed, is the <code class="literal">[CmdletBinding()]</code> line, right before the parameter declaration. This attribute technically converts your regular function into an advanced function. The first attribute we declare is the <code class="literal">ConfirmImpact</code> attribute, and this governs whether there is a confirmation prompt.</p><p>Every session of PowerShell contains an automatic variable called <code class="literal">$ConfirmPreference</code>, which is, by default, set at <code class="literal">High</code>. This means that there would be a confirm prompt if there is a confirmation impact of high or above. The confirmation impact is governed by the <code class="literal">ConfirmImpact</code> attribute, which is, by default, <code class="literal">Medium</code>. Now, if the value of the <code class="literal">ConfirmImpact</code> attribute is greater than or equal to that of the <code class="literal">$ConfirmPreference</code> variable, there would be a confirmation prompt. Since the impact is medium by default, and the preference is set at high, PowerShell does not ask us to confirm every action we perform.</p><p>In our function, we set the value of <code class="literal">ConfirmImpact</code> to the same as that of <code class="literal">$ConfirmPreference</code>, and therefore enable the confirmation prompt.</p><p>The next attribute we set is <code class="literal">SupportsShouldProcess</code>. This enables the <code class="literal">WhatIf</code> parameter. However, merely setting <code class="literal">SupportsShouldProcess</code> to <code class="literal">$true</code> does not exactly tell the script what to tell the user when they use <code class="literal">WhatIf</code>. Therefore, we use the <code class="literal">$PsCmdlet.ShouldProcess()</code> method within the script.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip76"></a>Note</h3><p>You could simply use <code class="literal">SupportsShouldProcess</code> instead of <code class="literal">SupportsShouldProcess=$true</code> and avoid redundancy. However, if you want your script to support PowerShell 2.0 or older, assigning <code class="literal">$true</code> to it is necessary.</p></div><p> </p><p>The <code class="literal">ShouldProcess()</code> method within <code class="literal">$PsCmdlet</code> (yes, <code class="literal">CmdletBinding</code> enables us to use this variable as well), by default, takes in one input, which is the target. When just the target is passed, the output—when <code class="literal">-WhatIf</code> is called—says the following:</p><pre class="programlisting">What if: Performing the operation "&lt;Cmdlet Name&gt;" on target "&lt;Specified target&gt;".</pre><p>If you would like to manually specify what operation the function performs instead of letting PowerShell pick the cmdlet name, specify that action as the second argument:</p><pre class="programlisting">if ($PsCmdlet.ShouldProcess("$PsScriptRoot", <span class="strong"><strong>"Create $Path"</strong></span>) {</pre><p>These two arguments also help with the confirmation prompt. The prompt uses the same data to ask you whether you would like to perform said operation on said target.</p><p>We use the <code class="literal">if</code> construct here because we want to make the <code class="literal">What if</code> output available only when <code class="literal">WhatIf</code> is called (or with the confirmation prompt when the <code class="literal">ConfirmImpact</code> is higher than or the same as the <code class="literal">ConfirmPreference</code>).</p></div></div>