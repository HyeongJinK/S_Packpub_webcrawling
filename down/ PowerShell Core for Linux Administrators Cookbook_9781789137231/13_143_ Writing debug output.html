<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch13lvl1sec140"></a>Writing debug output</h2></div></div><hr /></div><p>Traditionally, while writing scripts, we have used <span>regular</span><a id="id326367198" class="indexterm"></a> console output, also known as print-style debugging. This often leads to a lot of text in the output. Of course, this can be cleaned up once the scripting is complete, but that is still additional work, not to mention the need to add all of the debug output again during further development, changes, or extension. Also, as the complexity of the script increases, so does the complexity of debugging using console text.</p><p> </p><p>Enter: the extensive built-in debugging capabilities of PowerShell.</p><p>Write a debug output for the <code class="literal">New-File</code> function that you created in the previous chapter.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec357"></a>Getting ready</h3></div></div></div><p>Here are the requirements that need to be met before we get into the recipes:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Install Visual Studio Code and configure it to run PowerShell by referring to the <span class="emphasis"><em>Installing Visual Studio Code</em></span> recipe from <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Preparing for Administration Using PowerShell</em></span>.</li><li>Optionally, clone the repository that accompanies this book so that you have the necessary scripts to work with:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ git clone https://github.com/PacktPublishing/PowerShell-Core-Linux-Administrators-Cookbook book-code</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec358"></a>How to do it…</h3></div></div></div><p>We will pick the simplest file to ensure focus:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a copy of the <code class="literal">ch12/06-New-File.ps1</code> file. This file can be found in the code repository that accompanies this book.</li><li>Add a few <code class="literal">Write-Debug</code> lines to it.</li><li>Now, either change the <code class="literal">DebugPreference</code> to <code class="literal">Continue</code> from <code class="literal">SilentlyContinue</code>, or add <code class="literal">[CmdletBinding()]</code> to the function. If you chose the latter approach of adding <code class="literal">[CmdletBinding()]</code> to the script, this is what the final script should look like:</li></ol></div><pre class="programlisting">function New-File {
    [CmdletBinding()]
    param (
        # The path to the file (or the name)
        [Parameter(Mandatory=$true, Position=0)]
        [string[]]
        $Path
    )
    Write-Debug "Entered the process block."
    foreach ($Item in $Path) {
        Write-Debug "Iterating for item, $Item."
        New-Item -Path $Path -ItemType File
    }
}</pre><p>Next, load the script and call the function with the <code class="literal">Debug</code> switch. Confirm your actions through each step and read the debug output:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; New-File -Path ./MyFile.txt -Debug</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl2sec359"></a>How it works…</h3></div></div></div><p>The actual debug output is written using the <code class="literal">Write-Debug</code> cmdlet within the script. Whether the debug output is written or not is governed by two things: </p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Using the <code class="literal">DebugPreference</code> automatic variable. This variable resets itself to <code class="literal">SilentlyContinue</code> for each session. <code class="literal">SilentlyContinue</code> will make the script go on without the debug output being displayed. Setting the <code class="literal">DebugPreference</code> to <code class="literal">Continue</code> would change this behavior and display the debug output.</li><li>Converting a function into an advanced function by simply declaring <code class="literal">CmdletBinding()</code>. This way, you would be able to easily control the debug display using the <code class="literal">Debug</code> switch. Whenever you need the debug display, simply call the function with the <code class="literal">Debug</code> switch; during the other times, the debug <span>output</span><a id="id325898678" class="indexterm"></a> would be silent, unless overridden by the <code class="literal">DebugPreference</code> variable.</li></ol></div><p>One point to remember is that when turning on debug output using the <code class="literal">DebugPreference</code> variable, the functions will not confirm each of your actions like it does when you use the <code class="literal">Debug</code> switch.</p></div></div>