<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec65"></a>Understanding the extension of type data</h2></div></div><hr /></div><p>In the <span class="emphasis"><em>Selecting columns from the output</em></span> recipe in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Passing Data through the Pipeline</em></span>, we used a <span>hashtable</span><a id="id325906087" class="indexterm"></a> to set the name and the expression for a custom-named column. Later, we also used a small calculation within the<code class="literal">Select-Object</code>statement to get a calculated output. If you tried to select the column by the new name, that would have worked, too. Technically, you have already extended the object. But what is type data anyway? And why do we need a recipe to extend it when we can work with<code class="literal">Select-Object</code>?</p><p>Going too deep into what type data is and how to work with it, along with .NET classes and objects, could potentially make this concept an advanced one. Historically, most of us learners have put off learning advanced topics. Therefore, we will stick to the simple parts of it, and work only with PowerShell for now. This recipe will serve as a launchpad to help you understand what it is by making it simple and fun, keeping it away from anything advanced, in the interest of learning.</p><p>There are two options to extend the type data:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Using PowerShell cmdlets (to understand how it all works)</li><li style="list-style-type: disc">Using an XML file (for portability)</li></ul></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec179"></a>Getting ready</h3></div></div></div><p>To understand what we are talking about, here, you need to have read the following recipes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="emphasis"><em>Selecting columns from the output </em></span>from <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Passing Data through the Pipeline</em></span></li><li style="list-style-type: disc">The <span class="emphasis"><em>Creating a custom object from a returned object </em></span> recipe</li></ul></div><p>Let's come back to the question at hand: why extend type data when we can use <code class="literal">Select-Object</code>?</p><p>Efficiency. While you could change the name, add a calculation, and reference the calculated property with the new name, that change would have existed only in that context. If you added it to a variable, as in the previous recipe, <span class="emphasis"><em>Creating a custom object from a returned object</em></span>, where we made some nifty changes to the names and also created a custom <code class="literal">NoteProperty</code>, that would be a long way to go about it. This is where the extension of type data comes in.</p><p>The rule of the thumb is, if you do something repetitively, there's an issue: you haven't considered automating it. For example,  if you run the following code:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | select Name, Length, @{Name='Age'; Expression={[math]::Round(((Get-Date) - $_.LastWriteTime).TotalDays)}}</strong></span></pre><p>Instead of the following code:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . | select Name, Length, Age</strong></span></pre><p>If you do this 15 times a day, you should consider extending the object to give you what you care about.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec180"></a>How to do it…</h3></div></div></div><p>Navigate to the location where you created files for lab usage:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Enter the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $FilesWithAge = Get-ChildItem . | Select-Object Name, Length, LastWriteTime</strong></span></pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Now, add a property to the <code class="literal">$FilesWithAge</code> variable; the property should be the age of each file, in days:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $FilesWithAge | Add-Member -MemberType ScriptProperty -Name Age -Value { [math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays) }</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Add another property to it, called <code class="literal">ComputerName</code>, which is the name of your localhost:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $ComputerName = hostname</strong></span>
<span class="strong"><strong>PS&gt; $FilesWithAge | Add-Member -MemberType NoteProperty -Name ComputerName -Value $ComputerName</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Add another property, as an alias to <code class="literal">LastWriteTime</code>, called <code class="literal">Modified</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $FilesWithAge | Add-Member -MemberType AliasProperty -Name Modified -Value LastWriteTime</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>To format it so that it looks like a nice table, use the <span>following</span><a id="id326261761" class="indexterm"></a> code:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $FilesWithAge | Format-Table -AutoSize</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/e768bdc0-509a-4456-99e7-04faa7d5d31a.png" /></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Now, delete the variable, and query the files within the current directory (because that is what the variable actually held):</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Remove-Variable FilesWithAge</strong></span>
<span class="strong"><strong>PS&gt; Get-ChildItem .</strong></span></pre><p>You cannot see the <code class="literal">Age</code>, the <code class="literal">ComputerName</code>, or the <code class="literal">Modified</code> properties. Try <code class="literal">Get-Member</code>, if you want.</p><p>Next, we will look at how we can extend the type data itself so that every time you run <code class="literal">Get-ChildItem</code>, you also get the three properties we added to the variable.</p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Let's see what object is returned when you run <code class="literal">Get-ChildItem</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem | Get-Member</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>You get <code class="literal">System.IO.DirectoryInfo</code>, as well as <code class="literal">System.IO.FileInfo</code>. Now, we will pick <code class="literal">System.IO.FileInfo</code>. Run the <span>following</span><a id="id326261955" class="indexterm"></a> commands:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; $ComputerName = hostname </strong></span>

<span class="strong"><strong>PS&gt; Update-TypeData -TypeName System.IO.FileInfo -MemberType NoteProperty -MemberName ComputerName -Value $ComputerName</strong></span>

<span class="strong"><strong>PS&gt; Update-TypeData -TypeName System.IO.FileInfo -MemberType AliasProperty -MemberName Modified -Value LastWriteTime</strong></span>

<span class="strong"><strong>PS&gt; Update-TypeData -TypeName System.IO.FileInfo -MemberType ScriptProperty -MemberName Age -Value { [math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays) }</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>Query the contents of the current location and, optionally, format the output so that it looks like a table:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem . | Select-Object Name, Length, ComputerName, Age, Modified | Format-Table -AutoSize</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/8f17f74b-2dd8-4da1-a896-7f574d2e58fc.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>Do the same for any directory in the filesystem, with the only condition being that the directory should contain at least one file, and not just more directories:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem ./cities/ | Select-Object Name, Length, ComputerName, Age, Modified | Format-Table -AutoSize</strong></span></pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec181"></a>How it works…</h3></div></div></div><p>In the first section, we added members to the objects within a certain variable. This was a command-line-prompt-style extension to the <span class="emphasis"><em>Creating a custom object from a returned object</em></span> recipe, which was, by all means, a little more efficient in the context. However, the changes we made to the object remained only while the <code class="literal">$FilesWithAge</code> variable was valid. The object returned by <code class="literal">Get-ChildItem</code> was not modified at all.</p><p> </p><p> </p><p>There is an important point to note here: <code class="literal">$this</code>. We have come across the automatic variable, <code class="literal">$_</code> (or <code class="literal">$PSItem</code>, after PowerShell V3) when dealing with objects passed through the pipeline; this variable holds the current instance of the object in the pipeline. However, when we have to perform an object extension, we use the automatic variable, <code class="literal">$this</code>. Why? Because the property being referred to is being referred within the parent object (the object returned by <code class="literal">Get-ChildItem</code>). External methods would be able to use <code class="literal">$_</code>. In a way, <code class="literal">$_</code> does not even exist yet when performing member addition. Also, <code class="literal">$this</code>, in fact, refers to the object itself, which is returned by <code class="literal">Get-ChildItem</code>, and not just an instance of it.</p><p>When we would like to get a member as part of the object itself <span>throughout</span><a id="id326372257" class="indexterm"></a> the session, irrespective of the validity of a certain variable or the object instance, we extend the type data itself. Therefore, no matter what context you run the cmdlet in, you would get the additional members you added. Of course, the formatting rules in PowerShell may still not let those members appear in the output by default. You can always call the specific members, though, such as using <code class="literal">Select-Object</code> for properties, or simply using the member access operator on the properties: <code class="literal">(Get-ChildItem .).Age</code>.</p><p>For this, we use the <code class="literal">Update-TypeData</code> cmdlet. <code class="literal">Update-TypeData</code>, in this context, requires the <code class="literal">TypeName</code>, which, as we have already seen, can be determined using <code class="literal">Get-Member</code> on the returned object.</p><p>We mentioned four things in the <code class="literal">Update-TypeData</code> statements: </p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The type name</li><li style="list-style-type: disc">The member type</li><li style="list-style-type: disc">The member name</li><li style="list-style-type: disc">The member value</li></ul></div><p>The member type accepts several values, of which we use three:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li><code class="literal">AliasProperty</code>, which is simply a reference to another member within the object. The new property is just another name of an existing property. Therefore, the <code class="literal">Value</code> parameter can just take the name of the existing member.</li><li><code class="literal">NoteProperty</code>, which is a static value. In our case, we can use the hostname as the static value.</li><li><code class="literal">ScriptProperty</code>, which is essentially a calculation. We calculate the time span between the date when it was last modified and the current date. This calculation is the <code class="literal">Value</code> for the member, and accepts a script block.</li></ol></div><p> </p><p>This modification to the object will be valid as long as the session is valid; the change is not persistent across sessions. That brings us to the next recipe, where we will be making object modifications stick across sessions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec182"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Selecting columns from the output </em></span>recipe in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Passing Data through the Pipeline</em></span></li></ul></div></div></div>