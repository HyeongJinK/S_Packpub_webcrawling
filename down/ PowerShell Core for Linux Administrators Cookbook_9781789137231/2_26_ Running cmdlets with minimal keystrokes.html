<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec34"></a>Running cmdlets with minimal keystrokes</h2></div></div><hr /></div><p>Commands have <span>been</span><a id="id326185276" class="indexterm"></a> made to be short, historically. However, the <span>situation</span><a id="id326185270" class="indexterm"></a> turned into a dilemma over time, since shorter commands meant that they had to be remembered and longer commands meant more keystrokes.</p><p>PowerShell has long commands; however, it deals with them in two ways:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Aliases, which tend to be shorter</li><li style="list-style-type: disc">Tab completion, which require more keystrokes than aliases, but doesn't require remembering much</li></ul></div><p>The first way necessitates using our memory to recall command names as required. The second, on the other hand, solves the keystroke issue efficiently.</p><p>Bash users are used to getting a list of matches laid out in a nice tabular format when the <span class="emphasis"><em>Tab</em></span> key matches more than one string in the context. On the other hand, the matches cycle at the cursor in Windows (which most Bash users find weird).</p><p>Be that as it may, tab completion is a boon, and this recipe makes complete use of tab completion and simple string matching to significantly reduce keystrokes when using PowerShell cmdlets.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec96"></a>Getting ready</h3></div></div></div><p>We use the GNOME Terminal emulator for this recipe. Tab completion on PowerShell on Linux on Gnome Terminal behaves exactly the same way that it works on Bash on GNOME Terminal:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">If only one word matches the string before the tab, the word is completed</li><li style="list-style-type: disc">If multiple words match the string before the tab, all possible options are listed</li></ul></div><p>If you are using Visual Studio Code for this recipe, or a different Terminal emulator, its behavior may be different.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec97"></a>How to do it…</h3></div></div></div><p>Let us get right to it!</p><p>Say we would like to get the list of files and directories within the current directory:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The right way of doing this, as per best practices, would be as follows:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path .</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>However, as we've seen before, the easy way of doing this would be as follows:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; gci</strong></span></pre><p>We would use the former way when including the cmdlet in a script. This avoids ambiguity in most contexts that the script would run in. This usually means minimal bugs. The latter, on the other hand, is the short way of running the same cmdlet, by leveraging the user-friendly features of it, combined with the awareness of the environment as an intelligent human. This approach significantly reduces keystrokes—three characters, as opposed to 21.</p><p>Although, if you are writing a script and would like to reduce keystrokes, you could still do it, without having to remember things such as <code class="literal">gpv</code> means <code class="literal">Get-ItemPropertyValue</code>.</p><p>Enter: tab completion.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Follow the keystrokes mentioned here:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; get-ch&lt;Tab&gt;&lt;Space&gt;.</strong></span></pre><p>Those were ten keystrokes including <code class="literal">&lt;Enter&gt;</code>.</p><p>There may be situations where you would need to call a named parameter. And the named parameter might be long.</p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Find a command that has <code class="literal">ComputerName</code> as a parameter:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; get-comm&lt;Tab&gt;&lt;Space&gt;-param&lt;Tab&gt;&lt;Space&gt;computername&lt;Enter&gt;</strong></span></pre><p>This completes to the following:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Command -Parameter computername</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/2a7ec21a-7db9-40bf-8c41-6fd9631b10dc.png" /></div><p>But it throws an error. The error says, <code class="literal">Possible matches include: -ParameterName -ParameterType</code>. This is the <span>caveat</span><a id="id325892145" class="indexterm"></a> in PowerShell on Linux. Let us try again:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; get-comm&lt;Tab&gt;&lt;Space&gt;-param&lt;Tab&gt;&lt;Tab&gt;</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/2e0ddf31-5180-42aa-8d3e-7b09d25a5157.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Read the list of <span>possibilities</span><a id="id325892258" class="indexterm"></a> and select <code class="literal">ParameterName</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; get-comm&lt;Tab&gt;&lt;Space&gt;-param&lt;Tab&gt;n&lt;Tab&gt;&lt;Space&gt;computername&lt;Enter&gt;</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>The complete resolution of that would be as follows:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Command -ParameterName computername</strong></span></pre><p>And it worked.</p><p>Next, let us suspend the activity in our session for, say, five seconds. The cmdlet for this would be <code class="literal">Start-Sleep</code>.</p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Let us first get help on the cmdlet:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Start-Sleep</strong></span></pre><p>The help text says that the parameter at position one, which need not be named, is <code class="literal">Seconds</code> (square brackets around <code class="literal">Seconds</code> in the second parameter set), and it accepts integer values.</p><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Therefore, to suspend the session for 5 seconds, we would use the following:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Start-Sleep 5</strong></span></pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="9" type="1"><li>If we wanted the session (or script) suspended for 100 milliseconds, we would need to use the named <code class="literal">Milliseconds</code> parameter. With tab completion, it would be as follows:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; start-s&lt;Tab&gt;&lt;Space&gt;-mi&lt;Tab&gt;100</strong></span></pre><p>This would resolve to the following:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Start-Sleep -Milliseconds 100</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="10" type="1"><li>You can, in fact, reduce the number of tabs when using parameter names. Just type enough for PowerShell to uniquely identify the parameter name:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; start-s&lt;Tab&gt;&lt;Space&gt;-m&lt;Space&gt;100</strong></span></pre><p>This would resolve to the following:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Start-Sleep -m 100</strong></span></pre><p>If the delay was not noticeable, feel free to increase the number a little (say, to 3000).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec98"></a>How it works…</h3></div></div></div><p>We have already seen how to use aliases. Aliases work just like normal cmdlets, including the syntax of their parameters. The only catch is that we have to remember the aliases. Custom aliases, as we shall see in the <span class="emphasis"><em>Best practices</em></span> section, are a bad idea given that the aliases have to be imported everywhere we want to run scripts that have custom aliases. </p><p>Tab completion on the other hand, reduces the number of keystrokes, but requires muscle memory. It requires some level of practice, given which significantly improves productivity. </p><p>Tab completion works when writing cmdlets, writing <span>parameter</span><a id="id325905995" class="indexterm"></a> names, as well as when passing pre-defined values to parameters, such as the following:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; set-exec&lt;Tab&gt;&lt;Space&gt;-exec&lt;Tab&gt;&lt;Space&gt;unre&lt;Tab&gt;</strong></span></pre><p>This completes to the following: </p><pre class="programlisting"><span class="strong"><strong>PS&gt; Set-ExecutionPolicy -ExecutionPolicy Unrestricted </strong></span></pre><p>In many situations, it is not necessary to use tab completion at all, for instance, in the case of <code class="literal">Start-Sleep</code>. There is no parameter that starts with <code class="literal">m</code> in the case of cmdlets. Therefore, using <code class="literal">-m</code> was sufficient for PowerShell to uniquely identify <code class="literal">-Milliseconds</code>. That saved us the <code class="literal">&lt;Tab&gt;</code> keystroke as well. </p><p>Productivity with respect to writing scripts in PowerShell is a skill that comes with practice. While aliases sure are a shortcut to speed, they have their perils. On the other hand, using the keyboard to write scripts helps with muscle memory, which not only helps us think in PowerShell, it also helps in speeding up tab completion, which works equally well when running commands at the console or writing scripts. </p><p>Using short parameter names is generally not a <span>good</span><a id="id325906075" class="indexterm"></a> practice while scripting; use these with a similar caution as aliases. Short parameter names affect readability and might break scripts at some point in the future. For instance, you call a certain cmdlet in a script with a short parameter name, <code class="literal">-comp</code>, which at the time of the creation of the script, stood only for <code class="literal">ComputerName</code>. Later, imagine the cmdlet receives an update with an added parameter, <code class="literal">-CompatibilityMode</code>; this would break the script that you wrote.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec99"></a>There's more…</h3></div></div></div><p>Try to type the most commonly used cmdlets along with the parameters to practice tab completion. </p><p>Get familiar with Visual Studio Code by typing the cmdlets in the script pane. Notice how cmdlet, parameter, and parameter value completion work in Visual Studio Code. If you prefer completion to work the same way as at the console, refer to my custom settings JSON in the book's GitHub repository.</p></div></div>