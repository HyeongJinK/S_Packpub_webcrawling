<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec58"></a>Understanding pipeline-enabled parameters</h2></div></div><hr /></div><p>Understanding pipelines is not so much of a <span>requirement</span><a id="id325885507" class="indexterm"></a> if you plan to use PowerShell for only running commands on the console; it is well encapsulated, and the cmdlets are well designed to be able to handle passing objects between cmdlets. However, if you plan to create custom functions and modules, the concept of the pipeline is something you will want to understand well.</p><p>In this recipe, we will look into two ways cmdlets accept input. At the point where we create functions, we will look at how to enable pipeline input for parameters.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec161"></a>How to do it…</h3></div></div></div><p>We will mostly use the help documentation to demonstrate the two different kinds of pipeline input. Follow these steps to get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>At the prompt, type in the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Get-Item -Parameter Path</strong></span></pre><p>The output says that the parameter accepts a string input, and accepts input by property name as well as by value:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/805f4aec-a1c4-4fcd-a9df-0b3f303b2e74.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Type in the following code to see if a valid string is accepted:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; "$HOME/random" | Get-Item</strong></span></pre><p>Of course, substitute the path with that of the lab directory in your setup:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/19cccb69-05ae-415a-ad9b-fe1822bda131.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Let us try something similar with <code class="literal">Get-Date</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Get-Date -Parameter *</strong></span></pre><p>The <code class="literal">Date</code> parameter accepts values through the pipeline. However, the type is <code class="literal">DateTime</code>, and not <code class="literal">string</code>.</p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Try sending a valid string through the pipeline to see if it gets converted into a date:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; '21 June 2018' |  Get-Date</strong></span></pre><p>As we can see, it successfully converted the string into date and time:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/a876a1c8-acb1-4307-a73f-ce10802e9281.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Now, let's go back to getting details of the <span>current</span><a id="id325906084" class="indexterm"></a> directory. This time, however, we will only pick the <code class="literal">FullName</code> property of the object:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Item . | Select-Object FullName</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Pass this through the pipeline to the <code class="literal">Get-ChildItem</code> cmdlet:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Item . | Select-Object FullName | Get-ChildItem</strong></span></pre><p>As we can see, there is an error:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/d3d66b39-b915-41b2-8abf-ba51ceabf296.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Change the property name to <code class="literal">LiteralPath</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Item . | Select-Object @{Name = 'LiteralPath'; Expression = {$_.FullName}}</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Pass the object to <code class="literal">Get-ChildItem</code> through the pipeline:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Item . | Select-Object @{Name = 'LiteralPath'; Expression = {$_.FullName}} | Get-ChildItem</strong></span></pre><p>That worked.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec162"></a>How it works…</h3></div></div></div><p>There are two kinds of input through the pipeline:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><code class="literal">ByPropertyName</code></li><li style="list-style-type: disc"><code class="literal">ByValue</code></li></ul></div><p>The <code class="literal">ByValue</code> type is perhaps the most common. If a parameter <span>accepts</span><a id="id326071499" class="indexterm"></a> input through the pipeline by value, it would look for the data type that matches the defined data type in the output, and pick the output as input for itself. In case the data type is not the same as what has been defined, but can be converted into the required type, the parameter would convert the value into the data type it takes in and process it. This happened in the case of <code class="literal">Get-Date</code>, where we sent the date as a string, and passed it through the pipeline to <code class="literal">Get-Date</code>.</p><p>In the case of <code class="literal">Get-Item</code>, the <code class="literal">Path</code> parameter accepted a string input and processed the command. In the case of <code class="literal">Get-Date</code>, the <code class="literal">Date</code> parameter converted the string into a <code class="literal">DateTime</code> object and processed the request.</p><p> </p><p><code class="literal">ByPropertyName</code>, compared to <code class="literal">ByValue</code>, looks for a property of the exact same name as the parameter. In our case, <code class="literal">LiteralPath</code> of <code class="literal">Get-ChildItem</code> threw an error when we passed the <code class="literal">FullName</code> property, even though it was essentially the literal path of the object, and a string value. The reason for this error was that the property was not called <code class="literal">LiteralPath</code>. When we changed the name of the property to <code class="literal">LiteralPath</code>, <code class="literal">Get-ChildItem</code> accepted the input through the pipeline and gave us the desired output.</p></div></div>