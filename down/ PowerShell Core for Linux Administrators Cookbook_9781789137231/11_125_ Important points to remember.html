<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch11lvl1sec124"></a>Important points to remember</h2></div></div><hr /></div><p>While writing scripts and functions is straightforward in most situations, there are cases where you are required to write complex scripts whose lengths run in hundreds of lines. In such situations, it is important that you <span>remember</span><a id="id325885488" class="indexterm"></a> the following points.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec325"></a>Using Host cmdlets</h3></div></div></div><p>There <span>are</span><a id="id325585878" class="indexterm"></a> five <code class="literal">Host</code> cmdlets that help you <code class="literal">Clear</code> the host, <code class="literal">Get</code> information about the host, send <code class="literal">Out</code> the output to the host, <code class="literal">Read</code> information from the host, and <code class="literal">Write</code> information to the host.</p><p> </p><p>PowerShell is a shell—an engine—as Don Jones points out in his <a class="ulink" href="https://powershell.org/" target="_blank">powershell.org</a> article (<a class="ulink" href="https://powershell.org/2013/10/the-shell-vs-the-host/" target="_blank">https://powershell.org/2013/10/the-shell-vs-the-host/</a>). The Host is what hosts this engine, or interacts with the engine on your behalf. This is to reiterate that <code class="literal">Host</code> cmdlets send output to the sixth stream, called the information stream. The only stream that interacts with the pipeline, though, is the first, or the success stream. Behind the scenes, when PowerShell does not find an entity at the end of the pipeline to accept the output of the success stream, the output is redirected to the host (think <code class="literal">| Out-Host</code>).</p><p>Imagine the setup to be like this: there is a room, which has a heap of wet clothes. There is a camera pointing to the clothes, right near the window. The camera is hooked up to a large display, which is placed at the window, instead of plain glass. You can look into the room only through the display. At the moment, you can see the wet clothes on the screen. You cannot touch them, smell them, or weigh them; only see them.</p><p>The wet clothes are passed through a pipe into an electric dryer. The dried clothes are sent out of the machine. What you see now is dry clothes, and you know they are dry because someone just picked them up and unfurled them, and the clothes unfurled rather smoothly.</p><p>Now, imagine you placed the dryer right next to you, between you and the screen. The sequence now is, wet clothes | camera | screen | dryer | you. Can you take the image and dry it? Or do the wet clothes physically disappear if you turn off the screen? In this analogy, the camera acts as the formatting rules—the interface between the camera—the display is the information stream, and the screen is the host.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec326"></a>Returning objects from functions</h3></div></div></div><p>We are probably tired of reading that PowerShell works on objects. We also know that text is a form of object. Now, it is important to know how to return objects from functions and scripts.</p><p>In most programming languages, we use the <code class="literal">return</code> keyword to return content from functions. PowerShell has no such requirements; there is no need to use the <code class="literal">return</code> keyword to return objects from within functions or scripts. In PowerShell, we simply call the variable or use a statement that outputs content, and this is the <code class="literal">return</code> statement in itself. The convention is that as well: no <code class="literal">return</code> statements in functions and scripts. If you would like to use it anyway because you <span>are</span><a id="id325898629" class="indexterm"></a> used to it because of languages such as C++, feel free to use it. PowerShell will output content based on the cmdlet or statement used, regardless of the keyword.</p><p>One important point to note is that exports may be affected by how content is returned from the functions. For instance, check out the following code:</p><pre class="programlisting">function Test-Return {
    try {
        Test-Path $HOME/random/ -ErrorAction Stop
        $Files = Get-ChildItem $HOME/random/ -Recurse -File
        $Files
    }
    catch {
        Write-Error "Could not find the path specified."
    }
}

Test-Return | Export-Csv $HOME/random/FileListExport.csv</pre><p>This won't record anything in the CSV file. The reason is that the <code class="literal">Test-Path</code> statement in line #3 would return a <code class="literal">System.Boolean</code> object, while <code class="literal">$Files</code> would return a <code class="literal">System.IO.FileInfo</code> object. The <code class="literal">Export-Csv</code> cmdlet would not be able to parse the Boolean object into CSV. To see that two kinds of members are returned by the function, you can pipe the function to the <code class="literal">Get-Member</code> cmdlet. Also, note that using the return keyword for <code class="literal">$Files</code> and omitting it from line #3 will not affect the objects returned by the function.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl2sec327"></a>Naming functions</h3></div></div></div><p>As we saw in the previous recipes, functions can be used like we use cmdlets. When we define parameters, they can be used along with the function, just like how we use parameters with cmdlets. Therefore, it is a convention to name the functions in the Verb-Noun format as well. This way, it is almost intuitive to use them, since we <span>are</span><a id="id325901987" class="indexterm"></a> used to cmdlets now. Also, when these functions are packed into a module and shared, they can, again, be used just like cmdlets.</p><p>It is natural for us to create functions in the conventional form—how we do it in other programming languages—however, naming the PowerShell functions the PowerShell way would make things easier for everyone who uses your functions. Also, after loading the modules, <code class="literal">Get-Command</code> would show the functions you packaged into your module. In that case, which would be easier to use in PowerShell in the context of <code class="literal">Get-Command</code>: the conventional <code class="literal">burgerDetails</code> or <code class="literal">Get-Burger</code>?</p></div></div>