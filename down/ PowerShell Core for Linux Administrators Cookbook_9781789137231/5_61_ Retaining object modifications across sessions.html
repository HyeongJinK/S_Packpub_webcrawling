<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch05lvl1sec66"></a>Retaining object modifications across sessions</h2></div></div><hr /></div><p>In the previous recipe, <span class="emphasis"><em>Understanding the extension of type data</em></span>, we used the <code class="literal">Update-TypeData</code> cmdlet to add members. However, we said that the update was valid as long as the session was. Now, there are two <span>ways</span><a id="id326261781" class="indexterm"></a> by which we could make the type data stick across sessions:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Using the PowerShell profile</li><li style="list-style-type: disc">Using an XML file</li></ul></div><p>The PowerShell profile is straightforward. However, usually, the type data extension and formatting rules are packaged as part of PowerShell modules, and adding code to the profile is not particularly helpful in that case. In this recipe, we will write a simple XML (<code class="literal">.ps1xml</code>) file that we will load so that we can extend the type data.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec183"></a>Getting ready</h3></div></div></div><p>Restart your PowerShell session so that the custom data type extension is discarded.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec184"></a>How to do it…</h3></div></div></div><p>We need an XML file. You can either use the <code class="literal">New-Item</code> cmdlet to create one, or simply use your favorite text editor. We will use Visual Studio Code for this recipe. Follow these steps to get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open your text editor and create a new empty file, and save it as <code class="literal">CustomTypes.ps1xml</code>.</li><li>Add the following content to the XML file. Ensure that you don't change the case:</li></ol></div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Types&gt;
&lt;Type&gt;
&lt;Name&gt;System.IO.FileInfo&lt;/Name&gt;
&lt;Members&gt;
&lt;AliasProperty&gt;
&lt;Name&gt;Modified&lt;/Name&gt;
&lt;ReferencedMemberName&gt;LastWriteTime&lt;/ReferencedMemberName&gt;
&lt;/AliasProperty&gt;
&lt;ScriptProperty&gt;
&lt;Name&gt;Age&lt;/Name&gt;
&lt;GetScriptBlock&gt;[math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays)&lt;/GetScriptBlock&gt;
&lt;/ScriptProperty&gt;
     &lt;NoteProperty&gt;
       &lt;Name&gt;ItemType&lt;/Name&gt;
       &lt;Value&gt;File&lt;/Value&gt;
     &lt;/NoteProperty&gt;
&lt;/Members&gt;
&lt;/Type&gt;
&lt;/Types&gt;</pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Save the file at a convenient location.</li><li>Back at the terminal (or the <strong class="userinput"><code>PowerShell Integrated Console</code></strong>), enter the following command to update the type data using the XML. Note the <code class="literal">PrependPath</code> parameter:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Update-TypeData -PrependPath ~/Documents/code/github/powershell/ch05/CustomTypes.ps1xml</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Now, list out all the files within any directory of your choice:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem . -File | Select-Object Name, Length, Age, Modified</strong></span></pre><p> </p><p>You should see the new properties that you created:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/2ec3f527-c758-45a3-9961-45283e5de22c.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip46"></a>Note</h3><p>It is advised that you never modify the PS1XML files in the <code class="literal">$PSHome</code> directory. They are digitally signed by Microsoft and could be replaced with new versions during upgrades or patches.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec185"></a>How it works…</h3></div></div></div><p>Custom types and formats are mostly used while creating <span>custom</span><a id="id325585865" class="indexterm"></a> modules. Rarely do administrators need to modify the types or formats for stock PowerShell modules. When you do need to modify custom types or formats, create a new PS1XML; do not modify the stock files, since they are digitally signed, and modifying them would break your setup.</p><p>Think of this PS1XML file as a regular XML file. Here is a simpler way of showing the structure. Remember that each type and each of the members within must have a name:</p><pre class="programlisting">Types
-- Type
---- Members
------ [The custom properties and methods you define]</pre><p>In essence, using the XML for type extension is not very different from how we performed type extension in the previous recipe, except this uses an XML file, which makes the setup more portable. When we work on creating our custom modules, we will look at packaging the types along with the modules, and, at that time, we will look in at how to work the paths in detail. For now, we load the XML by manually specifying the exact path to the file. If you would like to load these custom types for every session of yours, you can easily call the PS1XML file from your profile. The portability aspect here is that the XML can easily be shared or deployed; only the loading would be manual, or would be done through the profile—much simpler than adding cmdlets to profiles.</p><p>When updating the type data using cmdlets, we used the <code class="literal">Name</code> and <code class="literal">Value</code> parameters, along with the <code class="literal">MemberType</code> parameter. PowerShell understood the context and set up the types accordingly. In the case of XML, though, you must remember to use the correct tags for each of the member types. For instance, for <code class="literal">AliasProperty</code>, the tags within should be <code class="literal">Name</code> and <code class="literal">ReferencedMemberName</code> (as in the following code); for <code class="literal">ScriptProperty</code>, they should be <code class="literal">Name</code> and <code class="literal">GetScriptBlock</code>; for <code class="literal">NoteProperty</code>, the tags should be <code class="literal">Name</code> and <code class="literal">Value</code>:</p><pre class="programlisting">&lt;AliasProperty&gt;
&lt;Name&gt;Modified&lt;/Name&gt;
&lt;ReferencedMemberName&gt;LastWriteTime&lt;/ReferencedMemberName&gt;
&lt;/AliasProperty&gt;</pre><p>Also, remember not to enclose the entire script block in braces when placing the statement within the <code class="literal">GetScriptBlock</code> tag:</p><pre class="programlisting">&lt;GetScriptBlock&gt;
 [math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays)
&lt;/GetScriptBlock&gt;</pre><p>Do not do this:</p><pre class="programlisting">&lt;GetScriptBlock&gt;
 { [math]::Round(((Get-Date) - $this.LastWriteTime).TotalDays) }
&lt;/GetScriptBlock&gt;</pre><p>When loading the XML, we use the <code class="literal">PrependPath</code> parameter to load our XML before the built-in types are loaded. To load them after the built-in types, there is no need to use the <code class="literal">AppendPath</code> parameter, unless the <span>situation</span><a id="id325892250" class="indexterm"></a> really needs it, since <code class="literal">AppendPath</code> is the default. Why do the parameters matter? They determine the precedence of loading the types.</p><p>The XML file shown may look like having a large number of items. Use the indent guide in Visual Studio Code to guide you through reading the XML. The file, in reality, is very <span>simple</span><a id="id325892264" class="indexterm"></a> to read. Reading it will help you <span>understand</span><a id="id325892273" class="indexterm"></a> how the properties are defined.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl2sec186"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The Update-TypeData cmdlet (<a class="ulink" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/update-typedata?view=powershell-6" target="_blank">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/update-typedata?view=powershell-6</a>)</li><li style="list-style-type: disc">The <code class="literal">Types.ps1xml</code> file (<a class="ulink" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_types.ps1xml?view=powershell-6" target="_blank">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_types.ps1xml?view=powershell-6</a>)</li></ul></div></div></div>