<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec108"></a>Sending output to a file</h2></div></div><hr /></div><p>Reading content from files is one part of <span>using</span><a id="id325892156" class="indexterm"></a> files for administration; sending output to files is another. This recipe is intended to show you the options available to send output to files. In PowerShell, the process works through redirection. We will mainly look at the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <code class="literal">Out-File</code> cmdlet</li><li style="list-style-type: disc">The <code class="literal">Tee-Object</code> cmdlet</li><li style="list-style-type: disc">Redirection operators</li></ul></div><p> </p><p> </p><p>The scenario for this recipe is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Send the list of the contents of <code class="literal">~/random/dir-04</code> to a file called <code class="literal">~/random/file-list.txt</code>.</li><li>Try to list the contents of <code class="literal">~/random/dir-05</code>. This would throw an error (because there is no such directory as <code class="literal">~/random/dir-05</code>). This error must be sent to <code class="literal">~/random/error.txt</code>.</li><li>Use <code class="literal">Write-Host</code> to write a note that the list of contents of the directory, <code class="literal">~/random/dir-03</code>, is being appended to <code class="literal">~/random/file-list.txt</code>; this console message should go to <code class="literal">~/random/message.txt</code>.</li><li>Append the list of the contents of <code class="literal">~/random/dir-03</code> to <code class="literal">~/random/file-list.txt</code>, while also displaying the list on the console.</li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec283"></a>Getting ready…</h3></div></div></div><p>In order to go through this lab recipe, you need the lab set up. If you have not already done so, run the quick-and-dirty <code class="literal">Initialize-PacktPs6CoreLinuxLab.ps1</code> script, under the <code class="literal">ch04</code> directory, within the <a class="ulink" href="https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook" target="_blank">https://github.com/PacktPublishing/PowerShell-6.0-Linux-Administration-Cookbook</a> repository. Run the script to get the necessary files.</p><p>Next, use the input file that we created in the <span class="emphasis"><em>Understanding Here-Strings</em></span> recipe in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Working with Strings</em></span>, to create files within the lab directory. Change the value of <code class="literal">$LabPath</code> to point to your lab directory:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; $LabPath = "$HOME/random"</strong></span>
<span class="strong"><strong>PS&gt; Get-Content ./ch06/03-input-file.txt | ForEach-Object { New-Item -Path (Join-Path $LabPath -ChildPath $PSItem) -ItemType Directory -Force }</strong></span></pre><p>Go through the <span class="emphasis"><em>Understanding Here-Strings</em></span> recipe from <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Working with Strings</em></span>, to create the directories needed for this recipe.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec284"></a>How to do it…</h3></div></div></div><p>Here are the cmdlets we will use to accomplish these tasks:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The <code class="literal">Get-ChildItem</code> cmdlet to list out the contents, and <code class="literal">Out-File</code> across the pipeline (or the familiar redirection operator, <code class="literal">&gt;</code>; they both work in PowerShell) to send the list of contents to a file.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The <code class="literal">Get-ChildItem</code> cmdlet to list the contents, and the <code class="literal">Out-File</code> cmdlet across the pipeline to send the error to the file. Everything that is displayed on the console should go to the file this way, shouldn't it?</li><li>The <code class="literal">Write-Host</code> cmdlet to display content on the screen, and, as usual, the <code class="literal">Out-File</code> cmdlet or the redirection operator to send the message to the file.</li><li>Again, the <code class="literal">Get-ChildItem</code> cmdlet to list the contents, and the <code class="literal">Tee-Object</code> cmdlet with the <code class="literal">Append</code> switch parameter (or the familiar redirect-and-append operator, <code class="literal">&gt;&gt;</code>) to append the <span>file</span><a id="id326185252" class="indexterm"></a> with the new list along with showing the content on the screen.</li></ol></div><p>Proceed to write the script. This script has been saved as <code class="literal">ch10/02-Write-ContentOne.ps1</code> within the code repository that accompanies this book:</p><pre class="programlisting">Get-ChildItem $HOME/random/dir-04 &gt; $HOME/random/file-list.txt

Get-ChildItem $HOME/random/dir-05 &gt; $HOME/random/error.txt

Write-Host "Listing the contents of ~/random/dir-03 and appending the list to file-list.txt." &gt; $HOME/random/message.txt

Get-ChildItem $HOME/random/dir-03 | Tee-Object $HOME/random/file-list.txt -Append</pre><p>The files, <code class="literal">message.txt</code> and <code class="literal">error.txt</code>, are empty, and the message and the error have appeared on the console:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/ef804e06-f4ee-4a32-9037-1c5e96f6532b.png" /></div><p>Modify the script a little now. This script has been saved as <code class="literal">ch10/02-Write-ContentTwo.ps1</code> within the code repository that accompanies this book:</p><pre class="programlisting">Get-ChildItem $HOME/random/dir-04 &gt; $HOME/random/file-list.txt

Get-ChildItem $HOME/random/dir-05 2&gt;&amp;1 | Out-File $HOME/random/error.txt

Write-Host "Listing the contents of ~/random/dir-03 and appending the list to file-list.txt." 6&gt;&amp;1 | Out-File $HOME/random/message.txt

Get-ChildItem $HOME/random/dir-03 | Tee-Object $HOME/random/file-list.txt -Append</pre><p>If we read the files, <code class="literal">error.txt</code> and <code class="literal">message.txt</code>,  after <span>running</span><a id="id326225793" class="indexterm"></a> the modified script, you see the error and the message in the files:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/ea8b42c4-0905-4036-904d-893c68734a5d.png" /></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note63"></a>Note</h3><p>In order to avoid confusion, the last <code class="literal">&gt;</code> operator in <code class="literal">2&gt;&amp;1 &gt; $HOME/random/error.txt</code>  has been replaced by the pipeline and the <code class="literal">Out-File</code> cmdlet.</p></div><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec285"></a>How it works…</h3></div></div></div><p>First, a (rather long) note on streams. And this is very important.</p><p>There are six streams in PowerShell (Core, and Windows PowerShell 5.0+):</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Success stream</li><li>Error stream</li><li>Warning stream</li><li>Verbose stream</li><li>Debug stream</li><li>Information stream</li></ol></div><p>Think of them as separate parallel lines that never meet each other by themselves. PowerShell uses all of these six streams to send output. By default, the output destination of all of these streams is the host program, which, in our case, is the terminal emulator.</p><p>The success stream is where the actual output is sent to. Therefore, output from all the cmdlets and all success stories, is sent to the success stream. The pipeline, the redirection operator, and the redirect-and-append operator also work only on the Success stream. Streams 2 through 5 are self-explanatory: the errors go to the error stream, warnings go to the warning stream, and so on.</p><p><code class="literal">Write-Host</code> is used when a message is to be shown on the host. Until PowerShell 5.0, <code class="literal">Write-Host</code> did not write anything to any of the streams; it simply bypassed all streams and went straight to the host program. Therefore, <code class="literal">Write-Host</code> was a little too evasive and dirty. During PowerShell 5.0, the team decided to bring in something that would retain the capabilities of <code class="literal">Write-Host</code> for backward compatibility, but make <code class="literal">Write-Host</code> content go to a stream. Obviously, to prevent what those who understand PowerShell streams call polluting the stream, <code class="literal">Write-Host</code> content had to be kept separate from the five aforementioned streams. So, a new stream called the information stream was introduced, along with the <code class="literal">Write-Information</code> cmdlet and a few information-related functionalities. <code class="literal">Write-Host</code> was programmed to write content to the information stream. While it is still argued that the verbose stream should be used to communicate with the user during script execution, it is still nice to have the plain old kind of interaction with the user using <code class="literal">Write-Host</code>. Now let's look at how the recipe works.</p><p> </p><p>Initially, we pick the simple redirection operator or the <code class="literal">Out-File</code> cmdlet; both of them perform the same task: pass the content of the success stream to a file. The difference <span>between</span><a id="id326376652" class="indexterm"></a> the two, apart from the fact that the former is an operator and the latter is a cmdlet, is that, in the case of the operator, you can simply add the operator to the end of the command, add a space, and type in the path to the file. Therefore, if you use the operator, the syntax would be <code class="literal">command &gt; //path/to/file</code>, whereas, for <code class="literal">Out-File</code>, it would be <code class="literal">command | Out-File //path/to/file</code>.</p><p>The error and the host message were not part of the Success stream. Therefore, they did not get sent to the respective files initially, but instead got sent straight to the default output of all the streams: the host program.</p><p>The order of the stream names is as mentioned at the beginning of this section. The third redirection operator (after <code class="literal">&gt;</code> and <code class="literal">&gt;&gt;</code>) redirects data between streams, and the syntax is <code class="literal">SourceStreamNumber&gt;&amp;DestinationStreamNumber</code>. Therefore, to redirect the contents of the error stream to the success stream (so we can use the file redirection operator or the pipeline), we use <code class="literal">2&gt;&amp;1</code>. To redirect the contents of the Information stream to the Success stream, we use <code class="literal">6&gt;&amp;1</code>. When we use this redirection, you would notice that the error and the console message are not shown on the screen anymore, but instead go further in the path we specified (in our case, down the pipeline to <code class="literal">Out-File</code>).</p><p>Another point to note is that <code class="literal">Out-File</code>, by default, rewrites the specified file with the new content. In order to change that behavior and make the cmdlet append content to the existing content in the file, we use the <code class="literal">Append</code> switch parameter. </p><p>If you would like the contents of the Success stream passed on further through the pipeline along with being sent to a file or a variable, use the <code class="literal">Tee-Object</code> cmdlet; think of the letter T, if you are not already familiar with the <code class="literal">tee</code> command in Linux. If we do not add a pipeline after the <code class="literal">Tee-Object</code> cmdlet, the contents of the Success stream would be sent to the host, which is the default outlet, along with being sent to the specified file or variable. This is what happens at the last line of our script. The positional parameter at position 0 (the first, unnamed parameter) is <code class="literal">FilePath</code>, whose value is the output file. Like <code class="literal">Out-File</code>, the <code class="literal">Tee-Object</code> cmdlet also rewrites the contents of the file by default, unless overridden by <code class="literal">Append</code>.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec286"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Read more about redirection using the following command: <code class="literal">Get-Help about_Redirection</code>.</li></ul></div></div></div>