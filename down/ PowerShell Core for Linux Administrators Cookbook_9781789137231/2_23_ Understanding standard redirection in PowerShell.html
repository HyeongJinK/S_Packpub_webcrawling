<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch02lvl1sec31"></a>Understanding standard redirection in PowerShell</h2></div></div><hr /></div><p>During the process of learning to use Bash or sh, we learn to use the <span>redirection</span><a id="id325892138" class="indexterm"></a> operators, such as <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, and <code class="literal">&gt;&gt;</code>. PowerShell works on redirection as well. However, the implementation of redirection is different in PowerShell.</p><p>Redirection in <span>PowerShell</span><a id="id325669220" class="indexterm"></a> mainly relies on streams, which are covered in a different chapter. For this recipe, we stick with the default stream, which is <code class="literal">Success</code>. This recipe covers different, simple redirections to help with basic administration.</p><p> </p><p>Before we begin, let us understand that PowerShell is very different from Bash in terms of redirection, although it packs some minor similarities; similarities enough to make you not go away, but rather appreciate the flexibility of the object model and the uniformity of use.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec84"></a>How to do it…</h3></div></div></div><p>We shall perform four activities in this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Redirect output to a file</li><li>Append another output to the same file</li><li>Send the output of a command to the console as well as a file</li><li>Accept the input of one command into another</li></ol></div><p>Apart from the operators that we use in the first two activities, we will also look at the cmdlet equivalents to those operators:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>List out all of the processes running on your computer at the moment:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Process</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>The output was shown on the console. Now, let us redirect the contents into a file:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Process &gt; processes.txt</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>List out the contents of the file:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content ./processes.txt</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Let us now append the file with the date and timestamp:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Date &gt;&gt; ./processes.txt</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Read the contents of the file now:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content ./processes.txt</strong></span></pre><p>You can see that the file now contains a list of all of the processes running in the system, as well as the timestamp. The timestamp got appended to the file.</p><p> </p><p>In PowerShell, the same results can be accomplished using the <code class="literal">Out-File</code> cmdlet. (<code class="literal">Out-File</code> has more features, such as setting the encoding and new line control.) Let us accomplish the same tasks using the <code class="literal">Out-File</code> cmdlet. You may want to delete <code class="literal">processes.txt</code> before proceeding:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>List out the currently-running processes again and send the output to a file using <code class="literal">Out-File</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Process | Out-File processes.txt</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Append the timestamp to the file:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Date | Out-File processes.txt -Append</strong></span></pre><p>If you notice, the output of <code class="literal">Get-Process</code> and <code class="literal">Get-Date</code> went directly to the file; nothing got displayed on the host.</p><p>If we want to display the output on the console as well as send the content to a file, we simply use <code class="literal">Tee-Object</code> instead of <code class="literal">Out-File</code>. If you would like, delete the file, <code class="literal">processes.txt</code>, again:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Run the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Process | Tee-Object ./processes.txt</strong></span></pre><p>The list of running processes should be shown at the Terminal.</p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Check the contents of the file, <code class="literal">processes.txt</code>:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS /home/ram&gt; Get-Content ./processes.txt</strong></span></pre><p>As you can see, the list of processes appears in the text file as well.</p><p>Let us now proceed with learning to make cmdlets accept input from files. Linux administrators are used to making commands accept input from a file, like so:</p><pre class="programlisting"><span class="strong"><strong>$ command &lt; input_file.txt</strong></span></pre><p>The command accepts input from <code class="literal">input_file.txt</code> and performs operations on the input content.</p><p>In PowerShell, this is handled using <code class="literal">Get-Content</code> and the pipe (<code class="literal">|</code>). The PowerShell equivalent of a command accepting input from a file would be as follows:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content input_file.txt | command</strong></span></pre><p> </p><p>This might seem the other way around to most of those who are not used to PowerShell. Let us break down the process into pieces and try to understand it better. For instance, let us say you have a list of files in a text file called <code class="literal">input.txt</code>:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Reveal the contents of the text file:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content input.txt</strong></span></pre><p>The contents of <code class="literal">input.txt</code> are as follows:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/c102a6d4-f47b-4019-80a8-c46532b97bc0.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>List out the contents of the current directory:</li></ol></div><pre class="programlisting"><span class="strong"><strong>$ ls</strong></span></pre><p>We have five test files in the current directory, four of which are in the list (the input file). Let us say that you would like to delete the files listed in the input file, from the directory.</p><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Pass the output of <code class="literal">Get-Content</code> to the command, <code class="literal">Remove-Item</code>, through the pipe:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content input.txt | Remove-Item</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/8e7b5b45-759b-4f9b-93c9-bc47cc51f386.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>List out the files currently present in the directory:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem</strong></span></pre><p>If you compare the output of <code class="literal">ls</code> (before) and <code class="literal">Get-ChildItem</code> (after), the files that were <span>listed</span><a id="id326261756" class="indexterm"></a> in the text file are no more.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec85"></a>How it works…</h3></div></div></div><p>In this recipe, we set out to understand the similarities between Bash and PowerShell. In spite of being fundamentally different from Bash, PowerShell does have some similarities to Bash. Two of the similarities, as we saw, are passing content to files and appending content to the files.</p><p>We looked at three cmdlets in this recipe, one of which was used twice.</p><p> </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec5"></a>Out-File</h4></div></div></div><p>Those comfortable with <span>Bash</span><a id="id326261788" class="indexterm"></a> use the <code class="literal">&gt;</code> for sending the output to a file, and <code class="literal">&gt;&gt;</code> to append the output to an existing file. In PowerShell, we use the <code class="literal">Out-File</code> cmdlet. We run a command that sends output to the standard output and, through the pipe, redirects the output to <code class="literal">Out-File</code>, which handles writing the output to a file. Usually, <code class="literal">Out-File</code> is used to send content to a text file.</p><p>When there is a need to append the content to a file, we use the <code class="literal">-Append</code> switch with <code class="literal">Out-File</code>. This way, if the file that is being written to already contains content, the content isn't overwritten (overwriting content is the default behavior of <code class="literal">Out-File</code>).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec6"></a>Tee-Object</h4></div></div></div><p>There are situations where you need to <span>send</span><a id="id326262247" class="indexterm"></a> content to a file, as well as display the content on the console. This is handled using a simple call of <code class="literal">Tee-Object</code>. <code class="literal">Tee-Object</code> works like the letter T; apart from sending content to a file or a variable, it also sends the content down the pipeline. If <code class="literal">Tee-Object</code> is the last cmdlet in the statement, the pipeline output is sent out to standard output, which in most cases is the host (or in other words, the console by default).</p><p>In our recipe, we sent the first output to the file, <code class="literal">processes.txt</code>, and the second output was not sent down the pipeline. Therefore, <code class="literal">Tee-Object</code> picked the standard output.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec7"></a>Accepting input from a file</h4></div></div></div><p>This process is significantly different in PowerShell, compared to Bash. In Bash, we call the command first, and then ask it to accept input from a file. In PowerShell, we make PowerShell read the contents of the input file first and then <span>send</span><a id="id326262392" class="indexterm"></a> the output to the command that accepts input through the pipeline.</p><p>In our recipe, we read the contents of the file, <code class="literal">input.txt</code>, which contained a list of four filenames. We used <code class="literal">Get-Content</code> to read the content from the file. <code class="literal">Get-Content</code> sent the output to the standard output at first, thereby showing us the contents of the file. We then added a pipe to tell PowerShell that we need further processing, and then added <code class="literal">Remove-Item</code> to the command chain. (<code class="literal">Remove-Item</code> deletes items, which could be directories, files, or links.)</p><p> </p><p>As we will see later in this chapter, the first parameter (positional parameter, position 1) of <code class="literal">Remove-Item</code> is <code class="literal">Path</code>, which is also the parameter that accepts input through the pipeline. For more information, run the following command and read about the <code class="literal">Path</code> parameter of <code class="literal">Remove-Item</code>:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Remove-Item -Parameter Path</strong></span></pre><div class="mediaobject"><img src="/graphics/9781789137231/graphics/26207a4a-87ff-496b-af00-6f1238cfb0fd.png" /></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec86"></a>There's more…</h3></div></div></div><p>Clean up the contents that we created for this recipe if you are the type that likes directories clean! If we need more files or directories in later recipes, we will create them as needed.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec87"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Understanding cmdlets and parameters</em></span> recipe</li></ul></div></div></div>