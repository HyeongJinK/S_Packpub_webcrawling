<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch07lvl1sec86"></a>Cleaning empty directories using the Do–While construct</h2></div></div><hr /></div><p>In the previous recipe, we found the second Sunday of May using the year as input. We used a <code class="literal">While</code> loop for that. The <code class="literal">While</code> loop checks the condition before even <span>starting</span><a id="id325877498" class="indexterm"></a> the iteration. If the condition returns <code class="literal">$false</code> at the very beginning, the loop would not even begin, for instance, if you input the year as <code class="literal">2016</code>.</p><p><code class="literal">Do–While</code> is a little different; the loop is executed once, regardless of whether the condition is true or not. The condition is checked only after the first iteration.</p><p>The scenario for this recipe is that we want to delete all empty directories within a certain directory.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec227"></a>Getting ready</h3></div></div></div><p>To work with this recipe, let's create a few empty directories within <code class="literal">$HOME/random</code>. Use the input file that is part of the Git repository of this book to create the directories:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Content ./ch07/08-input-file.txt | ForEach-Object { New-Item $($PSItem -replace '\.', "$HOME/random") -ItemType Directory</strong></span> }</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec228"></a>How to do it…</h3></div></div></div><p>If you run the following recipe within the <code class="literal">random</code> lab directory, all of its empty subdirectories will be deleted. Follow these steps to get started:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Open a new file and paste the following content into it:</li></ol></div><pre class="programlisting">do {
    $AllDirectories = (Get-ChildItem -Path $HOME/random -Recurse -Directory).FullName
    $EmptyDirectories = $AllDirectories | Where-Object {(Get-ChildItem $PSItem).Count -eq 0}
    $EmptyDirectories | Remove-Item
} while ($EmptyDirectories.Count -gt 0)</pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Let's add some logging to it so that we know what's happening:</li></ol></div><pre class="programlisting">$Iteration = 0
do {
    $AllDirectories = (Get-ChildItem -Path $HOME/random -Recurse -Directory).FullName
    $EmptyDirectories = $AllDirectories | Where-Object {(Get-ChildItem $PSItem).Count -eq 0}
    $EmptyDirectories | Remove-Item

    Write-Output "Iteration $Iteration. Removed the following $($EmptyDirectories.Count) directories."
    $EmptyDirectories
    $Iteration++
} while ($EmptyDirectories.Count -gt 0)</pre><p> </p><p>Note how there was an empty iteration, 5. This <span>shows</span><a id="id325892266" class="indexterm"></a> the nature of a <code class="literal">Do–While</code> loop:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/6c470d94-863e-46a1-8216-27285b745579.png" /></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec229"></a>How it works…</h3></div></div></div><p>The execution is similar to the <code class="literal">While</code> construct, however, as shown by <code class="literal">Iteration 0</code>, the <code class="literal">Do–While</code> construct executes the script block once without checking the condition. In our case, we queried the empty directories within the loop. If we had placed this query outside of the loop, we would have had to place it within as well, for loop control. This is inefficient programming.</p><p>PowerShell found nine empty directories during the <span>execution</span><a id="id325898619" class="indexterm"></a> of the script block. When the condition check happened after the execution, <code class="literal">9</code> was evaluated to be greater than <code class="literal">0</code>. The loop ran again. This time, the value of <code class="literal">$EmptyDirectories.Count</code> was evaluated to be <code class="literal">4</code>. The loop ran again, and this time again, the value was <code class="literal">4</code>, which is greater than <code class="literal">0</code>; the condition was still <code class="literal">$true</code>. During the next run, <code class="literal">$EmptyDirectories.Count</code> was evaluated to be <code class="literal">2</code>, then <code class="literal">1</code>, and then, during the last run, <code class="literal">0</code>. This time, the outcome of the condition became <code class="literal">$false</code>, and the loop exited. Essentially, the loop statement was: Go on while the count is more than zero.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl2sec230"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Taking actions on the returned objects </em></span>recipe in <a class="link" href="#" linkend="ch04">Chapter 4</a>, <span class="emphasis"><em>Passing Data through the Pipeline</em></span></li></ul></div></div></div>