<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch01lvl1sec22"></a>Working with aliases</h2></div></div><hr /></div><p>An alias, as the meaning goes, is an alternative name for cmdlet. They serve <span>two</span><a id="id325901986" class="indexterm"></a> purposes:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">To reduce the number of keystrokes</li><li style="list-style-type: disc">To make the transition to PowerShell smoother</li></ul></div><p>Traditionally, aliases were created in PowerShell so that Windows and Linux administrators did not find the new framework intimidating to work with. Regardless, aliases are best used only on the command line, and not in scripts, because some aliases are not aliases in Linux, and, in general, aliases affect readability. (For instance, it would take conscious effort to realize that <code class="literal">gbp</code> stands for <code class="literal">Get-PSBreakPoint</code>.)</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec52"></a>How to do it…</h3></div></div></div><p>As we have already mentioned, it is simple to think in PowerShell. When we know that the verb to fetch any information locally is <code class="literal">Get</code>, and the noun in this case would be <code class="literal">Alias</code>, the cmdlet should be <code class="literal">Get-Alias</code> :</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Run <code class="literal">Get-Help</code> to understand how to use the cmdlet:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help Get-Alias</strong></span></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip19"></a>Note</h3><p>If you're unsure about any command, or you would like to reduce keystrokes without involving aliases, use tab-completion. Write a part of the cmdlet or parameter and press the <span class="emphasis"><em>Tab</em></span> key. PowerShell will complete the command for you, or show you suggestions, based on which platform you're doing this on.</p></div><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>According to the help documentation, all of the parameters for <code class="literal">Get-Alias</code> are optional (they are all enclosed in <code class="literal">[]</code>). Therefore, simply running <code class="literal">Get-Alias</code> will give us a list of all of the aliases that are available in the current instance of PowerShell:</li></ol></div><div class="mediaobject"><img src="/graphics/9781789137231/graphics/23301887-96c6-4715-b2a7-58e60a1627c4.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now, let's try to resolve the <code class="literal">gbp</code> alias to the PowerShell cmdlet that it actually runs in:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Alias gbp</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Now, do the opposite: get the alias for a certain cmdlet. The <code class="literal">Definition</code> in the second parameter set of the help documentation should be used. The output shows the actual PowerShell cmdlet that runs when an alias is called:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS /home/ram&gt; Get-Alias -Definition Get-ChildItem</strong></span></pre><p> </p><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>We can see <span>two</span><a id="id326267096" class="indexterm"></a> aliases as output, both of which run <code class="literal">Get-ChildItem</code> under the hood. Now, let's run <code class="literal">dir</code> as well as <code class="literal">Get-ChildItem</code> and compare their outputs:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; dir</strong></span></pre><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>The two outputs are identical. Now, let's look at what type of object the commands return:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; /home/ram&gt; dir | Get-Member</strong></span></pre><pre class="programlisting"><span class="strong"><strong>PS&gt; /home/ram&gt; Get-ChildItem | Get-Member</strong></span></pre><p>They returned the same object as well.</p><p>Now, let's create an alias:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>First, identify a word that you'd like to use as the alias. For example, let's consider <code class="literal">listdir</code>.</li><li>Run <code class="literal">listdir</code> on PowerShell to ensure that such a cmdlet (or a Linux command) does not already exist.</li><li>List out the cmdlets that deal with aliases by running the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Command *alias</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li><code class="literal">New-Alias</code> is the cmdlet we are looking for, since it creates a new alias.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip20"></a>Note</h3><p>In PowerShell, the <code class="literal">Set</code> verb is used to modify something. Therefore, <code class="literal">Set-Alias</code> is used to modify an alias that already exists.</p></div><div class="orderedlist"><ol class="orderedlist arabic" start="5" type="1"><li>Read the help documentation for <code class="literal">New-Alias</code> by running the following command:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Help New-Alias</strong></span></pre><p>The help document indicates that only the <code class="literal">Name</code> and the <code class="literal">Value</code> parameters are mandatory. We will only use these two to create this simple alias.</p><div class="orderedlist"><ol class="orderedlist arabic" start="6" type="1"><li>Run the following command to create the custom alias:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; New-Alias listdir Get-ChildItem</strong></span></pre><p> </p><div class="orderedlist"><ol class="orderedlist arabic" start="7" type="1"><li>Check whether the alias was created as desired or not:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Alias listdir</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="8" type="1"><li>Next, run the alias to see what output it gives:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS /home/ram&gt; listdir</strong></span></pre><p>That is the output that we are familiar with—the output of <code class="literal">Get-ChildItem</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note21"></a>Note</h3><p>Aliases are ephemeral by default. They exist only as long as your PowerShell session exists. To use custom aliases without having to recreate them each time, export these aliases (the instructions for which are in the next recipe) and import them using your PowerShell profile. We will look at profiles in <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Preparing for Administration using PowerShell</em></span>.</p></div><p>Since aliases are ephemeral, let's export the alias we created. The output of <code class="literal">Get-Command</code> a few steps ago showed <code class="literal">Export-Alias</code>. <code class="literal">Get-Help</code> for the cmdlet shows that there are <span>two</span><a id="id326268232" class="indexterm"></a> ways to export the aliases: as a comma-separated values file, and as a script.</p><p>Export the aliases as a CSV file:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Export-Alias aliases.csv</strong></span></pre><p>Export the aliases as a script as well:</p><pre class="programlisting"><span class="strong"><strong>PS&gt; Export-Alias aliases.ps1 -As Script</strong></span></pre><p>View the contents of both files either using <code class="literal">cat</code> or <code class="literal">Get-Content</code>.</p><p>Optionally, edit the file to remove all of the aliases except the ones you created. The custom aliases can be found at the bottom of the list.</p><p>Next, import the aliases into your PowerShell session:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Restart PowerShell.</li><li>Check if the <code class="literal">listdir</code> alias that you created exists:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-Alias listdir</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now, import either of the alias exports:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Import-Alias ./aliases.csv</strong></span>
<span class="strong"><strong>PS&gt; # Or, simply call the script, ./aliases.ps1</strong></span></pre><p></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip22"></a>Note</h3><p>If you did not remove the pre-existing aliases, you may receive several errors, each saying that the new alias could not be created. There are two ways to handle this: the first way is to remove the default aliases from the export file (which is recommended), and the second way is to use the <code class="literal">-Force</code> parameter (this may still result in errors, but there would be significantly fewer).</p></div><p>If you would like to add these aliases to your session, follow the <span class="emphasis"><em>Enabling automated execution of commands for each load</em></span> recipe in  <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Preparing for Administration Using PowerShell</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec53"></a>How it works…</h3></div></div></div><p>Aliases are nothing but mappings that are done within PowerShell. The short words are mapped to PowerShell cmdlets; the cmdlets are recorded as <code class="literal">Definition</code> in each of the aliases. Aliases also support the same parameters as the cmdlet as well, since aliases are merely pointers to the right cmdlet. When you run anything on PowerShell, PowerShell checks its list of cmdlets and aliases (among other definitions) to understand what you are asking for. When PowerShell encounters an alias, it looks for which cmdlet it points to, and runs the cmdlet.</p><p>Using <code class="literal">New-Alias</code>, you can create a pointer with a custom name that points to the desired PowerShell cmdlet. When the custom cmdlets are exported as a script, the contents show <code class="literal">New-Alias</code> for each of the aliases available in the session.</p><p>Exporting aliases as CSV makes it easier to extend within a text editor if needed. The <code class="literal">Import-Alias</code> cmdlet understands that the first column in the CSV is the name of the alias, and that the second is its definition.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec54"></a>There's more…</h3></div></div></div><p>Add more content to your aliases, such as descriptions. Refer to the <span>help</span><a id="id326501786" class="indexterm"></a> documentation for <code class="literal">Get-Alias</code> to see what more you can do with aliases.
If you have a Windows computer, try running <code class="literal">Get-Alias</code> against Linux commands such as <code class="literal">ls</code>.</p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec55"></a>See also</h3></div></div></div><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>The <span class="emphasis"><em>Understanding cmdlets and parameters</em></span> recipe from <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Preparing for Administration Using PowerShell</em></span></li><li>The <span class="emphasis"><em>Enabling automated execution of commands for each load</em></span> recipe from <a class="link" href="#" linkend="ch02">Chapter 2</a>, <span class="emphasis"><em>Preparing for Administration Using PowerShell</em></span></li></ol></div></div></div>