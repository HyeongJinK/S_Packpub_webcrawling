<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch04lvl1sec57"></a>Taking actions on the returned objects</h2></div></div><hr /></div><p>We have been using the pipeline throughout this chapter to perform <span>various</span><a id="id325906000" class="indexterm"></a> activities on objects. We have been passing objects from one cmdlet to another and, in fact, taking actions on the objects being returned. This recipe, in the technical sense, is nothing new. However, to get ourselves more comfortable using the pipeline, and to show you that the pipeline is not just used for selection, filtration, and sorting, we will use the pipeline to also perform some deletions.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec158"></a>Getting ready</h3></div></div></div><p>If you do not have files within the demo directory that we created, please go ahead and create some files. Make sure that some of the files have some content in them.</p><p>Let us say that you have been given a requirement. There is a certain team that would like the top two largest files of each type to be deleted from a directory. If there is only one file of a certain type, that file has to be left alone.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec159"></a>How to do it…</h3></div></div></div><p>Here is an outline of the steps you will want to take:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Get all of the files at the path specified</li><li>Group all of the files by file type (extension)</li><li>Filter out those groups that contain more than one item</li><li>Expand each group, and sort the files by size (length)</li><li>Pick the two largest files in each group</li><li>Delete the files</li></ol></div><p>While we are working on a sandbox directory, and since we are taking precautions so that we don't delete anything important, it is still better to only prototype the action using <code class="literal">ShouldPerform</code> (the <code class="literal">WhatIf</code> parameter). This way, the files won't actually be deleted, and PowerShell will only tell you what it would do if the command is run.</p><p> </p><p>Let's get cracking:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>List the contents of the current directory and group the output based on the extension:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="2" type="1"><li>Filter to discard the lone files of each extension:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension | Where-Object Count -GT 1</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Now comes a loop construct. We will look at how this works in a future chapter. For now, just know that it works. The goal here is to only leverage the pipeline:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension | Where-Object Count -GT 1 | ForEach-Object {$_.Group | Sort-Object Length -Bottom 2}</strong></span></pre><p>Here is the output of the preceding command:</p><div class="mediaobject"><img src="/graphics/9781789137231/graphics/e1cb0196-2c9e-4a70-8c9b-3693e34c73ba.png" /></div><div class="orderedlist"><ol class="orderedlist arabic" start="4" type="1"><li>Delete these files using the <code class="literal">Remove-Item</code> cmdlet. Use the <code class="literal">WhatIf</code> switch if you do not want the files to be actually deleted:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; Get-ChildItem -Path . -File | Group-Object -Property Extension | Where-Object Count -GT 1 | ForEach-Object {$_.Group | Sort-Object Length -Bottom 2} | Remove-Item -WhatIf</strong></span></pre><p> </p><p> </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec160"></a>How it works…</h3></div></div></div><p>When any cmdlet reads an object through the pipeline, it reads the entire contents of the object. Any cmdlet that is designed to accept input through the pipeline picks the right property from the object, and then takes actions on the objects. In the case of this recipe, it was the <code class="literal">Path</code> property that was picked in order to <span>identify</span><a id="id325892295" class="indexterm"></a> the files to delete.</p><p>To know if a certain cmdlet accepts input from the pipeline, run <code class="literal">Get-Help</code> on the cmdlet with the <code class="literal">Full</code> parameter, and see if the value for <code class="literal">Accept pipeline input?</code> is <code class="literal">true</code>. The <code class="literal">InputObject</code> parameter of <code class="literal">Where-Object</code> and the <code class="literal">Path</code> parameter of <code class="literal">Move-Item</code> are a couple of examples.</p></div></div>