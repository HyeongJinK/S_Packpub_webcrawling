<div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec107"></a>Reading content from a file</h2></div></div><hr /></div><p>One of the most basic <span>operations</span><a id="id326456022" class="indexterm"></a> of the file is reading content from a file. So far, we have been reading content from file as a block of text. The PowerShell cmdlet for this operation is <code class="literal">Get-Content</code>. And it works a little different than expected. This recipe is aimed at explaining how different it is.</p><p>The task for this recipe is simple. You must display details of the file on the screen, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Show the details of a file</li><li>Read the first seven lines from the file</li><li>Read the last five lines of the file</li><li>Read content from the 11<sup>th</sup> to the 13<sup>th</sup> line of the file</li><li>Display the number of characters, words, and lines in the file</li><li>Import the contents of the file into a variable</li></ol></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec280"></a>How to do it…</h3></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic" type="1"><li>Create a dummy file at <code class="literal">~/random</code>. This script uses the code repository of the book as the location.</li><li>If you would like, create the file yourself using the following script block:</li></ol></div><pre class="programlisting"><span class="strong"><strong>PS&gt; for ($j = 0; $j -lt 100; $j++) { $($i = 0; while ($i -lt 8) { (-join ((65..90) + (97..122) | Get-Random -Count 8 | ForEach-Object { [char]$_ })).ToString(); $i++ }) -join ' ' | Out-File ./ch10/01-random-text.txt -Append }</strong></span></pre><div class="orderedlist"><ol class="orderedlist arabic" start="3" type="1"><li>Next, use the following script to get the necessary details:</li></ol></div><pre class="programlisting">Write-Host "File details:"

Get-Item ./ch10/01-random-text.txt

"Here are the first seven lines from the file."

Get-Content ./ch10/01-random-text.txt -ReadCount 7 | Select-Object -First 1

"Here are the last five lines from the file."

Get-Content ./ch10/01-random-text.txt -Tail 5

"Here are the eleventh to the thirteenth lines."

Get-Content ./ch10/01-random-text.txt | Select-Object -First 3 -Skip 10

"And here are some details about the content in the file."

Get-Content ./ch10/01-random-text.txt | Measure-Object -Character -Word -Line

"Finally, the content will be imported into a variable. Let us see if the content is a single block of text or not."

$Content = Get-Content ./ch10/01-random-text.txt

"There are $($Content.Count) elements in the variable."
"When read as raw content, the number of elements is $((Get-Content ./ch10/01-random-text.txt -Raw).Count)"</pre><p>Take the time to read the output.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip62"></a>Note</h3><p><code class="literal">Get-Content</code> with the <code class="literal">-Tail</code> parameter finds its primary use in reading log files. If you would like to follow along as the file is updated, use the <code class="literal">-Wait</code> switch parameter as well. This will update the output as content is added to the file in question. Like so: <code class="literal">Get-Content ./ch10/01-random-text.txt -Tail 5 -Wait</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec281"></a>How it works…</h3></div></div></div><p>The first task is relatively simple. It shows you the details about the file. Think of this as peeking into the file properties. If you would like more details, pipe the first line of the command to <code class="literal">Select-Object *</code>.</p><p>The second line is very important. The <code class="literal">ReadCount</code> parameter instructs <code class="literal">Get-Content</code> to read <span class="emphasis"><em>n</em></span> lines in a shot, and pass it along the pipeline. In our case, note how we have used <code class="literal">-ReadCount 7 | Select-Object -First 1</code> to read the first seven lines. In this case, <code class="literal">Get-Content</code> read the first seven lines of the file as a single block.</p><p>To read the last five lines of the file, we use the <code class="literal">Tail</code> parameter. However, in this case, the number of elements (lines) is retained; the imported content is an array of five strings, not a single block containing five lines. More on this in just a moment.</p><p> </p><p>To get the 11<sup>th</sup> to the 13<sup>th</sup> lines, we skip the first 10 lines, and pick only three lines. Simple enough.</p><p>Since the output object is a string, the <code class="literal">Measure-Object</code> cmdlet supports characters, words (groups of characters separated by spaces), and lines. The output says that we have 100 lines in the script, so many characters, and so many words.</p><p>The 100 lines is consistent with the number of <span>elements</span><a id="id325905966" class="indexterm"></a> present in <code class="literal">$Content</code>. This means that <code class="literal">Get-Content</code> imported the text as an array of 100 elements, the elements separated by a newline character in the file. This is an important point to note, because we are used to file content being read as a single block, with the newline characters preserved. PowerShell handles reading text from a file as an array of strings.</p><p>Using the <code class="literal">Raw</code> switch, however, changes this behavior. In this case, PowerShell imports the text as you would expect, in a single block, with the newline characters retained.</p><p>Getting content as an array of strings is primarily useful when we use a simple text file as an input file. Imagine you want to get some details about a certain 100 servers. You could simply place all the names in a file and make PowerShell import the names as separate names, thereby allowing you to use looping constructs such as <code class="literal">foreach</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec282"></a>See also</h3></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">The <span class="emphasis"><em>Replacing substrings within strings</em></span> recipe in <a class="link" href="#" linkend="ch06">Chapter 6</a>, <span class="emphasis"><em>Working with Strings</em></span> </li></ul></div></div></div>